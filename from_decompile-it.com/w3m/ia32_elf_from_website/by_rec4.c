// Generated by Rec Studio 4 - build Sep 23 2015

_init()
{// addr = 0x08049BFC
    _unknown_ __ebx;                       // r1
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    if( *((intOrPtr*)(_t4 + 570348 - 4)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    _t3 = __do_global_ctors_aux();
    _pop(__eax);
    return _t3;
}

L08049C08()
{
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    _pop(__ebx);
    if( *((intOrPtr*)(_t4 + 570348 - 4)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    _t3 = __do_global_ctors_aux();
    _pop(__eax);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return _t3;
}

fileno()
{// addr = 0x08049C3C
    goto __imp__fileno;
}

fputs()
{// addr = 0x08049C4C
    goto __imp__fputs;
}

abort()
{// addr = 0x08049C5C
    goto __imp__abort;
}

__errno_location()
{// addr = 0x08049C6C
    goto __imp____errno_location;
}

sigemptyset()
{// addr = 0x08049C7C
    goto __imp__sigemptyset;
}

inet_ntop()
{// addr = 0x08049C8C
    goto __imp__inet_ntop;
}

sprintf()
{// addr = 0x08049C9C
    goto __imp__sprintf;
}

popen()
{// addr = 0x08049CAC
    goto __imp__popen;
}

open()
{// addr = 0x08049CBC
    goto __imp__open;
}

connect()
{// addr = 0x08049CCC
    goto __imp__connect;
}

getpid()
{// addr = 0x08049CDC
    goto __imp__getpid;
}

mkdir()
{// addr = 0x08049CEC
    goto __imp__mkdir;
}

srand48()
{// addr = 0x08049CFC
    goto __imp__srand48;
}

strerror()
{// addr = 0x08049D0C
    goto __imp__strerror;
}

getsockname()
{// addr = 0x08049D1C
    goto __imp__getsockname;
}

memcmp()
{// addr = 0x08049D2C
    goto __imp__memcmp;
}

qsort()
{// addr = 0x08049D3C
    goto __imp__qsort;
}

inet_ntoa()
{// addr = 0x08049D4C
    goto __imp__inet_ntoa;
}

freeaddrinfo()
{// addr = 0x08049D5C
    goto __imp__freeaddrinfo;
}

bsearch()
{// addr = 0x08049D6C
    goto __imp__bsearch;
}

tgetflag()
{// addr = 0x08049D7C
    goto __imp__tgetflag;
}

__xstat()
{// addr = 0x08049D8C
    goto __imp____xstat;
}

__gmon_start__()
{// addr = 0x08049D9C
    goto __imp____gmon_start__;
}

__lxstat()
{// addr = 0x08049DAC
    goto __imp____lxstat;
}

__isoc99_sscanf()
{// addr = 0x08049DBC
    goto __imp____isoc99_sscanf;
}

vsprintf()
{// addr = 0x08049DCC
    goto __imp__vsprintf;
}

localtime()
{// addr = 0x08049DDC
    goto __imp__localtime;
}

getpass()
{// addr = 0x08049DEC
    goto __imp__getpass;
}

strchr()
{// addr = 0x08049DFC
    goto __imp__strchr;
}

getenv()
{// addr = 0x08049E0C
    goto __imp__getenv;
}

system()
{// addr = 0x08049E1C
    goto __imp__system;
}

strncpy()
{// addr = 0x08049E2C
    goto __imp__strncpy;
}

putchar()
{// addr = 0x08049E3C
    goto __imp__putchar;
}

ttyname()
{// addr = 0x08049E4C
    goto __imp__ttyname;
}

write()
{// addr = 0x08049E5C
    goto __imp__write;
}

GC_realloc()
{// addr = 0x08049E6C
    goto __imp__GC_realloc;
}

rename()
{// addr = 0x08049E7C
    goto __imp__rename;
}

memset()
{// addr = 0x08049E8C
    goto __imp__memset;
}

__libc_start_main()
{// addr = 0x08049E9C
    goto __imp____libc_start_main;
}

execl()
{// addr = 0x08049EAC
    goto __imp__execl;
}

_IO_getc()
{// addr = 0x08049EBC
    goto __imp___IO_getc;
}

floor()
{// addr = 0x08049ECC
    goto __imp__floor;
}

tcgetattr()
{// addr = 0x08049EEC
    goto __imp__tcgetattr;
}

chmod()
{// addr = 0x08049EFC
    goto __imp__chmod;
}

GC_set_warn_proc()
{// addr = 0x08049F0C
    goto __imp__GC_set_warn_proc;
}

bindtextdomain()
{// addr = 0x08049F1C
    goto __imp__bindtextdomain;
}

GC_malloc()
{// addr = 0x08049F2C
    goto __imp__GC_malloc;
}

read()
{// addr = 0x08049F3C
    goto __imp__read;
}

strtoll()
{// addr = 0x08049F4C
    goto __imp__strtoll;
}

gettext()
{// addr = 0x08049F5C
    goto __imp__gettext;
}

ungetc()
{// addr = 0x08049F6C
    goto __imp__ungetc;
}

readdir()
{// addr = 0x08049F7C
    goto __imp__readdir;
}

strtol()
{// addr = 0x08049F8C
    goto __imp__strtol;
}

fdopen()
{// addr = 0x08049F9C
    goto __imp__fdopen;
}

siglongjmp()
{// addr = 0x08049FAC
    goto __imp__siglongjmp;
}

tgetent()
{// addr = 0x08049FBC
    goto __imp__tgetent;
}

sigaction()
{// addr = 0x08049FCC
    goto __imp__sigaction;
}

fflush()
{// addr = 0x08049FDC
    goto __imp__fflush;
}

sqrt()
{// addr = 0x08049FEC
    goto __imp__sqrt;
}

opendir()
{// addr = 0x08049FFC
    goto __imp__opendir;
}

symlink()
{// addr = 0x0804A00C
    goto __imp__symlink;
}

ioctl()
{// addr = 0x0804A01C
    goto __imp__ioctl;
}

socket()
{// addr = 0x0804A02C
    goto __imp__socket;
}

dup2()
{// addr = 0x0804A03C
    goto __imp__dup2;
}

fseek()
{// addr = 0x0804A04C
    goto __imp__fseek;
}

execlp()
{// addr = 0x0804A05C
    goto __imp__execlp;
}

isatty()
{// addr = 0x0804A06C
    goto __imp__isatty;
}

getaddrinfo()
{// addr = 0x0804A07C
    goto __imp__getaddrinfo;
}

fclose()
{// addr = 0x0804A08C
    goto __imp__fclose;
}

bcopy()
{// addr = 0x0804A09C
    goto __imp__bcopy;
}

dup()
{// addr = 0x0804A0AC
    goto __imp__dup;
}

mktime()
{// addr = 0x0804A0BC
    goto __imp__mktime;
}

memcpy()
{// addr = 0x0804A0CC
    goto __imp__memcpy;
}

utime()
{// addr = 0x0804A0DC
    goto __imp__utime;
}

strlen()
{// addr = 0x0804A0EC
    goto __imp__strlen;
}

fopen()
{// addr = 0x0804A0FC
    goto __imp__fopen;
}

alarm()
{// addr = 0x0804A10C
    goto __imp__alarm;
}

unlink()
{// addr = 0x0804A11C
    goto __imp__unlink;
}

getpwuid()
{// addr = 0x0804A12C
    goto __imp__getpwuid;
}

freopen()
{// addr = 0x0804A13C
    goto __imp__freopen;
}

setlocale()
{// addr = 0x0804A14C
    goto __imp__setlocale;
}

waitpid()
{// addr = 0x0804A15C
    goto __imp__waitpid;
}

fgetc()
{// addr = 0x0804A16C
    goto __imp__fgetc;
}

feof()
{// addr = 0x0804A17C
    goto __imp__feof;
}

strcpy()
{// addr = 0x0804A18C
    goto __imp__strcpy;
}

getegid()
{// addr = 0x0804A19C
    goto __imp__getegid;
}

printf()
{// addr = 0x0804A1AC
    goto __imp__printf;
}

chdir()
{// addr = 0x0804A1BC
    goto __imp__chdir;
}

ctime()
{// addr = 0x0804A1CC
    goto __imp__ctime;
}

tputs()
{// addr = 0x0804A1DC
    goto __imp__tputs;
}

getuid()
{// addr = 0x0804A1EC
    goto __imp__getuid;
}

atol()
{// addr = 0x0804A1FC
    goto __imp__atol;
}

lrand48()
{// addr = 0x0804A20C
    goto __imp__lrand48;
}

gethostbyaddr()
{// addr = 0x0804A21C
    goto __imp__gethostbyaddr;
}

atoi()
{// addr = 0x0804A22C
    goto __imp__atoi;
}

strcasecmp()
{// addr = 0x0804A23C
    goto __imp__strcasecmp;
}

atof()
{// addr = 0x0804A24C
    goto __imp__atof;
}

GC_free()
{// addr = 0x0804A25C
    goto __imp__GC_free;
}

select()
{// addr = 0x0804A26C
    goto __imp__select;
}

closedir()
{// addr = 0x0804A27C
    goto __imp__closedir;
}

Gpm_Wgetch()
{// addr = 0x0804A28C
    goto __imp__Gpm_Wgetch;
}

close()
{// addr = 0x0804A29C
    goto __imp__close;
}

fwrite()
{// addr = 0x0804A2AC
    goto __imp__fwrite;
}

fprintf()
{// addr = 0x0804A2BC
    goto __imp__fprintf;
}

strstr()
{// addr = 0x0804A2CC
    goto __imp__strstr;
}

time()
{// addr = 0x0804A2DC
    goto __imp__time;
}

nl_langinfo()
{// addr = 0x0804A2EC
    goto __imp__nl_langinfo;
}

__stack_chk_fail()
{// addr = 0x0804A2FC
    goto __imp____stack_chk_fail;
}

Gpm_Close()
{// addr = 0x0804A30C
    goto __imp__Gpm_Close;
}

gethostname()
{// addr = 0x0804A31C
    goto __imp__gethostname;
}

atan2()
{// addr = 0x0804A32C
    goto __imp__atan2;
}

fputc()
{// addr = 0x0804A33C
    goto __imp__fputc;
}

strtok()
{// addr = 0x0804A34C
    goto __imp__strtok;
}

tgoto()
{// addr = 0x0804A35C
    goto __imp__tgoto;
}

strcasestr()
{// addr = 0x0804A36C
    goto __imp__strcasestr;
}

sleep()
{// addr = 0x0804A37C
    goto __imp__sleep;
}

tgetnum()
{// addr = 0x0804A38C
    goto __imp__tgetnum;
}

readlink()
{// addr = 0x0804A39C
    goto __imp__readlink;
}

strncasecmp()
{// addr = 0x0804A3AC
    goto __imp__strncasecmp;
}

getnameinfo()
{// addr = 0x0804A3BC
    goto __imp__getnameinfo;
}

strcat()
{// addr = 0x0804A3CC
    goto __imp__strcat;
}

getcwd()
{// addr = 0x0804A3DC
    goto __imp__getcwd;
}

log()
{// addr = 0x0804A3EC
    goto __imp__log;
}

puts()
{// addr = 0x0804A3FC
    goto __imp__puts;
}

fork()
{// addr = 0x0804A40C
    goto __imp__fork;
}

setpgrp()
{// addr = 0x0804A41C
    goto __imp__setpgrp;
}

textdomain()
{// addr = 0x0804A42C
    goto __imp__textdomain;
}

tcsetattr()
{// addr = 0x0804A43C
    goto __imp__tcsetattr;
}

bzero()
{// addr = 0x0804A44C
    goto __imp__bzero;
}

strspn()
{// addr = 0x0804A45C
    goto __imp__strspn;
}

sscanf()
{// addr = 0x0804A46C
    goto __imp__sscanf;
}

__fxstat()
{// addr = 0x0804A47C
    goto __imp____fxstat;
}

gmtime()
{// addr = 0x0804A48C
    goto __imp__gmtime;
}

fscanf()
{// addr = 0x0804A49C
    goto __imp__fscanf;
}

memchr()
{// addr = 0x0804A4AC
    goto __imp__memchr;
}

strncmp()
{// addr = 0x0804A4BC
    goto __imp__strncmp;
}

_IO_putc()
{// addr = 0x0804A4CC
    goto __imp___IO_putc;
}

pipe()
{// addr = 0x0804A4DC
    goto __imp__pipe;
}

Gpm_Open()
{// addr = 0x0804A4EC
    goto __imp__Gpm_Open;
}

fread()
{// addr = 0x0804A4FC
    goto __imp__fread;
}

strftime()
{// addr = 0x0804A50C
    goto __imp__strftime;
}

GC_malloc_atomic()
{// addr = 0x0804A51C
    goto __imp__GC_malloc_atomic;
}

tgetstr()
{// addr = 0x0804A52C
    goto __imp__tgetstr;
}

kill()
{// addr = 0x0804A53C
    goto __imp__kill;
}

strcspn()
{// addr = 0x0804A54C
    goto __imp__strcspn;
}

strdup()
{// addr = 0x0804A55C
    goto __imp__strdup;
}

getpeername()
{// addr = 0x0804A56C
    goto __imp__getpeername;
}

ferror()
{// addr = 0x0804A57C
    goto __imp__ferror;
}

getpwnam()
{// addr = 0x0804A58C
    goto __imp__getpwnam;
}

tolower()
{// addr = 0x0804A59C
    goto __imp__tolower;
}

strcmp()
{// addr = 0x0804A5AC
    goto __imp__strcmp;
}

__sigsetjmp()
{// addr = 0x0804A5BC
    goto __imp____sigsetjmp;
}

setenv()
{// addr = 0x0804A5CC
    goto __imp__setenv;
}

exit()
{// addr = 0x0804A5DC
    goto __imp__exit;
}

pclose()
{// addr = 0x0804A5EC
    goto __imp__pclose;
}

ceil()
{// addr = 0x0804A5FC
    goto __imp__ceil;
}

geteuid()
{// addr = 0x0804A60C
    goto __imp__geteuid;
}

_start(
    signed int __eax,                      // r0
    _unknown_ __edx                        // r3
)
{// addr = 0x0804A620
    _unknown_ __ebx;                       // r1
    signed int _t4;                        // _t4
    signed int _t5;                        // _t5

    __edx = __edx;
    _t3 = __eax;
    _pop(__esi);
    __ecx = __esp;
    __esp = __esp & -16;
    _push(__eax);
    _push(__esp);
    _push(__edx);
    _push(__libc_csu_fini);
    _push(__libc_csu_init);
    _push(__ecx);
    _push(__esi);
    _push(main);
    __libc_start_main();
    asm("hlt");
    0;
    0;
    _push(0);
    _push(_t5);
    __esp = __esp - 4;
    if(completed.7065 == 0) {
        _t3 = dtor_idx.7067;
        _t5 = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        if(_t3 <  &__DTOR_END__) {
            do {
                _t4 = _t3 + 1;
                dtor_idx.7067 = _t4;
                 *((intOrPtr*)(_t4 * 4 +  &__DTOR_LIST__))();
                _t3 = dtor_idx.7067;
            } while(_t3 < _t5);
        }
        completed.7065 = 1;
    }
    __esp = __esp + 4;
    _pop(__ebx);
    _pop(__ebp);
}

__do_global_dtors_aux()
{// addr = 0x0804A650
    _unknown_ __ebx;                       // r1
    _unknown_ _t3;                         // _t3
    signed int _t4;                        // _t4
    signed int _t5;                        // _t5
    signed int _t9;                        // _t9

    if(completed.7065 == 0) {
        _t4 = dtor_idx.7067;
        _t9 = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        if(_t4 >=  &__DTOR_END__) {
L4:
            completed.7065 = 1;
            return;
        }
        do {
            _t5 = _t4 + 1;
            dtor_idx.7067 = _t5;
             *((intOrPtr*)(_t5 * 4 +  &__DTOR_LIST__))();
            _t4 = dtor_idx.7067;
        } while(_t4 < _t9);
        goto L4;
    }
}

frame_dummy()
{// addr = 0x0804A6B0
    if(__JCR_LIST__ == 0 || 0 == 0) {
        return;
    } else {
         *__esp =  &__JCR_LIST__;
         *0();
        return;
    }
}

void fversion(FILE* f)
{// addr = 0x0804A6D4  --  defined in 'main.c' at line 117
    char* _v16;                            // _cfa_fffffff0
    char* _v20;                            // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8

    _v16 = "lang=en,m17n,image,color,ansi-color,mouse,gpm,menu,cookie,external-uri-loader,w3mmailer,nntp,gopher,ipv6,alarm,mark,migemo";
    _v20 = w3m_version;
    _v24 = "w3m version %s, options %s\n";
     *__esp = f;
    fprintf();
}

void fusage(FILE* f, int err)
{// addr = 0x0804A702  --  defined in 'main.c' at line 186
    int _v0;                               // _cfa_0
    FILE* _v16;           // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    int _v24;                              // _cfa_ffffffe8
    FILE* _v64;           // _cfa_ffffffc0
    FILE* _v68;           // _cfa_ffffffbc (outparam)
    _unknown_ _t366;                       // _t366

    fversion(f);
    _v16 = f;
    _v20 = 48;
    _v24 = 1;
     *__esp = "usage: w3m [options] [URL or filename]\noptions:\n";
    fwrite();
    _v16 = f;
    _v20 = 35;
    _v24 = 1;
     *__esp = "    -t tab           set tab width\n";
    fwrite();
    _v16 = f;
    _v20 = 45;
    _v24 = 1;
     *__esp = "    -r               ignore backspace effect\n";
    fwrite();
    _v16 = f;
    _v20 = 57;
    _v24 = 1;
     *__esp = "    -l line          # of preserved line (default 10000)\n";
    fwrite();
    _v16 = f;
    _v20 = 38;
    _v24 = 1;
     *__esp = "    -I charset       document charset\n";
    fwrite();
    _v16 = f;
    _v20 = 44;
    _v24 = 1;
     *__esp = "    -O charset       display/output charset\n";
    fwrite();
    _v16 = f;
    _v20 = 35;
    _v24 = 1;
     *__esp = "    -B               load bookmark\n";
    fwrite();
    _v16 = f;
    _v20 = 43;
    _v24 = 1;
     *__esp = "    -bookmark file   specify bookmark file\n";
    fwrite();
    _v16 = f;
    _v20 = 42;
    _v24 = 1;
     *__esp = "    -T type          specify content-type\n";
    fwrite();
    _v16 = f;
    _v20 = 43;
    _v24 = 1;
     *__esp = "    -m               internet message mode\n";
    fwrite();
    _v16 = f;
    _v20 = 41;
    _v24 = 1;
     *__esp = "    -v               visual startup mode\n";
    fwrite();
    _v16 = f;
    _v20 = 40;
    _v24 = 1;
     *__esp = "    -M               monochrome display\n";
    fwrite();
    _v16 = f;
    _v20 = 62;
    _v24 = 1;
     *__esp = "    -N               open URL of command line on each new tab\n";
    fwrite();
    _v16 = f;
    _v20 = 48;
    _v24 = 1;
     *__esp = "    -F               automatically render frame\n";
    fwrite();
    _v16 = f;
    _v20 = 60;
    _v24 = 1;
     *__esp = "    -cols width      specify column width (used with -dump)\n";
    fwrite();
    _v16 = f;
    _v20 = 77;
    _v24 = 1;
     *__esp = "    -ppc count       specify the number of pixels per character (4.0...32.0)\n";
    fwrite();
    _v16 = f;
    _v20 = 72;
    _v24 = 1;
     *__esp = "    -ppl count       specify the number of pixels per line (4.0...64.0)\n";
    fwrite();
    _v16 = f;
    _v20 = 53;
    _v24 = 1;
     *__esp = "    -dump            dump formatted page into stdout\n";
    fwrite();
    _v16 = f;
    _v20 = 63;
    _v24 = 1;
     *__esp = "    -dump_head       dump response of HEAD request into stdout\n";
    fwrite();
    _v16 = f;
    _v20 = 50;
    _v24 = 1;
     *__esp = "    -dump_source     dump page source into stdout\n";
    fwrite();
    _v16 = f;
    _v20 = 54;
    _v24 = 1;
     *__esp = "    -dump_both       dump HEAD and source into stdout\n";
    fwrite();
    _v16 = f;
    _v20 = 74;
    _v24 = 1;
     *__esp = "    -dump_extra      dump HEAD, source, and extra information into stdout\n";
    fwrite();
    _v16 = f;
    _v20 = 55;
    _v24 = 1;
     *__esp = "    -post file       use POST method with file content\n";
    fwrite();
    _v16 = f;
    _v20 = 47;
    _v24 = 1;
     *__esp = "    -header string   insert string as a header\n";
    fwrite();
    _v16 = f;
    _v20 = 37;
    _v24 = 1;
     *__esp = "    +<num>           goto <num> line\n";
    fwrite();
    _v16 = f;
    _v20 = 38;
    _v24 = 1;
     *__esp = "    -num             show line number\n";
    fwrite();
    _v16 = f;
    _v20 = 37;
    _v24 = 1;
     *__esp = "    -no-proxy        don't use proxy\n";
    fwrite();
    _v16 = f;
    _v20 = 48;
    _v24 = 1;
     *__esp = "    -4               IPv4 only (-o dns_order=4)\n";
    fwrite();
    _v16 = f;
    _v20 = 48;
    _v24 = 1;
     *__esp = "    -6               IPv6 only (-o dns_order=6)\n";
    fwrite();
    _v16 = f;
    _v20 = 37;
    _v24 = 1;
     *__esp = "    -no-mouse        don't use mouse\n";
    fwrite();
    _v16 = f;
    _v20 = 63;
    _v24 = 1;
     *__esp = "    -cookie          use cookie (-no-cookie: don't use cookie)\n";
    fwrite();
    _v16 = f;
    _v20 = 42;
    _v24 = 1;
     *__esp = "    -pauth user:pass proxy authentication\n";
    fwrite();
    _v16 = f;
    _v20 = 43;
    _v24 = 1;
     *__esp = "    -graph           use graphic character\n";
    fwrite();
    _v16 = f;
    _v20 = 49;
    _v24 = 1;
     *__esp = "    -no-graph        don't use graphic character\n";
    fwrite();
    _v16 = f;
    _v20 = 50;
    _v24 = 1;
     *__esp = "    -s               squeeze multiple blank lines\n";
    fwrite();
    _v16 = f;
    _v20 = 45;
    _v24 = 1;
     *__esp = "    -W               toggle wrap search mode\n";
    fwrite();
    _v16 = f;
    _v20 = 51;
    _v24 = 1;
     *__esp = "    -X               don't use termcap init/deinit\n";
    fwrite();
    _v16 = f;
    _v20 = 62;
    _v24 = 1;
     *__esp = "    -title[=TERM]    set buffer name to terminal title string\n";
    fwrite();
    _v16 = f;
    _v20 = 51;
    _v24 = 1;
     *__esp = "    -o opt=value     assign value to config option\n";
    fwrite();
    _v16 = f;
    _v20 = 46;
    _v24 = 1;
     *__esp = "    -show-option     print all config options\n";
    fwrite();
    _v16 = f;
    _v20 = 41;
    _v24 = 1;
     *__esp = "    -config file     specify config file\n";
    fwrite();
    _v16 = f;
    _v20 = 46;
    _v24 = 1;
     *__esp = "    -help            print this usage message\n";
    fwrite();
    _v16 = f;
    _v20 = 39;
    _v24 = 1;
     *__esp = "    -version         print w3m version\n";
    fwrite();
    _v16 = f;
    _v20 = 43;
    _v24 = 1;
     *__esp = "    -reqlog          write request logfile\n";
    fwrite();
    _v16 = f;
    _v20 = 32;
    _v24 = 1;
     *__esp = "    -debug           DO NOT USE\n";
    fwrite();
    if(show_params_p != 0) {
        show_params(f);
    }
     *__esp = err;
    exit();
    _push(_t366);
    __esp = __esp - 40;
    if((fmInitialized & 255) == 0) {
        if(orig_GC_warn_proc == 0) {
            _v64 = f;
            _v68 = _v0;
             *__esp = __imp__stderr;
            fprintf();
            return;
        }
        _v68 = f;
         *__esp = _v0;
         *orig_GC_warn_proc();
        return;
    }
    _v20 = i + n - ((-858993459 << 2) + ((i + n) * -858993459 >> 32 >> 4) << 2);
     *( &msg_ring + _v20 * 8) = _v0;
     *(135775524 + _v20 * 8) = f;
    if(n > 19) {
        i = i + 1;
    } else {
        n = n + 1;
    }
    if(lock == 0) {
        lock = 1;
        while(n > 0) {
            i = i - ((-858993459 << 2) + (i * -858993459 >> 32 >> 4) << 2);
            _v68 =  *(135775524 + i * 8);
             *__esp =  *( &msg_ring + i * 8);
            printf();
            sleep_till_anykey(1, 1);
            n = n - 1;
            i = i + 1;
        }
        lock = 0;
        return;
    }
}

void wrap_GC_warn_proc(char* msg, GC_word arg)
{// addr = 0x0804AD86  --  defined in 'main.c' at line 279
    int j;                                 // _cfa_fffffff0
    long unsigned int _v36;                // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8 (outparam)

    if((fmInitialized & 255) == 0) {
        if(orig_GC_warn_proc == 0) {
            _v36 = arg;
            _v40 = msg;
             *__esp = __imp__stderr;
            fprintf();
            return;
        }
        _v40 = arg;
         *__esp = msg;
         *orig_GC_warn_proc();
        return;
    }
    j = i + n - ((-858993459 << 2) + ((i + n) * -858993459 >> 32 >> 4) << 2);
     *( &msg_ring + j * 8) = msg;
     *(135775524 + j * 8) = arg;
    if(n > 19) {
        i = i + 1;
    } else {
        n = n + 1;
    }
    if(lock == 0) {
        lock = 1;
        while(n > 0) {
            i = i - ((-858993459 << 2) + (i * -858993459 >> 32 >> 4) << 2);
            _v40 =  *(135775524 + i * 8);
             *__esp =  *( &msg_ring + i * 8);
            printf();
            sleep_till_anykey(1, 1);
            n = n - 1;
            i = i + 1;
        }
        lock = 0;
        return;
    }
}

void sig_chld(int signo)
{// addr = 0x0804AEF1  --  defined in 'main.c' at line 323
    int p_stat;                            // _cfa_fffffff0
    pid_t pid;           // _cfa_ffffffec
    intOrPtr _v36;                         // _cfa_ffffffdc
    int* _v40;                             // _cfa_ffffffd8 (outparam)

    do {
        _v36 = 1;
        _v40 =  &p_stat;
         *__esp = -1;
        waitpid();
        pid =  &p_stat;
    } while(pid > 0);
    mySignal(17, sig_chld);
}

Str make_optional_header_string(char* s)
{// addr = 0x0804AF31  --  defined in 'main.c' at line 347
    char* p;                               // _cfa_fffffff0
    Str hs;                // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    char* _t40;                            // _t40
    char* _t42;                            // _t42
    char* _t50;                            // _t50
    char* _t58;                            // _t58

    _v40 = 10;
    _t40 = s;
     *__esp = _t40;
    strchr();
    if(_t40 != 0) {
L2:
        return 0;
    }
    _v40 = 13;
    _t42 = s;
     *__esp = _t42;
    strchr();
    if(_t42 == 0) {
        p = s;
        do {
        } while(( *p & 255) != 0 && ( *p & 255) != 58);
        if(( *p & 255) != 58 || p == s) {
            return 0;
        } else {
            _t50 = s;
             *__esp = _t50;
            strlen();
            hs = Strnew_size( &(_t50[3]));
            Strcopy_charp_n(hs, s, p - s);
            _t58 = hs->ptr;
            _v40 = "content-type";
             *__esp = _t58;
            strcasecmp();
            if(_t58 == 0) {
                override_content_type = 1;
            }
            Strcat_charp(hs, ": ");
            p =  &(p[1]);
            if(( *p & 255) == 0) {
L18:
                Strcat_charp(hs, "\n");
                return hs;
            } else {
                while(( *p & 255) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                    p =  &(p[1]);
                }
                Strcat_charp(hs, p);
                goto L18;
            }
        }
    }
    goto L2;
}

int main(int argc, char** argv, char** envp)
{// addr = 0x0804B07E  --  defined in 'main.c' at line 371
    Buffer* newbuf;     // r4+136
    char* p;                               // r4+132
    char c;                                // r4+143
    int i;                                 // r4+128
    InputStream redin;   // r4+124
    char* line_str;                        // r4+120
    char** load_argv;                      // r4+116
    FormList* request;   // r4+112
    int load_argc;                         // r4+108
    int load_bookmark;                     // r4+104
    int visual_start;                      // r4+100
    int open_new_tab;                      // r4+96
    char search_header;                    // r4+142
    char* default_type;                    // r4+92
    char* post_file;                       // r4+88
    Str err_msg;           // r4+84
    char* Locale;                          // r4+80
    wc_uint8 auto_detect;   // r4+141
    Str tmp;               // r4+76
    double ppc;                            // r4+48
    double ppc;                            // r4+40
    Str hs;                // r4+72
    Str s_page;            // r4+68
    FILE* fp;             // r4+64
    Str body;              // r4+60
    Anchor* a;          // r4+56
    int _v21;                              // _cfa_ffffffeb
    signed int _v22;                       // _cfa_ffffffea
    signed char _v23;                      // _cfa_ffffffe9
    Buffer* _v28;       // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    union input_stream* _v40;   // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    struct form_list* _v52;   // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    signed int _v76;                       // _cfa_ffffffb4
    struct _Str* _v80;    // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    struct _Str* _v88;    // _cfa_ffffffa8
    struct _Str* _v92;    // _cfa_ffffffa4
    struct _Str* _v96;    // _cfa_ffffffa0
    FILE* _v100;          // _cfa_ffffff9c
    struct _Str* _v104;   // _cfa_ffffff98
    Anchor* _v108;      // _cfa_ffffff94
    double _v116;                          // _cfa_ffffff8c
    double _v124;                          // _cfa_ffffff84
    _unknown_ _v140;                       // _cfa_ffffff74 (outparam)
    _unknown_ _v144;                       // _cfa_ffffff70 (outparam)
    struct form_list* _v148;   // _cfa_ffffff6c (outparam)
    char* _v152;                           // _cfa_ffffff68 (outparam)
    char* _v156;                           // _cfa_ffffff64 (outparam)
    char* _v160;                           // _cfa_ffffff60 (outparam)
    signed int _t758;                      // _t758
    int _t759;                             // _t759
    char* _t760;                           // _t760
    signed int _t769;                      // _t769
    signed int _t773;                      // _t773
    signed int _t778;                      // _t778
    signed int _t782;                      // _t782
    signed int _t787;                      // _t787
    char* _t801;                           // _t801
    char* _t820;                           // _t820
    char* _t822;                           // _t822
    char* _t824;                           // _t824
    char* _t826;                           // _t826
    char* _t828;                           // _t828
    char* _t830;                           // _t830
    char* _t832;                           // _t832
    char* _t834;                           // _t834
    signed int _t857;                      // _t857
    signed int _t861;                      // _t861
    signed int _t865;                      // _t865
    signed int _t869;                      // _t869
    signed int _t873;                      // _t873
    signed int _t877;                      // _t877
    signed int _t881;                      // _t881
    signed int _t885;                      // _t885
    signed int _t889;                      // _t889
    signed int _t893;                      // _t893
    signed int _t897;                      // _t897
    signed int _t901;                      // _t901
    signed int _t905;                      // _t905
    signed int _t909;                      // _t909
    signed int _t913;                      // _t913
    signed int _t917;                      // _t917
    signed int _t921;                      // _t921
    signed int _t925;                      // _t925
    signed int _t929;                      // _t929
    signed int _t933;                      // _t933
    signed int _t937;                      // _t937
    signed int _t941;                      // _t941
    signed int _t945;                      // _t945
    signed int _t949;                      // _t949
    signed int _t953;                      // _t953
    signed int _t957;                      // _t957
    signed int _t961;                      // _t961
    signed int _t965;                      // _t965
    signed int _t969;                      // _t969
    signed int _t973;                      // _t973
    signed int _t977;                      // _t977
    signed int _t991;                      // _t991
    signed int _t995;                      // _t995
    signed int _t999;                      // _t999
    signed int _t1003;                     // _t1003
    signed int _t1007;                     // _t1007
    signed int _t1011;                     // _t1011
    signed int _t1015;                     // _t1015
    signed int _t1019;                     // _t1019
    signed int _t1023;                     // _t1023
    char* _t1027;                          // _t1027
    signed int _t1031;                     // _t1031
    signed int _t1035;                     // _t1035
    signed int _t1039;                     // _t1039
    signed int _t1045;                     // _t1045
    signed int _t1055;                     // _t1055
    signed int _t1059;                     // _t1059
    signed int _t1063;                     // _t1063
    signed int _t1067;                     // _t1067
    signed int _t1071;                     // _t1071
    char** _t1084;                         // _t1084
    char** _t1098;                         // _t1098
    int _t1148;                            // _t1148
    struct _Str* _t1172;   // _t1172
    int _t1175;                            // _t1175
    struct _Str* _t1176;   // _t1176
    int _t1180;                            // _t1180
    signed int _t1195;                     // _t1195
    signed int _t1216;                     // _t1216
    signed int _t1236;                     // _t1236
    signed int _t1251;                     // _t1251
    int _t1255;                            // _t1255
    signed int _t1261;                     // _t1261
    int _t1265;                            // _t1265
    char* _t1267;                          // _t1267
    _None* _t1277;                         // _t1277
    FILE* _t1278;         // _t1278
    Buffer* _t1280;     // _t1280
    Buffer* _t1289;     // _t1289
    TabBuffer* _t1304;   // _t1304
    Buffer* _t1306;     // _t1306
    Buffer* _t1308;     // _t1308
    Buffer* _t1310;     // _t1310
    signed int _t1313;                     // _t1313
    int _t1316;                            // _t1316
    signed int _t1319;                     // _t1319
    short int _t1323;                      // _t1323
    signed int _t1331;                     // _t1331
    signed int _t1343;                     // _t1343
    FILE* _t1344;         // _t1344
    Buffer* _t1385;     // _t1385
    Buffer* _t1388;     // _t1388
    signed int _t1394;                     // _t1394
    signed int _t1399;                     // _t1399
    Buffer* _t1424;     // _t1424
    Buffer* _t1427;     // _t1427
    struct _AlarmEvent* _t1435;   // _t1435
    int _t1487;                            // _t1487
    _unknown_ _t1488;                      // _t1488
    char* _t1565;                          // _t1565
    _unknown_ _t1568;                      // _t1568
    TabBuffer* _t1569;   // _t1569
    int _t1602;                            // _t1602
    signed int _t1615;                     // _t1615
    char* _t1625;                          // _t1625
    _unknown_ _t1626;                      // _t1626
    TabBuffer* _t1627;   // _t1627
    double _t1697;                         // _t1697

    __esp = __esp & -16;
    _push(_t1626);
    _push(_t1568);
    __esp = __esp - 152;
    _v28 = 0;
    _v44 = 0;
    _v56 = 0;
    _v60 = 0;
    _v64 = 0;
    _v68 = 0;
    _v22 = 0;
    _v72 = 0;
    _v76 = 0;
    _v84 = 0;
    _v160 = 135036496;
     *__esp = 6;
    setlocale();
    _v160 = "/usr/share/locale";
     *__esp = "w3m";
    bindtextdomain();
     *__esp = "w3m";
    textdomain();
    NO_proxy_domains = newGeneralList();
    fileToDelete = newGeneralList();
    _t758 = argc - 1 << 2;
     *__esp = _t758;
    GC_malloc();
    _v48 = _t758;
    _v56 = 0;
    _t759 = currentdir();
    CurrentDir = _t759;
    getpid();
    CurrentPid = _t759;
    BookmarkFile = 0;
    config_file = 0;
    _v36 = 1;
    while(1) {
        _t760 = _v36;
        if(_t760 >= argc) {
            break;
        }
        __eflags = ( *(argv[_v36]) & 255) - 45;
        if(( *(argv[_v36]) & 255) != 45) {
L12:
            _v36 = _v36 + 1;
            __eflags = _v36;
            continue;
        }
        _t769 = argv[_v36];
        _v160 = _t769;
         *__esp = "-config";
        strcmp();
        __eflags = _t769;
        if(_t769 != 0) {
            _t773 = argv[_v36];
            _v160 = _t773;
             *__esp = "-h";
            strcmp();
            __eflags = _t773;
            if(_t773 == 0) {
L8:
                fusage(__imp__stdout, 0);
                goto L12;
            }
            _t778 = argv[_v36];
            _v160 = _t778;
             *__esp = "-help";
            strcmp();
            __eflags = _t778;
            if(_t778 != 0) {
                _t782 = argv[_v36];
                _v160 = _t782;
                 *__esp = "-V";
                strcmp();
                __eflags = _t782;
                if(_t782 == 0) {
L11:
                    fversion(__imp__stdout);
                     *__esp = 0;
                    exit();
                    goto L12;
                }
                _t787 = argv[_v36];
                _v160 = _t787;
                 *__esp = "-version";
                strcmp();
                __eflags = _t787;
                if(_t787 != 0) {
                    goto L12;
                }
                goto L11;
            }
            goto L8;
        } else {
            argv[_v36] = "-dummy";
            _v36 = _v36 + 1;
            __eflags = _v36 - argc;
            if(_v36 >= argc) {
                fusage(__imp__stderr, 1);
            }
            config_file = argv[_v36];
            argv[_v36] = "-dummy";
            goto L12;
        }
    }
     *__esp = "LC_ALL";
    getenv();
    _v84 = _t760;
    _t801 = non_null(_v84);
    if(_t801 != 0) {
L17:
        DisplayCharset = wc_guess_locale_charset(_v84, DisplayCharset);
        DocumentCharset = wc_guess_locale_charset(_v84, DocumentCharset);
        SystemCharset = wc_guess_locale_charset(_v84, SystemCharset);
L18:
        init_rc();
        LoadHist = newHist();
        SaveHist = newHist();
        ShellHist = newHist();
        TextHist = newHist();
        URLHist = newHist();
        if((FollowLocale & 255) != 0) {
            if(_v84 != 0) {
                DisplayCharset = wc_guess_locale_charset(_v84, DisplayCharset);
                SystemCharset = wc_guess_locale_charset(_v84, SystemCharset);
            }
        }
        _v23 = WcOption.auto_detect & 255;
        BookmarkCharset = DocumentCharset;
        _t820 = non_null(HTTP_proxy);
        if(_t820 != 0) {
L26:
            _t822 = non_null(GOPHER_proxy);
            if(_t822 != 0) {
L31:
                _t824 = non_null(FTP_proxy);
                if(_t824 != 0) {
L36:
                    _t826 = non_null(NO_proxy);
                    if(_t826 != 0) {
L41:
                        _t828 = non_null(NNTP_server);
                        if(_t828 == 0) {
                             *__esp = "NNTPSERVER";
                            getenv();
                            _v32 = _t828;
                            if(_v32 != 0) {
                                NNTP_server = _v32;
                            }
                        }
                        _t830 = non_null(NNTP_mode);
                        if(_t830 == 0) {
                             *__esp = "NNTPMODE";
                            getenv();
                            _v32 = _t830;
                            if(_v32 != 0) {
                                NNTP_mode = _v32;
                            }
                        }
                        _t832 = non_null(Editor);
                        if(_t832 == 0) {
                             *__esp = "EDITOR";
                            getenv();
                            _v32 = _t832;
                            if(_v32 != 0) {
                                Editor = _v32;
                            }
                        }
                        _t834 = non_null(Mailer);
                        if(_t834 == 0) {
                             *__esp = "MAILER";
                            getenv();
                            _v32 = _t834;
                            if(_v32 != 0) {
                                Mailer = _v32;
                            }
                        }
                        _v36 = 1;
                        while(_v36 < argc) {
                            __eflags = ( *(argv[_v36]) & 255) - 45;
                            if(( *(argv[_v36]) & 255) != 45) {
                                __eflags = ( *(argv[_v36]) & 255) - 43;
                                if(( *(argv[_v36]) & 255) != 43) {
                                     *((_v56 << 2) + _v48) = argv[_v36];
                                    _v56 = _v56 + 1;
                                } else {
                                    _v44 =  &(argv[_v36][1]);
                                }
L224:
                                _v36 = _v36 + 1;
                                __eflags = _v36;
                                continue;
                            }
                            _t857 = argv[_v36];
                            _v160 = _t857;
                             *__esp = "-t";
                            strcmp();
                            __eflags = _t857;
                            if(_t857 != 0) {
                                _t861 = argv[_v36];
                                _v160 = _t861;
                                 *__esp = "-r";
                                strcmp();
                                __eflags = _t861;
                                if(_t861 != 0) {
                                    _t865 = argv[_v36];
                                    _v160 = _t865;
                                     *__esp = "-l";
                                    strcmp();
                                    __eflags = _t865;
                                    if(_t865 != 0) {
                                        _t869 = argv[_v36];
                                        _v156 = 2;
                                        _v160 = _t869;
                                         *__esp = "-I";
                                        strncmp();
                                        __eflags = _t869;
                                        if(_t869 != 0) {
                                            _t873 = argv[_v36];
                                            _v156 = 2;
                                            _v160 = _t873;
                                             *__esp = "-O";
                                            strncmp();
                                            __eflags = _t873;
                                            if(_t873 != 0) {
                                                _t877 = argv[_v36];
                                                _v160 = _t877;
                                                 *__esp = "-graph";
                                                strcmp();
                                                __eflags = _t877;
                                                if(_t877 != 0) {
                                                    _t881 = argv[_v36];
                                                    _v160 = _t881;
                                                     *__esp = "-no-graph";
                                                    strcmp();
                                                    __eflags = _t881;
                                                    if(_t881 != 0) {
                                                        _t885 = argv[_v36];
                                                        _v160 = _t885;
                                                         *__esp = "-T";
                                                        strcmp();
                                                        __eflags = _t885;
                                                        if(_t885 != 0) {
                                                            _t889 = argv[_v36];
                                                            _v160 = _t889;
                                                             *__esp = "-m";
                                                            strcmp();
                                                            __eflags = _t889;
                                                            if(_t889 != 0) {
                                                                _t893 = argv[_v36];
                                                                _v160 = _t893;
                                                                 *__esp = "-v";
                                                                strcmp();
                                                                __eflags = _t893;
                                                                if(_t893 != 0) {
                                                                    _t897 = argv[_v36];
                                                                    _v160 = _t897;
                                                                     *__esp = "-N";
                                                                    strcmp();
                                                                    __eflags = _t897;
                                                                    if(_t897 != 0) {
                                                                        _t901 = argv[_v36];
                                                                        _v160 = _t901;
                                                                         *__esp = "-M";
                                                                        strcmp();
                                                                        __eflags = _t901;
                                                                        if(_t901 != 0) {
                                                                            _t905 = argv[_v36];
                                                                            _v160 = _t905;
                                                                             *__esp = "-B";
                                                                            strcmp();
                                                                            __eflags = _t905;
                                                                            if(_t905 != 0) {
                                                                                _t909 = argv[_v36];
                                                                                _v160 = _t909;
                                                                                 *__esp = "-bookmark";
                                                                                strcmp();
                                                                                __eflags = _t909;
                                                                                if(_t909 != 0) {
                                                                                    _t913 = argv[_v36];
                                                                                    _v160 = _t913;
                                                                                     *__esp = "-F";
                                                                                    strcmp();
                                                                                    __eflags = _t913;
                                                                                    if(_t913 != 0) {
                                                                                        _t917 = argv[_v36];
                                                                                        _v160 = _t917;
                                                                                         *__esp = "-W";
                                                                                        strcmp();
                                                                                        __eflags = _t917;
                                                                                        if(_t917 != 0) {
                                                                                            _t921 = argv[_v36];
                                                                                            _v160 = _t921;
                                                                                             *__esp = "-dump";
                                                                                            strcmp();
                                                                                            __eflags = _t921;
                                                                                            if(_t921 != 0) {
                                                                                                _t925 = argv[_v36];
                                                                                                _v160 = _t925;
                                                                                                 *__esp = "-dump_source";
                                                                                                strcmp();
                                                                                                __eflags = _t925;
                                                                                                if(_t925 != 0) {
                                                                                                    _t929 = argv[_v36];
                                                                                                    _v160 = _t929;
                                                                                                     *__esp = "-dump_head";
                                                                                                    strcmp();
                                                                                                    __eflags = _t929;
                                                                                                    if(_t929 != 0) {
                                                                                                        _t933 = argv[_v36];
                                                                                                        _v160 = _t933;
                                                                                                         *__esp = "-dump_both";
                                                                                                        strcmp();
                                                                                                        __eflags = _t933;
                                                                                                        if(_t933 != 0) {
                                                                                                            _t937 = argv[_v36];
                                                                                                            _v160 = _t937;
                                                                                                             *__esp = "-dump_extra";
                                                                                                            strcmp();
                                                                                                            __eflags = _t937;
                                                                                                            if(_t937 != 0) {
                                                                                                                _t941 = argv[_v36];
                                                                                                                _v160 = _t941;
                                                                                                                 *__esp = "-halfdump";
                                                                                                                strcmp();
                                                                                                                __eflags = _t941;
                                                                                                                if(_t941 != 0) {
                                                                                                                    _t945 = argv[_v36];
                                                                                                                    _v160 = _t945;
                                                                                                                     *__esp = "-halfload";
                                                                                                                    strcmp();
                                                                                                                    __eflags = _t945;
                                                                                                                    if(_t945 != 0) {
                                                                                                                        _t949 = argv[_v36];
                                                                                                                        _v160 = _t949;
                                                                                                                         *__esp = "-backend";
                                                                                                                        strcmp();
                                                                                                                        __eflags = _t949;
                                                                                                                        if(_t949 != 0) {
                                                                                                                            _t953 = argv[_v36];
                                                                                                                            _v160 = _t953;
                                                                                                                             *__esp = "-backend_batch";
                                                                                                                            strcmp();
                                                                                                                            __eflags = _t953;
                                                                                                                            if(_t953 != 0) {
                                                                                                                                _t957 = argv[_v36];
                                                                                                                                _v160 = _t957;
                                                                                                                                 *__esp = "-cols";
                                                                                                                                strcmp();
                                                                                                                                __eflags = _t957;
                                                                                                                                if(_t957 != 0) {
                                                                                                                                    _t961 = argv[_v36];
                                                                                                                                    _v160 = _t961;
                                                                                                                                     *__esp = "-ppc";
                                                                                                                                    strcmp();
                                                                                                                                    __eflags = _t961;
                                                                                                                                    if(_t961 != 0) {
                                                                                                                                        _t965 = argv[_v36];
                                                                                                                                        _v160 = _t965;
                                                                                                                                         *__esp = "-ppl";
                                                                                                                                        strcmp();
                                                                                                                                        __eflags = _t965;
                                                                                                                                        if(_t965 != 0) {
                                                                                                                                            _t969 = argv[_v36];
                                                                                                                                            _v160 = _t969;
                                                                                                                                             *__esp = "-num";
                                                                                                                                            strcmp();
                                                                                                                                            __eflags = _t969;
                                                                                                                                            if(_t969 != 0) {
                                                                                                                                                _t973 = argv[_v36];
                                                                                                                                                _v160 = _t973;
                                                                                                                                                 *__esp = "-no-proxy";
                                                                                                                                                strcmp();
                                                                                                                                                __eflags = _t973;
                                                                                                                                                if(_t973 != 0) {
                                                                                                                                                    _t977 = argv[_v36];
                                                                                                                                                    _v160 = _t977;
                                                                                                                                                     *__esp = "-4";
                                                                                                                                                    strcmp();
                                                                                                                                                    __eflags = _t977;
                                                                                                                                                    if(_t977 == 0) {
L160:
                                                                                                                                                        _v160 = argv[_v36][1] & 255;
                                                                                                                                                        set_param_option( *(Sprintf("dns_order=%c")));
                                                                                                                                                        goto L224;
                                                                                                                                                    }
                                                                                                                                                    _t991 = argv[_v36];
                                                                                                                                                    _v160 = _t991;
                                                                                                                                                     *__esp = "-6";
                                                                                                                                                    strcmp();
                                                                                                                                                    __eflags = _t991;
                                                                                                                                                    if(_t991 != 0) {
                                                                                                                                                        _t995 = argv[_v36];
                                                                                                                                                        _v160 = _t995;
                                                                                                                                                         *__esp = "-post";
                                                                                                                                                        strcmp();
                                                                                                                                                        __eflags = _t995;
                                                                                                                                                        if(_t995 != 0) {
                                                                                                                                                            _t999 = argv[_v36];
                                                                                                                                                            _v160 = _t999;
                                                                                                                                                             *__esp = "-header";
                                                                                                                                                            strcmp();
                                                                                                                                                            __eflags = _t999;
                                                                                                                                                            if(_t999 != 0) {
                                                                                                                                                                _t1003 = argv[_v36];
                                                                                                                                                                _v160 = _t1003;
                                                                                                                                                                 *__esp = "-no-mouse";
                                                                                                                                                                strcmp();
                                                                                                                                                                __eflags = _t1003;
                                                                                                                                                                if(_t1003 != 0) {
                                                                                                                                                                    _t1007 = argv[_v36];
                                                                                                                                                                    _v160 = _t1007;
                                                                                                                                                                     *__esp = "-no-cookie";
                                                                                                                                                                    strcmp();
                                                                                                                                                                    __eflags = _t1007;
                                                                                                                                                                    if(_t1007 != 0) {
                                                                                                                                                                        _t1011 = argv[_v36];
                                                                                                                                                                        _v160 = _t1011;
                                                                                                                                                                         *__esp = "-cookie";
                                                                                                                                                                        strcmp();
                                                                                                                                                                        __eflags = _t1011;
                                                                                                                                                                        if(_t1011 != 0) {
                                                                                                                                                                            _t1015 = argv[_v36];
                                                                                                                                                                            _v160 = _t1015;
                                                                                                                                                                             *__esp = "-pauth";
                                                                                                                                                                            strcmp();
                                                                                                                                                                            __eflags = _t1015;
                                                                                                                                                                            if(_t1015 != 0) {
                                                                                                                                                                                _t1019 = argv[_v36];
                                                                                                                                                                                _v160 = _t1019;
                                                                                                                                                                                 *__esp = "-s";
                                                                                                                                                                                strcmp();
                                                                                                                                                                                __eflags = _t1019;
                                                                                                                                                                                if(_t1019 != 0) {
                                                                                                                                                                                    _t1023 = argv[_v36];
                                                                                                                                                                                    _v160 = _t1023;
                                                                                                                                                                                     *__esp = "-X";
                                                                                                                                                                                    strcmp();
                                                                                                                                                                                    __eflags = _t1023;
                                                                                                                                                                                    if(_t1023 != 0) {
                                                                                                                                                                                        _t1027 = argv[_v36];
                                                                                                                                                                                        _v160 = _t1027;
                                                                                                                                                                                         *__esp = "-title";
                                                                                                                                                                                        strcmp();
                                                                                                                                                                                        __eflags = _t1027;
                                                                                                                                                                                        if(_t1027 != 0) {
                                                                                                                                                                                            _t1031 = argv[_v36];
                                                                                                                                                                                            _v156 = 7;
                                                                                                                                                                                            _v160 = _t1031;
                                                                                                                                                                                             *__esp = "-title=";
                                                                                                                                                                                            strncmp();
                                                                                                                                                                                            __eflags = _t1031;
                                                                                                                                                                                            if(_t1031 != 0) {
                                                                                                                                                                                                _t1035 = argv[_v36];
                                                                                                                                                                                                _v160 = _t1035;
                                                                                                                                                                                                 *__esp = "-o";
                                                                                                                                                                                                strcmp();
                                                                                                                                                                                                __eflags = _t1035;
                                                                                                                                                                                                if(_t1035 == 0) {
L199:
                                                                                                                                                                                                    _t1039 = argv[_v36];
                                                                                                                                                                                                    _v160 = _t1039;
                                                                                                                                                                                                     *__esp = "-show-option";
                                                                                                                                                                                                    strcmp();
                                                                                                                                                                                                    __eflags = _t1039;
                                                                                                                                                                                                    if(_t1039 == 0) {
L202:
                                                                                                                                                                                                        show_params(__imp__stdout);
                                                                                                                                                                                                         *__esp = 0;
                                                                                                                                                                                                        exit();
L203:
                                                                                                                                                                                                        _t1045 = set_param_option(argv[_v36]);
                                                                                                                                                                                                        __eflags = _t1045;
                                                                                                                                                                                                        if(_t1045 == 0) {
                                                                                                                                                                                                            _v156 = argv[_v36];
                                                                                                                                                                                                            _v160 = "%s: bad option\n";
                                                                                                                                                                                                             *__esp = __imp__stderr;
                                                                                                                                                                                                            fprintf();
                                                                                                                                                                                                            show_params_p = 1;
                                                                                                                                                                                                            fusage(__imp__stderr, 1);
                                                                                                                                                                                                        }
                                                                                                                                                                                                        goto L224;
                                                                                                                                                                                                    }
                                                                                                                                                                                                    _v36 = _v36 + 1;
                                                                                                                                                                                                    __eflags = _v36 - argc;
                                                                                                                                                                                                    if(_v36 >= argc) {
                                                                                                                                                                                                        goto L202;
                                                                                                                                                                                                    }
                                                                                                                                                                                                    _t1055 = argv[_v36];
                                                                                                                                                                                                    _v160 = 135037061;
                                                                                                                                                                                                     *__esp = _t1055;
                                                                                                                                                                                                    strcmp();
                                                                                                                                                                                                    __eflags = _t1055;
                                                                                                                                                                                                    if(_t1055 != 0) {
                                                                                                                                                                                                        goto L203;
                                                                                                                                                                                                    }
                                                                                                                                                                                                    goto L202;
                                                                                                                                                                                                }
                                                                                                                                                                                                _t1059 = argv[_v36];
                                                                                                                                                                                                _v160 = _t1059;
                                                                                                                                                                                                 *__esp = "-show-option";
                                                                                                                                                                                                strcmp();
                                                                                                                                                                                                __eflags = _t1059;
                                                                                                                                                                                                if(_t1059 != 0) {
                                                                                                                                                                                                    _t1063 = argv[_v36];
                                                                                                                                                                                                    _v160 = _t1063;
                                                                                                                                                                                                     *__esp = "-dummy";
                                                                                                                                                                                                    strcmp();
                                                                                                                                                                                                    __eflags = _t1063;
                                                                                                                                                                                                    if(_t1063 != 0) {
                                                                                                                                                                                                        _t1067 = argv[_v36];
                                                                                                                                                                                                        _v160 = _t1067;
                                                                                                                                                                                                         *__esp = "-debug";
                                                                                                                                                                                                        strcmp();
                                                                                                                                                                                                        __eflags = _t1067;
                                                                                                                                                                                                        if(_t1067 != 0) {
                                                                                                                                                                                                            _t1071 = argv[_v36];
                                                                                                                                                                                                            _v160 = _t1071;
                                                                                                                                                                                                             *__esp = "-reqlog";
                                                                                                                                                                                                            strcmp();
                                                                                                                                                                                                            __eflags = _t1071;
                                                                                                                                                                                                            if(_t1071 != 0) {
                                                                                                                                                                                                                fusage(__imp__stderr, 1);
                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                w3m_reqlog = rcFile("request.log");
                                                                                                                                                                                                            }
                                                                                                                                                                                                        } else {
                                                                                                                                                                                                            w3m_debug = 1;
                                                                                                                                                                                                        }
                                                                                                                                                                                                    }
                                                                                                                                                                                                    goto L224;
                                                                                                                                                                                                }
                                                                                                                                                                                                goto L199;
                                                                                                                                                                                            }
                                                                                                                                                                                            displayTitleTerm =  &(argv[_v36][7]);
                                                                                                                                                                                            goto L224;
                                                                                                                                                                                        }
                                                                                                                                                                                         *__esp = "TERM";
                                                                                                                                                                                        getenv();
                                                                                                                                                                                        displayTitleTerm = _t1027;
                                                                                                                                                                                        goto L224;
                                                                                                                                                                                    }
                                                                                                                                                                                    Do_not_use_ti_te = 1;
                                                                                                                                                                                    goto L224;
                                                                                                                                                                                }
                                                                                                                                                                                squeezeBlankLine = 1;
                                                                                                                                                                                goto L224;
                                                                                                                                                                            }
                                                                                                                                                                            _v36 = _v36 + 1;
                                                                                                                                                                            __eflags = _v36 - argc;
                                                                                                                                                                            if(_v36 >= argc) {
                                                                                                                                                                                fusage(__imp__stderr, 1);
                                                                                                                                                                            }
                                                                                                                                                                            _t1084 = encodeB(argv[_v36]);
                                                                                                                                                                            _v156 = 0;
                                                                                                                                                                            _v160 =  *_t1084;
                                                                                                                                                                            proxy_auth_cookie = Strnew_m_charp("Basic ");
                                                                                                                                                                            while(1) {
                                                                                                                                                                                __eflags =  *(argv[_v36]) & 255;
                                                                                                                                                                                if(( *(argv[_v36]) & 255) == 0) {
                                                                                                                                                                                    break;
                                                                                                                                                                                }
                                                                                                                                                                                 *(argv[_v36]) = 0;
                                                                                                                                                                                _t1098 =  &(argv[_v36]);
                                                                                                                                                                                _t1615 =  &(( *_t1098)[1]);
                                                                                                                                                                                __eflags = _t1615;
                                                                                                                                                                                 *_t1098 = _t1615;
                                                                                                                                                                            }
                                                                                                                                                                            goto L224;
                                                                                                                                                                        }
                                                                                                                                                                        use_cookie = 1;
                                                                                                                                                                        accept_cookie = 1;
                                                                                                                                                                        goto L224;
                                                                                                                                                                    }
                                                                                                                                                                    use_cookie = 0;
                                                                                                                                                                    accept_cookie = 0;
                                                                                                                                                                    goto L224;
                                                                                                                                                                }
                                                                                                                                                                use_mouse = 0;
                                                                                                                                                                goto L224;
                                                                                                                                                            }
                                                                                                                                                            _v36 = _v36 + 1;
                                                                                                                                                            __eflags = _v36 - argc;
                                                                                                                                                            if(_v36 >= argc) {
                                                                                                                                                                fusage(__imp__stderr, 1);
                                                                                                                                                            }
                                                                                                                                                            _v92 = make_optional_header_string(argv[_v36]);
                                                                                                                                                            __eflags = _v92;
                                                                                                                                                            if(_v92 != 0) {
                                                                                                                                                                __eflags = header_string;
                                                                                                                                                                if(header_string != 0) {
                                                                                                                                                                    Strcat(header_string, _v92);
                                                                                                                                                                } else {
                                                                                                                                                                    header_string = _v92;
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                            while(1) {
                                                                                                                                                                __eflags =  *(argv[_v36]) & 255;
                                                                                                                                                                if(( *(argv[_v36]) & 255) == 0) {
                                                                                                                                                                    break;
                                                                                                                                                                }
                                                                                                                                                                 *(argv[_v36]) = 0;
                                                                                                                                                                argv[_v36] =  &(argv[_v36][1]);
                                                                                                                                                            }
                                                                                                                                                            goto L224;
                                                                                                                                                        }
                                                                                                                                                        _v36 = _v36 + 1;
                                                                                                                                                        __eflags = _v36 - argc;
                                                                                                                                                        if(_v36 >= argc) {
                                                                                                                                                            fusage(__imp__stderr, 1);
                                                                                                                                                        }
                                                                                                                                                        _v76 = argv[_v36];
                                                                                                                                                        goto L224;
                                                                                                                                                    }
                                                                                                                                                    goto L160;
                                                                                                                                                }
                                                                                                                                                use_proxy = 0;
                                                                                                                                                goto L224;
                                                                                                                                            }
                                                                                                                                            showLineNum = 1;
                                                                                                                                            goto L224;
                                                                                                                                        }
                                                                                                                                        _v36 = _v36 + 1;
                                                                                                                                        __eflags = _v36 - argc;
                                                                                                                                        if(__eflags >= 0) {
                                                                                                                                            fusage(__imp__stderr, 1);
                                                                                                                                        }
                                                                                                                                         *__esp = argv[_v36];
                                                                                                                                        atof();
                                                                                                                                        _v124 = _t1697;
                                                                                                                                        _t1697 =  *135040592;
                                                                                                                                        asm("fxch st0, st1");
                                                                                                                                        asm("fucomip st0, st1");
                                                                                                                                        st0 = _t1697;
                                                                                                                                        __eflags = __eflags >= 0;
                                                                                                                                        if(__eflags != 0) {
                                                                                                                                            _t1697 =  *135040608;
                                                                                                                                            asm("fucomip st0, st1");
                                                                                                                                            st0 = _t1697;
                                                                                                                                            if(__eflags != 0) {
                                                                                                                                                _t1697 = _v124;
                                                                                                                                                pixel_per_line = _t1697;
                                                                                                                                                set_pixel_per_line = 1;
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                        goto L224;
                                                                                                                                    }
                                                                                                                                    _v36 = _v36 + 1;
                                                                                                                                    __eflags = _v36 - argc;
                                                                                                                                    if(__eflags >= 0) {
                                                                                                                                        fusage(__imp__stderr, 1);
                                                                                                                                    }
                                                                                                                                     *__esp = argv[_v36];
                                                                                                                                    atof();
                                                                                                                                    _v116 = _t1697;
                                                                                                                                    _t1697 =  *135040592;
                                                                                                                                    asm("fxch st0, st1");
                                                                                                                                    asm("fucomip st0, st1");
                                                                                                                                    st0 = _t1697;
                                                                                                                                    __eflags = __eflags >= 0;
                                                                                                                                    if(__eflags != 0) {
                                                                                                                                        _t1697 =  *135040600;
                                                                                                                                        asm("fucomip st0, st1");
                                                                                                                                        st0 = _t1697;
                                                                                                                                        if(__eflags != 0) {
                                                                                                                                            _t1697 = _v116;
                                                                                                                                            pixel_per_char = _t1697;
                                                                                                                                            set_pixel_per_char = 1;
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                    goto L224;
                                                                                                                                }
                                                                                                                                _v36 = _v36 + 1;
                                                                                                                                __eflags = _v36 - argc;
                                                                                                                                if(_v36 >= argc) {
                                                                                                                                    fusage(__imp__stderr, 1);
                                                                                                                                }
                                                                                                                                _t1148 = argv[_v36];
                                                                                                                                 *__esp = _t1148;
                                                                                                                                atoi();
                                                                                                                                COLS = _t1148;
                                                                                                                                goto L224;
                                                                                                                            }
                                                                                                                            w3m_backend = 1;
                                                                                                                            _v36 = _v36 + 1;
                                                                                                                            __eflags = _v36 - argc;
                                                                                                                            if(_v36 >= argc) {
                                                                                                                                fusage(__imp__stderr, 1);
                                                                                                                            }
                                                                                                                            __eflags = backend_batch_commands;
                                                                                                                            if(backend_batch_commands == 0) {
                                                                                                                                backend_batch_commands = newGeneralList();
                                                                                                                            }
                                                                                                                            pushValue(backend_batch_commands, allocStr(argv[_v36], -1));
                                                                                                                            goto L224;
                                                                                                                        }
                                                                                                                        w3m_backend = 1;
                                                                                                                        goto L224;
                                                                                                                    }
                                                                                                                    w3m_dump = 0;
                                                                                                                    w3m_halfload = 1;
                                                                                                                    _v72 = "text/html";
                                                                                                                    DefaultType = _v72;
                                                                                                                    goto L224;
                                                                                                                }
                                                                                                                w3m_dump = 16;
                                                                                                                goto L224;
                                                                                                            }
                                                                                                            w3m_dump = 14;
                                                                                                            goto L224;
                                                                                                        }
                                                                                                        w3m_dump = 6;
                                                                                                        goto L224;
                                                                                                    }
                                                                                                    w3m_dump = 2;
                                                                                                    goto L224;
                                                                                                }
                                                                                                w3m_dump = 4;
                                                                                                goto L224;
                                                                                            }
                                                                                            w3m_dump = 1;
                                                                                            goto L224;
                                                                                        }
                                                                                        __eflags = WrapDefault;
                                                                                        if(WrapDefault == 0) {
                                                                                            WrapDefault = 1;
                                                                                        } else {
                                                                                            WrapDefault = 0;
                                                                                        }
                                                                                        goto L224;
                                                                                    }
                                                                                    RenderFrame = 1;
                                                                                    goto L224;
                                                                                }
                                                                                _v36 = _v36 + 1;
                                                                                __eflags = _v36 - argc;
                                                                                if(_v36 >= argc) {
                                                                                    fusage(__imp__stderr, 1);
                                                                                }
                                                                                BookmarkFile = argv[_v36];
                                                                                __eflags = ( *BookmarkFile & 255) - 126;
                                                                                if(( *BookmarkFile & 255) == 126) {
                                                                                    goto L224;
                                                                                } else {
                                                                                    __eflags = ( *BookmarkFile & 255) - 47;
                                                                                    if(( *BookmarkFile & 255) == 47) {
                                                                                        goto L224;
                                                                                    }
                                                                                    _v88 = Strnew_charp(CurrentDir);
                                                                                    _t1172 = _v88;
                                                                                    __eflags = _t1172->length;
                                                                                    if(_t1172->length <= 0) {
L106:
                                                                                        _t1175 = _v88->length;
                                                                                        _t1176 = _v88;
                                                                                        __eflags = _t1175 + 1 - _t1176->area_size;
                                                                                        if(_t1175 + 1 >= _t1176->area_size) {
                                                                                            Strgrow(_v88);
                                                                                        }
                                                                                        _t1180 = _v88->length;
                                                                                        ( *_v88)[_t1180] = 47;
                                                                                        _v88->length = _t1180 + 1;
                                                                                        ( *_v88)[_v88->length] = 0;
L109:
                                                                                        Strcat_charp(_v88, BookmarkFile);
                                                                                        BookmarkFile = cleanupName( *_v88);
                                                                                        goto L224;
                                                                                    }
                                                                                    _t1625 =  *_v88;
                                                                                    _t1195 = _v88->length - 1;
                                                                                    __eflags = (_t1625[_t1195] & 255) - 47;
                                                                                    if((_t1625[_t1195] & 255) == 47) {
                                                                                        goto L109;
                                                                                    }
                                                                                    goto L106;
                                                                                }
                                                                            }
                                                                            _v60 = 1;
                                                                            goto L224;
                                                                        }
                                                                        useColor = 0;
                                                                        goto L224;
                                                                    }
                                                                    _v68 = 1;
                                                                    goto L224;
                                                                }
                                                                _v64 = 1;
                                                                goto L224;
                                                            }
                                                            _v22 = 1;
                                                            SearchHeader = _v22 & 255;
                                                            goto L224;
                                                        }
                                                        _v36 = _v36 + 1;
                                                        __eflags = _v36 - argc;
                                                        if(_v36 >= argc) {
                                                            fusage(__imp__stderr, 1);
                                                        }
                                                        _v72 = argv[_v36];
                                                        DefaultType = _v72;
                                                        goto L224;
                                                    }
                                                    UseGraphicChar = 0;
                                                } else {
                                                    UseGraphicChar = 1;
                                                }
                                            } else {
                                                __eflags = argv[_v36][2] & 255;
                                                if((argv[_v36][2] & 255) == 0) {
                                                    _v36 = _v36 + 1;
                                                    __eflags = _v36 - argc;
                                                    if(_v36 >= argc) {
                                                        fusage(__imp__stderr, 1);
                                                    }
                                                    _t1216 =  &(argv[_v36]);
                                                    __eflags = _t1216;
                                                    _v32 =  *_t1216;
                                                } else {
                                                    _v32 =  &(argv[_v36][2]);
                                                }
                                                DisplayCharset = wc_guess_charset_short(_v32, DisplayCharset);
                                            }
                                        } else {
                                            __eflags = argv[_v36][2] & 255;
                                            if((argv[_v36][2] & 255) == 0) {
                                                _v36 = _v36 + 1;
                                                __eflags = _v36 - argc;
                                                if(_v36 >= argc) {
                                                    fusage(__imp__stderr, 1);
                                                }
                                                _t1236 =  &(argv[_v36]);
                                                __eflags = _t1236;
                                                _v32 =  *_t1236;
                                            } else {
                                                _v32 =  &(argv[_v36][2]);
                                            }
                                            DocumentCharset = wc_guess_charset_short(_v32, DocumentCharset);
                                            WcOption.auto_detect = 0;
                                            UseContentCharset = 0;
                                        }
                                    } else {
                                        _v36 = _v36 + 1;
                                        __eflags = _v36 - argc;
                                        if(_v36 >= argc) {
                                            fusage(__imp__stderr, 1);
                                        }
                                        _t1251 = argv[_v36];
                                         *__esp = _t1251;
                                        atoi();
                                        __eflags = _t1251;
                                        if(_t1251 > 0) {
                                            _t1255 = argv[_v36];
                                             *__esp = _t1255;
                                            atoi();
                                            PagerMax = _t1255;
                                        }
                                    }
                                } else {
                                    ShowEffect = 0;
                                }
                            } else {
                                _v36 = _v36 + 1;
                                __eflags = _v36 - argc;
                                if(_v36 >= argc) {
                                    fusage(__imp__stderr, 1);
                                }
                                _t1261 = argv[_v36];
                                 *__esp = _t1261;
                                atoi();
                                __eflags = _t1261;
                                if(_t1261 > 0) {
                                    _t1265 = argv[_v36];
                                     *__esp = _t1265;
                                    atoi();
                                    Tabstop = _t1265;
                                }
                            }
                            goto L224;
                        }
                        FirstTab = 0;
                        LastTab = 0;
                        nTab = 0;
                        CurrentTab = 0;
                        CurrentKey = -1;
                        _t1267 = BookmarkFile;
                        if(_t1267 == 0) {
                            _t1267 = rcFile("bookmark.html");
                            BookmarkFile = _t1267;
                        }
                         *__esp = 1;
                        isatty();
                        if(_t1267 == 0 && w3m_dump == 0) {
                            w3m_dump = 1;
                        }
                        if(w3m_dump != 0 && COLS == 0) {
                            COLS = 80;
                        }
                        if(w3m_dump != 0 || w3m_backend != 0) {
                            __eflags = w3m_dump & 16;
                            if((w3m_dump & 16) != 0) {
                                __eflags = displayImage;
                                if(displayImage != 0) {
                                    activeImage = 1;
                                }
                            }
                        } else {
                            fmInit();
                            mySignal(28, resize_hook);
                        }
                        sync_with_option();
                        initCookie();
                        if(UseHistory != 0) {
                            loadHistory(URLHist);
                        }
                        wtf_init(DocumentCharset, DisplayCharset);
                        if(w3m_backend != 0) {
                            backend();
                        }
                        if(w3m_dump != 0) {
                            mySignal(2, 1);
                        }
                        mySignal(17, sig_chld);
                        _t1277 = mySignal(13, SigPipe);
                         *__esp = wrap_GC_warn_proc;
                        GC_set_warn_proc();
                        orig_GC_warn_proc = _t1277;
                        _t1278 = Strnew();
                        _v80 = _t1278;
                        if(_v56 != 0) {
                            _v36 = 0;
                            goto L324;
                        } else {
                             *__esp = 0;
                            isatty();
                            if(_t1278 != 0) {
                                __eflags = _v60;
                                if(_v60 == 0) {
                                    __eflags = _v64;
                                    if(_v64 == 0) {
                                         *__esp = "HTTP_HOME";
                                        getenv();
                                        _v32 = _t1278;
                                        __eflags = _v32;
                                        if(_v32 != 0) {
L259:
                                            _v148 = 0;
                                            _v152 = 0;
                                            _v28 = loadGeneralFile(_v32, 0, -1);
                                            __eflags = _v28;
                                            if(_v28 != 0) {
                                                __eflags = _v28 - 1;
                                                if(_v28 != 1) {
                                                    pushHashHist(URLHist,  *(parsedURL2Str( &(_v28->currentURL))));
                                                }
                                            } else {
                                                _v160 = _v32;
                                                Strcat(_v80, Sprintf("w3m: Can't load %s.\n"));
                                            }
L267:
                                            if(_v28 == 0) {
                                                if((fmInitialized & 255) != 0) {
                                                    fmTerm();
                                                }
                                                if(_v80->length != 0) {
                                                    _v160 = __imp__stderr;
                                                     *__esp =  *_v80;
                                                    fputs();
                                                }
                                                w3m_exit(2);
                                            }
                                            _v36 = -1;
L324:
                                            while(_v36 < _v56) {
                                                __eflags = _v36;
                                                if(_v36 < 0) {
                                                    __eflags = _v28 - 1;
                                                    if(_v28 == 1) {
L323:
                                                        _v36 = _v36 + 1;
                                                        __eflags = _v36;
                                                        continue;
                                                    }
L302:
                                                    _t1280 = _v28;
                                                    __eflags = _t1280->pagerSource;
                                                    if(_t1280->pagerSource != 0) {
L307:
                                                        _v28->search_header = _v22 & 255;
L308:
                                                        __eflags = CurrentTab;
                                                        if(CurrentTab != 0) {
                                                            __eflags = _v68;
                                                            if(_v68 == 0) {
                                                                CurrentTab->currentBuffer->nextBuffer = _v28;
                                                                CurrentTab->currentBuffer = _v28;
                                                            } else {
                                                                _newT();
                                                                CurrentTab->currentBuffer->nextBuffer = _v28;
                                                                delBuffer(CurrentTab->currentBuffer);
                                                            }
                                                        } else {
                                                            CurrentTab = newTab();
                                                            LastTab = CurrentTab;
                                                            FirstTab = LastTab;
                                                            nTab = 1;
                                                            _t1304 = CurrentTab;
                                                            _t1304->currentBuffer = _v28;
                                                            CurrentTab->firstBuffer = _t1304->currentBuffer;
                                                        }
                                                        __eflags = w3m_dump;
                                                        if(w3m_dump == 0) {
L315:
                                                            _t1289 = CurrentTab->currentBuffer;
                                                            __eflags = _t1289->frameset;
                                                            if(_t1289->frameset != 0) {
                                                                __eflags = RenderFrame & 255;
                                                                if((RenderFrame & 255) != 0) {
                                                                    rFrame();
                                                                }
                                                            }
                                                            goto L318;
                                                        } else {
                                                            __eflags = w3m_dump - 1;
                                                            if(w3m_dump != 1) {
L318:
                                                                __eflags = w3m_dump;
                                                                if(w3m_dump == 0) {
                                                                    CurrentTab->currentBuffer = _v28;
                                                                } else {
                                                                    do_dump(CurrentTab->currentBuffer);
                                                                }
                                                                goto L323;
                                                            }
                                                            goto L315;
                                                        }
                                                    }
                                                    _t1306 = _v28;
                                                    __eflags = _t1306->real_scheme - 4;
                                                    if(_t1306->real_scheme != 4) {
                                                        goto L308;
                                                    }
                                                    _t1308 = _v28;
                                                    __eflags = _t1308->header_source;
                                                    if(_t1308->header_source == 0) {
                                                        goto L308;
                                                    }
                                                    _t1310 = _v28;
                                                    __eflags = _t1310->currentURL.file;
                                                    if(_t1310->currentURL.file == 0) {
                                                        goto L308;
                                                    }
                                                    _t1313 = _v28->currentURL.file;
                                                    _v160 = 135037599;
                                                     *__esp = _t1313;
                                                    strcmp();
                                                    __eflags = _t1313;
                                                    if(_t1313 == 0) {
                                                        goto L308;
                                                    }
                                                    goto L307;
                                                }
                                                SearchHeader = _v22 & 255;
                                                DefaultType = _v72;
                                                _t1316 = w3m_dump;
                                                __eflags = _t1316 - 2;
                                                if(_t1316 != 2) {
                                                    __eflags = _v76;
                                                    if(_v76 == 0) {
L288:
                                                        _v52 = 0;
L289:
                                                        _t1319 = (_v36 << 2) + _v48;
                                                        __eflags = _t1319;
                                                        _v148 = _v52;
                                                        _v152 = 0;
                                                        _v28 = loadGeneralFile( *_t1319, 0, -1);
L290:
                                                        __eflags = _v28;
                                                        if(_v28 != 0) {
                                                            __eflags = _v28 - 1;
                                                            if(_v28 == 1) {
                                                                goto L323;
                                                            }
                                                            _t1323 = _v28->real_scheme;
                                                            __eflags = _t1323 - 4;
                                                            if(_t1323 < 4) {
L298:
                                                                pushHashHist(URLHist,  *(parsedURL2Str( &(_v28->currentURL))));
                                                                goto L302;
                                                            }
                                                            __eflags = _t1323 - 5;
                                                            if(_t1323 <= 5) {
                                                                _t1331 = (_v36 << 2) + _v48;
                                                                __eflags = _t1331;
                                                                unshiftHist(LoadHist,  *(wc_Str_conv(Strnew_charp( *_t1331), SystemCharset, InnerCharset)));
                                                                goto L298;
                                                            }
                                                            __eflags = _t1323 - 12;
                                                            if(_t1323 == 12) {
                                                                goto L302;
                                                            }
                                                            goto L298;
                                                        }
                                                        _v160 =  *((_v36 << 2) + _v48);
                                                        Strcat(_v80, Sprintf("w3m: Can't load %s.\n"));
                                                        goto L323;
                                                    }
                                                    __eflags = _v36;
                                                    if(_v36 != 0) {
                                                        goto L288;
                                                    }
                                                    _v160 = 135037599;
                                                    _t1343 = _v76;
                                                     *__esp = _t1343;
                                                    strcmp();
                                                    __eflags = _t1343;
                                                    if(_t1343 != 0) {
                                                        _t1344 = _v76;
                                                        _v160 = 135037601;
                                                         *__esp = _t1344;
                                                        fopen();
                                                        _v100 = _t1344;
                                                    } else {
                                                        _v100 = __imp__stdin;
                                                    }
                                                    __eflags = _v100;
                                                    if(_v100 != 0) {
                                                        _v104 = Strfgetall(_v100);
                                                        __eflags = _v100 - __imp__stdin;
                                                        if(_v100 != __imp__stdin) {
                                                             *__esp = _v100;
                                                            fclose();
                                                        }
                                                        _v52 = newFormList(0, "post", 0, 0, 0, 0, 0);
                                                        _v52->body =  *_v104;
                                                        _v52->boundary = 0;
                                                        _v52->length = _v104->length;
                                                        goto L289;
                                                    } else {
                                                        _v160 = _v76;
                                                        Strcat(_v80, Sprintf("w3m: Can't open %s.\n"));
                                                        goto L323;
                                                    }
                                                }
                                                 *__esp = 52;
                                                GC_malloc();
                                                _v52 = _t1316;
                                                _v52->method = 3;
                                                _v148 = _v52;
                                                _v152 = 0;
                                                _v28 = loadGeneralFile( *((_v36 << 2) + _v48), 0, -1);
                                                goto L290;
                                            }
                                            if(w3m_dump != 0) {
                                                if(_v80->length != 0) {
                                                    _v160 = __imp__stderr;
                                                     *__esp =  *_v80;
                                                    fputs();
                                                }
                                                save_cookies();
                                                w3m_exit(0);
                                            }
                                            if(add_download_list == 0) {
                                                CurrentTab = FirstTab;
                                            } else {
                                                add_download_list = 0;
                                                CurrentTab = LastTab;
                                                if(FirstTab == 0) {
                                                    CurrentTab = newTab();
                                                    LastTab = CurrentTab;
                                                    FirstTab = LastTab;
                                                    nTab = 1;
                                                }
                                                if(CurrentTab->firstBuffer == 0 || CurrentTab->firstBuffer == 1) {
                                                    _t1627 = CurrentTab;
                                                    _t1569 = CurrentTab;
                                                    _t1602 = COLS;
                                                    if(showLineNum == 0) {
                                                        _t1487 = 1;
                                                    } else {
                                                        _t1487 = 6;
                                                    }
                                                    _t1488 = _t1602 - _t1487;
                                                    _t1489 = _t1488 < 0 ? 0 : _t1488;
                                                    _t1569->currentBuffer = newBuffer(_t1488 < 0 ? 0 : _t1488);
                                                    _t1627->firstBuffer = _t1569->currentBuffer;
                                                    CurrentTab->currentBuffer->bufferprop = 24;
                                                    CurrentTab->currentBuffer->buffername = "Download List Panel";
                                                } else {
                                                    CurrentTab->currentBuffer = CurrentTab->firstBuffer;
                                                }
                                                ldDL();
                                            }
                                            if(FirstTab == 0 || CurrentTab->firstBuffer == 0 || CurrentTab->firstBuffer == 1) {
                                                if(_v28 == 1 && (fmInitialized & 255) != 0) {
                                                    inputLineHistSearch("Hit any key to quit w3m:", 135036496, 512, 0, 0);
                                                }
                                                if((fmInitialized & 255) != 0) {
                                                    fmTerm();
                                                }
                                                if(_v80->length != 0) {
                                                    _v160 = __imp__stderr;
                                                     *__esp =  *_v80;
                                                    fputs();
                                                }
                                                if(_v28 == 1) {
                                                    save_cookies();
                                                    if(_v80->length == 0) {
                                                        w3m_exit(0);
                                                    }
                                                }
                                                w3m_exit(2);
                                            }
                                            if(_v80->length != 0) {
                                                disp_message_nsec( *_v80, 0, 1, 1, 0);
                                            }
                                            SearchHeader = 0;
                                            DefaultType = 0;
                                            UseContentCharset = 1;
                                            WcOption.auto_detect = _v23 & 255;
                                            CurrentTab->currentBuffer = CurrentTab->firstBuffer;
                                            displayBuffer(CurrentTab->currentBuffer, 1);
                                            if(_v44 != 0) {
                                                _goLine(_v44);
                                            }
L359:
L359:
                                            if(add_download_list != 0) {
                                                add_download_list = 0;
                                                ldDL();
                                            }
                                            if(CurrentTab->currentBuffer->submit == 0) {
                                                goto L363;
                                            }
                                            _v108 = CurrentTab->currentBuffer->submit;
                                            CurrentTab->currentBuffer->submit = 0;
                                            gotoLine(CurrentTab->currentBuffer, _v108->start);
                                            CurrentTab->currentBuffer->pos = _v108->start.pos;
                                            _followForm(1);
L403:
                                            goto L359;
L363:
                                            __eflags = CurrentEvent;
                                            if(CurrentEvent == 0) {
                                                _t1385 = CurrentTab->currentBuffer;
                                                __eflags = _t1385->event;
                                                if(_t1385->event == 0) {
L370:
                                                    _t1388 = CurrentTab->currentBuffer;
                                                    __eflags = _t1388->event;
                                                    if(_t1388->event == 0) {
                                                        CurrentAlarm =  &DefaultAlarm;
                                                    }
                                                     *135792272 = 0;
                                                    __eflags = use_mouse;
                                                    if(use_mouse != 0) {
                                                        mouse_active();
                                                    }
                                                    __eflags = CurrentAlarm->sec;
                                                    if(CurrentAlarm->sec > 0) {
                                                        mySignal(14, SigAlarm);
                                                         *__esp = CurrentAlarm->sec;
                                                        alarm();
                                                    }
                                                    mySignal(28, resize_hook);
                                                    __eflags = activeImage;
                                                    if(activeImage == 0) {
L384:
                                                        _t1394 = need_resize_screen;
                                                        __eflags = _t1394;
                                                        if(_t1394 != 0) {
                                                            resize_screen();
                                                        }
                                                        sleep_till_anykey(1, 0);
                                                        __eflags = _t1394;
                                                    } else {
                                                        __eflags = displayImage;
                                                        if(displayImage == 0) {
                                                            do {
                                                                goto L384;
                                                            } while(_t1394 <= 0);
L387:
                                                            do_getch();
                                                            _v21 = _t1394;
                                                            __eflags = CurrentAlarm->sec;
                                                            if(CurrentAlarm->sec > 0) {
                                                                 *__esp = 0;
                                                                alarm();
                                                            }
                                                            __eflags = use_mouse;
                                                            if(use_mouse != 0) {
                                                                mouse_inactive();
                                                            }
                                                            _t1399 = _v21 & 0xff;
                                                            __eflags =  *( &MYCTYPE_MAP + _t1399) & 0x11;
                                                            if(( *( &MYCTYPE_MAP + _t1399) & 0x11) == 0) {
L402:
                                                                prev_key = CurrentKey;
                                                                CurrentKey = -1;
                                                                CurrentKeyData = 0;
                                                                goto L359;
                                                            } else {
                                                                __eflags = vi_prec_num;
                                                                if(vi_prec_num == 0) {
                                                                    set_buffer_environ(CurrentTab->currentBuffer);
                                                                    save_buffer_position(CurrentTab->currentBuffer);
                                                                    keyPressEventProc(_v21);
                                                                    prec_num = 0;
                                                                    goto L402;
                                                                }
                                                                __eflags = prec_num;
                                                                if(prec_num == 0) {
L395:
                                                                    __eflags = _v21 - 48;
                                                                    if(_v21 <= 48) {
L399:
                                                                        set_buffer_environ(CurrentTab->currentBuffer);
                                                                        save_buffer_position(CurrentTab->currentBuffer);
                                                                        keyPressEventProc(_v21);
                                                                        prec_num = 0;
                                                                        goto L402;
                                                                    }
L396:
                                                                    __eflags = _v21 - 57;
                                                                    if(_v21 > 57) {
                                                                        goto L399;
                                                                    }
                                                                    prec_num = (prec_num << 2) + prec_num + (prec_num << 2) + prec_num + _v21 - 48;
                                                                    __eflags = prec_num - 10000;
                                                                    if(prec_num > 10000) {
                                                                        prec_num = 10000;
                                                                    }
                                                                    goto L402;
                                                                }
                                                                __eflags = _v21 - 48;
                                                                if(_v21 == 48) {
                                                                    goto L396;
                                                                }
                                                                goto L395;
                                                            }
                                                        }
                                                        _t1424 = CurrentTab->currentBuffer;
                                                        __eflags = _t1424->img;
                                                        if(_t1424->img == 0) {
                                                            goto L384;
                                                        }
                                                        _t1427 = CurrentTab->currentBuffer;
                                                        __eflags = _t1427->image_loaded & 255;
                                                        if((_t1427->image_loaded & 255) != 0) {
                                                            goto L384;
                                                        } else {
                                                            goto L380;
                                                        }
                                                        do {
L380:
                                                            __eflags = need_resize_screen;
                                                            if(need_resize_screen != 0) {
                                                                resize_screen();
                                                            }
                                                            _t1394 = CurrentTab->currentBuffer;
                                                            loadImage(_t1394, 2);
                                                            sleep_till_anykey(1, 0);
                                                            __eflags = _t1394;
                                                        } while(_t1394 <= 0);
                                                        goto L387;
                                                    }
                                                }
                                                _t1435 = CurrentTab->currentBuffer->event;
                                                __eflags = _t1435->status & 65535;
                                                if((_t1435->status & 65535) == 0) {
                                                    CurrentTab->currentBuffer->event = 0;
                                                    goto L370;
                                                }
                                                CurrentAlarm = CurrentTab->currentBuffer->event;
                                                __eflags = CurrentAlarm->sec;
                                                if(CurrentAlarm->sec != 0) {
                                                    goto L370;
                                                }
                                                CurrentTab->currentBuffer->event = 0;
                                                CurrentKey = -1;
                                                CurrentKeyData = 0;
                                                CurrentCmdData = CurrentAlarm->data;
                                                 *((intOrPtr*)( *((intOrPtr*)(135103140 + CurrentAlarm->cmd * 8))))();
                                                CurrentCmdData = 0;
                                                goto L403;
                                            }
                                            CurrentKey = -1;
                                            CurrentKeyData = 0;
                                            CurrentCmdData = CurrentEvent->data;
                                             *((intOrPtr*)( *((intOrPtr*)(135103140 + CurrentEvent->cmd * 8))))();
                                            CurrentCmdData = 0;
                                            CurrentEvent = CurrentEvent->next;
                                            goto L403;
                                        }
                                         *__esp = "WWW_HOME";
                                        getenv();
                                        _v32 = _t1278;
                                        __eflags = _v32;
                                        if(_v32 == 0) {
                                            __eflags = fmInitialized & 255;
                                            if((fmInitialized & 255) != 0) {
                                                fmTerm();
                                            }
                                            fusage(__imp__stderr, 1);
                                            goto L267;
                                        }
                                        goto L259;
                                    }
                                    _v96 = Strnew_charp("<title>W3M startup page</title><center><b>Welcome to ");
                                    Strcat_charp(_v96, "<a href='http://w3m.sourceforge.net/'>");
                                    _v148 = 0;
                                    _v152 = "<br>Written by <a href='mailto:aitofw.ipsj.or.jp'>Akinori Ito</a>";
                                    _v156 = w3m_version;
                                    _v160 = "w3m</a>!<p><p>This is w3m version ";
                                    Strcat_m_charp(_v96);
                                    _v152 = 0;
                                    _v156 = "You can read <a href='file:///usr/share/doc/w3m/'>w3m documents on your local system</a>.";
                                    _v160 = "<p>Debian package is maintained by <a href='mailto:ukaidebian.or.jp'>Fumitoshi UKAI</a>.";
                                    Strcat_m_charp(_v96);
                                    _v28 = loadHTMLString(_v96);
                                    __eflags = _v28;
                                    if(_v28 != 0) {
                                        __eflags = _v28 - 1;
                                        if(_v28 != 1) {
                                            _v28->bufferprop = _v28->bufferprop & 65535 | 24;
                                        }
                                    } else {
                                        Strcat_charp(_v80, "w3m: Can't load string.\n");
                                    }
                                    goto L267;
                                }
                                _v148 = 0;
                                _v152 = 0;
                                _v28 = loadGeneralFile(BookmarkFile, 0, -1);
                                __eflags = _v28;
                                if(_v28 == 0) {
                                    Strcat_charp(_v80, "w3m: Can't load bookmark.\n");
                                }
                                goto L267;
                            }
                             *__esp = 0;
                            dup();
                            _v160 = "rb";
                             *__esp = _t1278;
                            fdopen();
                            _v40 = newFileStream(_t1278, pclose);
                            _v28 = openGeneralPagerBuffer(_v40);
                            _v160 = 0;
                             *__esp = 1;
                            dup2();
                            goto L267;
                        }
                    }
                     *__esp = "NO_PROXY";
                    getenv();
                    _v32 = _t826;
                    if(_v32 != 0) {
L40:
                        NO_proxy = _v32;
                        goto L41;
                    }
                     *__esp = "no_proxy";
                    getenv();
                    _v32 = _t826;
                    if(_v32 != 0) {
                        goto L40;
                    }
                     *__esp = "NO_proxy";
                    getenv();
                    _v32 = _t826;
                    if(_v32 == 0) {
                        goto L41;
                    }
                    goto L40;
                }
                 *__esp = "FTP_PROXY";
                getenv();
                _v32 = _t824;
                if(_v32 != 0) {
L35:
                    FTP_proxy = _v32;
                    goto L36;
                }
                 *__esp = "ftp_proxy";
                getenv();
                _v32 = _t824;
                if(_v32 != 0) {
                    goto L35;
                }
                 *__esp = "FTP_proxy";
                getenv();
                _v32 = _t824;
                if(_v32 == 0) {
                    goto L36;
                }
                goto L35;
            }
             *__esp = "GOPHER_PROXY";
            getenv();
            _v32 = _t822;
            if(_v32 != 0) {
L30:
                GOPHER_proxy = _v32;
                goto L31;
            }
             *__esp = "gopher_proxy";
            getenv();
            _v32 = _t822;
            if(_v32 != 0) {
                goto L30;
            }
             *__esp = "GOPHER_proxy";
            getenv();
            _v32 = _t822;
            if(_v32 == 0) {
                goto L31;
            }
            goto L30;
        }
         *__esp = "HTTP_PROXY";
        getenv();
        _v32 = _t820;
        if(_v32 != 0) {
L25:
            HTTP_proxy = _v32;
            goto L26;
        }
         *__esp = "http_proxy";
        getenv();
        _v32 = _t820;
        if(_v32 != 0) {
            goto L25;
        }
         *__esp = "HTTP_proxy";
        getenv();
        _v32 = _t820;
        if(_v32 == 0) {
            goto L26;
        }
        goto L25;
    }
     *__esp = "LC_CTYPE";
    getenv();
    _v84 = _t801;
    _t1565 = non_null(_v84);
    if(_t1565 != 0) {
        goto L17;
    }
     *__esp = "LANG";
    getenv();
    _v84 = _t1565;
    if(non_null(_v84) == 0) {
        goto L18;
    }
    goto L17;
}

void keyPressEventProc(int c)
{// addr = 0x0804D821  --  defined in 'main.c' at line 1182
    CurrentKey = c;
     *((intOrPtr*)( *((intOrPtr*)(135103140 + ( *( &GlobalKeymap + c) & 0xff) * 8))))();
}

void pushEvent(int cmd, _Unknown_base* data)
{// addr = 0x0804D847  --  defined in 'main.c' at line 1189
    Event* event;        // _cfa_fffffff0

     *__esp = 12;
    GC_malloc();
    event = __eax;
    event->cmd = cmd;
    event->data = data;
    event->next = 0;
    if(CurrentEvent == 0) {
        CurrentEvent = event;
    } else {
        LastEvent->next = event;
    }
    LastEvent = event;
}

void dump_source(Buffer* buf)
{// addr = 0x0804D89F  --  defined in 'main.c' at line 1205
    char c;                                // _cfa_fffffff3
    FILE* f;              // _cfa_ffffffec
    intOrPtr _v40;                         // _cfa_ffffffd8
    FILE* _t16;           // _t16

    if(buf->sourcefile != 0) {
        _t16 = buf->sourcefile;
        _v40 = 135037601;
         *__esp = _t16;
        fopen();
        f = _t16;
        if(f != 0) {
            while(1) {
                __eax = f;
                 *__esp = f;
                fgetc();
                c = __al;
                __eax = f;
                 *__esp = __eax;
                feof();
                if(__eax != 0) {
                    break;
                }
                __eax = c;
                 *__esp = c;
                putchar();
            }
            __eax = f;
             *__esp = f;
            fclose();
            return;
        }
        return;
    }
}

void dump_head(Buffer* buf)
{// addr = 0x0804D913  --  defined in 'main.c' at line 1221
    TextListItem* ti;   // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)

    if(buf->document_header != 0) {
        ti = buf->document_header->first;
        while(ti != 0) {
            _v40 =  *(wc_Str_conv_strict(Strnew_charp(ti->ptr), InnerCharset, buf->document_charset));
             *__esp = "%s";
            printf();
            ti = ti->next;
        }
         *__esp = 135036496;
        puts();
        return;
    }
    if((w3m_dump & 8) != 0) {
         *__esp = 10;
        putchar();
        return;
    }
}

void dump_extra(Buffer* buf)
{// addr = 0x0804D9B6  --  defined in 'main.c' at line 1243
    char* _v24;                            // _cfa_ffffffe8

    _v24 =  *(parsedURL2Str( &(buf->currentURL)));
     *__esp = "W3m-current-url: %s\n";
    printf();
    if(buf->baseURL != 0) {
        _v24 =  *(parsedURL2Str(buf->baseURL));
         *__esp = "W3m-base-url: %s\n";
        printf();
    }
    _v24 = wc_ces_to_charset(buf->document_charset);
     *__esp = "W3m-document-charset: %s\n";
    printf();
}

void do_dump(Buffer* buf)
{// addr = 0x0804DA34  --  defined in 'main.c' at line 1272
    _None prevtrap;                        // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    _None _t15;                            // _t15

    prevtrap = 0;
    _t15 = mySignal(2, intTrap);
    prevtrap = _t15;
    _v40 = 1;
     *__esp =  &IntReturn;
    __sigsetjmp();
    if(_t15 == 0) {
        if((w3m_dump & 8) != 0) {
            dump_extra(buf);
        }
        if((w3m_dump & 2) != 0) {
            dump_head(buf);
        }
        if((w3m_dump & 4) != 0) {
            dump_source(buf);
        }
        if(w3m_dump == 1) {
            saveBuffer(buf, __imp__stdout, 0);
        }
        mySignal(2, prevtrap);
        return;
    }
    mySignal(2, prevtrap);
}

void nulcmd()
{// addr = 0x0804DB05  --  defined in 'main.c' at line 1292

}

void pcmap()
{// addr = 0x0804DB0A  --  defined in 'main.c' at line 1303

}

void escKeyProc(int c, int esc, unsigned char* map)
{// addr = 0x0804DB0F  --  defined in 'main.c' at line 1309
    unsigned char** mmap;                  // _cfa_fffffff0
    int _t34;                              // _t34

    if(CurrentKey < 0 || (CurrentKey & 268435456) == 0) {
L12:
        CurrentKey = c | esc;
         *((intOrPtr*)( *((intOrPtr*)(135103140 + (map[c] & 0xff) * 8))))();
        return;
    } else {
        mmap = getKeyData(CurrentKey >> 16 & 1919);
        if(mmap == 0) {
            return;
        }
        _t34 = esc;
        if(_t34 == 512) {
            map = mmap[2];
        } else {
            if(_t34 == 1024) {
                map = mmap[3];
            } else {
                if(_t34 == 256) {
                    map = mmap[1];
                } else {
                    map =  *mmap;
                }
            }
        }
        esc = esc;
        goto L12;
    }
}

void escmap()
{// addr = 0x0804DBCA  --  defined in 'main.c' at line 1336
    char c;                                // _cfa_fffffff3
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    c = do_getch();
    if(( *( &MYCTYPE_MAP + (c & 0xff)) & 0x11) != 0) {
        escKeyProc(c, 256,  &EscKeymap);
        return;
    }
}

void escbmap()
{// addr = 0x0804DC0E  --  defined in 'main.c' at line 1344
    char c;                                // _cfa_fffffff3
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    c = do_getch();
    if(( *( &MYCTYPE_MAP + (c & 0xff)) & 8) != 0) {
        escdmap(c);
        return;
    }
    if(( *( &MYCTYPE_MAP + (c & 0xff)) & 0x11) != 0) {
        escKeyProc(c, 512,  &EscBKeymap);
        return;
    }
}

void escdmap(char c)
{// addr = 0x0804DC78  --  defined in 'main.c' at line 1357
    int d;                                 // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    _v32 = c;
    d = _v32 - 48;
    _v32 = do_getch();
    if(( *( &MYCTYPE_MAP + (_v32 & 0xff)) & 8) != 0) {
        d = (d << 2) + d + (d << 2) + d + _v32 - 48;
        _v32 = do_getch();
    }
    if(_v32 == 126) {
        escKeyProc(d, 1024,  &EscDKeymap);
        return;
    }
}

void multimap()
{// addr = 0x0804DCF4  --  defined in 'main.c' at line 1370
    char c;                                // _cfa_fffffff3
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    c = do_getch();
    if(( *( &MYCTYPE_MAP + (c & 0xff)) & 0x11) != 0) {
        CurrentKey = c | CurrentKey << 16 | 268435456;
        escKeyProc(c, 0, 0);
        return;
    }
}

void tmpClearBuffer(Buffer* buf)
{// addr = 0x0804DD53  --  defined in 'main.c' at line 1381
    if(buf->pagerSource != 0 || writeBufferCache(buf) != 0) {
        return;
    } else {
        buf->firstLine = 0;
        buf->topLine = 0;
        buf->currentLine = 0;
        buf->lastLine = 0;
        return;
    }
}

void pushBuffer(Buffer* buf)
{// addr = 0x0804DD9C  --  defined in 'main.c' at line 1410
    Buffer* b;          // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    TabBuffer* _t41;   // _t41

    deleteImage(CurrentTab->currentBuffer);
    if(clear_buffer != 0) {
        tmpClearBuffer(CurrentTab->currentBuffer);
    }
    if(CurrentTab->firstBuffer == CurrentTab->currentBuffer) {
        buf->nextBuffer = CurrentTab->firstBuffer;
        _t41 = CurrentTab;
        _t41->currentBuffer = buf;
        CurrentTab->firstBuffer = _t41->currentBuffer;
        return;
    }
    b = prevBuffer(CurrentTab->firstBuffer, CurrentTab->currentBuffer);
    if(b != 0) {
        b->nextBuffer = buf;
        buf->nextBuffer = CurrentTab->currentBuffer;
        CurrentTab->currentBuffer = buf;
        return;
    }
}

void delBuffer(Buffer* buf)
{// addr = 0x0804DE4F  --  defined in 'main.c' at line 1435
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(buf != 0) {
        if(CurrentTab->currentBuffer == buf) {
            CurrentTab->currentBuffer = buf->nextBuffer;
        }
        CurrentTab->firstBuffer = deleteBuffer(CurrentTab->firstBuffer, buf);
        if(CurrentTab->currentBuffer == 0) {
            CurrentTab->currentBuffer = CurrentTab->firstBuffer;
            return;
        }
    }
}

void repBuffer(Buffer* oldbuf, Buffer* buf)
{// addr = 0x0804DEBD  --  defined in 'main.c' at line 1447
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    CurrentTab->firstBuffer = replaceBuffer(CurrentTab->firstBuffer, oldbuf, buf);
    CurrentTab->currentBuffer = buf;
}

void intTrap(int _dummy)
{// addr = 0x0804DEFC  --  defined in 'main.c' at line 1455
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _t3;                         // _t3

    _v24 = 0;
     *__esp =  &IntReturn;
    siglongjmp();
    _push(_t3);
    __esp = __esp - 24;
    need_resize_screen = 1;
    mySignal(28, resize_hook);
}

void resize_hook(int _dummy)
{// addr = 0x0804DF16  --  defined in 'main.c' at line 1463
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    need_resize_screen = 1;
    mySignal(28, resize_hook);
}

void resize_screen()
{// addr = 0x0804DF3C  --  defined in 'main.c' at line 1471
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    need_resize_screen = 0;
    setlinescols();
    setupscreen();
    if(CurrentTab != 0) {
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
}

void SigPipe(int _dummy)
{// addr = 0x0804DF79  --  defined in 'main.c' at line 1483
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    init_migemo();
    mySignal(13, SigPipe);
}

void nscroll(int n, int mode)
{// addr = 0x0804DF9A  --  defined in 'main.c' at line 1498
    Buffer* buf;        // _cfa_fffffff0
    Line* top;            // _cfa_ffffffec
    Line* cur;            // _cfa_ffffffe8
    int lnum;                              // _cfa_ffffffe4
    int tlnum;                             // _cfa_ffffffe0
    int llnum;                             // _cfa_ffffffdc
    int diff_n;                            // _cfa_ffffffd8
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    buf = CurrentTab->currentBuffer;
    top = buf->topLine;
    cur = buf->currentLine;
    if(buf->firstLine == 0) {
        return;
    } else {
        lnum = cur->linenumber;
        buf->topLine = lineSkip(buf, top, n, 0);
        if(buf->topLine != top) {
            tlnum = buf->topLine->linenumber;
            llnum = buf->topLine->linenumber + (buf->LINES & 65535) - 1;
            if(nextpage_topline == 0) {
                diff_n = top->linenumber - tlnum + n;
            } else {
                diff_n = 0;
            }
            if(lnum < tlnum) {
                lnum = tlnum + diff_n;
            }
            if(lnum > llnum) {
                lnum = llnum + diff_n;
            }
        } else {
            lnum = lnum + n;
            if(buf->topLine->linenumber <= lnum) {
                if(buf->lastLine->linenumber < lnum) {
                    lnum = buf->lastLine->linenumber;
                }
            } else {
                lnum = buf->topLine->linenumber;
            }
        }
        gotoLine(buf, lnum);
        arrangeLine(buf);
        if(n <= 0) {
            if(buf->currentLine->bwidth + buf->currentLine->width >= buf->currentColumn + buf->visualpos) {
                while(buf->currentLine->prev != 0 && buf->currentLine->bpos != 0 && buf->currentLine->bwidth >= buf->currentColumn + buf->visualpos) {
                    cursorUp0(buf, 1);
                }
L31:
                displayBuffer(buf, mode);
                return;
            }
            cursorUp(buf, 1);
            goto L31;
        }
        if(buf->currentLine->bpos == 0) {
L20:
            while(buf->currentLine->next != 0 && buf->currentLine->next->bpos != 0) {
                if(buf->currentLine->bwidth + buf->currentLine->width < buf->currentColumn + buf->visualpos) {
                    cursorDown0(buf, 1);
                    continue;
                }
                goto L31;
            }
            goto L31;
        }
        if(buf->currentLine->bwidth < buf->currentColumn + buf->visualpos) {
            goto L20;
        }
        cursorDown(buf, 1);
        goto L31;
    }
}

void pgFore()
{// addr = 0x0804E22A  --  defined in 'main.c' at line 1555
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    int __ebx;                             // r1
    int _t11;                              // _t11

    __eflags = vi_prec_num;
    if(__eflags == 0) {
        __eflags = prec_num;
        if(prec_num == 0) {
            __ebx = 0;
        } else {
            __ebx = 3;
        }
        __eflags = prec_num;
        if(__eflags == 0) {
            _t11 = searchKeyNum() * ((CurrentTab->currentBuffer->LINES & 65535) - 1);
            __eflags = _t11;
        } else {
            _t11 = searchKeyNum();
        }
        nscroll(_t11, __ebx);
        return;
    }
    nscroll(searchKeyNum() * ((CurrentTab->currentBuffer->LINES & 65535) - 1), 0);
}

void pgBack()
{// addr = 0x0804E2B9  --  defined in 'main.c' at line 1565
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    int _t11;                              // _t11
    int _t15;                              // _t15

    __eflags = vi_prec_num;
    if(__eflags == 0) {
        __eflags = prec_num;
        if(prec_num == 0) {
            _t15 = 0;
        } else {
            _t15 = 3;
        }
        __eflags = prec_num;
        if(__eflags == 0) {
            _t11 = searchKeyNum() * (1 - (CurrentTab->currentBuffer->LINES & 65535));
            __eflags = _t11;
        } else {
            _t11 =  ~(searchKeyNum());
        }
        nscroll(_t11, _t15);
        return;
    }
    nscroll(searchKeyNum() * (1 - (CurrentTab->currentBuffer->LINES & 65535)), 0);
}

void lup1()
{// addr = 0x0804E35C  --  defined in 'main.c' at line 1575
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    nscroll(searchKeyNum(), 3);
}

void ldown1()
{// addr = 0x0804E379  --  defined in 'main.c' at line 1581
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    nscroll( ~(searchKeyNum()), 3);
}

void ctrCsrV()
{// addr = 0x0804E398  --  defined in 'main.c' at line 1587
    int offsety;                           // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(CurrentTab->currentBuffer->firstLine != 0) {
        offsety = (((CurrentTab->currentBuffer->LINES & 65535) >> 15) + (CurrentTab->currentBuffer->LINES & 65535) >> 1) - (CurrentTab->currentBuffer->cursorY & 65535);
        if(offsety != 0) {
            CurrentTab->currentBuffer->topLine = lineSkip(CurrentTab->currentBuffer, CurrentTab->currentBuffer->topLine,  ~offsety, 0);
            arrangeLine(CurrentTab->currentBuffer);
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    }
}

void ctrCsrH()
{// addr = 0x0804E457  --  defined in 'main.c' at line 1606
    int offsetx;                           // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(CurrentTab->currentBuffer->firstLine != 0) {
        offsetx = (CurrentTab->currentBuffer->cursorX & 65535) - (((CurrentTab->currentBuffer->COLS & 65535) >> 15) + (CurrentTab->currentBuffer->COLS & 65535) >> 1);
        if(offsetx != 0) {
            columnSkip(CurrentTab->currentBuffer, offsetx);
            arrangeCursor(CurrentTab->currentBuffer);
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    }
}

void rdrwSc()
{// addr = 0x0804E4E7  --  defined in 'main.c' at line 1620
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    clear();
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 1);
}

void clear_mark(Line* l)
{// addr = 0x0804E51C  --  defined in 'main.c' at line 1628
    int pos;                               // _cfa_fffffff8

    if(l != 0) {
        pos = 0;
        while(l->size > pos) {
             *(l->propBuf + pos + pos) =  *(l->propBuf + pos + pos) & 0xfffe;
            pos = pos + 1;
        }
        return;
    }
}

int srchcore(_None str, _None* func)
{// addr = 0x0804E569  --  defined in 'main.c' at line 1639
    _None* prevtrap;                       // _cfa_fffffff0
    _None i;                               // _cfa_ffffffec
    _None result;                          // _cfa_ffffffe8
    int _v40;                              // _cfa_ffffffd8 (outparam)
    _None* _t33;                           // _t33
    int _t37;                              // _t37
    _None* _t40;                           // _t40
    int _t42;                              // _t42

    result = 2;
    if(str != 0) {
        if(str != SearchString) {
            SearchString = str;
        }
    }
    if(SearchString == 0 || ( *SearchString & 255) == 0) {
        return 2;
    }
    str = conv_search_string(SearchString, DisplayCharset);
    _t33 = mySignal(2, intTrap);
    prevtrap = _t33;
    crmode();
    _v40 = 1;
     *__esp =  &IntReturn;
    __sigsetjmp();
    if(_t33 != 0) {
L19:
        __eax = mySignal(2, prevtrap);
        term_raw();
        return result;
    }
    i = 0;
L15:
L15:
    if(prec_num == 0) {
        _t37 = 1;
    } else {
        _t37 = prec_num;
    }
    if(_t37 > i) {
        goto L8;
    }
    goto L19;
L8:
    _v40 = str;
     *__esp = CurrentTab->currentBuffer;
    _t40 = func;
     *_t40();
    result = _t40;
    if(prec_num == 0) {
        _t42 = 0;
    } else {
        _t42 = prec_num - 1;
    }
    if(_t42 > i && (result & 1) != 0) {
        clear_mark(CurrentTab->currentBuffer->currentLine);
    }
    i = i + 1;
    goto L15;
}

void disp_srchresult(int result, char* prompt, char* str)
{// addr = 0x0804E6A3  --  defined in 'main.c' at line 1665
    char* _v20;                            // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8 (outparam)

    if(str == 0) {
        str = 135036496;
    }
    if((result & 2) != 0) {
        _v24 = str;
        disp_message( *(Sprintf("Not found: %s")), 1);
        return;
    }
    if((result & 4) != 0) {
        _v24 = str;
        disp_message( *(Sprintf("Search wrapped: %s")), 1);
        return;
    }
    if(show_srch_str != 0) {
        _v20 = str;
        _v24 = prompt;
        disp_message( *(Sprintf("%s%s")), 1);
        return;
    }
}

int dispincsrch(int ch, Str buf, Lineprop* prop)
{// addr = 0x0804E74F  --  defined in 'main.c' at line 1678
    char* str;                             // _cfa_fffffff0
    int do_next_search;                    // _cfa_ffffffec
    _None* _v40;                           // _cfa_ffffffd8 (outparam)
    int _t108;                             // _t108

    do_next_search = 0;
    if(ch == 0 && buf == 0) {
         *135775244 = CurrentTab->currentBuffer->topLine;
         *135775248 = CurrentTab->currentBuffer->currentLine;
         *135775308 = CurrentTab->currentBuffer->pos;
         *135775304 = CurrentTab->currentBuffer->cursorX & 65535;
         *135775306 = CurrentTab->currentBuffer->cursorY & 65535;
         *135775312 = CurrentTab->currentBuffer->visualpos;
         *135775300 = CurrentTab->currentBuffer->currentColumn;
        currentLine =  *135775248;
        pos.11062 =  *135775308;
        return -1;
    }
    str = buf->ptr;
    _t108 = ch;
    if(_t108 == 19) {
        searchRoutine = forwardSearch;
        do_next_search = 1;
    } else {
        if(_t108 == 28) {
            migemo_active =  ~migemo_active;
            while(1) {
L26:
                str =  &(str[1]);
                if(( *str & 255) == 0) {
                    break;
                }
                if(migemo_active <= 0) {
                     *prop =  *prop & 0xfffd;
                    prop =  &(prop[1]);
                } else {
                     *prop =  *prop & 65535 | 2;
                    prop =  &(prop[1]);
                }
            }
            return -1;
        }
        if(_t108 != 18) {
            if(ch < 0) {
L11:
                if(do_next_search == 0) {
                    if(( *str & 255) != 0) {
                        CurrentTab->currentBuffer->topLine =  *135775244;
                        CurrentTab->currentBuffer->currentLine =  *135775248;
                        CurrentTab->currentBuffer->pos =  *135775308;
                        CurrentTab->currentBuffer->cursorX =  *135775304 & 65535;
                        CurrentTab->currentBuffer->cursorY =  *135775306 & 65535;
                        CurrentTab->currentBuffer->visualpos =  *135775312;
                        CurrentTab->currentBuffer->currentColumn =  *135775300;
                        arrangeCursor(CurrentTab->currentBuffer);
                        _v40 = searchRoutine;
                        srchcore(str);
                        arrangeCursor(CurrentTab->currentBuffer);
                        currentLine = CurrentTab->currentBuffer->currentLine;
                        pos.11062 = CurrentTab->currentBuffer->pos;
                    }
                    displayBuffer(CurrentTab->currentBuffer, 1);
                    clear_mark(CurrentTab->currentBuffer->currentLine);
                    goto L26;
                }
                if(( *str & 255) == 0) {
                    return 16;
                }
                if(searchRoutine == forwardSearch) {
                    CurrentTab->currentBuffer->pos =  &(CurrentTab->currentBuffer->pos->lineBuf);
                }
                 *135775244 = CurrentTab->currentBuffer->topLine;
                 *135775248 = CurrentTab->currentBuffer->currentLine;
                 *135775308 = CurrentTab->currentBuffer->pos;
                 *135775304 = CurrentTab->currentBuffer->cursorX & 65535;
                 *135775306 = CurrentTab->currentBuffer->cursorY & 65535;
                 *135775312 = CurrentTab->currentBuffer->visualpos;
                 *135775300 = CurrentTab->currentBuffer->currentColumn;
                _v40 = searchRoutine;
                if(srchcore(str) == 2 && searchRoutine == forwardSearch) {
                    CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->pos - 1;
                     *135775244 = CurrentTab->currentBuffer->topLine;
                     *135775248 = CurrentTab->currentBuffer->currentLine;
                     *135775308 = CurrentTab->currentBuffer->pos;
                     *135775304 = CurrentTab->currentBuffer->cursorX & 65535;
                     *135775306 = CurrentTab->currentBuffer->cursorY & 65535;
                     *135775312 = CurrentTab->currentBuffer->visualpos;
                     *135775300 = CurrentTab->currentBuffer->currentColumn;
                }
                arrangeCursor(CurrentTab->currentBuffer);
                displayBuffer(CurrentTab->currentBuffer, 1);
                clear_mark(CurrentTab->currentBuffer->currentLine);
                return -1;
            }
            return ch;
        }
        searchRoutine = backwardSearch;
        do_next_search = 1;
    }
}

void isrch(_None* func, char* prompt)
{// addr = 0x0804EB6D  --  defined in 'main.c' at line 1756
    Buffer sbuf;        // _cfa_fffffeec
    char* str;                             // _cfa_fffffff0
    int _v196;                             // _cfa_ffffff3c
    int _v200;                             // _cfa_ffffff38
    signed short _v202;                    // _cfa_ffffff36
    signed short _v204;                    // _cfa_ffffff34
    int _v208;                             // _cfa_ffffff30
    Line* _v260;          // _cfa_fffffefc
    Line* _v264;          // _cfa_fffffef8
    _unknown_ _v300;                       // _cfa_fffffed4 (outparam)
    _unknown_ _v304;                       // _cfa_fffffed0 (outparam)
    _unknown_ _v308;                       // _cfa_fffffecc (outparam)
    _unknown_ _v312;                       // _cfa_fffffec8 (outparam)

    _v264 = CurrentTab->currentBuffer->topLine;
    _v260 = CurrentTab->currentBuffer->currentLine;
    _v200 = CurrentTab->currentBuffer->pos;
    _v204 = CurrentTab->currentBuffer->cursorX & 65535;
    _v202 = CurrentTab->currentBuffer->cursorY & 65535;
    _v196 = CurrentTab->currentBuffer->visualpos;
    _v208 = CurrentTab->currentBuffer->currentColumn;
    dispincsrch(0, 0, 0);
    searchRoutine = func;
    str = inputLineHistSearch(prompt, 0, 16, TextHist, dispincsrch);
    if(str == 0) {
        CurrentTab->currentBuffer->topLine = _v264;
        CurrentTab->currentBuffer->currentLine = _v260;
        CurrentTab->currentBuffer->pos = _v200;
        CurrentTab->currentBuffer->cursorX = _v204 & 65535;
        CurrentTab->currentBuffer->cursorY = _v202 & 65535;
        CurrentTab->currentBuffer->visualpos = _v196;
        CurrentTab->currentBuffer->currentColumn = _v208;
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
}

void srch(_None* func, char* prompt)
{// addr = 0x0804ECDF  --  defined in 'main.c' at line 1772
    char* str;                             // _cfa_fffffff0
    int result;                            // _cfa_ffffffec
    int disp;                              // _cfa_ffffffe8
    int pos;                               // _cfa_ffffffe4
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _None* _v56;                           // _cfa_ffffffc8 (outparam)

    disp = 0;
    str = searchKeyData();
    if(str == 0 || ( *str & 255) == 0) {
        str = inputLineHistSearch(prompt, 0, 16, TextHist, 0);
        if(str != 0 && ( *str & 255) == 0) {
            str = SearchString;
        }
        if(str != 0) {
            disp = 1;
            goto L8;
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    } else {
L8:
        pos = CurrentTab->currentBuffer->pos;
        if(func == forwardSearch) {
            CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->pos + 1;
        }
        _v56 = func;
        result = srchcore(str);
        if((result & 1) == 0) {
            CurrentTab->currentBuffer->pos = pos;
        } else {
            clear_mark(CurrentTab->currentBuffer->currentLine);
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        if(disp != 0) {
            disp_srchresult(result, prompt, str);
        }
        searchRoutine = func;
        return;
    }
}

void srchfor()
{// addr = 0x0804EE29  --  defined in 'main.c' at line 1806
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    srch(forwardSearch, "Forward: ");
}

void isrchfor()
{// addr = 0x0804EE45  --  defined in 'main.c' at line 1811
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    isrch(forwardSearch, "I-search: ");
}

void srchbak()
{// addr = 0x0804EE61  --  defined in 'main.c' at line 1818
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    srch(backwardSearch, "Backward: ");
}

void isrchbak()
{// addr = 0x0804EE7D  --  defined in 'main.c' at line 1823
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    isrch(backwardSearch, "I-search backward: ");
}

void srch_nxtprv(int reverse)
{// addr = 0x0804EE99  --  defined in 'main.c' at line 1829
    int result;                            // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _None*[1] _v40;                        // _cfa_ffffffd8 (outparam)
    char* _t34;                            // _t34
    char* _t42;                            // _t42

    if(searchRoutine != 0) {
        if(reverse != 0) {
            reverse = 1;
        }
        if(searchRoutine == backwardSearch) {
            reverse = reverse ^ 1;
        }
        if(reverse == 0) {
            CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->pos + 1;
        }
        _v40 = ( &routine)[reverse];
        result = srchcore(SearchString);
        if((result & 1) != 0) {
            clear_mark(CurrentTab->currentBuffer->currentLine);
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        _t42 = SearchString;
        if(reverse == 0) {
            _t34 = "Forward: ";
        } else {
            _t34 = "Backward: ";
        }
        disp_srchresult(result, _t34, _t42);
        return;
    }
    disp_message("No previous regular expression", 1);
}

void srchnxt()
{// addr = 0x0804EF7E  --  defined in 'main.c' at line 1858
    srch_nxtprv(0);
}

void srchprv()
{// addr = 0x0804EF92  --  defined in 'main.c' at line 1864
    srch_nxtprv(1);
}

void shiftvisualpos(Buffer* buf, int shift)
{// addr = 0x0804EFA6  --  defined in 'main.c' at line 1870
    Line* l;              // _cfa_fffffff0

    l = buf->currentLine;
    buf->visualpos = buf->visualpos - shift;
    if(buf->visualpos - l->bwidth < (buf->COLS & 65535)) {
        if(buf->visualpos - l->bwidth < 0) {
            buf->visualpos = l->bwidth;
        }
    } else {
        buf->visualpos = l->bwidth + (buf->COLS & 65535) - 1;
    }
    arrangeLine(buf);
    if(buf->visualpos - l->bwidth !=  ~shift || (buf->cursorX & 65535) != 0) {
        return;
    } else {
        buf->visualpos = l->bwidth;
        return;
    }
}

void shiftl()
{// addr = 0x0804F05A  --  defined in 'main.c' at line 1884
    int column;                            // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1

    if(CurrentTab->currentBuffer->firstLine != 0) {
        column = CurrentTab->currentBuffer->currentColumn;
        columnSkip(CurrentTab->currentBuffer, searchKeyNum() * (1 - (CurrentTab->currentBuffer->COLS & 65535)) + 1);
        shiftvisualpos(CurrentTab->currentBuffer, CurrentTab->currentBuffer->currentColumn - column);
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
}

void shiftr()
{// addr = 0x0804F101  --  defined in 'main.c' at line 1897
    int column;                            // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(CurrentTab->currentBuffer->firstLine != 0) {
        column = CurrentTab->currentBuffer->currentColumn;
        columnSkip(CurrentTab->currentBuffer, searchKeyNum() * ((CurrentTab->currentBuffer->COLS & 65535) - 1) - 1);
        shiftvisualpos(CurrentTab->currentBuffer, CurrentTab->currentBuffer->currentColumn - column);
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
}

void col1R()
{// addr = 0x0804F197  --  defined in 'main.c' at line 1909
    Buffer* buf;        // _cfa_fffffff0
    Line* l;              // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    int column;                            // _cfa_ffffffe4
    int n;                                 // _cfa_ffffffe0
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    buf = CurrentTab->currentBuffer;
    l = buf->currentLine;
    n = searchKeyNum();
    if(l != 0) {
        j = 0;
        while(j < n) {
            column = buf->currentColumn;
            columnSkip(CurrentTab->currentBuffer, 1);
            if(buf->currentColumn == column) {
L7:
                displayBuffer(CurrentTab->currentBuffer, 0);
                return;
            }
            shiftvisualpos(CurrentTab->currentBuffer, 1);
            j = j + 1;
        }
        goto L7;
    }
}

void col1L()
{// addr = 0x0804F238  --  defined in 'main.c' at line 1927
    Buffer* buf;        // _cfa_fffffff0
    Line* l;              // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    int n;                                 // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    buf = CurrentTab->currentBuffer;
    l = buf->currentLine;
    n = searchKeyNum();
    if(l != 0) {
        j = 0;
        while(j < n) {
            if(buf->currentColumn == 0) {
L7:
                displayBuffer(CurrentTab->currentBuffer, 0);
                return;
            }
            columnSkip(CurrentTab->currentBuffer, -1);
            shiftvisualpos(CurrentTab->currentBuffer, -1);
            j = j + 1;
        }
        goto L7;
    }
}

void setEnv()
{// addr = 0x0804F2CF  --  defined in 'main.c' at line 1944
    char* env;                             // _cfa_fffffff0
    char* var;                             // _cfa_ffffffec
    char* value;                           // _cfa_ffffffe8
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    char* _t47;                            // _t47
    char* _t64;                            // _t64

    CurrentKeyData = 0;
    env = searchKeyData();
    if(env == 0 || ( *env & 255) == 0) {
L3:
        if(env != 0 && ( *env & 255) != 0) {
            _v56 = env;
            env =  *(Sprintf("%s="));
        }
        env = inputLineHistSearch("Set environ: ", env, 16, TextHist, 0);
        if(env == 0 || ( *env & 255) == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
        goto L9;
    } else {
        _v56 = 61;
        _t64 = env;
         *__esp = _t64;
        strchr();
        if(_t64 != 0) {
L9:
            _v56 = 61;
            _t47 = env;
             *__esp = _t47;
            strchr();
            value = _t47;
            __eflags = value;
            if(__eflags != 0) {
                __eflags = value - env;
                if(__eflags > 0) {
                    var = allocStr(env, value - env);
                    value =  &(value[1]);
                    __eflags = value;
                    set_environ(var, value);
                }
            }
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
        goto L3;
    }
}

void pipeBuf()
{// addr = 0x0804F405  --  defined in 'main.c' at line 1968
    Buffer* buf;        // _cfa_fffffff0
    char* cmd;                             // _cfa_ffffffec
    char* tmpf;                            // _cfa_ffffffe8
    FILE* f;              // _cfa_ffffffe4
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    intOrPtr _v52;                         // _cfa_ffffffcc (outparam)
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    FILE* _t70;           // _t70

    CurrentKeyData = 0;
    cmd = searchKeyData();
    if(cmd == 0 || ( *cmd & 255) == 0) {
        cmd = inputLineHistSearch("Pipe buffer to: ", 135036496, 128, ShellHist, 0);
    }
    if(cmd != 0) {
        cmd =  *(wc_Str_conv_strict(Strnew_charp(cmd), InnerCharset, SystemCharset));
    }
    if(cmd == 0 || ( *cmd & 255) == 0) {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    } else {
        tmpf =  *(tmpfname(0, 0));
        _t70 = tmpf;
        _v56 = 135037898;
         *__esp = _t70;
        fopen();
        f = _t70;
        if(f != 0) {
            saveBuffer(CurrentTab->currentBuffer, f, 1);
             *__esp = f;
            fclose();
            buf = getpipe( *(myExtCommand(cmd, shell_quote(tmpf), 1)));
            if(buf != 0) {
                buf->filename = cmd;
                _v52 =  *(wc_Str_conv(Strnew_charp(cmd), SystemCharset, InnerCharset));
                _v56 = "*stream*";
                buf->buffername =  *(Sprintf("%s %s"));
                buf->bufferprop = buf->bufferprop & 65535 | 24;
                if(buf->type == 0) {
                    buf->type = "text/plain";
                }
                buf->currentURL.file = 135037599;
                pushBuffer(buf);
                displayBuffer(CurrentTab->currentBuffer, 1);
                return;
            }
            disp_message("Execution failed", 1);
            return;
        }
        _v56 = cmd;
        disp_message( *(Sprintf("Can't save buffer to %s")), 1);
        return;
    }
}

void pipesh()
{// addr = 0x0804F645  --  defined in 'main.c' at line 2014
    Buffer* buf;        // _cfa_fffffff0
    char* cmd;                             // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    CurrentKeyData = 0;
    cmd = searchKeyData();
    if(cmd == 0 || ( *cmd & 255) == 0) {
        cmd = inputLineHistSearch("(read shell[pipe])!", 135036496, 128, ShellHist, 0);
    }
    if(cmd != 0) {
        cmd =  *(wc_Str_conv_strict(Strnew_charp(cmd), InnerCharset, SystemCharset));
    }
    if(cmd == 0 || ( *cmd & 255) == 0) {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    } else {
        buf = getpipe(cmd);
        if(buf != 0) {
            buf->bufferprop = buf->bufferprop & 65535 | 24;
            if(buf->type == 0) {
                buf->type = "text/plain";
            }
            pushBuffer(buf);
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        }
        disp_message("Execution failed", 1);
        return;
    }
}

void readsh()
{// addr = 0x0804F776  --  defined in 'main.c' at line 2045
    Buffer* buf;        // _cfa_fffffff0
    _None* prevtrap;                       // _cfa_ffffffec
    char* cmd;                             // _cfa_ffffffe8
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    CurrentKeyData = 0;
    cmd = searchKeyData();
    if(cmd == 0 || ( *cmd & 255) == 0) {
        cmd = inputLineHistSearch("(read shell)!", 135036496, 128, ShellHist, 0);
    }
    if(cmd != 0) {
        cmd =  *(wc_Str_conv_strict(Strnew_charp(cmd), InnerCharset, SystemCharset));
    }
    if(cmd == 0 || ( *cmd & 255) == 0) {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    } else {
        prevtrap = mySignal(2, intTrap);
        crmode();
        buf = getshell(cmd);
        mySignal(2, prevtrap);
        term_raw();
        if(buf != 0) {
            buf->bufferprop = buf->bufferprop & 65535 | 24;
            if(buf->type == 0) {
                buf->type = "text/plain";
            }
            pushBuffer(buf);
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        }
        disp_message("Execution failed", 1);
        return;
    }
}

void execsh()
{// addr = 0x0804F8DE  --  defined in 'main.c' at line 2082
    char* cmd;                             // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    CurrentKeyData = 0;
    cmd = searchKeyData();
    if(cmd == 0 || ( *cmd & 255) == 0) {
        cmd = inputLineHistSearch("(exec shell)!", 135036496, 128, ShellHist, 0);
    }
    if(cmd != 0) {
        cmd =  *(wc_Str_conv_strict(Strnew_charp(cmd), InnerCharset, SystemCharset));
    }
    if(cmd != 0 && ( *cmd & 255) != 0) {
        fmTerm();
         *__esp = 10;
        putchar();
         *__esp = cmd;
        system();
         *__esp = "\n[Hit any key]";
        printf();
         *__esp = __imp__stdout;
        fflush();
        fmInit();
        do_getch();
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
}

void ldfile()
{// addr = 0x0804F9D9  --  defined in 'main.c' at line 2107
    char* fn;                              // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    fn = searchKeyData();
    if(fn == 0 || ( *fn & 255) == 0) {
        fn = inputLineHistSearch("(Load)Filename? ", 0, 32, LoadHist, 0);
    }
    if(fn != 0) {
        fn =  *(wc_Str_conv_strict(Strnew_charp(fn), InnerCharset, SystemCharset));
    }
    if(fn == 0 || ( *fn & 255) == 0) {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    } else {
        cmd_loadfile(fn);
        return;
    }
}

void ldhelp()
{// addr = 0x0804FA97  --  defined in 'main.c' at line 2126
    char* lang;                            // _cfa_fffffff0
    int n;                                 // _cfa_ffffffec
    Str tmp;               // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    intOrPtr _v36;                         // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    int _t16;                              // _t16
    intOrPtr* _t20;                        // _t20
    char** _t23;                           // _t23

    lang = AcceptLang;
    _v40 = ";, \t";
    _t16 = lang;
     *__esp = _t16;
    strcspn();
    n = _t16;
    _t20 = Str_form_quote(Strnew_charp_n(lang, n));
    _t23 = Str_form_quote(Strnew_charp(w3m_version));
    _v36 =  *_t20;
    _v40 =  *_t23;
    tmp = Sprintf("file:///$LIB/w3mhelp.cgi?version=%s&lang=%s");
    cmd_loadURL(tmp->ptr, 0, -1, 0);
}

void cmd_loadfile(char* fn)
{// addr = 0x0804FB31  --  defined in 'main.c' at line 2145
    Buffer* buf;        // _cfa_fffffff0
    char* emsg;                            // _cfa_ffffffec
    int _v44;                              // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    intOrPtr _v56;                         // _cfa_ffffffc8 (outparam)
    char* _t22;                            // _t22

    _t22 = file_to_url(fn);
    _v44 = 0;
    _v48 = 0;
    buf = loadGeneralFile(_t22, 0, -1);
    if(buf != 0) {
        if(buf != 1) {
            pushBuffer(buf);
            if((RenderFrame & 255) != 0 && CurrentTab->currentBuffer->frameset != 0) {
                rFrame();
            }
        }
    } else {
        _v56 =  *(wc_Str_conv(Strnew_charp(fn), SystemCharset, InnerCharset));
        emsg =  *(Sprintf("%s not found"));
        disp_err_message(emsg, 0);
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
}

void _movL(int n)
{// addr = 0x0804FC1A  --  defined in 'main.c' at line 2165
    int i;                                 // _cfa_fffffff0
    int m;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    m = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine != 0) {
        i = 0;
        while(i < m) {
            cursorLeft(CurrentTab->currentBuffer, n);
            i = i + 1;
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
}

void movL()
{// addr = 0x0804FC80  --  defined in 'main.c' at line 2175
    _movL(((CurrentTab->currentBuffer->COLS & 65535) >> 15) + (CurrentTab->currentBuffer->COLS & 65535) >> 1);
}

void movL1()
{// addr = 0x0804FCA9  --  defined in 'main.c' at line 2181
    _movL(1);
}

void _movD(int n)
{// addr = 0x0804FCBD  --  defined in 'main.c' at line 2188
    int i;                                 // _cfa_fffffff0
    int m;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    m = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine != 0) {
        i = 0;
        while(i < m) {
            cursorDown(CurrentTab->currentBuffer, n);
            i = i + 1;
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
}

void movD()
{// addr = 0x0804FD23  --  defined in 'main.c' at line 2198
    _movD(((CurrentTab->currentBuffer->LINES & 65535) + 1 >> 31) + (CurrentTab->currentBuffer->LINES & 65535) + 1 >> 1);
}

void movD1()
{// addr = 0x0804FD4D  --  defined in 'main.c' at line 2204
    _movD(1);
}

void _movU(int n)
{// addr = 0x0804FD61  --  defined in 'main.c' at line 2212
    int i;                                 // _cfa_fffffff0
    int m;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    m = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine != 0) {
        i = 0;
        while(i < m) {
            cursorUp(CurrentTab->currentBuffer, n);
            i = i + 1;
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
}

void movU()
{// addr = 0x0804FDC7  --  defined in 'main.c' at line 2222
    _movU(((CurrentTab->currentBuffer->LINES & 65535) + 1 >> 31) + (CurrentTab->currentBuffer->LINES & 65535) + 1 >> 1);
}

void movU1()
{// addr = 0x0804FDF1  --  defined in 'main.c' at line 2228
    _movU(1);
}

void _movR(int n)
{// addr = 0x0804FE05  --  defined in 'main.c' at line 2235
    int i;                                 // _cfa_fffffff0
    int m;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    m = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine != 0) {
        i = 0;
        while(i < m) {
            cursorRight(CurrentTab->currentBuffer, n);
            i = i + 1;
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
}

void movR()
{// addr = 0x0804FE6B  --  defined in 'main.c' at line 2245
    _movR(((CurrentTab->currentBuffer->COLS & 65535) >> 15) + (CurrentTab->currentBuffer->COLS & 65535) >> 1);
}

void movR1()
{// addr = 0x0804FE94  --  defined in 'main.c' at line 2251
    _movR(1);
}

int prev_nonnull_line(Line* line)
{// addr = 0x0804FEA8  --  defined in 'main.c' at line 2265
    Line* l;              // _cfa_fffffff8

    l = line;
    do {
    } while(l != 0 && l->len == 0);
    if(l == 0 || l->len == 0) {
        return -1;
    } else {
        CurrentTab->currentBuffer->currentLine = l;
        if(l != line) {
            CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->currentLine->len;
        }
        return 0;
    }
}

void movLW()
{// addr = 0x0804FF1D  --  defined in 'main.c' at line 2279
    char* lb;                              // _cfa_fffffff0
    Lineprop* pb;     // _cfa_ffffffec
    Line* pline;          // _cfa_ffffffe8
    int ppos;                              // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    int n;                                 // _cfa_ffffffdc
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    n = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    } else {
        i = 0;
L18:
        while(i < n) {
            pline = CurrentTab->currentBuffer->currentLine;
            ppos = CurrentTab->currentBuffer->pos;
            if(prev_nonnull_line(CurrentTab->currentBuffer->currentLine) < 0) {
L21:
                arrangeCursor(CurrentTab->currentBuffer);
                displayBuffer(CurrentTab->currentBuffer, 0);
                return;
            } else {
                goto L3;
            }
            while(1) {
L3:
                lb = CurrentTab->currentBuffer->currentLine->lineBuf;
                pb = CurrentTab->currentBuffer->currentLine->propBuf;
                do {
L5:
                } while(CurrentTab->currentBuffer->pos > 0 && (( *( &MYCTYPE_MAP + (lb[CurrentTab->currentBuffer->pos - 1] & 0xff)) & 0xc) == 0 || ( *(pb + CurrentTab->currentBuffer->pos - 1 + CurrentTab->currentBuffer->pos - 1) & 0x3f00) != 0));
                if(CurrentTab->currentBuffer->pos <= 0) {
                    if(prev_nonnull_line(CurrentTab->currentBuffer->currentLine->prev) >= 0) {
                        CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->currentLine->len;
L3:
                        lb = CurrentTab->currentBuffer->currentLine->lineBuf;
                        pb = CurrentTab->currentBuffer->currentLine->propBuf;
                        goto L5;
                    }
                    CurrentTab->currentBuffer->currentLine = pline;
                    CurrentTab->currentBuffer->pos = ppos;
                    goto L21;
                }
                lb = CurrentTab->currentBuffer->currentLine->lineBuf;
                pb = CurrentTab->currentBuffer->currentLine->propBuf;
                while(CurrentTab->currentBuffer->pos > 0 && ( *( &MYCTYPE_MAP + (lb[CurrentTab->currentBuffer->pos - 1] & 0xff)) & 0xc) != 0 && ( *(pb + CurrentTab->currentBuffer->pos - 1 + CurrentTab->currentBuffer->pos - 1) & 0x3f00) == 0) {
                    CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->pos - 1;
                }
                i = i + 1;
                goto L18;
            }
        }
        goto L21;
    }
}

int next_nonnull_line(Line* line)
{// addr = 0x08050144  --  defined in 'main.c' at line 2329
    Line* l;              // _cfa_fffffff8

    l = line;
    do {
    } while(l != 0 && l->len == 0);
    if(l == 0 || l->len == 0) {
        return -1;
    } else {
        CurrentTab->currentBuffer->currentLine = l;
        if(l != line) {
            CurrentTab->currentBuffer->pos = 0;
        }
        return 0;
    }
}

void movRW()
{// addr = 0x080501AE  --  defined in 'main.c' at line 2344
    char* lb;                              // _cfa_fffffff0
    Lineprop* pb;     // _cfa_ffffffec
    Line* pline;          // _cfa_ffffffe8
    int ppos;                              // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    int n;                                 // _cfa_ffffffdc
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    n = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    i = 0;
L20:
    while(i < n) {
        pline = CurrentTab->currentBuffer->currentLine;
        ppos = CurrentTab->currentBuffer->pos;
        if(next_nonnull_line(CurrentTab->currentBuffer->currentLine) < 0) {
L23:
            arrangeCursor(CurrentTab->currentBuffer);
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
        lb = CurrentTab->currentBuffer->currentLine->lineBuf;
        pb = CurrentTab->currentBuffer->currentLine->propBuf;
        while((lb[CurrentTab->currentBuffer->pos] & 255) != 0) {
            if(( *( &MYCTYPE_MAP + (lb[CurrentTab->currentBuffer->pos] & 0xff)) & 0xc) == 0) {
L12:
                while((lb[CurrentTab->currentBuffer->pos] & 255) == 0 || ( *( &MYCTYPE_MAP + (lb[CurrentTab->currentBuffer->pos] & 0xff)) & 0xc) != 0 && ( *(pb + CurrentTab->currentBuffer->pos + CurrentTab->currentBuffer->pos) & 0x3f00) == 0) {
                    if((lb[CurrentTab->currentBuffer->pos] & 255) == 0) {
                        if(next_nonnull_line(CurrentTab->currentBuffer->currentLine->next) >= 0) {
                            CurrentTab->currentBuffer->pos = 0;
                            lb = CurrentTab->currentBuffer->currentLine->lineBuf;
                            pb = CurrentTab->currentBuffer->currentLine->propBuf;
                            continue;
                        }
                        CurrentTab->currentBuffer->currentLine = pline;
                        CurrentTab->currentBuffer->pos = ppos;
                        goto L23;
                    }
                    i = i + 1;
                    goto L20;
                }
                CurrentTab->currentBuffer->pos =  &(CurrentTab->currentBuffer->pos->lineBuf);
                goto L12;
            }
            if(( *(pb + CurrentTab->currentBuffer->pos + CurrentTab->currentBuffer->pos) & 0x3f00) == 0) {
                CurrentTab->currentBuffer->pos =  &(CurrentTab->currentBuffer->pos->lineBuf);
                continue;
            }
            goto L12;
        }
        goto L12;
    }
    goto L23;
}

void _quitfm(int confirm)
{// addr = 0x080503D6  --  defined in 'main.c' at line 2391
    char* ans;                             // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    ans = 135038109;
    if(checkDownloadList() == 0) {
        if(confirm != 0) {
            ans = inputLineHistSearch("Do you want to exit w3m? (y/n)", 135036496, 512, 0, 0);
        }
    } else {
        ans = inputLineHistSearch("Download process retains. Do you want to exit w3m? (y/n)", 135036496, 512, 0, 0);
    }
    if(ans == 0) {
L9:
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    } else {
        if(( *( &MYCTYPE_MAP + ( *ans & 0xff)) & 4) == 0) {
            if(( *ans & 255) == 121) {
L10:
                term_title(135036496);
                if(activeImage != 0) {
                    termImage();
                }
                fmTerm();
                save_cookies();
                if(UseHistory != 0 && SaveURLHist != 0) {
                    saveHistory(URLHist, URLHistSize);
                }
                w3m_exit(0);
                return;
            }
            goto L9;
        }
        if(( *ans & 255 | 32) != 121) {
            goto L9;
        }
        goto L10;
    }
}

void quitfm()
{// addr = 0x08050501  --  defined in 'main.c' at line 2424
    _quitfm(0);
}

void qquitfm()
{// addr = 0x08050515  --  defined in 'main.c' at line 2430
    _quitfm(confirm_on_quit);
}

void selBuf()
{// addr = 0x0805052A  --  defined in 'main.c' at line 2436
    char cmd;                              // _cfa_fffffff3
    Buffer* buf;        // _cfa_ffffffec
    int ok;                                // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    signed int _t36;                       // _t36

    ok = 0;
    do {
        buf = selectBuffer(CurrentTab->firstBuffer, CurrentTab->currentBuffer,  &cmd);
        _t36 = cmd & 255;
        if(_t36 == 68) {
            delBuffer(buf);
            if(CurrentTab->firstBuffer == 0) {
                CurrentTab->firstBuffer = nullBuffer();
                CurrentTab->currentBuffer = CurrentTab->firstBuffer;
            }
            goto L18;
        }
        if(_t36 <= 68) {
            if(_t36 == 66) {
                ok = 1;
            } else {
                if(_t36 <= 66 && (_t36 == 10 || _t36 == 32)) {
                    CurrentTab->currentBuffer = buf;
                    ok = 1;
                }
            }
        } else {
            if(_t36 == 81) {
                quitfm();
            } else {
                if(_t36 == 113) {
                    qquitfm();
                }
            }
        }
L18:
    } while(ok == 0);
    buf = CurrentTab->firstBuffer;
    while(buf != 0) {
        if(CurrentTab->currentBuffer != buf) {
            deleteImage(buf);
            if(clear_buffer != 0) {
                tmpClearBuffer(buf);
            }
        }
        buf = buf->nextBuffer;
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
}

void susp()
{// addr = 0x08050668  --  defined in 'main.c' at line 2484
    intOrPtr _v24;                         // _cfa_ffffffe8 (outparam)

    move(LINES - 1, 0);
    clrtoeolx();
    refresh();
    fmTerm();
    _v24 = 19;
     *__esp = 0;
    kill();
    fmInit();
    displayBuffer(CurrentTab->currentBuffer, 1);
}

void _goLine(char* l)
{// addr = 0x080506C8  --  defined in 'main.c' at line 2507
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    int _t59;                              // _t59
    Buffer* _t81;       // _t81

    if(l == 0 || ( *l & 255) == 0 || CurrentTab->currentBuffer->currentLine == 0) {
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    CurrentTab->currentBuffer->pos = 0;
    if(( *l & 255) == 94 || ( *l & 255) == 36) {
        if(prec_num == 0) {
            goto L8;
        } else {
            gotoRealLine(CurrentTab->currentBuffer, prec_num);
            goto L13;
        }
    } else {
L8:
        if(( *l & 255) != 94) {
            if(( *l & 255) != 36) {
                _t59 = l;
                 *__esp = _t59;
                atoi();
                gotoRealLine(CurrentTab->currentBuffer, _t59);
            } else {
                CurrentTab->currentBuffer->topLine = lineSkip(CurrentTab->currentBuffer, CurrentTab->currentBuffer->lastLine, ( !(CurrentTab->currentBuffer->LINES & 65535) >> 31) +  !(CurrentTab->currentBuffer->LINES & 65535) >> 1, 1);
                CurrentTab->currentBuffer->currentLine = CurrentTab->currentBuffer->lastLine;
            }
        } else {
            _t81 = CurrentTab->currentBuffer;
            _t81->currentLine = CurrentTab->currentBuffer->firstLine;
            CurrentTab->currentBuffer->topLine = _t81->currentLine;
        }
L13:
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
}

void goLine()
{// addr = 0x0805084C  --  defined in 'main.c' at line 2532
    char* str;                             // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    str = searchKeyData();
    if(prec_num == 0) {
        if(str == 0) {
            _goLine(inputLineHistSearch("Goto line: ", 135036496, 16, 0, 0));
            return;
        }
        _goLine(str);
        return;
    }
    _goLine(135038203);
}

void goLineF()
{// addr = 0x080508BA  --  defined in 'main.c' at line 2546
    _goLine(135038203);
}

void goLineL()
{// addr = 0x080508CE  --  defined in 'main.c' at line 2551
    _goLine(135038217);
}

void linbeg()
{// addr = 0x080508E2  --  defined in 'main.c' at line 2557
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(CurrentTab->currentBuffer->firstLine != 0) {
        while(CurrentTab->currentBuffer->currentLine->prev != 0 && CurrentTab->currentBuffer->currentLine->bpos != 0) {
            cursorUp0(CurrentTab->currentBuffer, 1);
        }
        CurrentTab->currentBuffer->pos = 0;
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
}

void linend()
{// addr = 0x08050971  --  defined in 'main.c' at line 2569
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    __eflags = CurrentTab->currentBuffer->firstLine;
    if(__eflags != 0) {
        while(1) {
            CurrentTab = CurrentTab->currentBuffer;
            __eax = CurrentTab->currentBuffer->currentLine;
            __eax = CurrentTab->currentBuffer->currentLine->next;
            __eflags = __eax;
            if(__eax == 0) {
                break;
            }
            CurrentTab = CurrentTab->currentBuffer;
            CurrentTab->currentBuffer->currentLine = CurrentTab->currentBuffer->currentLine->next;
            __eax = CurrentTab->currentBuffer->currentLine->next->bpos;
            __eflags = __eax;
            if(__eax != 0) {
                CurrentTab = CurrentTab->currentBuffer;
                cursorDown0(CurrentTab->currentBuffer, 1);
                continue;
            }
            break;
        }
        CurrentTab = CurrentTab->currentBuffer;
        CurrentTab = CurrentTab->currentBuffer;
        CurrentTab->currentBuffer->currentLine = CurrentTab->currentBuffer->currentLine->len;
        __edx = CurrentTab->currentBuffer->currentLine->len - 1;
        __eflags = __edx;
        CurrentTab->currentBuffer->pos = __edx;
        CurrentTab = CurrentTab->currentBuffer;
        arrangeCursor(CurrentTab->currentBuffer);
        CurrentTab = CurrentTab->currentBuffer;
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
}

int cur_real_linenumber(Buffer* buf)
{// addr = 0x08050A14  --  defined in 'main.c' at line 2582
    Line* l;              // _cfa_fffffff8
    Line* cur;            // _cfa_fffffff4
    int n;                                 // _cfa_fffffff0
    int _t30;                              // _t30

    cur = buf->currentLine;
    if(cur == 0) {
        return 1;
    }
    if(cur->real_linenumber == 0) {
        _t30 = 1;
    } else {
        _t30 = cur->real_linenumber;
    }
    n = _t30;
    l = buf->firstLine;
    while(l != 0 && l != cur && l->real_linenumber == 0) {
        if(l->bpos == 0) {
            n = n + 1;
        }
        l = l->next;
    }
    return n;
}

void editBf()
{// addr = 0x08050A89  --  defined in 'main.c' at line 2598
    char* fn;                              // _cfa_fffffff0
    Str cmd;               // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    intOrPtr _v56;                         // _cfa_ffffffc8 (outparam)
    char* _t54;                            // _t54
    int _t65;                              // _t65

    fn = CurrentTab->currentBuffer->filename;
    if(fn != 0 && CurrentTab->currentBuffer->pagerSource == 0 && (CurrentTab->currentBuffer->type != 0 || CurrentTab->currentBuffer->edit != 0) && CurrentTab->currentBuffer->real_scheme == 4) {
        _t54 = CurrentTab->currentBuffer->currentURL.file;
        _v56 = 135037599;
         *__esp = _t54;
        strcmp();
        if(_t54 == 0 || (CurrentTab->currentBuffer->bufferprop & 2) != 0) {
            goto L7;
        } else {
            if(CurrentTab->currentBuffer->edit == 0) {
                _t65 = cur_real_linenumber(CurrentTab->currentBuffer);
                cmd = myEditor(Editor, shell_quote(fn), _t65);
            } else {
                cmd = unquote_mailcap(CurrentTab->currentBuffer->edit, CurrentTab->currentBuffer->real_type, fn, checkHeader(CurrentTab->currentBuffer, "Content-Type:"), 0);
            }
            fmTerm();
             *__esp = cmd->ptr;
            system();
            fmInit();
            displayBuffer(CurrentTab->currentBuffer, 1);
            reload();
            return;
        }
    }
L7:
    disp_err_message("Can't edit other than local file", 1);
}

void editScr()
{// addr = 0x08050C0E  --  defined in 'main.c' at line 2625
    char* tmpf;                            // _cfa_fffffff0
    FILE* f;              // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    FILE* _t24;           // _t24
    int _t30;                              // _t30

    tmpf =  *(tmpfname(0, 0));
    _t24 = tmpf;
    _v40 = 135037898;
     *__esp = _t24;
    fopen();
    f = _t24;
    if(f != 0) {
        saveBuffer(CurrentTab->currentBuffer, f, 1);
         *__esp = f;
        fclose();
        fmTerm();
        _t30 = cur_real_linenumber(CurrentTab->currentBuffer);
         *__esp =  *(myEditor(Editor, shell_quote(tmpf), _t30));
        system();
        fmInit();
         *__esp = tmpf;
        unlink();
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    _v40 = tmpf;
    disp_err_message( *(Sprintf("Can't open %s")), 1);
}

void _mark()
{// addr = 0x08050D0F  --  defined in 'main.c' at line 2650
    Line* l;              // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(use_mark == 0) {
        return;
    }
    if(CurrentTab->currentBuffer->firstLine != 0) {
        l = CurrentTab->currentBuffer->currentLine;
         *(l->propBuf + CurrentTab->currentBuffer->pos + CurrentTab->currentBuffer->pos) =  *(l->propBuf + CurrentTab->currentBuffer->pos + CurrentTab->currentBuffer->pos) & 65535 ^ 1;
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
}

void nextMk()
{// addr = 0x08050D8F  --  defined in 'main.c' at line 2663
    Line* l;              // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(use_mark == 0) {
        return;
    }
    if(CurrentTab->currentBuffer->firstLine != 0) {
        i =  &(CurrentTab->currentBuffer->pos->lineBuf);
        l = CurrentTab->currentBuffer->currentLine;
        if(l->len <= i) {
            i = 0;
            l = l->next;
        }
        while(l != 0) {
            while(1) {
                l = l->len;
                if(l->len <= i) {
                    break;
                }
                l = l->propBuf;
                l->propBuf + i + i =  *(l->propBuf + i + i) & 65535;
                if(__al == 0) {
                    i = i + 1;
                    continue;
                }
                CurrentTab = CurrentTab->currentBuffer;
                CurrentTab->currentBuffer->currentLine = l;
                CurrentTab = CurrentTab->currentBuffer;
                CurrentTab->currentBuffer->pos = i;
                CurrentTab = CurrentTab->currentBuffer;
                arrangeCursor(CurrentTab->currentBuffer);
                CurrentTab = CurrentTab->currentBuffer;
                displayBuffer(CurrentTab->currentBuffer, 0);
                return;
            }
            l = l->next;
            l = l->next;
            i = 0;
        }
        disp_message("No mark exist after here", 1);
        return;
    }
}

void prevMk()
{// addr = 0x08050E9C  --  defined in 'main.c' at line 2696
    Line* l;              // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(use_mark == 0) {
        return;
    }
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    } else {
        i = CurrentTab->currentBuffer->pos - 1;
        l = CurrentTab->currentBuffer->currentLine;
        if(i < 0) {
            l = l->prev;
            if(l != 0) {
                i = l->len - 1;
            }
        }
        while(l != 0) {
            while(i >= 0) {
                if(( *(l->propBuf + i + i) & 1) == 0) {
                    i = i - 1;
                    continue;
                }
                CurrentTab->currentBuffer->currentLine = l;
                CurrentTab->currentBuffer->pos = i;
                arrangeCursor(CurrentTab->currentBuffer);
                displayBuffer(CurrentTab->currentBuffer, 0);
                return;
            }
            l = l->prev;
            if(l != 0) {
                i = l->len - 1;
            }
        }
        disp_message("No mark exist before here", 1);
        return;
    }
}

void reMark()
{// addr = 0x08050FB6  --  defined in 'main.c' at line 2731
    Line* l;              // _cfa_fffffff0
    char* str;                             // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    char* p1;                              // _cfa_ffffffe4
    char* p2;                              // _cfa_ffffffe0
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5

    if(use_mark == 0) {
        return;
    }
    str = searchKeyData();
    if(str == 0 || ( *str & 255) == 0) {
        str = inputLineHistSearch("(Mark)Regexp: ", MarkString, 16, TextHist, 0);
        if(str == 0 || ( *str & 255) == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        } else {
            goto L6;
        }
    } else {
L6:
        str = conv_search_string(str, DisplayCharset);
        str = regexCompile(str, 1);
        if(str == 0) {
            MarkString = str;
            l = CurrentTab->currentBuffer->firstLine;
            while(l != 0) {
                p = l->lineBuf;
                while(regexMatch(p, l->lineBuf + l->len - p, l->lineBuf == p & 255) == 1) {
                    matchedPosition( &p1,  &p2);
                     *(l->propBuf + p1 - l->lineBuf + p1 - l->lineBuf) =  *(l->propBuf + p1 - l->lineBuf + p1 - l->lineBuf) & 65535 | 1;
                    p = p2;
                }
                l = l->next;
            }
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        }
        disp_message(str, 1);
        return;
    }
}

Buffer* loadNormalBuf(Buffer* buf, int renderframe)
{// addr = 0x0805117F  --  defined in 'main.c' at line 2771
    pushBuffer(buf);
    if(renderframe != 0 && (RenderFrame & 255) != 0 && CurrentTab->currentBuffer->frameset != 0) {
        rFrame();
    }
    return buf;
}

Buffer* loadLink(char* url, char* target, char* referer, FormList* request)
{// addr = 0x080511BD  --  defined in 'main.c' at line 2780
    Buffer* buf;        // _cfa_fffffff0
    Buffer* nfbuf;      // _cfa_ffffffec
    union frameset_element* f_element;   // _cfa_ffffffe8
    int flag;                              // _cfa_ffffffe4
    ParsedURL* base;   // _cfa_ffffffe0
    char* emsg;                            // _cfa_ffffffdc
    Anchor* al;         // _cfa_ffffffd8
    char* label;                           // _cfa_ffffffd4
    char* _v52;                            // _cfa_ffffffcc
    ParsedURL pu;    // _cfa_ffffffac
    FormList* _v108;   // _cfa_ffffff94
    int _v112;                             // _cfa_ffffff90 (outparam)
    Buffer* _v116;      // _cfa_ffffff8c (outparam)
    char* _v120;                           // _cfa_ffffff88 (outparam)
    _unknown_ __ebx;                       // r1
    _None _t136;                           // _t136
    char* _t150;                           // _t150

    f_element = 0;
    flag = 0;
    _v120 = url;
    message( *(Sprintf("loading %s")), 0, 0);
    refresh();
    base = baseURL(CurrentTab->currentBuffer);
    if(base == 0 || base->scheme == 4 || base->scheme == 5) {
        referer = -1;
    }
    if(referer == 0) {
        referer =  *(parsedURL2Str( &(CurrentTab->currentBuffer->currentURL)));
    }
    _t136 = baseURL(CurrentTab->currentBuffer);
    _v108 = request;
    _v112 = flag;
    buf = loadGeneralFile(url, _t136, referer);
    if(buf == 0) {
        _v120 = url;
        emsg =  *(Sprintf("Can't load %s"));
        disp_err_message(emsg, 0);
        return 0;
    }
    parseURL2(url,  &pu, base);
    pushHashHist(URLHist,  *(parsedURL2Str( &pu)));
    if(buf != 1) {
        if(on_target != 0) {
            if(do_download == 0) {
                if(target == 0) {
L17:
                    return loadNormalBuf(buf, 1);
                }
                _v120 = "_top";
                _t150 = target;
                 *__esp = _t150;
                strcmp();
                if(_t150 == 0 || (CurrentTab->currentBuffer->bufferprop & 2) == 0) {
                    goto L17;
                } else {
                    nfbuf = CurrentTab->currentBuffer->linkBuffer[1];
                    if(nfbuf != 0) {
                        f_element = search_frame(nfbuf->frameset, target);
                        if(f_element != 0) {
                            pushFrameTree( &(nfbuf->frameQ), copyFrameSet(nfbuf->frameset), CurrentTab->currentBuffer);
                            delBuffer(CurrentTab->currentBuffer);
                            CurrentTab->currentBuffer = nfbuf;
                            resetFrameElement(f_element, buf, referer, request);
                            discardBuffer(buf);
                            rFrame();
                            al = 0;
                            label = _v52;
                            if(label != 0 && ( *( *f_element) & 255) == 1) {
                                al = searchAnchor( *( *f_element + 28), label);
                            }
                            if(al == 0) {
                                _v116 = 0;
                                _v120 = target;
                                label =  *(Strnew_m_charp(135038377));
                                al = searchURLLabel(CurrentTab->currentBuffer, label);
                            }
                            if(al != 0) {
                                gotoLine(CurrentTab->currentBuffer, al->start.line);
                                if(label_topline != 0) {
                                    CurrentTab->currentBuffer->topLine = lineSkip(CurrentTab->currentBuffer, CurrentTab->currentBuffer->topLine, CurrentTab->currentBuffer->currentLine->linenumber - CurrentTab->currentBuffer->topLine->linenumber, 0);
                                }
                                CurrentTab->currentBuffer->pos = al->start.pos;
                                arrangeCursor(CurrentTab->currentBuffer);
                            }
                            displayBuffer(CurrentTab->currentBuffer, 0);
                            return buf;
                        }
                        return loadNormalBuf(buf, 1);
                    }
                    return loadNormalBuf(buf, 1);
                }
            }
            return loadNormalBuf(buf, 0);
        }
        return loadNormalBuf(buf, 1);
    } else {
        return 0;
    }
}

void gotoLabel(char* label)
{// addr = 0x080515BC  --  defined in 'main.c' at line 2872
    Buffer* buf;        // _cfa_fffffff0
    Anchor* al;         // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    int _t107;                             // _t107

    al = searchURLLabel(CurrentTab->currentBuffer, label);
    __eflags = al;
    if(__eflags != 0) {
        buf = newBuffer(CurrentTab->currentBuffer->width & 65535);
        copyBuffer(buf, CurrentTab->currentBuffer);
        i = 0;
        while(1) {
            __eflags = i - 4;
            if(i > 4) {
                break;
            }
             *(buf->topLine + (i + 4) * 4) = 0;
            i = i + 1;
            __eflags = i;
        }
        buf->currentURL.label = allocStr(label, -1);
        pushHashHist(URLHist,  *(parsedURL2Str( &(buf->currentURL))));
        buf->clone->filename =  &(buf->filename);
        pushBuffer(buf);
        gotoLine(CurrentTab->currentBuffer, al->start.line);
        __eflags = label_topline;
        if(__eflags != 0) {
            _t107 = CurrentTab->currentBuffer->currentLine->linenumber - CurrentTab->currentBuffer->topLine->linenumber;
            __eflags = _t107;
            CurrentTab->currentBuffer->topLine = lineSkip(CurrentTab->currentBuffer, CurrentTab->currentBuffer->topLine, _t107, 0);
        }
        CurrentTab->currentBuffer->pos = al->start.pos;
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    _v40 = label;
    disp_message( *(Sprintf("%s is not found")), 1);
}

void followA()
{// addr = 0x08051773  --  defined in 'main.c' at line 2905
    Line* l;              // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    int x;                                 // _cfa_ffffffe8
    int y;                                 // _cfa_ffffffe4
    int map;                               // _cfa_ffffffe0
    char* url;                             // _cfa_ffffffdc
    Str to;                // _cfa_ffffffd8
    Buffer* buf;        // _cfa_ffffffd4
    char* _v52;                            // _cfa_ffffffcc
    ParsedURL u;     // _cfa_ffffffac
    int _v96;                              // _cfa_ffffffa0 (outparam)
    int _v100;                             // _cfa_ffffff9c (outparam)
    char* _v104;                           // _cfa_ffffff98 (outparam)
    char** _t125;                          // _t125
    char* _t128;                           // _t128
    char* _t130;                           // _t130
    char* _t145;                           // _t145
    char* _t161;                           // _t161
    char* _t169;                           // _t169

    x = 0;
    y = 0;
    map = 0;
    if(CurrentTab->currentBuffer->firstLine.scheme == 0) {
        return;
    }
    l = CurrentTab->currentBuffer->currentLine.scheme;
    a = retrieveCurrentImg(CurrentTab->currentBuffer);
    if(a == 0) {
L5:
        if(a != 0) {
            if(a->image != 0 && (a->image->ismap & 255) != 0) {
                getMapXY(CurrentTab->currentBuffer, a,  &x,  &y);
                map = 1;
            }
        }
        a = retrieveCurrentAnchor(CurrentTab->currentBuffer);
        if(a == 0) {
            _followForm(0);
            return;
        }
        if((a & 255) != 35) {
            parseURL2(a->url,  &u, baseURL(CurrentTab->currentBuffer));
            _t125 = parsedURL2Str( &(CurrentTab->currentBuffer->currentURL));
            _t128 =  *(parsedURL2Str( &u));
            _v104 =  *_t125;
             *__esp = _t128;
            strcmp();
            if(_t128 != 0 || _v52 == 0) {
                _t130 = a->url;
                _v100 = 7;
                _v104 = "mailto:";
                 *__esp = _t130;
                strncasecmp();
                if(_t130 != 0 || non_null(Mailer) == 0) {
L20:
                    url = a->url;
                    if(map != 0) {
                        _v96 = y;
                        _v100 = x;
                        _v104 = a->url;
                        url =  *(Sprintf("%s?%d,%d"));
                    }
                    if(check_target == 0 || open_tab_blank == 0 || a->target == 0) {
L31:
                        loadLink(url, a->target, a->referer, 0);
                        displayBuffer(CurrentTab->currentBuffer, 0);
                        return;
                    } else {
                        _t145 = a->target;
                        _v104 = "_new";
                         *__esp = _t145;
                        strcasecmp();
                        if(_t145 == 0) {
L27:
                            _newT();
                            buf = CurrentTab->currentBuffer;
                            loadLink(url, a->target, a->referer, 0);
                            if(CurrentTab->currentBuffer == buf) {
                                deleteTab(CurrentTab);
                            } else {
                                delBuffer(buf);
                            }
                            displayBuffer(CurrentTab->currentBuffer, 1);
                            return;
                        }
                        _t161 = a->target;
                        _v104 = "_blank";
                         *__esp = _t161;
                        strcasecmp();
                        if(_t161 != 0) {
                            goto L31;
                        }
                        goto L27;
                    }
                } else {
                    _t169 = a->url;
                    _v104 = 63;
                     *__esp = _t169;
                    strchr();
                    if(_t169 != 0) {
                        goto L20;
                    }
                    to = Strnew_charp( &(a->url->ext));
                    fmTerm();
                     *__esp =  *(myExtCommand(Mailer, shell_quote(file_unquote(to->ptr)), 0));
                    system();
                    fmInit();
                    displayBuffer(CurrentTab->currentBuffer, 1);
                    pushHashHist(URLHist, a->url);
                    return;
                }
            } else {
                gotoLabel(_v52);
                return;
            }
        }
        gotoLabel( &(a->url->url));
        return;
    }
    if(a->image == 0) {
        goto L5;
    } else {
        if(a->image->map == 0) {
            goto L5;
        } else {
            _followForm(0);
            return;
        }
    }
}

void bufferA()
{// addr = 0x08051B2B  --  defined in 'main.c' at line 3012
    on_target = 0;
    followA();
    on_target = 1;
}

void followI()
{// addr = 0x08051B4C  --  defined in 'main.c' at line 3020
    Line* l;              // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    Buffer* buf;        // _cfa_ffffffe8
    char* emsg;                            // _cfa_ffffffe4
    int _v44;                              // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    _None _t45;                            // _t45

    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    l = CurrentTab->currentBuffer->currentLine;
    a = retrieveCurrentImg(CurrentTab->currentBuffer);
    if(a != 0) {
        _v56 = a->url;
        message( *(Sprintf("loading %s")), 0, 0);
        refresh();
        _t45 = baseURL(CurrentTab->currentBuffer);
        _v44 = 0;
        _v48 = 0;
        buf = loadGeneralFile(a->url, _t45, 0);
        if(buf != 0) {
            if(buf != 1) {
                pushBuffer(buf);
            }
        } else {
            _v56 = a->url;
            emsg =  *(Sprintf("Can't load %s"));
            disp_err_message(emsg, 0);
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
}

FormItemList* save_submit_formlist(FormItemList* src)
{// addr = 0x08051C66  --  defined in 'main.c' at line 3049
    FormList* list;   // _cfa_fffffff0
    FormList* srclist;   // _cfa_ffffffec
    FormItemList* srcitem;   // _cfa_ffffffe8
    FormItemList* item;   // _cfa_ffffffe4
    FormItemList* ret;   // _cfa_ffffffe0
    FormSelectOptionItem* opt;   // _cfa_ffffffdc
    FormSelectOptionItem* curopt;   // _cfa_ffffffd8
    FormSelectOptionItem* srcopt;   // _cfa_ffffffd4
    FormList* _t151;   // _t151
    FormItemList* _t170;   // _t170
    FormSelectOptionItem* _t195;   // _t195

    ret = 0;
    if(src != 0) {
        _t151 = src->parent;
        srclist = _t151;
         *__esp = 52;
        GC_malloc();
        list = _t151;
        list->method = srclist->method;
        list->action = Strdup(srclist->action);
        list->charset = srclist->charset;
        list->enctype = srclist->enctype;
        list->nitems = srclist->nitems;
        list->body = srclist->body;
        list->boundary = srclist->boundary;
        list->length = srclist->length;
        _t170 = srclist->item;
        srcitem = _t170;
        while(srcitem != 0) {
             *__esp = 72;
            GC_malloc();
            item = _t170;
            item->type = srcitem->type;
            item->name = Strdup(srcitem->name);
            item->value = Strdup(srcitem->value);
            item->checked = srcitem->checked;
            item->accept = srcitem->accept;
            item->size = srcitem->size;
            item->rows = srcitem->rows;
            item->maxlength = srcitem->maxlength;
            item->readonly = srcitem->readonly;
            curopt = 0;
            opt = curopt;
            srcopt = srcitem->select_option;
            while(srcopt != 0) {
                _t195 = srcopt->checked;
                if(_t195 != 0) {
                     *__esp = 16;
                    GC_malloc();
                    opt = _t195;
                    opt->value = Strdup(srcopt->value);
                    opt->label = Strdup(srcopt->label);
                    opt->checked = srcopt->checked;
                    if(item->select_option != 0) {
                        curopt->next = opt;
                        curopt = curopt->next;
                    } else {
                        curopt = opt;
                        item->select_option = curopt;
                    }
                }
                srcopt = srcopt->next;
            }
            item->select_option = opt;
            if(srcitem->label != 0) {
                item->label = Strdup(srcitem->label);
            }
            item->parent = list;
            item->next = 0;
            if(list->lastitem != 0) {
                list->lastitem->next = item;
                list->lastitem = item;
            } else {
                list->lastitem = item;
                list->item = list->lastitem;
            }
            if(srcitem == src) {
                ret = item;
            }
            _t170 = srcitem->next;
            srcitem = _t170;
        }
        return ret;
    }
    return 0;
}

Str conv_form_encoding(Str val, FormItemList* fi, Buffer* buf)
{// addr = 0x08051ED7  --  defined in 'main.c' at line 3129
    wc_ces charset;     // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    charset = SystemCharset;
    if(fi->parent->charset == 0) {
        if(buf->document_charset != 0 && buf->document_charset != 256) {
            charset = buf->document_charset;
        }
    } else {
        charset = fi->parent->charset;
    }
    return wc_Str_conv_strict(val, InnerCharset, charset);
}

void query_from_followform(Str* query, FormItemList* fi, int multipart)
{// addr = 0x08051F46  --  defined in 'main.c' at line 3144
    int x;                                 // _cfa_ffffffe8
    int y;                                 // _cfa_ffffffe4
    FormItemList* f2;   // _cfa_fffffff0
    FILE* body;           // _cfa_ffffffec
    int y;                                 // _cfa_ffffffe8
    int x;                                 // _cfa_ffffffe4
    char* _v44;                            // _cfa_ffffffd4 (outparam)
    char* _v48;                            // _cfa_ffffffd0 (outparam)
    struct form_list* _v52;   // _cfa_ffffffcc (outparam)
    int _v56;                              // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    struct _Str* _t290;   // _t290
    struct _Str* _t327;   // _t327
    char** _t381;                          // _t381
    FILE* _t432;          // _t432
    int _t464;                             // _t464
    int _t478;                             // _t478

    body = 0;
    if(multipart == 0) {
L3:
         *query = Strnew();
        f2 = fi->parent->item;
        while(f2 != 0) {
            if(f2->name == 0) {
L37:
                f2 = f2->next;
                continue;
            }
            if(f2->name->length != 0) {
L8:
                if(f2->type <= 7) {
                    goto __eax;
                }
                if(multipart == 0) {
                    if(f2->type != 7) {
                        if(f2->name != 0 && f2->name->length > 0) {
                            Strcat( *query, Str_form_quote(conv_form_encoding(f2->name, fi, CurrentTab->currentBuffer)));
                            if( *query->length + 1 >=  *query->area_size) {
                                Strgrow( *query);
                            }
                            _t327 =  *query;
                            _t478 = _t327->length;
                             *((char*)( *( *query) + _t478)) = 61;
                            _t327->length = _t478 + 1;
                             *((char*)( *( *query) +  *query->length)) = 0;
                        }
                        if(f2->value != 0) {
                            if(fi->parent->method != 2) {
                                Strcat( *query, Str_form_quote(conv_form_encoding(f2->value, fi, CurrentTab->currentBuffer)));
                            } else {
                                Strcat( *query, Str_form_quote(f2->value));
                            }
                        }
                    } else {
                        y = 0;
                        x = 0;
                        getMapXY(CurrentTab->currentBuffer, retrieveCurrentImg(CurrentTab->currentBuffer),  &y,  &x);
                        Strcat( *query, Str_form_quote(conv_form_encoding(f2->name, fi, CurrentTab->currentBuffer)));
                        _v56 = y;
                        Strcat( *query, Sprintf(".x=%d&"));
                        Strcat( *query, Str_form_quote(conv_form_encoding(f2->name, fi, CurrentTab->currentBuffer)));
                        _v56 = x;
                        Strcat( *query, Sprintf(".y=%d"));
                    }
                    if(f2->next != 0) {
                        if( *query->length + 1 >=  *query->area_size) {
                            Strgrow( *query);
                        }
                        _t290 =  *query;
                        _t464 = _t290->length;
                         *((char*)( *( *query) + _t464)) = 38;
                        _t290->length = _t464 + 1;
                         *((char*)( *( *query) +  *query->length)) = 0;
                    }
                } else {
                    if(f2->type != 7) {
                        if(f2->name != 0 && f2->name->length > 0 && f2->value != 0) {
                             *query = conv_form_encoding(f2->value, fi, CurrentTab->currentBuffer);
                            if(f2->type != 11) {
                                form_write_data(body, fi->parent->boundary,  *(conv_form_encoding(f2->name, fi, CurrentTab->currentBuffer)),  *( *query));
                            } else {
                                _t381 = wc_Str_conv_strict(f2->value, InnerCharset, SystemCharset);
                                form_write_from_file(body, fi->parent->boundary,  *(conv_form_encoding(f2->name, fi, CurrentTab->currentBuffer)),  *( *query),  *_t381);
                            }
                        }
                    } else {
                        x = 0;
                        y = 0;
                        getMapXY(CurrentTab->currentBuffer, retrieveCurrentImg(CurrentTab->currentBuffer),  &x,  &y);
                         *query = Strdup(conv_form_encoding(f2->name, fi, CurrentTab->currentBuffer));
                        Strcat_charp( *query, ".x");
                        _v56 = x;
                        form_write_data(body, fi->parent->boundary,  *( *query),  *(Sprintf("%d")));
                         *query = Strdup(conv_form_encoding(f2->name, fi, CurrentTab->currentBuffer));
                        Strcat_charp( *query, ".y");
                        _v56 = y;
                        form_write_data(body, fi->parent->boundary,  *( *query),  *(Sprintf("%d")));
                    }
                }
                goto L37;
            }
            if(multipart != 0) {
                goto L37;
            }
            if(f2->type != 0) {
                goto L37;
            }
            goto L8;
        }
        if(multipart == 0) {
            while(1) {
                query =  *query;
                __eax =  *query->length;
                if( *query->length <= 0) {
                    break;
                }
                query =  *query;
                query =  *query;
                 *query->length =  *query->length - 1;
                 *( *query) +  *query->length - 1 =  *( *( *query) +  *query->length - 1) & 255;
                if(__al == 38) {
                    query =  *query;
                    Strshrink( *query, 1);
                    continue;
                }
                return;
            }
L47:
            return;
        }
        _v52 = fi->parent->boundary;
        _v56 = "--%s--\n";
         *__esp = body;
        fprintf();
         *__esp = body;
        fclose();
        return;
    }
     *query = tmpfname(0, 0);
    _t432 =  *( *query);
    _v56 = 135037898;
     *__esp = _t432;
    fopen();
    body = _t432;
    if(body == 0) {
        goto L47;
    } else {
        fi->parent->body =  *( *query);
        _v44 = fi->parent->boundary;
        _v48 = fi->parent->body;
        _v52 = fi->parent;
        _v56 = CurrentPid;
        fi->parent->boundary =  *(Sprintf("------------------------------%d%ld%ld%ld"));
        goto L3;
    }
}

void submitForm()
{// addr = 0x08052630  --  defined in 'main.c' at line 3263
    _followForm(1);
}

void followForm()
{// addr = 0x08052644  --  defined in 'main.c' at line 3270
    _followForm(0);
}

void _followForm(int submit)
{// addr = 0x08052658  --  defined in 'main.c' at line 3276
    Anchor* a2;         // _cfa_ffffffe8
    char* p;                               // _cfa_ffffffe4
    FormItemList* f2;   // _cfa_ffffffdc
    Str tmp;               // _cfa_ffffffd8
    Str tmp2;              // _cfa_ffffffd4
    int i;                                 // _cfa_ffffffcc
    Buffer* buf;        // _cfa_ffffffc8
    struct stat st;       // _cfa_ffffff70
    Line* l;              // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    FormItemList* fi;   // _cfa_ffffffe0
    int multipart;                         // _cfa_ffffffd0
    _unknown_ _v184;                       // _cfa_ffffff48 (outparam)
    _unknown_ __ebx;                       // r1

    multipart = 0;
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    l = CurrentTab->currentBuffer->currentLine;
    a = retrieveCurrentForm(CurrentTab->currentBuffer);
    if(a != 0) {
        fi = a->url;
        if(fi->type > 11) {
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        }
        goto __eax;
    }
}

void topA()
{// addr = 0x08052F9E  --  defined in 'main.c' at line 3470
    HmarkerList* hl;   // _cfa_fffffff0
    BufferPoint* po;   // _cfa_ffffffec
    Anchor* an;         // _cfa_ffffffe8
    int hseq;                              // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    hl = CurrentTab->currentBuffer->hmarklist;
    hseq = 0;
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    if(hl == 0) {
        return;
    }
    if(hl->nmark == 0) {
        return;
    }
    if(hl->nmark >= prec_num) {
        if(prec_num > 0) {
            hseq = prec_num - 1;
        }
    } else {
        hseq = hl->nmark - 1;
    }
    while(hl->nmark > hseq) {
        po = hl->marks + (hseq + hseq + _t102 << 2);
        an = retrieveAnchor(CurrentTab->currentBuffer->href, po->line, po->pos);
        if(an == 0) {
            an = retrieveAnchor(CurrentTab->currentBuffer->formitem, po->line, po->pos);
        }
        hseq = hseq + 1;
        if(an == 0) {
            continue;
        } else {
            gotoLine(CurrentTab->currentBuffer, po->line);
            CurrentTab->currentBuffer->pos = po->pos;
            arrangeCursor(CurrentTab->currentBuffer);
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    }
}

void lastA()
{// addr = 0x08053101  --  defined in 'main.c' at line 3503
    HmarkerList* hl;   // _cfa_fffffff0
    BufferPoint* po;   // _cfa_ffffffec
    Anchor* an;         // _cfa_ffffffe8
    int hseq;                              // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    hl = CurrentTab->currentBuffer->hmarklist;
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    if(hl == 0) {
        return;
    }
    if(hl->nmark == 0) {
        return;
    }
    if(hl->nmark > prec_num) {
        if(prec_num <= 0) {
            hseq = hl->nmark - 1;
        } else {
            hseq = hl->nmark - prec_num;
        }
    } else {
        hseq = 0;
    }
    while(hseq >= 0) {
        po = hl->marks + (hseq + hseq + _t103 << 2);
        an = retrieveAnchor(CurrentTab->currentBuffer->href, po->line, po->pos);
        if(an == 0) {
            an = retrieveAnchor(CurrentTab->currentBuffer->formitem, po->line, po->pos);
        }
        hseq = hseq - 1;
        if(an == 0) {
            continue;
        } else {
            gotoLine(CurrentTab->currentBuffer, po->line);
            CurrentTab->currentBuffer->pos = po->pos;
            arrangeCursor(CurrentTab->currentBuffer);
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    }
}

void nextA()
{// addr = 0x0805326A  --  defined in 'main.c' at line 3538
    _nextA(0);
}

void prevA()
{// addr = 0x0805327E  --  defined in 'main.c' at line 3544
    _prevA(0);
}

void nextVA()
{// addr = 0x08053292  --  defined in 'main.c' at line 3550
    _nextA(1);
}

void prevVA()
{// addr = 0x080532A6  --  defined in 'main.c' at line 3556
    _prevA(1);
}

void _nextA(int visited)
{// addr = 0x080532BA  --  defined in 'main.c' at line 3563
    HmarkerList* hl;   // _cfa_fffffff0
    BufferPoint* po;   // _cfa_ffffffec
    Anchor* an;         // _cfa_ffffffe8
    Anchor* pan;        // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    int x;                                 // _cfa_ffffffdc
    int y;                                 // _cfa_ffffffd8
    int n;                                 // _cfa_ffffffd4
    int hseq;                              // _cfa_ffffffd0
    ParsedURL url;   // _cfa_ffffffa8
    _unknown_ _v96;                        // _cfa_ffffffa0 (outparam)
    _unknown_ _v100;                       // _cfa_ffffff9c (outparam)
    _unknown_ _v104;                       // _cfa_ffffff98 (outparam)

    hl = CurrentTab->currentBuffer->hmarklist;
    n = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    if(hl == 0) {
        return;
    }
    if(hl->nmark == 0) {
        return;
    }
    an = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if(visited != 1) {
        if(an == 0) {
            an = retrieveCurrentForm(CurrentTab->currentBuffer);
        }
    }
    y = CurrentTab->currentBuffer->currentLine->linenumber;
    x = CurrentTab->currentBuffer->pos;
    if(visited == 1) {
        n = hl->nmark;
    }
    i = 0;
L32:
    while(i < n) {
        pan = an;
        if(an == 0 || an->hseq < 0) {
            an = closest_next_anchor(CurrentTab->currentBuffer->href, 0, x, y);
            if(visited != 1) {
                an = closest_next_anchor(CurrentTab->currentBuffer->formitem, an, x, y);
            }
            if(an != 0) {
                x = an->start.pos;
                y = an->start;
                if(visited != 1) {
                    goto L31;
                }
                parseURL2(an->url,  &url, baseURL(CurrentTab->currentBuffer));
                if(getHashHist(URLHist,  *(parsedURL2Str( &url))) != 0) {
                    goto L37;
                }
                goto L31;
            } else {
                if(visited == 1) {
                    return;
                }
                an = pan;
                break;
            }
        } else {
            hseq = an->hseq + 1;
            while(hl->nmark > hseq) {
                po = hl->marks + (hseq + hseq + _t244 << 2);
                an = retrieveAnchor(CurrentTab->currentBuffer->href, po->line, po->pos);
                if(visited != 1 && an == 0) {
                    an = retrieveAnchor(CurrentTab->currentBuffer->formitem, po->line, po->pos);
                }
                hseq = hseq + 1;
                if(visited != 1 || an == 0) {
L21:
                    if(an == 0 || an == pan) {
                        continue;
                    } else {
L31:
                        i = i + 1;
                        goto L32;
                    }
                } else {
                    parseURL2(an->url,  &url, baseURL(CurrentTab->currentBuffer));
                    if(getHashHist(URLHist,  *(parsedURL2Str( &url))) != 0) {
L37:
                        if(an == 0) {
                            return;
                        }
                        if(an->hseq < 0) {
                            return;
                        }
                        po = hl->marks + (an->hseq + an->hseq + _t246 << 2);
                        gotoLine(CurrentTab->currentBuffer, po->line);
                        CurrentTab->currentBuffer->pos = po->pos;
                        arrangeCursor(CurrentTab->currentBuffer);
                        displayBuffer(CurrentTab->currentBuffer, 0);
                        return;
                    }
                    goto L21;
                }
            }
            if(visited == 1) {
                return;
            }
            an = pan;
            goto L37;
        }
    }
    if(visited == 1) {
        return;
    }
    goto L37;
}

void _prevA(int visited)
{// addr = 0x0805363C  --  defined in 'main.c' at line 3647
    HmarkerList* hl;   // _cfa_fffffff0
    BufferPoint* po;   // _cfa_ffffffec
    Anchor* an;         // _cfa_ffffffe8
    Anchor* pan;        // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    int x;                                 // _cfa_ffffffdc
    int y;                                 // _cfa_ffffffd8
    int n;                                 // _cfa_ffffffd4
    int hseq;                              // _cfa_ffffffd0
    ParsedURL url;   // _cfa_ffffffa8
    _unknown_ _v96;                        // _cfa_ffffffa0 (outparam)
    _unknown_ _v100;                       // _cfa_ffffff9c (outparam)
    _unknown_ _v104;                       // _cfa_ffffff98 (outparam)

    hl = CurrentTab->currentBuffer->hmarklist;
    n = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    if(hl == 0) {
        return;
    }
    if(hl->nmark == 0) {
        return;
    } else {
        an = retrieveCurrentAnchor(CurrentTab->currentBuffer);
        if(visited != 1) {
            if(an == 0) {
                an = retrieveCurrentForm(CurrentTab->currentBuffer);
            }
        }
        y = CurrentTab->currentBuffer->currentLine->linenumber;
        x = CurrentTab->currentBuffer->pos;
        if(visited == 1) {
            n = hl->nmark;
        }
        i = 0;
L33:
        while(i < n) {
            pan = an;
            if(an == 0 || an->hseq < 0) {
                an = closest_prev_anchor(CurrentTab->currentBuffer->href, 0, x, y);
                if(visited != 1) {
                    an = closest_prev_anchor(CurrentTab->currentBuffer->formitem, an, x, y);
                }
                if(an != 0) {
                    x = an->start.pos;
                    y = an->start;
                    if(visited == 1 && an != 0) {
                        parseURL2(an->url,  &url, baseURL(CurrentTab->currentBuffer));
                        if(getHashHist(URLHist,  *(parsedURL2Str( &url))) != 0) {
                            goto L38;
                        }
                    }
                    goto L32;
                } else {
                    if(visited == 1) {
                        return;
                    }
                    an = pan;
                    break;
                }
            } else {
                hseq = an->hseq - 1;
                while(hseq >= 0) {
                    po = hl->marks + (hseq + hseq + _t241 << 2);
                    an = retrieveAnchor(CurrentTab->currentBuffer->href, po->line, po->pos);
                    if(visited != 1 && an == 0) {
                        an = retrieveAnchor(CurrentTab->currentBuffer->formitem, po->line, po->pos);
                    }
                    hseq = hseq - 1;
                    if(visited != 1 || an == 0) {
L21:
                        if(an == 0 || an == pan) {
                            continue;
                        } else {
L32:
                            i = i + 1;
                            goto L33;
                        }
                    } else {
                        parseURL2(an->url,  &url, baseURL(CurrentTab->currentBuffer));
                        if(getHashHist(URLHist,  *(parsedURL2Str( &url))) != 0) {
L38:
                            if(an == 0) {
                                return;
                            }
                            if(an->hseq < 0) {
                                return;
                            }
                            po = hl->marks + (an->hseq + an->hseq + _t243 << 2);
                            gotoLine(CurrentTab->currentBuffer, po->line);
                            CurrentTab->currentBuffer->pos = po->pos;
                            arrangeCursor(CurrentTab->currentBuffer);
                            displayBuffer(CurrentTab->currentBuffer, 0);
                            return;
                        }
                        goto L21;
                    }
                }
                if(visited == 1) {
                    return;
                }
                an = pan;
                goto L38;
            }
        }
        if(visited == 1) {
            return;
        }
        goto L38;
    }
}

void nextX(int d, int dy)
{// addr = 0x080539BF  --  defined in 'main.c' at line 3731
    HmarkerList* hl;   // _cfa_fffffff0
    Anchor* an;         // _cfa_ffffffec
    Anchor* pan;        // _cfa_ffffffe8
    Line* l;              // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    int x;                                 // _cfa_ffffffdc
    int y;                                 // _cfa_ffffffd8
    int n;                                 // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    Line* _t113;          // _t113
    int _t114;                             // _t114
    int _t134;                             // _t134

    hl = CurrentTab->currentBuffer->hmarklist;
    n = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    if(hl == 0) {
        return;
    }
    if(hl->nmark == 0) {
        return;
    }
    an = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if(an == 0) {
        an = retrieveCurrentForm(CurrentTab->currentBuffer);
    }
    l = CurrentTab->currentBuffer->currentLine;
    x = CurrentTab->currentBuffer->pos;
    y = l->linenumber;
    pan = 0;
    i = 0;
L32:
    while(i < n) {
        if(an != 0) {
            if(d <= 0) {
                _t134 = an->start.pos - 1;
            } else {
                _t134 = an->end.pos;
            }
            x = _t134;
        }
        an = 0;
L17:
        while(1) {
            while(x >= 0 && l->len > x) {
                an = retrieveAnchor(CurrentTab->currentBuffer->href, y, x);
                if(an == 0) {
                    an = retrieveAnchor(CurrentTab->currentBuffer->formitem, y, x);
                }
                if(an == 0) {
                    x = x + d;
                    continue;
                } else {
                    pan = an;
                    break;
                }
            }
            if(dy == 0 || an != 0) {
L30:
                if(an == 0) {
L35:
                    if(pan == 0) {
                        return;
                    }
                    gotoLine(CurrentTab->currentBuffer, y);
                    CurrentTab->currentBuffer->pos = pan->start.pos;
                    arrangeCursor(CurrentTab->currentBuffer);
                    displayBuffer(CurrentTab->currentBuffer, 0);
                    return;
                }
                i = i + 1;
                goto L32;
            } else {
                if(dy <= 0) {
                    _t113 = l->prev;
                } else {
                    _t113 = l->next;
                }
                l = _t113;
                if(l == 0) {
                    goto L30;
                } else {
                    if(d > 0) {
                        _t114 = 0;
                    } else {
                        _t114 = l->len - 1;
                    }
                    x = _t114;
                    y = l->linenumber;
                    continue;
                }
            }
        }
    }
    goto L35;
}

void nextY(int d)
{// addr = 0x08053BD2  --  defined in 'main.c' at line 3787
    HmarkerList* hl;   // _cfa_fffffff0
    Anchor* an;         // _cfa_ffffffec
    Anchor* pan;        // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    int x;                                 // _cfa_ffffffe0
    int y;                                 // _cfa_ffffffdc
    int n;                                 // _cfa_ffffffd8
    int hseq;                              // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    signed int _t116;                      // _t116
    signed int _t130;                      // _t130

    hl = CurrentTab->currentBuffer->hmarklist;
    n = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    if(hl == 0) {
        return;
    }
    if(hl->nmark == 0) {
        return;
    }
    an = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if(an == 0) {
        an = retrieveCurrentForm(CurrentTab->currentBuffer);
    }
    x = CurrentTab->currentBuffer->pos;
    y = CurrentTab->currentBuffer->currentLine->linenumber + d;
    pan = 0;
    hseq = -1;
    i = 0;
    while(i < n) {
        if(an != 0) {
            _t130 = an->hseq;
            _t116 = _t130 >> 31;
            hseq = _t130 ^ _t116;
            hseq = hseq - _t116;
        }
        an = 0;
        while(y >= 0 && CurrentTab->currentBuffer->lastLine->linenumber >= y) {
            an = retrieveAnchor(CurrentTab->currentBuffer->href, y, x);
            if(an == 0) {
                an = retrieveAnchor(CurrentTab->currentBuffer->formitem, y, x);
            }
            if(an == 0 || (an->hseq ^ an->hseq >> 31) - (an->hseq >> 31) == hseq) {
                y = y + d;
                continue;
            } else {
                pan = an;
                break;
            }
        }
        if(an == 0) {
L22:
            if(pan == 0) {
                return;
            }
            gotoLine(CurrentTab->currentBuffer, pan->start.line);
            arrangeLine(CurrentTab->currentBuffer);
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
        i = i + 1;
    }
    goto L22;
}

void nextL()
{// addr = 0x08053DA5  --  defined in 'main.c' at line 3832
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    nextX(-1, 0);
}

void nextLU()
{// addr = 0x08053DC1  --  defined in 'main.c' at line 3838
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    nextX(-1, -1);
}

void nextR()
{// addr = 0x08053DDD  --  defined in 'main.c' at line 3844
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    nextX(1, 0);
}

void nextRD()
{// addr = 0x08053DF9  --  defined in 'main.c' at line 3850
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    nextX(1, 1);
}

void nextD()
{// addr = 0x08053E15  --  defined in 'main.c' at line 3856
    nextY(1);
}

void nextU()
{// addr = 0x08053E29  --  defined in 'main.c' at line 3862
    nextY(-1);
}

void nextBf()
{// addr = 0x08053E3D  --  defined in 'main.c' at line 3868
    Buffer* buf;        // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t16;                              // _t16

    i = 0;
L5:
L5:
    if(prec_num == 0) {
        _t16 = 1;
    } else {
        _t16 = prec_num;
    }
    if(_t16 > i) {
        goto L1;
    }
L11:
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
L1:
    buf = prevBuffer(CurrentTab->firstBuffer, CurrentTab->currentBuffer);
    if(buf != 0) {
        CurrentTab->currentBuffer = buf;
        i = i + 1;
        goto L5;
    }
    if(i != 0) {
        goto L11;
    }
}

void prevBf()
{// addr = 0x08053EBF  --  defined in 'main.c' at line 3886
    Buffer* buf;        // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t15;                              // _t15

    i = 0;
L5:
L5:
    if(prec_num == 0) {
        _t15 = 1;
    } else {
        _t15 = prec_num;
    }
    if(_t15 > i) {
        goto L1;
    }
L11:
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
L1:
    buf = CurrentTab->currentBuffer->nextBuffer;
    if(buf != 0) {
        CurrentTab->currentBuffer = buf;
        i = i + 1;
        goto L5;
    }
    if(i != 0) {
        goto L11;
    }
}

int checkBackBuffer(Buffer* buf)
{// addr = 0x08053F30  --  defined in 'main.c' at line 3904
    Buffer* fbuf;       // _cfa_fffffff8

    fbuf = buf->linkBuffer[1];
    if(fbuf == 0) {
L8:
        if(buf->nextBuffer == 0) {
            return 0;
        }
        return 1;
    }
    if(fbuf->frameQ == 0) {
        if((RenderFrame & 255) == 0 || buf->nextBuffer != fbuf) {
            goto L8;
        } else {
            if(fbuf->nextBuffer == 0) {
                return 0;
            }
            return 1;
        }
    }
    return 1;
}

void backBf()
{// addr = 0x08053F9F  --  defined in 'main.c' at line 3928
    Buffer* buf;        // _cfa_fffffff0
    struct frameset* fs;   // _cfa_ffffffec
    long int linenumber;                   // _cfa_ffffffe8
    long int top;                          // _cfa_ffffffe4
    int pos;                               // _cfa_ffffffe0
    int currentColumn;                     // _cfa_ffffffdc
    AnchorList* formitem;   // _cfa_ffffffd8
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    buf = CurrentTab->currentBuffer->linkBuffer[1];
    if(checkBackBuffer(CurrentTab->currentBuffer) == 0) {
        if(close_tab_back != 0 && nTab > 0) {
            deleteTab(CurrentTab);
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        }
        disp_message("Can't back...", 1);
        return;
    }
    delBuffer(CurrentTab->currentBuffer);
    if(buf != 0) {
        if(buf->frameQ == 0) {
            if((RenderFrame & 255) != 0 && CurrentTab->currentBuffer == buf) {
                delBuffer(CurrentTab->currentBuffer);
            }
        } else {
            linenumber = buf->frameQ->linenumber;
            top = buf->frameQ->top_linenumber;
            pos = buf->frameQ->pos;
            currentColumn = buf->frameQ->currentColumn;
            formitem = buf->frameQ->formitem;
            fs = popFrameTree( &(buf->frameQ));
            deleteFrameSet(buf->frameset);
            buf->frameset = fs;
            if(CurrentTab->currentBuffer == buf) {
                rFrame();
                CurrentTab->currentBuffer->topLine = lineSkip(CurrentTab->currentBuffer, CurrentTab->currentBuffer->firstLine, top - 1, 0);
                gotoLine(CurrentTab->currentBuffer, linenumber);
                CurrentTab->currentBuffer->pos = pos;
                CurrentTab->currentBuffer->currentColumn = currentColumn;
                arrangeCursor(CurrentTab->currentBuffer);
                formResetBuffer(CurrentTab->currentBuffer, formitem);
            }
        }
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
}

void deletePrevBuf()
{// addr = 0x080541B8  --  defined in 'main.c' at line 3977
    Buffer* buf;        // _cfa_fffffff0

    buf = CurrentTab->currentBuffer->nextBuffer;
    if(buf != 0) {
        delBuffer(buf);
        return;
    }
}

void cmd_loadURL(char* url, ParsedURL* current, char* referer, FormList* request)
{// addr = 0x080541DF  --  defined in 'main.c' at line 3986
    Buffer* buf;        // _cfa_fffffff0
    Str to;                // _cfa_ffffffec
    char* emsg;                            // _cfa_ffffffe8
    FormList* _v44;   // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc (outparam)
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    char* _t38;                            // _t38
    char* _t60;                            // _t60

    _v52 = 7;
    _v56 = "mailto:";
    _t38 = url;
     *__esp = _t38;
    strncasecmp();
    if(_t38 != 0 || non_null(Mailer) == 0) {
L4:
        refresh();
        _v44 = request;
        _v48 = 0;
        buf = loadGeneralFile(url, current, referer);
        if(buf != 0) {
            if(buf != 1) {
                pushBuffer(buf);
                if((RenderFrame & 255) != 0 && CurrentTab->currentBuffer->frameset != 0) {
                    rFrame();
                }
            }
        } else {
            _v56 =  *(wc_Str_conv(Strnew_charp(url), SystemCharset, InnerCharset));
            emsg =  *(Sprintf("Can't load %s"));
            disp_err_message(emsg, 0);
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    } else {
        _v56 = 63;
        _t60 = url;
         *__esp = _t60;
        strchr();
        if(_t60 != 0) {
            goto L4;
        } else {
            to = Strnew_charp( &(url[7]));
            fmTerm();
             *__esp =  *(myExtCommand(Mailer, shell_quote(file_unquote(to->ptr)), 0));
            system();
            fmInit();
            displayBuffer(CurrentTab->currentBuffer, 1);
            pushHashHist(URLHist, url);
            return;
        }
    }
}

void goURL0(char* prompt, int relative)
{// addr = 0x0805439A  --  defined in 'main.c' at line 4042
    char* url;                             // _cfa_fffffff0
    char* referer;                         // _cfa_ffffffec
    ParsedURL* current;   // _cfa_ffffffe8
    Buffer* cur_buf;    // _cfa_ffffffe4
    Hist* hist;           // _cfa_ffffffe0
    Anchor* a;          // _cfa_ffffffdc
    char* c_url;                           // _cfa_ffffffd8
    char* a_url;                           // _cfa_ffffffd4
    ParsedURL p_url;   // _cfa_ffffffac
    _unknown_ _v108;                       // _cfa_ffffff94 (outparam)
    _unknown_ _v112;                       // _cfa_ffffff90 (outparam)
    _unknown_ _v116;                       // _cfa_ffffff8c (outparam)
    _unknown_ _v120;                       // _cfa_ffffff88 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    ParsedURL* _t121;   // _t121

    cur_buf = CurrentTab->currentBuffer;
    url = searchKeyData();
    if(url != 0) {
L16:
        if(url == 0) {
L22:
            if(url == 0 || ( *url & 255) == 0) {
                displayBuffer(CurrentTab->currentBuffer, 1);
                return;
            } else {
                __eflags = ( *url & 255) - 35;
                if(__eflags != 0) {
                    __eflags = relative;
                    if(relative == 0) {
                        current = 0;
                        referer = 0;
                    } else {
                        current = baseURL(CurrentTab->currentBuffer);
                        referer =  *(parsedURL2Str( &(CurrentTab->currentBuffer->currentURL)));
                    }
                    parseURL2(url,  &p_url, current);
                    pushHashHist(URLHist,  *(parsedURL2Str( &p_url)));
                    cmd_loadURL(url, current, referer, 0);
                    __eflags = CurrentTab->currentBuffer - cur_buf;
                    if(__eflags == 0) {
                        return;
                    } else {
                        _t121 =  &(CurrentTab->currentBuffer->currentURL);
                        __eflags = _t121;
                        pushHashHist(URLHist,  *(parsedURL2Str(_t121)));
                        return;
                    }
                }
                gotoLabel( &(url[1]));
                return;
            }
        }
        if(relative != 0 || ( *url & 255) == 35) {
            if(CurrentTab->currentBuffer->document_charset == 0) {
                goto L21;
            }
            url =  *(wc_Str_conv_strict(Strnew_charp(url), InnerCharset, CurrentTab->currentBuffer->document_charset));
        } else {
L21:
            url =  *(wc_Str_conv_strict(Strnew_charp(url), InnerCharset, SystemCharset));
        }
        goto L22;
    }
    hist = copyHist(URLHist);
    current = baseURL(CurrentTab->currentBuffer);
    if(current != 0) {
        c_url =  *(parsedURL2Str(current));
        if(DefaultURLString != 1) {
            pushHist(hist, c_url);
        } else {
            url = c_url;
            if(DecodeURL != 0) {
                url = url_unquote_conv(url, 0);
            }
        }
    }
    a = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if(a != 0) {
        parseURL2(a->url,  &p_url, current);
        a_url =  *(parsedURL2Str( &p_url));
        if(DefaultURLString != 2) {
            pushHist(hist, a_url);
        } else {
            url = a_url;
            if(DecodeURL != 0) {
                url = url_unquote_conv(url, CurrentTab->currentBuffer->document_charset);
            }
        }
    }
    url = inputLineHistSearch(prompt, url, 256, hist, 0);
    if(url != 0) {
        while(( *url & 255) != 0 && ( *( &MYCTYPE_MAP + ( *url & 0xff)) & 2) != 0) {
            url =  &(url[1]);
            __eflags = url;
        }
    }
}

void goURL()
{// addr = 0x080546D7  --  defined in 'main.c' at line 4113
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    goURL0("Goto URL: ", 0);
}

void gorURL()
{// addr = 0x080546F3  --  defined in 'main.c' at line 4118
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    goURL0("Goto relative URL: ", 1);
}

void cmd_loadBuffer(Buffer* buf, int prop, int linkid)
{// addr = 0x0805470F  --  defined in 'main.c' at line 4124
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    Buffer* _t40;       // _t40
    ParsedURL* _t53;   // _t53
    signed int _t55;                       // _t55

    __eflags = buf;
    if(__eflags != 0) {
        __eflags = buf - 1;
        if(__eflags != 0) {
            buf->bufferprop.scheme = buf->bufferprop.scheme & 65535 | prop | 8;
            _t40 = buf;
            __eflags = _t40->bufferprop & 0x10;
            if((_t40->bufferprop & 0x10) == 0) {
                _t53 =  &(buf->currentURL);
                __eflags = _t53;
                copyParsedURL(_t53,  &(CurrentTab->currentBuffer->currentURL));
            }
            __eflags = linkid - -1;
            if(__eflags != 0) {
                _t55 =  *((intOrPtr*)( &REV_LB + linkid * 4)) + 4;
                __eflags = _t55;
                 *(buf->topLine + _t55 * 4) = CurrentTab->currentBuffer;
                 *(CurrentTab->currentBuffer->topLine + (linkid + 4) * 4) = buf;
            }
            pushBuffer(buf);
        }
    } else {
        disp_err_message("Can't load string", 0);
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
}

void ldBmark()
{// addr = 0x080547E1  --  defined in 'main.c' at line 4143
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    cmd_loadURL(BookmarkFile, 0, -1, 0);
}

void adBmark()
{// addr = 0x0805480E  --  defined in 'main.c' at line 4150
    Str tmp;               // _cfa_ffffffe0
    FormList* request;   // _cfa_ffffffdc
    intOrPtr _v48;                         // _cfa_ffffffd0
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    intOrPtr _v72;                         // _cfa_ffffffb8 (outparam)
    intOrPtr _v76;                         // _cfa_ffffffb4 (outparam)
    intOrPtr _v80;                         // _cfa_ffffffb0 (outparam)
    intOrPtr _v84;                         // _cfa_ffffffac (outparam)
    intOrPtr _v88;                         // _cfa_ffffffa8 (outparam)
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    char* _t33;                            // _t33
    intOrPtr* _t45;                        // _t45
    intOrPtr* _t48;                        // _t48
    intOrPtr* _t50;                        // _t50

    _t33 = wc_ces_to_charset(BookmarkCharset);
    _v48 =  *(Str_form_quote(wc_Str_conv_strict(Strnew_charp(CurrentTab->currentBuffer->buffername.scheme), InnerCharset, BookmarkCharset)));
    _t45 = Str_form_quote(parsedURL2Str( &(CurrentTab->currentBuffer->currentURL)));
    _t48 = Str_form_quote(Strnew_charp(BookmarkFile));
    _t50 = Str_form_quote(localCookie());
    _v72 = _t33;
    _v76 = _v48;
    _v80 =  *_t45;
    _v84 =  *_t48;
    _v88 =  *_t50;
    tmp = Sprintf("mode=panel&cookie=%s&bmark=%s&url=%s&title=%s&charset=%s");
    request = newFormList(0, "post", 0, 0, 0, 0, 0);
    request->body = tmp->ptr;
    request->length = tmp->length;
    cmd_loadURL("file:///$LIB/w3mbookmark", 0, -1, request);
}

void ldOpt()
{// addr = 0x08054950  --  defined in 'main.c' at line 4180
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    cmd_loadBuffer(load_option_panel(), 16, -1);
}

void setOpt()
{// addr = 0x08054975  --  defined in 'main.c' at line 4186
    char* opt;                             // _cfa_fffffff0
    char* v;                               // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    char* _v52;                            // _cfa_ffffffcc (outparam)
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    char* _t45;                            // _t45
    char* _t51;                            // _t51

    CurrentKeyData = 0;
    opt = searchKeyData();
    if(opt == 0 || ( *opt & 255) == 0) {
L3:
        if(opt == 0 || ( *opt & 255) == 0) {
L9:
            opt = inputLineHistSearch("Set option: ", opt, 16, TextHist, 0);
            if(opt == 0 || ( *opt & 255) == 0) {
                displayBuffer(CurrentTab->currentBuffer, 0);
                return;
            } else {
                goto L12;
            }
        } else {
            v = get_param_option(opt);
            if(v == 0) {
                _t45 = 135036496;
            } else {
                _t45 = v;
            }
            _v52 = _t45;
            _v56 = opt;
            opt =  *(Sprintf("%s=%s"));
            goto L9;
        }
    } else {
        _v56 = 61;
        _t51 = opt;
         *__esp = _t51;
        strchr();
        if(_t51 != 0) {
L12:
            if(set_param_option(opt) != 0) {
                sync_with_option();
            }
            displayBuffer(CurrentTab->currentBuffer, 4);
            return;
        }
        goto L3;
    }
}

void msgs()
{// addr = 0x08054A89  --  defined in 'main.c' at line 4209
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    cmd_loadBuffer(message_list_panel(), 16, -1);
}

void pginfo()
{// addr = 0x08054AAE  --  defined in 'main.c' at line 4215
    Buffer* buf;        // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    buf = CurrentTab->currentBuffer->linkBuffer[3];
    if(buf == 0) {
        buf = CurrentTab->currentBuffer->linkBuffer[2];
        if(buf != 0) {
            delBuffer(buf);
        }
        buf = page_info_panel(CurrentTab->currentBuffer);
        cmd_loadBuffer(buf, 0, 2);
        return;
    }
    CurrentTab->currentBuffer = buf;
    displayBuffer(CurrentTab->currentBuffer, 0);
}

void follow_map(struct parsed_tagarg* arg)
{// addr = 0x08054B3C  --  defined in 'main.c' at line 4231
    char* name;                            // _cfa_fffffff0
    Anchor* an;         // _cfa_ffffffec
    MapArea* a;        // _cfa_ffffffe8
    int x;                                 // _cfa_ffffffe4
    int y;                                 // _cfa_ffffffe0
    Buffer* buf;        // _cfa_ffffffdc
    ParsedURL p_url;   // _cfa_ffffffb4
    _unknown_ _v92;                        // _cfa_ffffffa4 (outparam)
    _unknown_ _v96;                        // _cfa_ffffffa0 (outparam)
    _unknown_ _v100;                       // _cfa_ffffff9c (outparam)
    char* _v104;                           // _cfa_ffffff98 (outparam)
    _unknown_ __ebx;                       // r1
    char** _t111;                          // _t111
    char* _t119;                           // _t119
    char** _t125;                          // _t125
    char* _t137;                           // _t137

    name = tag_get_value(arg, "link");
    an = retrieveCurrentImg(CurrentTab->currentBuffer);
    x = (CurrentTab->currentBuffer->cursorX.scheme & 65535) + (CurrentTab->currentBuffer->rootX.scheme & 65535);
    y = (CurrentTab->currentBuffer->cursorY.scheme & 65535) + (CurrentTab->currentBuffer->rootY.scheme & 65535);
    a = follow_map_menu(CurrentTab->currentBuffer, name, an, x, y);
    if(a == 0) {
        return;
    }
    if(a->url == 0) {
        return;
    }
    if((a & 255) == 0) {
        return;
    }
    if((a & 255) != 35) {
        parseURL2(a->url,  &p_url, baseURL(CurrentTab->currentBuffer));
        pushHashHist(URLHist,  *(parsedURL2Str( &p_url)));
        if(check_target == 0 || open_tab_blank == 0 || a->target == 0) {
L14:
            _t111 = parsedURL2Str( &(CurrentTab->currentBuffer->currentURL));
            cmd_loadURL(a->url, baseURL(CurrentTab->currentBuffer),  *_t111, 0);
            return;
        } else {
            _t119 = a->target;
            _v104 = "_new";
             *__esp = _t119;
            strcasecmp();
            if(_t119 == 0) {
L10:
                _newT();
                buf = CurrentTab->currentBuffer;
                _t125 = parsedURL2Str( &(CurrentTab->currentBuffer->currentURL));
                cmd_loadURL(a->url, baseURL(CurrentTab->currentBuffer),  *_t125, 0);
                if(CurrentTab->currentBuffer == buf) {
                    deleteTab(CurrentTab);
                } else {
                    delBuffer(buf);
                }
                displayBuffer(CurrentTab->currentBuffer, 1);
                return;
            }
            _t137 = a->target;
            _v104 = "_blank";
             *__esp = _t137;
            strcasecmp();
            if(_t137 != 0) {
                goto L14;
            }
            goto L10;
        }
    }
    gotoLabel( &(a->url[1]));
}

void linkMn()
{// addr = 0x08054DB5  --  defined in 'main.c' at line 4283
    LinkList* l;      // _cfa_fffffff0
    ParsedURL p_url;   // _cfa_ffffffc8
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    char** _t39;                           // _t39

    l = link_menu(CurrentTab->currentBuffer);
    if(l == 0) {
        return;
    }
    if(l->url != 0) {
        if((l & 255) != 35) {
            parseURL2(l->url,  &p_url, baseURL(CurrentTab->currentBuffer));
            pushHashHist(URLHist,  *(parsedURL2Str( &p_url)));
            _t39 = parsedURL2Str( &(CurrentTab->currentBuffer->currentURL));
            cmd_loadURL(l->url, baseURL(CurrentTab->currentBuffer),  *_t39, 0);
            return;
        }
        gotoLabel( &(l->url[1]));
        return;
    }
}

void anchorMn(_None* menu_func, int go)
{// addr = 0x08054E9D  --  defined in 'main.c' at line 4301
    Anchor* a;          // _cfa_fffffff0
    BufferPoint* po;   // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    Anchor* _t36;       // _t36

    if(CurrentTab->currentBuffer->href == 0) {
        return;
    }
    if(CurrentTab->currentBuffer->hmarklist == 0) {
        return;
    }
     *__esp = CurrentTab->currentBuffer;
    _t36 = menu_func;
    _t36->url();
    a = _t36;
    if(a == 0) {
        return;
    }
    if(a->hseq >= 0) {
        po = CurrentTab->currentBuffer->hmarklist->marks + (a->hseq + a->hseq + _t58 << 2);
        gotoLine(CurrentTab->currentBuffer, po->line);
        CurrentTab->currentBuffer->pos = po->pos;
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 0);
        if(go != 0) {
            followA();
            return;
        }
    }
}

void accessKey()
{// addr = 0x08054F83  --  defined in 'main.c' at line 4321
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    anchorMn(accesskey_menu, 1);
}

void listMn()
{// addr = 0x08054F9F  --  defined in 'main.c' at line 4327
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    anchorMn(list_menu, 1);
}

void movlistMn()
{// addr = 0x08054FBB  --  defined in 'main.c' at line 4332
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    anchorMn(list_menu, 0);
}

void linkLst()
{// addr = 0x08054FD7  --  defined in 'main.c' at line 4340
    Buffer* buf;        // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    buf = link_list_panel(CurrentTab->currentBuffer);
    if(buf != 0) {
        buf->document_charset = CurrentTab->currentBuffer->document_charset;
        cmd_loadBuffer(buf, 0, -1);
        return;
    }
}

void cooLst()
{// addr = 0x0805502A  --  defined in 'main.c' at line 4355
    Buffer* buf;        // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    buf = cookie_list_panel();
    if(buf != 0) {
        cmd_loadBuffer(buf, 16, -1);
        return;
    }
}

void ldHist()
{// addr = 0x0805505B  --  defined in 'main.c' at line 4367
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    cmd_loadBuffer(historyBuffer(URLHist), 16, -1);
}

void svA()
{// addr = 0x08055088  --  defined in 'main.c' at line 4374
    CurrentKeyData = 0;
    do_download = 1;
    followA();
    do_download = 0;
}

void svI()
{// addr = 0x080550B3  --  defined in 'main.c' at line 4383
    CurrentKeyData = 0;
    do_download = 1;
    followI();
    do_download = 0;
}

void svBuf()
{// addr = 0x080550DE  --  defined in 'main.c' at line 4392
    char* qfile;                           // _cfa_fffffff0
    char* file;                            // _cfa_ffffffec
    FILE* f;              // _cfa_ffffffe8
    int is_pipe;                           // _cfa_ffffffe4
    char* emsg;                            // _cfa_ffffffe0
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    intOrPtr _v72;                         // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    char* _t65;                            // _t65
    FILE* _t75;           // _t75
    FILE* _t100;          // _t100
    unsigned int _t103;                    // _t103
    unsigned int _t108;                    // _t108

    qfile = 0;
    CurrentKeyData = 0;
    file = searchKeyData();
    if(file == 0 || ( *file & 255) == 0) {
        qfile = inputLineHistSearch("Save buffer to: ", 0, 128, SaveHist, 0);
        if(qfile == 0 || ( *qfile & 255) == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        } else {
            goto L5;
        }
    }
L5:
    _t108 = SystemCharset;
    _t103 = InnerCharset;
    if(qfile == 0) {
        _t65 = file;
    } else {
        _t65 = qfile;
    }
    file =  *(wc_Str_conv_strict(Strnew_charp(_t65), _t103, _t108));
    if(( *file & 255) != 124) {
        if(qfile != 0) {
            file =  *(unescape_spaces(Strnew_charp(qfile)));
            file =  *(wc_Str_conv_strict(Strnew_charp(file), InnerCharset, SystemCharset));
        }
        file = expandPath(file);
        if(checkOverWrite(file) >= 0) {
            _t75 = file;
            _v72 = 135037898;
             *__esp = _t75;
            fopen();
            f = _t75;
            is_pipe = 0;
            goto L15;
        } else {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    } else {
        is_pipe = 1;
        _t100 =  &(file[1]);
        _v72 = 135037898;
         *__esp = _t100;
        popen();
        f = _t100;
L15:
        if(f != 0) {
            saveBuffer(CurrentTab->currentBuffer, f, 1);
            if(is_pipe == 0) {
                 *__esp = f;
                fclose();
            } else {
                 *__esp = f;
                pclose();
            }
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
        _v72 =  *(wc_Str_conv(Strnew_charp(file), SystemCharset, InnerCharset));
        emsg =  *(Sprintf("Can't open %s"));
        disp_err_message(emsg, 1);
        return;
    }
}

void svSrc()
{// addr = 0x08055329  --  defined in 'main.c' at line 4441
    char* file;                            // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(CurrentTab->currentBuffer->sourcefile != 0) {
        CurrentKeyData = 0;
        PermitSaveToPipe = 1;
        if(CurrentTab->currentBuffer->real_scheme != 4) {
            file = guess_save_name(CurrentTab->currentBuffer, CurrentTab->currentBuffer->currentURL.file);
        } else {
            file =  *(wc_Str_conv(Strnew_charp(guess_save_name(0, CurrentTab->currentBuffer->currentURL.real_file)), SystemCharset, InnerCharset));
        }
        _doFileCopy(CurrentTab->currentBuffer->sourcefile, file, 0);
        PermitSaveToPipe = 0;
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
}

void _peekURL(int only_img)
{// addr = 0x08055427  --  defined in 'main.c' at line 4461
    Anchor* a;          // _cfa_fffffff0
    Lineprop* pp;     // _cfa_ffffffec
    ParsedURL pu;    // _cfa_ffffffc4
    intOrPtr _v68;                         // _cfa_ffffffbc (outparam)
    Lineprop* _v72;   // _cfa_ffffffb8 (outparam)
    Anchor* _t45;       // _t45
    Lineprop* _t52;   // _t52
    Anchor* _t91;       // _t91

    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    if(CurrentKey != prev_key || s.15239 == 0) {
        offset = 0;
        s.15239 = 0;
        if(only_img != 0) {
            _t45 = 0;
        } else {
            _t45 = retrieveCurrentAnchor(CurrentTab->currentBuffer);
        }
        a = _t45;
        if(a != 0) {
L18:
            if(s.15239 == 0) {
                parseURL2(a->url,  &pu, baseURL(CurrentTab->currentBuffer));
                s.15239 = parsedURL2Str( &pu);
            }
            if(DecodeURL != 0) {
                s.15239 = Strnew_charp(url_unquote_conv( *s.15239, CurrentTab->currentBuffer->document_charset));
            }
            s.15239 = checkType(s.15239,  &pp, 0);
            _t52 = s.15239->length + s.15239->length;
             *__esp = _t52;
            GC_malloc_atomic();
            p.15240 = _t52;
            _v68 = s.15239->length + s.15239->length;
            _v72 = p.15240;
             *__esp = pp;
            bcopy();
            goto L24;
        } else {
            if(only_img != 0) {
                _t91 = 0;
            } else {
                _t91 = retrieveCurrentForm(CurrentTab->currentBuffer);
            }
            a = _t91;
            if(a != 0) {
                s.15239 = Strnew_charp(form2str(a->url));
                goto L18;
            } else {
                a = retrieveCurrentImg(CurrentTab->currentBuffer);
                if(a != 0) {
                    goto L18;
                }
                return;
            }
        }
    } else {
        if(s.15239->length - offset < COLS) {
            if(s.15239->length <= offset) {
                offset = 0;
            }
        } else {
            offset = offset + 1;
        }
L24:
        n.15243 = searchKeyNum();
        if(n.15243 > 1) {
            if(s.15239->length > (COLS - 1) * (n.15243 - 1)) {
                offset = (COLS - 1) * (n.15243 - 1);
            }
        }
        while(s.15239->length > offset && ( *(p.15240 + offset + offset) & 0x400) != 0) {
            offset = offset + 1;
        }
        disp_message_nomouse( *s.15239 + offset, 1);
        return;
    }
}

void peekURL()
{// addr = 0x080556C8  --  defined in 'main.c' at line 4521
    _peekURL(0);
}

void peekIMG()
{// addr = 0x080556DC  --  defined in 'main.c' at line 4527
    _peekURL(1);
}

Str currentURL()
{// addr = 0x080556F0  --  defined in 'main.c' at line 4534
    if((CurrentTab->currentBuffer->bufferprop.scheme & 8) == 0) {
        return parsedURL2Str( &(CurrentTab->currentBuffer->currentURL));
    }
    return Strnew_size(0);
}

void curURL()
{// addr = 0x0805572F  --  defined in 'main.c' at line 4541
    Lineprop* pp;     // _cfa_fffffff0
    intOrPtr _v36;                         // _cfa_ffffffdc (outparam)
    Lineprop* _v40;   // _cfa_ffffffd8 (outparam)
    Lineprop* _t33;   // _t33

    if((CurrentTab->currentBuffer->bufferprop & 8) != 0) {
        return;
    } else {
        if(CurrentKey != prev_key || s.15396 == 0) {
            offset.15399 = 0;
            s.15396 = currentURL();
            if(DecodeURL != 0) {
                s.15396 = Strnew_charp(url_unquote_conv( *s.15396, 0));
            }
            s.15396 = checkType(s.15396,  &pp, 0);
            _t33 = s.15396->length + s.15396->length;
             *__esp = _t33;
            GC_malloc_atomic();
            p.15397 = _t33;
            _v36 = s.15396->length + s.15396->length;
            _v40 = p.15397;
             *__esp = pp;
            bcopy();
        } else {
            if(s.15396->length - offset.15399 < COLS) {
                if(s.15396->length <= offset.15399) {
                    offset.15399 = 0;
                }
            } else {
                offset.15399 = offset.15399 + 1;
            }
        }
        n.15400 = searchKeyNum();
        if(n.15400 > 1) {
            if(s.15396->length > (COLS - 1) * (n.15400 - 1)) {
                offset.15399 = (COLS - 1) * (n.15400 - 1);
            }
        }
        while(s.15396->length > offset.15399 && ( *(p.15397 + offset.15399 + offset.15399) & 0x400) != 0) {
            offset.15399 = offset.15399 + 1;
        }
        disp_message_nomouse( *s.15396 + offset.15399, 1);
        return;
    }
}

void vwSrc()
{// addr = 0x08055906  --  defined in 'main.c' at line 4580
    wc_bool old_fix_width_conv;   // _cfa_fffffff3
    Buffer* buf;        // _cfa_ffffffec
    wc_ces old_charset;   // _cfa_ffffffe8
    FILE* f;              // _cfa_ffffffe4
    Str tmpf;              // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    int _t177;                             // _t177
    int _t178;                             // _t178
    char* _t187;                           // _t187
    Buffer* _t205;      // _t205
    char* _t236;                           // _t236
    char* _t264;                           // _t264
    FILE* _t267;          // _t267
    int _t273;                             // _t273
    int _t295;                             // _t295
    Buffer* _t301;      // _t301

    if(CurrentTab->currentBuffer->type == 0) {
        return;
    }
    if((CurrentTab->currentBuffer->bufferprop & 2) != 0) {
        return;
    }
    buf =  *(CurrentTab->currentBuffer + 44);
    if(buf != 0) {
L4:
        CurrentTab->currentBuffer = buf;
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    buf =  *(CurrentTab->currentBuffer + 44);
    if(buf != 0) {
        goto L4;
    }
    if(CurrentTab->currentBuffer->sourcefile == 0) {
        if(CurrentTab->currentBuffer->pagerSource == 0) {
            return;
        }
        _t264 = CurrentTab->currentBuffer->type;
        _v56 = "text/plain";
         *__esp = _t264;
        strcasecmp();
        if(_t264 != 0) {
            return;
        }
        tmpf = tmpfname(1, 0);
        _t267 = tmpf->ptr;
        _v56 = 135037898;
         *__esp = _t267;
        fopen();
        f = _t267;
        if(f == 0) {
            return;
        }
        old_charset = DisplayCharset;
        old_fix_width_conv =  *135119013 & 255;
        if(CurrentTab->currentBuffer->document_charset == 256) {
            _t273 = 0;
        } else {
            _t273 = CurrentTab->currentBuffer->document_charset;
        }
        DisplayCharset = _t273;
         *135119013 = 0;
        saveBufferBody(CurrentTab->currentBuffer, f, 1);
        DisplayCharset = old_charset;
         *135119013 = old_fix_width_conv & 255;
         *__esp = f;
        fclose();
        CurrentTab->currentBuffer->sourcefile = tmpf->ptr;
    }
    _t295 = COLS;
    if(showLineNum == 0) {
        _t177 = 1;
    } else {
        _t177 = 6;
    }
    _t178 = _t295 - _t177;
    _t179 = _t178 < 0 ? 0 : _t178;
    buf = newBuffer(_t178 < 0 ? 0 : _t178);
    if(is_html_type(CurrentTab->currentBuffer->type) != 0) {
        buf->type = "text/plain";
        if(CurrentTab->currentBuffer->real_type == 0 || is_html_type(CurrentTab->currentBuffer->real_type) == 0) {
            buf->real_type = CurrentTab->currentBuffer->real_type;
        } else {
            buf->real_type = "text/plain";
        }
        _v56 = CurrentTab->currentBuffer->buffername;
        buf->buffername =  *(Sprintf("source of %s"));
         *(buf + 44) = CurrentTab->currentBuffer;
         *(CurrentTab->currentBuffer + 44) = buf;
L28:
        _t301 = CurrentTab->currentBuffer;
        _t205 = buf;
        _t205->currentURL.scheme = _t301->currentURL.scheme;
        _t205->currentURL.user = _t301->currentURL.user;
        _t205->currentURL.pass = _t301->currentURL.pass;
        _t205->currentURL.host = _t301->currentURL.host;
        _t205->currentURL.port = _t301->currentURL.port;
        _t205->currentURL.file = _t301->currentURL.file;
        _t205->currentURL.real_file = _t301->currentURL.real_file;
        _t205->currentURL.query = _t301->currentURL.query;
        _t205->currentURL.label = _t301->currentURL.label;
        _t205->currentURL.is_nocache = _t301->currentURL.is_nocache;
        buf->real_scheme = CurrentTab->currentBuffer->real_scheme;
        buf->filename = CurrentTab->currentBuffer->filename;
        buf->sourcefile = CurrentTab->currentBuffer->sourcefile;
        buf->header_source = CurrentTab->currentBuffer->header_source;
        buf->search_header = CurrentTab->currentBuffer->search_header & 255;
        buf->document_charset = CurrentTab->currentBuffer->document_charset;
        buf->clone = CurrentTab->currentBuffer->clone;
         *(buf->clone) =  &(buf->filename);
        buf->need_reshape = 1;
        reshapeBuffer(buf);
        pushBuffer(buf);
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    _t187 = CurrentTab->currentBuffer->type;
    _v56 = "text/plain";
     *__esp = _t187;
    strcasecmp();
    if(_t187 == 0) {
        buf->type = "text/html";
        if(CurrentTab->currentBuffer->real_type == 0) {
L26:
            buf->real_type = CurrentTab->currentBuffer->real_type;
L27:
            _v56 = CurrentTab->currentBuffer->buffername;
            buf->buffername =  *(Sprintf("HTML view of %s"));
             *(buf + 44) = CurrentTab->currentBuffer;
             *(CurrentTab->currentBuffer + 44) = buf;
            goto L28;
        }
        _t236 = CurrentTab->currentBuffer->real_type;
        _v56 = "text/plain";
         *__esp = _t236;
        strcasecmp();
        if(_t236 != 0) {
            goto L26;
        }
        buf->real_type = "text/html";
        goto L27;
    }
}

void reload()
{// addr = 0x08055DB6  --  defined in 'main.c' at line 4671
    Buffer* buf;        // _cfa_fffffff0
    Buffer* fbuf;       // _cfa_ffffffec
    wc_ces old_charset;   // _cfa_ffffffe8
    Str url;               // _cfa_ffffffe4
    FormList* request;   // _cfa_ffffffe0
    int multipart;                         // _cfa_ffffffdc
    Str query;             // _cfa_ffffffd8
    _unknown_ _v84;                        // _cfa_ffffffac
    struct stat st;       // _cfa_ffffff80
    signed char _v144;                     // _cfa_ffffff70
    short int _v168;                       // _cfa_ffffff58
    signed int _v298;                      // _cfa_fffffed6
    signed int _v300;                      // _cfa_fffffed4
    signed int _v302;                      // _cfa_fffffed2
    signed int _v304;                      // _cfa_fffffed0
    char* _v336;                           // _cfa_fffffeb0
    Buffer sbuf;        // _cfa_fffffe7c
    FormList* _v412;   // _cfa_fffffe64
    int _v416;                             // _cfa_fffffe60
    _unknown_ _v420;                       // _cfa_fffffe5c (outparam)
    struct _Buffer* _v424;   // _cfa_fffffe58 (outparam)
    _unknown_ __ebx;                       // r1
    char* _t252;                           // _t252
    char* _t256;                           // _t256
    char* _t331;                           // _t331
    char* _t338;                           // _t338
    char* _t341;                           // _t341

    fbuf = 0;
    if((CurrentTab->currentBuffer->bufferprop & 8) != 0) {
        _t341 = CurrentTab->currentBuffer->buffername;
        _v424 = "Download List Panel";
         *__esp = _t341;
        strcmp();
        if(_t341 == 0) {
            ldDL();
            return;
        }
        disp_err_message("Can't reload...", 1);
        return;
    }
    if(CurrentTab->currentBuffer->currentURL != 4) {
L7:
        copyBuffer( &sbuf, CurrentTab->currentBuffer);
        if((CurrentTab->currentBuffer->bufferprop & 2) == 0) {
L22:
            if(CurrentTab->currentBuffer->frameset != 0) {
                fbuf = CurrentTab->currentBuffer->linkBuffer;
            }
            multipart = 0;
            if(CurrentTab->currentBuffer->form_submit == 0) {
                request = 0;
            } else {
                request =  *(CurrentTab->currentBuffer->form_submit + 64);
                if(request->method == 1 && request->enctype == 1) {
                    multipart = 1;
                    query_from_followform( &query, CurrentTab->currentBuffer->form_submit, multipart);
                    __stat(request->body,  &(st.st_dev));
                    request->length = st.st_size;
                }
            }
            url = parsedURL2Str( &(CurrentTab->currentBuffer->currentURL));
            message("Reloading...", 0, 0);
            refresh();
            old_charset = DocumentCharset;
            if(CurrentTab->currentBuffer->document_charset != 256) {
                DocumentCharset = CurrentTab->currentBuffer->document_charset;
            }
            SearchHeader = CurrentTab->currentBuffer->search_header & 255;
            DefaultType = CurrentTab->currentBuffer->real_type;
            _v412 = request;
            _v416 = 1;
            buf = loadGeneralFile(url->ptr, 0, -1);
            DocumentCharset = old_charset;
            SearchHeader = 0;
            DefaultType = 0;
            if(multipart != 0) {
                 *__esp = request->body;
                unlink();
            }
            if(buf != 0) {
                if(buf != 1) {
                    if(fbuf != 0) {
                        CurrentTab->firstBuffer = deleteBuffer(CurrentTab->firstBuffer, fbuf);
                    }
                    repBuffer(CurrentTab->currentBuffer, buf);
                    if(buf->type == 0 || _v336 == 0) {
L47:
                        CurrentTab->currentBuffer->search_header = _v144 & 255;
                        CurrentTab->currentBuffer->form_submit = _v168;
                        if(CurrentTab->currentBuffer->firstLine != 0) {
                            CurrentTab->currentBuffer->rootX = _v304 & 65535;
                            CurrentTab->currentBuffer->rootY = _v302 & 65535;
                            CurrentTab->currentBuffer->COLS = _v300 & 65535;
                            CurrentTab->currentBuffer->LINES = _v298 & 65535;
                            restorePosition(CurrentTab->currentBuffer,  &sbuf);
                        }
                        displayBuffer(CurrentTab->currentBuffer, 1);
                        return;
                    } else {
                        _t252 = buf->type;
                        _v424 = "text/plain";
                         *__esp = _t252;
                        strcasecmp();
                        if(_t252 != 0 || is_html_type(_v336) == 0) {
                            if(is_html_type(buf->type) == 0) {
                                goto L47;
                            }
                            _t256 = _v336;
                            _v424 = "text/plain";
                             *__esp = _t256;
                            strcasecmp();
                            if(_t256 != 0) {
                                goto L47;
                            }
                            goto L45;
                        } else {
L45:
                            vwSrc();
                            if(CurrentTab->currentBuffer != buf) {
                                CurrentTab->firstBuffer = deleteBuffer(CurrentTab->firstBuffer, buf);
                            }
                            goto L47;
                        }
                    }
                }
                displayBuffer(CurrentTab->currentBuffer, 0);
                return;
            } else {
                disp_err_message("Can't reload...", 1);
                return;
            }
        }
        fbuf = CurrentTab->currentBuffer->linkBuffer[1];
        if(fbuf == 0) {
            goto L22;
        }
        if((fmInitialized & 255) != 0) {
            message("Rendering frame", 0, 0);
            refresh();
        }
        buf = renderFrame(fbuf, 1);
        if(buf != 0) {
            if(fbuf->linkBuffer != 0) {
                if(buf->sourcefile != 0 && fbuf->linkBuffer[0x2e] != 0) {
                    _t331 = buf->sourcefile;
                    _v424 = fbuf->linkBuffer[0x2e];
                     *__esp = _t331;
                    strcmp();
                    if(_t331 == 0) {
                        fbuf->linkBuffer[0x2e] = 0;
                    }
                }
                delBuffer(fbuf->linkBuffer);
            }
            fbuf->linkBuffer = buf;
            buf->linkBuffer[1] = fbuf;
            pushBuffer(buf);
            CurrentTab->currentBuffer = buf;
            if(CurrentTab->currentBuffer->firstLine != 0) {
                CurrentTab->currentBuffer->rootX = _v304 & 65535;
                CurrentTab->currentBuffer->rootY = _v302 & 65535;
                CurrentTab->currentBuffer->COLS = _v300 & 65535;
                CurrentTab->currentBuffer->LINES = _v298 & 65535;
                restorePosition(CurrentTab->currentBuffer,  &sbuf);
            }
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        } else {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    } else {
        _t338 = CurrentTab->currentBuffer->currentURL.file;
        _v424 = 135037599;
         *__esp = _t338;
        strcmp();
        if(_t338 != 0) {
            goto L7;
        } else {
            disp_err_message("Can't reload stdin", 1);
            return;
        }
    }
}

void reshape()
{// addr = 0x080563C2  --  defined in 'main.c' at line 4796
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    CurrentTab->currentBuffer->need_reshape = 1;
    reshapeBuffer(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 1);
}

void _docCSet(wc_ces charset)
{// addr = 0x08056401  --  defined in 'main.c' at line 4805
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if((CurrentTab->currentBuffer->bufferprop & 8) == 0) {
        if(CurrentTab->currentBuffer->sourcefile != 0) {
            CurrentTab->currentBuffer->document_charset = charset;
            CurrentTab->currentBuffer->need_reshape = 1;
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        }
        disp_message("Can't reload...", 0);
        return;
    }
}

void change_charset(struct parsed_tagarg* arg)
{// addr = 0x08056480  --  defined in 'main.c' at line 4819
    Buffer* buf;        // _cfa_fffffff0
    wc_ces charset;     // _cfa_ffffffec
    char* _v40;                            // _cfa_ffffffd8
    char* _t38;                            // _t38
    unsigned int _t43;                     // _t43

    buf = CurrentTab->currentBuffer->linkBuffer[3];
    if(buf == 0) {
        return;
    }
    delBuffer(CurrentTab->currentBuffer);
    CurrentTab->currentBuffer = buf;
    if((CurrentTab->currentBuffer->bufferprop & 8) == 0) {
        charset = CurrentTab->currentBuffer->document_charset;
        while(arg != 0) {
            _t38 = arg->arg;
            _v40 = "charset";
             *__esp = _t38;
            strcmp();
            if(_t38 == 0) {
                _t43 = arg->value;
                 *__esp = _t43;
                atoi();
                charset = _t43;
            }
            arg = arg->next;
        }
        _docCSet(charset);
        return;
    }
}

void docCSet()
{// addr = 0x0805652C  --  defined in 'main.c' at line 4838
    char* cs;                              // _cfa_fffffff0
    wc_ces charset;     // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    cs = searchKeyData();
    if(cs == 0 || ( *cs & 255) == 0) {
        cs = inputLineHistSearch("Document charset: ", wc_ces_to_charset(CurrentTab->currentBuffer->document_charset), 16, 0, 0);
    }
    charset = wc_guess_charset_short(cs, 0);
    if(charset != 0) {
        _docCSet(charset);
        return;
    } else {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
}

void defCSet()
{// addr = 0x080565CE  --  defined in 'main.c' at line 4856
    char* cs;                              // _cfa_fffffff0
    wc_ces charset;     // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    cs = searchKeyData();
    if(cs == 0 || ( *cs & 255) == 0) {
        cs = inputLineHistSearch("Default document charset: ", wc_ces_to_charset(DocumentCharset), 16, 0, 0);
    }
    charset = wc_guess_charset_short(cs, 0);
    if(charset != 0) {
        DocumentCharset = charset;
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
}

void chkURLBuffer(Buffer* buf)
{// addr = 0x08056662  --  defined in 'main.c' at line 4875
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    i = 0;
    while( *( &url_like_pat + i * 4) != 0) {
        reAnchor(buf,  *( &url_like_pat + i * 4));
        i = i + 1;
    }
    chkExternalURIBuffer(buf);
    buf->check_url = buf->check_url & 255 | 1;
}

void chkURL()
{// addr = 0x080566C1  --  defined in 'main.c' at line 4907
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    chkURLBuffer(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 1);
}

void chkWORD()
{// addr = 0x080566F1  --  defined in 'main.c' at line 4913
    char* p;                               // _cfa_fffffff0
    int spos;                              // _cfa_ffffffec
    int epos;                              // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    p = getCurWord(CurrentTab->currentBuffer,  &spos,  &epos, ":"'`<>()[]{}&|;*?$");
    if(p != 0) {
        reAnchorWord(CurrentTab->currentBuffer, CurrentTab->currentBuffer->currentLine, spos, epos);
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
}

void chkNMIDBuffer(Buffer* buf)
{// addr = 0x08056775  --  defined in 'main.c' at line 4927
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    i = 0;
    while( *(i * 4 +  &url_like_pat.16013) != 0) {
        reAnchorNews(buf,  *(i * 4 +  &url_like_pat.16013));
        i = i + 1;
    }
    buf->check_url = buf->check_url & 255 | 2;
}

void chkNMID()
{// addr = 0x080567C9  --  defined in 'main.c' at line 4940
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    chkNMIDBuffer(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 1);
}

void rFrame()
{// addr = 0x080567F9  --  defined in 'main.c' at line 4948
    Buffer* buf;        // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    buf = CurrentTab->currentBuffer->linkBuffer;
    if(buf == 0) {
        if(CurrentTab->currentBuffer->frameset != 0) {
            if((fmInitialized & 255) != 0) {
                message("Rendering frame", 0, 0);
                refresh();
            }
            buf = renderFrame(CurrentTab->currentBuffer, 0);
            if(buf != 0) {
                buf->linkBuffer[1] = CurrentTab->currentBuffer;
                CurrentTab->currentBuffer->linkBuffer = buf;
                pushBuffer(buf);
                if((fmInitialized & 255) == 0 || display_ok == 0) {
L13:
                    return;
                } else {
                    displayBuffer(CurrentTab->currentBuffer, 1);
                    return;
                }
            } else {
                displayBuffer(CurrentTab->currentBuffer, 0);
                return;
            }
        }
        buf = CurrentTab->currentBuffer->linkBuffer[1];
        if(buf == 0) {
            goto L13;
        }
        CurrentTab->currentBuffer = buf;
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    CurrentTab->currentBuffer = buf;
    displayBuffer(CurrentTab->currentBuffer, 0);
}

void invoke_browser(char* url)
{// addr = 0x0805694C  --  defined in 'main.c' at line 4982
    Str cmd;               // _cfa_fffffff0
    char* browser;                         // _cfa_ffffffec
    int bg;                                // _cfa_ffffffe8
    int len;                               // _cfa_ffffffe4
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    int _t53;                              // _t53
    int _t64;                              // _t64
    int _t83;                              // _t83

    browser = 0;
    bg = 0;
    CurrentKeyData = 0;
    browser = searchKeyData();
    if(browser == 0 || ( *browser & 255) == 0) {
        _t53 = prec_num;
        if(_t53 == 2) {
            browser = ExtBrowser2;
        } else {
            if(_t53 > 2) {
                __eflags = _t53 - 3;
                if(__eflags == 0) {
                    browser = ExtBrowser3;
                }
            } else {
                if(_t53 >= 0) {
                    browser = ExtBrowser;
                }
            }
        }
        if(browser == 0 || ( *browser & 255) == 0) {
            browser = inputLineHistSearch("Browse command: ", 0, 16, 0, 0);
            if(browser != 0) {
                browser =  *(wc_Str_conv_strict(Strnew_charp(browser), InnerCharset, SystemCharset));
            }
        }
        goto L18;
    } else {
        browser =  *(wc_Str_conv_strict(Strnew_charp(browser), InnerCharset, SystemCharset));
L18:
        if(browser == 0 || ( *browser & 255) == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        } else {
            _t64 = browser;
             *__esp = _t64;
            strlen();
            len = _t64;
            __eflags = len - 1;
            if(__eflags > 0) {
                __eflags = (browser[len - 1] & 255) - 38;
                if(__eflags == 0) {
                    __eflags = (browser[len - 2] & 255) - 92;
                    if(__eflags != 0) {
                        _t83 = len - 2;
                        __eflags = _t83;
                        browser = allocStr(browser, _t83);
                        bg = 1;
                    }
                }
            }
            cmd = myExtCommand(browser, shell_quote(url), 0);
            Strremovetrailingspaces(cmd);
            fmTerm();
            mySystem(cmd->ptr, bg);
            fmInit();
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        }
    }
}

void extbrz()
{// addr = 0x08056B56  --  defined in 'main.c' at line 5030
    intOrPtr _v24;                         // _cfa_ffffffe8 (outparam)
    Buffer* _t17;       // _t17
    ParsedURL* _t21;   // _t21
    char* _t26;                            // _t26

    __eflags = CurrentTab->currentBuffer->bufferprop.scheme & 8;
    if(__eflags == 0) {
        _t17 = CurrentTab->currentBuffer;
        __eflags = _t17->currentURL.scheme - 4;
        if(_t17->currentURL.scheme != 4) {
L5:
            _t21 =  &(CurrentTab->currentBuffer->currentURL);
            __eflags = _t21;
            invoke_browser( *(parsedURL2Str(_t21)));
            return;
        }
        _t26 = CurrentTab->currentBuffer->currentURL.file;
        _v24 = 135037599;
         *__esp = _t26;
        strcmp();
        __eflags = _t26;
        if(__eflags != 0) {
            goto L5;
        }
        disp_err_message("Can't browse stdin", 1);
        return;
    }
    disp_err_message("Can't browse...", 1);
}

void linkbrz()
{// addr = 0x08056BF2  --  defined in 'main.c' at line 5047
    Anchor* a;          // _cfa_fffffff0
    ParsedURL pu;    // _cfa_ffffffc8
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)

    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    a = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if(a != 0) {
        parseURL2(a->url,  &pu, baseURL(CurrentTab->currentBuffer));
        invoke_browser( *(parsedURL2Str( &pu)));
        return;
    }
}

void curlno()
{// addr = 0x08056C65  --  defined in 'main.c' at line 5062
    Line* l;              // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    int cur;                               // _cfa_ffffffe8
    int all;                               // _cfa_ffffffe4
    int col;                               // _cfa_ffffffe0
    int len;                               // _cfa_ffffffdc
    _unknown_ _v46;                        // _cfa_ffffffd2
    short _v48;                            // _cfa_ffffffd0
    int _v52;                              // _cfa_ffffffcc
    int _v72;                              // _cfa_ffffffb8 (outparam)
    int _v76;                              // _cfa_ffffffb4 (outparam)
    int _v80;                              // _cfa_ffffffb0 (outparam)
    int _v84;                              // _cfa_ffffffac (outparam)
    int _v88;                              // _cfa_ffffffa8 (outparam)

    l = CurrentTab->currentBuffer->currentLine;
    cur = 0;
    all = 0;
    col = 0;
    len = 0;
    if(l == 0) {
L8:
        if(CurrentTab->currentBuffer->lastLine != 0) {
            all =  *(CurrentTab->currentBuffer->lastLine + 32);
        }
        if(CurrentTab->currentBuffer->pagerSource == 0 || (CurrentTab->currentBuffer->bufferprop & 0x40) != 0) {
            asm("fild dword [ebp-0x14]");
            asm("fmulp st1, st0");
            if(all == 0) {
                asm("fld1");
            } else {
                asm("fild dword [ebp-0x18]");
            }
            asm("fdivp st1, st0");
            asm("faddp st1, st0");
            asm("fnstcw word [ebp-0x2a]");
            _v48 = 12;
            asm("fldcw word [ebp-0x2c]");
            asm("fistp dword [ebp-0x30]");
            asm("fldcw word [ebp-0x2a]");
            _v72 = len;
            _v76 = col;
            _v80 = _v52;
            _v84 = all;
            _v88 = cur;
            tmp = Sprintf("line %d/%d (%d%%) col %d/%d");
        } else {
            _v80 = len;
            _v84 = col;
            _v88 = cur;
            tmp = Sprintf("line %d col %d/%d");
        }
        Strcat_charp(tmp, "  ");
        Strcat_charp(tmp, wc_ces_to_charset_desc(CurrentTab->currentBuffer->document_charset));
        disp_message(tmp->ptr, 0);
        return;
    } else {
        cur = l->real_linenumber;
        col = l->bwidth + CurrentTab->currentBuffer->currentColumn + (CurrentTab->currentBuffer->cursorX & 65535) + 1;
        while(l->next != 0 && l->next->bpos != 0) {
            l = l->next;
        }
        if(l->width < 0) {
            l->width = calcPosition(l->lineBuf, l->propBuf, l->len, l->len, 0, 0);
        }
        len = l->bwidth + l->width;
        goto L8;
    }
}

void dispI()
{// addr = 0x08056E77  --  defined in 'main.c' at line 5094
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(displayImage == 0) {
        initImage();
    }
    if(activeImage != 0) {
        displayImage = 1;
        CurrentTab->currentBuffer->image_flag = 2;
        CurrentTab->currentBuffer->need_reshape = 1;
        displayBuffer(CurrentTab->currentBuffer, 4);
        return;
    }
}

void stopI()
{// addr = 0x08056ED9  --  defined in 'main.c' at line 5110
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(activeImage != 0) {
        CurrentTab->currentBuffer->image_flag = 1;
        displayBuffer(CurrentTab->currentBuffer, 4);
        return;
    }
}

int mouse_scroll_line()
{// addr = 0x08056F14  --  defined in 'main.c' at line 5126
    if(relative_wheel_scroll == 0) {
        return fixed_wheel_scroll_count;
    }
    return ((relative_wheel_scroll_ratio * (LINES - 1) + 99) * 1374389535 >> 32 >> 5) - (relative_wheel_scroll_ratio * (LINES - 1) + 99 >> 31);
}

TabBuffer* posTab(int x, int y)
{// addr = 0x08056F53  --  defined in 'main.c' at line 5135
    TabBuffer* tab;   // _cfa_fffffff8

    if(mouse_action.menu_str == 0 ||  *135792264 <= x) {
L4:
        if((LastTab->y & 65535) >= y) {
            tab = FirstTab;
            while(tab != 0) {
                if((tab->x1 & 65535) > x || (tab->x2 & 65535) < x || (tab->y & 65535) != y) {
                    tab = tab->nextTab;
                    continue;
                } else {
                    return tab;
                }
            }
            return 0;
        }
        return 0;
    } else {
        if(y != 0) {
            goto L4;
        } else {
            return 1;
        }
    }
}

void do_mouse_action(int btn, int x, int y)
{// addr = 0x08056FDA  --  defined in 'main.c' at line 5151
    MouseActionMap* map;   // _cfa_fffffff0
    int ny;                                // _cfa_ffffffec
    int cx;                                // _cfa_ffffffe8
    int cy;                                // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t136;                             // _t136

    map = 0;
    ny = -1;
    if(nTab > 1 || mouse_action.menu_str != 0) {
        ny = (LastTab->y & 65535) + 1;
    }
    _t136 = btn;
    if(_t136 == 1) {
        btn = 1;
L9:
        if(y >= ny) {
            if(LINES - 1 != y) {
                if(y <= ny) {
                    goto L55;
                }
                if((CurrentTab->currentBuffer->cursorY & 65535) + (CurrentTab->currentBuffer->rootY & 65535) != y || (CurrentTab->currentBuffer->cursorX & 65535) + (CurrentTab->currentBuffer->rootX & 65535) != x && (( *135119023 & 255) == 0 || CurrentTab->currentBuffer->currentLine == 0 || ( *(CurrentTab->currentBuffer->currentLine->propBuf + CurrentTab->currentBuffer->pos + CurrentTab->currentBuffer->pos) & 0x3f00) != 2560 || (CurrentTab->currentBuffer->cursorX & 65535) + (CurrentTab->currentBuffer->rootX & 65535) + 1 != x)) {
                    cx = CurrentTab->currentBuffer->cursorX & 65535;
                    cy = CurrentTab->currentBuffer->cursorY & 65535;
                    cursorXY(CurrentTab->currentBuffer, x - (CurrentTab->currentBuffer->rootX & 65535), y - (CurrentTab->currentBuffer->rootY & 65535));
                    if((CurrentTab->currentBuffer->cursorY & 65535) + (CurrentTab->currentBuffer->rootY & 65535) == y && ((CurrentTab->currentBuffer->cursorX & 65535) + (CurrentTab->currentBuffer->rootX & 65535) == x || ( *135119023 & 255) != 0 && CurrentTab->currentBuffer->currentLine != 0 && ( *(CurrentTab->currentBuffer->currentLine->propBuf + CurrentTab->currentBuffer->pos + CurrentTab->currentBuffer->pos) & 0x3f00) == 2560 && (CurrentTab->currentBuffer->cursorX & 65535) + (CurrentTab->currentBuffer->rootX & 65535) + 1 == x)) {
                        if(retrieveCurrentAnchor(CurrentTab->currentBuffer) != 0 || retrieveCurrentForm(CurrentTab->currentBuffer) != 0) {
                            map = (btn << 3) + 135792308;
                        }
                    }
                    cursorXY(CurrentTab->currentBuffer, cx, cy);
                } else {
                    if(retrieveCurrentAnchor(CurrentTab->currentBuffer) != 0 || retrieveCurrentForm(CurrentTab->currentBuffer) != 0) {
                        map = (btn << 3) + 135792332;
                        if(map != 0 && map->func != 0) {
                        } else {
                            map = (btn << 3) + 135792308;
                        }
                    } else {
                    }
                }
                goto L47;
            } else {
                if( *135792260 != 0) {
                    if(x >= 0) {
                        if( *135792268 > x) {
                            if( *((intOrPtr*)(135792264 + (btn + 32) * 4)) != 0) {
                                map =  *((intOrPtr*)(135792264 + (btn + 32) * 4)) + (x << 3);
                            }
                        }
                    }
                }
L47:
                if(map == 0 || map->func == 0) {
                    map = (btn << 3) + 135792284;
                }
                if(map == 0 || map->func == 0) {
L55:
                    return;
                } else {
                     *135792272 = 1;
                     *135792276 = x;
                     *135792280 = y;
                    CurrentKey = -1;
                    CurrentKeyData = 0;
                    CurrentCmdData = map->data;
                    map();
                    CurrentCmdData = 0;
                    return;
                }
            }
        }
        if(mouse_action.menu_str == 0 || x < 0) {
L15:
            map = (btn << 3) + 135792356;
            goto L47;
        } else {
            if( *135792264 <= x) {
                goto L15;
            } else {
                if( *((intOrPtr*)(135792268 + (btn + 28) * 4)) != 0) {
                    map =  *((intOrPtr*)(135792268 + (btn + 28) * 4)) + (x << 3);
                }
                goto L47;
            }
        }
    }
    if(_t136 == 2) {
        btn = 2;
        goto L9;
    }
    if(_t136 != 0) {
        return;
    } else {
        btn = 0;
        goto L9;
    }
}

void process_mouse(int btn, int x, int y)
{// addr = 0x0805743D  --  defined in 'main.c' at line 5240
    int delta_x;                           // _cfa_fffffff0
    int delta_y;                           // _cfa_ffffffec
    TabBuffer* t;    // _cfa_ffffffe4
    Buffer* buf;        // _cfa_ffffffdc
    int cx;                                // _cfa_ffffffd8
    int cy;                                // _cfa_ffffffd4
    int i;                                 // _cfa_ffffffe8
    int ny;                                // _cfa_ffffffe0
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5

    ny = -1;
    if(nTab > 1 || mouse_action.menu_str != 0) {
        ny = (LastTab->y & 65535) + 1;
    }
    if(btn != 3) {
        if(btn != 64) {
            if(btn != 65) {
L17:
                if(btn != 3 || press_btn == -1) {
                    press_btn = btn;
                    press_x = x;
                    press_y = y;
                    return;
                } else {
                    press_btn = -1;
                    return;
                }
            }
            i = 0;
            while(mouse_scroll_line() > i) {
                lup1();
                i = i + 1;
            }
            goto L17;
        }
        i = 0;
        while(mouse_scroll_line() > i) {
            ldown1();
            i = i + 1;
        }
        goto L17;
    }
    if(press_btn > 4) {
        goto L17;
    }
    goto __eax;
}

void msToggle()
{// addr = 0x0805794D  --  defined in 'main.c' at line 5354
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(use_mouse == 0) {
        use_mouse = 1;
    } else {
        use_mouse = 0;
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
}

void mouse()
{// addr = 0x0805798C  --  defined in 'main.c' at line 5365
    int btn;                               // _cfa_fffffff0
    int x;                                 // _cfa_ffffffec
    int y;                                 // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    btn = (do_getch() & 255) - 32;
    x = (do_getch() & 255) - 33;
    if(x < 0) {
        x = x + 256;
    }
    y = (do_getch() & 255) - 33;
    if(y < 0) {
        y = y + 256;
    }
    if(x < 0) {
        return;
    }
    if(x >= COLS) {
        return;
    }
    if(y < 0) {
        return;
    }
    if(LINES - 1 >= y) {
        process_mouse(btn, x, y);
        return;
    }
}

int gpm_process_mouse(Gpm_Event* event, _Unknown_base* data)
{// addr = 0x08057A20  --  defined in 'main.c' at line 5392
    int btn;                               // _cfa_fffffff0
    int x;                                 // _cfa_ffffffec
    int y;                                 // _cfa_ffffffe8
    intOrPtr _v36;                         // _cfa_ffffffdc (outparam)
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    signed short* _t39;                    // _t39
    signed short* _t43;                    // _t43
    signed int _t51;                       // _t51

    btn = -1;
    if((event->type & 8) == 0) {
        if((event->type & 4) == 0) {
             *135774721 = 2;
            _t39 = __imp___gpm_arg + 4;
             *_t39 = (event->x & 65535) + __imp__gpm_zerobased;
             *__imp___gpm_arg =  *_t39 & 65535;
            _t43 = __imp___gpm_arg + 6;
             *_t43 = (event->y & 65535) + __imp__gpm_zerobased;
             *((short*)(__imp___gpm_arg + 2)) =  *_t43 & 65535;
             *((short*)(__imp___gpm_arg + 8)) = 3;
            _v36 = 135774721;
            _v40 = 21532;
             *__esp = __imp__gpm_consolefd;
            ioctl();
            return 0;
        } else {
            _t51 = event->buttons & 0xff;
            if(_t51 == 2) {
                btn = 1;
            } else {
                if(_t51 == 4) {
                    btn = 0;
                } else {
                    if(_t51 == 1) {
                        btn = 2;
                    }
                }
            }
            goto L11;
        }
    } else {
        btn = 3;
L11:
        x = event->x & 65535;
        y = event->y & 65535;
        process_mouse(btn, x - 1, y - 1);
        return 0;
    }
}

void movMs()
{// addr = 0x08057B62  --  defined in 'main.c' at line 5443
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if( *135792272 == 0) {
        return;
    }
    if(nTab > 1 || mouse_action.menu_str != 0) {
        if( *135792280 < (LastTab->y & 65535) + 1) {
            return;
        }
        goto L4;
    } else {
L4:
        if( *135792276 >= (CurrentTab->currentBuffer->rootX & 65535) &&  *135792280 < LINES - 1) {
            cursorXY(CurrentTab->currentBuffer,  *135792276 - (CurrentTab->currentBuffer->rootX & 65535),  *135792280 - (CurrentTab->currentBuffer->rootY & 65535));
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
}

void menuMs()
{// addr = 0x08057C30  --  defined in 'main.c' at line 5465
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if( *135792272 == 0) {
        return;
    }
    if(nTab > 1 || mouse_action.menu_str != 0) {
        if( *135792280 >= (LastTab->y & 65535) + 1) {
            goto L5;
        } else {
             *135792276 =  *135792276 - 2;
            goto L8;
        }
    } else {
L5:
        if( *135792276 >= (CurrentTab->currentBuffer->rootX & 65535) &&  *135792280 < LINES - 1) {
            cursorXY(CurrentTab->currentBuffer,  *135792276 - (CurrentTab->currentBuffer->rootX & 65535),  *135792280 - (CurrentTab->currentBuffer->rootY & 65535));
            displayBuffer(CurrentTab->currentBuffer, 0);
        }
L8:
        mainMn();
        return;
    }
}

void tabMs()
{// addr = 0x08057D0E  --  defined in 'main.c' at line 5482
    TabBuffer* tab;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if( *135792272 == 0) {
        return;
    }
    tab = posTab( *135792276,  *135792280);
    if(tab == 0) {
        return;
    }
    if(tab != 1) {
        CurrentTab = tab;
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
}

void closeTMs()
{// addr = 0x08057D6E  --  defined in 'main.c' at line 5495
    TabBuffer* tab;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if( *135792272 == 0) {
        return;
    }
    tab = posTab( *135792276,  *135792280);
    if(tab == 0) {
        return;
    }
    if(tab != 1) {
        deleteTab(tab);
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
}

void dispVer()
{// addr = 0x08057DD1  --  defined in 'main.c' at line 5510
    char* _v24;                            // _cfa_ffffffe8 (outparam)

    _v24 = w3m_version;
    disp_message( *(Sprintf("w3m version %s")), 1);
}

void wrapToggle()
{// addr = 0x08057E00  --  defined in 'main.c' at line 5515
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(WrapSearch == 0) {
        WrapSearch = 1;
        disp_message("Wrap search on", 1);
        return;
    }
    WrapSearch = 0;
    disp_message("Wrap search off", 1);
}

int is_wordchar(int c, const char* badchars)
{// addr = 0x08057E4F  --  defined in 'main.c' at line 5530
    int _v24;                              // _cfa_ffffffe8
    int _t19;                              // _t19
    const char* _t21;   // _t21

    if(badchars == 0) {
        return  *( &MYCTYPE_MAP + (c & 255)) & 4;
    }
    if(( *( &MYCTYPE_MAP + (c & 255)) & 2) != 0) {
L4:
        _t19 = 0;
L5:
        return _t19;
    }
    _v24 = c;
    _t21 = badchars;
     *__esp = _t21;
    strchr();
    if(_t21 != 0) {
        goto L4;
    }
    _t19 = 1;
    goto L5;
}

char* getCurWord(Buffer* buf, int* spos, int* epos, const char* badchars)
{// addr = 0x08057EAB  --  defined in 'main.c' at line 5539
    char* p;                               // _cfa_fffffff0
    Line* l;              // _cfa_ffffffec
    int b;                                 // _cfa_ffffffe8
    int e;                                 // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    l = buf->currentLine;
     *spos = 0;
     *epos = 0;
    if(l == 0) {
        return 0;
    }
    p = l->lineBuf;
    e = buf->pos;
    while(e > 0 && is_wordchar(p[e] & 255, badchars) == 0) {
        e = e - 1;
    }
    if(is_wordchar(p[e] & 255, badchars) != 0) {
        b = e;
        while(b > 0) {
            if(is_wordchar(p[b - 1] & 255, badchars) != 0) {
                b = b - 1;
                continue;
            }
L15:
            while(l->len > e && is_wordchar(p[e] & 255, badchars) != 0) {
                e = e + 1;
            }
             *spos = b;
             *epos = e;
            return  &(p[b]);
        }
        goto L15;
    }
    return 0;
}

char* GetWord(Buffer* buf)
{// addr = 0x08057FBD  --  defined in 'main.c' at line 5566
    int b;                                 // _cfa_fffffff0
    int e;                                 // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    p = getCurWord(buf,  &b,  &e, 0);
    if(p == 0) {
        return 0;
    }
    return  *(Strnew_charp_n(p, e - b));
}

void execdict(char* word)
{// addr = 0x08058013  --  defined in 'main.c' at line 5579
    char* w;                               // _cfa_fffffff0
    char* dictcmd;                         // _cfa_ffffffec
    Buffer* buf;        // _cfa_ffffffe8
    int _v44;                              // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc (outparam)
    char* _v56;                            // _cfa_ffffffc8 (outparam)

    if(UseDictCommand == 0 || word == 0 || ( *word & 255) == 0) {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    w =  *(wc_Str_conv_strict(Strnew_charp(word), InnerCharset, SystemCharset));
    if(( *w & 255) != 0) {
        _v52 =  *(Str_form_quote(Strnew_charp(w)));
        _v56 = DictCommand;
        dictcmd =  *(Sprintf("%s?%s"));
        _v44 = 0;
        _v48 = 0;
        buf = loadGeneralFile(dictcmd, 0, -1);
        if(buf != 0) {
            buf->filename = w;
            _v52 = word;
            _v56 = "*dictionary*";
            buf->buffername =  *(Sprintf("%s %s"));
            if(buf->type == 0) {
                buf->type = "text/plain";
            }
            pushBuffer(buf);
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        }
        disp_message("Execution failed", 1);
        return;
    } else {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
}

void dictword()
{// addr = 0x0805818A  --  defined in 'main.c' at line 5610
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    execdict(inputLineHistSearch("(dictionary)!", 135036496, 16, 0, 0));
}

void dictwordat()
{// addr = 0x080581C6  --  defined in 'main.c' at line 5615
    execdict(GetWord(CurrentTab->currentBuffer));
}

void set_buffer_environ(Buffer* buf)
{// addr = 0x080581E6  --  defined in 'main.c' at line 5623
    Line* l;              // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    char* s;                               // _cfa_ffffffe8
    ParsedURL pu;    // _cfa_ffffffc0
    _unknown_ _v84;                        // _cfa_ffffffac (outparam)
    long int _v88;                         // _cfa_ffffffa8 (outparam)
    char* _t94;                            // _t94
    char* _t143;                           // _t143

    if(buf == 0) {
        return;
    }
    if(buf == prev_buf) {
L6:
        l = buf->currentLine;
        if(l == 0 || buf == prev_buf && l == prev_line && buf->pos == prev_pos) {
            if(l == 0) {
                set_environ("W3M_CURRENT_WORD", 135036496);
                set_environ("W3M_CURRENT_LINK", 135036496);
                set_environ("W3M_CURRENT_IMG", 135036496);
                set_environ("W3M_CURRENT_FORM", 135036496);
                set_environ("W3M_CURRENT_LINE", 135039425);
                set_environ("W3M_CURRENT_COLUMN", 135039425);
            }
        } else {
            s = GetWord(buf);
            if(s == 0) {
                _t94 = 135036496;
            } else {
                _t94 = s;
            }
            set_environ("W3M_CURRENT_WORD", _t94);
            a = retrieveCurrentAnchor(buf);
            if(a == 0) {
                set_environ("W3M_CURRENT_LINK", 135036496);
            } else {
                parseURL2(a->url,  &pu, baseURL(buf));
                set_environ("W3M_CURRENT_LINK",  *(parsedURL2Str( &pu)));
            }
            a = retrieveCurrentImg(buf);
            if(a == 0) {
                set_environ("W3M_CURRENT_IMG", 135036496);
            } else {
                parseURL2(a->url,  &pu, baseURL(buf));
                set_environ("W3M_CURRENT_IMG",  *(parsedURL2Str( &pu)));
            }
            a = retrieveCurrentForm(buf);
            if(a == 0) {
                set_environ("W3M_CURRENT_FORM", 135036496);
            } else {
                set_environ("W3M_CURRENT_FORM", form2str(a->url));
            }
            _v88 = l->real_linenumber;
            set_environ("W3M_CURRENT_LINE",  *(Sprintf("%d")));
            _v88 = buf->currentColumn + (buf->cursorX & 65535) + 1;
            set_environ("W3M_CURRENT_COLUMN",  *(Sprintf("%d")));
        }
        prev_buf = buf;
        prev_line = l;
        prev_pos = buf->pos;
        return;
    }
    set_environ("W3M_SOURCEFILE", buf->sourcefile);
    set_environ("W3M_FILENAME", buf->filename);
    set_environ("W3M_TITLE", buf->buffername);
    set_environ("W3M_URL",  *(parsedURL2Str( &(buf->currentURL))));
    if(buf->real_type == 0) {
        _t143 = "unknown";
    } else {
        _t143 = buf->real_type;
    }
    set_environ("W3M_TYPE", _t143);
    set_environ("W3M_CHARSET", wc_ces_to_charset(buf->document_charset));
    goto L6;
}

char* searchKeyData()
{// addr = 0x08058533  --  defined in 'main.c' at line 5687
    char* data;                            // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    data = 0;
    if(CurrentKeyData == 0) {
L3:
        if(CurrentCmdData == 0 || ( *CurrentCmdData & 255) == 0) {
            if(CurrentKey >= 0) {
                data = getKeyData(CurrentKey);
            }
        } else {
            data = CurrentCmdData;
        }
L8:
        CurrentKeyData = 0;
        CurrentCmdData = 0;
        if(data == 0 || ( *data & 255) == 0) {
            return 0;
        }
        return allocStr(data, -1);
    }
    if(( *CurrentKeyData & 255) == 0) {
        goto L3;
    } else {
        data = CurrentKeyData;
        goto L8;
    }
}

int searchKeyNum()
{// addr = 0x080585D7  --  defined in 'main.c' at line 5705
    char* d;                               // _cfa_fffffff0
    int n;                                 // _cfa_ffffffec
    signed int _t9;                        // _t9
    int _t11;                              // _t11

    n = 1;
    d = searchKeyData();
    if(d != 0) {
        _t11 = d;
         *__esp = _t11;
        atoi();
        n = _t11;
    }
    if(prec_num == 0) {
        _t9 = 1;
    } else {
        _t9 = prec_num;
    }
    return _t9 * n;
}

void deleteFiles()
{// addr = 0x0805861B  --  defined in 'main.c' at line 5731
    Buffer* buf;        // _cfa_fffffff0
    char* f;                               // _cfa_ffffffec

    CurrentTab = FirstTab;
    while(CurrentTab != 0) {
        while(CurrentTab->firstBuffer != 0 && CurrentTab->firstBuffer != 1) {
            buf = CurrentTab->firstBuffer->nextBuffer;
            discardBuffer(CurrentTab->firstBuffer);
            CurrentTab->firstBuffer = buf;
        }
        CurrentTab = CurrentTab->nextTab;
    }
    while(1) {
        f = popValue(fileToDelete);
        if(f == 0) {
            break;
        }
         *__esp = f;
        unlink();
    }
}

void w3m_exit(int i)
{// addr = 0x080586AC  --  defined in 'main.c' at line 5748
    intOrPtr _v20;                         // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    char* _v44;                            // _cfa_ffffffd4
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ _v76;                        // _cfa_ffffffb4 (outparam)
    _unknown_ _v80;                        // _cfa_ffffffb0 (outparam)
    _unknown_ _v84;                        // _cfa_ffffffac (outparam)
    char* _t60;                            // _t60
    _unknown_ _t77;                        // _t77

    init_migemo();
    stopDownload();
    deleteFiles();
    disconnectFTP();
    disconnectNews();
     *__esp = i;
    exit();
    _push(_t77);
    __esp = __esp - 56;
    CurrentKeyData = 0;
    _v44 = searchKeyData();
    if(_v44 == 0 || ( *_v20 & 255) == 0) {
        _v20 = inputLineHistSearch("command [; ...]: ", 135036496, 16, TextHist, 0);
        if(_v20 != 0) {
            goto L21;
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    } else {
L21:
        while(( *_v20 & 255) != 0) {
            while(( *_v20 & 255) != 0 && ( *( &MYCTYPE_MAP + ( *_v20 & 0xff)) & 2) != 0) {
                _v20 =  &(_v20[1]);
            }
            if(( *_v20 & 255) != 59) {
                _v24 = getWord( &_v20);
                _v28 = getFuncList(_v24);
                if(_v28 < 0) {
L24:
                    displayBuffer(CurrentTab->currentBuffer, 0);
                    return;
                }
                _v24 = getQWord( &_v20);
                CurrentKey = -1;
                CurrentKeyData = 0;
                if(( *_v24 & 255) == 0) {
                    _t60 = 0;
                } else {
                    _t60 = _v24;
                }
                CurrentCmdData = _t60;
                if(use_mouse != 0) {
                    mouse_inactive();
                }
                 *((intOrPtr*)( *((intOrPtr*)(135103140 + _v28 * 8))))();
                if(use_mouse != 0) {
                    mouse_active();
                }
                CurrentCmdData = 0;
                continue;
            }
            _v20 =  &(_v20[1]);
        }
        goto L24;
    }
}

void execCmd()
{// addr = 0x080586D6  --  defined in 'main.c' at line 5768
    char* data;                            // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    int cmd;                               // _cfa_ffffffe8
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    char* _t58;                            // _t58

    CurrentKeyData = 0;
    data = searchKeyData();
    if(data == 0 || ( *data & 255) == 0) {
        data = inputLineHistSearch("command [; ...]: ", 135036496, 16, TextHist, 0);
        if(data == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    }
    while(( *data & 255) != 0) {
        while(( *data & 255) != 0 && ( *( &MYCTYPE_MAP + ( *data & 0xff)) & 2) != 0) {
            data =  &(data[1]);
        }
        if(( *data & 255) != 59) {
            p = getWord( &data);
            cmd = getFuncList(p);
            if(cmd < 0) {
L23:
                displayBuffer(CurrentTab->currentBuffer, 0);
                return;
            }
            p = getQWord( &data);
            CurrentKey = -1;
            CurrentKeyData = 0;
            if(( *p & 255) == 0) {
                _t58 = 0;
            } else {
                _t58 = p;
            }
            CurrentCmdData = _t58;
            if(use_mouse != 0) {
                mouse_inactive();
            }
             *((intOrPtr*)( *((intOrPtr*)(135103140 + cmd * 8))))();
            if(use_mouse != 0) {
                mouse_active();
            }
            CurrentCmdData = 0;
            continue;
        }
        data =  &(data[1]);
    }
    goto L23;
}

void SigAlarm(int _dummy)
{// addr = 0x08058864  --  defined in 'main.c' at line 5813
    char* data;                            // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(CurrentAlarm->sec <= 0) {
L15:
        return;
    }
    CurrentKey = -1;
    CurrentKeyData = 0;
    data = CurrentAlarm->data;
    CurrentCmdData = data;
    if(use_mouse != 0) {
        mouse_inactive();
    }
     *((intOrPtr*)( *((intOrPtr*)(135103140 + CurrentAlarm->cmd * 8))))();
    if(use_mouse != 0) {
        mouse_active();
    }
    CurrentCmdData = 0;
    if((CurrentAlarm->status & 65535) == 3) {
        CurrentAlarm->sec = 0;
        CurrentAlarm->status = 0;
    }
    if(CurrentTab->currentBuffer->event != 0) {
        if((CurrentTab->currentBuffer->event->status & 65535) == 0) {
            CurrentTab->currentBuffer->event = 0;
        } else {
            CurrentAlarm = CurrentTab->currentBuffer->event;
        }
    }
    if(CurrentTab->currentBuffer->event == 0) {
        CurrentAlarm =  &DefaultAlarm;
    }
    if(CurrentAlarm->sec <= 0) {
        goto L15;
    } else {
        mySignal(14, SigAlarm);
         *__esp = CurrentAlarm->sec;
        alarm();
        return;
    }
}

void setAlarm()
{// addr = 0x08058998  --  defined in 'main.c' at line 5852
    char* data;                            // _cfa_fffffff0
    int sec;                               // _cfa_ffffffec
    int cmd;                               // _cfa_ffffffe8
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    char* _v48;                            // _cfa_ffffffd0 (outparam)
    intOrPtr _v52;                         // _cfa_ffffffcc (outparam)
    int _v56;                              // _cfa_ffffffc8 (outparam)
    int _t70;                              // _t70

    sec = 0;
    cmd = -1;
    CurrentKeyData = 0;
    data = searchKeyData();
    if(data == 0 || ( *data & 255) == 0) {
        data = inputLineHistSearch("(Alarm)sec command: ", 135036496, 16, TextHist, 0);
        if(data != 0) {
            goto L4;
        } else {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    }
L4:
    if(( *data & 255) != 0) {
        _t70 = getWord( &data);
         *__esp = _t70;
        atoi();
        sec = _t70;
        if(sec > 0) {
            cmd = getFuncList(getWord( &data));
        }
    }
    if(cmd < 0) {
        setAlarmEvent( &DefaultAlarm, 0, 0, 0, 0);
    } else {
        data = getQWord( &data);
        setAlarmEvent( &DefaultAlarm, sec, 1, cmd, data);
        _v48 = data;
        _v52 =  *((intOrPtr*)( &w3mFuncList + cmd * 8));
        _v56 = sec;
        disp_message_nsec( *(Sprintf("%dsec %s %s")), 0, 1, 0, 1);
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
}

AlarmEvent* setAlarmEvent(AlarmEvent* event, int sec, short int status, int cmd, _Unknown_base* data)
{// addr = 0x08058B3A  --  defined in 'main.c' at line 5884
    signed short _v16;                     // _cfa_fffffff0
    AlarmEvent* _t17;   // _t17

    _t17 = status;
    _v16 = _t17;
    if(event == 0) {
         *__esp = 16;
        GC_malloc();
        event = _t17;
    }
    event->sec = sec;
    event->status = _v16 & 65535;
    event->cmd = cmd;
    event->data = data;
    return event;
}

void reinit()
{// addr = 0x08058B86  --  defined in 'main.c' at line 5896
    char* resource;                        // _cfa_fffffff0
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    char* _t31;                            // _t31
    char* _t34;                            // _t34
    char* _t35;                            // _t35
    char* _t36;                            // _t36
    char* _t37;                            // _t37
    char* _t38;                            // _t38
    char* _t39;                            // _t39
    char* _t40;                            // _t40
    char* _t41;                            // _t41

    resource = searchKeyData();
    if(resource != 0) {
        _v40 = "CONFIG";
        _t31 = resource;
         *__esp = _t31;
        strcasecmp();
        if(_t31 == 0) {
L4:
            init_rc();
            sync_with_option();
            displayBuffer(CurrentTab->currentBuffer, 4);
            return;
        }
        _v40 = "RC";
        _t34 = resource;
         *__esp = _t34;
        strcasecmp();
        if(_t34 != 0) {
            _v40 = "COOKIE";
            _t35 = resource;
             *__esp = _t35;
            strcasecmp();
            if(_t35 != 0) {
                _v40 = "KEYMAP";
                _t36 = resource;
                 *__esp = _t36;
                strcasecmp();
                if(_t36 != 0) {
                    _v40 = "MAILCAP";
                    _t37 = resource;
                     *__esp = _t37;
                    strcasecmp();
                    if(_t37 != 0) {
                        _v40 = "MOUSE";
                        _t38 = resource;
                         *__esp = _t38;
                        strcasecmp();
                        if(_t38 != 0) {
                            _v40 = "MENU";
                            _t39 = resource;
                             *__esp = _t39;
                            strcasecmp();
                            if(_t39 != 0) {
                                _v40 = "MIMETYPES";
                                _t40 = resource;
                                 *__esp = _t40;
                                strcasecmp();
                                if(_t40 != 0) {
                                    _v40 = "URIMETHODS";
                                    _t41 = resource;
                                     *__esp = _t41;
                                    strcasecmp();
                                    if(_t41 != 0) {
                                        _v40 = resource;
                                        disp_err_message( *(Sprintf("Don't know how to reinitialize '%s'")), 0);
                                        return;
                                    }
                                    initURIMethods();
                                    return;
                                }
                                initMimeTypes();
                                return;
                            }
                            initMenu();
                            return;
                        }
                        initMouseAction();
                        displayBuffer(CurrentTab->currentBuffer, 4);
                        return;
                    }
                    initMailcap();
                    return;
                }
                initKeymap(1);
                return;
            }
            initCookie();
            return;
        }
        goto L4;
    }
    init_rc();
    sync_with_option();
    initCookie();
    displayBuffer(CurrentTab->currentBuffer, 4);
}

void defKey()
{// addr = 0x08058D3C  --  defined in 'main.c' at line 5965
    char* data;                            // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    CurrentKeyData = 0;
    data = searchKeyData();
    if(data == 0 || ( *data & 255) == 0) {
        data = inputLineHistSearch("Key definition: ", 135036496, 16, TextHist, 0);
        if(data == 0 || ( *data & 255) == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        } else {
            goto L5;
        }
    }
L5:
    setKeymap(allocStr(data, -1), -1, 1);
    displayBuffer(CurrentTab->currentBuffer, 0);
}

TabBuffer* newTab()
{// addr = 0x08058E03  --  defined in 'main.c' at line 5984
    TabBuffer* n;    // _cfa_fffffff0

     *__esp = 24;
    GC_malloc();
    n = __eax;
    if(n != 0) {
        n->nextTab = 0;
        n->currentBuffer = 0;
        n->firstBuffer = 0;
        return n;
    }
    return 0;
}

void _newT()
{// addr = 0x08058E47  --  defined in 'main.c' at line 5998
    TabBuffer* tag;   // _cfa_fffffff0
    Buffer* buf;        // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    tag = newTab();
    if(tag != 0) {
        buf = newBuffer(CurrentTab->currentBuffer->width & 65535);
        copyBuffer(buf, CurrentTab->currentBuffer);
        buf->nextBuffer = 0;
        i = 0;
        while(i <= 4) {
             *(buf->topLine + (i + 4) * 4) = 0;
            i = i + 1;
        }
        buf->clone->filename =  &(buf->filename);
        tag->currentBuffer = buf;
        tag->firstBuffer = tag->currentBuffer;
        tag->nextTab = CurrentTab->nextTab;
        tag->prevTab = CurrentTab;
        if(CurrentTab->nextTab == 0) {
            LastTab = tag;
        } else {
            CurrentTab->nextTab->prevTab = tag;
        }
        CurrentTab->nextTab = tag;
        CurrentTab = tag;
        nTab = nTab + 1;
        return;
    }
}

void newT()
{// addr = 0x08058F3F  --  defined in 'main.c' at line 6027
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    _newT();
    displayBuffer(CurrentTab->currentBuffer, 4);
}

TabBuffer* numTab(int n)
{// addr = 0x08058F64  --  defined in 'main.c' at line 6034
    TabBuffer* tab;   // _cfa_fffffff8
    int i;                                 // _cfa_fffffff4

    if(n != 0) {
        if(n != 1) {
            if(nTab > 1) {
                tab = FirstTab;
                i = 1;
                while(tab != 0 && i < n) {
                    tab = tab->nextTab;
                    i = i + 1;
                }
                return tab;
            }
            return 0;
        }
        return FirstTab;
    }
    return CurrentTab;
}

void calcTabPos()
{// addr = 0x08058FC5  --  defined in 'main.c' at line 6050
    TabBuffer* tab;   // _cfa_fffffff8
    int lcol;                              // _cfa_fffffff4
    int rcol;                              // _cfa_fffffff0
    int col;                               // _cfa_ffffffec
    int n1;                                // _cfa_ffffffe8
    int n2;                                // _cfa_ffffffe4
    int na;                                // _cfa_ffffffe0
    int nx;                                // _cfa_ffffffdc
    int ny;                                // _cfa_ffffffd8
    int ix;                                // _cfa_ffffffd4
    int iy;                                // _cfa_ffffffd0
    signed int _v56;                       // _cfa_ffffffc8
    int _t128;                             // _t128

    lcol = 0;
    rcol = 0;
    if(mouse_action.menu_str == 0) {
        _t128 = 0;
    } else {
        _t128 =  *135792264;
    }
    lcol = _t128;
    if(nTab <= 0) {
        goto L28;
    } else {
        _v56 = TabCols;
        n1 = (COLS - rcol - lcol) / _v56;
        if(n1 < nTab) {
            if(n1 < 0) {
                n1 = 0;
            }
            _v56 = TabCols;
            n2 = COLS / _v56;
            if(n2 == 0) {
                n2 = 1;
            }
            ny = (nTab - n1 - 1) / n2 + 2;
        } else {
            n2 = 1;
            ny = 1;
        }
        na = (ny - 1) * n2 + n1;
        n1 = n1 - (na - nTab) / ny;
        if(n1 < 0) {
            n1 = 0;
        }
        na = (ny - 1) * n2 + n1;
        tab = FirstTab;
        iy = 0;
        while(iy < ny) {
            if(tab != 0) {
                if(iy != 0) {
                    _v56 = ny - 1;
                    nx = n2 - (na - nTab + iy - 1) / _v56;
                    col = COLS;
                } else {
                    nx = n1;
                    col = COLS - rcol - lcol;
                }
                ix = 0;
                while(ix < nx && tab != 0) {
                    tab->x1 = col * ix / nx;
                    tab->x2 = (ix + 1) * col / nx - 1;
                    tab->y = iy;
                    if(iy == 0) {
                        tab->x1 = (tab->x1 & 65535) + lcol;
                        tab->x2 = (tab->x2 & 65535) + lcol;
                    }
                    ix = ix + 1;
                    tab = tab->nextTab;
                }
                iy = iy + 1;
                continue;
            }
            return;
        }
L28:
        return;
    }
}

TabBuffer* deleteTab(TabBuffer* tab)
{// addr = 0x080591EE  --  defined in 'main.c' at line 6107
    Buffer* buf;        // _cfa_fffffff0
    Buffer* next;       // _cfa_ffffffec

    if(nTab <= 1) {
        return FirstTab;
    }
    if(tab->prevTab == 0) {
        tab->nextTab->prevTab = 0;
        FirstTab = tab->nextTab;
        if(tab == CurrentTab) {
            CurrentTab = tab->nextTab;
        }
    } else {
        if(tab->nextTab == 0) {
            LastTab = tab->prevTab;
        } else {
            tab->nextTab->prevTab = tab->prevTab;
        }
        tab->prevTab->nextTab = tab->nextTab;
        if(tab == CurrentTab) {
            CurrentTab = tab->prevTab;
        }
    }
    nTab = nTab - 1;
    buf = tab->firstBuffer;
    while(buf != 0 && buf != 1) {
        next = buf->nextBuffer;
        discardBuffer(buf);
        buf = next;
    }
    return FirstTab;
}

void closeT()
{// addr = 0x080592C9  --  defined in 'main.c' at line 6138
    TabBuffer* tab;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t15;                              // _t15

    if(nTab > 1) {
        if(prec_num == 0) {
            tab = CurrentTab;
        } else {
            if(prec_num == 0) {
                _t15 = 1;
            } else {
                _t15 = prec_num;
            }
            tab = numTab(_t15);
        }
        if(tab != 0) {
            deleteTab(tab);
        }
        displayBuffer(CurrentTab->currentBuffer, 4);
        return;
    }
}

void nextT()
{// addr = 0x0805933A  --  defined in 'main.c' at line 6153
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t9;                               // _t9

    if(nTab > 1) {
        i = 0;
L6:
L6:
        if(prec_num == 0) {
            _t9 = 1;
        } else {
            _t9 = prec_num;
        }
        if(_t9 > i) {
            goto L2;
        }
        displayBuffer(CurrentTab->currentBuffer, 4);
        return;
L2:
        if(CurrentTab->nextTab == 0) {
            CurrentTab = FirstTab;
        } else {
            CurrentTab = CurrentTab->nextTab;
        }
        i = i + 1;
        goto L6;
    }
}

void prevT()
{// addr = 0x080593B1  --  defined in 'main.c' at line 6168
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t11;                              // _t11

    if(nTab > 1) {
        i = 0;
L6:
L6:
        if(prec_num == 0) {
            _t11 = 1;
        } else {
            _t11 = prec_num;
        }
        if(_t11 > i) {
            goto L2;
        }
        displayBuffer(CurrentTab->currentBuffer, 4);
        return;
L2:
        if(CurrentTab->prevTab == 0) {
            CurrentTab = LastTab;
        } else {
            CurrentTab = CurrentTab->prevTab;
        }
        i = i + 1;
        goto L6;
    }
}

void followTab(TabBuffer* tab)
{// addr = 0x0805942A  --  defined in 'main.c' at line 6184
    Buffer* buf;        // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    Buffer* c;          // _cfa_ffffffe8
    Buffer* p;          // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a = retrieveCurrentImg(CurrentTab->currentBuffer);
    if(a == 0 || a->image == 0 || a->image->map == 0) {
        a = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    }
    if(a == 0) {
        return;
    }
    if(tab != CurrentTab) {
        _newT();
        buf = CurrentTab->currentBuffer;
        check_target = 0;
        followA();
        check_target = 1;
        if(tab != 0) {
            if(CurrentTab->currentBuffer == buf) {
L15:
                displayBuffer(CurrentTab->currentBuffer, 1);
                return;
            }
            c = CurrentTab->currentBuffer;
            p = prevBuffer(c, buf);
            p->nextBuffer = 0;
            CurrentTab->firstBuffer = buf;
            deleteTab(CurrentTab);
            CurrentTab = tab;
            buf = p;
            while(buf != 0) {
                p = prevBuffer(c, buf);
                pushBuffer(buf);
                buf = p;
            }
            goto L15;
        }
        if(CurrentTab->currentBuffer == buf) {
            deleteTab(CurrentTab);
        } else {
            delBuffer(buf);
        }
        goto L15;
    }
    check_target = 0;
    followA();
    check_target = 1;
}

void tabA()
{// addr = 0x080595AB  --  defined in 'main.c' at line 6232
    TabBuffer* _t2;   // _t2
    int _t4;                               // _t4

    if(prec_num == 0) {
        _t2 = 0;
    } else {
        if(prec_num == 0) {
            _t4 = 1;
        } else {
            _t4 = prec_num;
        }
        _t2 = numTab(_t4);
    }
    followTab(_t2);
}

void tabURL0(TabBuffer* tab, char* prompt, int relative)
{// addr = 0x080595E8  --  defined in 'main.c' at line 6238
    Buffer* buf;        // _cfa_fffffff0
    Buffer* c;          // _cfa_ffffffec
    Buffer* p;          // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(tab != CurrentTab) {
        _newT();
        buf = CurrentTab->currentBuffer;
        goURL0(prompt, relative);
        if(tab != 0) {
            if(CurrentTab->currentBuffer == buf) {
L10:
                displayBuffer(CurrentTab->currentBuffer, 1);
                return;
            }
            c = CurrentTab->currentBuffer;
            p = prevBuffer(c, buf);
            p->nextBuffer = 0;
            CurrentTab->firstBuffer = buf;
            deleteTab(CurrentTab);
            CurrentTab = tab;
            buf = p;
            while(buf != 0) {
                p = prevBuffer(c, buf);
                pushBuffer(buf);
                buf = p;
            }
            goto L10;
        }
        if(CurrentTab->currentBuffer == buf) {
            deleteTab(CurrentTab);
        } else {
            delBuffer(buf);
        }
        goto L10;
    }
    goURL0(prompt, relative);
}

void tabURL()
{// addr = 0x0805970B  --  defined in 'main.c' at line 6273
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    TabBuffer* _t4;   // _t4
    int _t6;                               // _t6

    if(prec_num == 0) {
        _t4 = 0;
    } else {
        if(prec_num == 0) {
            _t6 = 1;
        } else {
            _t6 = prec_num;
        }
        _t4 = numTab(_t6);
    }
    tabURL0(_t4, "Goto URL on new tab: ", 0);
}

void tabrURL()
{// addr = 0x08059758  --  defined in 'main.c' at line 6279
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    TabBuffer* _t4;   // _t4
    int _t6;                               // _t6

    if(prec_num == 0) {
        _t4 = 0;
    } else {
        if(prec_num == 0) {
            _t6 = 1;
        } else {
            _t6 = prec_num;
        }
        _t4 = numTab(_t6);
    }
    tabURL0(_t4, "Goto relative URL on new tab: ", 1);
}

void moveTab(TabBuffer* t, TabBuffer* t2, int right)
{// addr = 0x080597A5  --  defined in 'main.c' at line 6286
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(t2 == 1) {
        t2 = FirstTab;
    }
    if(t == 0) {
        return;
    }
    if(t2 == 0) {
        return;
    }
    if(t == t2) {
        return;
    }
    if(t != 1) {
        if(t->prevTab == 0) {
            t->nextTab->prevTab = 0;
            FirstTab = t->nextTab;
        } else {
            if(t->nextTab == 0) {
                LastTab = t->prevTab;
            } else {
                t->nextTab->prevTab = t->prevTab;
            }
            t->prevTab->nextTab = t->nextTab;
        }
        if(right == 0) {
            t->prevTab = t2->prevTab;
            t->nextTab = t2;
            if(t2->prevTab == 0) {
                FirstTab = t;
            } else {
                t2->prevTab->nextTab = t;
            }
            t2->prevTab = t;
        } else {
            t->nextTab = t2->nextTab;
            t->prevTab = t2;
            if(t2->nextTab == 0) {
                LastTab = t;
            } else {
                t2->nextTab->prevTab = t;
            }
            t2->nextTab = t;
        }
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
}

void tabR()
{// addr = 0x080598D9  --  defined in 'main.c' at line 6324
    TabBuffer* tab;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    TabBuffer* _t14;   // _t14
    int _t16;                              // _t16

    tab = CurrentTab;
    i = 0;
    while(tab != 0) {
        if(prec_num == 0) {
            _t16 = 1;
        } else {
            _t16 = prec_num;
        }
        if(_t16 > i) {
            tab = tab->nextTab;
            i = i + 1;
            continue;
        }
        break;
    }
    if(tab == 0) {
        _t14 = LastTab;
    } else {
        _t14 = tab;
    }
    moveTab(CurrentTab, _t14, 1);
}

void tabL()
{// addr = 0x08059948  --  defined in 'main.c' at line 6334
    TabBuffer* tab;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    TabBuffer* _t15;   // _t15
    int _t17;                              // _t17

    tab = CurrentTab;
    i = 0;
    while(tab != 0) {
        if(prec_num == 0) {
            _t17 = 1;
        } else {
            _t17 = prec_num;
        }
        if(_t17 > i) {
            tab = tab->prevTab;
            i = i + 1;
            continue;
        }
        break;
    }
    if(tab == 0) {
        _t15 = FirstTab;
    } else {
        _t15 = tab;
    }
    moveTab(CurrentTab, _t15, 0);
}

void addDownloadList(pid_t pid, char* url, char* save, char* lock, clen_t size)
{// addr = 0x080599B8  --  defined in 'main.c' at line 6345
    DownloadList* d;   // _cfa_fffffff0
    DownloadList* _v32;   // _cfa_ffffffe0
    long int _v36;                         // _cfa_ffffffdc
    struct _DownloadList* _v48;   // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    DownloadList* _t42;   // _t42
    long int _t50;                         // _t50

    _v36 = size;
    _t42 = _a24;
    _v32 = _t42;
     *__esp = 40;
    GC_malloc();
    d = _t42;
    d->pid = pid;
    d->url = url;
    if(( *save & 255) != 47 && ( *save & 255) != 126) {
        _v48 = 0;
        _v52 = save;
        _v56 = 135039651;
        save =  *(Strnew_m_charp(CurrentDir));
    }
    d->save = expandPath(save);
    d->lock = lock;
    __ecx = d;
    _t50 = _v36;
    __ecx->size = _t50;
    __ecx->size = _v32;
     *__esp = 0;
    time();
    d->time = _t50;
    d->ok = 0;
    d->next = 0;
    d->prev = LastDL;
    if(LastDL == 0) {
        FirstDL = d;
    } else {
        LastDL->next = d;
    }
    LastDL = d;
    add_download_list = 1;
}

int checkDownloadList()
{// addr = 0x08059AB4  --  defined in 'main.c' at line 6370
    DownloadList* d;   // _cfa_fffffff0
    struct stat st;       // _cfa_ffffff98
    _unknown_ _v120;                       // _cfa_ffffff88 (outparam)

    if(FirstDL != 0) {
        d = FirstDL;
        while(d != 0) {
            if(d->ok != 0 || __lstat(d->lock,  &(st.st_dev)) != 0) {
                d = d->next;
                continue;
            } else {
                return 1;
            }
        }
        return 0;
    }
    return 0;
}

char* convert_size3(clen_t size)
{// addr = 0x08059B14  --  defined in 'main.c' at line 6385
    Str tmp;               // _cfa_fffffff0
    int n;                                 // _cfa_ffffffec
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    char* _v52;                            // _cfa_ffffffcc (outparam)
    int _v56;                              // _cfa_ffffffc8 (outparam)
    char* _t39;                            // _t39
    signed int _t46;                       // _t46
    char* _t47;                            // _t47

    _v36 = size;
    _v32 = _a8;
    tmp = Strnew();
    do {
        n = __moddi3(_v36, _v32, 1000, 0);
        _t46 = _v32;
        _v36 = __divdi3(_v36, _t46, 1000, 0);
        _v32 = _t46;
        _t47 = tmp->ptr;
        if((_v36 | _v32) == 0) {
            _t39 = "%d%s";
        } else {
            _t39 = ",%.3d%s";
        }
        _v52 = _t47;
        _v56 = n;
        tmp = Sprintf(_t39);
    } while((_v36 | _v32) != 0);
    return tmp->ptr;
}

Buffer* DownloadListBuffer()
{// addr = 0x08059BC5  --  defined in 'main.c' at line 6399
    DownloadList* d;   // _cfa_ffffffe0
    Str src;               // _cfa_ffffffdc
    time_t cur_time;    // _cfa_ffffffd8
    int duration;                          // _cfa_ffffffd4
    int rate;                              // _cfa_ffffffd0
    int eta;                               // _cfa_ffffffcc
    size_t size;        // _cfa_ffffffc8
    int i;                                 // _cfa_ffffffc4
    int l;                                 // _cfa_ffffffc0
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ _v108;                       // _cfa_ffffff94
    struct stat st;       // _cfa_ffffff68
    Buffer* _v160;      // _cfa_ffffff60
    unsigned int _v164;                    // _cfa_ffffff5c
    _unknown_ _v166;                       // _cfa_ffffff5a
    short _v168;                           // _cfa_ffffff58
    int _v172;                             // _cfa_ffffff54
    signed int _v176;                      // _cfa_ffffff50
    intOrPtr _v204;                        // _cfa_ffffff34
    int _v208;                             // _cfa_ffffff30 (outparam)
    signed int _v212;                      // _cfa_ffffff2c (outparam)
    int _v216;                             // _cfa_ffffff28 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    long int _t288;                        // _t288
    _unknown_ _t300;                       // _t300
    _unknown_ _t303;                       // _t303
    int _t327;                             // _t327
    DownloadList* _t349;   // _t349
    long long int _t350;                   // _t350
    signed int _t357;                      // _t357
    char* _t358;                           // _t358
    DownloadList* _t388;   // _t388
    long long int _t389;                   // _t389
    DownloadList* _t421;   // _t421
    long long int _t422;                   // _t422
    DownloadList* _t424;   // _t424
    DownloadList* _t428;   // _t428
    signed int _t430;                      // _t430
    int _t432;                             // _t432
    DownloadList* _t437;   // _t437
    long long int _t438;                   // _t438
    int _t448;                             // _t448
    int _t462;                             // _t462
    int _t475;                             // _t475
    DownloadList* _t483;   // _t483
    size_t _t517;       // _t517
    size_t _t525;       // _t525
    size_t _t535;       // _t535
    size_t _t536;       // _t536
    _unknown_ _t540;                       // _t540
    long long int _t553;                   // _t553
    long long int _t580;                   // _t580
    long long int _t604;                   // _t604
    long long int _t609;                   // _t609

    src = 0;
    _t288 = FirstDL;
    if(_t288 == 0) {
        return 0;
    }
     *__esp = 0;
    time();
    cur_time = _t288;
    src = Strnew_charp("<html><head><title>Download List Panel</title></head>\n<body><h1 align=center>Download List Panel</h1>\n<form method=internal action=download><hr>\n");
    d = LastDL;
    while(d != 0) {
        if((d->size | d->size) == 0) {
L28:
            if(d->ok != 0) {
L33:
                 *__esp = size;
                _v216 = 0;
                _v216 = convert_size3();
                Strcat(src, Sprintf("  %s bytes loaded"));
L34:
                if(duration > 0) {
                    _v176 = duration;
                    rate = size / _v176;
                    _t357 = rate;
                    _v212 = 1;
                     *__esp = _t357;
                    _v216 = _t357 >> 31;
                    _t358 = convert_size();
                    _t518 = duration;
                    _t519 = duration;
                    _t521 = ((duration * -2004318071 >> 32) + duration >> 5) - (_t519 >> 31);
                    _v204 = _t358;
                    _v208 = duration - (((duration * -2004318071 >> 32) + duration >> 5) - (_t518 >> 31) << 2 << 4) - (((duration * -2004318071 >> 32) + duration >> 5) - (_t518 >> 31) << 2);
                    _v212 = ((duration * -2004318071 >> 32) + duration >> 5) - (_t519 >> 31) - ((((((duration * -2004318071 >> 32) + duration >> 5) - (_t519 >> 31)) * -2004318071 >> 32) + ((duration * -2004318071 >> 32) + duration >> 5) - (_t519 >> 31) >> 5) - (_t521 >> 31) << 2 << 4) - ((((((duration * -2004318071 >> 32) + duration >> 5) - (_t519 >> 31)) * -2004318071 >> 32) + ((duration * -2004318071 >> 32) + duration >> 5) - (_t519 >> 31) >> 5) - (_t521 >> 31) << 2);
                    _v216 = ((duration * -1851608123 >> 32) + duration >> 11) - (duration >> 31);
                    Strcat(src, Sprintf("  %02d:%02d:%02d  rate %s/sec"));
                    if(d->ok == 0) {
                        _t525 = size;
                        _t388 = d;
                        _t580 = _t388->size;
                        _t389 = _t388->size;
                        if(0 <= _t580 && (0 < _t580 || _t525 < _t389) && rate != 0) {
                            asm("sbb edx, ebx");
                            eta = __divdi3(d->size - size, d->size, rate, rate >> 31);
                            _t528 = eta;
                            _t529 = eta;
                            _t531 = ((eta * -2004318071 >> 32) + eta >> 5) - (_t529 >> 31);
                            _v208 = eta - (((eta * -2004318071 >> 32) + eta >> 5) - (_t528 >> 31) << 2 << 4) - (((eta * -2004318071 >> 32) + eta >> 5) - (_t528 >> 31) << 2);
                            _v212 = ((eta * -2004318071 >> 32) + eta >> 5) - (_t529 >> 31) - ((((((eta * -2004318071 >> 32) + eta >> 5) - (_t529 >> 31)) * -2004318071 >> 32) + ((eta * -2004318071 >> 32) + eta >> 5) - (_t529 >> 31) >> 5) - (_t531 >> 31) << 2 << 4) - ((((((eta * -2004318071 >> 32) + eta >> 5) - (_t529 >> 31)) * -2004318071 >> 32) + ((eta * -2004318071 >> 32) + eta >> 5) - (_t529 >> 31) >> 5) - (_t531 >> 31) << 2);
                            _v216 = ((eta * -1851608123 >> 32) + eta >> 11) - (eta >> 31);
                            Strcat(src, Sprintf("  eta %02d:%02d:%02d"));
                        }
                    }
                }
                if(src->length + 1 >= src->area_size) {
                    Strgrow(src);
                }
                _t327 = src->length;
                 *((char*)(src->ptr + _t327)) = 10;
                src->length = _t327 + 1;
                 *((char*)(src->ptr + src->length)) = 0;
                if(d->ok == 0) {
                    _v216 = d->pid;
                    Strcat(src, Sprintf("<input type=submit name=stop%d value=STOP>"));
                } else {
                    _v216 = d->pid;
                    Strcat(src, Sprintf("<input type=submit name=ok%d value=OK>"));
                    _t517 = size;
                    _t349 = d;
                    _t553 = _t349->size;
                    _t350 = _t349->size;
                    if(0 > _t553 || 0 >= _t553 && _t517 >= _t350) {
                        Strcat_charp(src, " Download completed");
                    } else {
                        Strcat_charp(src, " Download incompleted");
                    }
                }
                Strcat_charp(src, "\n</pre><hr>\n");
                d = d->prev;
                continue;
            }
            _t535 = size;
            _t421 = d;
            _t604 = _t421->size;
            _t422 = _t421->size;
            if(0 > _t604 || 0 >= _t604 && _t535 >= _t422) {
                goto L33;
            } else {
                _v164 = size;
                _v160 = 0;
                asm("fild qword [ebp-0xa0]");
                asm("fmulp st1, st0");
                _t424 = d;
                _v164 = _t424->size;
                _v160 = _t424->size;
                asm("fild qword [ebp-0xa0]");
                asm("fdivp st1, st0");
                asm("fnstcw word [ebp-0xa2]");
                _v168 = 12;
                asm("fldcw word [ebp-0xa4]");
                asm("fistp dword [ebp-0xa8]");
                asm("fldcw word [ebp-0xa2]");
                _t428 = d;
                 *__esp = _t428->size;
                _v216 = _t428->size;
                _t430 = convert_size3();
                 *__esp = size;
                _v216 = 0;
                _t432 = convert_size3();
                _v208 = _v172;
                _v212 = _t430;
                _v216 = _t432;
                Strcat(src, Sprintf("  %s / %s bytes (%d%%)"));
                goto L34;
            }
        } else {
            l = COLS - 6;
            _t536 = size;
            _t437 = d;
            _t609 = _t437->size;
            _t438 = _t437->size;
            if(0 > _t609 || 0 >= _t609 && _t536 >= _t438) {
                i = l;
            } else {
                asm("fild dword [ebp-0x3c]");
                _v164 = size;
                _v160 = 0;
                asm("fild qword [ebp-0xa0]");
                asm("fmulp st1, st0");
                _t483 = d;
                _v164 = _t483->size;
                _v160 = _t483->size;
                asm("fild qword [ebp-0xa0]");
                asm("fdivp st1, st0");
                asm("fnstcw word [ebp-0xa2]");
                _v168 = 12;
                asm("fldcw word [ebp-0xa4]");
                asm("fistp dword [ebp-0x38]");
                asm("fldcw word [ebp-0xa2]");
            }
            l = l - i;
            while(1) {
                i = i - 1;
                if(i <= 0) {
                    break;
                }
                if(src->length + 1 >= src->area_size) {
                    Strgrow(src);
                }
                _t448 = src->length;
                 *((char*)(src->ptr + _t448)) = 35;
                src->length = _t448 + 1;
                 *((char*)(src->ptr + src->length)) = 0;
            }
            while(1) {
                l = l - 1;
                if(l <= 0) {
                    break;
                }
                if(src->length + 1 >= src->area_size) {
                    Strgrow(src);
                }
                _t462 = src->length;
                 *((char*)(src->ptr + _t462)) = 95;
                src->length = _t462 + 1;
                 *((char*)(src->ptr + src->length)) = 0;
            }
            if(src->length + 1 >= src->area_size) {
                Strgrow(src);
            }
            _t475 = src->length;
             *((char*)(src->ptr + _t475)) = 10;
            src->length = _t475 + 1;
             *((char*)(src->ptr + src->length)) = 0;
            goto L28;
        }
    }
    Strcat_charp(src, "</form></body></html>");
    return loadHTMLString(src);
}

void download_action(struct parsed_tagarg* arg)
{// addr = 0x0805A352  --  defined in 'main.c' at line 6481
    DownloadList* d;   // _cfa_fffffff0
    pid_t pid;           // _cfa_ffffffec
    intOrPtr _v36;                         // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _t45;                            // _t45
    char* _t47;                            // _t47
    int _t50;                              // _t50
    int _t74;                              // _t74

    while(arg != 0) {
        _t45 = arg->arg;
        _v36 = 4;
        _v40 = "stop";
         *__esp = _t45;
        strncmp();
        if(_t45 != 0) {
            _t47 = arg->arg;
            _v36 = 2;
            _v40 = "ok";
             *__esp = _t47;
            strncmp();
            if(_t47 != 0) {
L17:
                arg = arg->next;
                continue;
            }
            _t50 =  &(arg->arg[2]);
             *__esp = _t50;
            atoi();
            pid = _t50;
L5:
            d = FirstDL;
            while(d != 0) {
                if(d->pid != pid) {
                    d = d->next;
                    continue;
                }
                 *__esp = d->lock;
                unlink();
                if(d->prev == 0) {
                    FirstDL = d->next;
                } else {
                    d->prev->next = d->next;
                }
                if(d->next == 0) {
                    LastDL = d->prev;
                } else {
                    d->next->prev = d->prev;
                }
                goto L17;
            }
            goto L17;
        }
        _t74 =  &(arg->arg[4]);
         *__esp = _t74;
        atoi();
        pid = _t74;
        _v40 = 9;
         *__esp = pid;
        kill();
        goto L5;
    }
    ldDL();
}

void stopDownload()
{// addr = 0x0805A47A  --  defined in 'main.c' at line 6516
    DownloadList* d;   // _cfa_fffffff0
    intOrPtr _v40;                         // _cfa_ffffffd8

    if(FirstDL != 0) {
        d = FirstDL;
        while(d != 0) {
            if(d->ok == 0) {
                _v40 = 9;
                 *__esp = d->pid;
                kill();
                 *__esp = d->lock;
                unlink();
            }
            d = d->next;
        }
        return;
    }
}

void ldDL()
{// addr = 0x0805A4D7  --  defined in 'main.c' at line 6533
    Buffer* buf;        // _cfa_fffffff0
    int replace;                           // _cfa_ffffffec
    int new_tab;                           // _cfa_ffffffe8
    int reload;                            // _cfa_ffffffe4
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    char* _t114;                           // _t114

    replace = 0;
    new_tab = 0;
    if((CurrentTab->currentBuffer->bufferprop & 8) != 0) {
        _t114 = CurrentTab->currentBuffer->buffername;
        _v56 = "Download List Panel";
         *__esp = _t114;
        strcmp();
        if(_t114 == 0) {
            replace = 1;
        }
    }
    if(FirstDL != 0) {
        reload = checkDownloadList();
        buf = DownloadListBuffer();
        if(buf != 0) {
            buf->bufferprop = buf->bufferprop & 65535 | 24;
            if(replace != 0) {
                buf->rootX = CurrentTab->currentBuffer->rootX & 65535;
                buf->rootY = CurrentTab->currentBuffer->rootY & 65535;
                buf->COLS = CurrentTab->currentBuffer->COLS & 65535;
                buf->LINES = CurrentTab->currentBuffer->LINES & 65535;
                restorePosition(buf, CurrentTab->currentBuffer);
            }
            if(replace == 0 && open_tab_dl_list != 0) {
                _newT();
                new_tab = 1;
            }
            pushBuffer(buf);
            if(replace != 0 || new_tab != 0) {
                deletePrevBuf();
            }
            if(reload != 0) {
                CurrentTab->currentBuffer->event = setAlarmEvent(CurrentTab->currentBuffer->event, 1, 2, 112, 0);
            }
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    if(replace == 0) {
        return;
    }
    if(CurrentTab->currentBuffer != CurrentTab->firstBuffer || CurrentTab->currentBuffer->nextBuffer != 0) {
        delBuffer(CurrentTab->currentBuffer);
    } else {
        if(nTab > 1) {
            deleteTab(CurrentTab);
        }
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
}

void save_buffer_position(Buffer* buf)
{// addr = 0x0805A6F6  --  defined in 'main.c' at line 6585
    BufferPos* b;    // _cfa_fffffff0
    int _t75;                              // _t75
    long int _t78;                         // _t78
    long int _t81;                         // _t81
    int _t88;                              // _t88
    long int _t125;                        // _t125
    long int _t126;                        // _t126

    b = buf->undo;
    _t75 = buf->firstLine;
    if(_t75 == 0) {
        return;
    }
    if(b == 0) {
L12:
         *__esp = 28;
        GC_malloc();
        b = _t75;
        if(buf->topLine == 0) {
            _t78 = 1;
        } else {
            _t78 = buf->topLine->linenumber;
        }
        b->top_linenumber = _t78;
        if(buf->currentLine == 0) {
            _t81 = 1;
        } else {
            _t81 = buf->currentLine->linenumber;
        }
        b->cur_linenumber = _t81;
        b->currentColumn = buf->currentColumn;
        b->pos = buf->pos;
        if(buf->currentLine == 0) {
            _t88 = 0;
        } else {
            _t88 = buf->currentLine->bpos;
        }
        b->bpos = _t88;
        b->next = 0;
        b->prev = buf->undo;
        if(buf->undo != 0) {
            buf->undo->next = b;
        }
        buf->undo = b;
        return;
    }
    _t125 = b->top_linenumber;
    if(buf->topLine == 0) {
        _t75 = 1;
    } else {
        _t75 = buf->topLine->linenumber;
    }
    if(_t125 != _t75) {
        goto L12;
    }
    _t126 = b->cur_linenumber;
    if(buf->currentLine == 0) {
        _t75 = 1;
    } else {
        _t75 = buf->currentLine->linenumber;
    }
    if(_t126 != _t75) {
        goto L12;
    }
    _t75 = buf->currentColumn;
    if(b->currentColumn != _t75) {
        goto L12;
    }
    _t75 = buf->pos;
    if(b->pos != _t75) {
        goto L12;
    }
}

void resetPos(BufferPos* b)
{// addr = 0x0805A856  --  defined in 'main.c' at line 6609
    long int _v36;                         // _cfa_ffffffdc
    Line top;             // _cfa_ffffffc0
    int _v72;                              // _cfa_ffffffb8
    long int _v88;                         // _cfa_ffffffa8
    Line cur;             // _cfa_ffffff8c
    int _v300;                             // _cfa_fffffed4
    int _v308;                             // _cfa_fffffecc
    struct _Line* _v360;   // _cfa_fffffe98
    struct _Line* _v364;   // _cfa_fffffe94
    Buffer buf;         // _cfa_fffffe88
    _unknown_ _v392;                       // _cfa_fffffe78 (outparam)

    _v36 = b->top_linenumber;
    _v88 = b->cur_linenumber;
    _v72 = b->bpos;
    _v364 =  &top;
    _v360 =  &cur;
    _v300 = b->pos;
    _v308 = b->currentColumn;
    restorePosition(CurrentTab->currentBuffer,  &buf);
    CurrentTab->currentBuffer->undo = b;
    displayBuffer(CurrentTab->currentBuffer, 1);
}

void undoPos()
{// addr = 0x0805A8E8  --  defined in 'main.c' at line 6626
    BufferPos* b;    // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int _t28;                              // _t28

    b = CurrentTab->currentBuffer->undo;
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    if(b == 0) {
        return;
    }
    if(b->prev != 0) {
        i = 0;
L5:
L5:
        if(prec_num == 0) {
            _t28 = 1;
        } else {
            _t28 = prec_num;
        }
        if(_t28 <= i || b->prev == 0) {
            goto L10;
        }
        i = i + 1;
        b = b->prev;
        goto L5;
L10:
        resetPos(b);
        return;
    }
}

void redoPos()
{// addr = 0x0805A96E  --  defined in 'main.c' at line 6639
    BufferPos* b;    // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int _t28;                              // _t28

    b = CurrentTab->currentBuffer->undo;
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    if(b == 0) {
        return;
    }
    if(b->next != 0) {
        i = 0;
L5:
L5:
        if(prec_num == 0) {
            _t28 = 1;
        } else {
            _t28 = prec_num;
        }
        if(_t28 <= i || b->next == 0) {
            goto L10;
        }
        i = i + 1;
        b = b->next;
        goto L5;
L10:
        resetPos(b);
        return;
    }
}

void KeyAbort(int _dummy)
{// addr = 0x0805A9F4  --  defined in 'file.c' at line 181
    intOrPtr _v0;                          // _cfa_0
    signed char* _v24;                     // _cfa_ffffffe8
    signed int _t11;                       // _t11
    _unknown_ _t18;                        // _t18

    _v24 = 1;
     *__esp =  &AbortLoading;
    siglongjmp();
    _push(_t18);
    __esp = __esp - 24;
    _t11 =  *_v24 & 0xff;
    if(_t11 == 7 || _t11 == 9) {
        closeNews();
        return;
    }
    if(_t11 == 2) {
        closeFTP();
        return;
    }
    if(ISclose( *(_v0 + 4)) == 0) {
         *(_v0 + 4) = 0;
        return;
    }
}

void UFhalfclose(URLFile* f)
{// addr = 0x0805AA0E  --  defined in 'file.c' at line 188
    signed int _t10;                       // _t10

    _t10 = f->scheme & 0xff;
    if(_t10 == 7 || _t10 == 9) {
        closeNews();
        return;
    } else {
        if(_t10 != 2) {
            if(ISclose(f->stream) != 0) {
                return;
            }
            f->stream = 0;
            return;
        }
        closeFTP();
        return;
    }
}

int currentLn(Buffer* buf)
{// addr = 0x0805AA60  --  defined in 'file.c' at line 207
    if(buf->currentLine == 0) {
        return 1;
    }
    return buf->currentLine->linenumber + 1;
}

Buffer* loadSomething(URLFile* f, char* path, _None* loadproc, Buffer* defaultbuf)
{// addr = 0x0805AA82  --  defined in 'file.c' at line 217
    Buffer* buf;        // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    Buffer* _v40;       // _cfa_ffffffd8 (outparam)
    Buffer* _t41;       // _t41
    char* _t45;                            // _t45
    struct _Str* _t62;    // _t62

    _v40 = defaultbuf;
     *__esp = f;
    _t41 = loadproc;
    _t41->filename();
    buf = _t41;
    if(buf == 0) {
        return 0;
    }
    buf->filename = path;
    if(buf->buffername == 0 || (buf & 255) == 0) {
        _v40 = "Subject:";
        _t45 = buf;
         *__esp = _t45;
        checkHeader();
        buf->buffername = _t45;
        if(buf->buffername == 0) {
            _t62 = path;
            lastFileName(_t62) = Strnew_charp(_t62);
            __eax = wc_Str_conv(_t62, SystemCharset, InnerCharset);
            buf->buffername =  *_t62;
        }
    }
    if(buf->currentURL == 255) {
        buf->currentURL = f->scheme & 0xff;
    }
    buf->real_scheme = f->scheme & 0xff;
    if((f->scheme & 255) == 4 && buf->sourcefile == 0) {
        buf->sourcefile = path;
    }
    return buf;
}

int dir_exist(char* path)
{// addr = 0x0805AB89  --  defined in 'file.c' at line 241
    _unknown_ _v84;                        // _cfa_ffffffac
    struct stat stbuf;    // _cfa_ffffff9c
    _unknown_ _v120;                       // _cfa_ffffff88 (outparam)

    if(path == 0 || ( *path & 255) == 0) {
        return 0;
    } else {
        if(__stat(path,  &(stbuf.st_dev)) != -1) {
            return (stbuf.st_mode & 61440) == 16384 & 255;
        }
        return 0;
    }
}

int is_dump_text_type(char* type)
{// addr = 0x0805ABD9  --  defined in 'file.c' at line 253
    struct mailcap* mcap;   // _cfa_fffffff0

    if(type == 0) {
L4:
        return 0;
    }
    mcap = searchExtViewer(type);
    if(mcap == 0 || (mcap->flags & 6) == 0) {
        goto L4;
    } else {
        return 1;
    }
}

int is_text_type(char* type)
{// addr = 0x0805AC14  --  defined in 'file.c' at line 261
    intOrPtr _v20;                         // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    char* _t12;                            // _t12
    char* _t13;                            // _t13

    if(type == 0 || ( *type & 255) == 0) {
L4:
        return 1;
    } else {
        _v20 = 5;
        _v24 = "text/";
        _t12 = type;
         *__esp = _t12;
        strncasecmp();
        if(_t12 == 0) {
            goto L4;
        }
        _v20 = 8;
        _v24 = "message/";
        _t13 = type;
         *__esp = _t13;
        strncasecmp();
        if(_t13 != 0) {
            return 0;
        }
        goto L4;
    }
}

int is_plain_text_type(char* type)
{// addr = 0x0805AC76  --  defined in 'file.c' at line 269
    char* _v24;                            // _cfa_ffffffe8
    char* _t12;                            // _t12

    if(type == 0) {
L2:
        if(is_text_type(type) == 0 || is_dump_text_type(type) != 0) {
            return 0;
        } else {
L4:
            return 1;
        }
    }
    _v24 = "text/plain";
    _t12 = type;
     *__esp = _t12;
    strcasecmp();
    if(_t12 == 0) {
        goto L4;
    }
    goto L2;
}

int is_html_type(char* type)
{// addr = 0x0805ACC5  --  defined in 'file.c' at line 276
    char* _v24;                            // _cfa_ffffffe8
    char* _t7;                             // _t7
    char* _t9;                             // _t9

    if(type == 0) {
L4:
        return 0;
    }
    _v24 = "text/html";
    _t7 = type;
     *__esp = _t7;
    strcasecmp();
    if(_t7 == 0) {
L3:
        return 1;
    }
    _v24 = "application/xhtml+xml";
    _t9 = type;
     *__esp = _t9;
    strcasecmp();
    if(_t9 != 0) {
        goto L4;
    }
    goto L3;
}

void check_compression(char* path, URLFile* uf)
{// addr = 0x0805AD0D  --  defined in 'file.c' at line 283
    int len;                               // _cfa_fffffff0
    struct compression_decoder* d;   // _cfa_ffffffec
    int elen;                              // _cfa_ffffffe8
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    int _t30;                              // _t30
    int _t37;                              // _t37
    char* _t42;                            // _t42

    if(path != 0) {
        _t30 = path;
         *__esp = _t30;
        strlen();
        len = _t30;
        uf->compression = 0;
        d =  &compression_decoders;
        while(d->type != 0) {
            if(d->ext == 0) {
L7:
                d = d + 44;
                continue;
            }
            _t37 = d->ext;
             *__esp = _t37;
            strlen();
            elen = _t37;
            if(len <= elen) {
                goto L7;
            }
            _t42 =  &(path[len - elen]);
            _v40 = d->ext;
             *__esp = _t42;
            strcasecmp();
            if(_t42 != 0) {
                goto L7;
            }
            uf->compression = d->type;
            uf->guess_type = d->mime_type;
            return;
        }
        return;
    }
}

char* compress_application_type(int compression)
{// addr = 0x0805ADB7  --  defined in 'file.c' at line 307
    struct compression_decoder* d;   // _cfa_fffffff8

    d =  &compression_decoders;
    while(d->type != 0) {
        if(d->type != compression) {
            d = d + 44;
            continue;
        }
        return d->mime_type;
    }
    return 0;
}

char* uncompressed_file_type(char* path, char** ext)
{// addr = 0x0805ADEC  --  defined in 'file.c' at line 319
    int len;                               // _cfa_fffffff0
    int slen;                              // _cfa_ffffffec
    Str fn;                // _cfa_ffffffe8
    char* t0;                              // _cfa_ffffffe4
    struct compression_decoder* d;   // _cfa_ffffffe0
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t37;                              // _t37
    int _t43;                              // _t43
    char* _t48;                            // _t48

    if(path != 0) {
        slen = 0;
        _t37 = path;
         *__esp = _t37;
        strlen();
        len = _t37;
        d =  &compression_decoders;
        while(d->type != 0) {
            if(d->ext == 0) {
L8:
                d = d + 44;
                continue;
            }
            _t43 = d->ext;
             *__esp = _t43;
            strlen();
            slen = _t43;
            if(len <= slen) {
                goto L8;
            }
            _t48 =  &(path[len - slen]);
            _v56 = d->ext;
             *__esp = _t48;
            strcasecmp();
            if(_t48 == 0) {
L12:
                if(d->type != 0) {
                    fn = Strnew_charp(path);
                    Strshrink(fn, slen);
                    if(ext != 0) {
                         *ext = filename_extension(fn->ptr, 0);
                    }
                    t0 = guessContentType(fn->ptr);
                    if(t0 == 0) {
                        t0 = "text/plain";
                    }
                    return t0;
                }
                return 0;
            }
            goto L8;
        }
        goto L12;
    }
    return 0;
}

int setModtime(char* path, time_t modtime)
{// addr = 0x0805AEF2  --  defined in 'file.c' at line 352
    _unknown_ _v16;                        // _cfa_fffffff0
    struct utimbuf t;   // _cfa_ffffffec
    _unknown_ _v52;                        // _cfa_ffffffcc
    struct stat st;       // _cfa_ffffff94
    long int* _v120;                       // _cfa_ffffff88 (outparam)
    long int _t13;                         // _t13
    int _t16;                              // _t16

    _t13 = __stat(path,  &(st.st_dev));
    if(_t13 != 0) {
         *__esp = 0;
        time();
        t.actime = _t13;
    } else {
        t.actime = st.st_atim.tv_sec;
    }
    t.modtime = modtime;
    _v120 =  &(t.actime);
    _t16 = path;
     *__esp = _t16;
    utime();
    return _t16;
}

void examineFile(char* path, URLFile* uf)
{// addr = 0x0805AF3F  --  defined in 'file.c' at line 366
    FILE* fp;             // _cfa_fffffff0
    char* ext;                             // _cfa_ffffffec
    char* t0;                              // _cfa_ffffffe8
    _unknown_ _v96;                        // _cfa_ffffffa0
    struct stat stbuf;    // _cfa_ffffff90
    union input_stream* _v136;   // _cfa_ffffff78 (outparam)
    int _t67;                              // _t67
    int _t70;                              // _t70

    uf->guess_type = 0;
    if(path == 0 || ( *path & 255) == 0 || __stat(path,  &(stbuf.st_dev)) == -1 || (stbuf.st_mode & 61440) != 32768) {
        uf->stream = 0;
        return;
    }
    _v136 = 0;
    _t67 = path;
     *__esp = _t67;
    open();
    uf->stream = newInputStream(_t67);
    if(do_download != 0) {
L18:
        return;
    } else {
        _t70 = use_lessopen;
        if(_t70 == 0) {
L15:
            check_compression(path, uf);
            if(uf->compression == 0) {
                goto L18;
            }
            ext = uf->ext;
            t0 = uncompressed_file_type(path,  &ext);
            uf->guess_type = t0;
            uf->ext = ext;
            uncompress_stream(uf, 0);
            return;
        }
         *__esp = "LESSOPEN";
        getenv();
        if(_t70 == 0) {
            goto L15;
        }
        uf->guess_type = guessContentType(path);
        if(uf->guess_type == 0) {
            uf->guess_type = "text/plain";
        }
        if(is_html_type(uf->guess_type) != 0) {
            goto L18;
        }
        fp = lessopen_stream(path);
        if(fp == 0) {
            goto L15;
        }
        if(ISclose(uf->stream) == 0) {
            uf->stream = 0;
        }
        uf->stream = newFileStream(fp, pclose);
        uf->guess_type = "text/plain";
        return;
    }
}

int check_command(char* cmd, int auxbin_p)
{// addr = 0x0805B0E4  --  defined in 'file.c' at line 407
    Str dirs;              // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* np;                              // _cfa_ffffffe8
    Str pathname;          // _cfa_ffffffe4
    _unknown_ _v100;                       // _cfa_ffffff9c
    struct stat st;       // _cfa_ffffff8c
    intOrPtr _v136;                        // _cfa_ffffff78 (outparam)
    char* _t45;                            // _t45
    char* _t50;                            // _t50
    int _t60;                              // _t60

    _t45 = path.9119;
    if(_t45 == 0) {
         *__esp = "PATH";
        getenv();
        path.9119 = _t45;
    }
    if(auxbin_p == 0) {
        dirs = Strnew_charp(path.9119);
    } else {
        dirs = Strnew_charp(w3m_auxbin_dir());
    }
    p = dirs->ptr;
    while(p != 0) {
        _v136 = 58;
        _t50 = p;
         *__esp = _t50;
        strchr();
        np = _t50;
        if(np != 0) {
             *np = 0;
            np =  &(np[1]);
        }
        pathname = Strnew();
        Strcat_charp(pathname, p);
        if(pathname->length + 1 >= pathname->area_size) {
            Strgrow(pathname);
        }
        _t60 = pathname->length;
         *((char*)(pathname->ptr + _t60)) = 47;
        pathname->length = _t60 + 1;
         *((char*)(pathname->ptr + pathname->length)) = 0;
        Strcat_charp(pathname, cmd);
        if(__stat(pathname->ptr,  &(st.st_dev)) != 0 || (st.st_mode & 61440) != 32768 || (st.st_mode & 73) == 0) {
            p = np;
            continue;
        } else {
            return 1;
        }
    }
    return 0;
}

char* acceptableEncoding()
{// addr = 0x0805B228  --  defined in 'file.c' at line 437
    struct compression_decoder* d;   // _cfa_fffffff0
    TextList* l;      // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(encodings == 0) {
        l = newGeneralList();
        d =  &compression_decoders;
        while(d->type != 0) {
            if(check_command(d->cmd, d->auxbin_p) != 0) {
                pushValue(l, allocStr(d->encoding, -1));
            }
            d = d + 44;
        }
        encodings = Strnew();
        while(1) {
            p = popValue(l);
            if(p == 0) {
                break;
            }
            if(encodings->length != 0) {
                Strcat_charp(encodings, ", ");
            }
            Strcat_charp(encodings, p);
        }
        return encodings->ptr;
    }
    return encodings->ptr;
}

Str convertLine(URLFile* uf, Str line, int mode, wc_ces* charset, wc_ces doc_charset)
{// addr = 0x0805B300  --  defined in 'file.c' at line 466
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    line = wc_Str_conv_with_detect(line, charset, doc_charset, InnerCharset);
    if(mode != 0) {
        cleanup_line(line, mode);
    }
    if(uf != 0 && (uf->scheme & 255) == 9) {
        Strchop(line);
    }
    return line;
}

Buffer* loadFile(char* path)
{// addr = 0x0805B363  --  defined in 'file.c' at line 489
    Buffer* buf;        // _cfa_fffffff0
    union input_stream* _v44;   // _cfa_ffffffd4
    URLFile uf;        // _cfa_ffffffd0
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ _t26;                        // _t26
    int _t27;                              // _t27
    int _t41;                              // _t41

    init_stream( &uf, 4, 0);
    examineFile(path,  &uf);
    if(_v44 != 0) {
        _t41 = COLS;
        if(showLineNum == 0) {
            _t26 = 1;
        } else {
            _t26 = 6;
        }
        _t27 = _t41 - _t26;
        _t28 = _t27 < 0 ? 0 : _t27;
        buf = newBuffer(_t27 < 0 ? 0 : _t27);
        current_content_length = 0;
         *135776436 = 0;
        content_charset = 0;
        buf = loadSomething( &uf, path, loadBuffer, buf);
        if(ISclose(_v44) == 0) {
            _v44 = 0;
        }
        return buf;
    }
    return 0;
}

int matchattr(char* p, char* attr, int len, Str* value)
{// addr = 0x0805B43F  --  defined in 'file.c' at line 508
    int quoted;                            // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    int _v36;                              // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    char* _t67;                            // _t67
    struct _Str* _t114;   // _t114
    int _t151;                             // _t151

    q = 0;
    _v36 = len;
    _v40 = attr;
    _t67 = p;
     *__esp = _t67;
    strncasecmp();
    if(_t67 != 0) {
L33:
        return 0;
    } else {
        p =  &(p[len]);
        while(( *p & 255) != 0) {
            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                p =  &(p[1]);
                continue;
            }
            break;
        }
        if(value == 0) {
            if(( *p & 255) == 0 || ( *p & 255) == 13 || ( *p & 255) == 10 || ( *p & 255) == 59) {
                return 1;
            } else {
                goto L33;
            }
        }
         *value = Strnew();
        if(( *p & 255) != 61) {
L27:
            return 1;
        } else {
            p =  &(p[1]);
            while(( *p & 255) != 0) {
                if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                    p =  &(p[1]);
                    continue;
                }
                break;
            }
            quoted = 0;
            while(( *p & 255) != 0 && ( *p & 255) != 13 && ( *p & 255) != 10 && (quoted != 0 || ( *p & 255) != 59)) {
                if(( *p & 255) != 34) {
                    if( *value->length + 1 >=  *value->area_size) {
                        Strgrow( *value);
                    }
                    _t114 =  *value;
                    _t151 = _t114->length;
                     *((char*)( *( *value) + _t151)) =  *p & 255;
                    _t114->length = _t151 + 1;
                     *((char*)( *( *value) +  *value->length)) = 0;
                } else {
                    quoted = quoted == 0 & 255;
                }
                p =  &(p[1]);
            }
            if(q != 0) {
                Strshrink( *value, p - q - 1);
            }
            goto L27;
        }
    }
}

char* xface2xpm(char* xface)
{// addr = 0x0805B62E  --  defined in 'file.c' at line 548
    ImageCache* cache;   // _cfa_fffffff0
    FILE* f;              // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    short _v46;                            // _cfa_ffffffd2
    short _v48;                            // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    Image image;         // _cfa_ffffffc8
    _unknown_ _v100;                       // _cfa_ffffff9c
    struct stat st;       // _cfa_ffffff70
    intOrPtr _v164;                        // _cfa_ffffff5c (outparam)
    FILE* _v168;          // _cfa_ffffff58 (outparam)
    char* _t60;                            // _t60
    FILE* _t62;           // _t62
    FILE* _t64;           // _t64

    while(( *xface & 255) != 0) {
        if(( *( &MYCTYPE_MAP + ( *xface & 0xff)) & 2) != 0) {
            xface =  &(xface[1]);
            continue;
        }
        break;
    }
    image.url = xface;
    _v52 = ".xpm";
    _v48 = 48;
    _v46 = 48;
    _v24 = 0;
    cache = getImage( &image, 0, 2);
    if((cache->loaded & 1) == 0 || __stat(cache->file,  &(st.st_dev)) != 0) {
        cache->loaded = 2;
        _t60 = shell_quote(cache->file);
        _t62 = shell_quote(auxbinFile("xface2xpm"));
        _v164 = _t60;
        _v168 = _t62;
        _t64 =  *(Sprintf("%s > %s"));
        _v168 = 135041136;
         *__esp = _t64;
        popen();
        f = _t64;
        if(f != 0) {
            _v168 = f;
             *__esp = xface;
            fputs();
             *__esp = f;
            pclose();
            if(__stat(cache->file,  &(st.st_dev)) != 0 || st.st_size == 0) {
                return 0;
            } else {
                cache->loaded = 5;
                cache->index = 0;
                return cache->file;
            }
        }
        return 0;
    } else {
        return cache->file;
    }
}

void readHeader(URLFile* uf, Buffer* newBuf, int thru, ParsedURL* pu)
{// addr = 0x0805B7A0  --  defined in 'file.c' at line 582
    char c;                                // _cfa_fffffff3
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    char* emsg;                            // _cfa_ffffffe4
    Str lineBuf2;          // _cfa_ffffffe0
    Str tmp;               // _cfa_ffffffdc
    TextList* headerlist;   // _cfa_ffffffd8
    wc_ces charset;     // _cfa_ffffffd4
    wc_ces mime_charset;   // _cfa_ffffffd0
    char* tmpf;                            // _cfa_ffffffcc
    FILE* src;            // _cfa_ffffffc8
    Lineprop* propBuffer;   // _cfa_ffffffc4
    FILE* ff;             // _cfa_ffffffc0
    Str src;               // _cfa_ffffffbc
    Line* l;              // _cfa_ffffffb8
    wc_ces old_charset;   // _cfa_ffffffb4
    struct compression_decoder* d;   // _cfa_ffffffb0
    char** e;                              // _cfa_ffffffac
    Str name;              // _cfa_ffffffa8
    Str value;             // _cfa_ffffffa4
    Str domain;            // _cfa_ffffffa0
    Str path;              // _cfa_ffffff9c
    Str comment;           // _cfa_ffffff98
    Str commentURL;        // _cfa_ffffff94
    Str port;              // _cfa_ffffff90
    Str tmp2;              // _cfa_ffffff8c
    int version;                           // _cfa_ffffff88
    int quoted;                            // _cfa_ffffff84
    int flag;                              // _cfa_ffffff80
    time_t expires;     // _cfa_ffffff7c
    int err;                               // _cfa_ffffff78
    char* ans;                             // _cfa_ffffff74
    Str msg;               // _cfa_ffffff70
    Str funcname;          // _cfa_ffffff6c
    int f;                                 // _cfa_ffffff68
    URLFile f;         // _cfa_ffffff48
    _unknown_ _v196;                       // _cfa_ffffff3c (outparam)
    _unknown_ _v200;                       // _cfa_ffffff38 (outparam)
    _unknown_ _v204;                       // _cfa_ffffff34 (outparam)
    _unknown_ _v208;                       // _cfa_ffffff30 (outparam)
    _unknown_ _v212;                       // _cfa_ffffff2c (outparam)
    _unknown_ _v216;                       // _cfa_ffffff28 (outparam)
    Linecolor* _v220;   // _cfa_ffffff24 (outparam)
    Linecolor* _v224;   // _cfa_ffffff20 (outparam)
    char* _v228;                           // _cfa_ffffff1c (outparam)
    char* _v232;                           // _cfa_ffffff18 (outparam)
    _unknown_ __ebx;                       // r1
    char* _t667;                           // _t667
    char* _t669;                           // _t669
    char* _t672;                           // _t672
    int _t722;                             // _t722
    char* _t734;                           // _t734
    signed int _t766;                      // _t766
    int _t804;                             // _t804
    char* _t809;                           // _t809
    char* _t836;                           // _t836
    char* _t880;                           // _t880
    int _t928;                             // _t928
    int _t960;                             // _t960
    char* _t971;                           // _t971
    char* _t989;                           // _t989
    char* _t990;                           // _t990
    char* _t1006;                          // _t1006
    char* _t1007;                          // _t1007
    char* _t1008;                          // _t1008
    char* _t1010;                          // _t1010
    int _t1027;                            // _t1027
    wc_ces* _t1049;     // _t1049
    int _t1070;                            // _t1070
    int _t1080;                            // _t1080
    _unknown_ _t1081;                      // _t1081
    char* _t1091;                          // _t1091
    char* _t1093;                          // _t1093
    char* _t1114;                          // _t1114
    char* _t1122;                          // _t1122
    FILE* _t1136;         // _t1136
    FILE* _t1151;         // _t1151
    unsigned int _t1205;                   // _t1205
    int _t1215;                            // _t1215

    lineBuf2 = 0;
    charset = 256;
    src = 0;
    newBuf->document_header = newGeneralList();
    headerlist = newBuf->document_header;
    if((uf->scheme & 255) != 0) {
        http_response_code = 0;
    } else {
        http_response_code = -1;
    }
    if(thru != 0) {
        if(newBuf->header_source == 0) {
            if(image_source == 0) {
                tmpf =  *(tmpfname(0, 0));
                _t1151 = tmpf;
                _v232 = 135041136;
                 *__esp = _t1151;
                fopen();
                src = _t1151;
                if(src != 0) {
                    newBuf->header_source = tmpf;
                }
            }
        }
    }
    while(1) {
L261:
        tmp = StrmyISgets(uf->stream);
        if(tmp->length != 0) {
            if((uf->scheme & 255) == 9) {
                if(( *(tmp->ptr) & 255) == 46) {
                    Strdelete(tmp, 0, 1);
                }
            }
            if(w3m_reqlog != 0) {
                _t1136 = w3m_reqlog;
                _v232 = 135041138;
                 *__esp = _t1136;
                fopen();
                ff = _t1136;
                _v224 = ff;
                _v228 = tmp->length;
                _v232 = 1;
                 *__esp = tmp->ptr;
                fwrite();
                 *__esp = ff;
                fclose();
            }
            if(src != 0) {
                _v224 = src;
                _v228 = tmp->length;
                _v232 = 1;
                 *__esp = tmp->ptr;
                fwrite();
            }
        } else {
            break;
        }
        cleanup_line(tmp, 3);
        if((tmp & 255) == 10 || (tmp & 255) == 13 || (tmp & 255) == 0) {
            if(lineBuf2 != 0) {
                goto L74;
            } else {
                break;
            }
        } else {
            if((w3m_dump & 2) != 0) {
                lineBuf2 = tmp;
L74:
                if((uf->scheme & 255) != 0 || http_response_code != -1) {
L87:
                    _t667 = lineBuf2->ptr;
                    _v228 = 26;
                    _v232 = "content-transfer-encoding:";
                     *__esp = _t667;
                    strncasecmp();
                    if(_t667 != 0) {
                        _t669 = lineBuf2->ptr;
                        _v228 = 17;
                        _v232 = "content-encoding:";
                         *__esp = _t669;
                        strncasecmp();
                        if(_t669 != 0) {
                            if(use_cookie == 0 || accept_cookie == 0 || pu == 0 || check_cookie_accept_domain(pu->host) == 0) {
L229:
                                _t672 = lineBuf2->ptr;
                                _v228 = 12;
                                _v232 = "w3m-control:";
                                 *__esp = _t672;
                                strncasecmp();
                                if(_t672 != 0 || (uf->scheme & 255) != 5) {
                                    goto L252;
                                } else {
                                    funcname = Strnew();
                                    p =  &(12[lineBuf2->ptr]);
                                    while(( *p & 255) != 0) {
                                        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                                            p =  &(p[1]);
                                            continue;
                                        }
L240:
                                        while(( *p & 255) != 0) {
                                            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
                                                if(funcname->length + 1 >= funcname->area_size) {
                                                    Strgrow(funcname);
                                                }
                                                _t722 = funcname->length;
                                                 *((char*)(funcname->ptr + _t722)) =  *p & 255;
                                                funcname->length = _t722 + 1;
                                                p =  &(p[1]);
                                                 *((char*)(funcname->ptr + funcname->length)) = 0;
                                                continue;
                                            }
L244:
                                            while(( *p & 255) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                                                p =  &(p[1]);
                                            }
                                            f = getFuncList(funcname->ptr);
                                            if(f >= 0) {
                                                tmp = Strnew_charp(p);
                                                Strchop(tmp);
                                                pushEvent(f, tmp->ptr);
                                            }
                                            goto L252;
                                        }
                                        goto L244;
                                    }
                                    goto L240;
                                }
                            } else {
                                _t734 = lineBuf2->ptr;
                                _v228 = 11;
                                _v232 = "Set-Cookie:";
                                 *__esp = _t734;
                                strncasecmp();
                                if(_t734 == 0) {
L121:
                                    name = Strnew();
                                    value = Strnew();
                                    domain = 0;
                                    path = 0;
                                    comment = 0;
                                    commentURL = 0;
                                    port = 0;
                                    flag = 0;
                                    expires = -1;
                                    q = 0;
                                    if(( *(lineBuf2->ptr + 10) & 255) != 50) {
                                        p =  &(11[lineBuf2->ptr]);
                                        version = 0;
                                    } else {
                                        p =  &(12[lineBuf2->ptr]);
                                        version = 1;
                                    }
                                    while(( *p & 255) != 0) {
                                        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                                            p =  &(p[1]);
                                            continue;
                                        }
L132:
                                        while(( *p & 255) != 61 && ( *p & 255) != 0 && ( *p & 255) != 13 && ( *p & 255) != 10 && ( *p & 255) != 59) {
                                            if(name->length + 1 >= name->area_size) {
                                                Strgrow(name);
                                            }
                                            _t960 = name->length;
                                             *((char*)(name->ptr + _t960)) =  *p & 255;
                                            name->length = _t960 + 1;
                                            p =  &(p[1]);
                                             *((char*)(name->ptr + name->length)) = 0;
                                        }
                                        Strremovetrailingspaces(name);
                                        if(( *p & 255) != 61) {
L193:
                                            while(( *p & 255) == 59) {
                                                p =  &(p[1]);
                                                while(( *p & 255) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                                                    p =  &(p[1]);
                                                }
                                                if(matchattr(p, "expires", 7,  &tmp2) == 0) {
                                                    _t766 = matchattr(p, "max-age", 7,  &tmp2);
                                                    if(_t766 == 0) {
                                                        if(matchattr(p, "domain", 6,  &tmp2) == 0) {
                                                            if(matchattr(p, "path", 4,  &tmp2) == 0) {
                                                                if(matchattr(p, "secure", 6, 0) == 0) {
                                                                    if(matchattr(p, "comment", 7,  &tmp2) == 0) {
                                                                        if(matchattr(p, "version", 7,  &tmp2) == 0) {
                                                                            if(matchattr(p, "port", 4,  &tmp2) == 0) {
                                                                                if(matchattr(p, "commentURL", 10,  &tmp2) == 0) {
                                                                                    if(matchattr(p, "discard", 7, 0) != 0) {
                                                                                        flag = flag | 16;
                                                                                    }
                                                                                } else {
                                                                                    commentURL = tmp2;
                                                                                }
                                                                            } else {
                                                                                port = tmp2;
                                                                            }
                                                                        } else {
                                                                            _t804 = tmp2->ptr;
                                                                             *__esp = _t804;
                                                                            atoi();
                                                                            version = _t804;
                                                                        }
                                                                    } else {
                                                                        comment = tmp2;
                                                                    }
                                                                } else {
                                                                    flag = flag | 2;
                                                                }
                                                            } else {
                                                                path = tmp2;
                                                            }
                                                        } else {
                                                            domain = tmp2;
                                                        }
                                                    } else {
                                                         *__esp = 0;
                                                        time();
                                                        _t809 = tmp2->ptr;
                                                         *__esp = _t809;
                                                        atol();
                                                        expires =  &(_t809[_t766]);
                                                    }
                                                } else {
                                                    expires = mymktime(tmp2->ptr);
                                                }
                                                quoted = 0;
                                                while(( *p & 255) != 0 && ( *p & 255) != 13 && ( *p & 255) != 10) {
                                                    if(quoted != 0 || ( *p & 255) != 59) {
                                                        if(( *p & 255) == 34) {
                                                            quoted = quoted == 0 & 255;
                                                        }
                                                        p =  &(p[1]);
                                                        continue;
                                                    } else {
                                                        goto L193;
                                                    }
                                                }
                                            }
                                            if(pu == 0) {
L252:
                                                if(headerlist != 0) {
                                                    pushValue(headerlist, allocStr(lineBuf2->ptr, -1));
                                                }
                                                Strfree(lineBuf2);
                                                lineBuf2 = 0;
                                                goto L261;
                                            }
                                            if(name->length <= 0) {
                                                goto L252;
                                            }
                                            if(show_cookie != 0) {
                                                if((flag & 2) == 0) {
                                                    _v228 = value->ptr;
                                                    _v232 = name->ptr;
                                                    disp_message_nsec( *(Sprintf("Received cookie: %s=%s")), 0, 1, 1, 0);
                                                } else {
                                                    disp_message_nsec("Received a secured cookie", 0, 1, 1, 0);
                                                }
                                            }
                                            err = add_cookie(pu, name, value, expires, domain, path, flag, comment, version, port, commentURL);
                                            if(err == 0) {
                                                goto L252;
                                            } else {
                                                if(accept_bad_cookie != 1) {
                                                    _t836 = 0;
                                                } else {
                                                    _t836 = 135041483;
                                                }
                                                ans = _t836;
                                                if((fmInitialized & 255) != 0 && (err & 32) != 0 && accept_bad_cookie == 2) {
                                                    if(domain == 0 || domain->ptr == 0) {
                                                        _t880 = "<localdomain>";
                                                    } else {
                                                        _t880 = domain->ptr;
                                                    }
                                                    _v228 = _t880;
                                                    _v232 = pu->host;
                                                    msg = Sprintf("Accept bad cookie from %s for %s?");
                                                    if(msg->length > COLS - 10) {
                                                        Strshrink(msg, msg->length + 10 - COLS);
                                                    }
                                                    Strcat_charp(msg, " (y/n)");
                                                    ans = inputAnswer(msg->ptr);
                                                }
                                                if(ans == 0) {
L220:
                                                    err = (err & -33) - 1;
                                                    if(err < 0 || err > 8) {
                                                        emsg = "This cookie was rejected to prevent security violation.";
                                                    } else {
                                                        _v232 =  *( &violations + err * 4);
                                                        emsg =  *(Sprintf("This cookie was rejected to prevent security violation. [%s]"));
                                                    }
                                                    record_err_message(emsg);
                                                    if(show_cookie != 0) {
                                                        disp_message_nsec(emsg, 0, 1, 1, 0);
                                                    }
                                                    goto L252;
                                                } else {
                                                    if(( *( &MYCTYPE_MAP + ( *ans & 0xff)) & 4) == 0) {
                                                        if(( *ans & 255) != 121) {
                                                            goto L220;
                                                        }
L219:
                                                        err = add_cookie(pu, name, value, expires, domain, path, flag | 32, comment, version, port, commentURL);
                                                        if(err == 0) {
                                                            if(show_cookie != 0) {
                                                                _v228 = value->ptr;
                                                                _v232 = name->ptr;
                                                                disp_message_nsec( *(Sprintf("Accepting invalid cookie: %s=%s")), 0, 1, 1, 0);
                                                            }
                                                            goto L252;
                                                        }
                                                        goto L220;
                                                    }
                                                    if(( *ans & 255 | 32) != 121) {
                                                        goto L220;
                                                    }
                                                    goto L219;
                                                }
                                            }
                                        }
                                        p =  &(p[1]);
                                        while(( *p & 255) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                                            p =  &(p[1]);
                                        }
                                        quoted = 0;
                                        while(( *p & 255) != 0 && ( *p & 255) != 13 && ( *p & 255) != 10 && (quoted != 0 || ( *p & 255) != 59)) {
                                            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
                                                q = p;
                                            }
                                            if(( *p & 255) == 34) {
                                                quoted = quoted == 0 & 255;
                                            }
                                            if(value->length + 1 >= value->area_size) {
                                                Strgrow(value);
                                            }
                                            _t928 = value->length;
                                             *((char*)(value->ptr + _t928)) =  *p & 255;
                                            value->length = _t928 + 1;
                                            p =  &(p[1]);
                                             *((char*)(value->ptr + value->length)) = 0;
                                        }
                                        if(q != 0) {
                                            Strshrink(value, p - q - 1);
                                        }
                                        goto L193;
                                    }
                                    goto L132;
                                }
                                _t971 = lineBuf2->ptr;
                                _v228 = 12;
                                _v232 = "Set-Cookie2:";
                                 *__esp = _t971;
                                strncasecmp();
                                if(_t971 != 0) {
                                    goto L229;
                                }
                                goto L121;
                            }
                        }
                        p =  &(17[lineBuf2->ptr]);
                        while(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                            p =  &(p[1]);
                        }
                        uf->compression = 0;
                        d =  &compression_decoders;
                        while(d->type != 0) {
                            e =  &(d->encodings);
                            while( *e != 0) {
                                _t989 =  *e;
                                 *__esp = _t989;
                                strlen();
                                _v228 = _t989;
                                _v232 =  *e;
                                _t990 = p;
                                 *__esp = _t990;
                                strncasecmp();
                                if(_t990 != 0) {
                                    e =  &(e[1]);
                                    continue;
                                }
                                uf->compression = d->type;
                                break;
                            }
                            if(uf->compression != 0) {
L114:
                                uf->content_encoding = uf->compression;
                                goto L252;
                            }
                            d = d + 44;
                        }
                        goto L114;
                    }
                    p =  &(26[lineBuf2->ptr]);
                    while(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                        p =  &(p[1]);
                    }
                    _v228 = 6;
                    _v232 = "base64";
                    _t1006 = p;
                     *__esp = _t1006;
                    strncasecmp();
                    if(_t1006 != 0) {
                        _v228 = 16;
                        _v232 = "quoted-printable";
                        _t1007 = p;
                         *__esp = _t1007;
                        strncasecmp();
                        if(_t1007 != 0) {
                            _v228 = 8;
                            _v232 = "uuencode";
                            _t1008 = p;
                             *__esp = _t1008;
                            strncasecmp();
                            if(_t1008 == 0) {
L97:
                                uf->encoding = 3;
                                goto L252;
                            }
                            _v228 = 10;
                            _v232 = "x-uuencode";
                            _t1010 = p;
                             *__esp = _t1010;
                            strncasecmp();
                            if(_t1010 != 0) {
                                uf->encoding = 0;
                                goto L252;
                            }
                            goto L97;
                        }
                        uf->encoding = 2;
                        goto L252;
                    }
                    uf->encoding = 1;
                    goto L252;
                } else {
                    p = lineBuf2->ptr;
                    while(( *p & 255) != 0) {
                        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
                            p =  &(p[1]);
                            continue;
                        } else {
                            do {
L83:
                            } while(( *p & 255) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0);
                            _t1027 = p;
                             *__esp = _t1027;
                            atoi();
                            http_response_code = _t1027;
                            if((fmInitialized & 255) != 0) {
                                message(lineBuf2->ptr, 0, 0);
                                refresh();
                            }
                            goto L87;
                        }
                    }
                    goto L83;
                }
            } else {
                if(lineBuf2 == 0) {
                    lineBuf2 = tmp;
                } else {
                    Strcat(lineBuf2, tmp);
                }
                c = ISgetc(uf->stream);
                ISundogetc(uf->stream);
                if(c == 32) {
                    continue;
                }
                if(c == 9) {
                    continue;
                } else {
                    lineBuf2 = decodeMIME(lineBuf2,  &mime_charset);
                    if(mime_charset == 0) {
                        _t1205 = DocumentCharset;
                    } else {
                        _t1205 = mime_charset;
                    }
                    if(mime_charset == 0) {
                        _t1049 =  &charset;
                    } else {
                        _t1049 =  &mime_charset;
                    }
                    lineBuf2 = convertLine(0, lineBuf2, 0, _t1049, _t1205);
                    tmp = Strnew_size(lineBuf2->length);
                    p = lineBuf2->ptr;
                    while(( *p & 255) != 0) {
                        while(( *q & 255) != 0 && ( *q & 255) != 13) {
                            if(( *q & 255) != 10) {
                                q =  &(q[1]);
                                continue;
                            }
                            break;
                        }
                        lineBuf2 = checkType(Strnew_charp_n(p, q - p),  &propBuffer, 0);
                        Strcat(tmp, lineBuf2);
                        if(thru != 0) {
                            if(FoldLine == 0) {
                                _t1070 = -1;
                            } else {
                                _t1215 = COLS;
                                if(showLineNum == 0) {
                                    _t1080 = 1;
                                } else {
                                    _t1080 = 6;
                                }
                                _t1081 = _t1215 - _t1080;
                                _t1082 = _t1081 < 0 ? 0 : _t1081;
                                _t1070 = (_t1081 < 0 ? 0 : _t1081) + 1;
                            }
                            addnewline(newBuf, lineBuf2->ptr, propBuffer, 0, lineBuf2->length, _t1070, -1);
                        }
                        goto L48;
                        do {
                        } while();
                        continue;
L48:
                        if(( *q & 255) == 0 || ( *q & 255) != 13 && ( *q & 255) != 10) {
                            p = q;
                        } else {
                            q =  &(q[1]);
                            goto L48;
                        }
                    }
                    if(thru == 0 || activeImage == 0 || displayImage == 0) {
L71:
                        lineBuf2 = tmp;
                        goto L74;
                    } else {
                        src = 0;
                        _t1091 = tmp->ptr;
                        _v228 = 12;
                        _v232 = "X-Image-URL:";
                         *__esp = _t1091;
                        strncasecmp();
                        if(_t1091 != 0) {
                            _t1093 = tmp->ptr;
                            _v228 = 7;
                            _v232 = "X-Face:";
                             *__esp = _t1093;
                            strncasecmp();
                            if(_t1093 == 0) {
                                tmpf = xface2xpm( &(tmp->ptr[7]));
                                if(tmpf != 0) {
                                    _t1114 = html_quote(tmpf);
                                    _v220 = 0;
                                    _v224 = " width=48 height=48>";
                                    _v228 = "" alt="X-Face"";
                                    _v232 = _t1114;
                                    src = Strnew_m_charp("<img src="file:");
                                }
                            }
L65:
                            if(src != 0) {
                                old_charset = newBuf->document_charset;
                                init_stream( &f, 4, newStrStream(src));
                                loadHTMLstream( &f, newBuf, 0, 1);
                                l = newBuf->lastLine;
                                goto L68;
                                do {
                                } while();
                                goto L71;
L68:
                                if(l == 0 || l->real_linenumber == 0) {
                                    newBuf->document_charset = old_charset;
                                } else {
                                    l->real_linenumber = 0;
                                    l = l->prev;
                                    goto L68;
                                }
                            }
                            goto L71;
                        } else {
                            tmpf =  &(tmp->ptr[0xc]);
                            goto L59;
                            do {
                            } while();
                            goto L65;
L59:
                            if(( *tmpf & 255) == 0 || ( *( &MYCTYPE_MAP + ( *tmpf & 0xff)) & 2) == 0) {
                                _t1122 = html_quote(tmpf);
                                _v224 = 0;
                                _v228 = "" alt="X-Image-URL">";
                                _v232 = _t1122;
                                src = Strnew_m_charp("<img src="");
                            } else {
                                tmpf =  &(tmpf[1]);
                                goto L59;
                            }
                            goto L65;
                        }
                    }
                }
            }
        }
    }
    if(thru != 0) {
        addnewline(newBuf, 135041709, propBuffer, 0, 0, -1, -1);
    }
    if(src == 0) {
        return;
    } else {
         *__esp = src;
        fclose();
        return;
    }
}

char* checkHeader(Buffer* buf, char* field)
{// addr = 0x0805CB59  --  defined in 'file.c' at line 927
    int len;                               // _cfa_fffffff0
    TextListItem* i;   // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    int _v36;                              // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    int _t27;                              // _t27
    char* _t32;                            // _t32

    if(buf == 0 || field == 0 || buf->document_header == 0) {
        return 0;
    }
    _t27 = field;
     *__esp = _t27;
    strlen();
    len = _t27;
    i = buf->document_header->first;
    while(i != 0) {
        _t32 = i->ptr;
        _v36 = len;
        _v40 = field;
         *__esp = _t32;
        strncasecmp();
        if(_t32 != 0) {
            i = i->next;
            continue;
        }
        p =  &(i->ptr[len]);
        return remove_space(p);
    }
    return 0;
}

char* checkContentType(Buffer* buf)
{// addr = 0x0805CBED  --  defined in 'file.c' at line 946
    char* p;                               // _cfa_fffffff0
    Str r;                 // _cfa_ffffffec
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    char* _t59;                            // _t59
    int _t98;                              // _t98

    p = checkHeader(buf, "Content-Type:");
    if(p == 0) {
        return 0;
    }
    r = Strnew();
    while(( *p & 255) != 0 && ( *p & 255) != 59 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
        if(r->length + 1 >= r->area_size) {
            Strgrow(r);
        }
        _t98 = r->length;
         *((char*)(r->ptr + _t98)) =  *p & 255;
        r->length = _t98 + 1;
        p =  &(p[1]);
         *((char*)(r->ptr + r->length)) = 0;
    }
    _v40 = "charset";
    _t59 = p;
     *__esp = _t59;
    strcasestr();
    p = _t59;
    if(p == 0) {
L22:
        return r->ptr;
    }
    p =  &(p[7]);
    while(( *p & 255) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
        p =  &(p[1]);
    }
    if(( *p & 255) != 61) {
        goto L22;
    }
    p =  &(p[1]);
    while(( *p & 255) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
        p =  &(p[1]);
    }
    if(( *p & 255) == 34) {
        p =  &(p[1]);
    }
    content_charset = wc_guess_charset(p, 0);
    goto L22;
}

int skip_auth_token(char** pp)
{// addr = 0x0805CD5B  --  defined in 'file.c' at line 992
    char* p;                               // _cfa_fffffff8
    int first;                             // _cfa_fffffff4
    int typ;                               // _cfa_fffffff0

    first = 0;
    p =  *pp;
    while(( *p & 255) > 127) {
        if(( *p & 255) <= 31) {
            typ = 1;
        } else {
            typ = 2;
        }
        if(first == 0) {
            first = typ;
L9:
            p =  &(p[1]);
            continue;
        }
        if(first == typ) {
            goto L9;
        }
         *pp = p;
        return first;
    }
    goto __eax;
}

Str extract_auth_val(char** q)
{// addr = 0x0805CDCE  --  defined in 'file.c' at line 1040
    unsigned char* qq;                     // _cfa_fffffff0
    int quoted;                            // _cfa_ffffffec
    Str val;               // _cfa_ffffffe8
    int _t117;                             // _t117
    int _t131;                             // _t131
    int _t146;                             // _t146
    int _t172;                             // _t172

    qq =  *q;
    quoted = 0;
    val = Strnew();
    while(( *qq & 255) != 0) {
        if(( *( &MYCTYPE_MAP + ( *qq & 0xff)) & 2) != 0) {
            qq =  &(qq[1]);
            continue;
        }
        break;
    }
    if(( *qq & 255) == 34) {
        quoted = 1;
        if(val->length + 1 >= val->area_size) {
            Strgrow(val);
        }
        _t117 = val->length;
         *((char*)(val->ptr + _t117)) =  *qq & 255;
        val->length = _t117 + 1;
        qq =  &(qq[1]);
         *((char*)(val->ptr + val->length)) = 0;
    }
    while(( *qq & 255) != 0) {
        if(quoted == 0 || ( *qq & 255) != 34) {
            if(quoted != 0) {
                if(quoted != 0 && ( *qq & 255) == 92) {
                    if(val->length + 1 >= val->area_size) {
                        Strgrow(val);
                    }
                    _t146 = val->length;
                     *((char*)(val->ptr + _t146)) =  *qq & 255;
                    val->length = _t146 + 1;
                    qq =  &(qq[1]);
                     *((char*)(val->ptr + val->length)) = 0;
                }
L24:
                if(val->length + 1 >= val->area_size) {
                    Strgrow(val);
                }
                _t131 = val->length;
                 *((char*)(val->ptr + _t131)) =  *qq & 255;
                val->length = _t131 + 1;
                qq =  &(qq[1]);
                 *((char*)(val->ptr + val->length)) = 0;
                continue;
            }
            if(( *qq & 0xff) - 9 > 84) {
                if(( *qq & 255) <= 31 || ( *qq & 255) == 127) {
                    qq =  &(qq[1]);
                    goto L30;
                } else {
                    goto L24;
                }
            }
            goto __eax;
        } else {
            if(val->length + 1 >= val->area_size) {
                Strgrow(val);
            }
            _t172 = val->length;
             *((char*)(val->ptr + _t172)) =  *qq & 255;
            val->length = _t172 + 1;
            qq =  &(qq[1]);
             *((char*)(val->ptr + val->length)) = 0;
L30:
             *q = qq;
            return val;
        }
    }
    goto L30;
}

Str qstr_unquote(Str s)
{// addr = 0x0805D007  --  defined in 'file.c' at line 1094
    char* p;                               // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t57;                              // _t57

    if(s != 0) {
        p = s->ptr;
        if(( *p & 255) != 34) {
            return s;
        }
        tmp = Strnew();
        p =  &(p[1]);
        while(( *p & 255) != 0) {
            if(( *p & 255) == 92) {
                p =  &(p[1]);
            }
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t57 = tmp->length;
             *((char*)(tmp->ptr + _t57)) =  *p & 255;
            tmp->length = _t57 + 1;
             *((char*)(tmp->ptr + tmp->length)) = 0;
            p =  &(p[1]);
        }
        if(tmp->length > 0 && ( *(tmp->ptr + tmp->length - 1) & 255) == 34) {
            Strshrink(tmp, 1);
        }
        return tmp;
    }
    return 0;
}

char* extract_auth_param(char* q, struct auth_param* auth)
{// addr = 0x0805D0EB  --  defined in 'file.c' at line 1117
    struct auth_param* ap;   // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    size_t len;         // _cfa_ffffffe8
    int token_type;                        // _cfa_ffffffe4
    intOrPtr _v36;                         // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    unsigned int _t88;                     // _t88
    char* _t90;                            // _t90

    ap = auth;
    do {
    } while(ap->name != 0);
    while(( *q & 255) != 0) {
        while(( *q & 255) != 0) {
            if(( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) != 0) {
                q =  &(q[1]);
                continue;
            }
            break;
        }
        ap = auth;
        while(ap->name != 0) {
            _t88 = ap->name;
             *__esp = _t88;
            strlen();
            len = _t88;
            _t90 = q;
            _v36 = len;
            _v40 = ap->name;
             *__esp = _t90;
            strncasecmp();
            if(_t90 != 0 || ( *( &MYCTYPE_MAP + (q[len] & 0xff)) & 2) == 0 && (q[len] & 255) != 61) {
                ap = ap + 8;
                continue;
            } else {
                p =  &(q[len]);
                while(( *p & 255) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                    p =  &(p[1]);
                }
                if(( *p & 255) == 61) {
                    q =  &(p[1]);
                    ap->val = extract_auth_val( &q);
                    break;
                }
                return q;
            }
        }
        if(ap->name != 0) {
L32:
            if(( *q & 255) == 0) {
                continue;
            }
            while(( *q & 255) != 0 && ( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) != 0) {
                q =  &(q[1]);
            }
            if(( *q & 255) != 44) {
L42:
                return q;
            }
            q =  &(q[1]);
            continue;
        }
        p = q;
        token_type = skip_auth_token( &q);
        if(token_type != 2) {
L31:
            return p;
        }
        if(( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) != 0) {
L26:
            while(( *q & 255) != 0 && ( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) != 0) {
                q =  &(q[1]);
            }
            if(( *q & 255) == 61) {
                q =  &(q[1]);
                extract_auth_val( &q);
                goto L32;
            }
            return p;
        }
        if(( *q & 255) != 61) {
            goto L31;
        }
        goto L26;
    }
    goto L42;
}

Str get_auth_param(struct auth_param* auth, char* name)
{// addr = 0x0805D322  --  defined in 'file.c' at line 1170
    struct auth_param* ap;   // _cfa_fffffff0
    char* _v40;                            // _cfa_ffffffd8
    char* _t16;                            // _t16

    ap = auth;
    while(ap->name != 0) {
        _v40 = ap->name;
        _t16 = name;
         *__esp = _t16;
        strcasecmp();
        if(_t16 != 0) {
            ap = ap + 8;
            continue;
        }
        return ap->val;
    }
    return 0;
}

Str AuthBasicCred(struct http_auth* ha, Str uname, Str pw, ParsedURL* pu, HRequest* hr, FormList* request)
{// addr = 0x0805D364  --  defined in 'file.c' at line 1181
    Str s;                 // _cfa_fffffff0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    int _t34;                              // _t34
    intOrPtr* _t44;                        // _t44

    s = Strdup(uname);
    if(s->length + 1 >= s->area_size) {
        Strgrow(s);
    }
    _t34 = s->length;
     *((char*)(s->ptr + _t34)) = 58;
    s->length = _t34 + 1;
     *((char*)(s->ptr + s->length)) = 0;
    Strcat(s, pw);
    _t44 = encodeB(s->ptr);
    _v36 = 0;
    _v40 =  *_t44;
    return Strnew_m_charp("Basic ");
}

struct http_auth* findAuthentication(struct http_auth* hauth, Buffer* buf, char* auth_field)
{// addr = 0x0805D3FE  --  defined in 'file.c' at line 1469
    struct http_auth* ha;   // _cfa_fffffff0
    int len;                               // _cfa_ffffffec
    int slen;                              // _cfa_ffffffe8
    TextListItem* i;   // _cfa_ffffffe4
    char* p0;                              // _cfa_ffffffe0
    char* p;                               // _cfa_ffffffdc
    int token_type;                        // _cfa_ffffffd8
    int _v52;                              // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    int _t89;                              // _t89
    char* _t95;                            // _t95
    int _t114;                             // _t114
    char* _t116;                           // _t116
    struct http_auth* _t126;   // _t126
    struct http_auth* _t177;   // _t177

    _t89 = auth_field;
     *__esp = _t89;
    strlen();
    len = _t89;
    _v56 = 16;
     *__esp = hauth;
    bzero();
    i = buf->document_header->first;
    while(i != 0) {
        _t95 = i->ptr;
        _v52 = len;
        _v56 = auth_field;
         *__esp = _t95;
        strncasecmp();
        if(_t95 != 0) {
L27:
            i = i->next;
            continue;
        } else {
            p =  &(i->ptr[len]);
            while(p != 0 && ( *p & 255) != 0) {
                while(( *p & 255) != 0) {
                    if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                        p =  &(p[1]);
                        continue;
                    }
                    break;
                }
                p0 = p;
                ha =  &www_auth;
                while(ha->scheme != 0) {
                    _t114 = ha->scheme;
                     *__esp = _t114;
                    strlen();
                    slen = _t114;
                    _t116 = p;
                    _v52 = slen;
                    _v56 = ha->scheme;
                     *__esp = _t116;
                    strncasecmp();
                    if(_t116 != 0) {
L15:
                        ha = ha + 16;
                        continue;
                    } else {
                        p =  &(p[slen]);
                        while(( *p & 255) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                            p =  &(p[1]);
                        }
                        if(hauth->pri >= ha->pri) {
                            p = extract_auth_param(p,  &none_auth_param);
                            goto L15;
                        }
                        _t126 = hauth;
                        _t177 = ha;
                        _t126->pri = _t177->pri;
                        _t126->scheme = _t177->scheme;
                        _t126->param = _t177->param;
                        _t126->cred = _t177->cred;
                        p = extract_auth_param(p, hauth->param);
                        break;
                    }
                }
                if(p0 != p) {
                    continue;
                }
                token_type = skip_auth_token( &p);
                if(token_type != 2 || ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
                    goto L27;
                } else {
                    while(( *p & 255) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                        p =  &(p[1]);
                    }
                    p = extract_auth_param(p,  &none_auth_param);
                    continue;
                }
            }
            goto L27;
        }
    }
    if(hauth->scheme == 0) {
        return 0;
    }
    return hauth;
}

void getAuthCookie(struct http_auth* hauth, char* auth_header, TextList* extra_header, ParsedURL* pu, HRequest* hr, FormList* request, _None* uname, _None* pwd)
{// addr = 0x0805D642  --  defined in 'file.c' at line 1515
    Str ss;                // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    TextListItem* i;   // _cfa_ffffffe8
    int a_found;                           // _cfa_ffffffe4
    int auth_header_len;                   // _cfa_ffffffe0
    char* realm;                           // _cfa_ffffffdc
    int proxy;                             // _cfa_ffffffd8
    char* pp;                              // _cfa_ffffffd4
    FormList* _v56;   // _cfa_ffffffc8
    HRequest* _v60;   // _cfa_ffffffc4 (outparam)
    char* _v64;                            // _cfa_ffffffc0 (outparam)
    char* _v68;                            // _cfa_ffffffbc (outparam)
    char* _v72;                            // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    int _t123;                             // _t123
    char* _t127;                           // _t127
    char* _t131;                           // _t131
    FILE* _t138;          // _t138
    char* _t140;                           // _t140
    char* _t146;                           // _t146
    struct _Str* _t152;   // _t152
    struct _Str* _t155;   // _t155
    _Unknown_base* _t160;                  // _t160
    FILE* _t161;          // _t161

    ss = 0;
    _t123 = auth_header;
     *__esp = _t123;
    strlen();
    auth_header_len = _t123;
    realm = 0;
    if(hauth != 0) {
        realm =  *(qstr_unquote(get_auth_param(hauth->param, "realm")));
    }
    if(realm == 0) {
        return;
    }
    a_found = 0;
    i = extra_header->first;
    while(i != 0) {
        _t127 = i->ptr;
        _v68 = auth_header_len;
        _v72 = auth_header;
         *__esp = _t127;
        strncasecmp();
        if(_t127 != 0) {
            i = i->next;
            continue;
        } else {
            a_found = 1;
        }
        break;
    }
    _v68 = auth_header_len;
    _t131 = auth_header;
    _v72 = _t131;
     *__esp = "Proxy-Authorization:";
    strncasecmp();
    proxy = _t131 == 0 & 255;
    if(a_found != 0) {
        if((fmInitialized & 255) == 0) {
            _v64 = __imp__stderr;
            _v68 = 27;
            _v72 = 1;
             *__esp = "Wrong username or password\n";
            fwrite();
        } else {
            message("Wrong username or password", 0, 0);
            refresh();
        }
         *__esp = 1;
        sleep();
        delValue(extra_header, i);
        invalidate_auth_user_passwd(pu, realm,  *uname,  *pwd, proxy);
    }
     *uname = 0;
     *pwd = 0;
    if(a_found == 0 && find_auth_user_passwd(pu, realm, uname, pwd, proxy) != 0) {
L31:
        _v56 = request;
        _v60 = hr;
        _v64 = pu;
        _v68 =  *pwd;
        _v72 =  *uname;
        _t152 = hauth;
         *__esp = _t152;
        hauth();
        ss = _t152;
        if(ss == 0) {
             *uname = 0;
             *pwd = 0;
            return;
        }
        _t155 = auth_header;
        Strnew_charp(_t155);
        tmp = _t155;
        _v60 = 0;
        _v64 = "\n";
        _v68 = ss->ptr;
        _v72 = " ";
        Strcat_m_charp(tmp);
        _t160 = tmp->ptr;
        allocStr(_t160, -1);
        pushValue(extra_header, _t160);
        return;
    }
    if((QuietMessage & 255) != 0) {
        return;
    }
     *__esp = 2;
    sleep();
    if((fmInitialized & 255) == 0) {
        _t138 = __imp__stdin;
         *__esp = _t138;
        feof();
        if(_t138 != 0) {
L23:
            _v68 = realm;
            _v72 = "w3m: Authorization required for %s\n";
             *__esp = __imp__stderr;
            fprintf();
             *__esp = 1;
            exit();
L24:
            if(proxy == 0) {
                _t140 = "Username for %s: ";
            } else {
                _t140 = "Proxy Username for %s: ";
            }
            _v72 = realm;
             *__esp = _t140;
            printf();
             *__esp = __imp__stdout;
            fflush();
             *uname = Strfgets(__imp__stdin);
            Strchop( *uname);
            if(proxy == 0) {
                _t146 = "Password: ";
            } else {
                _t146 = "Proxy Password: ";
            }
             *__esp = _t146;
            getpass();
             *pwd = Strnew_charp(_t146);
            goto L31;
        }
        _t161 = __imp__stdin;
         *__esp = _t161;
        ferror();
        if(_t161 == 0) {
            goto L24;
        }
        goto L23;
    }
    term_raw();
    _v72 = realm;
    pp = inputLineHistSearch( *(Sprintf("Username for %s: ")), 0, 16, 0, 0);
    if(pp != 0) {
         *uname = wc_Str_conv_strict(Strnew_charp(pp), InnerCharset, SystemCharset);
        _v72 = realm;
        pp = inputLineHistSearch( *(Sprintf("Password for %s: ")), 0, 64, 0, 0);
        if(pp != 0) {
             *pwd = wc_Str_conv_strict(Strnew_charp(pp), InnerCharset, SystemCharset);
            term_cbreak();
            goto L31;
        }
         *uname = 0;
        return;
    }
}

int same_url_p(ParsedURL* pu1, ParsedURL* pu2)
{// addr = 0x0805DAA4  --  defined in 'file.c' at line 1640
    char* _v24;                            // _cfa_ffffffe8
    char* _t41;                            // _t41
    char* _t46;                            // _t46

    if(pu1->scheme != pu2->scheme || pu1->port != pu2->port) {
L9:
        return 0;
    } else {
        if(pu1->host == 0) {
L5:
            if(pu1->file == 0) {
L8:
                return 1;
            }
            if(pu2->file == 0) {
                goto L9;
            }
            _t41 = pu1->file;
            _v24 = pu2->file;
             *__esp = _t41;
            strcmp();
            if(_t41 != 0) {
                goto L9;
            }
            goto L8;
        }
        if(pu2->host == 0) {
            goto L9;
        }
        _t46 = pu1->host;
        _v24 = pu2->host;
         *__esp = _t46;
        strcasecmp();
        if(_t46 != 0) {
            goto L9;
        }
        goto L5;
    }
}

int checkRedirection(ParsedURL* pu)
{// addr = 0x0805DB36  --  defined in 'file.c' at line 1649
    Str tmp;               // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v52;                       // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    ParsedURL* _t64;   // _t64

    if(pu == 0) {
        nredir = 0;
        nredir_size = 0;
        puv = 0;
        return 1;
    }
    if(nredir < FollowRedirection) {
        if(nredir_size <= 0) {
L9:
            if(puv == 0) {
                nredir_size = ((FollowRedirection >> 31) + FollowRedirection >> 1) + 1;
                _t64 = (nredir_size << 2) + nredir_size << 3;
                 *__esp = _t64;
                GC_malloc();
                puv = _t64;
                _v52 = (nredir_size << 2) + nredir_size << 3;
                _v56 = 0;
                 *__esp = puv;
                memset();
            }
            copyParsedURL(puv + ((nredir % nredir_size << 2) + nredir % nredir_size << 3), pu);
            nredir = nredir + 1;
            return 1;
        }
        _v32 = nredir_size;
        if(same_url_p(pu, puv + (((nredir - 1) % _v32 << 2) + (nredir - 1) % _v32 << 3)) != 0 || (nredir & 1) == 0 && same_url_p(pu, puv + ((((nredir >> 31) + nredir >> 1) % nredir_size << 2) + ((nredir >> 31) + nredir >> 1) % nredir_size << 3)) != 0) {
            _v56 =  *(parsedURL2Str(pu));
            tmp = Sprintf("Redirection loop detected (%s)");
            disp_err_message(tmp->ptr, 0);
            return 0;
        } else {
            goto L9;
        }
    } else {
        _v52 =  *(parsedURL2Str(pu));
        _v56 = FollowRedirection;
        tmp = Sprintf("Number of redirections exceeded %d at %s");
        disp_err_message(tmp->ptr, 0);
        return 0;
    }
}

Buffer* loadGeneralFile(char* path, _None current, char* referer, int flag, _None request)
{// addr = 0x0805DD60  --  defined in 'file.c' at line 1693
    struct http_auth hauth;   // _cfa_fffffeb4
    struct http_auth hauth;   // _cfa_fffffeb4
    struct stat st;       // _cfa_fffffeb4
    char _v16;                             // _cfa_fffffff0
    unsigned char status;                  // _cfa_ffffffe3
    _None of;                              // _cfa_ffffffdc
    Buffer* b;          // _cfa_ffffffd8
    _None proc;                            // _cfa_ffffffd4
    _None tpath;                           // _cfa_ffffffd0
    _None t;                               // _cfa_ffffffcc
    char* p;                               // _cfa_ffffffc8
    _None real_type;                       // _cfa_ffffffc4
    _None t_buf;                           // _cfa_ffffffc0
    _None searchHeader;                    // _cfa_ffffffbc
    _None searchHeader_through;            // _cfa_ffffffb8
    _None prevtrap;                        // _cfa_ffffffb4
    TextList* extra_header;   // _cfa_ffffffb0
    _None uname;                           // _cfa_ffffffac
    _None pwd;                             // _cfa_ffffffa8
    _None realm;                           // _cfa_ffffffa4
    _None add_auth_cookie_flag;            // _cfa_ffffffa0
    Str tmp;               // _cfa_ffffff9c
    _None page;                            // _cfa_ffffff98
    wc_ces charset;     // _cfa_ffffff94
    _None auth_pu;                         // _cfa_ffffff90
    Str cmd;               // _cfa_ffffff8c
    char* t1;                              // _cfa_ffffff88
    FILE* src;            // _cfa_ffffff84
    Str s;                 // _cfa_ffffff80
    char* file;                            // _cfa_ffffff7c
    char* file;                            // _cfa_ffffff78
    Buffer* b;          // _cfa_ffffff74
    Str s;                 // _cfa_ffffff70
    Anchor* a;          // _cfa_ffffff6c
    int l;                                 // _cfa_ffffff68
    int _v156;                             // _cfa_ffffff64
    URLOption url_option;   // _cfa_ffffff60
    HRequest hr;      // _cfa_ffffff54
    long int _v176;                        // _cfa_ffffff50
    intOrPtr _v180;                        // _cfa_ffffff4c
    intOrPtr _v184;                        // _cfa_ffffff48
    Buffer* _v188;      // _cfa_ffffff44
    int _v192;                             // _cfa_ffffff40
    int _v196;                             // _cfa_ffffff3c
    union input_stream* _v200;   // _cfa_ffffff38
    signed int _v202;                      // _cfa_ffffff36
    signed int _v203;                      // _cfa_ffffff35
    URLFile f;         // _cfa_ffffff34
    char* _v212;                           // _cfa_ffffff2c
    char* _v220;                           // _cfa_ffffff24
    char* _v224;                           // _cfa_ffffff20
    char* _v232;                           // _cfa_ffffff18
    ParsedURL pu;    // _cfa_ffffff0c
    _unknown_ _v268;                       // _cfa_fffffef4
    _unknown_ _v316;                       // _cfa_fffffec4
    _unknown_ _v324;                       // _cfa_fffffebc
    struct stat st;       // _cfa_fffffeb4
    long int _v336;                        // _cfa_fffffeb0
    intOrPtr _v340;                        // _cfa_fffffeac
    intOrPtr _v344;                        // _cfa_fffffea8
    Buffer* _v348;      // _cfa_fffffea4
    Buffer* _v352;      // _cfa_fffffea0
    int _v356;                             // _cfa_fffffe9c
    union input_stream* _v360;   // _cfa_fffffe98
    intOrPtr _v364;                        // _cfa_fffffe94
    intOrPtr _v372;                        // _cfa_fffffe8c
    Buffer** _v376;     // _cfa_fffffe88
    intOrPtr _v380;                        // _cfa_fffffe84
    char* _v384;                           // _cfa_fffffe80 (outparam)
    long int _v388;                        // _cfa_fffffe7c (outparam)
    intOrPtr _v392;                        // _cfa_fffffe78 (outparam)
    intOrPtr _v396;                        // _cfa_fffffe74 (outparam)
    _unknown_ _v400;                       // _cfa_fffffe70 (outparam)
    FILE* _v404;          // _cfa_fffffe6c (outparam)
    int _v408;                             // _cfa_fffffe68 (outparam)
    char* _v412;                           // _cfa_fffffe64 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t783;                      // _t783
    char* _t830;                           // _t830
    Buffer* _t842;      // _t842
    int _t859;                             // _t859
    int _t891;                             // _t891
    _unknown_ _t892;                       // _t892
    char* _t935;                           // _t935
    FILE* _t971;          // _t971
    int _t996;                             // _t996
    _unknown_ _t997;                       // _t997
    int _t1018;                            // _t1018
    _unknown_ _t1019;                      // _t1019
    FILE* _t1075;         // _t1075
    union input_stream* _t1172;   // _t1172
    int _t1175;                            // _t1175
    _unknown_ _t1176;                      // _t1176
    int _t1182;                            // _t1182
    _unknown_ _t1183;                      // _t1183
    int _t1199;                            // _t1199
    _unknown_ _t1200;                      // _t1200
    union input_stream* _t1234;   // _t1234
    int _t1237;                            // _t1237
    _unknown_ _t1238;                      // _t1238
    int _t1243;                            // _t1243
    _unknown_ _t1244;                      // _t1244
    signed int _t1262;                     // _t1262
    signed int _t1300;                     // _t1300
    Buffer* _t1356;     // _t1356
    intOrPtr _t1361;                       // _t1361
    _None* _t1390;                         // _t1390
    int _t1406;                            // _t1406
    intOrPtr _t1411;                       // _t1411
    int _t1416;                            // _t1416
    int _t1423;                            // _t1423
    int _t1443;                            // _t1443
    int _t1447;                            // _t1447
    int _t1450;                            // _t1450
    int _t1454;                            // _t1454
    int _t1458;                            // _t1458

    __esp = __esp - 396;
    of = 0;
    b = 0;
    proc = loadBuffer;
    t = "text/plain";
    real_type = 0;
    t_buf = 0;
    searchHeader = SearchHeader & 255;
    searchHeader_through = 1;
    prevtrap = 0;
    extra_header = newGeneralList();
    uname = 0;
    pwd = 0;
    realm = 0;
    status = 0;
    page = 0;
    charset = 256;
    tpath = path;
    prevtrap = 0;
    add_auth_cookie_flag = 0;
    checkRedirection(0);
L1:
    while(1) {
L1:
        while(1) {
            do {
L105:
                auth_pu =  &pu;
                getAuthCookie( &(st.st_dev), "Authorization:", extra_header, auth_pu,  &hr, request,  &uname,  &pwd);
                if(uname != 0) {
                    if(ISclose(_v200) == 0) {
                        _v200 = 0;
                    }
                    add_auth_cookie_flag = 1;
                    status = 0;
                    goto L1;
                } else {
                    if((TrapSignal & 255) != 0) {
                        if((fmInitialized & 255) != 0) {
                            term_raw();
                        }
                        if(prevtrap != 0) {
                            mySignal(2, prevtrap);
                        }
                    }
                    goto L200;
                }
            } while();
L6:
            url_option.auto_detect = referer;
            _v156 = flag;
            _v376 =  &status;
            openURL( &_v364, tpath,  &pu, current,  &url_option, request, extra_header, of,  &hr);
            __esp = __esp - 4;
            f.auto_detect = _v364;
            _v200 = _v360;
            _v196 = _v356;
            _v192 = _v352;
            _v188 = _v348;
            _v184 = _v344;
            _v180 = _v340;
            _v176 = _v336;
            of = 0;
            content_charset = 0;
            if(_v200 != 0) {
                _t783 = status & 255;
                if(_t783 != 254) {
                    _v412 = 1;
                     *__esp =  &AbortLoading;
                    __sigsetjmp();
                    if(_t783 == 0) {
                        b = 0;
                        if((_v203 & 255) != 0) {
                            searchHeader = 1;
                            searchHeader_through = 0;
                        }
                        if(header_string != 0) {
                            header_string = 0;
                        }
                        if((TrapSignal & 255) != 0) {
                            prevtrap = mySignal(2, KeyAbort);
                            if((fmInitialized & 255) != 0) {
                                term_cbreak();
                            }
                        }
                        if(pu.scheme == 0) {
L69:
                            if((fmInitialized & 255) != 0) {
                                term_cbreak();
                                _v412 = _v232;
                                message( *(Sprintf("%s contacted. Waiting for reply...")), 0, 0);
                                refresh();
                            }
                            if(t_buf == 0) {
                                _t1447 = COLS;
                                if(showLineNum == 0) {
                                    _t1182 = 1;
                                } else {
                                    _t1182 = 6;
                                }
                                _t1183 = _t1447 - _t1182;
                                _t1184 = _t1183 < 0 ? 0 : _t1183;
                                t_buf = newBuffer(_t1183 < 0 ? 0 : _t1183);
                            }
                            readHeader( &f, t_buf, 0,  &pu);
                            if(http_response_code <= 300 || http_response_code > 303) {
                                if(http_response_code != 307) {
                                    goto L87;
                                }
                                goto L79;
                            } else {
L79:
                                p = checkHeader(t_buf, "Location:");
                                if(p != 0 && checkRedirection( &pu) != 0) {
L87:
                                    t = checkContentType(t_buf);
                                    if(t == 0 && _v224 != 0 && (http_response_code <= 399 || http_response_code > 407) && (http_response_code <= 499 || http_response_code > 505)) {
                                        t = guessContentType(_v224);
                                    }
                                    if(t == 0) {
                                        t = "text/plain";
                                    }
                                    if(add_auth_cookie_flag != 0 && realm != 0 && uname != 0 && pwd != 0) {
                                        add_auth_user_passwd( &pu,  *(qstr_unquote(realm)), uname, pwd, 0);
                                        add_auth_cookie_flag = 0;
                                    }
                                    p = checkHeader(t_buf, "WWW-Authenticate:");
                                    if(p == 0 || http_response_code != 401 || findAuthentication( &(st.st_dev), t_buf, "WWW-Authenticate:") == 0) {
L114:
                                        p = checkHeader(t_buf, "Proxy-Authenticate:");
                                        if(p == 0 || http_response_code != 407 || findAuthentication( &(st.st_dev), t_buf, "Proxy-Authenticate:") == 0) {
L127:
                                            if((status & 255) != 1) {
                                                _v176 = mymktime(checkHeader(t_buf, "Last-Modified:"));
L192:
                                                _v184 = t;
                                                goto L200;
                                            }
                                            of =  &f;
                                            continue;
                                        } else {
                                            realm = get_auth_param(st.__pad1.tv_sec, "realm");
                                            if(realm == 0) {
                                                goto L127;
                                            }
                                            auth_pu = schemeToProxy(pu.scheme);
                                            getAuthCookie( &(st.st_dev), "Proxy-Authorization:", extra_header, auth_pu,  &hr, request,  &uname,  &pwd);
                                            if(uname != 0) {
                                                if(ISclose(_v200) == 0) {
                                                    _v200 = 0;
                                                }
                                                add_auth_cookie_flag = 1;
                                                status = 0;
                                                continue;
                                            } else {
                                                if((TrapSignal & 255) != 0) {
                                                    if((fmInitialized & 255) != 0) {
                                                        term_raw();
                                                    }
                                                    if(prevtrap != 0) {
                                                        mySignal(2, prevtrap);
                                                    }
                                                }
                                                goto L200;
                                            }
                                        }
                                    } else {
                                        realm = get_auth_param(st.__pad1.tv_sec, "realm");
                                        if(realm == 0) {
                                            goto L114;
                                        }
                                        goto L105;
                                    }
                                } else {
                                    tpath = url_quote( *(wc_Str_conv_strict(Strnew_charp(p), InnerCharset, DocumentCharset)));
                                    request = 0;
                                    _t1172 = ISclose(_v200);
                                    if(_t1172 == 0) {
                                        _v200 = 0;
                                        _t1172 = _v200;
                                    }
                                     *__esp = 40;
                                    GC_malloc();
                                    current = _t1172;
                                    copyParsedURL(current,  &pu);
                                    _t1443 = COLS;
                                    if(showLineNum == 0) {
                                        _t1175 = 1;
                                    } else {
                                        _t1175 = 6;
                                    }
                                    _t1176 = _t1443 - _t1175;
                                    _t1177 = _t1176 < 0 ? 0 : _t1176;
                                    t_buf = newBuffer(_t1176 < 0 ? 0 : _t1176);
                                     *(t_buf + 64) =  *(t_buf + 64) & 65535 | 32;
                                    status = 0;
L1:
                                    while(1) {
                                        do {
L1:
                                            if((TrapSignal & 255) != 0) {
                                                if((fmInitialized & 255) != 0) {
                                                    term_raw();
                                                }
                                                if(prevtrap != 0) {
                                                    mySignal(2, prevtrap);
                                                }
                                            }
                                            goto L6;
                                        } while(p != 0 && checkRedirection( &pu) != 0);
                                        goto L87;
                                    }
                                }
                            }
                        }
                        if(pu.scheme != 1 || non_null(GOPHER_proxy) == 0) {
                            if(pu.scheme != 2 || non_null(FTP_proxy) == 0) {
                                goto L130;
                            } else {
                                goto L67;
                            }
                        } else {
L67:
                            if((use_proxy & 255) == 0 || check_no_proxy(_v232) != 0) {
L130:
                                if(pu.scheme == 9 || pu.scheme == 7) {
                                    if(t_buf == 0) {
                                        _t1450 = COLS;
                                        if(showLineNum == 0) {
                                            _t1199 = 1;
                                        } else {
                                            _t1199 = 6;
                                        }
                                        _t1200 = _t1450 - _t1199;
                                        _t1201 = _t1200 < 0 ? 0 : _t1200;
                                        t_buf = newBuffer(_t1200 < 0 ? 0 : _t1200);
                                    }
                                    readHeader( &f, t_buf, 1,  &pu);
                                    t = checkContentType(t_buf);
                                    if(t == 0) {
                                        t = "text/plain";
                                    }
                                } else {
                                    if(pu.scheme != 1) {
                                        if(pu.scheme != 2) {
                                            if(pu.scheme != 11) {
                                                if(searchHeader == 0) {
                                                    if(DefaultType == 0) {
                                                        t = guessContentType(_v224);
                                                        if(t == 0) {
                                                            t = "text/plain";
                                                        }
                                                        real_type = t;
                                                        if(_v184 != 0) {
                                                            t = _v184;
                                                        }
                                                    } else {
                                                        t = DefaultType;
                                                        DefaultType = 0;
                                                    }
                                                    goto L192;
                                                }
                                                SearchHeader = 0;
                                                searchHeader = 0;
                                                if(t_buf == 0) {
                                                    _t1458 = COLS;
                                                    if(showLineNum == 0) {
                                                        _t1243 = 1;
                                                    } else {
                                                        _t1243 = 6;
                                                    }
                                                    _t1244 = _t1458 - _t1243;
                                                    _t1245 = _t1244 < 0 ? 0 : _t1244;
                                                    t_buf = newBuffer(_t1244 < 0 ? 0 : _t1244);
                                                }
                                                readHeader( &f, t_buf, searchHeader_through,  &pu);
                                                if((_v203 & 255) == 0) {
L183:
                                                    t = checkContentType(t_buf);
                                                    if(t == 0) {
                                                        t = "text/plain";
                                                    }
                                                    goto L192;
                                                } else {
                                                    p = checkHeader(t_buf, "Location:");
                                                    if(p == 0 || checkRedirection( &pu) == 0) {
                                                        goto L183;
                                                    } else {
                                                        tpath = url_quote( *(wc_Str_conv_strict(Strnew_charp(remove_space(p)), InnerCharset, DocumentCharset)));
                                                        request = 0;
                                                        _t1234 = ISclose(_v200);
                                                        if(_t1234 == 0) {
                                                            _v200 = 0;
                                                            _t1234 = _v200;
                                                        }
                                                        add_auth_cookie_flag = 0;
                                                         *__esp = 40;
                                                        GC_malloc();
                                                        current = _t1234;
                                                        copyParsedURL(current,  &pu);
                                                        _t1454 = COLS;
                                                        if(showLineNum == 0) {
                                                            _t1237 = 1;
                                                        } else {
                                                            _t1237 = 6;
                                                        }
                                                        _t1238 = _t1454 - _t1237;
                                                        _t1239 = _t1238 < 0 ? 0 : _t1238;
                                                        t_buf = newBuffer(_t1238 < 0 ? 0 : _t1238);
                                                         *(t_buf + 64) =  *(t_buf + 64) & 65535 | 32;
                                                        status = 0;
                                                        continue;
                                                    }
                                                }
                                            }
                                            t = _v184;
                                            goto L192;
                                        }
                                        check_compression(path,  &f);
                                        if(_v192 == 0) {
                                            real_type = guessContentType(_v224);
                                            if(real_type == 0) {
                                                real_type = "text/plain";
                                            }
                                            t = real_type;
                                        } else {
                                            t1 = uncompressed_file_type(_v224, 0);
                                            real_type = _v184;
                                            if(t1 == 0) {
                                                t = real_type;
                                            } else {
                                                t = t1;
                                            }
                                        }
                                        goto L192;
                                    }
                                    _t1262 =  *_v224 & 255;
                                    if(_t1262 == 103) {
                                        t = "image/gif";
                                        goto L192;
                                    }
                                    if(_t1262 > 103) {
                                        if(_t1262 == 109) {
L150:
                                            page = loadGopherDir( &f,  &pu,  &charset);
                                            t = "gopher:directory";
                                            if((TrapSignal & 255) != 0) {
                                                if((fmInitialized & 255) != 0) {
                                                    term_raw();
                                                }
                                                if(prevtrap != 0) {
                                                    mySignal(2, prevtrap);
                                                }
                                            }
                                            goto L200;
                                        }
                                        if(_t1262 == 115) {
                                            t = "audio/basic";
                                        } else {
                                            if(_t1262 == 104) {
                                                t = "text/html";
                                            }
                                        }
                                        goto L192;
                                    }
                                    if(_t1262 == 48) {
                                        t = "text/plain";
                                        goto L192;
                                    }
                                    if(_t1262 == 49) {
                                        goto L150;
                                    }
                                }
                                goto L192;
                            } else {
                                goto L69;
                            }
                        }
                    } else {
                        if((TrapSignal & 255) != 0) {
                            if((fmInitialized & 255) != 0) {
                                term_raw();
                            }
                            if(prevtrap != 0) {
                                mySignal(2, prevtrap);
                            }
                        }
                        if(b != 0) {
                            discardBuffer(b);
                        }
                        if(ISclose(_v200) == 0) {
                            _v200 = 0;
                        }
                        _t842 = 0;
                        goto L365;
                    }
                } else {
                    if((TrapSignal & 255) != 0) {
                        if((fmInitialized & 255) != 0) {
                            term_raw();
                        }
                        if(prevtrap != 0) {
                            mySignal(2, prevtrap);
                        }
                    }
                    if(ISclose(_v200) == 0) {
                        _v200 = 0;
                    }
                    _t842 = 0;
L365:
                     &_v16 =  &_v16;
                    return _t842;
                }
            }
            _t1300 = f.auto_detect & 0xff;
            if(_t1300 == 4) {
                if(__stat(_v220,  &(st.st_dev)) >= 0) {
                    if((st.st_mode.tv_sec & 61440) != 16384) {
L32:
                        if(page == 0 ||  *((intOrPtr*)(page + 4)) <= 0) {
                            _t842 = 0;
                            goto L365;
                        } else {
                            goto L200;
                        }
                    }
                    if(UseExternalDirBuffer == 0) {
                        page = loadLocalDir(_v220);
                        t = "local:directory";
                        charset = SystemCharset;
                        goto L32;
                    } else {
                        _v408 = _v224;
                        _v412 = DirBufferCommand;
                        cmd = Sprintf("%s?dir=%s#current");
                        _v400 = 0;
                        _v404 = 0;
                        b = loadGeneralFile(cmd->ptr, 0, -1);
                        if(b != 0) {
                            if(b != 1) {
                                copyParsedURL( &(b->currentURL),  &pu);
                                b->filename = b->currentURL.real_file;
                            }
                        }
                        _t842 = b;
                        goto L365;
                    }
                } else {
                    _t842 = 0;
                    goto L365;
                }
            }
            if(_t1300 > 4) {
                if(_t1300 == 10) {
                    page = loadNewsgroup( &pu,  &charset);
                    t = "news:group";
                    goto L32;
                }
                if(_t1300 == 255) {
                    tmp = searchURIMethods( &pu);
                    if(tmp == 0) {
                        _v412 =  *(parsedURL2Str( &pu));
                        disp_err_message( *(Sprintf("Unknown URI: %s")), 0);
                        goto L32;
                    } else {
                        _v400 = request;
                        _v404 = flag;
                        b = loadGeneralFile(tmp->ptr, current, referer);
                        if(b != 0) {
                            if(b != 1) {
                                copyParsedURL( &(b->currentURL),  &pu);
                            }
                        }
                        _t842 = b;
                        goto L365;
                    }
                } else {
                    goto L32;
                }
            } else {
                if(_t1300 == 3) {
                    page = loadFTPDir( &pu,  &charset);
                    t = "ftp:directory";
                }
                goto L32;
            }
L200:
            if(page == 0) {
                if(real_type == 0) {
                    real_type = t;
                }
                proc = loadBuffer;
                 *__esp = 40;
                GC_malloc();
                cur_baseURL = loadBuffer;
                copyParsedURL(cur_baseURL,  &pu);
                current_content_length = 0;
                 *135776436 = 0;
                p = checkHeader(t_buf, "Content-Length:");
                if(p != 0) {
                    current_content_length = strtoclen(p);
                     *135776436 =  &pu;
                }
                if(do_download == 0) {
                    if(_v188 == 0 || (AutoUncompress & 255) == 0 || (w3m_dump & 8) != 0) {
                        if(_v192 != 0) {
                            if((w3m_dump & 4) != 0 || (w3m_dump & -33) == 0 && is_text_type(t) == 0 && searchExtViewer(t) == 0) {
                                t = compress_application_type(_v192);
                                _v192 = 0;
                            } else {
                                if(t_buf == 0) {
                                    _t1423 = COLS;
                                    if(showLineNum == 0) {
                                        _t1018 = 1;
                                    } else {
                                        _t1018 = 6;
                                    }
                                    _t1019 = _t1423 - _t1018;
                                    _t1020 = _t1019 < 0 ? 0 : _t1019;
                                    t_buf = newBuffer(_t1019 < 0 ? 0 : _t1019);
                                }
                                uncompress_stream( &f, t_buf + 184);
                                uncompressed_file_type(_v224,  &( &f->use_jisc6226));
                            }
                        }
                    } else {
                        uncompress_stream( &f,  &( &pu->real_file));
                    }
                    if(image_source == 0) {
                        if(is_html_type(t) == 0) {
                            if(is_plain_text_type(t) == 0) {
                                if(activeImage == 0 || displayImage == 0 || useExtImageViewer != 0 || (w3m_dump & -33) != 0) {
L284:
                                    if(w3m_backend != 0) {
                                        goto L324;
                                    }
                                    if((w3m_dump & -33) == 0 || is_dump_text_type(t) != 0) {
                                        if(do_download != 0) {
L305:
                                            if((TrapSignal & 255) != 0) {
                                                if((fmInitialized & 255) != 0) {
                                                    term_raw();
                                                }
                                                if(prevtrap != 0) {
                                                    mySignal(2, prevtrap);
                                                }
                                            }
                                            if(pu.scheme != 4) {
                                                if((DecodeCTE & 255) != 0 && (_v200->base.stream.cur & 255) != 4) {
                                                    _v200 = newEncodedStream(_v200, _v202 & 255);
                                                }
                                                _v384 = guess_save_name(t_buf, _v224);
                                                 *__esp = f.auto_detect;
                                                _v412 = _v200;
                                                _v408 = _v196;
                                                _v404 = _v192;
                                                _v400 = _v188;
                                                _v396 = _v184;
                                                _v392 = _v180;
                                                _v388 = _v176;
                                                if(doFileSave() != 0) {
                                                    if(ISclose(_v200) == 0) {
                                                        _v200 = 0;
                                                    }
                                                } else {
                                                    UFhalfclose( &f);
                                                }
                                            } else {
                                                if(ISclose(_v200) == 0) {
                                                    _v200 = 0;
                                                }
                                                _doFileCopy(_v220,  *(wc_Str_conv(Strnew_charp(guess_save_name(0, _v220)), SystemCharset, InnerCharset)), 1);
                                            }
                                            _t842 = 1;
                                            goto L365;
                                        }
                                        _t1361 = t_buf;
                                        _t1411 = t;
                                        if(_v220 == 0) {
                                            _t935 = _v224;
                                        } else {
                                            _t935 = _v220;
                                        }
                                        _v372 = _t1361;
                                        _v376 =  &b;
                                        _v380 = _t1411;
                                        _v384 = _t935;
                                         *__esp = f.auto_detect;
                                        _v412 = _v200;
                                        _v408 = _v196;
                                        _v404 = _v192;
                                        _v400 = _v188;
                                        _v396 = _v184;
                                        _v392 = _v180;
                                        _v388 = _v176;
                                        if(doExternal() == 0) {
                                            goto L305;
                                        } else {
                                            if(b != 0 && b != 1) {
                                                b->real_scheme = f.auto_detect & 0xff;
                                                b->real_type = real_type;
                                                if(b->currentURL.host == 0 && b->currentURL.file == 0) {
                                                    copyParsedURL( &(b->currentURL),  &pu);
                                                }
                                            }
                                            if(ISclose(_v200) == 0) {
                                                _v200 = 0;
                                            }
                                            if((TrapSignal & 255) != 0) {
                                                if((fmInitialized & 255) != 0) {
                                                    term_raw();
                                                }
                                                if(prevtrap != 0) {
                                                    mySignal(2, prevtrap);
                                                }
                                            }
                                            _t842 = b;
                                            goto L365;
                                        }
                                    } else {
                                        if((w3m_dump & 32) == 0) {
                                            goto L324;
                                        }
                                        _t842 = 0;
                                        goto L365;
                                    }
                                } else {
                                    _t971 = t;
                                    _v408 = 6;
                                    _v412 = "image/";
                                     *__esp = _t971;
                                    strncasecmp();
                                    if(_t971 != 0) {
                                        goto L284;
                                    }
                                    proc = loadImageBuffer;
L324:
                                    if((flag & 2) != 0) {
                                        if(t_buf == 0) {
                                            _t1406 = COLS;
                                            if(showLineNum == 0) {
                                                _t891 = 1;
                                            } else {
                                                _t891 = 6;
                                            }
                                            _t892 = _t1406 - _t891;
                                            _t893 = _t892 < 0 ? 0 : _t892;
                                            t_buf = newBuffer(_t892 < 0 ? 0 : _t892);
                                        }
                                         *(t_buf + 64) =  *(t_buf + 64) & 65535 | 2;
                                    }
                                    frame_source = flag & 4;
                                    _t1356 = t_buf;
                                    _t1390 = proc;
                                    if(_v220 == 0) {
                                        _t830 = _v224;
                                    } else {
                                        _t830 = _v220;
                                    }
                                    b = loadSomething( &f, _t830, _t1390, _t1356);
                                    if(ISclose(_v200) == 0) {
                                        _v200 = 0;
                                    }
                                    frame_source = 0;
                                    if(b != 0) {
                                        b->real_scheme = f.auto_detect & 0xff;
                                        b->real_type = real_type;
                                        if(b->currentURL.host == 0 && b->currentURL.file == 0) {
                                            copyParsedURL( &(b->currentURL),  &pu);
                                        }
                                        if(is_html_type(t) == 0) {
                                            if(w3m_backend == 0) {
                                                if(proc != loadImageBuffer) {
                                                    b->type = "text/plain";
                                                } else {
                                                    b->type = "text/html";
                                                }
                                            } else {
                                                s = Strnew_charp(t);
                                                b->type = s->ptr;
                                            }
                                        } else {
                                            b->type = "text/html";
                                        }
                                        if(_v212 != 0) {
                                            if(proc != loadHTMLBuffer) {
                                                _t859 = _v212;
                                                 *__esp = _t859;
                                                atoi();
                                                l = _t859;
                                                gotoRealLine(b, l);
                                                b->pos = 0;
                                                arrangeCursor(b);
                                            } else {
                                                a = searchURLLabel(b, _v212);
                                                if(a != 0) {
                                                    gotoLine(b, a->start.line);
                                                    if(label_topline != 0) {
                                                        b->topLine = lineSkip(b, b->topLine, b->currentLine->linenumber - b->topLine->linenumber, 0);
                                                    }
                                                    b->pos = a->start.pos;
                                                    arrangeCursor(b);
                                                }
                                            }
                                        }
                                    }
                                    if(header_string != 0) {
                                        header_string = 0;
                                    }
                                    if((f.auto_detect & 255) == 7 || (f.auto_detect & 255) == 9) {
                                        reAnchorNewsheader(b);
                                    }
                                    preFormUpdateBuffer(b);
                                    if((TrapSignal & 255) != 0) {
                                        if((fmInitialized & 255) != 0) {
                                            term_raw();
                                        }
                                        if(prevtrap != 0) {
                                            mySignal(2, prevtrap);
                                        }
                                    }
                                    _t842 = b;
                                    goto L365;
                                }
                            }
                            proc = loadBuffer;
                            goto L324;
                        }
                        proc = loadHTMLBuffer;
                        goto L324;
                    } else {
                        b = 0;
                        if((_v200->base.stream.cur & 255) != 4) {
                            _v200 = newEncodedStream(_v200, _v202 & 255);
                        }
                        _v384 = image_source;
                         *__esp = f.auto_detect;
                        _v412 = _v200;
                        _v408 = _v196;
                        _v404 = _v192;
                        _v400 = _v188;
                        _v396 = _v184;
                        _v392 = _v180;
                        _v388 = _v176;
                        if(save2tmp() == 0) {
                            _t1416 = COLS;
                            if(showLineNum == 0) {
                                _t996 = 1;
                            } else {
                                _t996 = 6;
                            }
                            _t997 = _t1416 - _t996;
                            _t998 = _t997 < 0 ? 0 : _t997;
                            b = newBuffer(_t997 < 0 ? 0 : _t997);
                            b->sourcefile = image_source;
                            b->real_type = t;
                        }
                        if(ISclose(_v200) == 0) {
                            _v200 = 0;
                        }
                        if((TrapSignal & 255) != 0) {
                            if((fmInitialized & 255) != 0) {
                                term_raw();
                            }
                            if(prevtrap != 0) {
                                mySignal(2, prevtrap);
                            }
                        }
                        _t842 = b;
                        goto L365;
                    }
                } else {
                    if((TrapSignal & 255) != 0) {
                        if((fmInitialized & 255) != 0) {
                            term_raw();
                        }
                        if(prevtrap != 0) {
                            mySignal(2, prevtrap);
                        }
                    }
                    if((DecodeCTE & 255) != 0 && (_v200->base.stream.cur & 255) != 4) {
                        _v200 = newEncodedStream(_v200, _v202 & 255);
                    }
                    if(pu.scheme != 4) {
                        file = guess_save_name(t_buf, _v224);
                    } else {
                        if((PreserveTimestamp & 255) != 0 && __stat(_v220,  &(st.st_dev)) == 0) {
                            _v176 = st.st_mtim.tv_sec;
                        }
                        file =  *(wc_Str_conv(Strnew_charp(guess_save_name(0, _v220)), SystemCharset, InnerCharset));
                    }
                    _v384 = file;
                     *__esp = f.auto_detect;
                    _v412 = _v200;
                    _v408 = _v196;
                    _v404 = _v192;
                    _v400 = _v188;
                    _v396 = _v184;
                    _v392 = _v180;
                    _v388 = _v176;
                    if(doFileSave() != 0) {
                        if(ISclose(_v200) == 0) {
                            _v200 = 0;
                        }
                    } else {
                        UFhalfclose( &f);
                    }
                    _t842 = 1;
                    goto L365;
                }
            }
            if(image_source == 0) {
                tmp = tmpfname(1, ".html");
                _t1075 = tmp->ptr;
                _v412 = 135041136;
                 *__esp = _t1075;
                fopen();
                src = _t1075;
                if(src != 0) {
                    s = wc_Str_conv_strict(page, InnerCharset, charset);
                    _v404 = src;
                    _v408 = s->length;
                    _v412 = 1;
                     *__esp = s->ptr;
                    fwrite();
                     *__esp = src;
                    fclose();
                }
                if(do_download == 0) {
                    b = loadHTMLString(page);
                    if(b != 0) {
                        copyParsedURL( &(b->currentURL),  &pu);
                        b->real_scheme = pu.scheme;
                        b->real_type = t;
                        if(src != 0) {
                            b->sourcefile = tmp->ptr;
                        }
                        b->document_charset = charset;
                    }
                    _t842 = b;
                } else {
                    if(src != 0) {
                        file = guess_filename(_v224);
                        if((f.auto_detect & 255) == 1) {
                            _v412 = file;
                            file =  *(Sprintf("%s.html"));
                        }
                        if((f.auto_detect & 255) == 10) {
                            _v412 = file;
                            file =  *(Sprintf("%s.html"));
                        }
                        doFileMove(tmp->ptr, file);
                        _t842 = 1;
                    } else {
                        _t842 = 0;
                    }
                }
            } else {
                _t842 = 0;
            }
            goto L365;
        }
    }
}

char* has_hidden_link(struct readbuffer* obuf, int cmd)
{// addr = 0x0805FA4E  --  defined in 'file.c' at line 2293
    Str line;              // _cfa_fffffff8
    struct link_stack* p;   // _cfa_fffffff4

    line = obuf->line;
    if(line->length <= 0 || ( *(line->ptr + line->length - 1) & 255) != 62) {
        return 0;
    } else {
        p = link_stack;
        while(p != 0) {
            if(p->cmd == cmd) {
L9:
                if(p != 0) {
                    if((obuf->pos & 65535) != (p->pos & 65535)) {
                        return 0;
                    }
                    return  &(line->ptr[p->offset & 65535]);
                }
                return 0;
            }
            p = p->next;
        }
        goto L9;
    }
}

void push_link(int cmd, int offset, int pos)
{// addr = 0x0805FAE4  --  defined in 'file.c' at line 2314
    struct link_stack* p;   // _cfa_fffffff0

     *__esp = 12;
    GC_malloc();
    p = __eax;
    p->cmd = cmd;
    p->offset = offset;
    p->pos = pos;
    p->next = link_stack;
    link_stack = p;
}

int is_period_char(unsigned char* ch)
{// addr = 0x0805FB2F  --  defined in 'file.c' at line 2326
    if(( *ch & 0xff) - 33 <= 92) {
        goto __eax;
    }
    return 0;
}

int is_beginning_char(unsigned char* ch)
{// addr = 0x0805FB5A  --  defined in 'file.c' at line 2346
    signed int _t4;                        // _t4

    _t4 =  *ch & 0xff;
    if(_t4 == 91) {
L7:
        return 1;
    }
    if(_t4 > 91) {
        if(_t4 == 96 || _t4 == 123) {
            goto L7;
        } else {
L8:
            return 0;
        }
    }
    if(_t4 == 40 || _t4 == 60) {
        goto L7;
    } else {
        goto L8;
    }
}

int is_word_char(unsigned char* ch)
{// addr = 0x0805FB94  --  defined in 'file.c' at line 2361
    Lineprop ctype;   // _cfa_fffffffa

    ctype = ( *( &WTF_TYPE_MAP + ( *ch & 0xff)) & 0xff) << 8;
    if((ctype & 0x1900) == 0) {
        if((ctype & 0x600) == 0) {
            if(( *( &MYCTYPE_MAP + ( *ch & 0xff)) & 0xc) == 0) {
                if(( *ch & 0xff) - 34 > 92) {
                    if(( *ch & 255) != 160) {
                        return 0;
                    }
                    return 1;
                }
                goto __eax;
            }
            return 1;
        }
        return 1;
    }
    return 0;
}

int is_combining_char(unsigned char* ch)
{// addr = 0x0805FC36  --  defined in 'file.c' at line 2408
    Lineprop ctype;   // _cfa_fffffffa

    ctype = ( *( &WTF_TYPE_MAP + ( *ch & 0xff)) & 0xff) << 8;
    if((ctype & 0x400) == 0) {
        return 0;
    }
    return 1;
}

int is_boundary(unsigned char* ch1, unsigned char* ch2)
{// addr = 0x0805FC71  --  defined in 'file.c' at line 2419
    if(( *ch1 & 255) == 0 || ( *ch2 & 255) == 0) {
        return 1;
    }
    if(( *ch1 & 255) != 32) {
L6:
        if(( *ch1 & 255) == 32 || is_period_char(ch2) == 0) {
            if(( *ch2 & 255) == 32 || is_beginning_char(ch1) == 0) {
                if(is_combining_char(ch2) == 0) {
                    if(is_word_char(ch1) == 0 || is_word_char(ch2) == 0) {
                        return 1;
                    } else {
                        return 0;
                    }
                }
                return 0;
            } else {
                return 0;
            }
        } else {
            return 0;
        }
    } else {
        if(( *ch2 & 255) != 32) {
            goto L6;
        } else {
            return 0;
        }
    }
}

void set_breakpoint(struct readbuffer* obuf, int tag_length)
{// addr = 0x0805FD35  --  defined in 'file.c' at line 2445
    intOrPtr _v20;                         // _cfa_ffffffec
    Anchor* _v24;       // _cfa_ffffffe8

    obuf->bp.len =  *(obuf->line + 4);
    obuf->bp = obuf->pos & 65535;
    obuf->bp.tlen = tag_length;
    obuf->bp.flag = obuf->flag;
    obuf->bp.top_margin = obuf->top_margin & 65535;
    obuf->bp.bottom_margin = obuf->bottom_margin & 65535;
    if((obuf->bp.init_flag & 255) != 0) {
        _v20 = 60;
        _v24 =  &(obuf->bp.anchor);
         *__esp =  &(obuf->anchor);
        bcopy();
        obuf->bp.img_alt = obuf->img_alt;
        obuf->bp.fontstat = obuf->fontstat & 255;
        obuf->bp.fontstat[2] = obuf->fontstat[2] & 255;
        obuf->bp.fontstat[1] = obuf->fontstat[1] & 255;
        obuf->bp.fontstat[3] = obuf->fontstat[3] & 255;
        obuf->bp.fontstat[4] = obuf->fontstat[4] & 255;
        obuf->bp.nobr_level = obuf->nobr_level & 65535;
        obuf->bp.prev_ctype = obuf->prev_ctype & 65535;
        obuf->bp.init_flag = 0;
        return;
    }
}

void back_to_breakpoint(struct readbuffer* obuf)
{// addr = 0x0805FE7C  --  defined in 'file.c' at line 2474
    intOrPtr _v20;                         // _cfa_ffffffec
    Anchor* _v24;       // _cfa_ffffffe8

    obuf->flag = obuf->bp.flag;
    _v20 = 60;
    _v24 =  &(obuf->anchor);
     *__esp =  &(obuf->bp.anchor);
    bcopy();
    obuf->img_alt = obuf->bp.img_alt;
    obuf->fontstat = obuf->bp.fontstat & 255;
    obuf->fontstat[2] = obuf->bp.fontstat[2] & 255;
    obuf->fontstat[1] = obuf->bp.fontstat[1] & 255;
    obuf->fontstat[3] = obuf->bp.fontstat[3] & 255;
    obuf->fontstat[4] = obuf->bp.fontstat[4] & 255;
    obuf->prev_ctype = obuf->bp.prev_ctype & 65535;
    obuf->pos = obuf->bp;
    obuf->top_margin = obuf->bp.top_margin & 65535;
    obuf->bottom_margin = obuf->bp.bottom_margin & 65535;
    if((obuf->flag & 128) != 0) {
        obuf->nobr_level = obuf->bp.nobr_level & 65535;
        return;
    }
}

void append_tags(struct readbuffer* obuf)
{// addr = 0x0805FF94  --  defined in 'file.c' at line 2494
    int i;                                 // _cfa_fffffff0
    int len;                               // _cfa_ffffffec
    int set_bp;                            // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t56;                              // _t56
    int _t70;                              // _t70

    len =  *(obuf->line + 4);
    set_bp = 0;
    i = 0;
    while(obuf->tag_sp > i) {
        _t56 = ( *(obuf + (i + 72) * 4))[1];
        if(_t56 == 65) {
L9:
            push_link(( *(obuf + (i + 72) * 4))[1],  *(obuf->line + 4), obuf->pos & 65535);
L10:
            Strcat_charp(obuf->line,  *((char**)( *(obuf + (i + 72) * 4))));
            _t70 = ( *(obuf + (i + 72) * 4))[1];
            if(_t70 == 50) {
                if((obuf->nobr_level & 65535) > 1) {
L16:
                    i = i + 1;
                    continue;
                }
L14:
                set_bp = 1;
                goto L16;
            }
            if(_t70 == 69) {
                goto L14;
            } else {
                goto L16;
            }
        }
        if(_t56 > 65) {
            if(_t56 == 109 || _t56 == 136 || _t56 == 105) {
                goto L9;
            } else {
                goto L10;
            }
        }
        if(_t56 == 1 || _t56 == 7) {
            goto L9;
        } else {
            goto L10;
        }
    }
    obuf->tag_sp = 0;
    if(set_bp == 0) {
        return;
    }
    set_breakpoint(obuf, obuf->line->length - len);
}

void push_tag(struct readbuffer* obuf, char* cmdname, int cmd)
{// addr = 0x080600BA  --  defined in 'file.c' at line 2527
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ __ebx;                       // r1

    _t31 = obuf;
     *__esp = 8;
    GC_malloc();
     *(obuf + (_t31->tag_sp + 72) * 4) = obuf;
     *((char**)( *(obuf + (obuf->tag_sp + 72) * 4))) = allocStr(cmdname, -1);
    ( *(obuf + (obuf->tag_sp + 72) * 4))[1] = cmd;
    obuf->tag_sp = obuf->tag_sp + 1;
    if(obuf->tag_sp > 9 || (obuf->flag & 527) != 0) {
        append_tags(obuf);
        return;
    } else {
        return;
    }
}

void push_nchars(struct readbuffer* obuf, int width, char* str, int len, Lineprop mode)
{// addr = 0x08060163  --  defined in 'file.c' at line 2538
    signed short _v16;                     // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v16 = mode;
    append_tags(obuf);
    Strcat_charp_n(obuf->line, str, len);
    obuf->pos = (obuf->pos & 65535) + width;
    if(width > 0) {
        Strcopy_charp_n(obuf->prevchar, str, len);
        obuf->prev_ctype = _v16 & 65535;
    }
    obuf->flag = obuf->flag | 128;
}

void check_breakpoint(struct readbuffer* obuf, int pre_mode, char* ch)
{// addr = 0x080601F1  --  defined in 'file.c' at line 2558
    int tlen;                              // _cfa_fffffff0
    int len;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    len =  *(obuf->line + 4);
    append_tags(obuf);
    if(pre_mode != 0) {
L5:
        return;
    }
    tlen =  *(obuf->line + 4) - len;
    if(tlen > 0 || is_boundary( *(obuf->prevchar), ch) != 0) {
        set_breakpoint(obuf, tlen);
        return;
    } else {
        goto L5;
    }
}

void push_char(struct readbuffer* obuf, int pre_mode, char ch)
{// addr = 0x08060259  --  defined in 'file.c' at line 2573
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    struct _Str* _t53;    // _t53
    int _t77;                              // _t77

    _v16 = ch;
    check_breakpoint(obuf, pre_mode,  &_v16);
    if(obuf->line->length + 1 >= obuf->line->area_size) {
        Strgrow(obuf->line);
    }
    _t53 = obuf->line;
    _t77 = _t53->length;
     *((char*)( *(obuf->line) + _t77)) = _v16 & 255;
    _t53->length = _t77 + 1;
     *((char*)( *(obuf->line) + obuf->line->length)) = 0;
    obuf->pos = (obuf->pos & 65535) + 1;
    Strcopy_charp_n(obuf->prevchar,  &_v16, 1);
    if((_v16 & 255) != 32) {
        obuf->prev_ctype = 0;
    }
    obuf->flag = obuf->flag | 128;
}

void push_spaces(struct readbuffer* obuf, int pre_mode, int width)
{// addr = 0x08060330  --  defined in 'file.c' at line 2587
    int i;                                 // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    struct _Str* _t52;    // _t52
    int _t74;                              // _t74

    if(width > 0) {
        check_breakpoint(obuf, pre_mode, " ");
        i = 0;
        while(i < width) {
            if(obuf->line->length + 1 >= obuf->line->area_size) {
                Strgrow(obuf->line);
            }
            _t52 = obuf->line;
            _t74 = _t52->length;
             *((char*)( *(obuf->line) + _t74)) = 32;
            _t52->length = _t74 + 1;
             *((char*)( *(obuf->line) + obuf->line->length)) = 0;
            i = i + 1;
        }
        obuf->pos = (obuf->pos & 65535) + width;
        Strcopy_charp_n(obuf->prevchar, " ", 1);
        obuf->flag = obuf->flag | 128;
        return;
    }
}

void proc_mchar(struct readbuffer* obuf, int pre_mode, int width, char** str, Lineprop mode)
{// addr = 0x08060416  --  defined in 'file.c' at line 2602
    signed short _v16;                     // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v16 = mode;
    check_breakpoint(obuf, pre_mode,  *str);
    obuf->pos = (obuf->pos & 65535) + width;
    Strcat_charp_n(obuf->line,  *str,  *( &WTF_LEN_MAP + ( *( *str) & 0xff)) & 0xff);
    if(width > 0) {
        Strcopy_charp_n(obuf->prevchar,  *str, 1);
        if(( *( *str) & 255) != 32) {
            obuf->prev_ctype = _v16 & 65535;
        }
    }
     *str =  &(( *str)[ *( &WTF_LEN_MAP + ( *( *str) & 0xff)) & 0xff]);
    obuf->flag = obuf->flag | 128;
}

void push_render_image(Str str, int width, int limit, struct html_feed_environ* h_env)
{// addr = 0x080604F8  --  defined in 'file.c' at line 2618
    struct readbuffer* obuf;   // _cfa_fffffff0
    int indent;                            // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    obuf = h_env->obuf;
    indent =  &(h_env->envs[h_env->envc])->indent & 255;
    push_spaces(obuf, 1, (limit - width >> 31) + limit - width >> 1);
    push_nchars(obuf, width, str->ptr, str->length, 0);
    push_spaces(obuf, 1, (limit - width + 1 >> 31) + limit - width + 1 >> 1);
    if(width > 0) {
        flushline(h_env, obuf, indent, 0, h_env->limit);
        return;
    }
}

int sloppy_parse_line(char** str)
{// addr = 0x080605DF  --  defined in 'file.c' at line 2632
    if(( *( *str) & 255) != 60) {
        while(1) {
            str =  *str;
            if(__al == 0) {
                break;
            }
            str =  *str;
            if(__al != 60) {
                str =  *str;
                __eax = str;
                 *str =  &(( *str)[1]);
                continue;
            }
            break;
        }
        __eax = 0;
        return 0;
    }
    while(( *( *str) & 255) != 0 && ( *( *str) & 255) != 62) {
         *str =  &(( *str)[1]);
    }
    if(( *( *str) & 255) == 62) {
         *str =  &(( *str)[1]);
    }
    return 1;
}

void passthrough(struct readbuffer* obuf, char* str, int back)
{// addr = 0x08060664  --  defined in 'file.c' at line 2649
    int cmd;                               // _cfa_fffffff0
    Str tok;               // _cfa_ffffffec
    char* str_bak;                         // _cfa_ffffffe8
    Str str_save;          // _cfa_ffffffe4
    char* q;                               // _cfa_ffffffe0
    struct link_stack* p;   // _cfa_ffffffdc
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1

    tok = Strnew();
    if(back != 0) {
        str_save = Strnew_charp(str);
        Strshrink(obuf->line,  *(obuf->line) + obuf->line->length - str);
        str = str_save->ptr;
    }
    while(( *str & 255) != 0) {
        str_bak = str;
        if(sloppy_parse_line( &str) == 0) {
            push_nchars(obuf, 0, str_bak, str - str_bak, obuf->prev_ctype & 0xffff);
            continue;
        }
        q = str_bak;
        cmd = gethtmlcmd( &q);
        if(back == 0) {
            Strcat_charp_n(tok, str_bak, str - str_bak);
            push_tag(obuf, tok->ptr, cmd);
            Strclear(tok);
            continue;
        }
        p = link_stack;
        while(p != 0) {
            if(p->cmd != cmd) {
                p = p->next;
                continue;
            }
            link_stack = p->next;
            break;
        }
        back = 0;
    }
}

void fillline(struct readbuffer* obuf, int indent)
{// addr = 0x080607D1  --  defined in 'file.c' at line 2708
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    push_spaces(obuf, 1, indent - (obuf->pos & 65535));
    obuf->flag = obuf->flag & 127;
}

void flushline(struct html_feed_environ* h_env, struct readbuffer* obuf, int indent, int force, int width)
{// addr = 0x08060812  --  defined in 'file.c' at line 2715
    struct html_feed_environ h;   // _cfa_ffffff54
    struct readbuffer o;   // _cfa_fffffe04
    struct environment[0] e;   // _cfa_ffffff84
    TextLineList* buf;   // _cfa_fffffff0
    FILE* f;              // _cfa_ffffffec
    Str line;              // _cfa_ffffffe8
    Str pass;              // _cfa_ffffffe4
    char* hidden_anchor;                   // _cfa_ffffffe0
    char* hidden_img;                      // _cfa_ffffffdc
    char* hidden_bold;                     // _cfa_ffffffd8
    char* hidden_under;                    // _cfa_ffffffd4
    char* hidden_italic;                   // _cfa_ffffffd0
    char* hidden_strike;                   // _cfa_ffffffcc
    char* hidden_ins;                      // _cfa_ffffffc8
    char* hidden;                          // _cfa_ffffffc4
    char* tp;                              // _cfa_ffffffc0
    char* ep;                              // _cfa_ffffffbc
    int i;                                 // _cfa_ffffffb8
    TextLine* lbuf;   // _cfa_ffffffb4
    char* p;                               // _cfa_ffffffb0
    char* q;                               // _cfa_ffffffac
    Str tmp;               // _cfa_ffffffa8
    Str tmp2;              // _cfa_ffffffa4
    int i;                                 // _cfa_ffffffa0
    Str tmp;               // _cfa_ffffff9c
    char* c;                               // _cfa_ffffff98
    Str tmp;               // _cfa_ffffff94
    struct environment[0] e;   // _cfa_ffffff84
    struct html_feed_environ h;   // _cfa_ffffff54
    _unknown_ _v174;                       // _cfa_ffffff52
    _unknown_ _v176;                       // _cfa_ffffff50
    _unknown_ _v496;                       // _cfa_fffffe10
    _unknown_ _v502;                       // _cfa_fffffe0a
    struct readbuffer o;   // _cfa_fffffe04
    _unknown_ _v516;                       // _cfa_fffffdfc (outparam)
    _unknown_ _v520;                       // _cfa_fffffdf8 (outparam)
    _unknown_ _v524;                       // _cfa_fffffdf4 (outparam)
    FILE* _v528;          // _cfa_fffffdf0 (outparam)
    int _v532;                             // _cfa_fffffdec (outparam)
    int _v536;                             // _cfa_fffffde8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t744;                             // _t744
    struct _Str* _t794;   // _t794
    struct _Str* _t818;   // _t818
    struct _Str* _t822;   // _t822
    struct _Str* _t897;   // _t897
    int _t1002;                            // _t1002
    int _t1036;                            // _t1036
    int _t1049;                            // _t1049

    buf = h_env->buf;
    f = h_env->f;
    line = obuf->line;
    pass = 0;
    hidden_anchor = 0;
    hidden_img = 0;
    hidden_bold = 0;
    hidden_under = 0;
    hidden_italic = 0;
    hidden_strike = 0;
    hidden_ins = 0;
    hidden = 0;
    if((obuf->flag & 527) == 0) {
        if(line->length > 0) {
            if(( *(line->ptr + line->length - 1) & 255) == 32) {
                Strshrink(line, 1);
                obuf->pos = (obuf->pos & 65535) - 1;
            }
        }
    }
    append_tags(obuf);
    if(obuf->anchor != 0) {
        hidden_anchor = has_hidden_link(obuf, 1);
        hidden = hidden_anchor;
    }
    if(obuf->img_alt != 0) {
        hidden_img = has_hidden_link(obuf, 136);
        if(hidden_img != 0) {
            if(hidden == 0 || hidden_img < hidden) {
                hidden = hidden_img;
            }
        }
    }
    if((obuf->fontstat & 255) != 0) {
        hidden_bold = has_hidden_link(obuf, 7);
        if(hidden_bold != 0) {
            if(hidden == 0 || hidden_bold < hidden) {
                hidden = hidden_bold;
            }
        }
    }
    if((obuf->fontstat[2] & 255) != 0) {
        hidden_italic = has_hidden_link(obuf, 109);
        if(hidden_italic != 0) {
            if(hidden == 0 || hidden_italic < hidden) {
                hidden = hidden_italic;
            }
        }
    }
    if((obuf->fontstat[1] & 255) != 0) {
        hidden_under = has_hidden_link(obuf, 65);
        if(hidden_under != 0) {
            if(hidden == 0 || hidden_under < hidden) {
                hidden = hidden_under;
            }
        }
    }
    if((obuf->fontstat[3] & 255) != 0) {
        hidden_strike = has_hidden_link(obuf, 105);
        if(hidden_strike != 0) {
            if(hidden == 0 || hidden_strike < hidden) {
                hidden = hidden_strike;
            }
        }
    }
    if((obuf->fontstat[4] & 255) != 0) {
        hidden_ins = has_hidden_link(obuf, 63);
        if(hidden_ins != 0) {
            if(hidden == 0 || hidden_ins < hidden) {
                hidden = hidden_ins;
            }
        }
    }
    if(hidden != 0) {
        pass = Strnew_charp(hidden);
        Strshrink(line, line->ptr + line->length - hidden);
    }
    if((obuf->flag & 527) == 0) {
        if((obuf->pos & 65535) > width) {
            tp = line->ptr + obuf->bp.len - obuf->bp.tlen;
            ep = line->ptr + line->length;
            if(obuf->bp == (obuf->pos & 65535)) {
                if(tp <= ep) {
                    if(line->ptr < tp) {
                        if(( *(tp - 1) & 255) == 32) {
                            _v532 = ep - tp + 1;
                            _v536 = tp - 1;
                             *__esp = tp;
                            bcopy();
                            line->length = line->length - 1;
                            obuf->pos = (obuf->pos & 65535) - 1;
                        }
                    }
                }
            }
        }
    }
    if(obuf->anchor != 0) {
        if(hidden_anchor == 0) {
            Strcat_charp(line, 135043896);
        }
    }
    if(obuf->img_alt != 0) {
        if(hidden_img == 0) {
            Strcat_charp(line, "</img_alt>");
        }
    }
    if((obuf->fontstat & 255) != 0 && hidden_bold == 0) {
        Strcat_charp(line, "</b>");
    }
    if((obuf->fontstat[2] & 255) != 0 && hidden_italic == 0) {
        Strcat_charp(line, "</i>");
    }
    if((obuf->fontstat[1] & 255) != 0 && hidden_under == 0) {
        Strcat_charp(line, "</u>");
    }
    if((obuf->fontstat[3] & 255) != 0 && hidden_strike == 0) {
        Strcat_charp(line, "</s>");
    }
    if((obuf->fontstat[4] & 255) != 0 && hidden_ins == 0) {
        Strcat_charp(line, "</ins>");
    }
    if((obuf->top_margin & 65535) <= 0) {
L75:
        if(force == 1 || (obuf->flag & 32768) != 0) {
            lbuf = newTextLine(line, obuf->pos & 65535);
            if((obuf->flag & 112) != 32) {
                if((obuf->flag & 112) != 64) {
                    if((obuf->flag & 112) == 16 && (obuf->flag & 131072) != 0) {
                        align(lbuf, width, 1);
                    }
                } else {
                    align(lbuf, width, 2);
                }
            } else {
                align(lbuf, width, 0);
            }
            if((lbuf->pos & 65535) > h_env->maxlimit) {
                h_env->maxlimit = lbuf->pos & 65535;
            }
            if(buf == 0) {
                if(f != 0) {
                    if((ExtHalfdump & 255) == 0) {
                        _t818 = lbuf->line;
                    } else {
                        _t818 = wc_Str_conv(lbuf->line, InnerCharset, DisplayCharset);
                    }
                    _t1002 = _t818->length;
                    if((ExtHalfdump & 255) == 0) {
                        _t822 = lbuf->line;
                    } else {
                        _t822 = wc_Str_conv(lbuf->line, InnerCharset, DisplayCharset);
                    }
                    _v528 = f;
                    _v532 = _t1002;
                    _v536 = 1;
                     *__esp = _t822->ptr;
                    fwrite();
                    _v536 = f;
                     *__esp = 10;
                    fputc();
                }
            } else {
                pushValue(buf, lbuf);
            }
            if((obuf->flag & 655) != 0 || (obuf->flag & 32768) != 0) {
                h_env->blank_lines = 0;
            } else {
                h_env->blank_lines =  &(h_env->blank_lines->first);
            }
            goto L120;
        } else {
            p = line->ptr;
            tmp = Strnew();
            tmp2 = Strnew();
            while(( *p & 255) != 0) {
                q = p;
                if(sloppy_parse_line( &p) != 0) {
                    Strcat_charp_n(tmp, q, p - q);
                    if(force != 2) {
                        Strcat(tmp2, tmp);
                    } else {
                        if(buf == 0) {
                            if(f != 0) {
                                _v528 = f;
                                _v532 = tmp->length;
                                _v536 = 1;
                                 *__esp = tmp->ptr;
                                fwrite();
                            }
                        } else {
                            appendTextLine(buf, tmp, 0);
                        }
                    }
                    Strclear(tmp);
                }
            }
            if(force != 2) {
                if(pass != 0) {
                    Strcat(tmp2, pass);
                }
                pass = tmp2;
            } else {
                if(pass != 0) {
                    if(buf == 0) {
                        if(f != 0) {
                            _v528 = f;
                            _v532 = pass->length;
                            _v536 = 1;
                             *__esp = pass->ptr;
                            fwrite();
                        }
                    } else {
                        appendTextLine(buf, pass, 0);
                    }
                }
                pass = 0;
            }
L120:
            if((obuf->bottom_margin & 65535) <= 0) {
L129:
                if((obuf->top_margin & 65535) < 0) {
                    return;
                }
                if((obuf->bottom_margin & 65535) < 0) {
L170:
                    return;
                }
                obuf->line = Strnew_size(256);
                obuf->pos = 0;
                obuf->top_margin = 0;
                obuf->bottom_margin = 0;
                Strcopy_charp_n(obuf->prevchar, " ", 1);
                obuf->bp.init_flag = 1;
                obuf->flag = obuf->flag & 127;
                set_breakpoint(obuf, 0);
                obuf->prev_ctype = 0;
                link_stack = 0;
                fillline(obuf, indent);
                if(pass != 0) {
                    passthrough(obuf, pass->ptr, 0);
                }
                if(hidden_anchor == 0 && obuf->anchor != 0) {
                    if(obuf->anchor.hseq > 0) {
                        obuf->anchor.hseq =  ~(obuf->anchor.hseq);
                    }
                    _v536 = obuf->anchor.hseq;
                    tmp = Sprintf("<A HSEQ="%d" HREF="");
                    Strcat_charp(tmp, html_quote(obuf->anchor));
                    if(obuf->anchor.target != 0) {
                        Strcat_charp(tmp, "" TARGET="");
                        Strcat_charp(tmp, html_quote(obuf->anchor.target));
                    }
                    if(obuf->anchor.referer != 0) {
                        Strcat_charp(tmp, "" REFERER="");
                        Strcat_charp(tmp, html_quote(obuf->anchor.referer));
                    }
                    if(obuf->anchor.title != 0) {
                        Strcat_charp(tmp, "" TITLE="");
                        Strcat_charp(tmp, html_quote(obuf->anchor.title));
                    }
                    if((obuf->anchor.accesskey & 255) != 0) {
                        c =  *( &HTML_QUOTE_MAP + ( *( &QUOTE_MAP + (obuf->anchor.accesskey & 0xff)) & 7) * 4);
                        Strcat_charp(tmp, "" ACCESSKEY="");
                        if(c == 0) {
                            if(tmp->length + 1 >= tmp->area_size) {
                                Strgrow(tmp);
                            }
                            _t744 = tmp->length;
                             *((char*)(tmp->ptr + _t744)) = obuf->anchor.accesskey & 255;
                            tmp->length = _t744 + 1;
                             *((char*)(tmp->ptr + tmp->length)) = 0;
                        } else {
                            Strcat_charp(tmp, c);
                        }
                    }
                    Strcat_charp(tmp, "">");
                    push_tag(obuf, tmp->ptr, 1);
                }
                if(hidden_img == 0 && obuf->img_alt != 0) {
                    tmp = Strnew_charp("<IMG_ALT SRC="");
                    Strcat_charp(tmp, html_quote( *(obuf->img_alt)));
                    Strcat_charp(tmp, "">");
                    push_tag(obuf, tmp->ptr, 136);
                }
                if(hidden_bold == 0 && (obuf->fontstat & 255) != 0) {
                    push_tag(obuf, "<B>", 7);
                }
                if(hidden_italic == 0 && (obuf->fontstat[2] & 255) != 0) {
                    push_tag(obuf, "<I>", 109);
                }
                if(hidden_under == 0 && (obuf->fontstat[1] & 255) != 0) {
                    push_tag(obuf, "<U>", 65);
                }
                if(hidden_strike == 0 && (obuf->fontstat[3] & 255) != 0) {
                    push_tag(obuf, "<S>", 105);
                }
                if(hidden_ins != 0 || (obuf->fontstat[4] & 255) == 0) {
                    goto L170;
                } else {
                    push_tag(obuf, "<INS>", 63);
                    return;
                }
            }
            init_henv( &(h.obuf),  &(o.line),  &e, 1, 0, width, indent);
            o.line = Strnew_size(width + 20);
            o.pos = obuf->pos & 65535;
            o.flag = obuf->flag;
            o.top_margin = 65535;
            o.bottom_margin = 65535;
            Strcat_charp(o.line, "<pre_int>");
            i = 0;
            while((o.pos & 65535) > i) {
                if(o.line->length + 1 >= o.line->area_size) {
                    Strgrow(o.line);
                }
                _t794 = o.line;
                _t1036 = _t794->length;
                 *((char*)(o.line->ptr + _t1036)) = 32;
                _t794->length = _t1036 + 1;
                 *((char*)(o.line->ptr + o.line->length)) = 0;
                i = i + 1;
            }
            Strcat_charp(o.line, "</pre_int>");
            i = 0;
            while((obuf->bottom_margin & 65535) > i) {
                flushline(h_env,  &(o.line), indent, force, width);
                i = i + 1;
            }
            goto L129;
        }
    } else {
        init_henv( &(h.obuf),  &(o.line),  &e, 1, 0, width, indent);
        o.line = Strnew_size(width + 20);
        o.pos = obuf->pos & 65535;
        o.flag = obuf->flag;
        o.top_margin = 65535;
        o.bottom_margin = 65535;
        Strcat_charp(o.line, "<pre_int>");
        i = 0;
        while((o.pos & 65535) > i) {
            if(o.line->length + 1 >= o.line->area_size) {
                Strgrow(o.line);
            }
            _t897 = o.line;
            _t1049 = _t897->length;
             *((char*)(o.line->ptr + _t1049)) = 32;
            _t897->length = _t1049 + 1;
             *((char*)(o.line->ptr + o.line->length)) = 0;
            i = i + 1;
        }
        Strcat_charp(o.line, "</pre_int>");
        i = 0;
        while((obuf->top_margin & 65535) > i) {
            flushline(h_env,  &(o.line), indent, force, width);
            i = i + 1;
        }
        goto L75;
    }
}

void do_blankline(struct html_feed_environ* h_env, struct readbuffer* obuf, int indent, int indent_incr, int width)
{// addr = 0x08061711  --  defined in 'file.c' at line 3029
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(h_env->blank_lines == 0) {
        flushline(h_env, obuf, indent, 1, width);
        return;
    }
}

void purgeline(struct html_feed_environ* h_env)
{// addr = 0x0806174B  --  defined in 'file.c' at line 3037
    char* p;                               // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    Str tmp;               // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(h_env->buf == 0) {
        return;
    }
    if(h_env->blank_lines != 0) {
        p =  *( *(rpopValue(h_env->buf)));
        tmp = Strnew();
        while(( *p & 255) != 0) {
            q = p;
            if(sloppy_parse_line( &p) != 0) {
                Strcat_charp_n(tmp, q, p - q);
            }
        }
        appendTextLine(h_env->buf, tmp, 0);
        h_env->blank_lines = h_env->blank_lines - 1;
        return;
    }
}

int close_effect0(struct readbuffer* obuf, int cmd)
{// addr = 0x08061803  --  defined in 'file.c' at line 3058
    int i;                                 // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    signed int _v36;                       // _cfa_ffffffdc (outparam)
    struct cmdtable*** _v40;   // _cfa_ffffffd8 (outparam)

    i = obuf->tag_sp - 1;
    while(i >= 0) {
        if( *((intOrPtr*)( *((intOrPtr*)(obuf + (i + 72) * 4)) + 4)) == cmd) {
L6:
            if(i < 0) {
                p = has_hidden_link(obuf, cmd);
                if(p == 0) {
                    return 0;
                }
                passthrough(obuf, p, 1);
                return 1;
            }
            obuf->tag_sp = obuf->tag_sp - 1;
            _v36 = (obuf->tag_sp - i) * 4;
            _v40 =  &(( &(obuf->tag_stack))[i]);
             *__esp =  &(( &(obuf->tag_stack))[i + 1]);
            bcopy();
            return 1;
        }
        i = i - 1;
    }
    goto L6;
}

void close_anchor(struct html_feed_environ* h_env, struct readbuffer* obuf)
{// addr = 0x080618EE  --  defined in 'file.c' at line 3081
    int i;                                 // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    int is_erased;                         // _cfa_ffffffe8
    signed int _v36;                       // _cfa_ffffffdc (outparam)
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    struct _Str* _t142;   // _t142
    int _t185;                             // _t185

    if(obuf->anchor == 0) {
L25:
        _v40 = 60;
         *__esp =  &(obuf->anchor);
        bzero();
        return;
    } else {
        p = 0;
        is_erased = 0;
        i = obuf->tag_sp - 1;
        while(i >= 0) {
            if( *((intOrPtr*)( *((intOrPtr*)(obuf + (i + 72) * 4)) + 4)) == 1) {
L7:
                if(i < 0 && obuf->anchor.hseq > 0 && obuf->line->length > 0 && ( *( *(obuf->line) + obuf->line->length - 1) & 255) == 32) {
                    Strshrink(obuf->line, 1);
                    obuf->pos = (obuf->pos & 65535) - 1;
                    is_erased = 1;
                }
                if(i >= 0) {
L14:
                    if(obuf->anchor.hseq <= 0) {
                        if(i < 0) {
                            passthrough(obuf, p, 1);
                        } else {
                            obuf->tag_sp = obuf->tag_sp - 1;
                            _v36 = (obuf->tag_sp - i) * 4;
                            _v40 =  &(obuf->tag_stack) + (i << 2);
                             *__esp =  &(obuf->tag_stack) + (i + 1 << 2);
                            bcopy();
                        }
                        _v40 = 60;
                         *__esp =  &(obuf->anchor);
                        bzero();
                        return;
                    }
                    HTMLlineproc0(135044067, h_env, 1);
                    Strcopy_charp_n(obuf->prevchar, " ", 1);
                    is_erased = 0;
                    goto L20;
                } else {
                    p = has_hidden_link(obuf, 1);
                    if(p == 0) {
L20:
                        if(is_erased != 0) {
                            if(obuf->line->length + 1 >= obuf->line->area_size) {
                                Strgrow(obuf->line);
                            }
                            _t142 = obuf->line;
                            _t185 = _t142->length;
                             *((char*)( *(obuf->line) + _t185)) = 32;
                            _t142->length = _t185 + 1;
                             *((char*)( *(obuf->line) + obuf->line->length)) = 0;
                            obuf->pos = (obuf->pos & 65535) + 1;
                        }
                        push_tag(obuf, 135043896, 2);
                        goto L25;
                    }
                    goto L14;
                }
            } else {
                i = i - 1;
                continue;
            }
        }
        goto L7;
    }
}

void save_fonteffect(struct html_feed_environ* h_env, struct readbuffer* obuf)
{// addr = 0x08061B5C  --  defined in 'file.c' at line 3128
    intOrPtr _v20;                         // _cfa_ffffffec (outparam)
    intOrPtr _v24;                         // _cfa_ffffffe8 (outparam)

    if(obuf->fontstat_sp <= 4) {
        _v20 = 7;
        _v24 =  &(obuf->fontstat_stack) + (obuf->fontstat_sp << 3) - obuf->fontstat_sp;
         *__esp =  &(obuf->fontstat);
        bcopy();
    }
    obuf->fontstat_sp = obuf->fontstat_sp + 1;
    if((obuf->fontstat & 255) != 0) {
        push_tag(obuf, "</b>", 8);
    }
    if((obuf->fontstat[2] & 255) != 0) {
        push_tag(obuf, "</i>", 110);
    }
    if((obuf->fontstat[1] & 255) != 0) {
        push_tag(obuf, "</u>", 66);
    }
    if((obuf->fontstat[3] & 255) != 0) {
        push_tag(obuf, "</s>", 106);
    }
    if((obuf->fontstat[4] & 255) != 0) {
        push_tag(obuf, "</ins>", 64);
    }
    _v24 = 7;
     *__esp =  &(obuf->fontstat);
    bzero();
}

void restore_fonteffect(struct html_feed_environ* h_env, struct readbuffer* obuf)
{// addr = 0x08061CA6  --  defined in 'file.c' at line 3148
    int _v20;                              // _cfa_ffffffec (outparam)
    char** _v24;                           // _cfa_ffffffe8 (outparam)

    if(obuf->fontstat_sp > 0) {
        obuf->fontstat_sp = obuf->fontstat_sp - 1;
    }
    if(obuf->fontstat_sp <= 4) {
        _v20 = 7;
        _v24 =  &(obuf->fontstat);
         *__esp =  &(obuf->fontstat_stack) + (obuf->fontstat_sp << 3) - obuf->fontstat_sp;
        bcopy();
    }
    if((obuf->fontstat & 255) != 0) {
        push_tag(obuf, 135044069, 7);
    }
    if((obuf->fontstat[2] & 255) != 0) {
        push_tag(obuf, 135044073, 109);
    }
    if((obuf->fontstat[1] & 255) != 0) {
        push_tag(obuf, 135044077, 65);
    }
    if((obuf->fontstat[3] & 255) != 0) {
        push_tag(obuf, 135044081, 105);
    }
    if((obuf->fontstat[4] & 255) != 0) {
        push_tag(obuf, 135044085, 63);
        return;
    }
}

Str process_title(struct parsed_tag* tag)
{// addr = 0x08061DEB  --  defined in 'file.c' at line 3168
    cur_title = Strnew();
    return 0;
}

Str process_n_title(struct parsed_tag* tag)
{// addr = 0x08061E02  --  defined in 'file.c' at line 3175
    Str tmp;               // _cfa_fffffff0
    struct _Str* _v32;    // _cfa_ffffffe0
    char* _v36;                            // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char* _t11;                            // _t11

    if(cur_title != 0) {
        Strremovefirstspaces(cur_title);
        Strremovetrailingspaces(cur_title);
        _t11 = html_quote(cur_title->ptr);
        _v32 = 0;
        _v36 = "">";
        _v40 = _t11;
        tmp = Strnew_m_charp("<title_alt title="");
        cur_title = 0;
        return tmp;
    }
    return 0;
}

void feed_title(char* str)
{// addr = 0x08061E73  --  defined in 'file.c' at line 3190
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    char* __ebx;                           // r1

    __eax = cur_title;
    if(cur_title == 0) {
        return;
    }
    while(1) {
        str =  *str & 255;
        if(__al == 0) {
            break;
        }
        str =  *str & 255;
        if(__al != 38) {
            str =  *str & 255;
            if(__al == 10) {
L6:
                cur_title = cur_title->length;
                __edx = cur_title->length + 1;
                cur_title = cur_title->area_size;
                if(cur_title->length + 1 >= cur_title->area_size) {
                    __eax = cur_title;
                    Strgrow(cur_title);
                }
                __eax = cur_title;
                __ebx = cur_title->ptr;
                __eax = cur_title;
                __edx = __eax[4];
                __edx =  &(__edx[cur_title->ptr]);
                __edx[cur_title->ptr] = 32;
                __eax[4] = __edx;
                __eax = cur_title;
                __edx = cur_title->ptr;
                cur_title = cur_title->length;
                __eax = cur_title->ptr + cur_title->length;
                 *(cur_title->ptr + cur_title->length) = 0;
                str =  &(str[1]);
                str =  &(str[1]);
            } else {
                str =  *str & 255;
                if(__al != 13) {
                    cur_title = cur_title->length;
                    __edx = cur_title->length + 1;
                    cur_title = cur_title->area_size;
                    if(cur_title->length + 1 >= cur_title->area_size) {
                        __eax = cur_title;
                        Strgrow(cur_title);
                    }
                    __eax = cur_title;
                    __ebx = cur_title->ptr;
                    __eax = cur_title;
                    __ecx = __eax[4];
                    __edx = __ecx;
                    __edx = str;
                     *((char*)(cur_title->ptr + __ecx)) = __bl;
                    __eax[4] = __ecx;
                    __eax =  &(__edx[1]);
                    str =  &(__edx[1]);
                    __eax = cur_title;
                    __edx = cur_title->ptr;
                    cur_title = cur_title->length;
                    __eax = cur_title->ptr + cur_title->length;
                     *(cur_title->ptr + cur_title->length) = 0;
                } else {
                    goto L6;
                }
            }
        } else {
            __eax =  &str;
            __eax = getescapecmd( &str);
            __edx = cur_title;
            Strcat_charp(cur_title, __eax);
        }
    }
}

Str process_img(struct parsed_tag* tag, int width)
{// addr = 0x08061FA7  --  defined in 'file.c' at line 3207
    char* p;                               // _cfa_ffffffe0
    char* q;                               // _cfa_ffffffdc
    char* r;                               // _cfa_ffffffd8
    char* r2;                              // _cfa_ffffffd4
    char* s;                               // _cfa_ffffffd0
    char* t;                               // _cfa_ffffffcc
    int w;                                 // _cfa_ffffffc8
    int i;                                 // _cfa_ffffffc4
    int nw;                                // _cfa_ffffffc0
    int ni;                                // _cfa_ffffffbc
    int n;                                 // _cfa_ffffffb8
    int w0;                                // _cfa_ffffffb4
    int i0;                                // _cfa_ffffffb0
    int align;                             // _cfa_ffffffac
    int xoffset;                           // _cfa_ffffffa8
    int yoffset;                           // _cfa_ffffffa4
    int top;                               // _cfa_ffffffa0
    int bottom;                            // _cfa_ffffff9c
    int ismap;                             // _cfa_ffffff98
    int use_image;                         // _cfa_ffffff94
    int pre_int;                           // _cfa_ffffff90
    int ext_pre_int;                       // _cfa_ffffff8c
    Str tmp;               // _cfa_ffffff88
    Str tmp2;              // _cfa_ffffff84
    char* r;                               // _cfa_ffffff80
    int _v132;                             // _cfa_ffffff7c
    short _v154;                           // _cfa_ffffff66
    short _v156;                           // _cfa_ffffff64
    char* _v160;                           // _cfa_ffffff60
    Image image;         // _cfa_ffffff5c
    char* _v184;                           // _cfa_ffffff48
    ParsedURL u;     // _cfa_ffffff34
    int _v208;                             // _cfa_ffffff30
    _unknown_ _v210;                       // _cfa_ffffff2e
    short _v212;                           // _cfa_ffffff2c
    _unknown_ _v224;                       // _cfa_ffffff20 (outparam)
    int _v228;                             // _cfa_ffffff1c (outparam)
    int _v232;                             // _cfa_ffffff18 (outparam)
    int _t545;                             // _t545
    int _t561;                             // _t561
    struct parsed_tag* _t568;   // _t568
    int _t574;                             // _t574
    char* _t590;                           // _t590
    int _t595;                             // _t595
    Str _t596;             // _t596
    int _t600;                             // _t600
    signed int _t611;                      // _t611
    int _t616;                             // _t616
    Str _t617;             // _t617
    int _t621;                             // _t621
    char* _t630;                           // _t630
    int _t637;                             // _t637
    Str _t638;             // _t638
    int _t642;                             // _t642
    int _t659;                             // _t659
    Str _t660;             // _t660
    int _t664;                             // _t664
    char* _t674;                           // _t674
    char* _t678;                           // _t678
    int _t695;                             // _t695
    int _t697;                             // _t697
    signed int _t718;                      // _t718
    signed char _t720;                     // _t720
    signed int _t721;                      // _t721
    signed int _t731;                      // _t731
    signed char _t733;                     // _t733
    signed int _t734;                      // _t734
    int _t752;                             // _t752
    char* _t761;                           // _t761
    int _t837;                             // _t837
    int _t847;                             // _t847
    int _t849;                             // _t849
    int _t850;                             // _t850
    int _t868;                             // _t868
    int _t870;                             // _t870
    char* _t883;                           // _t883
    int _t888;                             // _t888
    char* _t891;                           // _t891
    int _t895;                             // _t895
    int _t905;                             // _t905
    struct parsed_tag* _t909;   // _t909
    signed int _t918;                      // _t918
    int _t923;                             // _t923
    struct parsed_tag* _t927;   // _t927
    struct parsed_tag* _t929;   // _t929
    signed int _t938;                      // _t938
    int _t1003;                            // _t1003
    int _t1004;                            // _t1004
    unsigned char* _t1009;                 // _t1009
    unsigned char* _t1010;                 // _t1010

    r2 = 0;
    ni = 1;
    w0 = -1;
    i0 = -1;
    ismap = 0;
    if(activeImage == 0 || displayImage == 0) {
        _t545 = 0;
    } else {
        _t545 = 1;
    }
    use_image = _t545;
    pre_int = 0;
    ext_pre_int = 0;
    tmp = Strnew();
    if(parsedtag_get_value(tag, 31,  &p) == 0) {
        return tmp;
    }
    p = remove_space(p);
    q = 0;
    parsedtag_get_value(tag, 5,  &q);
    t = q;
    parsedtag_get_value(tag, 49,  &t);
    w = -1;
    _t561 = parsedtag_get_value(tag, 38,  &w);
    __eflags = _t561;
    if(_t561 != 0) {
        __eflags = w;
        if(w < 0) {
            __eflags = width;
            if(width <= 0) {
                w = -1;
            } else {
                _v208 =  ~width;
                asm("fild dword [ebp-0xcc]");
                asm("fmulp st1, st0");
                _v208 = w;
                asm("fild dword [ebp-0xcc]");
                asm("fmulp st1, st0");
                asm("fdivp st1, st0");
                asm("faddp st1, st0");
                asm("fnstcw word [ebp-0xce]");
                _v212 = 12;
                asm("fldcw word [ebp-0xd0]");
                asm("fistp dword [ebp-0xcc]");
                asm("fldcw word [ebp-0xce]");
                w = _v208;
            }
        }
        __eflags = use_image;
        if(use_image != 0) {
            __eflags = w;
            if(w > 0) {
                _v208 = w;
                asm("fild dword [ebp-0xcc]");
                asm("fmulp st1, st0");
                asm("fdivp st1, st0");
                asm("faddp st1, st0");
                asm("fnstcw word [ebp-0xce]");
                _v212 = 12;
                asm("fldcw word [ebp-0xd0]");
                asm("fistp dword [ebp-0xcc]");
                asm("fldcw word [ebp-0xce]");
                w = _v208;
                __eflags = w;
                if(w != 0) {
                    __eflags = w - 2048;
                    if(w > 2048) {
                        w = 2048;
                    }
                } else {
                    w = 1;
                }
            }
        }
    }
    __eflags = use_image;
    if(use_image == 0) {
        parsedtag_get_value(tag, 17,  &i);
        goto L30;
    } else {
        i = -1;
        _t923 = parsedtag_get_value(tag, 17,  &i);
        __eflags = _t923;
        if(_t923 != 0) {
            __eflags = i;
            if(i <= 0) {
                i = -1;
            } else {
                _v208 = i;
                asm("fild dword [ebp-0xcc]");
                asm("fmulp st1, st0");
                asm("fdivp st1, st0");
                asm("faddp st1, st0");
                asm("fnstcw word [ebp-0xce]");
                _v212 = 12;
                asm("fldcw word [ebp-0xd0]");
                asm("fistp dword [ebp-0xcc]");
                asm("fldcw word [ebp-0xce]");
                i = _v208;
                __eflags = i;
                if(i != 0) {
                    __eflags = i - 2048;
                    if(i > 2048) {
                        i = 2048;
                    }
                } else {
                    i = 1;
                }
            }
        }
        align = -1;
        parsedtag_get_value(tag, 4,  &align);
        ismap = 0;
        _t927 = tag;
        __eflags = _t927->map;
        if(_t927->map != 0) {
            _t929 = tag;
            __eflags = (_t929->map[0x2e] & 255) - 75;
            if((_t929->map[0x2e] & 255) != 75) {
                _t1010 = tag->attrid;
                _t938 = tag->map[0x2e] & 0xff;
                __eflags = _t1010[_t938] & 255;
                if((_t1010[_t938] & 255) != 0) {
                    ismap = 1;
                }
            }
        }
L30:
        r = 0;
        parsedtag_get_value(tag, 34,  &r);
        _t568 = tag;
        __eflags = _t568->map;
        if(_t568->map != 0) {
            _t909 = tag;
            __eflags = (_t909->map[0x4a] & 255) - 75;
            if((_t909->map[0x4a] & 255) != 75) {
                _t1009 = tag->attrid;
                _t918 = tag->map[0x4a] & 0xff;
                __eflags = _t1009[_t918] & 255;
                if((_t1009[_t918] & 255) != 0) {
                    ext_pre_int = 1;
                }
            }
        }
        tmp = Strnew_size(128);
        __eflags = use_image;
        if(use_image != 0) {
            _t905 = align;
            __eflags = _t905 - 1;
            if(_t905 == 1) {
                Strcat_charp(tmp, "<div_int align=left>");
            } else {
                __eflags = _t905 - 2;
                if(_t905 == 2) {
                    Strcat_charp(tmp, "<div_int align=right>");
                } else {
                    __eflags = _t905;
                    if(_t905 == 0) {
                        Strcat_charp(tmp, "<div_int align=center>");
                    }
                }
            }
        }
        __eflags = r;
        if(r != 0) {
            _t883 = r;
            _v232 = 35;
             *__esp = _t883;
            strchr();
            r2 = _t883;
            s = "<form_int method=internal action=map>";
            tmp2 = process_form(parse_tag( &s, 1));
            __eflags = tmp2;
            if(tmp2 != 0) {
                Strcat(tmp, tmp2);
            }
            __eflags = form_sp;
            if(form_sp < 0) {
                _t888 = -1;
            } else {
                _t888 = form_stack[form_sp];
            }
            _v232 = _t888;
            Strcat(tmp, Sprintf("<input_alt fid="%d" type=hidden name=link value=""));
            __eflags = r2;
            if(r2 == 0) {
                _t891 = r;
            } else {
                _t891 =  &(r2[1]);
            }
            Strcat_charp(tmp, html_quote(_t891));
            __eflags = form_sp;
            if(form_sp < 0) {
                _t895 = -1;
            } else {
                _t895 = form_stack[form_sp];
            }
            _t1003 = cur_hseq;
            _t1004 = _t1003 + 1;
            __eflags = _t1004;
            cur_hseq = _t1004;
            _v228 = _t895;
            _v232 = _t1003;
            Strcat(tmp, Sprintf(""><input_alt hseq="%d" fid="%d" type=submit no_effect=true>"));
        }
        __eflags = use_image;
        if(use_image == 0) {
            __eflags = w;
            if(w < 0) {
                asm("fmulp st1, st0");
                asm("fnstcw word [ebp-0xce]");
                _v212 = 12;
                asm("fldcw word [ebp-0xd0]");
                asm("fistp dword [ebp-0xcc]");
                asm("fldcw word [ebp-0xce]");
                w = _v208;
            }
            __eflags = w;
            if(w == 0) {
                _t574 = 1;
            } else {
                _v208 = w - 1;
                asm("fild dword [ebp-0xcc]");
                asm("fdivp st1, st0");
                asm("fld1");
                asm("faddp st1, st0");
                asm("fnstcw word [ebp-0xce]");
                _v212 = 12;
                asm("fldcw word [ebp-0xd0]");
                asm("fistp dword [ebp-0xcc]");
                asm("fldcw word [ebp-0xce]");
                _t574 = _v208;
            }
            nw = _t574;
            __eflags = r;
            if(r != 0) {
                Strcat_charp(tmp, "<pre_int>");
                pre_int = 1;
            }
            Strcat_charp(tmp, "<img_alt src="");
            goto L83;
        } else {
            w0 = w;
            i0 = i;
            __eflags = w;
            if(w < 0) {
L58:
                parseURL2( *(wc_Str_conv(Strnew_charp(p), InnerCharset, cur_document_charset & 255)),  &u, cur_baseURL);
                image.url =  *(parsedURL2Str( &u));
                _t837 = uncompressed_file_type(_v184,  &( &image->ext));
                __eflags = _t837;
                if(_t837 == 0) {
                    _v160 = filename_extension(_v184, 1);
                }
                _v132 = 0;
                _v156 = w;
                _v154 = i;
                _v132 = getImage( &image, cur_baseURL, 1);
                __eflags = _v132;
                if(_v132 != 0) {
                    _t868 = _v132;
                    __eflags =  *(_t868 + 28) & 65535;
                    if(( *(_t868 + 28) & 65535) > 0) {
                        _t870 = _v132;
                        __eflags =  *(_t870 + 30) & 65535;
                        if(( *(_t870 + 30) & 65535) > 0) {
                            w0 =  *(_v132 + 28) & 65535;
                            w = w0;
                            i0 =  *(_v132 + 30) & 65535;
                            i = i0;
                        }
                    }
                }
                __eflags = w;
                if(w < 0) {
                    asm("fmulp st1, st0");
                    asm("fnstcw word [ebp-0xce]");
                    _v212 = 12;
                    asm("fldcw word [ebp-0xd0]");
                    asm("fistp dword [ebp-0xcc]");
                    asm("fldcw word [ebp-0xce]");
                    w = _v208;
                }
                __eflags = i;
                if(i < 0) {
                    asm("fnstcw word [ebp-0xce]");
                    _v212 = 12;
                    asm("fldcw word [ebp-0xd0]");
                    asm("fistp dword [ebp-0xcc]");
                    asm("fldcw word [ebp-0xce]");
                    i = _v208;
                }
L68:
                __eflags = w - 3;
                if(w <= 3) {
                    _t847 = 1;
                } else {
                    _v208 = w - 3;
                    asm("fild dword [ebp-0xcc]");
                    asm("fdivp st1, st0");
                    asm("fld1");
                    asm("faddp st1, st0");
                    asm("fnstcw word [ebp-0xce]");
                    _v212 = 12;
                    asm("fldcw word [ebp-0xd0]");
                    asm("fistp dword [ebp-0xcc]");
                    asm("fldcw word [ebp-0xce]");
                    _t847 = _v208;
                }
                nw = _t847;
                __eflags = i - 3;
                if(i <= 3) {
                    _t849 = 1;
                } else {
                    _v208 = i - 3;
                    asm("fild dword [ebp-0xcc]");
                    asm("fdivp st1, st0");
                    asm("fld1");
                    asm("faddp st1, st0");
                    asm("fnstcw word [ebp-0xce]");
                    _v212 = 12;
                    asm("fldcw word [ebp-0xd0]");
                    asm("fistp dword [ebp-0xcc]");
                    asm("fldcw word [ebp-0xce]");
                    _t849 = _v208;
                }
                ni = _t849;
                _t850 = cur_iseq;
                cur_iseq = _t850 + 1;
                _v232 = _t850;
                Strcat(tmp, Sprintf("<pre_int><img_alt hseq="%d" src=""));
                pre_int = 1;
L83:
                Strcat_charp(tmp, html_quote(p));
                Strcat_charp(tmp, 135044377);
                __eflags = t;
                if(t != 0) {
                    Strcat_charp(tmp, " title="");
                    Strcat_charp(tmp, html_quote(t));
                    Strcat_charp(tmp, 135044377);
                }
                __eflags = use_image;
                if(use_image == 0) {
L119:
                    Strcat_charp(tmp, 135044483);
                    __eflags = q;
                    if(q != 0) {
                        __eflags =  *q & 255;
                        if(( *q & 255) == 0) {
                            __eflags = ignore_null_img_alt;
                            if(ignore_null_img_alt != 0) {
                                q = 0;
                            }
                        }
                    }
                    __eflags = q;
                    if(q == 0) {
                        __eflags = w;
                        if(w <= 0) {
L160:
                            q = p;
                            while(1) {
                                __eflags =  *q & 255;
                                if(( *q & 255) == 0) {
                                    break;
                                }
                                _t590 =  &(q[1]);
                                __eflags = _t590;
                                q = _t590;
                            }
                            while(1) {
                                __eflags = q - p;
                                if(q <= p) {
                                    break;
                                }
                                __eflags = ( *q & 255) - 47;
                                if(( *q & 255) != 47) {
                                    _t678 = q - 1;
                                    __eflags = _t678;
                                    q = _t678;
                                    continue;
                                }
                                break;
                            }
                            __eflags = ( *q & 255) - 47;
                            if(( *q & 255) == 47) {
                                _t674 =  &(q[1]);
                                __eflags = _t674;
                                q = _t674;
                            }
                            _t595 = tmp->length;
                            _t596 = tmp;
                            __eflags = _t595 + 1 - _t596->area_size;
                            if(_t595 + 1 >= _t596->area_size) {
                                Strgrow(tmp);
                            }
                            _t600 = tmp->length;
                             *((char*)(tmp->ptr + _t600)) = 91;
                            tmp->length = _t600 + 1;
                             *((char*)(tmp->ptr + tmp->length)) = 0;
                            n = 1;
                            p = q;
                            while(1) {
                                __eflags =  *q & 255;
                                if(( *q & 255) == 0) {
                                    break;
                                }
                                _t611 =  *q & 0xff;
                                __eflags =  *( &MYCTYPE_MAP + _t611) & 0xc;
                                if(( *( &MYCTYPE_MAP + _t611) & 0xc) != 0) {
L175:
                                    _t616 = tmp->length;
                                    _t617 = tmp;
                                    __eflags = _t616 + 1 - _t617->area_size;
                                    if(_t616 + 1 >= _t617->area_size) {
                                        Strgrow(tmp);
                                    }
                                    _t621 = tmp->length;
                                     *((char*)(tmp->ptr + _t621)) =  *q & 255;
                                    tmp->length = _t621 + 1;
                                     *((char*)(tmp->ptr + tmp->length)) = 0;
                                    n = n + 1;
                                    __eflags = n + 1 - nw;
                                    if(n + 1 >= nw) {
L183:
                                        _t637 = tmp->length;
                                        _t638 = tmp;
                                        __eflags = _t637 + 1 - _t638->area_size;
                                        if(_t637 + 1 >= _t638->area_size) {
                                            Strgrow(tmp);
                                        }
                                        _t642 = tmp->length;
                                         *((char*)(tmp->ptr + _t642)) = 93;
                                        tmp->length = _t642 + 1;
                                         *((char*)(tmp->ptr + tmp->length)) = 0;
                                        n = n + 1;
                                        __eflags = n;
                                        goto L186;
                                    } else {
                                        _t630 =  &(q[1]);
                                        __eflags = _t630;
                                        q = _t630;
                                        continue;
                                    }
                                }
                                __eflags = ( *q & 255) - 95;
                                if(( *q & 255) == 95) {
                                    goto L175;
                                }
                                __eflags = ( *q & 255) - 45;
                                if(( *q & 255) != 45) {
                                    goto L183;
                                }
                                goto L175;
                            }
                            goto L183;
                        }
                        __eflags = i;
                        if(i <= 0) {
                            goto L160;
                        }
                        __eflags = w - 31;
                        if(w > 31) {
L153:
                            __eflags = w - 200;
                            if(w <= 200) {
                                goto L160;
                            }
                            __eflags = i - 12;
                            if(i > 12) {
                                goto L160;
                            }
                            __eflags = pre_int;
                            if(pre_int == 0) {
                                Strcat_charp(tmp, "<pre_int>");
                                pre_int = 1;
                            }
                            _v208 = w;
                            asm("fild dword [ebp-0xcc]");
                            asm("fdivp st1, st0");
                            _v208 = symbol_width;
                            asm("fild dword [ebp-0xcc]");
                            asm("fdivp st1, st0");
                            asm("fnstcw word [ebp-0xce]");
                            _v212 = 12;
                            asm("fldcw word [ebp-0xd0]");
                            asm("fistp dword [ebp-0xcc]");
                            asm("fldcw word [ebp-0xce]");
                            w = _v208;
                            __eflags = w;
                            if(w <= 0) {
                                w = 1;
                            }
                            push_symbol(tmp, 26, symbol_width, w);
                            n = symbol_width * w;
                            goto L186;
                        }
                        __eflags = i - 47;
                        if(i > 47) {
                            goto L153;
                        }
                        n = 1;
                        _t695 = p;
                        _v232 = 135044485;
                         *__esp = _t695;
                        strcasestr();
                        __eflags = _t695;
                        if(_t695 != 0) {
L147:
                            Strcat_charp(tmp, 135044497);
                            goto L186;
                        }
                        _t697 = p;
                        _v232 = 135044491;
                         *__esp = _t697;
                        strcasestr();
                        __eflags = _t697;
                        if(_t697 == 0) {
                            __eflags = i * w - 127;
                            if(i * w > 127) {
                                __eflags = pre_int;
                                if(pre_int == 0) {
                                    Strcat_charp(tmp, "<pre_int>");
                                    pre_int = 1;
                                }
                                push_symbol(tmp, 44, symbol_width, 1);
                                n = symbol_width;
                            } else {
                                Strcat_charp(tmp, 135044499);
                            }
                            goto L186;
                        }
                        goto L147;
                    } else {
                        n = wtf_strwidth(q);
                        __eflags = use_image;
                        if(use_image == 0) {
                            Strcat_charp(tmp, html_quote(q));
L186:
                            __eflags = use_image;
                            if(use_image == 0) {
L192:
                                Strcat_charp(tmp, "</img_alt>");
                                __eflags = pre_int;
                                if(pre_int != 0) {
                                    __eflags = ext_pre_int;
                                    if(ext_pre_int == 0) {
                                        Strcat_charp(tmp, "</pre_int>");
                                    }
                                }
                                __eflags = r;
                                if(r != 0) {
                                    Strcat_charp(tmp, "</input_alt>");
                                    process_n_form();
                                }
                                __eflags = use_image;
                                if(use_image != 0) {
                                    __eflags = align - 2;
                                    if(align <= 2) {
                                        Strcat_charp(tmp, "</div_int>");
                                    }
                                }
                                return tmp;
                            }
                            while(1) {
                                __eflags = n - nw;
                                if(n >= nw) {
                                    goto L192;
                                }
                                _t659 = tmp->length;
                                _t660 = tmp;
                                __eflags = _t659 + 1 - _t660->area_size;
                                if(_t659 + 1 >= _t660->area_size) {
                                    Strgrow(tmp);
                                }
                                _t664 = tmp->length;
                                 *((char*)(tmp->ptr + _t664)) = 32;
                                tmp->length = _t664 + 1;
                                 *((char*)(tmp->ptr + tmp->length)) = 0;
                                n = n + 1;
                                __eflags = n;
                            }
                            goto L192;
                        }
                        __eflags = n - nw;
                        if(n <= nw) {
                            Strcat_charp(tmp, html_quote(q));
                            goto L186;
                        }
                        r = q;
                        n = 0;
                        while(1) {
                            __eflags = r;
                            if(r == 0) {
                                break;
                            }
                            __eflags =  *135119023 & 255;
                            if(( *135119023 & 255) == 0) {
                                _t718 =  *r & 0xff;
                                __eflags =  *( &WTF_WIDTH_MAP + _t718) & 255;
                                _t720 = ( *( &WTF_WIDTH_MAP + _t718) & 255) != 0;
                                __eflags = _t720;
                                _t721 = _t720 & 255;
                            } else {
                                _t721 =  *( &WTF_WIDTH_MAP + ( *r & 0xff)) & 0xff;
                            }
                            __eflags = _t721 + n - nw;
                            if(_t721 + n > nw) {
L138:
                                Strcat_charp(tmp, html_quote( *(Strnew_charp_n(q, r - q))));
                                goto L186;
                            } else {
                                r =  &(r[ *( &WTF_LEN_MAP + ( *r & 0xff)) & 0xff]);
                                __eflags =  *135119023 & 255;
                                if(( *135119023 & 255) == 0) {
                                    _t731 =  *r & 0xff;
                                    __eflags =  *( &WTF_WIDTH_MAP + _t731) & 255;
                                    _t733 = ( *( &WTF_WIDTH_MAP + _t731) & 255) != 0;
                                    __eflags = _t733;
                                    _t734 = _t733 & 255;
                                } else {
                                    _t734 =  *( &WTF_WIDTH_MAP + ( *r & 0xff)) & 0xff;
                                }
                                n = n + _t734;
                                __eflags = n;
                                continue;
                            }
                        }
                        goto L138;
                    }
                } else {
                    __eflags = w0;
                    if(w0 >= 0) {
                        _v232 = w0;
                        Strcat(tmp, Sprintf(" width=%d"));
                    }
                    __eflags = i0;
                    if(i0 >= 0) {
                        _v232 = i0;
                        Strcat(tmp, Sprintf(" height=%d"));
                    }
                    _t752 = align;
                    __eflags = _t752 - 5;
                    if(_t752 == 5) {
                        top = 0;
                        bottom = ni - 1;
                        yoffset = 0;
                        asm("fnstcw word [ebp-0xce]");
                        _v212 = 12;
                    } else {
                        __eflags = _t752 - 6;
                        if(_t752 == 6) {
                            top = ni - 1;
                            bottom = 0;
                            asm("fild dword [ebp-0x40]");
                            asm("fmulp st1, st0");
                            _v208 = i;
                            asm("fild dword [ebp-0xcc]");
                            asm("fsubp st1, st0");
                            asm("fnstcw word [ebp-0xce]");
                            _v212 = 12;
                            asm("fldcw word [ebp-0xd0]");
                            asm("fistp dword [ebp-0x58]");
                            asm("fldcw word [ebp-0xce]");
L104:
                            asm("fild dword [ebp-0x3c]");
                            asm("fmulp st1, st0");
                            _v208 = w;
                            asm("fild dword [ebp-0xcc]");
                            asm("fsubp st1, st0");
                            asm("fdivp st1, st0");
                            asm("fldcw word [ebp-0xd0]");
                            asm("fistp dword [ebp-0x54]");
                            asm("fldcw word [ebp-0xce]");
                            __eflags = xoffset;
                            if(xoffset != 0) {
                                _v232 = xoffset;
                                Strcat(tmp, Sprintf(" xoffset=%d"));
                            }
                            __eflags = yoffset;
                            if(yoffset != 0) {
                                _v232 = yoffset;
                                Strcat(tmp, Sprintf(" yoffset=%d"));
                            }
                            __eflags = top;
                            if(top != 0) {
                                _v232 = top;
                                Strcat(tmp, Sprintf(" top_margin=%d"));
                            }
                            __eflags = bottom;
                            if(bottom != 0) {
                                _v232 = bottom;
                                Strcat(tmp, Sprintf(" bottom_margin=%d"));
                            }
                            __eflags = r;
                            if(r != 0) {
                                Strcat_charp(tmp, " usemap="");
                                __eflags = r2;
                                if(r2 == 0) {
                                    _t761 = r;
                                } else {
                                    _t761 =  &(r2[1]);
                                }
                                Strcat_charp(tmp, html_quote(_t761));
                                Strcat_charp(tmp, 135044377);
                            }
                            __eflags = ismap;
                            if(ismap != 0) {
                                Strcat_charp(tmp, " ismap");
                            }
                            goto L119;
                        }
                        __eflags = _t752 - 4;
                        if(_t752 == 4) {
                            top = (ni >> 31) + ni >> 1;
                            bottom = top;
                            _t787 = top;
                            __eflags = top + _t787 - ni;
                            if(top + _t787 != ni) {
                                asm("fild dword [ebp-0x40]");
                                asm("fmulp st1, st0");
                                _v208 = i;
                                asm("fild dword [ebp-0xcc]");
                                asm("fsubp st1, st0");
                                asm("fdivp st1, st0");
                                asm("fnstcw word [ebp-0xce]");
                                _v212 = 12;
                                asm("fldcw word [ebp-0xd0]");
                                asm("fistp dword [ebp-0x58]");
                                asm("fldcw word [ebp-0xce]");
                            } else {
                                _v208 = ni + 1;
                                asm("fild dword [ebp-0xcc]");
                                asm("fmulp st1, st0");
                                _v208 = i;
                                asm("fild dword [ebp-0xcc]");
                                asm("fsubp st1, st0");
                                asm("fdivp st1, st0");
                                asm("fnstcw word [ebp-0xce]");
                                _v212 = 12;
                                asm("fldcw word [ebp-0xd0]");
                                asm("fistp dword [ebp-0x58]");
                                asm("fldcw word [ebp-0xce]");
                            }
                            goto L104;
                        }
                        top = ni - 1;
                        bottom = 0;
                        __eflags = ni - 1;
                        if(__eflags != 0) {
L102:
                            asm("fild dword [ebp-0x40]");
                            asm("fmulp st1, st0");
                            _v208 = i;
                            asm("fild dword [ebp-0xcc]");
                            asm("fsubp st1, st0");
                            asm("fnstcw word [ebp-0xce]");
                            _v212 = 12;
                            asm("fldcw word [ebp-0xd0]");
                            asm("fistp dword [ebp-0x58]");
                            asm("fldcw word [ebp-0xce]");
                            __eflags = yoffset - -1;
                            if(yoffset < -1) {
                                yoffset = yoffset + 1;
                                __eflags = yoffset;
                            }
                        } else {
                            asm("fild dword [ebp-0x40]");
                            asm("fmulp st1, st0");
                            _v208 = i;
                            asm("fild dword [ebp-0xcc]");
                            asm("fxch st0, st1");
                            asm("fucomip st0, st1");
                            st0 = pixel_per_line;
                            if(__eflags == 0) {
                                goto L102;
                            }
                            yoffset = 0;
                            asm("fnstcw word [ebp-0xce]");
                            _v212 = 12;
                        }
                    }
                    goto L104;
                }
            }
            __eflags = i;
            if(i >= 0) {
                goto L68;
            }
            goto L58;
        }
    }
}

Str process_anchor(struct parsed_tag* tag, char* tagbuf)
{// addr = 0x08063264  --  defined in 'file.c' at line 3524
    Str tmp;               // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    int _v40;                              // _cfa_ffffffd8 (outparam)
    int _t16;                              // _t16
    int _t23;                              // _t23

    if((tag->need_reconstruct & 255) == 0) {
        _t16 = cur_hseq;
        cur_hseq = _t16 + 1;
        _v40 = _t16;
        tmp = Sprintf("<a hseq="%d"");
        Strcat_charp(tmp,  &(tagbuf[2]));
        return tmp;
    }
    _t23 = cur_hseq;
    cur_hseq = _t23 + 1;
    _v40 = _t23;
    parsedtag_set_value(tag, 69,  *(Sprintf("%d")));
    return parsedtag2str(tag);
}

Str process_input(struct parsed_tag* tag)
{// addr = 0x080632F6  --  defined in 'file.c' at line 3538
    int i;                                 // _cfa_ffffffe0
    int w;                                 // _cfa_ffffffdc
    int v;                                 // _cfa_ffffffd8
    int x;                                 // _cfa_ffffffd4
    int y;                                 // _cfa_ffffffd0
    int z;                                 // _cfa_ffffffcc
    int iw;                                // _cfa_ffffffc8
    int ih;                                // _cfa_ffffffc4
    char* q;                               // _cfa_ffffffc0
    char* p;                               // _cfa_ffffffbc
    char* r;                               // _cfa_ffffffb8
    char* p2;                              // _cfa_ffffffb4
    char* s;                               // _cfa_ffffffb0
    Str tmp;               // _cfa_ffffffac
    char* qq;                              // _cfa_ffffffa8
    int qlen;                              // _cfa_ffffffa4
    char* s;                               // _cfa_ffffffa0
    int _v112;                             // _cfa_ffffff90
    char* _v128;                           // _cfa_ffffff80
    int _v132;                             // _cfa_ffffff7c
    int _v136;                             // _cfa_ffffff78
    char* _v140;                           // _cfa_ffffff74
    char* _v144;                           // _cfa_ffffff70
    int _v148;                             // _cfa_ffffff6c (outparam)
    int _v152;                             // _cfa_ffffff68 (outparam)
    _unknown_ __ebx;                       // r1
    int __edi;                             // r4
    char* __esi;                           // r5
    int _t281;                             // _t281
    int _t284;                             // _t284
    int _t287;                             // _t287
    int _t293;                             // _t293
    int _t300;                             // _t300
    int _t310;                             // _t310
    int _t322;                             // _t322
    int _t329;                             // _t329
    int _t336;                             // _t336
    int _t351;                             // _t351
    signed int _t359;                      // _t359
    signed int _t367;                      // _t367
    int _t413;                             // _t413
    char* _t474;                           // _t474
    int _t486;                             // _t486

    tmp = 0;
    qq = 135041709;
    qlen = 0;
    if(form_sp < 0 || form_stack[form_sp] < 0) {
        s = "<form_int method=internal action=none>";
        tmp = process_form(parse_tag( &s, 1));
    }
    if(tmp == 0) {
        tmp = Strnew();
    }
    p = "text";
    parsedtag_get_value(tag, 33,  &p);
    q = 0;
    parsedtag_get_value(tag, 36,  &q);
    r = 135041709;
    parsedtag_get_value(tag, 25,  &r);
    w = 20;
    parsedtag_get_value(tag, 30,  &w);
    i = 20;
    parsedtag_get_value(tag, 22,  &i);
    p2 = 0;
    parsedtag_get_value(tag, 5,  &p2);
    if(tag->map == 0 || (tag->map[0xc] & 255) == 75) {
L9:
        _t281 = 0;
        goto L10;
    } else {
        if((tag->attrid[tag->map[0xc] & 0xff] & 255) == 0) {
            goto L9;
        } else {
            _t281 = 1;
L10:
            x = _t281;
            if(tag->map == 0) {
L14:
                _t284 = 0;
L15:
                y = _t284;
                if(tag->map == 0 || (tag->map[0x2b] & 255) == 75 || (tag->attrid[tag->map[0x2b] & 0xff] & 255) == 0) {
                    _t287 = 0;
                } else {
                    _t287 = 1;
                }
                z = _t287;
                v = formtype(p);
                if(v == -1) {
                    return 0;
                }
                if(q != 0 || v > 10) {
                    if(v == 11) {
                        q = 0;
                    }
                    if(q != 0) {
                        qq = html_quote(q);
                        qlen = wtf_strwidth(q);
                    }
                    Strcat_charp(tmp, "<pre_int>");
                    _t293 = v;
                    if(_t293 == 3) {
                        if(tmp->length + 1 >= tmp->area_size) {
                            Strgrow(tmp);
                        }
                        _t300 = tmp->length;
                         *((char*)(tmp->ptr + _t300)) = 40;
                        tmp->length = _t300 + 1;
                         *((char*)(tmp->ptr + tmp->length)) = 0;
                        goto L40;
                    } else {
                        if(_t293 > 3) {
                            if(_t293 != 11) {
L40:
                                _v112 = i;
                                __edi = w;
                                _t474 = html_quote(r);
                                __esi = p;
                                if(form_sp < 0) {
                                    _t486 = -1;
                                } else {
                                    _t486 = form_stack[form_sp];
                                }
                                _t310 = cur_hseq;
                                cur_hseq = _t310 + 1;
                                _v128 = qq;
                                _v132 = _v112;
                                _v136 = __edi;
                                _v140 = _t474;
                                _v144 = __esi;
                                _v148 = _t486;
                                _v152 = _t310;
                                Strcat(tmp, Sprintf("<input_alt hseq="%d" fid="%d" type=%s name="%s" width=%d maxlength=%d value="%s""));
                                if(x != 0) {
                                    Strcat_charp(tmp, " checked");
                                }
                                if(y != 0) {
                                    Strcat_charp(tmp, " accept");
                                }
                                if(z != 0) {
                                    Strcat_charp(tmp, " readonly");
                                }
                                if(tmp->length + 1 >= tmp->area_size) {
                                    Strgrow(tmp);
                                }
                                _t322 = tmp->length;
                                 *((char*)(tmp->ptr + _t322)) = 62;
                                tmp->length = _t322 + 1;
                                 *((char*)(tmp->ptr + tmp->length)) = 0;
                                if(v != 6) {
                                    if(v > 11) {
L68:
                                        if(v > 11) {
                                            if(v <= 11) {
                                                _t359 = 1 << v;
                                                if((_t359 & 1200) != 0) {
                                                    Strcat_charp(tmp, 135044796);
                                                } else {
                                                    if((_t359 & 2051) != 0) {
                                                        Strcat_charp(tmp, "</u>");
                                                    }
                                                }
                                            }
                                            Strcat_charp(tmp, "</input_alt>");
                                            _t329 = v;
                                            if(_t329 == 3) {
                                                if(tmp->length + 1 >= tmp->area_size) {
                                                    Strgrow(tmp);
                                                }
                                                _t336 = tmp->length;
                                                 *((char*)(tmp->ptr + _t336)) = 41;
                                                tmp->length = _t336 + 1;
                                                 *((char*)(tmp->ptr + tmp->length)) = 0;
L86:
                                                Strcat_charp(tmp, "</pre_int>");
                                                goto L87;
                                            }
                                            if(_t329 > 3) {
                                                if(_t329 != 11) {
                                                    goto L86;
                                                }
L80:
                                                if(tmp->length + 1 >= tmp->area_size) {
                                                    Strgrow(tmp);
                                                }
                                                _t351 = tmp->length;
                                                 *((char*)(tmp->ptr + _t351)) = 93;
                                                tmp->length = _t351 + 1;
                                                 *((char*)(tmp->ptr + tmp->length)) = 0;
                                                goto L86;
                                            }
                                            if(_t329 < 0) {
                                                goto L86;
                                            }
                                            goto L80;
                                        }
                                        goto __eax;
                                    }
                                    _t367 = 1 << v;
                                    if((_t367 & 1072) != 0) {
L67:
                                        Strcat_charp(tmp, L"[]");
                                        goto L68;
                                    }
                                    if((_t367 & 2051) != 0) {
                                        Strcat_charp(tmp, 135044077);
                                        goto L68;
                                    }
                                    if((_t367 & 128) != 0) {
                                        s = 0;
                                        parsedtag_get_value(tag, 31,  &s);
                                        if(s == 0) {
                                            goto L67;
                                        }
                                        _v152 = html_quote(s);
                                        Strcat(tmp, Sprintf("<img src="%s""));
                                        if(p2 != 0) {
                                            _v152 = html_quote(p2);
                                            Strcat(tmp, Sprintf(" alt="%s""));
                                        }
                                        if(parsedtag_get_value(tag, 38,  &iw) != 0) {
                                            _v152 = iw;
                                            Strcat(tmp, Sprintf(" width="%d""));
                                        }
                                        if(parsedtag_get_value(tag, 17,  &ih) != 0) {
                                            _v152 = ih;
                                            Strcat(tmp, Sprintf(" height="%d""));
                                        }
                                        Strcat_charp(tmp, " pre_int>");
                                        Strcat_charp(tmp, "</input_alt></pre_int>");
                                        return tmp;
                                    }
                                    goto L68;
                                } else {
                                    Strcat_charp(tmp, "</input_alt></pre_int>");
L87:
                                    return tmp;
                                }
                            }
L34:
                            if(tmp->length + 1 >= tmp->area_size) {
                                Strgrow(tmp);
                            }
                            _t413 = tmp->length;
                             *((char*)(tmp->ptr + _t413)) = 91;
                            tmp->length = _t413 + 1;
                             *((char*)(tmp->ptr + tmp->length)) = 0;
                            goto L40;
                        }
                        if(_t293 < 0) {
                            goto L40;
                        }
                        goto L34;
                    }
                } else {
                    goto __eax;
                }
            }
            if((tag->map[1] & 255) == 75 || (tag->attrid[tag->map[1] & 0xff] & 255) == 0) {
                goto L14;
            } else {
                _t284 = 1;
                goto L15;
            }
        }
    }
}

Str process_select(struct parsed_tag* tag)
{// addr = 0x08063D02  --  defined in 'file.c' at line 3718
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* s;                               // _cfa_ffffffe8
    int _v44;                              // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    int _v52;                              // _cfa_ffffffcc (outparam)
    signed int _v56;                       // _cfa_ffffffc8 (outparam)
    int __esi;                             // r5
    int _t42;                              // _t42
    int _t49;                              // _t49
    FormSelectOption* _t60;   // _t60
    int _t78;                              // _t78

    tmp = 0;
    if(form_sp < 0 || form_stack[form_sp] < 0) {
        s = "<form_int method=internal action=none>";
        tmp = process_form(parse_tag( &s, 1));
    }
    p = 135041709;
    parsedtag_get_value(tag, 25,  &p);
    cur_select = Strnew_charp(p);
    if(tag->map == 0 || (tag->map[0x18] & 255) == 75 || (tag->attrid[tag->map[0x18] & 0xff] & 255) == 0) {
        _t42 = 0;
    } else {
        _t42 = 1;
    }
    select_is_multiple = _t42;
    if(select_is_multiple != 0) {
        select_str = Strnew();
    } else {
        __esi = n_select;
        __ecx = html_quote(p);
        if(form_sp < 0) {
            _t49 = -1;
        } else {
            _t49 = form_stack[form_sp];
        }
        _t78 = cur_hseq;
        cur_hseq = _t78 + 1;
        _v44 = __esi;
        _v48 = __ecx;
        _v52 = _t49;
        _v56 = _t78;
        select_str = Sprintf("<pre_int>[<input_alt hseq="%d" fid="%d" type=select name="%s" selectnumber=%d");
        Strcat_charp(select_str, 135044483);
        if(n_select == max_select) {
            max_select = max_select + max_select;
            _t60 = select_option;
            _v56 = max_select * 8;
             *__esp = _t60;
            GC_realloc();
            select_option = _t60;
        }
         *(select_option + (n_select << 3)) = 0;
        (select_option + (n_select << 3))[1] = 0;
        cur_option_maxwidth = 0;
    }
    cur_option = 0;
    cur_status = 0;
    n_selectitem = 0;
    return tmp;
}

Str process_n_select()
{// addr = 0x08063F01  --  defined in 'file.c' at line 3758
    struct _Str* _v36;    // _cfa_ffffffdc
    FormItemList sitem;   // _cfa_ffffffac
    _unknown_ _v104;                       // _cfa_ffffff98 (outparam)

    if(cur_select != 0) {
        process_option();
        if(select_is_multiple != 0) {
            Strcat_charp(select_str, "<br>");
        } else {
            if( *(select_option + (n_select << 3)) != 0) {
                chooseSelectOption( &sitem,  *(select_option + (n_select << 3)));
                Strcat(select_str, textfieldrep(_v36, cur_option_maxwidth));
            }
            Strcat_charp(select_str, "</input_alt>]</pre_int>");
            n_select = n_select + 1;
        }
        cur_select = 0;
        n_selectitem = 0;
        return select_str;
    }
    return 0;
}

void feed_select(char* str)
{// addr = 0x08063FDE  --  defined in 'file.c' at line 3782
    Str tmp;               // _cfa_fffffff0
    int prev_status;                       // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    struct parsed_tag* tag;   // _cfa_ffffffe4
    char* q;                               // _cfa_ffffffe0
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    Str _t98;              // _t98
    int _t135;                             // _t135
    int _t154;                             // _t154
    char* _t158;                           // _t158

    tmp = Strnew();
    prev_status = cur_status;
    if(cur_select == 0) {
        return;
    }
    while(read_token(tmp,  &str,  &cur_status, 0, 0) != 0) {
        if(cur_status != 0) {
            continue;
        }
        if(prev_status != 0) {
            continue;
        }
        p = tmp->ptr;
        if(( *(tmp->ptr) & 255) != 60 || tmp->length <= 0 || ( *(tmp->ptr + tmp->length - 1) & 255) != 62) {
            if(cur_option == 0) {
                continue;
            }
            while(( *p & 255) != 0) {
                if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0 || prev_spaces == 0) {
                    if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
                        prev_spaces = 0;
                    } else {
                        prev_spaces = 1;
                    }
                    if(( *p & 255) != 38) {
                        if(cur_option->length + 1 >= cur_option->area_size) {
                            Strgrow(cur_option);
                        }
                        _t98 = cur_option;
                        _t154 = _t98->length;
                        _t158 = p;
                         *((char*)(cur_option->ptr + _t154)) =  *_t158 & 255;
                        _t98->length = _t154 + 1;
                        p =  &(_t158[1]);
                         *((char*)(cur_option->ptr + cur_option->length)) = 0;
                    } else {
                        Strcat_charp(cur_option, getescapecmd( &p));
                    }
                } else {
                    p =  &(p[1]);
                    if(prev_spaces > 0) {
                        prev_spaces = prev_spaces + 1;
                    }
                }
            }
        } else {
            tag = parse_tag( &p, 0);
            if(tag != 0) {
                if((tag->tagid & 0xff) == 49) {
                    process_option();
                    cur_option = Strnew();
                    if(parsedtag_get_value(tag, 36,  &q) == 0) {
                        cur_option_value = 0;
                    } else {
                        cur_option_value = Strnew_charp(q);
                    }
                    if(parsedtag_get_value(tag, 42,  &q) == 0) {
                        cur_option_label = 0;
                    } else {
                        cur_option_label = Strnew_charp(q);
                    }
                    if(tag->map == 0 || (tag->map[0x29] & 255) == 75 || (tag->attrid[tag->map[0x29] & 0xff] & 255) == 0) {
                        _t135 = 0;
                    } else {
                        _t135 = 1;
                    }
                    cur_option_selected = _t135;
                    prev_spaces = -1;
                }
            }
        }
    }
}

void process_option()
{// addr = 0x080642DF  --  defined in 'file.c' at line 3846
    char begin_char;                       // _cfa_ffffffe3
    char end_char;                         // _cfa_ffffffe2
    int len;                               // _cfa_ffffffdc
    char* _v52;                            // _cfa_ffffffcc
    FormSelectOption* _v56;   // _cfa_ffffffc8
    char* _v60;                            // _cfa_ffffffc4
    int _v64;                              // _cfa_ffffffc0 (outparam)
    int _v68;                              // _cfa_ffffffbc (outparam)
    char _v72;                             // _cfa_ffffffb8 (outparam)
    FormSelectOption* __ebx;   // r1
    int __edi;                             // r4
    char* __esi;                           // r5

    begin_char = 91;
    end_char = 93;
    if(cur_select != 0) {
        if(cur_option != 0) {
            while(1) {
                __eax = cur_option;
                __eax = cur_option->length;
                if(cur_option->length <= 0) {
                    break;
                }
                __eax = cur_option;
                __eax = cur_option->length;
                if(cur_option->length <= 0) {
                    __eax = 0;
                } else {
                    __eax = cur_option;
                    __edx = cur_option->ptr;
                    __eax = cur_option;
                    __eax = cur_option->length;
                    __eax = cur_option->length - 1;
                    cur_option->ptr + cur_option->length - 1 =  *(cur_option->ptr + cur_option->length - 1) & 255;
                    __eax = __al & 255;
                }
                __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                __eax = __al & 255;
                if(__eax != 0) {
                    __eax = cur_option;
                    Strshrink(cur_option, 1);
                    continue;
                } else {
                    break;
                }
            }
            __eax = cur_option_value;
            if(cur_option_value == 0) {
                __eax = cur_option;
                cur_option_value = cur_option;
            }
            __eax = cur_option_label;
            if(cur_option_label == 0) {
                __eax = cur_option;
                cur_option_label = cur_option;
            }
            __eax = select_is_multiple;
            if(select_is_multiple != 0) {
                __eax = select_is_multiple;
                if(select_is_multiple == 0) {
                    begin_char = 40;
                    end_char = 41;
                }
                cur_option_value = cur_option_value->ptr;
                __esi = html_quote(cur_option_value->ptr);
                cur_select = cur_select->ptr;
                __ebx = html_quote(cur_select->ptr);
                __eax = select_is_multiple;
                if(select_is_multiple == 0) {
                    __edx = "radio";
                } else {
                    __edx = "checkbox";
                }
                __eax = form_sp;
                if(form_sp < 0) {
                    __eax = -1;
                } else {
                    __eax = form_stack;
                    form_sp = form_sp << 2;
                    __eax =  &(form_stack[form_sp]);
                    __eax = form_stack[form_sp];
                }
                __ecx = cur_hseq;
                __edi = __ecx;
                cur_hseq = __ecx;
                __ecx = begin_char;
                _v52 = __esi;
                _v56 = __ebx;
                _v60 = __edx;
                _v64 = __eax;
                _v68 = __edi;
                _v72 = begin_char;
                __eax = Sprintf("<br><pre_int>%c<input_alt hseq="%d" fid="%d" type=%s name="%s" value="%s"");
                __edx = select_str;
                Strcat(select_str, __eax);
                __eax = cur_option_selected;
                if(cur_option_selected == 0) {
                    __eax = select_str;
                    Strcat_charp(select_str, "> </input_alt>");
                } else {
                    __eax = select_str;
                    Strcat_charp(select_str, " checked>*</input_alt>");
                }
                __eax = select_str;
                __eax = select_str->length;
                __edx = select_str->length + 1;
                __eax = select_str;
                __eax = select_str->area_size;
                if(select_str->length + 1 >= select_str->area_size) {
                    __eax = select_str;
                    Strgrow(select_str);
                }
                __eax = select_str;
                __ebx = select_str->ptr;
                __eax = select_str;
                __edx =  *(__eax + 4);
                __ecx = __edx;
                __ebx =  &(__edx[select_str->ptr]);
                __ecx = end_char & 255;
                __edx[select_str->ptr] = end_char & 255;
                 *(__eax + 4) = __edx;
                __eax = select_str;
                __edx = select_str->ptr;
                __eax = select_str;
                __eax = select_str->length;
                __eax = select_str->ptr + select_str->length;
                 *(select_str->ptr + select_str->length) = 0;
                cur_option_label = cur_option_label->ptr;
                __eax = html_quote(cur_option_label->ptr);
                __edx = select_str;
                Strcat_charp(select_str, __eax);
                __eax = select_str;
                Strcat_charp(select_str, "</pre_int>");
                n_selectitem = n_selectitem + 1;
                n_selectitem = n_selectitem + 1;
                return;
            } else {
                cur_option_label = cur_option_label->ptr;
                len = wtf_strwidth(cur_option_label->ptr);
                __eax = cur_option_maxwidth;
                if(len > cur_option_maxwidth) {
                    __eax = len;
                    cur_option_maxwidth = len;
                }
                __ecx = cur_option_selected;
                __edx = cur_option_label;
                __eax = cur_option_value;
                __ebx = select_option;
                n_select = n_select << 3;
                __ebx = select_option + (n_select << 3);
                addSelectOption(select_option + (n_select << 3), cur_option_value, cur_option_label, cur_option_selected);
                return;
            }
        }
        return;
    }
}

Str process_textarea(struct parsed_tag* tag, int width)
{// addr = 0x0806458C  --  defined in 'file.c' at line 3891
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* s;                               // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    signed int _v40;                       // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t60;                              // _t60
    Str* _t68;             // _t68
    int _t81;                              // _t81
    int _t83;                              // _t83
    char* _t84;                            // _t84

    tmp = 0;
    if(form_sp < 0 || form_stack[form_sp] < 0) {
        s = "<form_int method=internal action=none>";
        tmp = process_form(parse_tag( &s, 1));
    }
    p = 135041709;
    parsedtag_get_value(tag, 25,  &p);
    cur_textarea = Strnew_charp(p);
    cur_textarea_size = 20;
    if(parsedtag_get_value(tag, 13,  &p) != 0) {
        _t83 = p;
         *__esp = _t83;
        atoi();
        cur_textarea_size = _t83;
        _t84 = p;
         *__esp = _t84;
        strlen();
        if((p[_t84 - 1] & 255) == 37) {
            cur_textarea_size = (cur_textarea_size * width * 1374389535 >> 32 >> 5) - (cur_textarea_size * width >> 31) - 2;
        }
        if(cur_textarea_size <= 0) {
            cur_textarea_size = 20;
        }
    }
    cur_textarea_rows = 1;
    if(parsedtag_get_value(tag, 28,  &p) != 0) {
        _t81 = p;
         *__esp = _t81;
        atoi();
        cur_textarea_rows = _t81;
        if(cur_textarea_rows <= 0) {
            cur_textarea_rows = 1;
        }
    }
    if(tag->map == 0 || (tag->map[0x2b] & 255) == 75 || (tag->attrid[tag->map[0x2b] & 0xff] & 255) == 0) {
        _t60 = 0;
    } else {
        _t60 = 1;
    }
    cur_textarea_readonly = _t60;
    if(n_textarea >= max_textarea) {
        max_textarea = max_textarea + max_textarea;
        _t68 = textarea_str;
        _v40 = max_textarea * 4;
         *__esp = _t68;
        GC_realloc();
        textarea_str = _t68;
    }
     *(textarea_str + (n_textarea << 2)) = Strnew();
    ignore_nl_textarea = 1;
    return tmp;
}

Str process_n_textarea()
{// addr = 0x0806479C  --  defined in 'file.c' at line 3930
    Str tmp;               // _cfa_ffffffe0
    int i;                                 // _cfa_ffffffdc
    int _v48;                              // _cfa_ffffffd0
    int _v64;                              // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    int _v76;                              // _cfa_ffffffb4
    char* _v80;                            // _cfa_ffffffb0
    int _v84;                              // _cfa_ffffffac
    int _v88;                              // _cfa_ffffffa8 (outparam)
    int __ebx;                             // r1
    _unknown_ __edi;                       // r4
    int __esi;                             // r5
    int _t50;                              // _t50
    int _t62;                              // _t62
    char* _t80;                            // _t80
    int _t89;                              // _t89

    if(cur_textarea != 0) {
        tmp = Strnew();
        _t89 = n_textarea;
        _v48 = cur_textarea_rows - 1;
        __esi = cur_textarea_rows;
        __ebx = cur_textarea_size;
        _t80 = html_quote(cur_textarea->ptr);
        if(form_sp < 0) {
            _t50 = -1;
        } else {
            _t50 = form_stack[form_sp];
        }
        _v64 = _t89;
        _v68 = _v48;
        _v72 = __esi;
        _v76 = __ebx;
        _v80 = _t80;
        _v84 = _t50;
        _v88 = cur_hseq;
        Strcat(tmp, Sprintf("<pre_int>[<input_alt hseq="%d" fid="%d" type=textarea name="%s" size=%d rows=%d top_margin=%d textareanumber=%d"));
        if(cur_textarea_readonly != 0) {
            Strcat_charp(tmp, " readonly");
        }
        Strcat_charp(tmp, "><u>");
        i = 0;
        while(i < cur_textarea_size) {
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t62 = tmp->length;
             *((char*)(tmp->ptr + _t62)) = 32;
            tmp->length = _t62 + 1;
             *((char*)(tmp->ptr + tmp->length)) = 0;
            i = i + 1;
        }
        Strcat_charp(tmp, "</u></input_alt>]</pre_int>\n");
        cur_hseq = cur_hseq + 1;
        n_textarea = n_textarea + 1;
        cur_textarea = 0;
        return tmp;
    }
    return 0;
}

void feed_textarea(char* str)
{// addr = 0x08064924  --  defined in 'file.c' at line 3960
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ __ebx;                       // r1
    struct _Str* _t50;    // _t50
    int _t81;                              // _t81
    char* _t96;                            // _t96

    if(cur_textarea == 0) {
        return;
    }
    if(ignore_nl_textarea != 0) {
        if(( *str & 255) == 10) {
            str =  &(str[1]);
        }
    }
    ignore_nl_textarea = 0;
    while(( *str & 255) != 0) {
        if(( *str & 255) != 38) {
            if(( *str & 255) != 10) {
                if(( *str & 255) != 13) {
                    if( *(textarea_str + (n_textarea << 2))->length + 1 >=  *(textarea_str + (n_textarea << 2))->area_size) {
                        Strgrow( *(textarea_str + (n_textarea << 2)));
                    }
                    _t50 =  *(textarea_str + (n_textarea << 2));
                    _t81 = _t50->length;
                    _t96 = str;
                     *((char*)( *( *(textarea_str + (n_textarea << 2))) + _t81)) =  *_t96 & 255;
                    _t50->length = _t81 + 1;
                    str =  &(_t96[1]);
                     *((char*)( *( *(textarea_str + (n_textarea << 2))) +  *(textarea_str + (n_textarea << 2))->length)) = 0;
                }
            } else {
                Strcat_charp( *(textarea_str + (n_textarea << 2)), "\n");
                str =  &(str[1]);
            }
        } else {
            Strcat_charp( *(textarea_str + (n_textarea << 2)), getescapecmd( &str));
        }
    }
}

Str process_hr(struct parsed_tag* tag, int width, int indent_width)
{// addr = 0x08064ACC  --  defined in 'file.c' at line 3984
    Str tmp;               // _cfa_fffffff0
    int w;                                 // _cfa_ffffffec
    int x;                                 // _cfa_ffffffe8
    int _v32;                              // _cfa_ffffffe0
    _unknown_ _v34;                        // _cfa_ffffffde
    short _v36;                            // _cfa_ffffffdc
    signed int _v48;                       // _cfa_ffffffd0
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    int _t67;                              // _t67
    int _t85;                              // _t85

    tmp = Strnew_charp("<nobr>");
    w = 0;
    x = 0;
    if(width > indent_width) {
        width = width - indent_width;
    }
    if(parsedtag_get_value(tag, 38,  &w) == 0) {
        w = width;
    } else {
        if(w < 0) {
            _t85 = ( ~w * width * 1374389535 >> 32 >> 5) - ( ~w * width >> 31);
        } else {
            _v32 = w;
            asm("fild dword [ebp-0x1c]");
            asm("fdivp st1, st0");
            asm("fnstcw word [ebp-0x1e]");
            _v36 = 12;
            asm("fldcw word [ebp-0x20]");
            asm("fistp dword [ebp-0x1c]");
            asm("fldcw word [ebp-0x1e]");
            _t85 = _v32;
        }
        w = _t85;
    }
    parsedtag_get_value(tag, 4,  &x);
    _t67 = x;
    if(_t67 == 1) {
        Strcat_charp(tmp, "<div_int align=left>");
    } else {
        if(_t67 == 2) {
            Strcat_charp(tmp, "<div_int align=right>");
        } else {
            if(_t67 == 0) {
                Strcat_charp(tmp, "<div_int align=center>");
            }
        }
    }
    _v48 = symbol_width;
    w = w / _v48;
    if(w <= 0) {
        w = 1;
    }
    push_symbol(tmp, 26, symbol_width, w);
    Strcat_charp(tmp, "</div_int></nobr>");
    return tmp;
}

char* check_charset(char* p)
{// addr = 0x08064C43  --  defined in 'file.c' at line 4019
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(wc_guess_charset(p, 0) == 0) {
        return 0;
    }
    return p;
}

char* check_accept_charset(char* ac)
{// addr = 0x08064C6C  --  defined in 'file.c' at line 4025
    char* s;                               // _cfa_fffffff0
    char* e;                               // _cfa_ffffffec
    signed int _v40;                       // _cfa_ffffffd8 (outparam)

    s = ac;
    while(( *s & 255) != 0) {
        while(1) {
            s =  *s & 255;
            if(__al == 0) {
                break;
            }
            s =  *s & 255;
            __eax = __eax[ &MYCTYPE_MAP] & 255;
            __eax = __al & 255;
            if(__eax != 0) {
L1:
                s =  &(s[1]);
                continue;
            }
            s =  *s & 255;
            if(__al == 44) {
                goto L1;
            }
            break;
        }
        s =  *s & 255;
        if(__al == 0) {
L18:
            return 0;
        }
        __eax = s;
        e = s;
        while(1) {
            e =  *e & 255;
            if(__al == 0) {
                break;
            }
            e =  *e & 255;
            __eax = __eax[ &MYCTYPE_MAP] & 255;
            __eax = __al & 255;
            if(__eax != 0) {
                break;
            }
            e =  *e & 255;
            if(__al != 44) {
                e =  &(e[1]);
                continue;
            }
            break;
        }
        s = e - s;
        _v40 = e - s;
        __eax = s;
         *__esp = s;
        __eax = Strnew_charp_n();
        __eax =  *__eax;
        if(__eax == 0) {
            __eax = e;
            s = e;
            continue;
        }
        __eax = ac;
        return ac;
    }
    goto L18;
}

Str process_form_int(struct parsed_tag* tag, int fid)
{// addr = 0x08064D4E  --  defined in 'file.c' at line 4046
    char* p;                               // _cfa_ffffffe0
    char* q;                               // _cfa_ffffffdc
    char* r;                               // _cfa_ffffffd8
    char* s;                               // _cfa_ffffffd4
    char* tg;                              // _cfa_ffffffd0
    char* n;                               // _cfa_ffffffcc
    Str tmp;               // _cfa_ffffffc8
    FormList** _v64;   // _cfa_ffffffc0
    _unknown_ _v84;                        // _cfa_ffffffac (outparam)
    _unknown_ _v88;                        // _cfa_ffffffa8 (outparam)
    _unknown_ _v92;                        // _cfa_ffffffa4 (outparam)
    intOrPtr _v96;                         // _cfa_ffffffa0 (outparam)
    intOrPtr _v100;                        // _cfa_ffffff9c (outparam)
    char* _v104;                           // _cfa_ffffff98 (outparam)
    _unknown_ __ebx;                       // r1
    char* _t130;                           // _t130
    char* _t132;                           // _t132
    FormList** _t160;   // _t160
    int* _t162;                            // _t162
    FormList** _t164;   // _t164
    int* _t166;                            // _t166

    p = "get";
    parsedtag_get_value(tag, 23,  &p);
    q = "!CURRENT_URL!";
    parsedtag_get_value(tag, 3,  &q);
    r = 0;
    if(parsedtag_get_value(tag, 2,  &r) != 0) {
        r = check_accept_charset(r);
    }
    if(r == 0 && parsedtag_get_value(tag, 11,  &r) != 0) {
        r = check_charset(r);
    }
    s = 0;
    parsedtag_get_value(tag, 16,  &s);
    tg = 0;
    parsedtag_get_value(tag, 32,  &tg);
    n = 0;
    parsedtag_get_value(tag, 25,  &n);
    if(fid >= 0) {
        if(form_max < fid) {
            form_max = fid;
        }
        form_sp = fid;
    } else {
        form_max = form_max + 1;
        form_sp = form_sp + 1;
        fid = form_max;
    }
    if(forms_size != 0) {
        if(forms_size <= form_max) {
            forms_size = forms_size + form_max;
            _t160 = forms;
            _v104 = forms_size * 4;
             *__esp = _t160;
            GC_realloc();
            forms = _t160;
            _t162 = form_stack;
            _v104 = forms_size * 4;
             *__esp = _t162;
            GC_realloc();
            form_stack = _t162;
        }
    } else {
        forms_size = 10;
        _t164 = forms_size << 2;
         *__esp = _t164;
        GC_malloc();
        forms = _t164;
        _t166 = forms_size << 2;
         *__esp = _t166;
        GC_malloc_atomic();
        form_stack = _t166;
    }
    form_stack[form_sp] = fid;
    if((w3m_dump & 16) == 0) {
        _v64 =  &(forms[fid]);
         *_v64 = newFormList(q, p, r, s, tg, n, 0);
        return 0;
    } else {
        _t130 = html_quote(p);
        _t132 = html_quote(q);
        _v96 = _t130;
        _v100 = _t132;
        _v104 = fid;
        tmp = Sprintf("<form_int fid="%d" action="%s" method="%s"");
        if(s != 0) {
            _v104 = html_quote(s);
            Strcat(tmp, Sprintf(" enctype="%s""));
        }
        if(tg != 0) {
            _v104 = html_quote(tg);
            Strcat(tmp, Sprintf(" target="%s""));
        }
        if(n != 0) {
            _v104 = html_quote(n);
            Strcat(tmp, Sprintf(" name="%s""));
        }
        if(r != 0) {
            _v104 = html_quote(r);
            Strcat(tmp, Sprintf(" accept-charset="%s""));
        }
        Strcat_charp(tmp, 135044483);
        return tmp;
    }
}

Str process_form(struct parsed_tag* tag)
{// addr = 0x080650DB  --  defined in 'file.c' at line 4112
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return process_form_int(tag, -1);
}

Str process_n_form()
{// addr = 0x080650F6  --  defined in 'file.c' at line 4118
    if(form_sp >= 0) {
        form_sp = form_sp - 1;
    }
    return 0;
}

void clear_ignore_p_flag(int cmd, struct readbuffer* obuf)
{// addr = 0x08065116  --  defined in 'file.c' at line 4126
    int i;                                 // _cfa_fffffff8

    i = 0;
    while(( &clear_flag_cmd)[i] != 0) {
        if(( &clear_flag_cmd)[i] == cmd) {
            obuf->flag = obuf->flag & 223;
            return;
        }
        i = i + 1;
    }
}

void set_alignment(struct readbuffer* obuf, struct parsed_tag* tag)
{// addr = 0x0806515B  --  defined in 'file.c' at line 4142
    long int flag;                         // _cfa_fffffff0
    int align;                             // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t45;                              // _t45
    int _t47;                              // _t47

    flag = -1;
    if(parsedtag_get_value(tag, 4,  &align) != 0) {
        _t47 = align;
        if(_t47 == 1) {
            flag = 16;
        } else {
            if(_t47 == 2) {
                flag = 64;
            } else {
                if(_t47 == 0) {
                    flag = 32;
                }
            }
        }
    }
    if(obuf->flag_sp <= 9) {
        _t45 = obuf->flag_sp;
         *(obuf + (_t45 + 4) * 4) = obuf->flag & 112;
        obuf->flag_sp = _t45 + 1;
    }
    if(flag == -1) {
        return;
    } else {
        obuf->flag = obuf->flag & -113;
        obuf->flag = obuf->flag | flag;
        return;
    }
}

void process_idattr(struct readbuffer* obuf, int cmd, struct parsed_tag* tag)
{// addr = 0x0806520D  --  defined in 'file.c' at line 4167
    char* id;                              // _cfa_fffffff0
    char* framename;                       // _cfa_ffffffec
    Str idtag;             // _cfa_ffffffe8
    intOrPtr _v36;                         // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    char* _t42;                            // _t42
    char* _t44;                            // _t44

    id = 0;
    framename = 0;
    idtag = 0;
    if(cmd == 31) {
        return;
    }
    parsedtag_get_value(tag, 20,  &id);
    parsedtag_get_value(tag, 67,  &framename);
    if(id != 0) {
        if(framename == 0) {
            _v40 = html_quote(id);
            idtag = Sprintf("<_id id="%s">");
        } else {
            _t42 = html_quote(framename);
            _t44 = html_quote(id);
            _v36 = _t42;
            _v40 = _t44;
            idtag = Sprintf("<_id id="%s" framename="%s">");
        }
        push_tag(obuf, idtag->ptr, 138);
        return;
    }
}

int ul_type(struct parsed_tag* tag, int default_type)
{// addr = 0x080652EC  --  defined in 'file.c' at line 4223
    char* p;                               // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    char* _t16;                            // _t16
    char* _t17;                            // _t17
    char* _t18;                            // _t18

    if(parsedtag_get_value(tag, 33,  &p) == 0) {
L7:
        return default_type;
    }
    _t16 = p;
    _v40 = "disc";
     *__esp = _t16;
    strcasecmp();
    if(_t16 != 0) {
        _t17 = p;
        _v40 = "circle";
         *__esp = _t17;
        strcasecmp();
        if(_t17 != 0) {
            _t18 = p;
            _v40 = "square";
             *__esp = _t18;
            strcasecmp();
            if(_t18 != 0) {
                goto L7;
            }
            return 115;
        }
        return 99;
    }
    return 100;
}

int getMetaRefreshParam(char* q, Str* refresh_uri)
{// addr = 0x0806536F  --  defined in 'file.c' at line 4238
    int refresh_interval;                  // _cfa_fffffff0
    char* r;                               // _cfa_ffffffec
    Str s_tmp;             // _cfa_ffffffe8
    intOrPtr _v36;                         // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    int _t59;                              // _t59

    s_tmp = 0;
    if(q == 0 || refresh_uri == 0) {
        return 0;
    }
    _t59 = q;
     *__esp = _t59;
    atoi();
    refresh_interval = _t59;
    if(refresh_interval >= 0) {
        while(1) {
L28:
            q =  *q & 255;
            if(__al == 0) {
                break;
            }
            _v36 = 4;
            _v40 = "url=";
            __eax = q;
             *__esp = __eax;
            strncasecmp();
            if(__eax != 0) {
                while(1) {
L18:
                    q =  *q & 255;
                    if(__al == 0) {
                        break;
                    }
                    q =  *q & 255;
                    if(__al != 59) {
                        q =  &(q[1]);
                        continue;
                    }
                    break;
                }
                q =  *q & 255;
                if(__al == 59) {
                    q =  &(q[1]);
                }
                while(1) {
                    q =  *q & 255;
                    if(__al == 0) {
                        goto L28;
                    }
                    q =  *q & 255;
                    if(__al == 32) {
                        q =  &(q[1]);
                        continue;
                    }
                    goto L28;
                }
                continue;
            }
            q =  &(q[4]);
            q =  *q & 255;
            if(__al == 34) {
                q =  &(q[1]);
            }
            __eax = q;
            r = q;
            while(1) {
                r =  *r & 255;
                if(__al == 0) {
                    break;
                }
                r =  *r & 255;
                __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                __eax = __al & 255;
                if(__eax != 0) {
                    break;
                }
                r =  *r & 255;
                if(__al != 59) {
                    r =  &(r[1]);
                    continue;
                }
                break;
            }
            q = r - q;
            _v40 = r - q;
            __eax = q;
             *__esp = q;
            s_tmp = Strnew_charp_n();
            s_tmp = s_tmp;
            s_tmp->length = s_tmp->length - 1;
            s_tmp->ptr + s_tmp->length - 1 =  *(s_tmp->ptr + s_tmp->length - 1) & 255;
            if(__al == 34) {
                s_tmp = s_tmp->length;
                __eax = s_tmp;
                s_tmp->length = s_tmp->length - 1;
                s_tmp = s_tmp;
                s_tmp->length = s_tmp->ptr + s_tmp->length;
                 *(s_tmp->ptr + s_tmp->length) = 0;
            }
            __eax = r;
            q = r;
            goto L18;
        }
        __eax = refresh_uri;
         *refresh_uri = s_tmp;
        __eax = refresh_interval;
        return refresh_interval;
    } else {
        return 0;
    }
}

int HTMLtagproc1(struct parsed_tag* tag, struct html_feed_environ* h_env)
{// addr = 0x080654E5  --  defined in 'file.c' at line 4280
    char* p;                               // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    char* r;                               // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    int w;                                 // _cfa_ffffffe0
    int x;                                 // _cfa_ffffffdc
    int y;                                 // _cfa_ffffffd8
    int z;                                 // _cfa_ffffffd4
    int count;                             // _cfa_ffffffd0
    int width;                             // _cfa_ffffffcc
    Str tmp;               // _cfa_ffffffc0
    int hseq;                              // _cfa_ffffffbc
    Str num;               // _cfa_ffffffb0
    int refresh_interval;                  // _cfa_ffffffac
    Str s;                 // _cfa_ffffffa8
    Str s;                 // _cfa_ffffffa4
    Str s;                 // _cfa_ffffffa0
    Str s;                 // _cfa_ffffff9c
    struct readbuffer* obuf;   // _cfa_ffffffc8
    struct environment* envs;   // _cfa_ffffffc4
    int cmd;                               // _cfa_ffffffb8
    char* id;                              // _cfa_ffffffb4
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    int _t29;                              // _t29

    obuf = h_env->obuf;
    envs = h_env->envs;
    id = 0;
    cmd = tag->tagid & 0xff;
    if((obuf->flag & 1) != 0) {
        _t29 = cmd;
        if(_t29 < 50 || _t29 > 51 && _t29 + -128 > 1) {
            goto L5;
        } else {
            return 1;
        }
    }
L5:
    if(cmd > 144) {
        return 0;
    } else {
        goto __eax;
    }
}

Str textlist_feed()
{// addr = 0x08069B8B  --  defined in 'file.c' at line 5232
    TextLine* p;      // _cfa_fffffff8

    if(_tl_lp2 == 0) {
        return 0;
    }
    p = _tl_lp2->ptr;
    _tl_lp2 = _tl_lp2->next;
    return p->line;
}

int ex_efct(int ex)
{// addr = 0x08069BBF  --  defined in 'file.c' at line 5243
    int effect;                            // _cfa_fffffff8

    effect = 0;
    if(ex != 0) {
        if((ex & 1) != 0) {
            effect = effect | 2;
        }
        if((ex & 2) != 0) {
            effect = effect | 2;
        }
        if((ex & 4) != 0) {
            effect = effect | 4;
        }
        return effect;
    }
    return 0;
}

void HTMLlineproc2body(Buffer* buf, _None* feed, int llimit)
{// addr = 0x08069C08  --  defined in 'file.c' at line 5263
    char* q;                               // _cfa_ffffffc8
    char* r;                               // _cfa_ffffffc4
    char* s;                               // _cfa_ffffffc0
    char* t;                               // _cfa_ffffffbc
    struct frameset*[9] frameset_s;   // _cfa_fffffef8
    int hseq;                              // _cfa_ffffffa0
    int selected;                          // _cfa_ffffff20
    FormItemList* item;   // _cfa_ffffff24
    FormItemList* item;   // _cfa_ffffff28
    Str tmp;               // _cfa_ffffff30
    int refresh_interval;                  // _cfa_ffffff2c
    union frameset_element element;   // _cfa_ffffff34
    MapArea* a;        // _cfa_ffffff38
    MapList* m;        // _cfa_ffffff3c
    FormList* form;   // _cfa_ffffff50
    int top;                               // _cfa_ffffff4c
    int bottom;                            // _cfa_ffffff48
    int textareanumber;                    // _cfa_ffffff44
    int selectnumber;                      // _cfa_ffffff30
    int hpos;                              // _cfa_ffffff40
    int w;                                 // _cfa_ffffff6c
    int h;                                 // _cfa_ffffff68
    int iseq;                              // _cfa_ffffff64
    int ismap;                             // _cfa_ffffff60
    int xoffset;                           // _cfa_ffffff30
    int yoffset;                           // _cfa_ffffff44
    int top;                               // _cfa_ffffff48
    int bottom;                            // _cfa_ffffff4c
    ParsedURL u;     // _cfa_fffffed0
    Image* image;        // _cfa_ffffff5c
    BufferPoint* po;   // _cfa_ffffff58
    Anchor* a;          // _cfa_ffffff54
    int h;                                 // _cfa_ffffff70
    char symbol;                           // _cfa_ffffffe3
    Lineprop mode;    // _cfa_ffffffe0
    Lineprop effect;   // _cfa_ffffffde
    Lineprop ex_effect;   // _cfa_ffffffdc
    Anchor* a_href;     // _cfa_ffffffd8
    Anchor* a_img;      // _cfa_ffffffd4
    Anchor* a_form;     // _cfa_ffffffd0
    char* p;                               // _cfa_ffffffcc
    char* str;                             // _cfa_ffffffb8
    int pos;                               // _cfa_ffffffb4
    int nlines;                            // _cfa_ffffffb0
    int frameset_sp;                       // _cfa_ffffffac
    union frameset_element* idFrame;   // _cfa_ffffffa8
    char* id;                              // _cfa_ffffffa4
    int form_id;                           // _cfa_ffffff9c
    Str line;              // _cfa_ffffff98
    char* endp;                            // _cfa_ffffff94
    int internal;                          // _cfa_ffffff90
    Anchor** a_textarea;   // _cfa_ffffff8c
    Anchor** a_select;   // _cfa_ffffff88
    char** buf;                            // _cfa_ffffff84
    int len;                               // _cfa_ffffff80
    int len;                               // _cfa_ffffff7c
    int len;                               // _cfa_ffffff78
    struct parsed_tag* tag;   // _cfa_ffffff74
    _unknown_ _v364;                       // _cfa_fffffe94 (outparam)
    _unknown_ _v368;                       // _cfa_fffffe90 (outparam)
    _unknown_ _v372;                       // _cfa_fffffe8c (outparam)
    _unknown_ _v376;                       // _cfa_fffffe88 (outparam)
    _unknown_ _v380;                       // _cfa_fffffe84 (outparam)
    _unknown_ _v384;                       // _cfa_fffffe80 (outparam)
    _unknown_ _v388;                       // _cfa_fffffe7c (outparam)
    int _v392;                             // _cfa_fffffe78 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    struct _Str* _t353;   // _t353
    Lineprop* _t420;   // _t420
    char* _t467;                           // _t467
    char* _t482;                           // _t482
    char* _t490;                           // _t490
    Lineprop* _t492;   // _t492
    char* _t512;                           // _t512
    Lineprop* _t514;   // _t514
    char* _t529;                           // _t529
    char* _t544;                           // _t544
    char* _t552;                           // _t552
    Lineprop* _t554;   // _t554
    char* _t594;                           // _t594
    char* _t611;                           // _t611
    char* _t619;                           // _t619
    Lineprop* _t621;   // _t621
    _unknown_ _t628;                       // _t628
    _unknown_ _t630;                       // _t630
    FormList* _t654;   // _t654
    FormSelectOption* _t665;   // _t665
    Anchor** _t667;     // _t667
    Str* _t669;            // _t669
    Anchor** _t671;     // _t671
    char* _t672;                           // _t672
    Lineprop* _t674;   // _t674

    a_href = 0;
    a_img = 0;
    a_form = 0;
    frameset_sp = -1;
    idFrame = 0;
    id = 0;
    symbol = 0;
    internal = 0;
    a_textarea = 0;
    a_select = 0;
    if(out_size == 0) {
        out_size = 256;
        _t672 = out_size;
         *__esp = _t672;
        GC_malloc_atomic();
        outc = _t672;
        _t674 = out_size + out_size;
         *__esp = _t674;
        GC_malloc_atomic();
        outp = _t674;
    }
    n_textarea = -1;
    if(max_textarea == 0) {
        max_textarea = 10;
        _t669 = max_textarea << 2;
         *__esp = _t669;
        GC_malloc();
        textarea_str = _t669;
        _t671 = max_textarea << 2;
         *__esp = _t671;
        GC_malloc();
        a_textarea = _t671;
    }
    n_select = -1;
    if(max_select == 0) {
        max_select = 10;
        _t665 = max_select << 3;
         *__esp = _t665;
        GC_malloc();
        select_option = _t665;
        _t667 = max_select << 2;
         *__esp = _t667;
        GC_malloc();
        a_select = _t667;
    }
    effect = 0;
    ex_effect = 0;
    nlines = 0;
    while(1) {
L78:
        _t353 = feed;
        _t353->ptr();
        line = _t353;
        if(line == 0) {
            break;
        }
        if(n_textarea < 0) {
            while(1) {
L10:
                nlines = nlines + 1;
                if(nlines == llimit) {
                    break;
                } else {
                    pos = 0;
                    Strremovetrailingspaces(line);
                    str = line->ptr;
                    endp =  &(str[line->length]);
                }
                while(str < endp) {
                    mode = ( *( &WTF_TYPE_MAP + ( *str & 0xff)) & 0xff) << 8;
                    if(((ex_efct(ex_effect & 65535) | effect & 65535) & 32768) == 0 || ( *str & 255) == 60) {
                        if(mode == 256 || mode == 8192) {
                             *((short*)(outp + pos + pos)) = effect & 65535 | ex_efct(ex_effect & 65535);
                            outc[pos] = 32;
                            pos = pos + 1;
                            str =  &(str[1]);
                        } else {
                            if((mode & 0x1000) == 0) {
                                if(( *str & 255) == 60 || ( *str & 255) == 38) {
                                    if(( *str & 255) != 38) {
                                        tag = parse_tag( &str, 1);
                                        if(tag == 0) {
                                            continue;
                                        }
                                        if((tag->tagid & 0xff) > 142) {
                                            id = 0;
                                            if(parsedtag_get_value(tag, 20,  &id) != 0) {
                                                id = url_quote( *(wc_Str_conv_strict(Strnew_charp(id), InnerCharset, buf->document_charset)));
                                                registerName(buf, id, currentLn(buf), pos);
                                            }
                                            if(renderFrameSet == 0 || parsedtag_get_value(tag, 67,  &p) == 0) {
L66:
                                                if(id != 0 && idFrame != 0) {
                                                     *( *idFrame + 28) = putAnchor( *( *idFrame + 28), id, 0, 0, 0, 0, 0, currentLn(buf), pos);
                                                }
                                                continue;
                                            } else {
                                                p = url_quote( *(wc_Str_conv_strict(Strnew_charp(p), InnerCharset, buf->document_charset)));
                                                if(idFrame == 0) {
L63:
                                                    idFrame = search_frame(renderFrameSet, p);
                                                    if(idFrame != 0 && ( *( *idFrame) & 255) != 1) {
                                                        idFrame = 0;
                                                    }
                                                    goto L66;
                                                }
                                                _t420 =  *( *idFrame + 4);
                                                _v392 = p;
                                                 *__esp = _t420;
                                                strcmp();
                                                if(_t420 == 0) {
                                                    goto L66;
                                                }
                                                goto L63;
                                            }
                                        }
                                        goto __eax;
                                    }
                                    p = getescapecmd( &str);
L52:
                                    while(( *p & 255) != 0) {
                                        if(pos + 1 >= out_size) {
                                            out_size = (pos + pos + pos >> 31) + pos + pos + pos >> 1;
                                            _t512 = outc;
                                            _v392 = out_size;
                                             *__esp = _t512;
                                            GC_realloc();
                                            outc = _t512;
                                            _t514 = outp;
                                            _v392 = out_size + out_size;
                                             *__esp = _t514;
                                            GC_realloc();
                                            outp = _t514;
                                        }
                                        mode = ( *( &WTF_TYPE_MAP + ( *p & 0xff)) & 0xff) << 8;
                                        if(mode == 256 || mode == 8192) {
                                             *((short*)(outp + pos + pos)) = effect & 65535 | ex_efct(ex_effect & 65535);
                                            outc[pos] = 32;
                                            pos = pos + 1;
                                            p =  &(p[1]);
                                        } else {
                                            if((mode & 0x1000) == 0) {
                                                len =  *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff;
                                                 *((short*)(outp + pos + pos)) = ex_efct(ex_effect & 65535) | effect & 65535 | mode & 65535;
                                                _t467 = p;
                                                outc[pos] =  *_t467 & 255;
                                                p =  &(_t467[1]);
                                                pos = pos + 1;
                                                len = len - 1;
                                                if(len == 0) {
                                                    continue;
                                                }
                                                mode = mode & 0xf9 | 4;
                                                while(1) {
                                                    len = len - 1;
                                                    if(len == 0) {
                                                        goto L52;
                                                    }
                                                    if(pos + 1 >= out_size) {
                                                        out_size = (pos + pos + pos >> 31) + pos + pos + pos >> 1;
                                                        _t490 = outc;
                                                        _v392 = out_size;
                                                         *__esp = _t490;
                                                        GC_realloc();
                                                        outc = _t490;
                                                        _t492 = outp;
                                                        _v392 = out_size + out_size;
                                                         *__esp = _t492;
                                                        GC_realloc();
                                                        outp = _t492;
                                                    }
                                                     *((short*)(outp + pos + pos)) = ex_efct(ex_effect & 65535) | effect & 65535 | mode & 65535;
                                                    _t482 = p;
                                                    outc[pos] =  *_t482 & 255;
                                                    p =  &(_t482[1]);
                                                    pos = pos + 1;
                                                }
                                                continue;
                                            }
                                             *((short*)(outp + pos + pos)) = effect & 65535 | ex_efct(ex_effect & 65535);
                                            outc[pos] = 32;
                                            pos = pos + 1;
                                            p =  &(p[ *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff]);
                                        }
                                    }
                                } else {
                                    len =  *( &WTF_LEN_MAP + ( *str & 0xff)) & 0xff;
                                     *((short*)(outp + pos + pos)) = ex_efct(ex_effect & 65535) | effect & 65535 | mode & 65535;
                                    _t529 = str;
                                    outc[pos] =  *_t529 & 255;
                                    str =  &(_t529[1]);
                                    pos = pos + 1;
                                    len = len - 1;
                                    if(len == 0) {
                                        continue;
                                    }
                                    mode = mode & 0xf9 | 4;
                                    while(1) {
                                        len = len - 1;
                                        if(len == 0) {
                                            break;
                                        }
                                        if(pos + 1 >= out_size) {
                                            out_size = (pos + pos + pos >> 31) + pos + pos + pos >> 1;
                                            _t552 = outc;
                                            _v392 = out_size;
                                             *__esp = _t552;
                                            GC_realloc();
                                            outc = _t552;
                                            _t554 = outp;
                                            _v392 = out_size + out_size;
                                             *__esp = _t554;
                                            GC_realloc();
                                            outp = _t554;
                                        }
                                         *((short*)(outp + pos + pos)) = ex_efct(ex_effect & 65535) | effect & 65535 | mode & 65535;
                                        _t544 = str;
                                        outc[pos] =  *_t544 & 255;
                                        str =  &(_t544[1]);
                                        pos = pos + 1;
                                    }
                                }
                                continue;
                            }
                             *((short*)(outp + pos + pos)) = effect & 65535 | ex_efct(ex_effect & 65535);
                            outc[pos] = 32;
                            pos = pos + 1;
                            str =  &(str[ *( &WTF_LEN_MAP + ( *str & 0xff)) & 0xff]);
                        }
                        continue;
                    } else {
                        buf = set_symbol(symbol_width0);
                        p = buf[symbol];
                        len =  *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff;
                        mode = ( *( &WTF_TYPE_MAP + ( *p & 0xff)) & 0xff) << 8;
                         *((short*)(outp + pos + pos)) = ex_efct(ex_effect & 65535) | effect & 65535 | mode & 65535;
                        _t594 = p;
                        outc[pos] =  *_t594 & 255;
                        p =  &(_t594[1]);
                        pos = pos + 1;
                        len = len - 1;
                        if(len == 0) {
L22:
                            str =  &(str[symbol_width]);
                            continue;
                        } else {
                            mode = mode & 0xf9 | 4;
                            while(1) {
                                len = len - 1;
                                if(len == 0) {
                                    goto L22;
                                }
                                if(pos + 1 >= out_size) {
                                    out_size = (pos + pos + pos >> 31) + pos + pos + pos >> 1;
                                    _t619 = outc;
                                    _v392 = out_size;
                                     *__esp = _t619;
                                    GC_realloc();
                                    outc = _t619;
                                    _t621 = outp;
                                    _v392 = out_size + out_size;
                                     *__esp = _t621;
                                    GC_realloc();
                                    outp = _t621;
                                }
                                 *((short*)(outp + pos + pos)) = ex_efct(ex_effect & 65535) | effect & 65535 | mode & 65535;
                                _t611 = p;
                                outc[pos] =  *_t611 & 255;
                                p =  &(_t611[1]);
                                pos = pos + 1;
                            }
                            goto L22;
                        }
                    }
                }
                if(internal == 0) {
                    addnewline(buf, outc, outp, 0, pos, -1, nlines);
                }
                if(internal == 142) {
                    internal = 0;
                }
                if(str == endp) {
                    goto L78;
                } else {
                    line = Strsubstr(line, str - line->ptr, endp - str);
                    continue;
                }
            }
L81:
            form_id = 1;
            while(form_id <= form_max) {
                forms[form_id]->next = forms[form_id - 1];
                form_id = form_id + 1;
            }
            if(form_max < 0) {
                _t654 = 0;
            } else {
                _t654 = forms[form_max];
            }
            buf->formlist = _t654;
            if(n_textarea != 0) {
                addMultirowsForm(buf, buf->formitem);
            }
            addMultirowsImg(buf, buf->img);
            return;
        }
        if((line & 255) == 60) {
            goto L10;
        } else {
            Strcat( *(textarea_str + (n_textarea << 2)), line);
            continue;
        }
    }
    goto L81;
}

void addLink(Buffer* buf, struct parsed_tag* tag)
{// addr = 0x0806C0A4  --  defined in 'file.c' at line 5934
    char type;                             // _cfa_fffffff3
    char* href;                            // _cfa_ffffffec
    char* title;                           // _cfa_ffffffe8
    char* ctype;                           // _cfa_ffffffe4
    char* rel;                             // _cfa_ffffffe0
    char* rev;                             // _cfa_ffffffdc
    LinkList* l;      // _cfa_ffffffd8
    LinkList* i;      // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    LinkList* _t91;   // _t91

    href = 0;
    title = 0;
    ctype = 0;
    rel = 0;
    rev = 0;
    type = 0;
    parsedtag_get_value(tag, 18,  &href);
    if(href != 0) {
        href = url_quote( *(wc_Str_conv_strict(Strnew_charp(remove_space(href)), InnerCharset, buf->document_charset)));
    }
    parsedtag_get_value(tag, 49,  &title);
    parsedtag_get_value(tag, 33,  &ctype);
    parsedtag_get_value(tag, 47,  &rel);
    if(rel != 0) {
        type = 1;
        if(title == 0) {
            title = rel;
        }
    }
    parsedtag_get_value(tag, 48,  &rev);
    _t91 = rev;
    if(_t91 != 0) {
        type = 2;
        _t91 = title;
        if(_t91 == 0) {
            _t91 = rev;
            title = _t91;
        }
    }
     *__esp = 20;
    GC_malloc();
    l = _t91;
    l->url = href;
    l->title = title;
    l->ctype = ctype;
    l->type = type & 255;
    l->next = 0;
    if(buf->linklist == 0) {
        buf->linklist = l;
        return;
    } else {
        i = buf->linklist;
        while(i->next != 0) {
            i = i->next;
        }
        i->next = l;
        return;
    }
}

void HTMLlineproc2(Buffer* buf, TextLineList* tl)
{// addr = 0x0806C24B  --  defined in 'file.c' at line 5976
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    _tl_lp2 = tl->first;
    HTMLlineproc2body(buf, textlist_feed, -1);
}

Str file_feed()
{// addr = 0x0806C278  --  defined in 'file.c' at line 5985
    Str s;                 // _cfa_fffffff0

    s = StrISgets(_file_lp2);
    if(s->length != 0) {
        return s;
    }
    ISclose(_file_lp2);
    return 0;
}

void HTMLlineproc3(Buffer* buf, InputStream stream)
{// addr = 0x0806C2B1  --  defined in 'file.c' at line 5997
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    _file_lp2 = stream;
    HTMLlineproc2body(buf, file_feed, -1);
}

void proc_escape(struct readbuffer* obuf, char** str_return)
{// addr = 0x0806C2DC  --  defined in 'file.c' at line 6004
    Lineprop mode;    // _cfa_fffffff2
    char* str;                             // _cfa_ffffffec
    char* estr;                            // _cfa_ffffffe8
    int ech;                               // _cfa_ffffffe4
    int width;                             // _cfa_ffffffe0
    int n_add;                             // _cfa_ffffffdc
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    short unsigned int _t82;               // _t82
    int _t96;                              // _t96
    int _t108;                             // _t108

    str =  *str_return;
    ech = getescapechar(str_return);
    n_add =  *str_return - str;
    mode = 0;
    if(ech < 0) {
         *str_return = str;
        proc_mchar(obuf, obuf->flag & 655, 1, str_return, 0);
        return;
    }
    if(( *( &MYCTYPE_MAP + (ech & 255)) & 1) == 0) {
        _t82 = 0;
    } else {
        _t82 = 256;
    }
    mode = _t82;
    estr = conv_entity(ech);
    check_breakpoint(obuf, obuf->flag & 655, estr);
    width = wtf_strwidth(estr);
    if(width != 1 || ( *estr & 0xff) != ech || ech == 38 || ech == 60 || ech == 62) {
        push_nchars(obuf, width, str, n_add, mode & 65535);
    } else {
        if(( *( &MYCTYPE_MAP + (ech & 255)) & 1) != 0) {
            mode = 256;
        }
        _t108 = estr;
         *__esp = _t108;
        strlen();
        push_nchars(obuf, width, estr, _t108, mode & 65535);
    }
    _t96 = estr;
     *__esp = _t96;
    strlen();
    Strcopy_charp_n(obuf->prevchar, estr, _t96);
    obuf->prev_ctype = mode & 65535;
}

int need_flushline(struct html_feed_environ* h_env, struct readbuffer* obuf, Lineprop mode)
{// addr = 0x0806C497  --  defined in 'file.c' at line 6035
    char ch;                               // _cfa_fffffffb
    short _v24;                            // _cfa_ffffffe8
    char _t28;                             // _t28

    _v24 = mode;
    if((obuf->flag & 512) == 0) {
        if(obuf->line->length <= 0) {
            _t28 = 0;
        } else {
            _t28 =  *( *(obuf->line) + obuf->line->length - 1) & 255;
        }
        ch = _t28;
        if(ch != 32) {
            if((obuf->pos & 65535) <= h_env->limit) {
                return 0;
            }
            return 1;
        } else {
            return 0;
        }
    }
    if((obuf->pos & 65535) <= h_env->limit) {
        return 0;
    }
    return 1;
}

int table_width(struct html_feed_environ* h_env, int table_level)
{// addr = 0x0806C532  --  defined in 'file.c' at line 6059
    int width;                             // _cfa_fffffff8

    if(table_level >= 0) {
        width =  *( *((intOrPtr*)( &tables + table_level * 4)) + 24);
        if(table_level > 0 || width > 0) {
            return width;
        } else {
            return h_env->limit - ( &(h_env->envs[h_env->envc])->indent & 255);
        }
    }
    return 0;
}

void HTMLlineproc0(char* line, struct html_feed_environ* h_env, int internal)
{// addr = 0x0806C58D  --  defined in 'file.c' at line 6072
    char ch;                               // _cfa_fffffff3
    Lineprop mode;    // _cfa_fffffff0
    int cmd;                               // _cfa_ffffffec
    struct readbuffer* obuf;   // _cfa_ffffffe8
    int indent;                            // _cfa_ffffffe4
    int delta;                             // _cfa_ffffffe0
    struct parsed_tag* tag;   // _cfa_ffffffdc
    Str tokbuf;            // _cfa_ffffffd8
    struct table* tbl;   // _cfa_ffffffd4
    struct table_mode* tbl_mode;   // _cfa_ffffffd0
    int tbl_width;                         // _cfa_ffffffcc
    int is_hangul;                         // _cfa_ffffffc8
    int prev_is_hangul;                    // _cfa_ffffffc4
    int level;                             // _cfa_ffffffc0
    char* str;                             // _cfa_ffffffbc
    char* p;                               // _cfa_ffffffb8
    int is_tag;                            // _cfa_ffffffb4
    int pre_mode;                          // _cfa_ffffffb0
    int end_tag;                           // _cfa_ffffffac
    struct table* tbl0;   // _cfa_ffffffa8
    int indent;                            // _cfa_ffffffa4
    int indent;                            // _cfa_ffffffa0
    char* p;                               // _cfa_ffffff9c
    int ech;                               // _cfa_ffffff98
    char* p;                               // _cfa_ffffff94
    char* bp;                              // _cfa_ffffff90
    char* tp;                              // _cfa_ffffff8c
    int i;                                 // _cfa_ffffff88
    Str line;              // _cfa_ffffff84
    char* tp;                              // _cfa_ffffff80
    int i;                                 // _cfa_ffffff7c
    signed int _v144;                      // _cfa_ffffff70
    int _v172;                             // _cfa_ffffff54 (outparam)
    int _v176;                             // _cfa_ffffff50 (outparam)
    int _v180;                             // _cfa_ffffff4c (outparam)
    char* _v184;                           // _cfa_ffffff48 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ _t639;                       // _t639
    int _t644;                             // _t644
    int _t699;                             // _t699
    char* _t800;                           // _t800
    char* _t802;                           // _t802
    signed int _t923;                      // _t923

    obuf = h_env->obuf;
    tbl = 0;
    tbl_mode = 0;
    tbl_width = 0;
    prev_is_hangul = 0;
    tokbuf = Strnew();
L1:
    while(1) {
L1:
        if((obuf->table_level & 65535) >= 0) {
            _t923 = obuf->table_level & 65535;
            _t924 = _t923 - 19 > 0 ? 19 : _t923;
            _t925 = _t923 - 19 > 0 ? 19 : _t923;
            level = _t923 - 19 > 0 ? 19 : _t923;
            tbl =  *( &tables + level * 4);
            tbl_mode =  &table_mode + (level << 4);
            tbl_width = table_width(h_env, level);
        }
        while(( *line & 255) != 0) {
            end_tag = _t644;
            if(( *line & 255) == 60) {
L11:
                if(obuf->status != 7) {
                    read_token(h_env->tagbuf,  &line,  &(obuf->status), pre_mode & 2575, obuf->status != 0 & 255);
                    if(obuf->status != 0) {
L175:
                        return;
                    }
                    goto L14;
                } else {
                    obuf->status = 0;
L14:
                    if(h_env->tagbuf->length == 0) {
                        continue;
                    }
                    str =  *(h_env->tagbuf);
                    if(( *str & 255) != 60) {
L31:
                        if((pre_mode & 22542) == 0) {
L58:
                            if((obuf->table_level & 65535) < 0) {
L73:
                                if(is_tag == 0) {
                                    if((obuf->flag & 3145728) == 0) {
                                        while(1) {
                                            str =  *str & 255;
                                            if(__al == 0) {
                                                break;
                                            }
                                            str =  *str & 255;
                                            __eax =  *(__eax +  &WTF_TYPE_MAP) & 255;
                                            mode = __ax;
                                            if(__al == 0) {
                                                str =  *str & 255;
                                                __al = __al != 0;
                                                __eax = __al & 255;
                                            } else {
                                                str =  *str & 255;
                                                __eax =  *(__eax +  &WTF_WIDTH_MAP) & 255;
                                                __eax = __al & 255;
                                            }
                                            delta = __eax;
                                            obuf = obuf->flag;
                                            __eax = obuf->flag & 527;
                                            if((obuf->flag & 527) == 0) {
                                                str =  *str & 255;
                                                __eax =  *(__eax +  &MYCTYPE_MAP) & 255;
                                                __eax = __al & 255;
                                                if(__eax == 0) {
                                                    __eax = obuf;
                                                    __eax = obuf->flag;
                                                    __edx = obuf->flag;
                                                    __eax = obuf;
                                                    obuf->flag = obuf->flag;
                                                }
                                                if(mode == 0 || mode == 256) {
                                                    str =  *str & 255;
                                                    __eax =  *(__eax +  &MYCTYPE_MAP) & 255;
                                                    __eax = __al & 255;
                                                    if(__eax == 0) {
                                                        goto L123;
                                                    }
                                                    obuf = obuf->prevchar;
                                                     *(obuf->prevchar) =  *( *(obuf->prevchar)) & 255;
                                                    if(__al != 32) {
                                                        obuf = obuf->flag;
                                                        __eax = obuf->flag & 655;
                                                        _v180 = 32;
                                                        _v184 = obuf->flag & 655;
                                                        __eax = obuf;
                                                         *__esp = obuf;
                                                        push_char();
                                                    }
                                                    str =  &(str[1]);
                                                    str =  &(str[1]);
                                                    goto L147;
                                                } else {
L123:
                                                    if(mode != 2560) {
                                                        is_hangul = 0;
                                                    } else {
                                                        str = wtf_is_hangul(str);
                                                        is_hangul = __eax;
                                                    }
                                                    if(__al != 0 || mode != 2560 || is_hangul != 0 || prev_is_hangul != 0) {
L144:
                                                        __eax = is_hangul;
                                                        prev_is_hangul = is_hangul;
                                                        str =  *str & 255;
                                                        if(__al != 38) {
                                                            __eax = mode & 65535;
                                                            obuf = obuf->flag;
                                                            __edx = obuf->flag & 655;
                                                            _v172 = mode & 65535;
                                                            __eax =  &str;
                                                            _v176 =  &str;
                                                            __eax = delta;
                                                            _v180 = delta;
                                                            _v184 = obuf->flag & 655;
                                                            __eax = obuf;
                                                             *__esp = obuf;
                                                            proc_mchar();
                                                        } else {
                                                            __eax =  &str;
                                                            _v184 =  &str;
                                                            __eax = obuf;
                                                             *__esp = obuf;
                                                            proc_escape();
                                                        }
                                                        goto L147;
                                                    } else {
                                                        __eax = obuf;
                                                        __edx = obuf->pos & 65535;
                                                        h_env = h_env;
                                                        h_env->envc = h_env->envc << 4;
                                                         &(h_env->envs[h_env->envc]) =  &(h_env->envs[h_env->envc])->indent & 255;
                                                        asm("cbw");
                                                        if(__dx <= __ax) {
                                                            goto L144;
                                                        }
                                                        obuf = obuf->line;
                                                        __eax =  *(obuf->line + 4);
                                                        if( *(obuf->line + 4) <= 0) {
                                                            goto L144;
                                                        }
                                                        obuf = obuf->line;
                                                        __edx =  *(obuf->line);
                                                        obuf = obuf->line;
                                                         *(obuf->line + 4) =  *(obuf->line + 4) - 1;
                                                         *(obuf->line) +  *(obuf->line + 4) - 1 =  *( *(obuf->line) +  *(obuf->line + 4) - 1) & 255;
                                                        if(__al != 32) {
                                                            goto L144;
                                                        }
                                                        while(1) {
                                                            obuf = obuf->line;
                                                            __eax =  *(obuf->line + 4);
                                                            if( *(obuf->line + 4) <= 1) {
                                                                break;
                                                            }
                                                            obuf = obuf->line;
                                                            __edx =  *(obuf->line);
                                                            obuf = obuf->line;
                                                             *(obuf->line + 4) =  *(obuf->line + 4) - 2;
                                                            __eax =  *(obuf->line) +  *(obuf->line + 4) - 2;
                                                            _v180 = 2;
                                                            _v184 = "  ";
                                                             *__esp = __eax;
                                                            strncmp();
                                                            if(__eax != 0) {
                                                                break;
                                                            }
                                                            __eax = obuf;
                                                            __edx = obuf->pos & 65535;
                                                            h_env = h_env;
                                                            h_env->envc = h_env->envc << 4;
                                                             &(h_env->envs[h_env->envc]) =  &(h_env->envs[h_env->envc])->indent & 255;
                                                            asm("cbw");
                                                            if(__dx >= __ax) {
                                                                obuf = obuf->line;
                                                                Strshrink(obuf->line, 1);
                                                                obuf = obuf->pos & 65535;
                                                                __edx = (obuf->pos & 65535) - 1;
                                                                __eax = obuf;
                                                                obuf->pos = __dx;
                                                                continue;
                                                            }
                                                            break;
                                                        }
                                                        obuf = obuf->line;
                                                        __eax =  *(obuf->line + 4);
                                                        if( *(obuf->line + 4) > 2) {
                                                            obuf = obuf->prev_ctype & 65535;
                                                            if(__ax == 2560) {
                                                                obuf = obuf->line;
                                                                __eax =  *(obuf->line + 4);
                                                                if( *(obuf->line + 4) > 0) {
                                                                    obuf = obuf->line;
                                                                    __edx =  *(obuf->line);
                                                                    obuf = obuf->line;
                                                                     *(obuf->line + 4) =  *(obuf->line + 4) - 1;
                                                                     *(obuf->line) +  *(obuf->line + 4) - 1 =  *( *(obuf->line) +  *(obuf->line + 4) - 1) & 255;
                                                                    if(__al == 32) {
                                                                        __eax = obuf;
                                                                        __edx = obuf->pos & 65535;
                                                                        h_env = h_env;
                                                                        h_env->envc = h_env->envc << 4;
                                                                         &(h_env->envs[h_env->envc]) =  &(h_env->envs[h_env->envc])->indent & 255;
                                                                        asm("cbw");
                                                                        if(__dx >= __ax) {
                                                                            obuf = obuf->line;
                                                                            Strshrink(obuf->line, 1);
                                                                            obuf = obuf->pos & 65535;
                                                                            __edx = (obuf->pos & 65535) - 1;
                                                                            __eax = obuf;
                                                                            obuf->pos = __dx;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        goto L144;
                                                    }
                                                }
                                            } else {
                                                str =  *str & 255;
                                                ch = __al;
                                                obuf = obuf->flag;
                                                __eax = obuf->flag & 8;
                                                if((obuf->flag & 8) == 0) {
                                                    str =  *str & 255;
                                                    if(__al == 38) {
                                                        __eax = str;
                                                        p = str;
                                                        __eax =  &p;
                                                        ech = getescapechar( &p);
                                                        if(ech == 10 || ech == 13) {
                                                            ch = 10;
                                                            p = p - 1;
                                                            str = p - 1;
                                                        } else {
                                                            if(ech == 9) {
                                                                ch = 9;
                                                                p = p - 1;
                                                                str = p - 1;
                                                            }
                                                        }
                                                    }
                                                }
                                                if(ch != 10) {
                                                    __eax = obuf;
                                                    __eax = obuf->flag;
                                                    __edx = obuf->flag;
                                                    __eax = obuf;
                                                    obuf->flag = obuf->flag;
                                                }
                                                if(ch != 10) {
                                                    if(ch != 9) {
                                                        obuf = obuf->flag;
                                                        __eax = obuf->flag & 8;
                                                        if((obuf->flag & 8) == 0) {
                                                            str =  *str & 255;
                                                            if(__al != 38) {
                                                                __eax = mode & 65535;
                                                                _v172 = mode & 65535;
                                                                __eax =  &str;
                                                                _v176 =  &str;
                                                                __eax = delta;
                                                                _v180 = delta;
                                                                _v184 = 1;
                                                                __eax = obuf;
                                                                 *__esp = obuf;
                                                                proc_mchar();
                                                            } else {
                                                                __eax =  &str;
                                                                _v184 =  &str;
                                                                __eax = obuf;
                                                                 *__esp = obuf;
                                                                proc_escape();
                                                            }
                                                        } else {
                                                            str =  *str & 255;
                                                            __eax =  *(__eax +  &QUOTE_MAP) & 255;
                                                            __eax = __al & 255;
                                                            __eax = __eax & 7;
                                                            p = __eax;
                                                            if(p == 0) {
                                                                __eax = mode & 65535;
                                                                _v172 = mode & 65535;
                                                                __eax =  &str;
                                                                _v176 =  &str;
                                                                __eax = delta;
                                                                _v180 = delta;
                                                                _v184 = 1;
                                                                __eax = obuf;
                                                                 *__esp = obuf;
                                                                proc_mchar();
                                                            } else {
                                                                __eax = p;
                                                                 *__esp = __eax;
                                                                strlen();
                                                                _v172 = 0;
                                                                _v176 = __eax;
                                                                __eax = p;
                                                                _v180 = p;
                                                                _v184 = 1;
                                                                __eax = obuf;
                                                                 *__esp = obuf;
                                                                push_nchars();
                                                                str =  &(str[1]);
                                                                str =  &(str[1]);
                                                            }
                                                        }
                                                        goto L113;
                                                    } else {
                                                        goto L104;
                                                    }
                                                    do {
L104:
                                                        obuf = obuf->flag;
                                                        __eax = obuf->flag & 655;
                                                        _v180 = 32;
                                                        _v184 = obuf->flag & 655;
                                                        __eax = obuf;
                                                         *__esp = obuf;
                                                        push_char();
                                                        __eax = h_env;
                                                        __edx = h_env->envs;
                                                        h_env = h_env->envc;
                                                        h_env->envc << 4 =  &(h_env->envs[h_env->envc]);
                                                        __edx = __al;
                                                        __eax = obuf;
                                                        __eax = obuf->pos & 65535;
                                                        __ax = __eax;
                                                        __edx = __eax + __al;
                                                        __eax = Tabstop;
                                                        _v144 = Tabstop;
                                                        __eax = __edx;
                                                        __edx = __edx >> 31;
                                                        _t380 = __eax % _v144;
                                                        __eax = __eax / _v144;
                                                        __edx = _t380;
                                                        __eax = _t380;
                                                    } while(_t380 != 0);
                                                    str =  &(str[1]);
                                                    str =  &(str[1]);
                                                    goto L113;
                                                } else {
                                                    str =  &(str[1]);
                                                    str =  &(str[1]);
                                                    obuf = obuf->flag;
                                                    __eax = obuf->flag & 8192;
                                                    if((obuf->flag & 8192) == 0) {
                                                        obuf = obuf->flag;
                                                        __eax = obuf->flag & 512;
                                                        if((obuf->flag & 512) == 0) {
                                                            __eax = h_env;
                                                            __edx = h_env->limit;
                                                            h_env = h_env;
                                                            h_env->envc = h_env->envc << 4;
                                                             &(h_env->envs[h_env->envc]) =  &(h_env->envs[h_env->envc])->indent & 255;
                                                            __eax = __al;
                                                            _v172 = h_env->limit;
                                                            _v176 = 1;
                                                            _v180 = __eax;
                                                            __eax = obuf;
                                                            _v184 = obuf;
                                                            __eax = h_env;
                                                             *__esp = h_env;
                                                            flushline();
                                                        } else {
                                                            obuf = obuf->flag;
                                                            __eax = obuf->flag & 655;
                                                            _v180 = 32;
                                                            _v184 = obuf->flag & 655;
                                                            __eax = obuf;
                                                             *__esp = obuf;
                                                            push_char();
                                                        }
L113:
                                                        obuf = obuf->flag;
                                                        __eax = obuf->flag & 143;
                                                        if((obuf->flag & 143) == 0) {
L147:
                                                            __eax = mode & 65535;
                                                            _v180 = mode & 65535;
                                                            __eax = obuf;
                                                            _v184 = obuf;
                                                            __eax = h_env;
                                                             *__esp = h_env;
                                                            if(need_flushline() != 0) {
                                                                obuf = obuf->line;
                                                                __edx =  *(obuf->line);
                                                                obuf = obuf->bp.len;
                                                                __eax =  *(obuf->line) + obuf->bp.len;
                                                                bp =  *(obuf->line) + obuf->bp.len;
                                                                obuf = obuf->bp.tlen;
                                                                 ~(obuf->bp.tlen) =  &(bp[ ~(obuf->bp.tlen)]);
                                                                tp =  &(bp[ ~(obuf->bp.tlen)]);
                                                                i = 0;
                                                                obuf = obuf->line;
                                                                __eax =  *(obuf->line);
                                                                if( *(obuf->line) < tp) {
                                                                    tp = tp - 1;
                                                                    if(__al == 32) {
                                                                        i = 1;
                                                                    }
                                                                }
                                                                __eax = h_env;
                                                                __edx = h_env->envs;
                                                                h_env = h_env->envc;
                                                                h_env->envc << 4 =  &(h_env->envs[h_env->envc]);
                                                                __eax =  &(h_env->envs[h_env->envc])->indent & 255;
                                                                indent = __eax;
                                                                obuf = obuf->bp;
                                                                __eax = obuf->bp - i;
                                                                if(obuf->bp - i > indent) {
                                                                    __eax = obuf;
                                                                    append_tags(obuf);
                                                                    __eax = bp;
                                                                    line = Strnew_charp(bp);
                                                                    obuf = obuf->line;
                                                                    __edx =  *(obuf->line + 4);
                                                                    obuf = obuf->bp.len;
                                                                    __edx =  *(obuf->line + 4) - obuf->bp.len;
                                                                    obuf = obuf->line;
                                                                    Strshrink(obuf->line,  *(obuf->line + 4) - obuf->bp.len);
                                                                    __eax = obuf;
                                                                    back_to_breakpoint(obuf);
                                                                    h_env = h_env->limit;
                                                                    _v172 = h_env->limit;
                                                                    _v176 = 0;
                                                                    __eax = indent;
                                                                    _v180 = indent;
                                                                    __eax = obuf;
                                                                    _v184 = obuf;
                                                                    __eax = h_env;
                                                                     *__esp = h_env;
                                                                    flushline();
                                                                    line = line->ptr;
                                                                    _v180 = 1;
                                                                    __edx = h_env;
                                                                    _v184 = h_env;
                                                                     *__esp = line->ptr;
                                                                    __eax = HTMLlineproc0();
                                                                }
                                                            }
                                                            continue;
                                                        }
                                                        continue;
                                                    }
                                                    __eax = obuf;
                                                    __eax = obuf->flag;
                                                    __edx = obuf->flag;
                                                    __eax = obuf;
                                                    obuf->flag = obuf->flag;
                                                    continue;
                                                }
                                            }
                                        }
                                        continue;
                                    }
                                    continue;
                                }
                                tag = parse_tag( &str, internal);
                                if(tag == 0) {
                                    continue;
                                }
                                cmd = tag->tagid & 0xff;
                                if(HTMLtagproc1(tag, h_env) != 0) {
                                    process_idattr(obuf, cmd, tag);
                                } else {
                                    if((tag->need_reconstruct & 255) != 0) {
                                        h_env->tagbuf = parsedtag2str(tag);
                                    }
                                    push_tag(obuf,  *(h_env->tagbuf), cmd);
                                }
                                obuf->bp.init_flag = 1;
                                clear_ignore_p_flag(cmd, obuf);
                                if(cmd != 31) {
                                    continue;
                                } else {
                                    goto L1;
                                }
                            }
                            _t699 = feed_table(tbl, str, tbl_mode, tbl_width, internal);
                            if(_t699 == 0) {
                                obuf->table_level = (obuf->table_level & 65535) - 1;
                                if((obuf->table_level & 65535) <= 18) {
                                    end_table(tbl);
                                    if((obuf->table_level & 65535) < 0) {
                                        if((obuf->flag & 1048576) == 0) {
                                            if(tbl->vspace > 0 && (obuf->flag & 8192) == 0) {
                                                indent =  &(h_env->envs[h_env->envc])->indent & 255;
                                                flushline(h_env, obuf, indent, 0, h_env->limit);
                                                do_blankline(h_env, obuf, indent, 0, h_env->limit);
                                            }
                                            save_fonteffect(h_env, obuf);
                                            renderTable(tbl, tbl_width, h_env);
                                            restore_fonteffect(h_env, obuf);
                                            obuf->flag = obuf->flag & 223;
                                            if(tbl->vspace > 0) {
                                                indent =  &(h_env->envs[h_env->envc])->indent & 255;
                                                do_blankline(h_env, obuf, indent, 0, h_env->limit);
                                                obuf->flag = obuf->flag | 32;
                                            }
                                            Strcopy_charp_n(obuf->prevchar, " ", 1);
                                        }
                                    } else {
                                        tbl0 =  *( &tables + (obuf->table_level & 65535) * 4);
                                        _v184 = tbl0->ntable & 65535;
                                        str =  *(Sprintf("<table_alt tid=%d>"));
                                        pushTable(tbl0, tbl);
                                        tbl = tbl0;
                                        tbl_mode =  &table_mode + ((obuf->table_level & 65535) << 4);
                                        tbl_width = table_width(h_env, obuf->table_level & 65535);
                                        feed_table(tbl, str, tbl_mode, tbl_width, 1);
                                    }
                                }
                                continue;
                            }
                            if(_t699 == 1) {
                                goto L73;
                            } else {
                                continue;
                            }
                        }
                        if(is_tag == 0) {
L40:
                            if((pre_mode & 16384) == 0) {
                                if((pre_mode & 4096) == 0) {
                                    if(is_tag != 0) {
                                        _t800 = str;
                                        _v180 = 4;
                                        _v184 = 135047049;
                                         *__esp = _t800;
                                        strncmp();
                                        if(_t800 != 0) {
                                            _t802 =  &(str[1]);
                                            _v184 = 60;
                                             *__esp = _t802;
                                            strchr();
                                            p = _t802;
                                            if(p != 0) {
                                                str =  *(Strnew_charp_n(str, p - str));
                                                _v180 = 0;
                                                _v184 = line;
                                                line =  *(Strnew_m_charp(p));
                                            }
                                        }
                                        is_tag = 0;
                                    }
                                    if((obuf->table_level & 65535) >= 0) {
                                        goto L58;
                                    }
                                    if((pre_mode & 2048) == 0) {
                                        if((pre_mode & 2) != 0) {
                                            continue;
                                        }
                                        if((pre_mode & 4) != 0) {
                                            continue;
                                        } else {
                                            goto L58;
                                        }
                                    } else {
                                        feed_textarea(str);
                                        continue;
                                    }
                                }
                                if((obuf->table_level & 65535) >= 0) {
                                    goto L58;
                                } else {
                                    feed_select(str);
                                    continue;
                                }
                            } else {
                                feed_title(str);
                                continue;
                            }
                        }
                        p = str;
                        tag = parse_tag( &p, internal);
                        if(tag == 0 || (tag->tagid & 0xff) != end_tag && ((pre_mode & 4096) == 0 || (tag->tagid & 255) != 43) && ((pre_mode & 16384) == 0 || (tag->tagid & 255) != 96 && (tag->tagid & 255) != 72)) {
                            goto L40;
                        } else {
                            goto L58;
                        }
                    }
                    if((str[1] & 255) == 0) {
L24:
                        if((pre_mode & 22542) == 0) {
                            _v180 = 0;
                            _v184 = line;
                            line =  *(Strnew_m_charp( &(str[1])));
                            str = 135047044;
                        }
                        goto L31;
                    }
                    if(( *( &MYCTYPE_MAP + (str[1] & 0xff)) & 4) != 0 || (str[1] & 255) == 47 || (str[1] & 255) == 33 || (str[1] & 255) == 63 || (str[1] & 255) == 0 || (str[1] & 255) == 95) {
                        is_tag = 1;
                        goto L31;
                    } else {
                        goto L24;
                    }
                }
            }
            if(obuf->status == 0) {
                read_token(tokbuf,  &line,  &(obuf->status), pre_mode & 2575, 0);
                if(obuf->status != 0) {
                    obuf->status = 0;
                }
                str = tokbuf->ptr;
                goto L31;
            }
            goto L11;
        }
        if((obuf->flag & 6799) != 0) {
            goto L175;
        }
        i = 0;
        if(obuf->bp != (obuf->pos & 65535)) {
            tp =  *(obuf->line) +  *(obuf->line + 4);
        } else {
            tp =  *(obuf->line) + obuf->bp.len - obuf->bp.tlen;
        }
        if( *(obuf->line) < tp && ( *(tp - 1) & 255) == 32) {
            i = 1;
        }
        indent =  &(h_env->envs[h_env->envc])->indent & 255;
        if((obuf->pos & 65535) - i <= h_env->limit) {
            goto L175;
        } else {
            flushline(h_env, obuf, indent, 0, h_env->limit);
            return;
        }
    }
}

void addnewline2(Buffer* buf, char* line, Lineprop* prop, Linecolor* color, int pos, int nlines)
{// addr = 0x0806D554  --  defined in 'file.c' at line 6439
    Line* l;              // _cfa_fffffff0

     *__esp = 52;
    GC_malloc();
    l = __eax;
    l->next = 0;
    l->lineBuf = line;
    l->propBuf = prop;
    l->colorBuf = color;
    l->len = pos;
    l->width = -1;
    l->size = pos;
    l->bpos = 0;
    l->bwidth = 0;
    l->prev = buf->currentLine;
    if(buf->currentLine == 0) {
        l->next = 0;
    } else {
        l->next = buf->currentLine->next;
        buf->currentLine->next = l;
    }
    if(buf->lastLine == 0 || buf->lastLine == buf->currentLine) {
        buf->lastLine = l;
    }
    buf->currentLine = l;
    if(buf->firstLine == 0) {
        buf->firstLine = l;
    }
    buf->allLine =  &(buf->allLine->lineBuf);
    l->linenumber = buf->allLine;
    if(nlines >= 0) {
        l->real_linenumber = nlines;
    } else {
        l->real_linenumber = 0;
    }
    l = 0;
}

void addnewline(Buffer* buf, char* line, Lineprop* prop, Linecolor* color, int pos, int width, int nlines)
{// addr = 0x0806D678  --  defined in 'file.c' at line 6479
    char* s;                               // _cfa_fffffff0
    Lineprop* p;      // _cfa_ffffffec
    Linecolor* c;    // _cfa_ffffffe8
    Line* l;              // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    int bpos;                              // _cfa_ffffffdc
    int bwidth;                            // _cfa_ffffffd8
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    int _v68;                              // _cfa_ffffffbc (outparam)
    Linecolor* _v72;   // _cfa_ffffffb8 (outparam)
    Linecolor* _t159;   // _t159
    Lineprop* _t167;   // _t167

    if(pos <= 0) {
        s = NullLine;
        p =  &NullProp;
    } else {
        s = allocStr(line, pos);
        _t167 = pos + pos;
         *__esp = _t167;
        GC_malloc_atomic();
        p = _t167;
        _v68 = pos + pos;
        _v72 = p;
         *__esp = prop;
        bcopy();
    }
    if(pos <= 0 || color == 0) {
        c = 0;
    } else {
        _t159 = pos;
         *__esp = _t159;
        GC_malloc_atomic();
        c = _t159;
        _v68 = pos;
        _v72 = c;
         *__esp = color;
        bcopy();
    }
    addnewline2(buf, s, p, c, pos, nlines);
    if(pos <= 0) {
        return;
    } else {
        if(width <= 0) {
            return;
        }
        bpos = 0;
        bwidth = 0;
        while(1) {
            l = buf->currentLine;
            l->bpos = bpos;
            l->bwidth = bwidth;
            i = columnLen(l, width);
            if(i != 0) {
                goto L15;
            }
            i = i + 1;
            while(l->len > i && ( *(p + i + i) & 0x400) != 0) {
                i = i + 1;
            }
L15:
            l->len = i;
            l->width = calcPosition(l->lineBuf, l->propBuf, l->len, l->len, 0, 0);
            if(pos <= i) {
                return;
            }
            bpos = bpos + l->len;
            bwidth = bwidth + l->width;
            s =  &(s[i]);
            p = p + i + i;
            if(c != 0) {
                c = c + i;
            }
            pos = pos - i;
            addnewline2(buf, s, p, c, pos, nlines);
        }
    }
}

Buffer* loadHTMLBuffer(URLFile* f, Buffer* newBuf)
{// addr = 0x0806D888  --  defined in 'file.c' at line 6546
    FILE* src;            // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    FILE* _t71;           // _t71
    int _t77;                              // _t77
    int _t78;                              // _t78
    int _t88;                              // _t88

    src = 0;
    if(newBuf != 0) {
L5:
        if(newBuf->sourcefile == 0 && ((f->scheme & 255) != 4 || newBuf->mailcap != 0)) {
            tmp = tmpfname(1, ".html");
            _t71 = tmp->ptr;
            _v40 = 135041136;
             *__esp = _t71;
            fopen();
            src = _t71;
            if(src != 0) {
                newBuf->sourcefile = tmp->ptr;
            }
        }
        loadHTMLstream(f, newBuf, src, newBuf->bufferprop & 2);
        newBuf->topLine = newBuf->firstLine;
        newBuf->lastLine = newBuf->currentLine;
        newBuf->currentLine = newBuf->firstLine;
        if(n_textarea != 0) {
            formResetBuffer(newBuf, newBuf->formitem);
        }
        if(src != 0) {
             *__esp = src;
            fclose();
        }
        return newBuf;
    }
    _t88 = COLS;
    if(showLineNum == 0) {
        _t77 = 1;
    } else {
        _t77 = 6;
    }
    _t78 = _t88 - _t77;
    _t79 = _t78 < 0 ? 0 : _t78;
    newBuf = newBuffer(_t78 < 0 ? 0 : _t78);
    goto L5;
}

char* convert_size(clen_t size, int usefloat)
{// addr = 0x0806D9B9  --  defined in 'file.c' at line 6579
    float csize;                           // _cfa_fffffff0
    int sizepos;                           // _cfa_ffffffec
    char** sizes;                          // _cfa_ffffffe8
    int _v32;                              // _cfa_ffffffe0
    long long int _v36;                    // _cfa_ffffffdc
    char* _v48;                            // _cfa_ffffffd0
    long long _v56;                        // _cfa_ffffffc8
    char* __ebx;                           // r1
    char* _t27;                            // _t27
    _unknown_ _t35;                        // _t35
    long long _t45;                        // _t45

    _v36 = size;
    _v32 = usefloat;
    sizepos = 0;
    sizes =  &_size_unit;
    asm("fild qword [ebp-0x20]");
    csize = __fp0;
    while(1) {
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        st0 =  *135048104;
        if(_t35 >= 0 || sizes[sizepos + 1] == 0) {
            break;
        }
        asm("fdivp st1, st0");
        csize =  *135048096;
        sizepos = sizepos + 1;
    }
    __ebx = sizes[sizepos];
    asm("fmulp st1, st0");
    asm("faddp st1, st0");
     *__esp =  *135048064;
    floor();
    _t45 =  *135048056;
    asm("fdivp st1, st0");
    if( *((intOrPtr*)(__ebp + 16)) == 0) {
        _t27 = "%.0f%s";
    } else {
        _t27 = "%.3g%s";
    }
    _v48 = __ebx;
    _v56 = _t45;
    return  *(Sprintf(_t27));
}

char* convert_size2(clen_t size1, clen_t size2, int usefloat)
{// addr = 0x0806DA74  --  defined in 'file.c' at line 6595
    char** sizes;                          // _cfa_fffffff0
    float csize;                           // _cfa_ffffffec
    float factor;                          // _cfa_ffffffe8
    int sizepos;                           // _cfa_ffffffe4
    long long int _v32;                    // _cfa_ffffffe0
    int _v36;                              // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    int _v44;                              // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    int _v52;                              // _cfa_ffffffcc
    long long _v60;                        // _cfa_ffffffc4
    char* _v72;                            // _cfa_ffffffb8
    long long _v80;                        // _cfa_ffffffb0
    long long _v88;                        // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    int _t42;                              // _t42
    char* _t47;                            // _t47
    intOrPtr _t55;                         // _t55
    char* _t56;                            // _t56
    _unknown_ _t59;                        // _t59
    long long _t75;                        // _t75

    _v36 = size1;
    _v32 = size2;
    _v44 = usefloat;
    _v40 = _a16;
    sizes =  &_size_unit;
    factor = 1065353216;
    sizepos = 0;
    __ecx = _v36;
    _t55 = _v32;
    _t42 = _v44;
    __edx = _v40;
    if(__edx > _t55) {
L4:
        _v52 = _t42;
        _v48 = __edx;
        asm("fild qword [ebp-0x30]");
        csize = __fp0;
        while(1) {
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            st0 =  *135048104;
            if(_t59 >= 0 || sizes[sizepos + 1] == 0) {
                break;
            }
            asm("fmulp st1, st0");
            factor =  *135048096;
            sizepos = sizepos + 1;
        }
        _t56 = sizes[sizepos];
        asm("fild qword [ebp-0x28]");
        asm("fmulp st1, st0");
        asm("faddp st1, st0");
         *__esp =  *135048064;
        floor();
        asm("fdivp st1, st0");
        _v60 =  *135048056;
        asm("fild qword [ebp-0x20]");
        asm("fmulp st1, st0");
        asm("faddp st1, st0");
         *__esp =  *135048064;
        floor();
        asm("fdivp st1, st0");
        if( *((intOrPtr*)(__ebp + 24)) == 0) {
            _t47 = "%.0f/%.0f%s";
        } else {
            _t47 = "%.3g/%.3g%s";
        }
        _v72 = _t56;
        _t75 = _v60;
        _v80 = _t75;
        _v88 = _t75;
        return  *(Sprintf(_t47));
    }
    if(__edx < _t55) {
L3:
        _t42 = __ecx;
        __edx = _t55;
        goto L4;
    }
    _t59 = _t42 - __ecx;
    if(_t59 >= 0) {
        goto L4;
    }
    goto L3;
}

void showProgress(clen_t* linelen, clen_t* trbyte)
{// addr = 0x0806DB9B  --  defined in 'file.c' at line 6613
    int i;                                 // _cfa_ffffffe0
    int j;                                 // _cfa_ffffffdc
    int rate;                              // _cfa_ffffffd8
    int duration;                          // _cfa_ffffffd4
    int eta;                               // _cfa_ffffffd0
    int pos;                               // _cfa_ffffffcc
    time_t cur_time;    // _cfa_ffffffc8
    Str messages;          // _cfa_ffffffc4
    char* fmtrbyte;                        // _cfa_ffffffc0
    char* fmrate;                          // _cfa_ffffffbc
    double ratio;                          // _cfa_ffffffb4
    long long int _v80;                    // _cfa_ffffffb0
    long long int _v84;                    // _cfa_ffffffac
    int _v96;                              // _cfa_ffffffa0
    signed int _v100;                      // _cfa_ffffff9c
    intOrPtr _v104;                        // _cfa_ffffff98
    char* _v108;                           // _cfa_ffffff94
    intOrPtr _v112;                        // _cfa_ffffff90 (outparam)
    double _v116;                          // _cfa_ffffff8c (outparam)
    char* _v120;                           // _cfa_ffffff88 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    clen_t* _t162;      // _t162
    long long int _t163;                   // _t163
    long int _t164;                        // _t164
    clen_t* _t169;      // _t169
    clen_t* _t172;      // _t172
    clen_t* _t177;      // _t177
    signed int _t188;                      // _t188
    clen_t* _t200;      // _t200
    clen_t* _t203;      // _t203
    clen_t* _t208;      // _t208
    clen_t* _t211;      // _t211
    signed int _t237;                      // _t237
    int _t239;                             // _t239
    clen_t* _t291;      // _t291
    clen_t* _t296;      // _t296
    long long int _t313;                   // _t313
    intOrPtr _t314;                        // _t314
    char* _t319;                           // _t319

    if((fmInitialized & 255) == 0) {
        return;
    }
    _t162 = linelen;
    _t313 = _t162[0];
    _t163 =  *_t162;
    if(_t313 > 0) {
L4:
        _t164 = current_content_length;
        _t314 =  *135776436;
        if(_t314 < 0 || _t314 <= 0 && _t164 <= 0) {
             *__esp = 0;
            time();
            cur_time = _t164;
            if(( *trbyte | trbyte[0]) == 0) {
                move(LINES - 1, 0);
                clrtoeolx();
                start_time = cur_time;
            }
            _t169 = linelen;
            asm("adc edx, ebx");
            _t291 = trbyte;
             *_t291 =  *_t169 +  *trbyte;
            _t291[0] = _t169[0];
            _t172 = linelen;
             *_t172 = 0;
            _t172[0] = 0;
            if(cur_time == last_time) {
                return;
            } else {
                last_time = cur_time;
                move(LINES - 1, 0);
                _t177 = trbyte;
                _v116 = 1;
                 *__esp =  *_t177;
                _v120 = _t177[0];
                fmtrbyte = convert_size();
                duration = cur_time - start_time;
                if(duration == 0) {
                    _v120 = fmtrbyte;
                    messages = Sprintf("%7s loaded");
                } else {
                    _t319 = trbyte[0];
                    _t188 = __divdi3( *trbyte, _t319, duration, duration >> 31);
                    _v116 = 1;
                     *__esp = _t188;
                    _v120 = _t319;
                    fmrate = convert_size();
                    _v116 = fmrate;
                    _v120 = fmtrbyte;
                    messages = Sprintf("%7s loaded %7s/s");
                }
                message(messages->ptr, 0, 0);
                refresh();
                return;
            }
        } else {
             *__esp = 0;
            time();
            cur_time = _t164;
            if(( *trbyte | trbyte[0]) == 0) {
                move(LINES - 1, 0);
                clrtoeolx();
                start_time = cur_time;
            }
            _t200 = linelen;
            asm("adc edx, ebx");
            _t296 = trbyte;
             *_t296 =  *_t200 +  *trbyte;
            _t296[0] = _t200[0];
            _t203 = linelen;
             *_t203 = 0;
            _t203[0] = 0;
            if(cur_time == last_time) {
                return;
            } else {
                last_time = cur_time;
                move(LINES - 1, 0);
                _t208 = trbyte;
                _v84 =  *_t208;
                _v80 = _t208[0];
                asm("fild qword [ebp-0x50]");
                asm("fmulp st1, st0");
                _v84 = current_content_length;
                _v80 =  *135776436;
                asm("fild qword [ebp-0x50]");
                asm("fdivp st1, st0");
                ratio =  *135048056;
                _t211 = trbyte;
                _v108 = 1;
                _v116 = current_content_length;
                _v112 =  *135776436;
                 *__esp =  *_t211;
                _v120 = _t211[0];
                fmtrbyte = convert_size2();
                duration = cur_time - start_time;
                if(duration == 0) {
                    _v116 = ratio;
                    _v120 = fmtrbyte;
                    messages = Sprintf("%11s %3.0f%%                          ");
                } else {
                    rate = __divdi3( *trbyte, trbyte[0], duration, duration >> 31);
                    _t237 = rate;
                    _v116 = 1;
                     *__esp = _t237;
                    _v120 = _t237 >> 31;
                    fmrate = convert_size();
                    if(rate == 0) {
                        _t239 = -1;
                    } else {
                        asm("sbb edx, ebx");
                        _t239 = __divdi3(current_content_length -  *trbyte,  *135776436, rate, rate >> 31);
                    }
                    eta = _t239;
                    _t303 = eta;
                    _t304 = eta;
                    _t306 = ((eta * -2004318071 >> 32) + eta >> 5) - (_t304 >> 31);
                    _v96 = eta - (((eta * -2004318071 >> 32) + eta >> 5) - (_t303 >> 31) << 2 << 4) - (((eta * -2004318071 >> 32) + eta >> 5) - (_t303 >> 31) << 2);
                    _v100 = ((eta * -2004318071 >> 32) + eta >> 5) - (_t304 >> 31) - ((((((eta * -2004318071 >> 32) + eta >> 5) - (_t304 >> 31)) * -2004318071 >> 32) + ((eta * -2004318071 >> 32) + eta >> 5) - (_t304 >> 31) >> 5) - (_t306 >> 31) << 2 << 4) - ((((((eta * -2004318071 >> 32) + eta >> 5) - (_t304 >> 31)) * -2004318071 >> 32) + ((eta * -2004318071 >> 32) + eta >> 5) - (_t304 >> 31) >> 5) - (_t306 >> 31) << 2);
                    _v104 = ((eta * -1851608123 >> 32) + eta >> 11) - (eta >> 31);
                    _v108 = fmrate;
                    _v116 = ratio;
                    _v120 = fmtrbyte;
                    messages = Sprintf("%11s %3.0f%% %7s/s eta %02d:%02d:%02d     ");
                }
                addstr(messages->ptr);
                pos = 42;
                i = __divdi3( *trbyte * (COLS - pos - 1), (COLS - pos - 1 >> 31) *  *trbyte + trbyte[0] * (COLS - pos - 1) + ( *trbyte * (COLS - pos - 1) >> 32), current_content_length,  *135776436) + pos;
                move(LINES - 1, pos);
                standout();
                addch(32);
                j = pos + 1;
                while(j <= i) {
                    addch(124);
                    j = j + 1;
                }
                standend();
                refresh();
                return;
            }
        }
    }
    if(_t313 < 0) {
        return;
    }
    if(_t163 <= 1023) {
        return;
    }
    goto L4;
}

void init_henv(struct html_feed_environ* h_env, struct readbuffer* obuf, struct environment* envs, int nenv, TextLineList* buf, int limit, int indent)
{// addr = 0x0806E0B9  --  defined in 'file.c' at line 6698
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    intOrPtr _v24;                         // _cfa_ffffffe8 (outparam)

    envs->indent = indent;
    obuf->line = Strnew();
    obuf->cprop = 0;
    obuf->pos = 0;
    obuf->prevchar = Strnew_size(8);
    Strcopy_charp_n(obuf->prevchar, " ", 1);
    obuf->flag = 8192;
    obuf->flag_sp = 0;
    obuf->status = 0;
    obuf->table_level = 65535;
    obuf->nobr_level = 0;
    _v24 = 60;
     *__esp =  &(obuf->anchor);
    bzero();
    obuf->img_alt = 0;
    obuf->fontstat = 0;
    obuf->fontstat[2] = 0;
    obuf->fontstat[1] = 0;
    obuf->fontstat[3] = 0;
    obuf->fontstat[4] = 0;
    obuf->prev_ctype = 0;
    obuf->tag_sp = 0;
    obuf->fontstat_sp = 0;
    obuf->top_margin = 0;
    obuf->bottom_margin = 0;
    obuf->bp.init_flag = 1;
    set_breakpoint(obuf, 0);
    h_env->buf = buf;
    h_env->f = 0;
    h_env->obuf = obuf;
    h_env->tagbuf = Strnew();
    h_env->limit = limit;
    h_env->maxlimit = 0;
    h_env->envs = envs;
    h_env->nenv = nenv;
    h_env->envc = 0;
    h_env->envc_real = 0;
    h_env->title = 0;
    h_env->blank_lines = 0;
}

void completeHTMLstream(struct html_feed_environ* h_env, struct readbuffer* obuf)
{// addr = 0x0806E26B  --  defined in 'file.c' at line 6744
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    close_anchor(h_env, obuf);
    if(obuf->img_alt != 0) {
        push_tag(obuf, "</img_alt>", 137);
        obuf->img_alt = 0;
    }
    if((obuf->fontstat & 255) != 0) {
        push_tag(obuf, "</b>", 8);
        obuf->fontstat = 0;
    }
    if((obuf->fontstat[2] & 255) != 0) {
        push_tag(obuf, "</i>", 110);
        obuf->fontstat[2] = 0;
    }
    if((obuf->fontstat[1] & 255) != 0) {
        push_tag(obuf, "</u>", 66);
        obuf->fontstat[1] = 0;
    }
    if((obuf->fontstat[3] & 255) != 0) {
        push_tag(obuf, "</s>", 106);
        obuf->fontstat[3] = 0;
    }
    if((obuf->fontstat[4] & 255) != 0) {
        push_tag(obuf, "</ins>", 64);
        obuf->fontstat[4] = 0;
    }
    if((obuf->flag & 2048) != 0) {
        HTMLlineproc0("</textarea>", h_env, 1);
    }
    if((obuf->flag & 4096) != 0) {
        HTMLlineproc0("</select>", h_env, 1);
    }
    if((obuf->flag & 16384) != 0) {
        HTMLlineproc0("</title>", h_env, 1);
    }
    if((obuf->table_level & 65535) > 19) {
        obuf->table_level = 19;
    }
    while((obuf->table_level & 65535) >= 0) {
         *( &table_mode + ((obuf->table_level & 65535) << 4)) =  *( &table_mode + ((obuf->table_level & 65535) << 4)) & -15;
        HTMLlineproc0("</table>", h_env, 1);
    }
}

void print_internal_information(struct html_feed_environ* henv)
{// addr = 0x0806E4A4  --  defined in 'file.c' at line 6791
    int i;                                 // _cfa_fffffff0
    Str s;                 // _cfa_ffffffec
    TextLineList* tl;   // _cfa_ffffffe8
    FormSelectOptionItem* ip;   // _cfa_ffffffe4
    TextLineListItem* p;   // _cfa_ffffffe0
    int _v48;                              // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc (outparam)
    int _v56;                              // _cfa_ffffffc8 (outparam)
    char* __ebx;                           // r1
    char* __esi;                           // r5
    TextLine* _t123;   // _t123
    char* _t166;                           // _t166
    int _t167;                             // _t167
    int _t180;                             // _t180

    tl = newGeneralList();
    s = Strnew_charp("<internal>");
    pushValue(tl, newTextLine(s, 0));
    if(henv->title != 0) {
        _t180 = html_quote(henv->title);
        _v48 = 0;
        _v52 = "">";
        _v56 = _t180;
        s = Strnew_m_charp("<title_alt title="");
        pushValue(tl, newTextLine(s, 0));
    }
    if(n_select > 0) {
        i = 0;
        while(i < n_select) {
            _v56 = i;
            s = Sprintf("<select_int selectnumber=%d>");
            pushValue(tl, newTextLine(s, 0));
            ip =  *(select_option + (i << 3));
            while(ip != 0) {
                if(ip->checked == 0) {
                    __ebx = 135041709;
                } else {
                    __ebx = " selected";
                }
                __esi = html_quote( *(ip->label));
                if(ip->value == 0) {
                    _t166 =  *(ip->label);
                } else {
                    _t166 = ip->value->value;
                }
                _t167 = html_quote(_t166);
                _v48 = __ebx;
                _v52 = __esi;
                _v56 = _t167;
                s = Sprintf("<option_int value="%s" label="%s"%s>");
                pushValue(tl, newTextLine(s, 0));
                ip = ip->next;
            }
            s = Strnew_charp("</select_int>");
            pushValue(tl, newTextLine(s, 0));
            i = i + 1;
        }
    }
    if(n_textarea > 0) {
        i = 0;
        while(i < n_textarea) {
            _v56 = i;
            s = Sprintf("<textarea_int textareanumber=%d>");
            pushValue(tl, newTextLine(s, 0));
            s = Strnew_charp(html_quote( *( *(textarea_str + (i << 2)))));
            Strcat_charp(s, "</textarea_int>");
            pushValue(tl, newTextLine(s, 0));
            i = i + 1;
        }
    }
    s = Strnew_charp("</internal>");
    pushValue(tl, newTextLine(s, 0));
    if(henv->buf != 0) {
        appendGeneralList(henv->buf, tl);
        return;
    }
    if(henv->f != 0) {
        p = tl->first;
        while(p != 0) {
            if((ExtHalfdump & 255) == 0) {
                _t123 = p->ptr->ptr;
            } else {
                _t123 = wc_Str_conv(p->ptr->ptr, InnerCharset, DisplayCharset);
            }
            _v52 = _t123->line;
            _v56 = "%s\n";
             *__esp = henv->f;
            fprintf();
            p = p->next;
        }
    }
}

void loadHTMLstream(URLFile* f, Buffer* newBuf, FILE* src, int internal)
{// addr = 0x0806E813  --  defined in 'file.c' at line 6869
    Str lineBuf2;          // _cfa_fffffff0
    wc_ces charset;     // _cfa_ffffffec
    _None doc_charset;                     // _cfa_ffffffe8
    _None image_flag;                      // _cfa_ffffffe4
    _None prevtrap;                        // _cfa_ffffffe0
    int _v40;                              // _cfa_ffffffd8
    clen_t linelen;     // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    clen_t trbyte;      // _cfa_ffffffcc
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v84;                        // _cfa_ffffffac
    _unknown_ _v92;                        // _cfa_ffffffa4
    _unknown_ _v96;                        // _cfa_ffffffa0
    struct html_feed_environ htmlenv1;   // _cfa_ffffff9c
    struct environment[19] envs;   // _cfa_fffffe5c
    _unknown_ _v696;                       // _cfa_fffffd48
    struct readbuffer obuf;   // _cfa_fffffd0c
    _unknown_ _v772;                       // _cfa_fffffcfc (outparam)
    _unknown_ _v776;                       // _cfa_fffffcf8 (outparam)
    int _v780;                             // _cfa_fffffcf4 (outparam)
    FILE* _v784;          // _cfa_fffffcf0 (outparam)
    int _v788;                             // _cfa_fffffcec (outparam)
    char* _v792;                           // _cfa_fffffce8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t186;                             // _t186
    Str* _t188;            // _t188
    FormSelectOption* _t190;   // _t190
    FILE* _t205;          // _t205
    char* _t310;                           // _t310

    linelen = 0;
    _v40 = 0;
    trbyte = 0;
    _v48 = 0;
    lineBuf2 = Strnew();
    charset = 256;
    doc_charset = DocumentCharset;
    prevtrap = 0;
    if((fmInitialized & 255) == 0) {
L3:
        symbol_width0 = 0;
        get_symbol(DisplayCharset,  &symbol_width0);
        if(( *135119023 & 255) == 0) {
            _t186 = 1;
        } else {
            _t186 = symbol_width0;
        }
        symbol_width = _t186;
L7:
        cur_title = 0;
        n_textarea = 0;
        cur_textarea = 0;
        max_textarea = 10;
        _t188 = max_textarea << 2;
         *__esp = _t188;
        GC_malloc();
        textarea_str = _t188;
        n_select = 0;
        max_select = 10;
        _t190 = max_select << 3;
         *__esp = _t190;
        GC_malloc();
        select_option = _t190;
        cur_select = 0;
        form_sp = -1;
        form_max = -1;
        forms_size = 0;
        forms = 0;
        cur_hseq = 1;
        cur_iseq = 1;
        if((newBuf->image_flag & 255) == 0) {
            if(activeImage == 0) {
L13:
                image_flag = 1;
                goto L14;
            }
            if(displayImage == 0 || autoImage == 0) {
                goto L13;
            } else {
                image_flag = 2;
                goto L14;
            }
        } else {
            image_flag = newBuf->image_flag & 255;
L14:
            if(newBuf->currentURL.file != 0) {
                cur_baseURL = baseURL(newBuf);
            }
            if(w3m_halfload != 0) {
                newBuf->buffername = "---";
                newBuf->document_charset = InnerCharset;
                max_textarea = 0;
                max_select = 0;
                HTMLlineproc3(newBuf, f->stream);
                w3m_halfload = 0;
                return;
            }
            init_henv( &(htmlenv1.obuf),  &(obuf.line),  &envs, 20, 0, newBuf->width & 65535, 0);
            if((w3m_dump & 16) == 0) {
                _t205 = newGeneralList();
                htmlenv1.buf = _t205;
            } else {
                _t205 = __imp__stdout;
                htmlenv1.f = _t205;
            }
            _v792 = 1;
             *__esp =  &AbortLoading;
            __sigsetjmp();
            if(_t205 == 0) {
                if((TrapSignal & 255) != 0) {
                    prevtrap = mySignal(2, KeyAbort);
                    if((fmInitialized & 255) != 0) {
                        term_cbreak();
                    }
                }
                if(newBuf != 0) {
                    if((newBuf->bufferprop & 2) == 0) {
                        if(newBuf->document_charset != 0) {
                            doc_charset = newBuf->document_charset;
                            charset = doc_charset;
                        }
                    } else {
                        charset = InnerCharset;
                    }
                }
                if(content_charset == 0 || (UseContentCharset & 255) == 0) {
                    if(f->guess_type != 0) {
                        _t310 = f->guess_type;
                        _v792 = "application/xhtml+xml";
                         *__esp = _t310;
                        strcasecmp();
                        if(_t310 == 0) {
                            doc_charset = 3178565;
                        }
                    }
                } else {
                    doc_charset = content_charset;
                }
                meta_charset = 0;
                if(( *(f->stream + 20) & 255) != 4) {
                    f->stream = newEncodedStream(f->stream, f->encoding & 255);
                }
                while(1) {
                    lineBuf2 = StrmyISgets(f->stream);
                    if(lineBuf2->length == 0) {
                        break;
                    }
                    if((f->scheme & 255) != 9 || ( *(lineBuf2->ptr) & 255) != 46) {
L44:
                        if(src != 0) {
                            _v784 = src;
                            _v788 = lineBuf2->length;
                            _v792 = 1;
                             *__esp = lineBuf2->ptr;
                            fwrite();
                        }
                        asm("adc edx, ebx");
                        linelen = linelen + lineBuf2->length;
                        _v40 = _v40;
                        if((w3m_dump & 8) != 0) {
                            _v780 = 1;
                            _v788 = current_content_length;
                            _v784 =  *135776436;
                             *__esp = linelen;
                            _v792 = _v40;
                            _v792 = convert_size2();
                             *__esp = "W3m-in-progress: %s\n";
                            printf();
                        }
                        if((w3m_dump & 4) == 0) {
                            showProgress( &linelen,  &trbyte);
                            if(meta_charset != 0) {
                                if(content_charset == 0 && (UseContentCharset & 255) != 0) {
                                    doc_charset = meta_charset;
                                    charset = 256;
                                }
                                meta_charset = 0;
                            }
                            lineBuf2 = convertLine(f, lineBuf2, 2,  &charset, doc_charset);
                            cur_document_charset = charset;
                            HTMLlineproc0(lineBuf2->ptr,  &(htmlenv1.obuf), internal);
                        }
                        continue;
                    } else {
                        Strdelete(lineBuf2, 0, 1);
                        if((lineBuf2 & 255) == 10 || (lineBuf2 & 255) == 13 || (lineBuf2 & 255) == 0) {
                            break;
                        } else {
                            goto L44;
                        }
                    }
                }
                if(obuf.status != 0) {
                    obuf.status = 7;
                    HTMLlineproc0(135047508,  &(htmlenv1.obuf), internal);
                }
                obuf.status = 0;
                completeHTMLstream( &(htmlenv1.obuf),  &(obuf.line));
                flushline( &(htmlenv1.obuf),  &(obuf.line), 0, 2, htmlenv1.limit);
                if(htmlenv1.title != 0) {
                    newBuf->buffername = htmlenv1.title;
                }
                if((w3m_dump & 16) == 0) {
                    if(w3m_backend == 0) {
                        goto L76;
                    }
                    if((TrapSignal & 255) != 0) {
                        if((fmInitialized & 255) != 0) {
                            term_raw();
                        }
                        if(prevtrap != 0) {
                            mySignal(2, prevtrap);
                        }
                    }
                    print_internal_information( &(htmlenv1.obuf));
                    backend_halfdump_buf = htmlenv1.buf;
                    return;
                } else {
                    if((TrapSignal & 255) != 0) {
                        if((fmInitialized & 255) != 0) {
                            term_raw();
                        }
                        if(prevtrap != 0) {
                            mySignal(2, prevtrap);
                        }
                    }
                    print_internal_information( &(htmlenv1.obuf));
                    return;
                }
            } else {
                HTMLlineproc0("<br>Transfer Interrupted!<br>",  &(htmlenv1.obuf), 1);
L76:
                newBuf->trbyte = trbyte + linelen;
                if((TrapSignal & 255) != 0) {
                    if((fmInitialized & 255) != 0) {
                        term_raw();
                    }
                    if(prevtrap != 0) {
                        mySignal(2, prevtrap);
                    }
                }
                if((newBuf->bufferprop & 2) == 0) {
                    newBuf->document_charset = charset;
                }
                newBuf->image_flag = image_flag;
                HTMLlineproc2(newBuf, htmlenv1.buf);
                return;
            }
        }
    }
    if(graph_ok() == 0) {
        goto L3;
    } else {
        symbol_width0 = 1;
        symbol_width = symbol_width0;
        goto L7;
    }
}

Buffer* loadHTMLString(Str page)
{// addr = 0x0806EF44  --  defined in 'file.c' at line 7050
    _None prevtrap;                        // _cfa_fffffff0
    Buffer* newBuf;     // _cfa_ffffffec
    URLFile f;         // _cfa_ffffffcc
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    int _v72;                              // _cfa_ffffffb8 (outparam)
    int _t51;                              // _t51
    _unknown_ _t52;                        // _t52
    Buffer* _t54;       // _t54
    int _t93;                              // _t93

    prevtrap = 0;
    _t93 = COLS;
    if(showLineNum == 0) {
        _t51 = 1;
    } else {
        _t51 = 6;
    }
    _t52 = _t93 - _t51;
    _t53 = _t52 < 0 ? 0 : _t52;
    _t54 = newBuffer(_t52 < 0 ? 0 : _t52);
    newBuf = _t54;
    _v72 = 1;
     *__esp =  &AbortLoading;
    __sigsetjmp();
    if(_t54 == 0) {
        if((TrapSignal & 255) != 0) {
            prevtrap = mySignal(2, KeyAbort);
            if((fmInitialized & 255) != 0) {
                term_cbreak();
            }
        }
        init_stream( &f, 4, newStrStream(page));
        newBuf->document_charset = InnerCharset;
        loadHTMLstream( &f, newBuf, 0, 1);
        newBuf->document_charset = 256;
        if((TrapSignal & 255) != 0) {
            if((fmInitialized & 255) != 0) {
                term_raw();
            }
            if(prevtrap != 0) {
                mySignal(2, prevtrap);
            }
        }
        newBuf->topLine = newBuf->firstLine;
        newBuf->lastLine = newBuf->currentLine;
        newBuf->currentLine = newBuf->firstLine;
        newBuf->type = "text/html";
        newBuf->real_type = newBuf->type;
        if(n_textarea != 0) {
            formResetBuffer(newBuf, newBuf->formitem);
        }
        return newBuf;
    } else {
        if((TrapSignal & 255) != 0) {
            if(prevtrap != 0) {
                mySignal(2, prevtrap);
            }
        }
        discardBuffer(newBuf);
        return 0;
    }
}

Str loadGopherDir(URLFile* uf, ParsedURL* pu, wc_ces* charset)
{// addr = 0x0806F10D  --  defined in 'file.c' at line 7091
    _None tmp;                             // _cfa_ffffffe0
    Str lbuf;              // _cfa_ffffffdc
    Str name;              // _cfa_ffffffd8
    Str file;              // _cfa_ffffffd4
    Str host;              // _cfa_ffffffd0
    Str port;              // _cfa_ffffffcc
    _None p;                               // _cfa_ffffffc8
    _None q;                               // _cfa_ffffffc4
    _None prevtrap;                        // _cfa_ffffffc0
    wc_ces doc_charset;   // _cfa_ffffffbc
    unsigned int _v80;                     // _cfa_ffffffb0
    URLFile* _v96;     // _cfa_ffffffa0
    char* _v100;                           // _cfa_ffffff9c
    _None _v104;                           // _cfa_ffffff98
    char* _v108;                           // _cfa_ffffff94 (outparam)
    _unknown_ _v112;                       // _cfa_ffffff90 (outparam)
    char* _v116;                           // _cfa_ffffff8c (outparam)
    _unknown_ _v120;                       // _cfa_ffffff88 (outparam)
    _None _t160;                           // _t160
    signed int _t227;                      // _t227
    char* _t237;                           // _t237
    char* _t245;                           // _t245

    prevtrap = 0;
    doc_charset = DocumentCharset;
    tmp = parsedURL2Str(pu);
    p = html_quote( *tmp);
    tmp = convertLine(0, Strnew_charp(file_unquote( *tmp)), 0, charset, doc_charset);
    q = html_quote( *tmp);
    _v96 = 0;
    _v100 = "</h1>\n<table>\n";
    _v104 = q;
    _v108 = "</title>\n</head>\n<body>\n<h1>Index of ";
    _v112 = q;
    _v116 = "">\n<title>";
    _v120 = p;
    _t160 = Strnew_m_charp("<html>\n<head>\n<base href="");
    tmp = _t160;
    _v120 = 1;
     *__esp =  &AbortLoading;
    __sigsetjmp();
    if(_t160 != 0) {
    } else {
        if((TrapSignal & 255) != 0) {
            prevtrap = mySignal(2, KeyAbort);
            if((fmInitialized & 255) != 0) {
                term_cbreak();
            }
        }
        while(1) {
            lbuf = StrISgets(uf->stream);
            if(lbuf->length == 0) {
                break;
            }
            if((lbuf & 255) != 46 || (lbuf->ptr[1] & 255) != 10 && (lbuf->ptr[1] & 255) != 13) {
                lbuf = convertLine(uf, lbuf, 2, charset, doc_charset);
                p = lbuf->ptr;
                q = p;
                while(( *q & 255) != 0) {
                    if(( *q & 255) != 9) {
                        q =  &(1[q]);
                        continue;
                    }
                    break;
                }
                name = Strnew_charp_n(p, q - p);
                if(( *q & 255) != 0) {
                    p =  &(1[q]);
                    q = p;
                    while(( *q & 255) != 0 && ( *q & 255) != 9) {
                        q =  &(1[q]);
                    }
                    file = Strnew_charp_n(p, q - p);
                    if(( *q & 255) != 0) {
                        p =  &(1[q]);
                        q = p;
                        while(( *q & 255) != 0 && ( *q & 255) != 9) {
                            q =  &(1[q]);
                        }
                        host = Strnew_charp_n(p, q - p);
                        if(( *q & 255) != 0) {
                            p =  &(1[q]);
                            q = p;
                            while(( *q & 255) != 0 && ( *q & 255) != 9 && ( *q & 255) != 13 && ( *q & 255) != 10) {
                                q =  &(1[q]);
                            }
                            port = Strnew_charp_n(p, q - p);
                            _t227 = name & 255;
                            if(_t227 == 103) {
                                p = "[gif]";
L48:
                                _v100 = 0;
                                _v104 = file->ptr;
                                _v108 = 135047673;
                                _v112 = port->ptr;
                                _v116 = 135047675;
                                _v120 = host->ptr;
                                q =  *(Strnew_m_charp("gopher://"));
                                _t237 = html_quote( &(name->ptr[1]));
                                _v80 =  *charset;
                                _t245 = html_quote(url_quote( *(wc_Str_conv_strict(Strnew_charp(q), InnerCharset, _v80))));
                                _v96 = 0;
                                _v100 = "</a>\n";
                                _v104 = _t237;
                                _v108 = p;
                                _v112 = "">";
                                _v116 = _t245;
                                _v120 = "<a href="";
                                Strcat_m_charp(tmp);
                                continue;
                            }
                            if(_t227 > 103) {
                                if(_t227 == 109) {
                                    p = "[message]";
                                    goto L48;
                                }
                                if(_t227 == 115) {
                                    p = "[sound]";
                                    goto L48;
                                }
                                if(_t227 == 104) {
                                    p = "[HTML]";
                                    goto L48;
                                }
L47:
                                p = "[unsupported]";
                                goto L48;
                            }
                            if(_t227 == 48) {
                                p = "[text file]";
                                goto L48;
                            }
                            if(_t227 == 49) {
                                p = "[directory]";
                                goto L48;
                            }
                            goto L47;
                        }
                        goto L49;
                    }
                    goto L49;
                } else {
L49:
                    continue;
                }
            } else {
L52:
                if((TrapSignal & 255) != 0) {
                    if((fmInitialized & 255) != 0) {
                        term_raw();
                    }
                    if(prevtrap != 0) {
                        mySignal(2, prevtrap);
                    }
                }
                Strcat_charp(tmp, "</table>\n</body>\n</html>\n");
                return tmp;
            }
        }
    }
}

Buffer* loadBuffer(URLFile* uf, _None newBuf)
{// addr = 0x0806F5A5  --  defined in 'file.c' at line 7183
    _None pre_lbuf;                        // _cfa_ffffffe3
    _None src;                             // _cfa_ffffffdc
    wc_ces charset;     // _cfa_ffffffd8
    _None doc_charset;                     // _cfa_ffffffd4
    Str lineBuf2;          // _cfa_ffffffd0
    int nlines;                            // _cfa_ffffffcc
    Str tmpf;              // _cfa_ffffffc8
    Lineprop* propBuffer;   // _cfa_ffffffc4
    Linecolor* colorBuffer;   // _cfa_ffffffc0
    _None prevtrap;                        // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    clen_t linelen;     // _cfa_ffffffb4
    int _v80;                              // _cfa_ffffffb0
    clen_t trbyte;      // _cfa_ffffffac
    _unknown_ _v100;                       // _cfa_ffffff9c (outparam)
    _unknown_ _v104;                       // _cfa_ffffff98 (outparam)
    int _v108;                             // _cfa_ffffff94 (outparam)
    intOrPtr _v112;                        // _cfa_ffffff90 (outparam)
    int _v116;                             // _cfa_ffffff8c (outparam)
    char* _v120;                           // _cfa_ffffff88 (outparam)
    _unknown_ __ebx;                       // r1
    struct _Str* _t156;   // _t156
    int _t196;                             // _t196
    int _t199;                             // _t199
    _unknown_ _t200;                       // _t200
    char* _t257;                           // _t257
    int _t265;                             // _t265
    _unknown_ _t266;                       // _t266
    int _t297;                             // _t297
    int _t306;                             // _t306

    src = 0;
    charset = 256;
    doc_charset = DocumentCharset;
    pre_lbuf = 0;
    linelen = 0;
    _v72 = 0;
    trbyte = 0;
    _v80 = 0;
    propBuffer = 0;
    colorBuffer = 0;
    prevtrap = 0;
    if(newBuf == 0) {
        _t306 = COLS;
        if(showLineNum == 0) {
            _t265 = 1;
        } else {
            _t265 = 6;
        }
        _t266 = _t306 - _t265;
        _t267 = _t266 < 0 ? 0 : _t266;
        newBuf = newBuffer(_t266 < 0 ? 0 : _t266);
    }
    _t156 = Strnew();
    lineBuf2 = _t156;
    _v120 = 1;
     *__esp =  &AbortLoading;
    __sigsetjmp();
    if(_t156 != 0) {
    } else {
        if((TrapSignal & 255) != 0) {
            prevtrap = mySignal(2, KeyAbort);
            if((fmInitialized & 255) != 0) {
                term_cbreak();
            }
        }
        if( *(newBuf + 184) == 0 && ((uf->scheme & 255) != 4 ||  *((intOrPtr*)(newBuf + 232)) != 0)) {
            tmpf = tmpfname(1, 0);
            _t257 = tmpf->ptr;
            _v120 = 135041136;
             *__esp = _t257;
            fopen();
            src = _t257;
            if(src != 0) {
                 *(newBuf + 184) = tmpf->ptr;
            }
        }
        if( *(newBuf + 208) != 0) {
            doc_charset =  *(newBuf + 208);
            charset = doc_charset;
        }
        if(content_charset != 0 && (UseContentCharset & 255) != 0) {
            doc_charset = content_charset;
        }
        nlines = 0;
        if(( *(uf->stream + 20) & 255) != 4) {
            uf->stream = newEncodedStream(uf->stream, uf->encoding & 255);
        }
        while(1) {
            lineBuf2 = StrmyISgets(uf->stream);
            if(lineBuf2->length == 0) {
                break;
            }
            if((uf->scheme & 255) != 9 || ( *(lineBuf2->ptr) & 255) != 46) {
L26:
                if(src != 0) {
                    _v112 = src;
                    _v116 = lineBuf2->length;
                    _v120 = 1;
                     *__esp = lineBuf2->ptr;
                    fwrite();
                }
                asm("adc edx, ebx");
                linelen = linelen + lineBuf2->length;
                _v72 = _v72;
                if((w3m_dump & 8) != 0) {
                    _v108 = 1;
                    _v116 = current_content_length;
                    _v112 =  *135776436;
                     *__esp = linelen;
                    _v120 = _v72;
                    _v120 = convert_size2();
                     *__esp = "W3m-in-progress: %s\n";
                    printf();
                }
                if((w3m_dump & 4) != 0) {
                    continue;
                } else {
                    showProgress( &linelen,  &trbyte);
                    if(frame_source != 0) {
                        continue;
                    }
                    lineBuf2 = convertLine(uf, lineBuf2, 1,  &charset, doc_charset);
                    if(squeezeBlankLine == 0) {
L37:
                        nlines = nlines + 1;
                        Strchop(lineBuf2);
                        lineBuf2 = checkType(lineBuf2,  &propBuffer, 0);
                        if(FoldLine == 0) {
                            _t196 = -1;
                        } else {
                            _t297 = COLS;
                            if(showLineNum == 0) {
                                _t199 = 1;
                            } else {
                                _t199 = 6;
                            }
                            _t200 = _t297 - _t199;
                            _t201 = _t200 < 0 ? 0 : _t200;
                            _t196 = (_t200 < 0 ? 0 : _t200) + 1;
                        }
                        addnewline(newBuf, lineBuf2->ptr, propBuffer, colorBuffer, lineBuf2->length, _t196, nlines);
                        continue;
                    }
                    if((lineBuf2 & 255) != 10 || (pre_lbuf & 255) != 10) {
                        pre_lbuf = lineBuf2 & 255;
                        goto L37;
                    } else {
                        nlines = nlines + 1;
                        continue;
                    }
                }
            } else {
                Strdelete(lineBuf2, 0, 1);
                if((lineBuf2 & 255) == 10 || (lineBuf2 & 255) == 13 || (lineBuf2 & 255) == 0) {
L50:
                    if((TrapSignal & 255) != 0) {
                        if((fmInitialized & 255) != 0) {
                            term_raw();
                        }
                        if(prevtrap != 0) {
                            mySignal(2, prevtrap);
                        }
                    }
                     *((intOrPtr*)(newBuf + 12)) =  *((intOrPtr*)(newBuf + 8));
                     *((intOrPtr*)(newBuf + 20)) =  *((intOrPtr*)(newBuf + 16));
                     *((intOrPtr*)(newBuf + 16)) =  *((intOrPtr*)(newBuf + 8));
                     *((intOrPtr*)(newBuf + 200)) = trbyte + linelen;
                     *(newBuf + 208) = charset;
                    if(src != 0) {
                         *__esp = src;
                        fclose();
                    }
                    return newBuf;
                } else {
                    goto L26;
                }
            }
        }
    }
}

Buffer* loadImageBuffer(URLFile* uf, Buffer* newBuf)
{// addr = 0x0806FA5B  --  defined in 'file.c' at line 7282
    ImageCache* cache;   // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    Str tmpf;              // _cfa_ffffffe8
    FILE* src;            // _cfa_ffffffe4
    _None prevtrap;                        // _cfa_ffffffe0
    URLFile f;         // _cfa_ffffffc0
    Buffer* _v68;       // _cfa_ffffffbc
    short _v90;                            // _cfa_ffffffa6
    short _v92;                            // _cfa_ffffffa4
    char* _v96;                            // _cfa_ffffffa0
    Image image;         // _cfa_ffffff9c
    struct stat st;       // _cfa_ffffff44
    char* _v204;                           // _cfa_ffffff34
    intOrPtr _v208;                        // _cfa_ffffff30
    char* _v212;                           // _cfa_ffffff2c
    char* _v216;                           // _cfa_ffffff28
    int _v220;                             // _cfa_ffffff24
    int _v224;                             // _cfa_ffffff20 (outparam)
    char* _v228;                           // _cfa_ffffff1c (outparam)
    char* _v232;                           // _cfa_ffffff18 (outparam)
    URLFile* _t145;    // _t145
    FILE* _t164;          // _t164
    int _t187;                             // _t187
    _unknown_ _t188;                       // _t188
    int _t241;                             // _t241

    src = 0;
    prevtrap = 0;
    loadImage(newBuf, 1);
    image.url = uf->url;
    _v96 = uf->ext;
    _v92 = 65535;
    _v90 = 65535;
    _v68 = 0;
    cache = getImage( &image, cur_baseURL, 2);
    if(cur_baseURL->is_nocache != 0 || (cache->loaded & 1) == 0 || __stat(cache->file,  &(st.st_dev)) != 0) {
        if((TrapSignal & 255) != 0) {
            prevtrap = mySignal(2, KeyAbort);
            if((fmInitialized & 255) != 0) {
                term_cbreak();
            }
        }
        if((uf->stream[0x14] & 255) != 4) {
            uf->stream = newEncodedStream(uf->stream, uf->encoding & 255);
        }
        _v204 = cache->file;
        _t145 = uf;
         *__esp = _t145->scheme;
        _v232 = _t145->stream;
        _v228 = _t145->ext;
        _v224 = _t145->compression;
        _v220 = _t145->content_encoding;
        _v216 = _t145->guess_type;
        _v212 = _t145->url;
        _v208 = _t145->modtime;
        if(save2tmp() >= 0) {
            if(ISclose(uf->stream) == 0) {
                uf->stream = 0;
            }
            if((TrapSignal & 255) != 0) {
                if((fmInitialized & 255) != 0) {
                    term_raw();
                }
                if(prevtrap != 0) {
                    mySignal(2, prevtrap);
                }
            }
            cache->loaded = 1;
            cache->index = 0;
            goto L26;
        }
        if(ISclose(uf->stream) == 0) {
            uf->stream = 0;
        }
        if((TrapSignal & 255) != 0) {
            if((fmInitialized & 255) != 0) {
                term_raw();
            }
            if(prevtrap != 0) {
                mySignal(2, prevtrap);
            }
        }
        return 0;
    } else {
L26:
        if(newBuf == 0) {
            _t241 = COLS;
            if(showLineNum == 0) {
                _t187 = 1;
            } else {
                _t187 = 6;
            }
            _t188 = _t241 - _t187;
            _t189 = _t188 < 0 ? 0 : _t188;
            newBuf = newBuffer(_t188 < 0 ? 0 : _t188);
        }
        cache->loaded = cache->loaded & 255 | 4;
        if(newBuf->sourcefile == 0 && (uf->scheme & 255) != 4) {
            newBuf->sourcefile = cache->file;
        }
        _v232 = html_quote(image.url);
        tmp = Sprintf("<img src="%s"><br><br>");
        tmpf = tmpfname(1, ".html");
        _t164 = tmpf->ptr;
        _v232 = 135041136;
         *__esp = _t164;
        fopen();
        src = _t164;
        newBuf->mailcap_source = tmpf->ptr;
        init_stream( &f, 4, newStrStream(tmp));
        loadHTMLstream( &f, newBuf, src, 1);
        if(src != 0) {
             *__esp = src;
            fclose();
        }
        newBuf->topLine = newBuf->firstLine;
        newBuf->lastLine = newBuf->currentLine;
        newBuf->currentLine = newBuf->firstLine;
        newBuf->image_flag = 2;
        return newBuf;
    }
}

Str conv_symbol(Line* l)
{// addr = 0x0806FDDB  --  defined in 'file.c' at line 7343
    char c;                                // _cfa_fffffff3
    Str tmp;               // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    char* ep;                              // _cfa_ffffffe4
    Lineprop* pr;     // _cfa_ffffffe0
    int w;                                 // _cfa_ffffffdc
    char** symbol;                         // _cfa_ffffffd8
    int len;                               // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    int _t89;                              // _t89
    int _t127;                             // _t127

    tmp = 0;
    p = l->lineBuf;
    ep =  &(p[l->len]);
    pr = l->propBuf;
    symbol = 0;
    while(p < ep) {
        if(( *pr & 65535) >= 0) {
            if(tmp != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t89 = tmp->length;
                 *((char*)(tmp->ptr + _t89)) =  *p & 255;
                tmp->length = _t89 + 1;
                 *((char*)(tmp->ptr + tmp->length)) = 0;
            }
        } else {
            c = (wtf_get_code(p) & 127) - 32;
            len =  *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff;
            if(tmp == 0) {
                tmp = Strnew_size(l->len);
                Strcopy_charp_n(tmp, l->lineBuf, p - l->lineBuf);
                if(( *pr & 0x800) == 0) {
                    _t127 = 1;
                } else {
                    _t127 = 2;
                }
                w = _t127;
                symbol = get_symbol(DisplayCharset,  &w);
            }
            Strcat_charp(tmp, symbol[c]);
            p =  &(p[len - 1]);
            pr = pr + len - 1 + len - 1;
        }
        p =  &(p[1]);
        pr =  &(pr[1]);
    }
    if(tmp == 0) {
        return Strnew_charp_n(l->lineBuf, l->len);
    }
    return tmp;
}

void _saveBuffer(Buffer* buf, Line* l, FILE* f, int cont)
{// addr = 0x0806FF79  --  defined in 'file.c' at line 7390
    Str tmp;               // _cfa_fffffff0
    int is_html;                           // _cfa_ffffffec
    int set_charset;                       // _cfa_ffffffe8
    wc_ces charset;     // _cfa_ffffffe4
    FILE* _v32;           // _cfa_ffffffe0
    int _v36;                              // _cfa_ffffffdc (outparam)
    FILE* _v40;           // _cfa_ffffffd8 (outparam)
    unsigned int _t60;                     // _t60

    is_html = 0;
    set_charset = DisplayCharset == 0 & 255;
    if(DisplayCharset == 0) {
        _t60 = 256;
    } else {
        _t60 = DisplayCharset;
    }
    charset = _t60;
    is_html = is_html_type(buf->type);
L14:
    while(l != 0) {
        if(is_html == 0) {
            tmp = Strnew_charp_n(l->lineBuf, l->len);
        } else {
            tmp = conv_symbol(l);
        }
        tmp = wc_Str_conv(tmp, InnerCharset, charset);
        _v32 = f;
        _v36 = tmp->length;
        _v40 = 1;
         *__esp = tmp->ptr;
        fwrite();
        if(tmp->length <= 0 || ( *(tmp->ptr + tmp->length - 1) & 255) != 10) {
            if(cont == 0 || l->next == 0 || l->next->bpos == 0) {
                _v40 = f;
                 *__esp = 10;
                _IO_putc();
            }
        }
        l = l->next;
    }
    if(buf->pagerSource == 0 || (buf->bufferprop & 0x40) != 0) {
        return;
    } else {
        l = getNextPage(buf, PagerMax);
        if(set_charset != 0) {
            charset = buf->document_charset;
        }
        goto L14;
    }
}

void saveBuffer(Buffer* buf, FILE* f, int cont)
{// addr = 0x080700E6  --  defined in 'file.c' at line 7423
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    _saveBuffer(buf, buf->firstLine, f, cont);
}

void saveBufferBody(Buffer* buf, FILE* f, int cont)
{// addr = 0x08070111  --  defined in 'file.c' at line 7429
    Line* l;              // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    l = buf->firstLine;
    while(l != 0 && l->real_linenumber == 0) {
        l = l->next;
    }
    _saveBuffer(buf, l, f, cont);
}

Buffer* loadcmdout(char* cmd, _None* loadproc, Buffer* defaultbuf)
{// addr = 0x0807015D  --  defined in 'file.c' at line 7439
    FILE* f;              // _cfa_fffffff0
    Buffer* buf;        // _cfa_ffffffec
    Buffer* _v48;       // _cfa_ffffffd0
    URLFile uf;        // _cfa_ffffffcc
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    Buffer* _v72;       // _cfa_ffffffb8 (outparam)
    FILE* _t24;           // _t24
    Buffer* _t31;       // _t31
    union input_stream* _t32;   // _t32

    if(cmd == 0 || ( *cmd & 255) == 0) {
        return 0;
    } else {
        _v72 = 135047752;
        _t24 = cmd;
         *__esp = _t24;
        popen();
        f = _t24;
        if(f != 0) {
            init_stream( &uf, 255, newFileStream(f, pclose));
            _v72 = defaultbuf;
             *__esp =  &uf;
            _t31 = loadproc;
            _t31->filename();
            buf = _t31;
            _t32 = _v48;
            __eax = ISclose(_t32);
            if(_t32 == 0) {
                _v48 = 0;
            }
            return buf;
        }
        return 0;
    }
}

Buffer* getshell(char* cmd)
{// addr = 0x08070200  --  defined in 'file.c' at line 7461
    Buffer* buf;        // _cfa_fffffff0
    intOrPtr _v36;                         // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)

    buf = loadcmdout(cmd, loadBuffer, 0);
    if(buf != 0) {
        buf->filename = cmd;
        _v36 =  *(wc_Str_conv(Strnew_charp(cmd), SystemCharset, InnerCharset));
        _v40 = "*Shellout*";
        buf->buffername =  *(Sprintf("%s %s"));
        return buf;
    }
    return 0;
}

Buffer* getpipe(char* cmd)
{// addr = 0x0807028F  --  defined in 'file.c' at line 7478
    FILE* f;              // _cfa_fffffff0
    Buffer* buf;        // _cfa_ffffffec
    intOrPtr _v36;                         // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    FILE* _t32;           // _t32
    _unknown_ _t34;                        // _t34
    int _t35;                              // _t35
    int _t56;                              // _t56

    if(cmd == 0 || ( *cmd & 255) == 0) {
        return 0;
    } else {
        _v40 = 135047752;
        _t32 = cmd;
         *__esp = _t32;
        popen();
        f = _t32;
        if(f != 0) {
            _t56 = COLS;
            if(showLineNum == 0) {
                _t34 = 1;
            } else {
                _t34 = 6;
            }
            _t35 = _t56 - _t34;
            _t36 = _t35 < 0 ? 0 : _t35;
            buf = newBuffer(_t35 < 0 ? 0 : _t35);
            buf->pagerSource = newFileStream(f, pclose);
            buf->filename = cmd;
            _v36 =  *(wc_Str_conv(Strnew_charp(cmd), SystemCharset, InnerCharset));
            _v40 = "*stream*";
            buf->buffername =  *(Sprintf("%s %s"));
            buf->bufferprop = buf->bufferprop & 65535 | 1;
            buf->document_charset = 256;
            return buf;
        }
        return 0;
    }
}

Buffer* openPagerBuffer(InputStream stream, Buffer* buf)
{// addr = 0x080703A2  --  defined in 'file.c' at line 7504
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    char* _t32;                            // _t32
    _unknown_ _t52;                        // _t52
    int _t53;                              // _t53
    int _t65;                              // _t65

    if(buf == 0) {
        _t65 = COLS;
        if(showLineNum == 0) {
            _t52 = 1;
        } else {
            _t52 = 6;
        }
        _t53 = _t65 - _t52;
        _t54 = _t53 < 0 ? 0 : _t53;
        buf = newBuffer(_t53 < 0 ? 0 : _t53);
    }
    _t32 = buf;
    _t32[0x5c] = stream;
     *__esp = "MAN_PN";
    getenv();
    buf->buffername = _t32;
    if(buf->buffername != 0) {
        buf->buffername =  *(wc_Str_conv(Strnew_charp(buf->buffername), SystemCharset, InnerCharset));
    } else {
        buf->buffername = "*stream*";
    }
    buf->bufferprop = buf->bufferprop & 65535 | 1;
    if(content_charset == 0 || (UseContentCharset & 255) == 0) {
        buf->document_charset = 256;
    } else {
        buf->document_charset = content_charset;
    }
    buf->currentLine = buf->firstLine;
    return buf;
}

Buffer* openGeneralPagerBuffer(InputStream stream)
{// addr = 0x080704A4  --  defined in 'file.c' at line 7528
    Buffer* buf;        // _cfa_fffffff0
    char* t;                               // _cfa_ffffffec
    Buffer* t_buf;      // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    union input_stream* _v52;   // _cfa_ffffffcc
    signed int _v54;                       // _cfa_ffffffca
    URLFile uf;        // _cfa_ffffffc8
    Buffer* _v64;       // _cfa_ffffffc0
    Buffer** _v68;      // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    char* _v76;                            // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    intOrPtr _v84;                         // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0 (outparam)
    int _v100;                             // _cfa_ffffff9c (outparam)
    ParsedURL* _v104;   // _cfa_ffffff98 (outparam)
    ParsedURL* _t152;   // _t152
    int _t174;                             // _t174
    _unknown_ _t175;                       // _t175
    int _t189;                             // _t189

    t = "text/plain";
    t_buf = 0;
    init_stream( &uf, 255, stream);
    content_charset = 0;
    if((SearchHeader & 255) == 0) {
        if(DefaultType != 0) {
            t = DefaultType;
            DefaultType = 0;
        }
        goto L11;
    } else {
        _t189 = COLS;
        if(showLineNum == 0) {
            _t174 = 1;
        } else {
            _t174 = 6;
        }
        _t175 = _t189 - _t174;
        _t176 = _t175 < 0 ? 0 : _t175;
        t_buf = newBuffer(_t175 < 0 ? 0 : _t175);
        readHeader( &uf, t_buf, 1, 0);
        t = checkContentType(t_buf);
        if(t == 0) {
            t = "text/plain";
        }
        if(t_buf != 0) {
            t_buf->topLine = t_buf->firstLine;
            t_buf->currentLine = t_buf->lastLine;
        }
        SearchHeader = 0;
L11:
        if(is_html_type(t) == 0) {
            if(is_plain_text_type(t) == 0) {
                if(activeImage == 0 || displayImage == 0 || useExtImageViewer != 0 || (w3m_dump & -33) != 0) {
L23:
                    _v64 = t_buf;
                    _v68 =  &buf;
                    _v72 = t;
                    _v76 = 135047787;
                     *__esp = uf.auto_detect;
                    _v104 = _v52;
                    _v100 = _v48;
                    _v96 = _v44;
                    _v92 = _v40;
                    _v88 = _v36;
                    _v84 = _v32;
                    _v80 = _v28;
                    if(doExternal() == 0) {
                        if((stream->base.stream.cur & 255) != 4) {
                            stream = newEncodedStream(stream, _v54 & 255);
                        }
                        buf = openPagerBuffer(stream, t_buf);
                        buf->type = "text/plain";
                        goto L32;
                    }
                    if(ISclose(_v52) == 0) {
                        _v52 = 0;
                    }
                    if(buf == 0 || buf == 1) {
                        return buf;
                    } else {
                        goto L32;
                    }
                } else {
                    _v100 = 6;
                    _v104 = "image/";
                    _t152 = t;
                     *__esp = _t152;
                    strncasecmp();
                    if(_t152 != 0) {
                        goto L23;
                    }
                     *__esp = 40;
                    GC_malloc();
                    cur_baseURL = _t152;
                    parseURL(135047787, cur_baseURL, 0);
                    buf = loadImageBuffer( &uf, t_buf);
                    buf->type = "text/html";
L32:
                    buf->real_type = t;
                    buf->currentURL = 4;
                    buf->currentURL.file = 135047787;
                    return buf;
                }
            }
            if((stream->base.stream.cur & 255) != 4) {
                stream = newEncodedStream(stream, _v54 & 255);
            }
            buf = openPagerBuffer(stream, t_buf);
            buf->type = "text/plain";
            goto L32;
        }
        buf = loadHTMLBuffer( &uf, t_buf);
        buf->type = "text/html";
        goto L32;
    }
}

Line* getNextPage(Buffer* buf, int plen)
{// addr = 0x080707C1  --  defined in 'file.c' at line 7595
    _None pre_lbuf;                        // _cfa_ffffffe3
    wc_uint8 old_auto_detect;   // _cfa_ffffffe2
    _None top;                             // _cfa_ffffffdc
    _None last;                            // _cfa_ffffffd8
    _None cur;                             // _cfa_ffffffd4
    int i;                                 // _cfa_ffffffd0
    _None nlines;                          // _cfa_ffffffcc
    Str lineBuf2;          // _cfa_ffffffc8
    wc_ces charset;     // _cfa_ffffffc4
    _None doc_charset;                     // _cfa_ffffffc0
    _None squeeze_flag;                    // _cfa_ffffffbc
    Lineprop* propBuffer;   // _cfa_ffffffb8
    Linecolor* colorBuffer;   // _cfa_ffffffb4
    _None prevtrap;                        // _cfa_ffffffb0
    Line* l;              // _cfa_ffffffac
    int _v88;                              // _cfa_ffffffa8
    clen_t linelen;     // _cfa_ffffffa4
    int _v96;                              // _cfa_ffffffa0
    clen_t trbyte;      // _cfa_ffffff9c
    URLFile uf;        // _cfa_ffffff7c
    _unknown_ _v148;                       // _cfa_ffffff6c (outparam)
    _unknown_ _v152;                       // _cfa_ffffff68 (outparam)
    _unknown_ _v156;                       // _cfa_ffffff64 (outparam)
    _unknown_ _v160;                       // _cfa_ffffff60 (outparam)
    intOrPtr _v164;                        // _cfa_ffffff5c (outparam)
    char* _v168;                           // _cfa_ffffff58 (outparam)
    _unknown_ __ebx;                       // r1
    int __edi;                             // r4
    _unknown_ __esi;                       // r5
    unsigned char _t221;                   // _t221
    int _t250;                             // _t250
    int _t279;                             // _t279
    int _t280;                             // _t280
    char* _t292;                           // _t292
    int _t368;                             // _t368

    top = buf->topLine;
    last = buf->lastLine;
    cur = buf->currentLine;
    nlines = 0;
    linelen = 0;
    _v88 = 0;
    trbyte = buf->trbyte;
    _v96 = 0;
    pre_lbuf = 0;
    doc_charset = DocumentCharset;
    old_auto_detect = WcOption.auto_detect & 255;
    squeeze_flag = 0;
    propBuffer = 0;
    colorBuffer = 0;
    prevtrap = 0;
    if(buf->pagerSource == 0) {
        return 0;
    }
    if(last != 0) {
        nlines =  *((intOrPtr*)(last + 32));
        pre_lbuf =  *( *last) & 255;
        if((pre_lbuf & 255) == 0) {
            pre_lbuf = 10;
        }
        buf->currentLine = last;
    }
    charset = buf->document_charset;
    if(buf->document_charset == 256) {
        if((UseContentCharset & 255) != 0) {
            content_charset = 0;
            checkContentType(buf);
            if(content_charset != 0) {
                doc_charset = content_charset;
            }
        }
    } else {
        doc_charset = buf->document_charset;
    }
    _t221 = buf->auto_detect & 255;
    WcOption.auto_detect = _t221;
    _v168 = 1;
     *__esp =  &AbortLoading;
    __sigsetjmp();
    if(_t221 != 0) {
L50:
        if((TrapSignal & 255) != 0) {
            if((fmInitialized & 255) != 0) {
                term_raw();
            }
            if(prevtrap != 0) {
                mySignal(2, prevtrap);
            }
        }
        buf->trbyte = trbyte + linelen;
        buf->document_charset = charset;
        WcOption.auto_detect = old_auto_detect & 255;
        buf->topLine = top;
        buf->currentLine = cur;
        if(last != 0) {
            if(last != 0 && ( *((intOrPtr*)(last + 12)) != 0 || squeeze_flag == 0)) {
                last =  *((intOrPtr*)(last + 12));
            }
        } else {
            last = buf->firstLine;
        }
        return last;
    }
    if((TrapSignal & 255) != 0) {
        prevtrap = mySignal(2, KeyAbort);
        if((fmInitialized & 255) != 0) {
            term_cbreak();
        }
    }
    init_stream( &uf, 255, 0);
    i = 0;
    while(i < plen) {
        lineBuf2 = StrmyISgets(buf->pagerSource);
        if(lineBuf2->length != 0) {
            asm("adc edx, ebx");
            linelen = linelen + lineBuf2->length;
            _v88 = _v88;
            showProgress( &linelen,  &trbyte);
            lineBuf2 = convertLine( &uf, lineBuf2, 1,  &charset, doc_charset);
            if(squeezeBlankLine == 0) {
L27:
                nlines = nlines + 1;
                Strchop(lineBuf2);
                lineBuf2 = checkType(lineBuf2,  &propBuffer,  &colorBuffer);
                __edi = nlines;
                if(FoldLine == 0) {
                    _t250 = -1;
                } else {
                    _t368 = COLS;
                    if(showLineNum == 0) {
                        _t279 = 1;
                    } else {
                        _t279 = 6;
                    }
                    _t280 = _t368 - _t279;
                    _t281 = _t280 < 0 ? 0 : _t280;
                    _t250 = (_t280 < 0 ? 0 : _t280) + 1;
                }
                addnewline(buf, lineBuf2->ptr, propBuffer, colorBuffer, lineBuf2->length, _t250, __edi);
                if(top == 0) {
                    top = buf->firstLine;
                    cur = top;
                }
                if(buf->lastLine->real_linenumber - buf->firstLine->real_linenumber < PagerMax) {
L46:
                    i = i + 1;
                    continue;
                } else {
                    l = buf->firstLine;
                    do {
                        if(top == l) {
                            top = l->next;
                        }
                        if(cur == l) {
                            cur = l->next;
                        }
                        if(last == l) {
                            last = 0;
                        }
                        l = l->next;
                    } while(l != 0 && l->bpos != 0);
                    buf->firstLine = l;
                     *(buf->firstLine + 16) = 0;
                    goto L46;
                }
            }
            squeeze_flag = 0;
            if((lineBuf2 & 255) != 10 || (pre_lbuf & 255) != 10) {
                pre_lbuf = lineBuf2 & 255;
                goto L27;
            } else {
                nlines = nlines + 1;
                i = i - 1;
                squeeze_flag = 1;
                goto L46;
            }
        }
        _t292 = buf->filename;
        if(_t292 == 0) {
             *__esp = "MAN_PN";
            getenv();
            if(_t292 == 0) {
                buf->buffername = "*stream(closed)*";
            }
        } else {
            _v164 =  *(wc_Str_conv(Strnew_charp(buf->filename), SystemCharset, InnerCharset));
            _v168 = "*stream(closed)*";
            buf->buffername =  *(Sprintf("%s %s"));
        }
        buf->bufferprop = buf->bufferprop & 65535 | 64;
        goto L50;
    }
    goto L50;
}

int save2tmp(URLFile uf, char* tmpf)
{// addr = 0x08070CBA  --  defined in 'file.c' at line 7719
    char c;                                // _cfa_fffffff3
    FILE* ff;             // _cfa_ffffffec
    int check;                             // _cfa_ffffffe8
    _None prevtrap;                        // _cfa_ffffffe4
    Str buf;               // _cfa_ffffffe0
    int _v40;                              // _cfa_ffffffd8
    clen_t linelen;     // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    clen_t trbyte;      // _cfa_ffffffcc
    FILE* _v64;           // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc (outparam)
    FILE* _v72;           // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    FILE* _t72;           // _t72

    linelen = 0;
    _v40 = 0;
    trbyte = 0;
    _v48 = 0;
    prevtrap = 0;
    _t72 =  *(__ebp + 40);
    _v72 = "wb";
     *__esp = _t72;
    fopen();
    ff = _t72;
    if(ff == 0) {
        return -1;
    }
    _v68 = 156;
    _v72 =  &env_bak;
     *__esp =  &AbortLoading;
    bcopy();
    _v72 = 1;
     *__esp =  &AbortLoading;
    __sigsetjmp();
    if(_t72 != 0) {
    } else {
        if((TrapSignal & 255) != 0) {
            prevtrap = mySignal(2, KeyAbort);
            if((fmInitialized & 255) != 0) {
                term_cbreak();
            }
        }
        check = 0;
        if((uf.auto_detect & 255) != 9) {
            buf = Strnew_size(1536);
            while(ISread(tmpf, buf, 1536) != 0) {
                _v64 = ff;
                _v68 = buf->length;
                _v72 = 1;
                 *__esp = buf->ptr;
                fwrite();
                asm("adc edx, ebx");
                linelen = linelen + buf->length;
                _v40 = _v40;
                showProgress( &linelen,  &trbyte);
            }
L28:
            _v68 = 156;
            _v72 =  &AbortLoading;
             *__esp =  &env_bak;
            bcopy();
            if((TrapSignal & 255) != 0) {
                if((fmInitialized & 255) != 0) {
                    term_raw();
                }
                if(prevtrap != 0) {
                    mySignal(2, prevtrap);
                }
            }
             *__esp = ff;
            fclose();
            current_content_length = 0;
             *135776436 = 0;
            return 0;
        }
        while(1) {
            c = ISgetc(tmpf);
            if((tmpf[0x15] & 255) != 0) {
                break;
            }
            if(c != 10) {
                if(c != 46 || check != 1) {
                    if(c != 13 || check != 2) {
                        check = 0;
                    } else {
                        check = 1 + check;
                    }
                } else {
                    check = 1 + check;
                }
L20:
                _v72 = ff;
                 *__esp = c;
                _IO_putc();
                asm("adc edx, 0x0");
                linelen = 1 + linelen;
                _v40 = _v40;
                showProgress( &linelen,  &trbyte);
                continue;
            }
            if(check != 0) {
                if(check != 3) {
                    goto L20;
                }
                goto L28;
            }
            check = 1 + check;
            goto L20;
        }
    }
}

int doExternal(URLFile uf, char* path, char* type, Buffer** bufp, Buffer* defaultbuf)
{// addr = 0x08070F2F  --  defined in 'file.c' at line 7778
    Str tmpf;              // _cfa_fffffff0
    Str command;           // _cfa_ffffffec
    struct mailcap* mcap;   // _cfa_ffffffe8
    int mc_stat;                           // _cfa_ffffffe4
    Buffer* buf;        // _cfa_ffffffe0
    char* header;                          // _cfa_ffffffdc
    char* src;                             // _cfa_ffffffd8
    char* ext;                             // _cfa_ffffffd4
    Str tmp;               // _cfa_ffffffd0
    char* _v76;                            // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    intOrPtr _v84;                         // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    Buffer* _v92;       // _cfa_ffffffa4 (outparam)
    Buffer** _v96;      // _cfa_ffffffa0 (outparam)
    char* _v100;                           // _cfa_ffffff9c (outparam)
    char* _v104;                           // _cfa_ffffff98 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    char* _t195;                           // _t195
    int _t282;                             // _t282
    _unknown_ _t283;                       // _t283
    int _t291;                             // _t291
    int _t356;                             // _t356

    buf = 0;
    src = 0;
    ext = type;
    mcap = searchExtViewer( *(__ebp + 44));
    if(mcap == 0) {
        return 0;
    }
    if(mcap->nametemplate != 0) {
        tmpf = unquote_mailcap(mcap->nametemplate, 0, 135041709, 0, 0);
        if((tmpf & 255) == 46) {
            ext = tmpf->ptr;
        }
    }
    if(ext == 0) {
L8:
        _t195 = 0;
L9:
        tmpf = tmpfname(0, _t195);
        if((path[0x14] & 255) != 4) {
            path = newEncodedStream(path, _a6 & 255);
        }
        header = checkHeader( *(__ebp + 52), "Content-Type:");
        if(header != 0) {
            header =  *(wc_Str_conv_strict(Strnew_charp(header), InnerCharset, SystemCharset));
        }
        command = unquote_mailcap(mcap->viewer,  *(__ebp + 44), tmpf->ptr, header,  &mc_stat);
        if((mc_stat & 1) == 0) {
            _v100 = shell_quote(tmpf->ptr);
            _v104 = command->ptr;
            tmp = Sprintf("(%s) < %s");
            command = tmp;
        }
        if((mcap->flags & 6) != 0 || (mcap->flags & 1) != 0) {
L25:
            _v76 = tmpf->ptr;
             *__esp = uf.auto_detect;
            _v104 = path;
            _v100 = type;
            _v96 = bufp;
            _v92 = defaultbuf;
            _v88 = _a24;
            _v84 = _a28;
            _v80 = _a32;
            if(save2tmp() >= 0) {
                if((mcap->flags & 6) != 0) {
                    if( *(__ebp + 52) == 0) {
                        _t356 = COLS;
                        if(showLineNum == 0) {
                            _t282 = 1;
                        } else {
                            _t282 = 6;
                        }
                        _t283 = _t356 - _t282;
                        _t284 = _t283 < 0 ? 0 : _t283;
                         *(__ebp + 52) = newBuffer(_t283 < 0 ? 0 : _t283);
                    }
                    if( *(__ebp + 52)->sourcefile == 0) {
                        src = tmpf->ptr;
                    } else {
                        src =  *(__ebp + 52)->sourcefile;
                    }
                     *(__ebp + 52)->sourcefile = 0;
                     *(__ebp + 52)->mailcap = mcap;
                }
                if((mcap->flags & 4) == 0) {
                    if((mcap->flags & 2) == 0) {
                        if((mcap->flags & 1) != 0 || BackgroundExtViewer == 0) {
                            fmTerm();
                            mySystem(command->ptr, 0);
                            fmInit();
                            if(CurrentTab != 0) {
                                if(CurrentTab->currentBuffer != 0) {
                                    displayBuffer(CurrentTab->currentBuffer, 1);
                                }
                            }
                        } else {
                            mySystem(command->ptr, 1);
                        }
                        buf = 1;
                    } else {
                        buf = loadcmdout(command->ptr, loadBuffer,  *(__ebp + 52));
                        if(buf != 0 && buf != 1) {
                            buf->type = "text/plain";
                            buf->mailcap_source = buf->sourcefile;
                            buf->sourcefile = src;
                        }
                    }
                } else {
                    buf = loadcmdout(command->ptr, loadHTMLBuffer,  *(__ebp + 52));
                    if(buf != 0 && buf != 1) {
                        buf->type = "text/html";
                        buf->mailcap_source = buf->sourcefile;
                        buf->sourcefile = src;
                    }
                }
                if(buf != 0 && buf != 1) {
                    buf->filename =  *(__ebp + 40);
                    if(buf->buffername == 0 || (buf & 255) == 0) {
                        buf->buffername =  *(wc_Str_conv(Strnew_charp(lastFileName( *(__ebp + 40))), SystemCharset, InnerCharset));
                    }
                    buf->edit = mcap->edit;
                    buf->mailcap = mcap;
                }
                 *( *(__ebp + 48)) = buf;
                return 1;
            }
             *( *(__ebp + 48)) = 0;
            return 1;
        } else {
            _t291 = BackgroundExtViewer;
            if(_t291 == 0) {
                goto L25;
            }
            flush_tty();
            fork();
            if(_t291 == 0) {
                if(ISclose(path) == 0) {
                    path = 0;
                }
                myExec(command->ptr);
            }
             *( *(__ebp + 48)) = 1;
            return 1;
        }
    }
    if(( *ext & 255) == 0) {
        goto L8;
    } else {
        _t195 = ext;
        goto L9;
    }
}

int _MoveFile(char* path1, char* path2)
{// addr = 0x08071480  --  defined in 'file.c' at line 7883
    InputStream f1;   // _cfa_fffffff0
    FILE* f2;             // _cfa_ffffffec
    int is_pipe;                           // _cfa_ffffffe8
    Str buf;               // _cfa_ffffffe4
    int _v32;                              // _cfa_ffffffe0
    clen_t linelen;     // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    clen_t trbyte;      // _cfa_ffffffd4
    FILE* _v48;           // _cfa_ffffffd0
    int _v52;                              // _cfa_ffffffcc (outparam)
    int _v56;                              // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t45;                              // _t45
    FILE* _t49;           // _t49
    FILE* _t74;           // _t74

    linelen = 0;
    _v32 = 0;
    trbyte = 0;
    _v40 = 0;
    _v56 = 0;
    _t45 = path1;
     *__esp = _t45;
    open();
    f1 = newInputStream(_t45);
    if(f1 != 0) {
        if(( *path2 & 255) != 124 || (PermitSaveToPipe & 255) == 0) {
            is_pipe = 0;
            _t49 = path2;
            _v56 = "wb";
             *__esp = _t49;
            fopen();
            f2 = _t49;
        } else {
            is_pipe = 1;
            _t74 =  &(path2[1]);
            _v56 = 135041136;
             *__esp = _t74;
            popen();
            f2 = _t74;
        }
        if(f2 != 0) {
            current_content_length = 0;
             *135776436 = 0;
            buf = Strnew_size(1536);
            while(ISread(f1, buf, 1536) != 0) {
                _v48 = f2;
                _v52 = buf->length;
                _v56 = 1;
                 *__esp = buf->ptr;
                fwrite();
                asm("adc edx, ebx");
                linelen = linelen + buf->length;
                _v32 = _v32;
                showProgress( &linelen,  &trbyte);
            }
            ISclose(f1);
            if(is_pipe == 0) {
                 *__esp = f2;
                fclose();
            } else {
                 *__esp = f2;
                pclose();
            }
            return 0;
        } else {
            ISclose(f1);
            return -1;
        }
    }
    return -1;
}

int _doFileCopy(char* tmpf, char* defstr, int download)
{// addr = 0x0807160F  --  defined in 'file.c' at line 7922
    Str msg;               // _cfa_ffffffe0
    Str filen;             // _cfa_ffffffdc
    char* p;                               // _cfa_ffffffd8
    char* q;                               // _cfa_ffffffd4
    pid_t pid;           // _cfa_ffffffd0
    char* lock;                            // _cfa_ffffffcc
    int is_pipe;                           // _cfa_ffffffc8
    signed int _v64;                       // _cfa_ffffffc0
    clen_t size;        // _cfa_ffffffbc
    _unknown_ _v92;                        // _cfa_ffffffa4
    _unknown_ _v112;                       // _cfa_ffffff90
    struct stat st;       // _cfa_ffffff64
    signed int _v168;                      // _cfa_ffffff58
    long long int _v172;                   // _cfa_ffffff54 (outparam)
    char* _v176;                           // _cfa_ffffff50 (outparam)
    char* _v180;                           // _cfa_ffffff4c (outparam)
    char* _v184;                           // _cfa_ffffff48 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    char* _t149;                           // _t149
    int _t215;                             // _t215
    char** _t220;                          // _t220
    signed int _t225;                      // _t225
    char** _t249;                          // _t249
    char** _t252;                          // _t252

    q = 0;
    size = 0;
    _v64 = 0;
    is_pipe = 0;
    if((fmInitialized & 255) == 0) {
        q = searchKeyData();
        if(q == 0 || ( *q & 255) == 0) {
             *__esp = "(Download)Save file to: ";
            printf();
             *__esp = __imp__stdout;
            fflush();
            filen = Strfgets(__imp__stdin);
            if(filen->length != 0) {
                q = filen->ptr;
                goto L35;
            }
            return -1;
        } else {
L35:
            _t149 = q;
             *__esp = _t149;
            strlen();
            p =  &(q[_t149 - 1]);
            while(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                p = p - 1;
            }
            p[1] = 0;
            if(( *q & 255) != 0) {
                p = q;
                if(( *p & 255) != 124 || (PermitSaveToPipe & 255) == 0) {
                    p = expandPath(p);
                    if(checkOverWrite(p) >= 0) {
                        goto L45;
                    }
                    return -1;
                } else {
                    is_pipe = 1;
L45:
                    if(checkCopyFile(tmpf, p) >= 0) {
                        if(_MoveFile(tmpf, p) >= 0) {
                            if((PreserveTimestamp & 255) != 0 && is_pipe == 0 && __stat(tmpf,  &(st.st_dev)) == 0) {
                                setModtime(p, st.st_mtim);
                            }
L53:
                            return 0;
                        }
                        _v184 = p;
                         *__esp = "Can't save to %s\n";
                        printf();
                        return -1;
                    }
                    _v180 = p;
                    _v184 = tmpf;
                     *__esp = "Can't copy. %s and %s are identical.";
                    printf();
                    return -1;
                }
            }
            return -1;
        }
    }
    p = searchKeyData();
    if(p == 0 || ( *p & 255) == 0) {
        q = inputLineHistSearch("(Download)Save file to: ", defstr, 128, SaveHist, 0);
        if(q == 0) {
L5:
            return 0;
        }
        if(( *q & 255) != 0) {
            p =  *(wc_Str_conv_strict(Strnew_charp(q), InnerCharset, SystemCharset));
            goto L7;
        }
        goto L5;
    } else {
L7:
        if(( *p & 255) != 124) {
L10:
            if(q != 0) {
                p =  *(unescape_spaces(Strnew_charp(q)));
                p =  *(wc_Str_conv_strict(Strnew_charp(q), InnerCharset, SystemCharset));
            }
            p = expandPath(p);
            if(checkOverWrite(p) < 0) {
                return -1;
            }
L14:
            if(checkCopyFile(tmpf, p) < 0) {
                _t249 = wc_Str_conv(Strnew_charp(p), SystemCharset, InnerCharset);
                _t252 = wc_Str_conv(Strnew_charp(tmpf), SystemCharset, InnerCharset);
                _v180 =  *_t249;
                _v184 =  *_t252;
                msg = Sprintf("Can't copy. %s and %s are identical.");
                disp_err_message(msg->ptr, 0);
                return -1;
            }
            if(download != 0) {
                lock =  *(tmpfname(0, ".lock"));
                _v184 = lock;
                _t215 = p;
                 *__esp = _t215;
                symlink();
                flush_tty();
                fork();
                pid = _t215;
                if(pid == 0) {
                    setup_child(0, 0, -1);
                    if(_MoveFile(tmpf, p) == 0 && (PreserveTimestamp & 255) != 0 && is_pipe == 0 && __stat(tmpf,  &(st.st_dev)) == 0) {
                        setModtime(p, st.st_mtim);
                    }
                     *__esp = lock;
                    unlink();
                     *__esp = 0;
                    exit();
                }
                if(__stat(tmpf,  &(st.st_dev)) == 0) {
                    _t225 = st.st_size;
                    size = _t225;
                    _v64 = _t225 >> 31;
                }
                _t220 = wc_Str_conv(Strnew_charp(tmpf), SystemCharset, InnerCharset);
                _v172 = size;
                _v168 = _v64;
                _v176 = lock;
                _v180 = p;
                _v184 =  *_t220;
                 *__esp = pid;
                addDownloadList();
                goto L53;
            } else {
                if(_MoveFile(tmpf, p) < 0) {
                    _v184 =  *(wc_Str_conv(Strnew_charp(p), SystemCharset, InnerCharset));
                    msg = Sprintf("Can't save to %s");
                    disp_err_message(msg->ptr, 0);
                }
                return -1;
            }
        }
        if((PermitSaveToPipe & 255) == 0) {
            goto L10;
        } else {
            is_pipe = 1;
            goto L14;
        }
    }
}

int doFileMove(char* tmpf, char* defstr)
{// addr = 0x08071B71  --  defined in 'file.c' at line 8036
    int ret;                               // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    ret = _doFileCopy(tmpf, defstr, 0);
     *__esp = tmpf;
    unlink();
    return ret;
}

int doFileSave(URLFile uf, char* defstr)
{// addr = 0x08071BA4  --  defined in 'file.c' at line 8044
    Str msg;               // _cfa_fffffff0
    Str filen;             // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    char* q;                               // _cfa_ffffffe4
    pid_t pid;           // _cfa_ffffffe0
    char* lock;                            // _cfa_ffffffdc
    char* tmpf;                            // _cfa_ffffffd8
    char* _v60;                            // _cfa_ffffffc4
    long int _v64;                         // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    long long int _v76;                    // _cfa_ffffffb4 (outparam)
    char* _v80;                            // _cfa_ffffffb0 (outparam)
    char* _v84;                            // _cfa_ffffffac (outparam)
    char* _v88;                            // _cfa_ffffffa8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    char* _t142;                           // _t142
    int _t210;                             // _t210

    tmpf = 0;
    if((fmInitialized & 255) == 0) {
        q = searchKeyData();
        if(q == 0 || ( *q & 255) == 0) {
             *__esp = "(Download)Save file to: ";
            printf();
             *__esp = __imp__stdout;
            fflush();
            filen = Strfgets(__imp__stdin);
            if(filen->length != 0) {
                q = filen->ptr;
                goto L29;
            }
            return -1;
        } else {
L29:
            _t142 = q;
             *__esp = _t142;
            strlen();
            p =  &(q[_t142 - 1]);
            while(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                p = p - 1;
            }
            p[1] = 0;
            if(( *q & 255) != 0) {
                p = expandPath(q);
                if(checkOverWrite(p) >= 0) {
                    if(checkSaveFile(defstr, p) >= 0) {
                        if(_a20 != 0 && (AutoUncompress & 255) != 0) {
                            uncompress_stream( &uf,  &tmpf);
                            if(tmpf != 0) {
                                 *__esp = tmpf;
                                unlink();
                            }
                        }
                        _v60 = p;
                         *__esp = uf.auto_detect;
                        _v88 = defstr;
                        _v84 = _a12;
                        _v80 = _a16;
                        _v76 = _a20;
                        _v72 = _a24;
                        _v68 = _a28;
                        _v64 = _a32;
                        if(save2tmp() >= 0) {
                            if((PreserveTimestamp & 255) != 0 && _a32 != -1) {
                                setModtime(p, _a32);
                            }
L47:
                            return 0;
                        } else {
                            _v88 = p;
                             *__esp = "Can't save to %s\n";
                            printf();
                            return -1;
                        }
                    }
                    _v88 = p;
                     *__esp = "Can't save. Load file and %s are identical.";
                    printf();
                    return -1;
                }
                return -1;
            }
            return -1;
        }
    }
    p = searchKeyData();
    if(p == 0 || ( *p & 255) == 0) {
        p = inputLineHistSearch("(Download)Save file to: ",  *(__ebp + 40), 32, SaveHist, 0);
        if(p == 0) {
L5:
            return -1;
        }
        if(( *p & 255) != 0) {
            p =  *(wc_Str_conv_strict(Strnew_charp(p), InnerCharset, SystemCharset));
            goto L7;
        }
        goto L5;
    } else {
L7:
        if(checkOverWrite(p) < 0) {
            return -1;
        }
        if(checkSaveFile(defstr, p) < 0) {
            _v88 =  *(wc_Str_conv(Strnew_charp(p), SystemCharset, InnerCharset));
            msg = Sprintf("Can't save. Load file and %s are identical.");
            disp_err_message(msg->ptr, 0);
            return -1;
        }
        lock =  *(tmpfname(0, ".lock"));
        _v88 = lock;
        _t210 = p;
         *__esp = _t210;
        symlink();
        flush_tty();
        fork();
        pid = _t210;
        if(pid == 0) {
            setup_child(0, 0, ISfileno(defstr));
            _v60 = p;
             *__esp = uf.auto_detect;
            _v88 = defstr;
            _v84 = _a12;
            _v80 = _a16;
            _v76 = _a20;
            _v72 = _a24;
            _v68 = _a28;
            _v64 = _a32;
            if(save2tmp() == 0 && (PreserveTimestamp & 255) != 0 && _a32 != -1) {
                setModtime(p, _a32);
            }
            if(ISclose(defstr) == 0) {
                defstr = 0;
            }
             *__esp = lock;
            unlink();
             *__esp = 0;
            exit();
        }
        _v76 = current_content_length;
        _v72 =  *135776436;
        _v80 = lock;
        _v84 = p;
        _v88 = _a28;
         *__esp = pid;
        addDownloadList();
        goto L47;
    }
}

int checkCopyFile(char* path1, char* path2)
{// addr = 0x0807201D  --  defined in 'file.c' at line 8148
    _unknown_ _v88;                        // _cfa_ffffffa8
    struct stat st1;      // _cfa_ffffff9c
    _unknown_ _v176;                       // _cfa_ffffff50
    struct stat st2;      // _cfa_ffffff44
    _unknown_ _v200;                       // _cfa_ffffff38 (outparam)

    if(( *path2 & 255) == 124) {
        if((PermitSaveToPipe & 255) == 0) {
            goto L3;
        } else {
            return 0;
        }
    }
L3:
    if(__stat(path1,  &(st1.st_dev)) != 0 || __stat(path2,  &(st2.st_dev)) != 0 || st1.st_ino != st2.st_ino) {
        return 0;
    } else {
        return -1;
    }
}

int checkSaveFile(InputStream stream, char* path2)
{// addr = 0x0807208C  --  defined in 'file.c' at line 8161
    int des;                               // _cfa_fffffff0
    _unknown_ _v92;                        // _cfa_ffffffa4
    struct stat st1;      // _cfa_ffffff98
    _unknown_ _v180;                       // _cfa_ffffff4c
    struct stat st2;      // _cfa_ffffff40
    _unknown_ _v216;                       // _cfa_ffffff28 (outparam)

    des = ISfileno(stream);
    if(des < 0) {
        return 0;
    }
    if(( *path2 & 255) != 124 || (PermitSaveToPipe & 255) == 0) {
        if(__fstat(des,  &(st1.st_dev)) != 0 || __stat(path2,  &(st2.st_dev)) != 0 || st1.st_ino != st2.st_ino) {
            return 0;
        } else {
            return -1;
        }
    } else {
        return 0;
    }
}

int checkOverWrite(char* path)
{// addr = 0x08072116  --  defined in 'file.c' at line 8177
    char* ans;                             // _cfa_fffffff0
    struct stat st;       // _cfa_ffffff98
    _unknown_ _v120;                       // _cfa_ffffff88 (outparam)

    if(__stat(path,  &(st.st_dev)) >= 0) {
        ans = inputAnswer("File exists. Overwrite? (y/n)");
        if(ans == 0) {
L8:
            return -1;
        }
        if(( *( &MYCTYPE_MAP + ( *ans & 0xff)) & 4) == 0) {
            if(( *ans & 255) != 121) {
                goto L8;
            }
L7:
            return 0;
        }
        if(( *ans & 255 | 32) == 121) {
            goto L7;
        }
        goto L8;
    }
    return 0;
}

char* inputAnswer(char* prompt)
{// addr = 0x0807218F  --  defined in 'file.c' at line 8193
    char* ans;                             // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    char* _v56;                            // _cfa_ffffffc8 (outparam)

    if((QuietMessage & 255) == 0) {
        if((fmInitialized & 255) == 0) {
            _v56 = prompt;
             *__esp = 135048000;
            printf();
             *__esp = __imp__stdout;
            fflush();
            ans =  *(Strfgets(__imp__stdin));
        } else {
            term_raw();
            ans = inputLineHistSearch(prompt, 135041709, 512, 0, 0);
        }
        return ans;
    }
    return 135047998;
}

void uncompress_stream(URLFile* uf, char** src)
{// addr = 0x0807221F  --  defined in 'file.c' at line 8212
    pid_t pid1;          // _cfa_fffffff0
    FILE* f1;             // _cfa_ffffffec
    char* expand_cmd;                      // _cfa_ffffffe8
    char* expand_name;                     // _cfa_ffffffe4
    char* tmpf;                            // _cfa_ffffffe0
    char* ext;                             // _cfa_ffffffdc
    struct compression_decoder* d;   // _cfa_ffffffd8
    pid_t pid2;          // _cfa_ffffffd4
    FILE* f2;             // _cfa_ffffffd0
    Str buf;               // _cfa_ffffffcc
    FILE* f;              // _cfa_ffffffc8
    FILE* _v64;           // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc (outparam)
    char* _v72;                            // _cfa_ffffffb8 (outparam)
    FILE* _t156;          // _t156

    expand_cmd = "gunzip";
    expand_name = "gunzip";
    tmpf = 0;
    ext = 0;
    if(( *(uf->stream + 20) & 255) != 4) {
        uf->stream = newEncodedStream(uf->stream, uf->encoding & 255);
        uf->encoding = 0;
    }
    d =  &compression_decoders;
    while(d->type != 0) {
        if(uf->compression != d->type) {
            d = d + 44;
            continue;
        } else {
            if(d->auxbin_p == 0) {
                expand_cmd = d->cmd;
            } else {
                expand_cmd = auxbinFile(d->cmd);
            }
            expand_name = d->name;
            ext = d->ext;
            break;
        }
    }
    uf->compression = 0;
    if((uf->scheme & 255) != 4 && image_source == 0) {
        tmpf =  *(tmpfname(0, ext));
    }
    pid1 = open_pipe_rw( &f1, 0);
    if(pid1 >= 0) {
        if(pid1 != 0) {
L34:
            if(tmpf != 0) {
                if(src == 0) {
                    uf->scheme = 4;
                } else {
                     *src = tmpf;
                }
            }
            UFhalfclose(uf);
            uf->stream = newFileStream(f1, fclose);
            return;
        }
        f2 = __imp__stdin;
        pid2 = open_pipe_rw( &f2, 0);
        if(pid2 < 0) {
            if(ISclose(uf->stream) == 0) {
                uf->stream = 0;
            }
             *__esp = 1;
            exit();
        }
        if(pid2 != 0) {
L33:
            _v72 = 2;
             *__esp = 1;
            dup2();
            setup_child(1, -1, -1);
            _v68 = 0;
            _v72 = expand_name;
             *__esp = expand_cmd;
            execlp();
             *__esp = 1;
            exit();
            goto L34;
        } else {
            buf = Strnew_size(1536);
            f = 0;
            setup_child(1, 2, ISfileno(uf->stream));
            if(tmpf != 0) {
                _t156 = tmpf;
                _v72 = "wb";
                 *__esp = _t156;
                fopen();
                f = _t156;
            }
            while(ISread(uf->stream, buf, 1536) != 0) {
                _v64 = __imp__stdout;
                _v68 = buf->length;
                _v72 = 1;
                 *__esp = buf->ptr;
                fwrite();
                if(f != 0) {
                    _v64 = f;
                    _v68 = buf->length;
                    _v72 = 1;
                     *__esp = buf->ptr;
                    fwrite();
                }
            }
            if(ISclose(uf->stream) == 0) {
                uf->stream = 0;
            }
            if(f != 0) {
                 *__esp = f;
                fclose();
            }
             *__esp = 0;
            exit();
            goto L33;
        }
    } else {
        if(ISclose(uf->stream) != 0) {
            return;
        }
        uf->stream = 0;
        return;
    }
}

FILE* lessopen_stream(char* path)
{// addr = 0x08072573  --  defined in 'file.c' at line 8302
    char* lessopen;                        // _cfa_fffffff0
    FILE* fp;             // _cfa_ffffffec
    Str tmpf;              // _cfa_ffffffe8
    int c;                                 // _cfa_ffffffe4
    FILE* _v40;           // _cfa_ffffffd8
    FILE* _t35;           // _t35
    int _t36;                              // _t36

     *__esp = "LESSOPEN";
    getenv();
    lessopen = __eax;
    if(lessopen != 0) {
        if(( *lessopen & 255) != 0) {
            if(( *lessopen & 255) != 124) {
                fp = 0;
L11:
                return fp;
            }
            lessopen =  &(lessopen[1]);
            _v40 = shell_quote(path);
            tmpf = Sprintf(lessopen);
            _t35 = tmpf->ptr;
            _v40 = 135047752;
             *__esp = _t35;
            popen();
            fp = _t35;
            if(fp != 0) {
                _t36 = fp;
                 *__esp = _t36;
                _IO_getc();
                c = _t36;
                if(c != -1) {
                    _v40 = fp;
                     *__esp = c;
                    ungetc();
                    goto L11;
                }
                 *__esp = fp;
                fclose();
                return 0;
            }
            return 0;
        }
        return 0;
    }
    return 0;
}

char* guess_filename(char* file)
{// addr = 0x08072646  --  defined in 'file.c' at line 8376
    char* p;                               // _cfa_fffffff0
    char* s;                               // _cfa_ffffffec

    p = 0;
    if(file != 0) {
        p = mybasename(file);
    }
    if(p == 0 || ( *p & 255) == 0) {
        return "index.html";
    }
    s = p;
    if(( *p & 255) == 35) {
        p =  &(p[1]);
    }
    while(( *p & 255) != 0) {
        if(( *p & 255) != 35 || (p[1] & 255) == 0) {
            if(( *p & 255) != 63) {
                p =  &(p[1]);
                continue;
            }
            goto L10;
        } else {
L10:
             *p = 0;
            break;
        }
    }
    return s;
}

char* guess_save_name(Buffer* buf, char* path)
{// addr = 0x080726D3  --  defined in 'file.c' at line 8398
    Str name;              // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    char* _t54;                            // _t54
    char* _t71;                            // _t71

    if(buf == 0 || buf->document_header == 0) {
L16:
        return guess_filename(path);
    } else {
        name = 0;
        p = checkHeader(buf, "Content-Disposition:");
        if(p == 0) {
L9:
            p = checkHeader(buf, "Content-Type:");
            if(p != 0) {
                _v40 = "name";
                _t54 = p;
                 *__esp = _t54;
                strcasestr();
                q = _t54;
                if(q != 0 && (q == p || ( *( &MYCTYPE_MAP + ( *(q - 1) & 0xff)) & 2) != 0 || ( *(q - 1) & 255) == 59)) {
                    if(matchattr(q, "name", 4,  &name) != 0) {
                        path = name->ptr;
                    }
                }
            }
            goto L16;
        }
        _v40 = "filename";
        _t71 = p;
         *__esp = _t71;
        strcasestr();
        q = _t71;
        if(q == 0 || q != p && ( *( &MYCTYPE_MAP + ( *(q - 1) & 0xff)) & 2) == 0 && ( *(q - 1) & 255) != 59) {
            goto L9;
        } else {
            if(matchattr(q, "filename", 8,  &name) == 0) {
                goto L9;
            } else {
                path = name->ptr;
                goto L16;
            }
        }
    }
}

Buffer* newBuffer(int width)
{// addr = 0x08072844  --  defined in 'buffer.c' at line 25
    Buffer* n;          // _cfa_fffffff0
    Buffer* _v40;       // _cfa_ffffffd8
    unsigned char _t44;                    // _t44

     *__esp = 260;
    GC_malloc();
    n = __eax;
    if(n != 0) {
        _v40 = 260;
         *__esp = n;
        bzero();
        n->width = width;
        n->COLS = COLS;
        n->LINES = LINES - 1;
        n->currentURL = 255;
        n->baseURL = 0;
        n->baseTarget = 0;
        n->buffername = 135048112;
        _t44 = n;
         *((short*)(_t44 + 64)) = 0;
         *__esp = 4;
        GC_malloc();
        n->clone = _t44;
         *(n->clone) = 1;
        n->trbyte = 0;
        n->auto_detect = WcOption.auto_detect & 255;
        return n;
    }
    return 0;
}

Buffer* nullBuffer()
{// addr = 0x08072929  --  defined in 'buffer.c' at line 57
    Buffer* b;          // _cfa_fffffff0

    b = newBuffer(COLS);
    b->buffername = "*Null*";
    return b;
}

void clearBuffer(Buffer* buf)
{// addr = 0x0807294E  --  defined in 'buffer.c' at line 70
    buf->lastLine = 0;
    buf->currentLine = buf->lastLine;
    buf->topLine = buf->currentLine;
    buf->firstLine = buf->topLine;
    buf->allLine = 0;
}

void discardBuffer(Buffer* buf)
{// addr = 0x0807298B  --  defined in 'buffer.c' at line 81
    int i;                                 // _cfa_fffffff0
    Buffer* b;          // _cfa_ffffffec
    intOrPtr _v36;                         // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    int* _t69;                             // _t69
    char* _t101;                           // _t101

    deleteImage(buf);
    clearBuffer(buf);
    i = 0;
    do {
    } while(i <= 4);
    if(buf->savecache != 0) {
         *__esp = buf->savecache;
        unlink();
    }
    _t69 = buf->clone;
     *_t69 =  *_t69 - 1;
    if( *_t69 != 0) {
        return;
    } else {
        if(buf->pagerSource != 0) {
            ISclose(buf->pagerSource);
        }
        if(buf->sourcefile == 0) {
L17:
            if(buf->header_source != 0) {
                 *__esp = buf->header_source;
                unlink();
            }
            if(buf->mailcap_source != 0) {
                 *__esp = buf->mailcap_source;
                unlink();
            }
            while(buf->frameset != 0) {
                deleteFrameSet(buf->frameset);
                buf->frameset = popFrameTree( &(buf->frameQ));
            }
            return;
        } else {
            if(buf->real_type == 0) {
L14:
                if(buf->real_scheme != 4 || (buf->bufferprop & 2) != 0) {
                     *__esp = buf->sourcefile;
                    unlink();
                }
                goto L17;
            }
            _t101 = buf->real_type;
            _v36 = 6;
            _v40 = "image/";
             *__esp = _t101;
            strncasecmp();
            if(_t101 == 0) {
                goto L17;
            }
            goto L14;
        }
    }
}

Buffer* namedBuffer(Buffer* first, char* name)
{// addr = 0x08072B1F  --  defined in 'buffer.c' at line 121
    Buffer* buf;        // _cfa_fffffff0
    char* _v40;                            // _cfa_ffffffd8
    char* _t21;                            // _t21
    char* _t27;                            // _t27

    _t21 = first->buffername;
    _v40 = name;
     *__esp = _t21;
    strcmp();
    if(_t21 != 0) {
        buf = first;
        while(buf->nextBuffer != 0) {
            _t27 = buf->nextBuffer->buffername;
            _v40 = name;
             *__esp = _t27;
            strcmp();
            if(_t27 != 0) {
                buf = buf->nextBuffer;
                continue;
            }
            return buf->nextBuffer;
        }
        return 0;
    }
    return first;
}

Buffer* deleteBuffer(Buffer* first, Buffer* delbuf)
{// addr = 0x08072B89  --  defined in 'buffer.c' at line 140
    Buffer* buf;        // _cfa_fffffff0
    Buffer* b;          // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(first != delbuf || first->nextBuffer == 0) {
        buf = prevBuffer(first, delbuf);
        if(buf != 0) {
            b = buf->nextBuffer;
            buf->nextBuffer = b->nextBuffer;
            discardBuffer(b);
        }
        return first;
    } else {
        buf = first->nextBuffer;
        discardBuffer(first);
        return buf;
    }
}

Buffer* replaceBuffer(Buffer* first, Buffer* delbuf, Buffer* newbuf)
{// addr = 0x08072BFA  --  defined in 'buffer.c' at line 161
    Buffer* buf;        // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(delbuf != 0) {
        if(first != delbuf) {
            if(delbuf == 0) {
L7:
                newbuf->nextBuffer = first;
                return newbuf;
            }
            buf = prevBuffer(first, delbuf);
            if(buf == 0) {
                goto L7;
            }
            buf->nextBuffer = newbuf;
            newbuf->nextBuffer = delbuf->nextBuffer;
            discardBuffer(delbuf);
            return first;
        }
        newbuf->nextBuffer = delbuf->nextBuffer;
        discardBuffer(delbuf);
        return newbuf;
    }
    newbuf->nextBuffer = first;
    return newbuf;
}

Buffer* nthBuffer(Buffer* firstbuf, int n)
{// addr = 0x08072C8C  --  defined in 'buffer.c' at line 185
    int i;                                 // _cfa_fffffff8
    Buffer* buf;        // _cfa_fffffff4

    buf = firstbuf;
    if(n >= 0) {
        i = 0;
        while(i < n) {
            if(buf != 0) {
                buf = buf->nextBuffer;
                i = i + 1;
                continue;
            }
            return 0;
        }
        return buf;
    }
    return firstbuf;
}

void writeBufferName(Buffer* buf, int n)
{// addr = 0x08072CD3  --  defined in 'buffer.c' at line 201
    Str msg;               // _cfa_fffffff0
    int all;                               // _cfa_ffffffec
    int _v36;                              // _cfa_ffffffdc (outparam)
    int _v40;                              // _cfa_ffffffd8 (outparam)
    int _t83;                              // _t83
    int _t90;                              // _t90
    char* _t102;                           // _t102
    int _t109;                             // _t109

    all = buf->allLine.scheme;
    if(all == 0 && buf->lastLine.scheme != 0) {
        all = buf->lastLine.scheme[0x1c];
    }
    move(n, 0);
    _v36 = all;
    _v40 = buf->buffername.scheme;
    msg = Sprintf("<%s> [%d lines]");
    if(buf->filename == 0) {
L16:
        addnstr_sup(msg->ptr, COLS - 1);
        return;
    }
    _t83 = buf->currentURL.scheme;
    if(_t83 < 4) {
L12:
        if(msg->length + 1 >= msg->area_size) {
            Strgrow(msg);
        }
        _t90 = msg->length;
         *((char*)(msg->ptr + _t90)) = 32;
        msg->length = _t90 + 1;
         *((char*)(msg->ptr + msg->length)) = 0;
        Strcat(msg, parsedURL2Str( &(buf->currentURL)));
        goto L16;
    }
    if(_t83 <= 5) {
        _t102 = buf->currentURL.file;
        _v40 = 135048143;
         *__esp = _t102;
        strcmp();
        if(_t102 != 0) {
            if(msg->length + 1 >= msg->area_size) {
                Strgrow(msg);
            }
            _t109 = msg->length;
             *((char*)(msg->ptr + _t109)) = 32;
            msg->length = _t109 + 1;
             *((char*)(msg->ptr + msg->length)) = 0;
            Strcat_charp(msg,  *(wc_Str_conv(Strnew_charp(buf->currentURL.real_file), SystemCharset, InnerCharset)));
        }
        goto L16;
    }
    if(_t83 - 254 > 1) {
        goto L12;
    }
    goto L16;
}

void gotoLine(Buffer* buf, int n)
{// addr = 0x08072EA3  --  defined in 'buffer.c' at line 238
    signed int _v16;                       // _cfa_fffffff0
    char[31] msg;                          // _cfa_ffffffd0
    Line* l;              // _cfa_ffffffcc
    Buffer* _v64;       // _cfa_ffffffc0
    _unknown_ _v80;                        // _cfa_ffffffb0 (outparam)
    long int _v84;                         // _cfa_ffffffac (outparam)
    char* _v88;                            // _cfa_ffffffa8 (outparam)

    _v64 = buf;
    _v16 =  *gs:0x14];
    l = _v64->firstLine;
    if(l == 0) {
L20:
        if((_v16 ^  *gs:0x14]) == 0) {
            return;
        }
        __stack_chk_fail();
        return;
    }
    if(_v64->pagerSource == 0 || (_v64->bufferprop & 0x40) != 0) {
L7:
        if(l->linenumber <= n) {
            if(_v64->lastLine->linenumber >= n) {
                while(l != 0) {
                    if(l->linenumber < n) {
                        l = l->next;
                        continue;
                    }
                    _v64->currentLine = l;
                    if(_v64->topLine->linenumber > n || _v64->topLine->linenumber + (_v64->LINES & 65535) <= n) {
                        _v64->topLine = lineSkip(_v64, l, ( !(_v64->LINES & 65535) >> 31) +  !(_v64->LINES & 65535) >> 1, 0);
                    }
                    goto L20;
                }
                goto L20;
            }
            l = _v64->lastLine;
            _v84 = _v64->lastLine->linenumber;
            _v88 = "Last line is #%ld";
             *__esp =  &msg;
            sprintf();
            set_delayed_message( &msg);
            _v64->currentLine = l;
            _v64->topLine = lineSkip(_v64, _v64->currentLine, 1 - (_v64->LINES & 65535), 0);
        } else {
            _v84 = l->linenumber;
            _v88 = "First line is #%ld";
             *__esp =  &msg;
            sprintf();
            set_delayed_message( &msg);
            _v64->currentLine = l;
            _v64->topLine = _v64->currentLine;
        }
        goto L20;
    } else {
        if(_v64->lastLine->linenumber < n) {
            getNextPage(_v64, n - _v64->lastLine->linenumber);
        }
        do {
        } while(_v64->lastLine->linenumber < n && getNextPage(_v64, 1) != 0);
        goto L7;
    }
}

void gotoRealLine(Buffer* buf, int n)
{// addr = 0x080730B4  --  defined in 'buffer.c' at line 283
    signed int _v16;                       // _cfa_fffffff0
    char[31] msg;                          // _cfa_ffffffd0
    Line* l;              // _cfa_ffffffcc
    Buffer* _v64;       // _cfa_ffffffc0
    _unknown_ _v80;                        // _cfa_ffffffb0 (outparam)
    long int _v84;                         // _cfa_ffffffac (outparam)
    char* _v88;                            // _cfa_ffffffa8 (outparam)

    _v64 = buf;
    _v16 =  *gs:0x14];
    l = _v64->firstLine;
    if(l == 0) {
L20:
        if((_v16 ^  *gs:0x14]) == 0) {
            return;
        }
        __stack_chk_fail();
        return;
    }
    if(_v64->pagerSource == 0 || (_v64->bufferprop & 0x40) != 0) {
L7:
        if(l->real_linenumber <= n) {
            if(_v64->lastLine->real_linenumber >= n) {
                while(l != 0) {
                    if(l->real_linenumber < n) {
                        l = l->next;
                        continue;
                    }
                    _v64->currentLine = l;
                    if(_v64->topLine->real_linenumber > n || _v64->topLine->real_linenumber + (_v64->LINES & 65535) <= n) {
                        _v64->topLine = lineSkip(_v64, l, ( !(_v64->LINES & 65535) >> 31) +  !(_v64->LINES & 65535) >> 1, 0);
                    }
                    goto L20;
                }
                goto L20;
            }
            l = _v64->lastLine;
            _v84 = _v64->lastLine->real_linenumber;
            _v88 = "Last line is #%ld";
             *__esp =  &msg;
            sprintf();
            set_delayed_message( &msg);
            _v64->currentLine = l;
            _v64->topLine = lineSkip(_v64, _v64->currentLine, 1 - (_v64->LINES & 65535), 0);
        } else {
            _v84 = l->real_linenumber;
            _v88 = "First line is #%ld";
             *__esp =  &msg;
            sprintf();
            set_delayed_message( &msg);
            _v64->currentLine = l;
            _v64->topLine = _v64->currentLine;
        }
        goto L20;
    } else {
        if(_v64->lastLine->real_linenumber < n) {
            getNextPage(_v64, n - _v64->lastLine->real_linenumber);
        }
        do {
        } while(_v64->lastLine->real_linenumber < n && getNextPage(_v64, 1) != 0);
        goto L7;
    }
}

Buffer* listBuffer(Buffer* top, Buffer* current)
{// addr = 0x080732C5  --  defined in 'buffer.c' at line 326
    int i;                                 // _cfa_fffffff0
    int c;                                 // _cfa_ffffffec
    Buffer* buf;        // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    c = 0;
    buf = top;
    move(0, 0);
    if(useColor != 0) {
        setfcolor(basic_color);
        setbcolor(bg_color);
    }
    clrtobotx();
    i = 0;
    while(LINES - 1 > i) {
        if(buf == current) {
            c = i;
            standout();
        }
        writeBufferName(buf, i);
        if(buf != current) {
            clrtoeolx();
        } else {
            standend();
            clrtoeolx();
            move(i, 0);
            toggle_stand();
        }
        if(buf->nextBuffer != 0) {
            buf = buf->nextBuffer;
            i = i + 1;
            continue;
        } else {
            move(i + 1, 0);
            clrtobotx();
        }
        break;
    }
    standout();
    message("Buffer selection mode: SPC for select / D for delete buffer", 0, 0);
    standend();
    move(c, 0);
    refresh();
    return buf->nextBuffer;
}

Buffer* selectBuffer(Buffer* firstbuf, Buffer* currentbuf, char* selectchar)
{// addr = 0x08073401  --  defined in 'buffer.c' at line 379
    char c;                                // _cfa_fffffff3
    int i;                                 // _cfa_ffffffec
    int cpoint;                            // _cfa_ffffffe8
    int spoint;                            // _cfa_ffffffe4
    int maxbuf;                            // _cfa_ffffffe0
    int sclimit;                           // _cfa_ffffffdc
    Buffer* buf;        // _cfa_ffffffd8
    Buffer* topbuf;     // _cfa_ffffffd4
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    char _t139;                            // _t139
    char _t185;                            // _t185

    sclimit = LINES - 1;
    cpoint = 0;
    i = cpoint;
    buf = firstbuf;
    goto L4;
    do {
    } while();
    while(1) {
L9:
        c = do_getch();
        if(c == 27) {
            c = do_getch();
            if(c == 91 || c == 79) {
                c = do_getch();
                _t185 = c;
                if(_t185 == 66) {
                    c = 106;
                } else {
                    if(_t185 > 66) {
                        if(_t185 == 67) {
                            c = 32;
                        } else {
                            if(_t185 == 68) {
                                c = 66;
                            }
                        }
                    } else {
                        if(_t185 == 65) {
                            c = 107;
                        }
                    }
                }
            }
        }
L23:
        _t139 = c;
        if(_t139 == 16) {
L36:
            if(spoint <= 0) {
                if(cpoint > 0) {
                    i = cpoint - sclimit;
                    if(i < 0) {
                        i = 0;
                    }
                    cpoint = cpoint - 1;
                    spoint = cpoint - i;
                    currentbuf = nthBuffer(firstbuf, cpoint);
                    topbuf = nthBuffer(firstbuf, i);
                    listBuffer(topbuf, currentbuf);
                }
            } else {
                writeBufferName(currentbuf, spoint);
                spoint = spoint - 1;
                currentbuf = nthBuffer(topbuf, spoint);
                cpoint = cpoint - 1;
                standout();
                writeBufferName(currentbuf, spoint);
                standend();
                move(spoint, 0);
                toggle_stand();
            }
L45:
            move(spoint, 0);
            refresh();
            while(1) {
L9:
                c = do_getch();
                if(c == 27) {
                    c = do_getch();
                    if(c == 91 || c == 79) {
                        c = do_getch();
                        _t185 = c;
                        if(_t185 == 66) {
                            c = 106;
                        } else {
                            if(_t185 > 66) {
                                if(_t185 == 67) {
                                    c = 32;
                                } else {
                                    if(_t185 == 68) {
                                        c = 66;
                                    }
                                }
                            } else {
                                if(_t185 == 65) {
                                    c = 107;
                                }
                            }
                        }
                    }
                }
                goto L23;
            }
        }
        if(_t139 > 16) {
            if(_t139 == 106) {
L30:
                if(sclimit - 1 <= spoint) {
                    if(maxbuf - 1 > cpoint) {
                        topbuf = currentbuf;
                        currentbuf = currentbuf->nextBuffer;
                        cpoint = cpoint + 1;
                        spoint = 1;
                        listBuffer(topbuf, currentbuf);
                    }
                    goto L45;
                }
                if(currentbuf->nextBuffer != 0) {
                    writeBufferName(currentbuf, spoint);
                    currentbuf = currentbuf->nextBuffer;
                    cpoint = cpoint + 1;
                    spoint = spoint + 1;
                    standout();
                    writeBufferName(currentbuf, spoint);
                    standend();
                    move(spoint, 0);
                    toggle_stand();
                    goto L45;
                }
                continue;
            }
            if(_t139 == 107) {
                goto L36;
            }
L42:
             *selectchar = c & 255;
            return currentbuf;
        }
        if(_t139 == 14) {
            goto L30;
        } else {
            goto L42;
        }
    }
L4:
    if(buf != 0) {
        if(buf == currentbuf) {
            cpoint = i;
        }
        i = i + 1;
        buf = buf->nextBuffer;
        goto L4;
    } else {
        maxbuf = i;
        if(cpoint < sclimit) {
            topbuf = firstbuf;
            spoint = cpoint;
        } else {
            spoint = (sclimit >> 31) + sclimit >> 1;
            topbuf = nthBuffer(firstbuf, cpoint - spoint);
        }
        listBuffer(topbuf, currentbuf);
    }
    goto L9;
}

void reshapeBuffer(Buffer* buf)
{// addr = 0x080736FB  --  defined in 'buffer.c' at line 504
    wc_uint8 old_auto_detect;   // _cfa_fffffff3
    Line* cur;            // _cfa_ffffffec
    int n;                                 // _cfa_ffffffe8
    union input_stream* _v52;   // _cfa_ffffffcc
    URLFile f;         // _cfa_ffffffc8
    union input_stream* _v84;   // _cfa_ffffffac
    URLFile h;         // _cfa_ffffffa8
    AnchorList* _v240;   // _cfa_ffffff10
    intOrPtr _v272;                        // _cfa_fffffef0
    char _v280;                            // _cfa_fffffee8
    Line* _v332;          // _cfa_fffffeb4
    intOrPtr _v336;                        // _cfa_fffffeb0
    intOrPtr _v340;                        // _cfa_fffffeac
    Buffer sbuf;        // _cfa_fffffea4
    _unknown_ _v352;                       // _cfa_fffffea0 (outparam)
    _unknown_ _v356;                       // _cfa_fffffe9c (outparam)
    Buffer* _v360;      // _cfa_fffffe98 (outparam)
    _unknown_ __ebx;                       // r1
    int _t197;                             // _t197
    _unknown_ _t198;                       // _t198
    char* _t207;                           // _t207
    char* _t334;                           // _t334
    int _t350;                             // _t350

    old_auto_detect = WcOption.auto_detect & 255;
    if((buf->need_reshape & 255) == 0) {
        return;
    } else {
        buf->need_reshape = 0;
        _t350 = COLS;
        if(showLineNum == 0) {
            _t197 = 1;
        } else {
            _t197 = 6;
        }
        _t198 = _t350 - _t197;
        _t199 = _t198 < 0 ? 0 : _t198;
        _t352 = _t198 < 0 ? 0 : _t198;
        buf->width = _t198 < 0 ? 0 : _t198;
        if(buf->sourcefile == 0) {
            return;
        } else {
            init_stream( &f, 4, 0);
            if(buf->mailcap_source == 0) {
                _t207 = buf->sourcefile;
            } else {
                _t207 = buf->mailcap_source;
            }
            examineFile(_t207,  &f);
            if(_v52 == 0) {
                return;
            } else {
                copyBuffer( &sbuf, buf);
                clearBuffer(buf);
                while(buf->frameset != 0) {
                    deleteFrameSet(buf->frameset);
                    buf->frameset = popFrameTree( &(buf->frameQ));
                }
                buf->href = 0;
                buf->name = 0;
                buf->img = 0;
                buf->formitem = 0;
                buf->formlist = 0;
                buf->linklist = 0;
                buf->maplist = 0;
                if(buf->hmarklist != 0) {
                     *(buf->hmarklist + 4) = 0;
                }
                if(buf->imarklist != 0) {
                     *(buf->imarklist + 4) = 0;
                }
                if(buf->header_source == 0) {
L27:
                    WcOption.auto_detect = 0;
                    UseContentCharset = 0;
                    if(is_html_type(buf->type) == 0) {
                        _v360 = buf;
                        loadBuffer( &f);
                    } else {
                        loadHTMLBuffer( &f, buf);
                    }
                    if(ISclose(_v52) == 0) {
                        _v52 = 0;
                    }
                    WcOption.auto_detect = old_auto_detect & 255;
                    UseContentCharset = 1;
                    buf->height = LINES;
                    if(buf->firstLine == 0 || _v340 == 0) {
L50:
                        if((buf->check_url & 1) != 0) {
                            chkURLBuffer(buf);
                        }
                        if((buf->check_url & 2) != 0) {
                            chkNMIDBuffer(buf);
                        }
                        if(buf->real_scheme == 7 || buf->real_scheme == 9) {
                            reAnchorNewsheader(buf);
                        }
                        formResetBuffer(buf, _v240);
                        return;
                    } else {
                        cur = _v332;
                        buf->pos = _v272 + cur->bpos;
                        while(cur->bpos != 0 && cur->prev != 0) {
                            cur = cur->prev;
                        }
                        if(cur->real_linenumber <= 0) {
                            gotoLine(buf, cur->linenumber);
                        } else {
                            gotoRealLine(buf, cur->real_linenumber);
                        }
                        n = buf->currentLine->linenumber - buf->topLine->linenumber +  *((intOrPtr*)(_v336 + 28)) - cur->linenumber;
                        if(n != 0) {
                            buf->topLine = lineSkip(buf, buf->topLine, n, 0);
                            if(cur->real_linenumber <= 0) {
                                gotoLine(buf, cur->linenumber);
                            } else {
                                gotoRealLine(buf, cur->real_linenumber);
                            }
                        }
                        buf->pos = buf->pos - buf->currentLine->bpos;
                        if(FoldLine == 0 || is_html_type(buf->type) != 0) {
                            buf->currentColumn = _v280;
                        } else {
                            buf->currentColumn = 0;
                        }
                        arrangeCursor(buf);
                        goto L50;
                    }
                } else {
                    if(buf->currentURL != 4 || buf->mailcap_source != 0) {
L20:
                        init_stream( &h, 4, 0);
                        examineFile(buf->header_source,  &h);
                        if(_v84 != 0) {
                            readHeader( &h, buf, 1, 0);
                            if(ISclose(_v84) == 0) {
                                _v84 = 0;
                            }
                        }
                        goto L27;
                    } else {
                        _t334 = buf->currentURL.file;
                        _v360 = 135048143;
                         *__esp = _t334;
                        strcmp();
                        if(_t334 != 0) {
                            if((buf->search_header & 255) != 0) {
                                readHeader( &f, buf, 1, 0);
                            }
                            goto L27;
                        }
                        goto L20;
                    }
                }
            }
        }
    }
}

void copyBuffer(Buffer* a, Buffer* b)
{// addr = 0x08073C16  --  defined in 'buffer.c' at line 612
    intOrPtr _v20;                         // _cfa_ffffffec
    Buffer* _v24;       // _cfa_ffffffe8

    readBufferCache(b);
    _v20 = 260;
    _v24 = a;
     *__esp = b;
    bcopy();
}

Buffer* prevBuffer(Buffer* first, Buffer* buf)
{// addr = 0x08073C43  --  defined in 'buffer.c' at line 619
    Buffer* b;          // _cfa_fffffff8

    b = first;
    while(b != 0 && b->nextBuffer != buf) {
        b = b->nextBuffer;
    }
    return b;
}

int writeBufferCache(Buffer* buf)
{// addr = 0x08073C70  --  defined in 'buffer.c' at line 631
    Str tmp;               // _cfa_fffffff0
    FILE* cache;          // _cfa_ffffffec
    Line* l;              // _cfa_ffffffe8
    int colorflag;                         // _cfa_ffffffe4
    FILE* _v32;           // _cfa_ffffffe0
    int _v36;                              // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8 (outparam)
    FILE* _t137;          // _t137
    FILE* _t140;          // _t140
    FILE* _t146;          // _t146
    FILE* _t150;          // _t150
    FILE* _t152;          // _t152
    FILE* _t154;          // _t154
    FILE* _t156;          // _t156
    FILE* _t158;          // _t158
    FILE* _t160;          // _t160
    FILE* _t162;          // _t162
    Linecolor* _t181;   // _t181
    char* _t185;                           // _t185
    Lineprop* _t189;   // _t189

    cache = 0;
    if(buf->savecache == 0) {
        if(buf->firstLine == 0) {
L29:
            buf->savecache = 0;
            return -1;
        }
        tmp = tmpfname(3, 0);
        buf->savecache = tmp->ptr;
        _t137 = buf->savecache;
        _v40 = 135048244;
         *__esp = _t137;
        fopen();
        cache = _t137;
        if(cache == 0) {
            goto L29;
        }
        _t140 = cache;
        _v32 = _t140;
        _v36 = 1;
        _v40 = 4;
         *__esp =  &(buf->currentLine->linenumber);
        fwrite();
        if(_t140 == 0) {
L26:
             *__esp = cache;
            fclose();
             *__esp = buf->savecache;
            unlink();
            goto L29;
        }
        _t146 = cache;
        _v32 = _t146;
        _v36 = 1;
        _v40 = 4;
         *__esp =  &(buf->topLine->linenumber);
        fwrite();
        if(_t146 == 0) {
            goto L26;
        }
        l = buf->firstLine;
        while(l != 0) {
            _t150 = cache;
            _v32 = _t150;
            _v36 = 1;
            _v40 = 4;
             *__esp =  &(l->real_linenumber);
            fwrite();
            if(_t150 == 0) {
                goto L26;
            }
            _t152 = cache;
            _v32 = _t152;
            _v36 = 1;
            _v40 = 2;
             *__esp =  &(l->usrflags);
            fwrite();
            if(_t152 == 0) {
                goto L26;
            }
            _t154 = cache;
            _v32 = _t154;
            _v36 = 1;
            _v40 = 4;
             *__esp =  &(l->width);
            fwrite();
            if(_t154 == 0) {
                goto L26;
            }
            _t156 = cache;
            _v32 = _t156;
            _v36 = 1;
            _v40 = 4;
             *__esp =  &(l->len);
            fwrite();
            if(_t156 == 0) {
                goto L26;
            }
            _t158 = cache;
            _v32 = _t158;
            _v36 = 1;
            _v40 = 4;
             *__esp =  &(l->size);
            fwrite();
            if(_t158 == 0) {
                goto L26;
            }
            _t160 = cache;
            _v32 = _t160;
            _v36 = 1;
            _v40 = 4;
             *__esp =  &(l->bpos);
            fwrite();
            if(_t160 == 0) {
                goto L26;
            }
            _t162 = cache;
            _v32 = _t162;
            _v36 = 1;
            _v40 = 4;
             *__esp =  &(l->bwidth);
            fwrite();
            if(_t162 == 0) {
                goto L26;
            }
            if(l->bpos != 0) {
L17:
                colorflag = l->colorBuf != 0 & 255;
                _v32 = cache;
                _v36 = 1;
                _v40 = 4;
                 *__esp =  &colorflag;
                fwrite();
                if( &colorflag == 0) {
                    goto L26;
                }
                if(colorflag == 0 || l->bpos != 0) {
L21:
                    l = l->next;
                    continue;
                } else {
                    _t181 = l->colorBuf;
                    _v32 = cache;
                    _v36 = l->size;
                    _v40 = 1;
                     *__esp = _t181;
                    fwrite();
                    if(_t181 < l->size) {
                        goto L26;
                    }
                    goto L21;
                }
            }
            _t185 = l->lineBuf;
            _v32 = cache;
            _v36 = l->size;
            _v40 = 1;
             *__esp = _t185;
            fwrite();
            if(_t185 < l->size) {
                goto L26;
            }
            _t189 = l->propBuf;
            _v32 = cache;
            _v36 = l->size;
            _v40 = 2;
             *__esp = _t189;
            fwrite();
            if(_t189 < l->size) {
                goto L26;
            }
            goto L17;
        }
         *__esp = cache;
        fclose();
        return 0;
    }
    return -1;
}

int readBufferCache(Buffer* buf)
{// addr = 0x08073FE8  --  defined in 'buffer.c' at line 694
    FILE* cache;          // _cfa_fffffff0
    Line* l;              // _cfa_ffffffec
    Line* prevl;          // _cfa_ffffffe8
    Line* basel;          // _cfa_ffffffe4
    long int lnum;                         // _cfa_ffffffe0
    long int clnum;                        // _cfa_ffffffdc
    long int tlnum;                        // _cfa_ffffffd8
    int colorflag;                         // _cfa_ffffffd4
    FILE* _v48;           // _cfa_ffffffd0
    int _v52;                              // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    FILE* _t178;          // _t178

    l = 0;
    prevl = 0;
    basel = 0;
    lnum = 0;
    if(buf->savecache == 0) {
        return -1;
    }
    __edx = 135048246;
    _t178 = buf->savecache;
    _v56 = 135048246;
     *__esp = _t178;
    fopen();
    cache = _t178;
    if(cache == 0) {
L5:
        buf->savecache = 0;
        return -1;
    } else {
        _v48 = cache;
        _v52 = 1;
        _v56 = 4;
         *__esp =  &clnum;
        fread();
        if( &clnum == 0) {
            goto L5;
        }
        _v48 = cache;
        _v52 = 1;
        _v56 = 4;
         *__esp =  &tlnum;
        fread();
        if( &tlnum != 0) {
            while(1) {
                __eax = cache;
                 *__esp = __eax;
                feof();
                if(__eax != 0) {
                    break;
                }
                lnum = lnum + 1;
                __eax = l;
                prevl = __eax;
                 *__esp = 52;
                GC_malloc();
                l = __eax;
                __eax = l;
                __edx = prevl;
                l->prev = prevl;
                if(prevl == 0) {
                    __eax = buf;
                    __edx = l;
                    buf->firstLine = l;
                } else {
                    __eax = prevl;
                    __edx = l;
                    prevl->next = l;
                }
                __eax = l;
                __edx = lnum;
                l->linenumber = lnum;
                __eax = clnum;
                if(lnum == clnum) {
                    __eax = buf;
                    __edx = l;
                    buf->currentLine = l;
                }
                __eax = tlnum;
                if(lnum == tlnum) {
                    __eax = buf;
                    __edx = l;
                    buf->topLine = l;
                }
                __eax = l;
                __edx =  &(l->real_linenumber);
                __eax = cache;
                _v48 = __eax;
                _v52 = 1;
                _v56 = 4;
                 *__esp =  &(l->real_linenumber);
                fread();
                if(__eax == 0) {
L35:
                    __eax = buf;
                    __edx = prevl;
                    buf->lastLine = prevl;
                    buf = buf->lastLine;
                    buf->lastLine->next = 0;
                    __eax = cache;
                     *__esp = cache;
                    fclose();
                    buf = buf->savecache;
                     *__esp = buf->savecache;
                    unlink();
                    __eax = buf;
                    buf->savecache = 0;
                    __eax = 0;
                    return 0;
                } else {
                    __eax = l;
                    __edx =  &(l->usrflags);
                    __eax = cache;
                    _v48 = __eax;
                    _v52 = 1;
                    _v56 = 2;
                     *__esp =  &(l->usrflags);
                    fread();
                    if(__eax == 0) {
                        goto L35;
                    }
                    __eax = l;
                    __edx =  &(l->width);
                    __eax = cache;
                    _v48 = __eax;
                    _v52 = 1;
                    _v56 = 4;
                     *__esp =  &(l->width);
                    fread();
                    if(__eax == 0) {
                        goto L35;
                    }
                    __eax = l;
                    __edx =  &(l->len);
                    __eax = cache;
                    _v48 = __eax;
                    _v52 = 1;
                    _v56 = 4;
                     *__esp =  &(l->len);
                    fread();
                    if(__eax == 0) {
                        goto L35;
                    }
                    __eax = l;
                    __edx =  &(l->size);
                    __eax = cache;
                    _v48 = __eax;
                    _v52 = 1;
                    _v56 = 4;
                     *__esp =  &(l->size);
                    fread();
                    if(__eax == 0) {
                        goto L35;
                    }
                    __eax = l;
                    __edx =  &(l->bpos);
                    __eax = cache;
                    _v48 = __eax;
                    _v52 = 1;
                    _v56 = 4;
                     *__esp =  &(l->bpos);
                    fread();
                    if(__eax == 0) {
                        goto L35;
                    }
                    __eax = l;
                    __edx =  &(l->bwidth);
                    __eax = cache;
                    _v48 = __eax;
                    _v52 = 1;
                    _v56 = 4;
                     *__esp =  &(l->bwidth);
                    fread();
                    if(__eax == 0) {
                        goto L35;
                    }
                    l = l->bpos;
                    if(l->bpos != 0) {
                        if(basel == 0) {
                            goto L35;
                        }
                        __eax = basel;
                        __edx = basel->lineBuf;
                        l = l->bpos;
                        __edx = basel->lineBuf + l->bpos;
                        __eax = l;
                        l->lineBuf = basel->lineBuf + l->bpos;
                        __eax = basel;
                        __edx = basel->propBuf;
                        __eax = l;
                        __eax = l->bpos;
                        __eax = l->bpos + l->bpos;
                        __edx = basel->propBuf + l->bpos + l->bpos;
                        __eax = l;
                        l->propBuf = basel->propBuf + l->bpos + l->bpos;
L24:
                        __eax = cache;
                        _v48 = cache;
                        _v52 = 1;
                        _v56 = 4;
                        __eax =  &colorflag;
                         *__esp =  &colorflag;
                        fread();
                        if( &colorflag == 0) {
                            goto L35;
                        }
                        __eax = colorflag;
                        if(colorflag == 0) {
                            __eax = l;
                            l->colorBuf = 0;
                        } else {
                            l = l->bpos;
                            if(l->bpos != 0) {
                                __eax = basel;
                                __edx = basel->colorBuf;
                                l = l->bpos;
                                __edx = basel->colorBuf + l->bpos;
                                __eax = l;
                                l->colorBuf = basel->colorBuf + l->bpos;
                            } else {
                                __eax = l;
                                __eax = l->size;
                                 *__esp = __eax;
                                GC_malloc_atomic();
                                __edx = __eax;
                                __eax = l;
                                l->colorBuf = __edx;
                                l = l->size;
                                __edx = l->size;
                                l = l->colorBuf;
                                _v48 = cache;
                                _v52 = l->size;
                                _v56 = 1;
                                 *__esp = l->colorBuf;
                                fread();
                            }
                        }
                        continue;
                    }
                    __eax = l;
                    basel = l;
                    l = l->size;
                    __eax =  &(l->size->lineBuf);
                     *__esp = __eax;
                    GC_malloc_atomic();
                    __edx = __eax;
                    __eax = l;
                    l->lineBuf = __edx;
                    l = l->size;
                    __edx = l->size;
                    l = l->lineBuf;
                    _v48 = cache;
                    _v52 = l->size;
                    _v56 = 1;
                     *__esp = l->lineBuf;
                    fread();
                    __eax = l;
                    __edx = l->lineBuf;
                    l = l->size;
                    __eax = l->lineBuf + l->size;
                     *(l->lineBuf + l->size) = 0;
                    __eax = l;
                    __eax = l->size;
                    __eax = l->size + l->size;
                     *__esp = __eax;
                    GC_malloc_atomic();
                    __edx = __eax;
                    __eax = l;
                    l->propBuf = __edx;
                    l = l->size;
                    __edx = l->size;
                    l = l->propBuf;
                    _v48 = cache;
                    _v52 = l->size;
                    _v56 = 2;
                     *__esp = l->propBuf;
                    fread();
                    goto L24;
                }
            }
            goto L35;
        }
        goto L5;
    }
}

void effect_anchor_start()
{// addr = 0x08074428  --  defined in 'display.c' at line 73
    if(useColor == 0) {
        underline();
        return;
    }
    setfcolor(anchor_color);
}

void effect_anchor_end()
{// addr = 0x0807444D  --  defined in 'display.c' at line 73
    if(useColor == 0) {
        underlineend();
        return;
    }
    setfcolor(basic_color);
}

void effect_image_start()
{// addr = 0x08074472  --  defined in 'display.c' at line 75
    if(useColor == 0) {
        standout();
        return;
    }
    setfcolor(image_color);
}

void effect_image_end()
{// addr = 0x08074497  --  defined in 'display.c' at line 75
    if(useColor == 0) {
        standend();
        return;
    }
    setfcolor(basic_color);
}

void effect_form_start()
{// addr = 0x080744BC  --  defined in 'display.c' at line 77
    if(useColor == 0) {
        standout();
        return;
    }
    setfcolor(form_color);
}

void effect_form_end()
{// addr = 0x080744E1  --  defined in 'display.c' at line 77
    if(useColor == 0) {
        standend();
        return;
    }
    setfcolor(basic_color);
}

void effect_mark_start()
{// addr = 0x08074506  --  defined in 'display.c' at line 79
    if(useColor == 0) {
        standout();
        return;
    }
    setbcolor(mark_color);
}

void effect_mark_end()
{// addr = 0x0807452B  --  defined in 'display.c' at line 79
    if(useColor == 0) {
        standend();
        return;
    }
    setbcolor(bg_color);
}

void effect_active_start()
{// addr = 0x08074550  --  defined in 'display.c' at line 84
    if(useColor == 0) {
        bold();
        return;
    }
    if(useActiveColor == 0) {
        underline();
        return;
    }
    setfcolor(active_color);
    underline();
}

void effect_active_end()
{// addr = 0x0807458A  --  defined in 'display.c' at line 105
    if(useColor == 0) {
        boldend();
        return;
    }
    if(useActiveColor == 0) {
        underlineend();
        return;
    }
    setfcolor(basic_color);
    underlineend();
}

void effect_visited_start()
{// addr = 0x080745C4  --  defined in 'display.c' at line 119
    if(useVisitedColor == 0 || useColor == 0) {
        return;
    } else {
        setfcolor(visited_color);
        return;
    }
}

void effect_visited_end()
{// addr = 0x080745EB  --  defined in 'display.c' at line 131
    if(useVisitedColor == 0 || useColor == 0) {
        return;
    } else {
        setfcolor(basic_color);
        return;
    }
}

void fmTerm()
{// addr = 0x08074612  --  defined in 'display.c' at line 160
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if((fmInitialized & 255) != 0) {
        move(LINES - 1, 0);
        clrtoeolx();
        refresh();
        if(activeImage != 0) {
            loadImage(0, 1);
        }
        if(use_mouse != 0) {
            mouse_end();
        }
        reset_tty();
        fmInitialized = 0;
        return;
    }
}

void fmInit()
{// addr = 0x0807467E  --  defined in 'display.c' at line 184
    if((fmInitialized & 255) == 0) {
        initscr();
        term_raw();
        term_noecho();
        if(displayImage != 0) {
            initImage();
        }
    }
    fmInitialized = 1;
}

Str make_lastline_link(Buffer* buf, char* title, char* url)
{// addr = 0x080746B5  --  defined in 'display.c' at line 233
    Str s;                 // _cfa_fffffff0
    Str u;                 // _cfa_ffffffec
    Lineprop* pr;     // _cfa_ffffffe8
    char* p;                               // _cfa_ffffffe4
    int l;                                 // _cfa_ffffffe0
    int i;                                 // _cfa_ffffffdc
    ParsedURL pu;    // _cfa_ffffffb4
    Linecolor** _v80;   // _cfa_ffffffb0
    intOrPtr _v84;                         // _cfa_ffffffac (outparam)
    char* _v88;                            // _cfa_ffffffa8 (outparam)
    _unknown_ __esi;                       // r5
    int _t119;                             // _t119

    s = 0;
    l = COLS - 1;
    if(title == 0) {
L12:
        if(url != 0) {
            parseURL2(url,  &pu, baseURL(buf));
            u = parsedURL2Str( &pu);
            if(DecodeURL != 0) {
                u = Strnew_charp(url_unquote_conv(u->ptr, buf->document_charset));
            }
            u = checkType(u,  &pr, 0);
            if(l <= 4 || wtf_strwidth(u->ptr) <= l) {
                if(s != 0) {
                    Strcat(s, u);
                    return s;
                }
                return u;
            } else {
                if(s == 0) {
                    s = Strnew_size(COLS);
                }
                i = (l - 2 >> 31) + l - 2 >> 1;
                while(i != 0 && ( *(pr + i + i) & 0x400) != 0) {
                    i = i - 1;
                }
                Strcat_charp_n(s, u->ptr, i);
                Strcat_charp(s, 135048254);
                _t119 = wtf_strwidth(u->ptr);
                i = _t119 + wtf_strwidth(s->ptr) + 1 - COLS;
                while(u->length > i && ( *(pr + i + i) & 0x400) != 0) {
                    i = i + 1;
                }
                Strcat_charp(s,  &(u->ptr[i]));
                return s;
            }
        }
        return s;
    }
    if(( *title & 255) == 0) {
        goto L12;
    } else {
        _v80 = 0;
        _v84 = 135048248;
        _v88 = title;
        s = Strnew_m_charp(135048250);
        p = s->ptr;
        while(( *p & 255) != 0) {
            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 1) != 0 || ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                 *p = 32;
            }
            p =  &(p[1]);
        }
        if(url != 0) {
            Strcat_charp(s, 135048252);
        }
        l = l - wtf_strwidth(s->ptr);
        if(l > 0) {
            goto L12;
        }
        return s;
    }
}

Str make_lastline_message(Buffer* buf)
{// addr = 0x0807495D  --  defined in 'display.c' at line 289
    Str msg;               // _cfa_fffffff0
    Str s;                 // _cfa_ffffffec
    int sl;                                // _cfa_ffffffe8
    MapArea* a;        // _cfa_ffffffe4
    Anchor* a;          // _cfa_ffffffe0
    char* p;                               // _cfa_ffffffdc
    Anchor* a_img;      // _cfa_ffffffd8
    int cl;                                // _cfa_ffffffd4
    int ll;                                // _cfa_ffffffd0
    int r;                                 // _cfa_ffffffcc
    int l;                                 // _cfa_ffffffc8
    char* p;                               // _cfa_ffffffc4
    _unknown_ _v62;                        // _cfa_ffffffc2
    short _v64;                            // _cfa_ffffffc0
    int _v80;                              // _cfa_ffffffb0
    int _v84;                              // _cfa_ffffffac (outparam)
    int _v88;                              // _cfa_ffffffa8 (outparam)
    signed int _t144;                      // _t144
    char* _t185;                           // _t185

    s = 0;
    sl = 0;
    if(displayLink == 0) {
L20:
        if(use_mouse == 0 ||  *135792260 == 0) {
            msg = Strnew();
        } else {
            msg = Strnew_charp( *135792260);
        }
        if(displayLineInfo == 0 || buf->currentLine == 0 || buf->lastLine == 0) {
            Strcat_charp(msg, "Viewing");
        } else {
            cl = buf->currentLine->real_linenumber;
            ll = buf->lastLine->real_linenumber;
            asm("fild dword [ebp-0x28]");
            asm("fmulp st1, st0");
            if(ll == 0) {
                asm("fld1");
            } else {
                asm("fild dword [ebp-0x2c]");
            }
            asm("fdivp st1, st0");
            asm("faddp st1, st0");
            asm("fnstcw word [ebp-0x3a]");
            _v64 = 12;
            asm("fldcw word [ebp-0x3c]");
            asm("fistp dword [ebp-0x30]");
            asm("fldcw word [ebp-0x3a]");
            _v80 = r;
            _v84 = ll;
            _v88 = cl;
            Strcat(msg, Sprintf("%d/%d (%d%%)"));
        }
        Strcat_charp(msg, " <");
        Strcat_charp(msg, buf->buffername);
        if(s == 0) {
            Strcat_charp(msg, 135048284);
            goto L46;
        } else {
            l = COLS - 3 - sl;
            if(wtf_strwidth(msg->ptr) <= l) {
L44:
                Strcat_charp(msg, "> ");
                Strcat(msg, s);
L46:
                return msg;
            }
            p = msg->ptr;
            while(( *p & 255) != 0) {
                if(( *135119023 & 255) == 0) {
                    _t144 = ( *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 255) != 0 & 255;
                } else {
                    _t144 =  *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 0xff;
                }
                l = l - _t144;
                if(l < 0) {
L43:
                    l = p - msg->ptr;
                    Strtruncate(msg, l);
                    goto L44;
                } else {
                    p =  &(p[ *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff]);
                    continue;
                }
            }
            goto L43;
        }
    }
    a = retrieveCurrentMapArea(buf);
    if(a == 0) {
        a = retrieveCurrentAnchor(buf);
        p = 0;
        if(a == 0 || a->title == 0) {
L7:
            a_img = retrieveCurrentImg(buf);
            if(a_img != 0 && a_img->title != 0) {
                if((a_img & 255) != 0) {
                    p = a_img->title;
                }
            }
            goto L11;
        } else {
            if((a & 255) == 0) {
                goto L7;
            } else {
                p = a->title;
L11:
                if(p != 0 || a != 0) {
                    if(a == 0) {
                        _t185 = 0;
                    } else {
                        _t185 = a->url;
                    }
                    s = make_lastline_link(buf, p, _t185);
                }
                goto L17;
            }
        }
    } else {
        s = make_lastline_link(buf, a->alt, a->url);
L17:
        if(s != 0) {
            sl = wtf_strwidth(s->ptr);
            if(COLS - 3 > sl) {
                goto L20;
            } else {
                return s;
            }
        }
        goto L20;
    }
}

void displayBuffer(Buffer* buf, int mode)
{// addr = 0x08074C9B  --  defined in 'display.c' at line 367
    Str msg;               // _cfa_fffffff0
    int ny;                                // _cfa_ffffffec
    long int _v32;                         // _cfa_ffffffe0
    _unknown_ _v34;                        // _cfa_ffffffde
    short _v36;                            // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t139;                             // _t139
    _unknown_ _t140;                       // _t140
    int _t264;                             // _t264
    _unknown_ _t265;                       // _t265
    int _t275;                             // _t275
    signed int _t282;                      // _t282
    int _t301;                             // _t301

    ny = 0;
    if(buf == 0) {
        goto L64;
    } else {
        if(buf->topLine == 0) {
            if(readBufferCache(buf) == 0) {
                mode = 1;
            }
        }
        if((buf->width & 65535) == 0) {
            _t301 = COLS;
            if(showLineNum == 0) {
                _t264 = 1;
            } else {
                _t264 = 6;
            }
            _t265 = _t301 - _t264;
            _t266 = _t265 < 0 ? 0 : _t265;
            _t303 = _t265 < 0 ? 0 : _t265;
            buf->width = _t265 < 0 ? 0 : _t265;
        }
        if((buf->height & 65535) == 0) {
            buf->height = LINES;
        }
        _t282 = buf->width & 65535;
        _t275 = COLS;
        if(showLineNum == 0) {
            _t139 = 1;
        } else {
            _t139 = 6;
        }
        _t140 = _t275 - _t139;
        _t141 = _t140 < 0 ? 0 : _t140;
        _t313 = _t282 - (_t140 < 0 ? 0 : _t140);
        if(_t282 == (_t140 < 0 ? 0 : _t140) || is_html_type(buf->type) == 0 && FoldLine == 0) {
            if((buf->need_reshape & 255) == 0) {
                goto L19;
            }
            goto L18;
        } else {
L18:
            buf->need_reshape = 1;
            reshapeBuffer(buf);
L19:
            if(showLineNum == 0) {
                buf->rootX = 0;
                goto L28;
            } else {
                if(buf->lastLine != 0 && buf->lastLine->real_linenumber > 0) {
                    _v32 = buf->lastLine->real_linenumber;
                    asm("fild dword [ebp-0x1c]");
                    asm("faddp st1, st0");
                     *__esp =  *135048552;
                    log();
                    asm("fdivp st1, st0");
                    asm("fnstcw word [ebp-0x1e]");
                    _v36 = 12;
                    asm("fldcw word [ebp-0x20]");
                    asm("fistp dword [ebp-0x1c]");
                    asm("fldcw word [ebp-0x1e]");
                    buf->rootX = _v32 + 2;
                }
                if((buf->rootX & 65535) <= 4) {
                    buf->rootX = 5;
                }
                if((buf->rootX & 65535) > COLS) {
                    buf->rootX = COLS;
                }
L28:
                buf->COLS = COLS - (buf->rootX & 65535);
                if(nTab > 1 || mouse_action.menu_str != 0) {
                    if(mode == 1 || mode == 4) {
                        calcTabPos();
                    }
                    ny = (LastTab->y & 65535) + 2;
                    if(LINES - 1 < ny) {
                        ny = LINES - 1;
                    }
                }
                if((buf->rootY & 65535) != ny || (buf->LINES & 65535) != LINES - 1 - ny) {
                    buf->rootY = ny;
                    buf->LINES = LINES - ny - 1;
                    arrangeCursor(buf);
                    mode = 4;
                }
                if(mode == 1 || mode == 3 || mode == 4 || buf->topLine != cline || buf->currentColumn != ccolumn) {
                    if(activeImage != 0 && (mode == 4 || buf->topLine != cline || buf->currentColumn != ccolumn)) {
                        if(draw_image_flag != 0) {
                            clear();
                        }
                        clearImage();
                        loadImage(buf, 1);
                        image_touch = image_touch + 1;
                        draw_image_flag = 0;
                    }
                    redrawNLine(buf, LINES - 1);
                    cline = buf->topLine;
                    ccolumn = buf->currentColumn;
                }
                if(buf->topLine == 0) {
                    buf->topLine = buf->firstLine;
                }
                if((buf->need_reshape & 255) == 0) {
                    drawAnchorCursor(buf);
                    msg = make_lastline_message(buf);
                    if(buf->firstLine == 0) {
                        Strcat_charp(msg, "\tNo Line");
                    }
                    if(delayed_msg != 0) {
                        disp_message(delayed_msg, 0);
                        delayed_msg = 0;
                        refresh();
                    }
                    standout();
                    message(msg->ptr, (buf->cursorX & 65535) + (buf->rootX & 65535), (buf->cursorY & 65535) + (buf->rootY & 65535));
                    standend();
                    term_title( *(wc_Str_conv_strict(Strnew_charp(buf->buffername), InnerCharset, SystemCharset)));
                    refresh();
                    if(activeImage == 0 || displayImage == 0 || buf->img == 0) {
L64:
                        return;
                    } else {
                        drawImage();
                        return;
                    }
                } else {
                    displayBuffer(buf, 1);
                    return;
                }
            }
        }
    }
}

void drawAnchorCursor0(Buffer* buf, AnchorList* al, int hseq, int prevhseq, int tline, int eline, int active)
{// addr = 0x08075138  --  defined in 'display.c' at line 503
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    Line* l;              // _cfa_ffffffe8
    Anchor* an;         // _cfa_ffffffe4
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1

    l = buf->topLine;
    j = 0;
    while(al->nanchor > j) {
        an = al->anchors + (j << 2 << 4) - (j << 2);
        if(an->start < tline) {
L24:
            j = j + 1;
            continue;
        }
        if(an->start >= eline) {
            return;
        }
        while(l != 0) {
            if(l->linenumber != an->start) {
                l = l->next;
                continue;
            }
            if(hseq >= 0) {
                if(an->hseq != hseq) {
                    goto L18;
                } else {
                    i = an->start.pos;
                    while(an->end.pos > i) {
                        if(( *(l->propBuf + i + i) & 0x70) != 0) {
                            if(active == 0) {
                                 *(l->propBuf + i + i) =  *(l->propBuf + i + i) & 0x7f;
                            } else {
                                 *(l->propBuf + i + i) =  *(l->propBuf + i + i) & 65535 | 128;
                            }
                        }
                        i = i + 1;
                    }
                    if(active != 0) {
                        redrawLineRegion(buf, l, l->linenumber - tline + (buf->rootY & 65535), an->start.pos, an->end.pos);
                    }
                    goto L24;
                }
            } else {
L18:
                if(prevhseq >= 0 && an->hseq == prevhseq && active != 0) {
                    redrawLineRegion(buf, l, l->linenumber - tline + (buf->rootY & 65535), an->start.pos, an->end.pos);
                }
                goto L24;
            }
        }
        return;
    }
}

void drawAnchorCursor(Buffer* buf)
{// addr = 0x0807531B  --  defined in 'display.c' at line 545
    Anchor* an;         // _cfa_fffffff0
    int hseq;                              // _cfa_ffffffec
    int prevhseq;                          // _cfa_ffffffe8
    int tline;                             // _cfa_ffffffe4
    int eline;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)

    if(buf->firstLine == 0) {
        return;
    }
    if(buf->hmarklist == 0) {
        return;
    }
    if(buf->href != 0 || buf->formitem != 0) {
        an = retrieveCurrentAnchor(buf);
        if(an == 0) {
            an = retrieveCurrentMap(buf);
        }
        if(an == 0) {
            hseq = -1;
        } else {
            hseq = an->hseq;
        }
        tline = buf->topLine->linenumber;
        eline = (buf->LINES & 65535) + tline;
        prevhseq = buf->hmarklist->prevhseq;
        if(buf->href != 0) {
            drawAnchorCursor0(buf, buf->href, hseq, prevhseq, tline, eline, 1);
            drawAnchorCursor0(buf, buf->href, hseq, -1, tline, eline, 0);
        }
        if(buf->formitem != 0) {
            drawAnchorCursor0(buf, buf->formitem, hseq, prevhseq, tline, eline, 1);
            drawAnchorCursor0(buf, buf->formitem, hseq, -1, tline, eline, 0);
        }
        buf->hmarklist->prevhseq = hseq;
        return;
    }
}

void redrawNLine(Buffer* buf, int n)
{// addr = 0x080754C6  --  defined in 'display.c' at line 579
    Line* l;              // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    TabBuffer* t;    // _cfa_ffffffe8
    int l;                                 // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(useColor != 0) {
        setfcolor(basic_color);
        setbcolor(bg_color);
    }
    if(nTab > 1 || mouse_action.menu_str != 0) {
        move(0, 0);
        if(mouse_action.menu_str != 0) {
            addstr(mouse_action.menu_str);
        }
        clrtoeolx();
        t = FirstTab;
        while(t != 0) {
            move(t->y & 65535, t->x1 & 65535);
            if(t == CurrentTab) {
                bold();
            }
            addch(91);
            l = (t->x2 & 65535) - (t->x1 & 65535) - 1 - wtf_strwidth( *(t->currentBuffer + 4));
            if(l < 0) {
                l = 0;
            }
            if(l > 1) {
                addnstr_sup(135048252, (l >> 31) + l >> 1);
            }
            if(t == CurrentTab) {
                effect_active_start();
            }
            addnstr( *(t->currentBuffer + 4), (t->x2 & 65535) - (t->x1 & 65535) - l);
            if(t == CurrentTab) {
                effect_active_end();
            }
            if(l + 1 > 1) {
                addnstr_sup(135048252, (l + 1 >> 31) + l + 1 >> 1);
            }
            move(t->y & 65535, t->x2 & 65535);
            addch(93);
            if(t == CurrentTab) {
                boldend();
            }
            t = t->nextTab;
        }
        move((LastTab->y & 65535) + 1, 0);
        i = 0;
        while(i < COLS) {
            addch(126);
            i = i + 1;
        }
        goto L26;
    } else {
L26:
        i = 0;
        l = buf->topLine;
        while((buf->LINES & 65535) > i) {
            if((buf->LINES & 65535) - n <= i ||  ~n > i) {
                l = redrawLine(buf, l, (buf->rootY & 65535) + i);
            }
            if(l == 0) {
L35:
                if(n > 0) {
                    move((buf->rootY & 65535) + i, 0);
                    clrtobotx();
                }
                if(activeImage == 0) {
                    return;
                } else {
                    if(displayImage == 0) {
                        return;
                    }
                    if(buf->img == 0) {
                        return;
                    }
                    move((buf->cursorY & 65535) + (buf->rootY & 65535), (buf->cursorX & 65535) + (buf->rootX & 65535));
                    i = 0;
                    l = buf->topLine;
                    while((buf->LINES & 65535) > i && l != 0) {
                        if((buf->LINES & 65535) - n <= i ||  ~n > i) {
                            redrawLineImage(buf, l, (buf->rootY & 65535) + i);
                        }
                        i = i + 1;
                        l = l->next;
                    }
                    getAllImage(buf);
                    return;
                }
            } else {
                i = i + 1;
                l = l->next;
                continue;
            }
        }
        goto L35;
    }
}

Line* redrawLine(Buffer* buf, Line* l, int i)
{// addr = 0x08075864  --  defined in 'display.c' at line 660
    signed int _v16;                       // _cfa_fffffff0
    char[15] tmp;                          // _cfa_ffffffe0
    int j;                                 // _cfa_ffffffdc
    int pos;                               // _cfa_ffffffd8
    int rcol;                              // _cfa_ffffffd4
    int ncol;                              // _cfa_ffffffd0
    int delta;                             // _cfa_ffffffcc
    int column;                            // _cfa_ffffffc8
    char* p;                               // _cfa_ffffffc4
    Lineprop* pr;     // _cfa_ffffffc0
    Linecolor* pc;   // _cfa_ffffffbc
    Anchor* a;          // _cfa_ffffffb8
    int k;                                 // _cfa_ffffffb4
    int vpos;                              // _cfa_ffffffb0
    ParsedURL url;   // _cfa_ffffff88
    Buffer* _v128;      // _cfa_ffffff80
    Line* _v132;          // _cfa_ffffff7c
    _unknown_ _v136;                       // _cfa_ffffff78
    _unknown_ _v138;                       // _cfa_ffffff76
    _unknown_ _v140;                       // _cfa_ffffff74
    _unknown_ _v152;                       // _cfa_ffffff68 (outparam)
    _unknown_ _v156;                       // _cfa_ffffff64 (outparam)
    long int _v160;                        // _cfa_ffffff60 (outparam)
    signed int _v164;                      // _cfa_ffffff5c (outparam)
    char* _v168;                           // _cfa_ffffff58 (outparam)
    _unknown_ __ebx;                       // r1
    Line* _t257;          // _t257

    _v128 = buf;
    _v132 = l;
    _v16 =  *gs:0x14];
    delta = 1;
    column = _v128->currentColumn;
    vpos = -1;
    if(_v132 != 0) {
L5:
        move(i, 0);
        if(showLineNum != 0) {
            if((_v128->rootX & 65535) == 0) {
                if((_v128->rootX & 65535) <= 4) {
                    _v128->rootX = 5;
                }
                if((_v128->rootX & 65535) > COLS) {
                    _v128->rootX = COLS;
                }
                _v128->COLS = COLS - (_v128->rootX & 65535);
            }
            if(_v132->real_linenumber == 0 || _v132->bpos != 0) {
                _v160 = 135048306;
                _v164 = (_v128->rootX & 65535) - 1;
                _v168 = "%*s ";
                 *__esp =  &tmp;
                sprintf();
            } else {
                _v160 = _v132->real_linenumber;
                _v164 = (_v128->rootX & 65535) - 1;
                _v168 = "%*ld:";
                 *__esp =  &tmp;
                sprintf();
            }
            addstr( &tmp);
        }
        move(i, _v128->rootX & 65535);
        if(_v132->width < 0) {
            _v132->width = calcPosition( *_v132, _v132->propBuf, _v132->len, _v132->len, 0, 0);
        }
        if(_v132->len == 0 || _v132->width - 1 < column) {
            clrtoeolx();
            _t257 = _v132;
            goto L85;
        } else {
            pos = columnPos(_v132, column);
            p =  *_v132 + pos;
            pr = _v132->propBuf + pos + pos;
            if(useColor == 0 || _v132->colorBuf == 0) {
                pc = 0;
            } else {
                pc = _v132->colorBuf + pos;
            }
            rcol = calcPosition( *_v132, _v132->propBuf, _v132->len, pos, 0, 0);
            j = 0;
            while(rcol - column < (_v128->COLS & 65535)) {
                if(pos + j < _v132->len) {
                    if(useVisitedColor == 0 || pos + j < vpos || ( *(pr + j + j) & 0x4000) != 0) {
L38:
                        delta = wtf_len( &(p[j]));
                        ncol = calcPosition( *_v132, _v132->propBuf, _v132->len, pos + j + delta, 0, 0);
                        if(ncol - column > (_v128->COLS & 65535)) {
                            break;
                        }
                        if(pc != 0) {
                            do_color( *(pc + j) & 0xff);
                        }
                        if(rcol >= column) {
                            if((p[j] & 255) != 9) {
                                addMChar( &(p[j]),  *(pr + j + j) & 0xffff, delta);
L52:
                                rcol = ncol;
                                goto L53;
                            }
                            while(rcol < ncol) {
                                addChar(32, 0);
                                rcol = rcol + 1;
                            }
                            goto L52;
                        } else {
                            rcol = column;
                            while(rcol < ncol) {
                                addChar(32, 0);
                                rcol = rcol + 1;
                            }
L53:
                            j = j + delta;
                            continue;
                        }
                    } else {
                        a = retrieveAnchor(_v128->href, _v132->linenumber, pos + j);
                        if(a == 0) {
                            goto L38;
                        }
                        parseURL2(a->url,  &url, baseURL(_v128));
                        if(getHashHist(URLHist,  *(parsedURL2Str( &url))) == 0) {
L37:
                            vpos = a->end.pos;
                            goto L38;
                        }
                        k = a->start.pos;
                        while(a->end.pos > k) {
                             *(pr + k - pos + k - pos) =  *(pr + k - pos + k - pos) & 65535 | 64;
                            k = k + 1;
                        }
                        goto L37;
                    }
                }
                break;
            }
            if(somode != 0) {
                somode = 0;
                standend();
            }
            if(ulmode != 0) {
                ulmode = 0;
                underlineend();
            }
            if(bomode != 0) {
                bomode = 0;
                boldend();
            }
            if(emph_mode != 0) {
                emph_mode = 0;
                boldend();
            }
            if(anch_mode != 0) {
                anch_mode = 0;
                effect_anchor_end();
            }
            if(imag_mode != 0) {
                imag_mode = 0;
                effect_image_end();
            }
            if(form_mode != 0) {
                form_mode = 0;
                effect_form_end();
            }
            if(visited_mode != 0) {
                visited_mode = 0;
                effect_visited_end();
            }
            if(active_mode != 0) {
                active_mode = 0;
                effect_active_end();
            }
            if(mark_mode != 0) {
                mark_mode = 0;
                effect_mark_end();
            }
            if(graph_mode != 0) {
                graph_mode = 0;
                graphend();
            }
            if((color_mode & 255) != 0) {
                do_color(0);
            }
            if(rcol - column < (_v128->COLS & 65535)) {
                clrtoeolx();
            }
            _t257 = _v132;
L85:
            if((_v16 ^  *gs:0x14]) == 0) {
                return _t257;
            }
            __stack_chk_fail();
            return _t257;
        }
    }
    if(_v128->pagerSource == 0) {
        _t257 = 0;
        goto L85;
    }
    _v132 = getNextPage(_v128, (_v128->LINES & 65535) + (_v128->rootY & 65535) - i);
    if(_v132 != 0) {
        goto L5;
    } else {
        _t257 = 0;
        goto L85;
    }
}

Line* redrawLineImage(Buffer* buf, Line* l, int i)
{// addr = 0x08075F31  --  defined in 'display.c' at line 820
    int j;                                 // _cfa_fffffff0
    int pos;                               // _cfa_ffffffec
    int rcol;                              // _cfa_ffffffe8
    int column;                            // _cfa_ffffffe4
    Anchor* a;          // _cfa_ffffffe0
    int x;                                 // _cfa_ffffffdc
    int y;                                 // _cfa_ffffffd8
    int sx;                                // _cfa_ffffffd4
    int sy;                                // _cfa_ffffffd0
    int w;                                 // _cfa_ffffffcc
    int h;                                 // _cfa_ffffffc8
    Image* image;        // _cfa_ffffffc4
    ImageCache* cache;   // _cfa_ffffffc0
    intOrPtr _v80;                         // _cfa_ffffffb0
    _unknown_ _v82;                        // _cfa_ffffffae
    short _v84;                            // _cfa_ffffffac
    _unknown_ _v100;                       // _cfa_ffffff9c (outparam)
    _unknown_ _v104;                       // _cfa_ffffff98 (outparam)
    _unknown_ _v108;                       // _cfa_ffffff94 (outparam)
    _unknown_ _v112;                       // _cfa_ffffff90 (outparam)
    _unknown_ _v116;                       // _cfa_ffffff8c (outparam)
    _unknown_ _v120;                       // _cfa_ffffff88 (outparam)
    _unknown_ __ebx;                       // r1

    column = buf->currentColumn;
    if(l == 0) {
        return 0;
    }
    if(l->width < 0) {
        l->width = calcPosition(l->lineBuf, l->propBuf, l->len, l->len, 0, 0);
    }
    if(l->len == 0) {
L6:
        return l;
    }
    if(l->width - 1 >= column) {
        pos = columnPos(l, column);
        rcol = calcPosition(l->lineBuf, l->propBuf, l->len, pos, 0, 0);
        j = 0;
        while(rcol - column < (buf->COLS & 65535) && pos + j < l->len) {
            if(rcol - column >= 0) {
                a = retrieveAnchor(buf->img, l->linenumber, pos + j);
                if(a == 0 || a->image == 0 || a->image->touch >= image_touch) {
L38:
                    rcol = calcPosition(l->lineBuf, l->propBuf, l->len, pos + j + 1, 0, 0);
                    goto L39;
                } else {
                    image = a->image;
                    image->cache = getImage(image, baseURL(buf), buf->image_flag & 255);
                    cache = image->cache;
                    if(cache == 0) {
                        goto L38;
                    }
                    if((image->width & 65535) >= 0 || (cache->width & 65535) <= 0) {
                        if((image->height & 65535) >= 0 || (cache->height & 65535) <= 0) {
                            goto L19;
                        } else {
                            goto L18;
                        }
                    } else {
L18:
                        image->width = cache->width & 65535;
                        image->height = cache->height & 65535;
                        buf->need_reshape = 1;
L19:
                        _v80 = rcol - column + (buf->rootX & 65535);
                        asm("fild dword [ebp-0x4c]");
                        asm("fmulp st1, st0");
                        asm("fnstcw word [ebp-0x4e]");
                        _v84 = 12;
                        asm("fldcw word [ebp-0x50]");
                        asm("fistp dword [ebp-0x20]");
                        asm("fldcw word [ebp-0x4e]");
                        asm("fild dword [ebp+0x10]");
                        asm("fmulp st1, st0");
                        asm("fldcw word [ebp-0x50]");
                        asm("fistp dword [ebp-0x24]");
                        asm("fldcw word [ebp-0x4e]");
                        _v80 = rcol - calcPosition(l->lineBuf, l->propBuf, l->len, a->start.pos, 0, 0);
                        asm("fild dword [ebp-0x4c]");
                        asm("fmulp st1, st0");
                        asm("fnstcw word [ebp-0x4e]");
                        _v84 = 12;
                        asm("fldcw word [ebp-0x50]");
                        asm("fistp dword [ebp-0x28]");
                        asm("fldcw word [ebp-0x4e]");
                        _v80 = l->linenumber - (image->y & 65535);
                        asm("fild dword [ebp-0x4c]");
                        asm("fmulp st1, st0");
                        asm("fldcw word [ebp-0x50]");
                        asm("fistp dword [ebp-0x2c]");
                        asm("fldcw word [ebp-0x4e]");
                        if(sx != 0 || (image->xoffset & 65535) + x < 0) {
                            sx = sx - (image->xoffset & 65535);
                        } else {
                            x = x + (image->xoffset & 65535);
                        }
                        if(sy != 0 || (image->yoffset & 65535) + y < 0) {
                            sy = sy - (image->yoffset & 65535);
                        } else {
                            y = y + (image->yoffset & 65535);
                        }
                        if((image->width & 65535) <= 0) {
                            asm("fmulp st1, st0");
                            asm("fild dword [ebp-0x28]");
                            asm("fsubp st1, st0");
                            asm("fldcw word [ebp-0x50]");
                            asm("fistp dword [ebp-0x30]");
                            asm("fldcw word [ebp-0x4e]");
                        } else {
                            w = (image->width & 65535) - sx;
                        }
                        if((image->height & 65535) <= 0) {
                            asm("fild dword [ebp-0x2c]");
                            asm("fsubp st1, st0");
                            asm("fldcw word [ebp-0x50]");
                            asm("fistp dword [ebp-0x34]");
                            asm("fldcw word [ebp-0x4e]");
                        } else {
                            h = (image->height & 65535) - sy;
                        }
                        _v80 = (buf->rootX & 65535) + (buf->COLS & 65535);
                        asm("fild dword [ebp-0x4c]");
                        asm("fmulp st1, st0");
                        asm("fild dword [ebp-0x20]");
                        asm("fsubp st1, st0");
                        asm("fldcw word [ebp-0x50]");
                        asm("fistp dword [ebp-0x4c]");
                        asm("fldcw word [ebp-0x4e]");
                        if(_v80 < w) {
                            _v80 = (buf->rootX & 65535) + (buf->COLS & 65535);
                            asm("fild dword [ebp-0x4c]");
                            asm("fmulp st1, st0");
                            asm("fild dword [ebp-0x20]");
                            asm("fsubp st1, st0");
                            asm("fldcw word [ebp-0x50]");
                            asm("fistp dword [ebp-0x30]");
                            asm("fldcw word [ebp-0x4e]");
                        }
                        _v80 = LINES - 1;
                        asm("fild dword [ebp-0x4c]");
                        asm("fmulp st1, st0");
                        asm("fild dword [ebp-0x24]");
                        asm("fsubp st1, st0");
                        asm("fldcw word [ebp-0x50]");
                        asm("fistp dword [ebp-0x4c]");
                        asm("fldcw word [ebp-0x4e]");
                        if(_v80 < h) {
                            _v80 = LINES - 1;
                            asm("fild dword [ebp-0x4c]");
                            asm("fmulp st1, st0");
                            asm("fild dword [ebp-0x24]");
                            asm("fsubp st1, st0");
                            asm("fldcw word [ebp-0x50]");
                            asm("fistp dword [ebp-0x34]");
                            asm("fldcw word [ebp-0x4e]");
                        }
                        addImage(cache, x, y, sx, sy, w, h);
                        image->touch = image_touch;
                        draw_image_flag = 1;
                        goto L38;
                    }
                }
            } else {
                rcol = calcPosition(l->lineBuf, l->propBuf, l->len, pos + j + 1, 0, 0);
L39:
                j = j + 1;
                continue;
            }
        }
        return l;
    }
    goto L6;
}

int redrawLineRegion(Buffer* buf, Line* l, int i, int bpos, int epos)
{// addr = 0x0807648A  --  defined in 'display.c' at line 890
    int j;                                 // _cfa_fffffff0
    int pos;                               // _cfa_ffffffec
    int rcol;                              // _cfa_ffffffe8
    int ncol;                              // _cfa_ffffffe4
    int delta;                             // _cfa_ffffffe0
    int column;                            // _cfa_ffffffdc
    char* p;                               // _cfa_ffffffd8
    Lineprop* pr;     // _cfa_ffffffd4
    Linecolor* pc;   // _cfa_ffffffd0
    int bcol;                              // _cfa_ffffffcc
    int ecol;                              // _cfa_ffffffc8
    Anchor* a;          // _cfa_ffffffc4
    int k;                                 // _cfa_ffffffc0
    int vpos;                              // _cfa_ffffffbc
    ParsedURL url;   // _cfa_ffffff94
    _unknown_ _v120;                       // _cfa_ffffff88 (outparam)
    _unknown_ _v124;                       // _cfa_ffffff84 (outparam)
    _unknown_ _v128;                       // _cfa_ffffff80 (outparam)
    _unknown_ _v132;                       // _cfa_ffffff7c (outparam)
    _unknown_ _v136;                       // _cfa_ffffff78 (outparam)
    _unknown_ __ebx;                       // r1

    delta = 1;
    column = buf->currentColumn;
    vpos = -1;
    if(l == 0) {
        return 0;
    }
    pos = columnPos(l, column);
    p = l->lineBuf + pos;
    pr = l->propBuf + pos + pos;
    if(useColor == 0 || l->colorBuf == 0) {
        pc = 0;
    } else {
        pc = l->colorBuf + pos;
    }
    rcol = calcPosition(l->lineBuf, l->propBuf, l->len, pos, 0, 0);
    bcol = bpos - pos;
    ecol = epos - pos;
    j = 0;
    while(rcol - column < (buf->COLS & 65535)) {
        if(pos + j < l->len) {
            if(useVisitedColor == 0 || pos + j < vpos || ( *(pr + j + j) & 0x4000) != 0) {
L16:
                delta = wtf_len( &(p[j]));
                ncol = calcPosition(l->lineBuf, l->propBuf, l->len, pos + j + delta, 0, 0);
                if(ncol - column > (buf->COLS & 65535)) {
                    break;
                }
                if(pc != 0) {
                    do_color( *(pc + j) & 0xff);
                }
                if(j < bcol || j >= ecol) {
L32:
                    rcol = ncol;
                    goto L33;
                } else {
                    if(rcol >= column) {
                        move(i, rcol - column + (buf->rootX & 65535));
                        if((p[j] & 255) != 9) {
                            addMChar( &(p[j]),  *(pr + j + j) & 0xffff, delta);
                            goto L32;
                        }
                        while(rcol < ncol) {
                            addChar(32, 0);
                            rcol = rcol + 1;
                        }
                        goto L32;
                    }
                    move(i, buf->rootX & 65535);
                    rcol = column;
                    while(rcol < ncol) {
                        addChar(32, 0);
                        rcol = rcol + 1;
                    }
L33:
                    j = j + delta;
                    continue;
                }
            } else {
                a = retrieveAnchor(buf->href, l->linenumber, pos + j);
                if(a == 0) {
                    goto L16;
                }
                parseURL2(a->url,  &url, baseURL(buf));
                if(getHashHist(URLHist,  *(parsedURL2Str( &url))) == 0) {
L15:
                    vpos = a->end.pos;
                    goto L16;
                }
                k = a->start.pos;
                while(a->end.pos > k) {
                     *(pr + k - pos + k - pos) =  *(pr + k - pos + k - pos) & 65535 | 64;
                    k = k + 1;
                }
                goto L15;
            }
        }
        break;
    }
    if(somode != 0) {
        somode = 0;
        standend();
    }
    if(ulmode != 0) {
        ulmode = 0;
        underlineend();
    }
    if(bomode != 0) {
        bomode = 0;
        boldend();
    }
    if(emph_mode != 0) {
        emph_mode = 0;
        boldend();
    }
    if(anch_mode != 0) {
        anch_mode = 0;
        effect_anchor_end();
    }
    if(imag_mode != 0) {
        imag_mode = 0;
        effect_image_end();
    }
    if(form_mode != 0) {
        form_mode = 0;
        effect_form_end();
    }
    if(visited_mode != 0) {
        visited_mode = 0;
        effect_visited_end();
    }
    if(active_mode != 0) {
        active_mode = 0;
        effect_active_end();
    }
    if(mark_mode != 0) {
        mark_mode = 0;
        effect_mark_end();
    }
    if(graph_mode != 0) {
        graph_mode = 0;
        graphend();
    }
    if((color_mode & 255) != 0) {
        do_color(0);
    }
    return rcol - column;
}

void do_effects(Lineprop m)
{// addr = 0x08076954  --  defined in 'display.c' at line 1033
    signed int _v16;                       // _cfa_fffffff0

    _v16 = m;
    if(ulmode != 0) {
        underlineend();
        ulmode = 0;
    }
    if(somode != 0) {
        standend();
        somode = 0;
    }
    if(bomode != 0) {
        boldend();
        bomode = 0;
    }
    if(emph_mode != 0) {
        boldend();
        emph_mode = 0;
    }
    if(anch_mode != 0) {
        effect_anchor_end();
        anch_mode = 0;
    }
    if(imag_mode != 0) {
        effect_image_end();
        imag_mode = 0;
    }
    if(form_mode != 0) {
        effect_form_end();
        form_mode = 0;
    }
    if(visited_mode != 0) {
        effect_visited_end();
        visited_mode = 0;
    }
    if(active_mode != 0) {
        effect_active_end();
        active_mode = 0;
    }
    if(mark_mode != 0) {
        effect_mark_end();
        mark_mode = 0;
    }
    if(graph_mode != 0) {
        graphend();
        graph_mode = 0;
    }
    if((_v16 & 2) != 0 && ulmode == 0) {
        underline();
        ulmode = 1;
    }
    if((_v16 & 4) != 0 && somode == 0) {
        standout();
        somode = 1;
    }
    if((_v16 & 8) != 0 && bomode == 0) {
        bold();
        bomode = 1;
    }
    if((_v16 & 8) != 0 && emph_mode == 0) {
        bold();
        emph_mode = 1;
    }
    if((_v16 & 0x10) != 0 && anch_mode == 0) {
        effect_anchor_start();
        anch_mode = 1;
    }
    if((_v16 & 0x20) != 0 && imag_mode == 0) {
        effect_image_start();
        imag_mode = 1;
    }
    if((_v16 & 0x40) != 0 && form_mode == 0) {
        effect_form_start();
        form_mode = 1;
    }
    if((_v16 & 0x4000) != 0 && visited_mode == 0) {
        effect_visited_start();
        visited_mode = 1;
    }
    if((_v16 & 0x80) != 0 && active_mode == 0) {
        effect_active_start();
        active_mode = 1;
    }
    if((_v16 & 1) == 0 || mark_mode != 0) {
        return;
    } else {
        effect_mark_start();
        mark_mode = 1;
        return;
    }
}

void do_color(Linecolor c)
{// addr = 0x08076BCD  --  defined in 'display.c' at line 1068
    signed int _v16;                       // _cfa_fffffff0

    _v16 = c;
    if((_v16 & 8) == 0) {
        if((color_mode & 8) != 0) {
            setfcolor(basic_color);
        }
    } else {
        setfcolor(_v16 & 7);
    }
    if((_v16 & 255) >= 0) {
        if((color_mode & 255) < 0) {
            setbcolor(bg_color);
        }
    } else {
        setbcolor((_v16 & 255) >> 4 & 7);
    }
    color_mode = _v16 & 255;
}

void addChar(char c, Lineprop mode)
{// addr = 0x08076C55  --  defined in 'display.c' at line 1086
    char _v16;                             // _cfa_fffffff0
    signed short _v20;                     // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v16 = c;
    _v20 = mode;
    addMChar( &_v16, _v20 & 65535, 1);
}

void addMChar(char* p, Lineprop mode, size_t len)
{// addr = 0x08076C85  --  defined in 'display.c' at line 1092
    char c;                                // _cfa_fffffff3
    Lineprop m;       // _cfa_fffffff0
    char** symbol;                         // _cfa_ffffffec
    int w;                                 // _cfa_ffffffe8
    char[4] buf;                           // _cfa_ffffffe3
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v68;                       // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8 (outparam)
    char _t61;                             // _t61
    int _t68;                              // _t68

    _v48 = mode;
    m = _v48 & 0xc0;
    c =  *p & 255;
    if((_v48 & 0x400) != 0) {
        return;
    }
    do_effects(m & 65535);
    if((_v48 & 65535) >= 0) {
        if((_v48 & 0x100) == 0) {
            if((_v48 & 0x1000) == 0) {
                addmch(p, len);
                return;
            }
            _v68 = (wtf_get_code(p) | -128) & 255;
            _v72 = "[%.2X]";
             *__esp =  &buf;
            sprintf();
            addstr( &buf);
            return;
        }
        _t61 = c;
        if(_t61 == 10) {
            addch(32);
            return;
        }
        if(_t61 > 10) {
            if(_t61 == 13) {
                return;
            }
            if(_t61 == 127) {
                addstr("^?");
                return;
            }
L25:
            addch(94);
            addch((c & 255) + 64);
            return;
        }
        if(_t61 == 9) {
            addch(c);
            return;
        }
        goto L25;
    }
    if((_v48 & 0x800) == 0) {
        _t68 = 1;
    } else {
        _t68 = 2;
    }
    w = _t68;
    c = (wtf_get_code(p) & 127) - 32;
    if(graph_ok() == 0 || c > 31) {
        symbol = get_symbol(DisplayCharset,  &w);
        addstr(symbol[c]);
        return;
    } else {
        if(graph_mode == 0) {
            graphstart();
            graph_mode = 1;
        }
        if(w != 2 || ( *135119023 & 255) == 0) {
            addch( *( *( &graph_symbol + c * 4)) & 255);
            return;
        } else {
            addstr( *( &graph2_symbol + c * 4));
            return;
        }
    }
}

void record_err_message(char* s)
{// addr = 0x08076E82  --  defined in 'display.c' at line 1176
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if((fmInitialized & 255) != 0) {
        if(message_list == 0) {
            message_list = newGeneralList();
        }
        if((message_list->nitem & 65535) >= LINES) {
            popValue(message_list);
        }
        pushValue(message_list, allocStr(s, -1));
        return;
    }
}

Buffer* message_list_panel()
{// addr = 0x08076EEF  --  defined in 'display.c' at line 1191
    Str tmp;               // _cfa_fffffff0
    ListItem* p;      // _cfa_ffffffec
    intOrPtr _v44;                         // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    char* _t34;                            // _t34

    tmp = Strnew_size(COLS * LINES);
    Strcat_charp(tmp, "<html><head><title>List of error messages</title></head><body><h1>List of error messages</h1><table cellpadding=0>\n");
    if(message_list == 0) {
        Strcat_charp(tmp, "<tr><td>(no message recorded)</td></tr>\n");
    } else {
        p = message_list->last;
        while(p != 0) {
            _t34 = html_quote(p->ptr);
            _v44 = 0;
            _v48 = "</pre></td></tr>\n";
            _v52 = _t34;
            _v56 = "<tr><td><pre>";
            Strcat_m_charp(tmp);
            p = p->prev;
        }
    }
    Strcat_charp(tmp, "</table></body></html>");
    return loadHTMLString(tmp);
}

void message(char* s, int return_x, int return_y)
{// addr = 0x08076FAF  --  defined in 'display.c' at line 1211
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if((fmInitialized & 255) != 0) {
        move(LINES - 1, 0);
        addnstr(s, COLS - 1);
        clrtoeolx();
        move(return_y, return_x);
        return;
    }
}

void disp_err_message(char* s, int redraw_current)
{// addr = 0x0807700B  --  defined in 'display.c' at line 1222
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    record_err_message(s);
    disp_message(s, redraw_current);
}

void disp_message_nsec(char* s, int redraw_current, int sec, int purge, int mouse)
{// addr = 0x08077030  --  defined in 'display.c' at line 1229
    intOrPtr _v20;                         // _cfa_ffffffec (outparam)
    char* _v24;                            // _cfa_ffffffe8 (outparam)

    if((QuietMessage & 255) != 0) {
L18:
        return;
    }
    if((fmInitialized & 255) == 0) {
        _v20 =  *(wc_Str_conv_strict(Strnew_charp(s), InnerCharset, SystemCharset));
        _v24 = "%s\n";
         *__esp = __imp__stderr;
        fprintf();
        return;
    }
    if(CurrentTab == 0) {
L6:
        message(s, LINES - 1, 0);
        goto L7;
    } else {
        if(CurrentTab->currentBuffer == 0) {
            goto L6;
        } else {
            message(s, (CurrentTab->currentBuffer->cursorX & 65535) + (CurrentTab->currentBuffer->rootX & 65535), (CurrentTab->currentBuffer->cursorY & 65535) + (CurrentTab->currentBuffer->rootY & 65535));
L7:
            refresh();
            if(mouse != 0 && use_mouse != 0) {
                mouse_active();
            }
            sleep_till_anykey(sec, purge);
            if(mouse != 0 && use_mouse != 0) {
                mouse_inactive();
            }
            if(CurrentTab == 0 || CurrentTab->currentBuffer == 0 || redraw_current == 0) {
                goto L18;
            } else {
                displayBuffer(CurrentTab->currentBuffer, 0);
                return;
            }
        }
    }
}

void disp_message(char* s, int redraw_current)
{// addr = 0x0807719C  --  defined in 'display.c' at line 1257
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    disp_message_nsec(s, redraw_current, 10, 0, 1);
}

void disp_message_nomouse(char* s, int redraw_current)
{// addr = 0x080771CE  --  defined in 'display.c' at line 1263
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    disp_message_nsec(s, redraw_current, 10, 0, 0);
}

void set_delayed_message(char* s)
{// addr = 0x08077200  --  defined in 'display.c' at line 1270
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    delayed_msg = allocStr(s, -1);
}

void cursorUp0(Buffer* buf, int n)
{// addr = 0x08077220  --  defined in 'display.c' at line 1276
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if((buf->cursorY & 65535) <= 0) {
        buf->topLine = lineSkip(buf, buf->topLine,  ~n, 0);
        if(buf->currentLine->prev != 0) {
            buf->currentLine = buf->currentLine->prev;
        }
        arrangeLine(buf);
        return;
    }
    cursorUpDown(buf, -1);
}

void cursorUp(Buffer* buf, int n)
{// addr = 0x0807729E  --  defined in 'display.c' at line 1289
    Line* l;              // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    l = buf->currentLine;
    if(buf->firstLine == 0) {
        return;
    }
    while(buf->currentLine->prev != 0 && buf->currentLine->bpos != 0) {
        cursorUp0(buf, n);
    }
    if(buf->currentLine != buf->firstLine) {
        cursorUp0(buf, n);
        while(buf->currentLine->prev != 0 && buf->currentLine->bpos != 0 && buf->currentLine->bwidth >= buf->currentColumn + buf->visualpos) {
            cursorUp0(buf, n);
        }
        return;
    }
    gotoLine(buf, l->linenumber);
    arrangeLine(buf);
}

void cursorDown0(Buffer* buf, int n)
{// addr = 0x0807737B  --  defined in 'display.c' at line 1308
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if((buf->cursorY & 65535) >= (buf->LINES & 65535) - 1) {
        buf->topLine = lineSkip(buf, buf->topLine, n, 0);
        if(buf->currentLine->next != 0) {
            buf->currentLine = buf->currentLine->next;
        }
        arrangeLine(buf);
        return;
    }
    cursorUpDown(buf, 1);
}

void cursorDown(Buffer* buf, int n)
{// addr = 0x08077402  --  defined in 'display.c' at line 1321
    Line* l;              // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    l = buf->currentLine;
    if(buf->firstLine == 0) {
        return;
    }
    while(buf->currentLine->next != 0 && buf->currentLine->next->bpos != 0) {
        cursorDown0(buf, n);
    }
    if(buf->currentLine != buf->lastLine) {
        cursorDown0(buf, n);
        while(buf->currentLine->next != 0 && buf->currentLine->next->bpos != 0 && buf->currentLine->bwidth + buf->currentLine->width < buf->currentColumn + buf->visualpos) {
            cursorDown0(buf, n);
        }
        return;
    }
    gotoLine(buf, l->linenumber);
    arrangeLine(buf);
}

void cursorUpDown(Buffer* buf, int n)
{// addr = 0x080774F1  --  defined in 'display.c' at line 1341
    Line* cl;             // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    cl = buf->currentLine;
    if(buf->firstLine == 0) {
        return;
    }
    buf->currentLine = currentLineSkip(buf, cl, n, 0);
    if(buf->currentLine != cl) {
        arrangeLine(buf);
        return;
    }
}

void cursorRight(Buffer* buf, int n)
{// addr = 0x0807754F  --  defined in 'display.c' at line 1353
    int i;                                 // _cfa_fffffff0
    int delta;                             // _cfa_ffffffec
    int cpos;                              // _cfa_ffffffe8
    int vpos2;                             // _cfa_ffffffe4
    Line* l;              // _cfa_ffffffe0
    Lineprop* p;      // _cfa_ffffffdc
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1

    delta = 1;
    l = buf->currentLine;
    if(buf->firstLine == 0) {
        return;
    }
    if(buf->pos != l->len) {
L4:
        i = buf->pos;
        p = l->propBuf;
        while(i + delta < l->len) {
            if(( *(p + i + delta + i + delta) & 0x400) != 0) {
                delta = delta + 1;
                continue;
            }
            break;
        }
        if(i + delta >= l->len) {
            if(l->len != 0) {
                if(l->next == 0 || l->next->bpos == 0) {
                    buf->pos = l->len - 1;
                    while(buf->pos != 0 && ( *(p + buf->pos + buf->pos) & 0x400) != 0) {
                        buf->pos = buf->pos - 1;
                    }
                    goto L19;
                } else {
                    cursorDown0(buf, 1);
                    buf->pos = 0;
                    arrangeCursor(buf);
                    return;
                }
            }
            buf->pos = 0;
            goto L19;
        } else {
            buf->pos = i + delta;
L19:
            cpos = calcPosition(l->lineBuf, l->propBuf, l->len, buf->pos, 0, 0);
            buf->visualpos = l->bwidth + cpos - buf->currentColumn;
            delta = 1;
            while(buf->pos + delta < l->len && ( *(p + buf->pos + delta + buf->pos + delta) & 0x400) != 0) {
                delta = delta + 1;
            }
            vpos2 = calcPosition(l->lineBuf, l->propBuf, l->len, buf->pos + delta, 0, 0) - buf->currentColumn - 1;
            if((buf->COLS & 65535) <= vpos2 && n != 0) {
                columnSkip(buf, vpos2 - (buf->COLS & 65535) + n - (vpos2 - (buf->COLS & 65535)) % n);
                buf->visualpos = l->bwidth + cpos - buf->currentColumn;
            }
            buf->cursorX = buf->visualpos - l->bwidth;
            return;
        }
    }
    if(l->next == 0) {
        return;
    }
    if(l->next->bpos == 0) {
        return;
    }
    goto L4;
}

void cursorLeft(Buffer* buf, int n)
{// addr = 0x08077833  --  defined in 'display.c' at line 1404
    int i;                                 // _cfa_fffffff0
    int delta;                             // _cfa_ffffffec
    int cpos;                              // _cfa_ffffffe8
    Line* l;              // _cfa_ffffffe4
    Lineprop* p;      // _cfa_ffffffe0
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1

    delta = 1;
    l = buf->currentLine;
    if(buf->firstLine == 0) {
        return;
    } else {
        i = buf->pos;
        p = l->propBuf;
        while(i - delta > 0 && ( *(p + i - delta + i - delta) & 0x400) != 0) {
            delta = delta + 1;
        }
        if(i < delta) {
            if(l->prev == 0 || l->bpos == 0) {
                buf->pos = 0;
L11:
                cpos = calcPosition(l->lineBuf, l->propBuf, l->len, buf->pos, 0, 0);
                buf->visualpos = l->bwidth + cpos - buf->currentColumn;
                if(buf->visualpos - l->bwidth < 0 && n != 0) {
                    columnSkip(buf, buf->visualpos - n - l->bwidth - (buf->visualpos - l->bwidth) % n);
                    buf->visualpos = l->bwidth + cpos - buf->currentColumn;
                }
                buf->cursorX = buf->visualpos - l->bwidth;
                return;
            } else {
                cursorUp0(buf, -1);
                buf->pos = buf->currentLine->len - 1;
                arrangeCursor(buf);
                return;
            }
        }
        buf->pos = i - delta;
        goto L11;
    }
}

void cursorHome(Buffer* buf)
{// addr = 0x08077A04  --  defined in 'display.c' at line 1440
    buf->visualpos = 0;
    buf->cursorY = 0;
    buf->cursorX = buf->cursorY & 65535;
}

void arrangeCursor(Buffer* buf)
{// addr = 0x08077A2A  --  defined in 'display.c' at line 1452
    int col;                               // _cfa_fffffff0
    int col2;                              // _cfa_ffffffec
    int pos;                               // _cfa_ffffffe8
    int delta;                             // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1

    delta = 1;
    if(buf == 0) {
        return;
    }
    if(buf->currentLine == 0) {
        return;
    }
    if(buf->currentLine->linenumber - buf->topLine->linenumber >= (buf->LINES & 65535) || buf->currentLine->linenumber >= buf->topLine->linenumber) {
L4:
        buf->topLine = lineSkip(buf, buf->currentLine, 0, 0);
        while(buf->pos < 0) {
            if(buf->currentLine->prev == 0) {
                break;
                do {
                } while();
L24:
                while(buf->pos > 0 && ( *(buf->currentLine->propBuf + buf->pos + buf->pos) & 0x400) != 0) {
                    buf->pos = buf->pos - 1;
                }
                col = calcPosition(buf->currentLine->lineBuf, buf->currentLine->propBuf, buf->currentLine->len, buf->pos, 0, 0);
                while(buf->pos + delta < buf->currentLine->len && ( *(buf->currentLine->propBuf + buf->pos + delta + buf->pos + delta) & 0x400) != 0) {
                    delta = delta + 1;
                }
                col2 = calcPosition(buf->currentLine->lineBuf, buf->currentLine->propBuf, buf->currentLine->len, buf->pos + delta, 0, 0);
                if(buf->currentColumn > col || buf->currentColumn + (buf->COLS & 65535) < col2) {
                    buf->currentColumn = 0;
                    if((buf->COLS & 65535) < col2) {
                        columnSkip(buf, col);
                    }
                }
                buf->cursorY = buf->currentLine->linenumber - buf->topLine->linenumber;
                buf->visualpos = buf->currentLine->bwidth + calcPosition(buf->currentLine->lineBuf, buf->currentLine->propBuf, buf->currentLine->len, buf->pos, 0, 0) - buf->currentColumn;
                buf->cursorX = buf->visualpos - buf->currentLine->bwidth;
                return;
                break;
            }
            if(buf->currentLine->bpos != 0) {
                pos = buf->pos + buf->currentLine->prev->len;
                cursorUp0(buf, 1);
                buf->pos = pos;
                continue;
            } else {
                break;
            }
        }
L14:
        if(buf->pos < buf->currentLine->len || buf->currentLine->next == 0 || buf->currentLine->next->bpos == 0) {
            if(buf->currentLine->len == 0 || buf->pos < 0) {
                buf->pos = 0;
            } else {
                if(buf->pos >= buf->currentLine->len) {
                    buf->pos = buf->currentLine->len - 1;
                }
            }
            goto L24;
        } else {
            pos = buf->pos - buf->currentLine->len;
            cursorDown0(buf, 1);
            buf->pos = pos;
            goto L14;
        }
    } else {
        goto L4;
    }
}

void arrangeLine(Buffer* buf)
{// addr = 0x08077DD8  --  defined in 'display.c' at line 1512
    int i;                                 // _cfa_fffffff0
    int cpos;                              // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    if(buf->firstLine != 0) {
        buf->cursorY = buf->currentLine->linenumber - buf->topLine->linenumber;
        i = columnPos(buf->currentLine, buf->currentColumn + buf->visualpos - buf->currentLine->bwidth);
        cpos = calcPosition(buf->currentLine->lineBuf, buf->currentLine->propBuf, buf->currentLine->len, i, 0, 0) - buf->currentColumn;
        if(cpos < 0) {
            if(buf->currentLine->len <= i) {
                buf->cursorX = 0;
                buf->pos = 0;
                return;
            }
            buf->cursorX = 0;
            buf->pos = i + 1;
            return;
        }
        buf->cursorX = cpos;
        buf->pos = i;
        return;
    }
}

void cursorXY(Buffer* buf, int x, int y)
{// addr = 0x08077EE9  --  defined in 'display.c' at line 1543
    int oldX;                              // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    Buffer* _t53;       // _t53
    Buffer* _t65;       // _t65
    unsigned int _t72;                     // _t72
    unsigned int _t81;                     // _t81
    unsigned short _t92;                   // _t92
    unsigned short _t94;                   // _t94

    cursorUpDown(buf, y - (buf->cursorY & 65535));
    if((buf->cursorX & 65535) > x) {
        while((buf->cursorX & 65535) > x) {
            _t81 = buf->COLS & 65535;
            _t94 = _t81 >> 15;
            __eflags = _t94;
            cursorLeft(buf, _t94 + _t81 >> 1);
        }
        return;
    }
    __eflags = (buf->cursorX & 65535) - x;
    if(__eflags < 0) {
        while(1) {
            _t53 = buf;
            __eflags = (_t53->cursorX & 65535) - x;
            if((_t53->cursorX & 65535) >= x) {
                break;
            }
            oldX = buf->cursorX & 65535;
            cursorRight(buf, ((buf->COLS & 65535) >> 15) + (buf->COLS & 65535) >> 1);
            _t65 = buf;
            __eflags = (_t65->cursorX & 65535) - oldX;
            if((_t65->cursorX & 65535) != oldX) {
                continue;
            }
L11:
            __eflags = (buf->cursorX & 65535) - x;
            if(__eflags > 0) {
                _t72 = buf->COLS & 65535;
                _t92 = _t72 >> 15;
                __eflags = _t92;
                cursorLeft(buf, _t92 + _t72 >> 1);
                return;
            }
            goto L13;
        }
        goto L11;
    }
L13:
}

void restorePosition(Buffer* buf, Buffer* orig)
{// addr = 0x08077FDF  --  defined in 'display.c' at line 1568
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t46;                              // _t46
    int _t51;                              // _t51

    if(orig->topLine == 0) {
        _t46 = 0;
    } else {
        _t46 = orig->topLine->linenumber - 1;
    }
    buf->topLine = lineSkip(buf, buf->firstLine, _t46, 0);
    if(orig->currentLine == 0) {
        _t51 = 1;
    } else {
        _t51 = orig->currentLine->linenumber;
    }
    gotoLine(buf, _t51);
    buf->pos = orig->pos;
    if(buf->currentLine != 0 && orig->currentLine != 0) {
        buf->pos = buf->pos + orig->currentLine->bpos - buf->currentLine->bpos;
    }
    buf->currentColumn = orig->currentColumn;
    arrangeCursor(buf);
}

int columnSkip(Buffer* buf, int offset)
{// addr = 0x080780B8  --  defined in 'etc.c' at line 39
    int i;                                 // _cfa_fffffff0
    int maxColumn;                         // _cfa_ffffffec
    int column;                            // _cfa_ffffffe8
    int nlines;                            // _cfa_ffffffe4
    Line* l;              // _cfa_ffffffe0
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)

    column = buf->currentColumn + offset;
    nlines = (buf->LINES & 65535) + 1;
    maxColumn = 0;
    i = 0;
    l = buf->topLine;
    while(i < nlines && l != 0) {
        if(l->width < 0) {
            l->width = calcPosition(l->lineBuf, l->propBuf, l->len, l->len, 0, 0);
        }
        if(l->width - 1 > maxColumn) {
            maxColumn = l->width - 1;
        }
        i = i + 1;
        l = l->next;
    }
    maxColumn = maxColumn + 1 - (buf->COLS & 65535);
    if(column < maxColumn) {
        maxColumn = column;
    }
    if(maxColumn < 0) {
        maxColumn = 0;
    }
    if(buf->currentColumn != maxColumn) {
        buf->currentColumn = maxColumn;
        return 1;
    } else {
        return 0;
    }
}

int columnPos(Line* line, int column)
{// addr = 0x080781C9  --  defined in 'etc.c' at line 66
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    i = 1;
    while(line->len > i) {
        if(calcPosition(line->lineBuf, line->propBuf, line->len, i, 0, 0) > column) {
L6:
            i = i - 1;
            while(i > 0 && ( *(line->propBuf + i + i) & 0x400) != 0) {
                i = i - 1;
            }
            return i;
        }
        i = i + 1;
    }
    goto L6;
}

Line* lineSkip(Buffer* buf, Line* line, int offset, int last)
{// addr = 0x0807825D  --  defined in 'etc.c' at line 83
    int i;                                 // _cfa_fffffff0
    Line* l;              // _cfa_ffffffec
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1

    l = currentLineSkip(buf, line, offset, last);
    if(nextpage_topline != 0) {
L5:
        return l;
    }
    i = (buf->LINES & 65535) - 1 + l->linenumber - buf->lastLine->linenumber;
    while(i > 0 && l->prev != 0) {
        i = i - 1;
        l = l->prev;
    }
    goto L5;
}

Line* currentLineSkip(Buffer* buf, Line* line, int offset, int last)
{// addr = 0x080782DE  --  defined in 'etc.c' at line 96
    int i;                                 // _cfa_fffffff0
    int n;                                 // _cfa_ffffffec
    Line* l;              // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    l = line;
    if(buf->pagerSource == 0 || (buf->bufferprop & 0x40) != 0) {
L9:
        if(offset == 0) {
            return l;
        }
        if(offset <= 0) {
            i = 0;
            while( ~offset > i && l->prev != 0) {
                i = i + 1;
                l = l->prev;
            }
L21:
            return l;
        }
        i = 0;
        while(i < offset) {
            if(l->next != 0) {
                i = i + 1;
                l = l->next;
                continue;
            }
            goto L21;
        }
        goto L21;
    } else {
        n = line->linenumber + offset + (buf->LINES & 65535);
        if(buf->lastLine->linenumber < n) {
            getNextPage(buf, n - buf->lastLine->linenumber);
        }
        while(last != 0 || buf->lastLine->linenumber < n) {
            if(getNextPage(buf, 1) != 0) {
                continue;
            }
            break;
        }
        if(last != 0) {
            l = buf->lastLine;
        }
        goto L9;
    }
}

int gethtmlcmd(char** s)
{// addr = 0x080783F7  --  defined in 'etc.c' at line 123
    signed int _v16;                       // _cfa_fffffff0
    char[127] cmdstr;                      // _cfa_ffffff70
    char* p;                               // _cfa_ffffff6c
    char* save;                            // _cfa_ffffff68
    int cmd;                               // _cfa_ffffff64
    char** _v160;                          // _cfa_ffffff60
    _unknown_ _v180;                       // _cfa_ffffff4c (outparam)
    _unknown_ _v184;                       // _cfa_ffffff48 (outparam)
    char _t93;                             // _t93
    char _t131;                            // _t131
    int _t149;                             // _t149

    _v160 = s;
    _v16 =  *gs:0x14];
    p =  &cmdstr;
    save =  *_v160;
     *_v160 =  &(( *_v160)[1]);
    if(( *( &MYCTYPE_MAP + ( *( *_v160) & 0xff)) & 0xc) != 0 || ( *( *_v160) & 255) == 95 || ( *( *_v160) & 255) == 47) {
        if(( *( &MYCTYPE_MAP + ( *( *_v160) & 0xff)) & 4) == 0) {
            _t93 =  *( *_v160) & 255;
        } else {
            _t93 =  *( *_v160) & 255 | 32;
        }
         *p = _t93;
        p =  &(p[1]);
         *_v160 =  &(( *_v160)[1]);
        if(( *(p - 1) & 255) == 47) {
            while(( *( *_v160) & 255) != 0) {
                if(( *( &MYCTYPE_MAP + ( *( *_v160) & 0xff)) & 2) != 0) {
                     *_v160 =  &(( *_v160)[1]);
                    continue;
                }
L18:
                while(( *( &MYCTYPE_MAP + ( *( *_v160) & 0xff)) & 0xc) != 0 || ( *( *_v160) & 255) == 95) {
                    if(p -  &cmdstr <= 127) {
                        if(( *( &MYCTYPE_MAP + ( *( *_v160) & 0xff)) & 4) == 0) {
                            _t131 =  *( *_v160) & 255;
                        } else {
                            _t131 =  *( *_v160) & 255 | 32;
                        }
                         *p = _t131;
                        p =  &(p[1]);
                         *_v160 =  &(( *_v160)[1]);
                        continue;
                    }
                    break;
                }
                if(p -  &cmdstr != 128) {
                     *p = 0;
                    cmd = getHash_si( &tagtable,  &cmdstr, 0);
                    while(( *( *_v160) & 255) != 0 && ( *( *_v160) & 255) != 62) {
                         *_v160 =  &(( *_v160)[1]);
                    }
                    if(( *( *_v160) & 255) == 62) {
                         *_v160 =  &(( *_v160)[1]);
                    }
                    _t149 = cmd;
                    goto L30;
                }
                 *_v160 =  &(save[1]);
                _t149 = 0;
                goto L30;
            }
            goto L18;
        }
        goto L18;
    } else {
        _t149 = 0;
L30:
        if((_v16 ^  *gs:0x14]) == 0) {
            return _t149;
        }
        __stack_chk_fail();
        return _t149;
    }
}

int parse_ansi_color(char** str, Lineprop* effect, Linecolor* color)
{// addr = 0x080786B3  --  defined in 'etc.c' at line 163
    Linecolor c;     // _cfa_fffffff3
    Lineprop e;       // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t116;                             // _t116
    int _t117;                             // _t117

    p =  *str;
    e =  *effect & 65535;
    c =  *color & 255;
    if(( *p & 255) != 27) {
L2:
        return 0;
    }
    if((p[1] & 255) == 91) {
        p =  &(p[2]);
        q = p;
        do {
        } while(( *( &MYCTYPE_MAP + ( *q & 0xff)) & 8) != 0 || ( *q & 255) == 59);
        if(( *q & 255) != 109) {
            return 0;
        }
         *str =  &(q[1]);
        while(( *p & 255) != 109) {
            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 8) == 0) {
                e = 0;
                c = 0;
L46:
                 *effect = e & 65535;
                 *color = c & 255;
                return 1;
            }
            q = p;
            p =  &(p[1]);
            while(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 8) != 0) {
                p =  &(p[1]);
            }
            _t116 = allocStr(q, p - q);
             *__esp = _t116;
            atoi();
            i = _t116;
            _t117 = i;
            if(_t117 == 5) {
L30:
                e = 8;
L42:
                if(( *p & 255) != 109) {
                    p =  &(p[1]);
                    continue;
                }
                goto L46;
            }
            if(_t117 > 5) {
                if(_t117 == 39) {
                    c = c & 240;
                    goto L42;
                }
                if(_t117 > 39) {
                    if(_t117 == 49) {
                        c = c & 15;
                        goto L42;
                    }
                    if(_t117 == 100) {
                        c = 0;
                        goto L42;
                    }
L36:
                    if(i <= 29 || i > 37) {
                        if(i > 39 && i <= 47) {
                            c = i - 40 << 4 | c & 0xf | -128;
                        }
                    } else {
                        c = i - 30 | c & 0xf0 | 8;
                    }
                    goto L42;
                }
                if(_t117 == 7) {
                    e = 4;
                    goto L42;
                }
                goto L36;
            }
            if(_t117 == 1) {
                goto L30;
            }
            if(_t117 == 4) {
                e = 2;
                goto L42;
            }
            if(_t117 == 0) {
                e = 0;
                c = 0;
                goto L42;
            }
            goto L36;
        }
        e = 0;
        c = 0;
        goto L46;
    }
    goto L2;
}

Str checkType(Str s, Lineprop** oprop, Linecolor** ocolor)
{// addr = 0x080788C5  --  defined in 'etc.c' at line 238
    Linecolor cmode;   // _cfa_fffffff3
    Lineprop mode;    // _cfa_fffffff0
    Lineprop effect;   // _cfa_ffffffee
    Lineprop ceffect;   // _cfa_ffffffec
    Lineprop* prop;   // _cfa_ffffffe8
    char* str;                             // _cfa_ffffffe4
    char* endp;                            // _cfa_ffffffe0
    char* bs;                              // _cfa_ffffffdc
    int check_color;                       // _cfa_ffffffd8
    Linecolor* color;   // _cfa_ffffffd4
    char* es;                              // _cfa_ffffffd0
    int do_copy;                           // _cfa_ffffffcc
    int i;                                 // _cfa_ffffffc8
    int plen;                              // _cfa_ffffffc4
    int clen;                              // _cfa_ffffffc0
    char* sp;                              // _cfa_ffffffbc
    char* ep;                              // _cfa_ffffffb8
    int ok;                                // _cfa_ffffffb4
    int _v84;                              // _cfa_ffffffac (outparam)
    int _v88;                              // _cfa_ffffffa8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t396;                             // _t396
    char* _t419;                           // _t419
    char* _t428;                           // _t428
    char* _t437;                           // _t437
    char* _t442;                           // _t442
    char* _t453;                           // _t453
    int _t468;                             // _t468
    int _t494;                             // _t494
    signed int _t506;                      // _t506
    char* _t531;                           // _t531
    char* _t532;                           // _t532
    char* _t538;                           // _t538
    Linecolor* _t541;   // _t541
    short unsigned int _t555;              // _t555
    char* _t560;                           // _t560
    char* _t565;                           // _t565
    short unsigned int _t584;              // _t584
    char* _t595;                           // _t595
    int _t600;                             // _t600
    Linecolor* _t603;   // _t603
    int _t605;                             // _t605
    Lineprop* _t608;   // _t608
    char* _t684;                           // _t684

    effect = 0;
    str = s->ptr;
    endp = s->ptr + s->length;
    bs = 0;
    ceffect = 0;
    cmode = 0;
    check_color = 0;
    color = 0;
    es = 0;
    do_copy = 0;
    plen = 0;
    if(s->length > prop_size) {
        _t605 = s->length;
        _t606 = _t605 - 256 < 0 ? 256 : _t605;
        prop_size = _t605 - 256 < 0 ? 256 : _t605;
        _t608 = prop_buffer;
        _v88 = prop_size + prop_size;
         *__esp = _t608;
        GC_realloc();
        prop_buffer = _t608;
    }
    prop = prop_buffer;
    if(ShowEffect == 0) {
L27:
        if(do_copy != 0) {
L119:
            while(str < endp) {
                if(prop - prop_buffer >> 1 >= prop_size) {
L122:
                     *oprop = prop_buffer;
                    if(ocolor != 0) {
                        if(check_color == 0) {
                            _t541 = 0;
                        } else {
                            _t541 = color_buffer;
                        }
                         *ocolor = _t541;
                    }
                    return s;
                }
                if(bs == 0) {
L87:
                    if(es == 0) {
L96:
                        plen =  *( &WTF_LEN_MAP + ( *str & 0xff)) & 0xff;
                        mode = effect & 65535 | ( *( &WTF_TYPE_MAP + ( *str & 0xff)) & 0xff) << 8;
                        if(color != 0) {
                             *color = cmode & 255;
                            color =  &(color[1]);
                            mode = mode | ceffect & 65535;
                        }
                         *prop = mode & 65535;
                        prop =  &(prop[1]);
                        if(plen <= 1) {
                            if(do_copy != 0) {
                                if(s->length + 1 >= s->area_size) {
                                    Strgrow(s);
                                }
                                _t396 = s->length;
                                 *((char*)(s->ptr + _t396)) =  *str & 255;
                                s->length = _t396 + 1;
                                 *(s->ptr + s->length) = 0;
                            }
                            str =  &(str[1]);
                            goto L112;
                        } else {
                            mode = mode & 0xf9 | 4;
                            i = 1;
                            while(i < plen) {
                                 *prop = mode & 65535;
                                prop =  &(prop[1]);
                                if(color != 0) {
                                     *color = cmode & 255;
                                    color =  &(color[1]);
                                }
                                i = i + 1;
                            }
                            if(do_copy != 0) {
                                Strcat_charp_n(s, str, plen);
                            }
                            str =  &(str[plen]);
L112:
                            effect = 0;
                            continue;
                        }
                    }
                    if(str != es) {
                        if(str > es) {
                            _t419 = str;
                            _v84 = endp - str;
                            _v88 = 27;
                             *__esp = _t419;
                            memchr();
                            es = _t419;
                        }
                        goto L96;
                    }
                    ok = parse_ansi_color( &str,  &ceffect,  &cmode);
                    if(str < endp) {
                        _t428 = str;
                        _v84 = endp - str;
                        _v88 = 27;
                         *__esp = _t428;
                        memchr();
                        es = _t428;
                    }
                    if(ok == 0) {
                        goto L96;
                    } else {
                        if((cmode & 255) != 0) {
                            check_color = 1;
                        }
                        continue;
                    }
                }
                if(bs - 2 != str) {
L42:
                    if(bs - 1 != str || ( *str & 255) != 95) {
                        if(str != bs) {
                            if(str > bs) {
                                _t437 = str;
                                _v84 = endp - str;
                                _v88 = 8;
                                 *__esp = _t437;
                                memchr();
                                bs = _t437;
                            }
                            goto L87;
                        }
                        if((str[1] & 255) != 95) {
                            _t442 =  &(str[1]);
                            _v84 = 3;
                            _v88 = 135048581;
                             *__esp = _t442;
                            strncmp();
                            if(_t442 != 0) {
                                if((str[1] & 255) != 8) {
                                    if(s->length == 0) {
                                        str =  &(str[1]);
L83:
                                        if(str < endp) {
                                            _t453 = str;
                                            _v84 = endp - str;
                                            _v88 = 8;
                                             *__esp = _t453;
                                            memchr();
                                            bs = _t453;
                                        }
                                        continue;
                                    }
                                    clen =  *( &WTF_LEN_MAP + (str[1] & 0xff)) & 0xff;
                                    if(plen != clen) {
L81:
                                        Strshrink(s, plen);
                                        prop = prop +  ~(plen + plen);
                                        str =  &(str[1]);
                                        goto L83;
                                    }
                                    _t468 = plen;
                                    _v84 = _t468;
                                    _v88 =  &(str[1]);
                                     *__esp =  &(str[ ~plen]);
                                    strncmp();
                                    if(_t468 != 0) {
                                        goto L81;
                                    }
                                    i = 1;
                                    while(i <= plen) {
                                         *(prop +  ~(i + i)) =  *(prop +  ~(i + i)) & 65535 | 8;
                                        i = i + 1;
                                    }
                                    str =  &(str[clen + 1]);
                                    goto L83;
                                }
                                if(s->length == 0) {
                                    str =  &(str[2]);
                                    goto L83;
                                }
                                clen =  *( &WTF_LEN_MAP + (str[2] & 0xff)) & 0xff;
                                if(plen != clen) {
L72:
                                    Strshrink(s, plen);
                                    prop = prop +  ~(plen + plen);
                                    str =  &(str[2]);
                                    goto L83;
                                }
                                _t494 = plen;
                                _v84 = _t494;
                                _v88 =  &(str[2]);
                                 *__esp =  &(str[ ~plen]);
                                strncmp();
                                if(_t494 != 0) {
                                    goto L72;
                                }
                                i = 1;
                                while(i <= plen) {
                                     *(prop +  ~(i + i)) =  *(prop +  ~(i + i)) & 65535 | 8;
                                    i = i + 1;
                                }
                                str =  &(str[clen + 2]);
                                goto L83;
                            }
                            if(s->length == 0) {
                                str =  &(str[2]);
                                goto L83;
                            }
                            _t684 = str;
                            if(plen != 1) {
                                _t506 = 4;
                            } else {
                                _t506 = 3;
                            }
                            str =  &(_t684[_t506]);
                            i = 1;
                            while(i <= plen) {
                                 *(prop +  ~(i + i)) =  *(prop +  ~(i + i)) & 65535 | 2;
                                i = i + 1;
                            }
                            goto L83;
                        }
                        if(s->length == 0) {
                            str =  &(str[1]);
                            goto L83;
                        }
                        str =  &(str[2]);
                        i = 1;
                        while(i <= plen) {
                             *(prop +  ~(i + i)) =  *(prop +  ~(i + i)) & 65535 | 2;
                            i = i + 1;
                        }
                        goto L83;
                    } else {
                        str =  &(str[2]);
                        effect = 2;
                        if(str < endp) {
                            _t531 = str;
                            _v84 = endp - str;
                            _v88 = 8;
                             *__esp = _t531;
                            memchr();
                            bs = _t531;
                        }
                        continue;
                    }
                }
                _t532 = str;
                _v84 = 4;
                _v88 = 135048576;
                 *__esp = _t532;
                strncmp();
                if(_t532 != 0) {
                    goto L42;
                }
                str =  &(str[4]);
                effect = 2;
                if(str < endp) {
                    _t538 = str;
                    _v84 = endp - str;
                    _v88 = 8;
                     *__esp = _t538;
                    memchr();
                    bs = _t538;
                }
            }
            goto L122;
        }
        while(str < endp) {
            if(( *( &MYCTYPE_MAP + ( *str & 0xff)) & 0x11) != 0) {
                if(( *( &MYCTYPE_MAP + ( *str & 0xff)) & 1) == 0) {
                    _t555 = 0;
                } else {
                    _t555 = 256;
                }
                 *prop = _t555;
                prop =  &(prop[1]);
                str =  &(str[1]);
                continue;
            }
            goto L119;
        }
        goto L119;
    } else {
        _t560 = str;
        _v84 = s->length;
        _v88 = 8;
         *__esp = _t560;
        memchr();
        bs = _t560;
        if(ocolor != 0) {
            _t595 = str;
            _v84 = s->length;
            _v88 = 27;
             *__esp = _t595;
            memchr();
            es = _t595;
            if(es != 0) {
                if(s->length > color_size) {
                    _t600 = s->length;
                    _t601 = _t600 - 256 < 0 ? 256 : _t600;
                    color_size = _t600 - 256 < 0 ? 256 : _t600;
                    _t603 = color_buffer;
                    _v88 = color_size;
                     *__esp = _t603;
                    GC_realloc();
                    color_buffer = _t603;
                }
                color = color_buffer;
            }
        }
        if(bs != 0 || es != 0) {
            sp = str;
            s = Strnew_size(s->length);
            do_copy = 1;
            if(bs == 0) {
                _t565 = endp;
            } else {
                _t565 = bs - 2;
            }
            ep = _t565;
            if(es != 0) {
                if(es - 2 < ep) {
                    ep = es - 2;
                }
            }
            while(str < ep && ( *( &MYCTYPE_MAP + ( *str & 0xff)) & 0x11) != 0) {
                if(( *( &MYCTYPE_MAP + ( *str & 0xff)) & 1) == 0) {
                    _t584 = 0;
                } else {
                    _t584 = 256;
                }
                 *prop = _t584;
                prop =  &(prop[1]);
                if(color != 0) {
                     *color = 0;
                    color =  &(color[1]);
                }
                str =  &(str[1]);
            }
            Strcat_charp_n(s, sp, str - sp);
        }
        goto L27;
    }
}

int nextColumn(int n, char* p, Lineprop* pr)
{// addr = 0x080791C2  --  defined in 'etc.c' at line 473
    signed int _v8;                        // _cfa_fffffff8
    signed int _t37;                       // _t37

    if(( *pr & 0x100) == 0) {
        if(( *pr & 0x1000) == 0) {
            if(( *135119023 & 255) == 0) {
                _t37 = ( *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 255) != 0 & 255;
            } else {
                _t37 =  *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 0xff;
            }
            return _t37 + n;
        }
        return n + 4;
    }
    if(( *p & 255) != 9) {
        if(( *p & 255) != 10) {
            if(( *p & 255) == 13) {
                return n;
            }
            return n + 2;
        }
        return n + 1;
    }
    _v8 = Tabstop;
    return Tabstop * (Tabstop + n) / _v8;
}

int calcPosition(char* l, Lineprop* pr, int len, int pos, int bpos, int mode)
{// addr = 0x08079289  --  defined in 'etc.c' at line 494
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ _t116;                       // _t116
    int* _t119;                            // _t119

    if(l == 0 || len == 0) {
        return bpos;
    }
    if(l != prevl.9601 || mode != 0) {
L7:
        if(len + 1 > size.9600) {
            _t116 = len + 1;
            _t117 = _t116 - 256 < 0 ? 256 : _t116;
            size.9600 = _t116 - 256 < 0 ? 256 : _t116;
            _t119 = size.9600 << 2;
             *__esp = _t119;
            GC_malloc();
            realColumn = _t119;
        }
        prevl.9601 = l;
        i = 0;
        j = bpos;
        if(( *(pr + i + i) & 0x400) == 0) {
            goto L19;
        } else {
            while(i < len && ( *(pr + i + i) & 0x400) != 0) {
                realColumn[i] = j;
                i = i + 1;
            }
            if(i > 0 && ( *(pr + i - 1 + i - 1) & 0x800) != 0 && ( *135119023 & 255) != 0) {
                j = j + 1;
            }
            while(1) {
L19:
                realColumn[i] = j;
                if(i == len) {
                    break;
                }
                j = nextColumn(j,  &(l[i]), pr + i + i);
                i = i + 1;
                while(i < len) {
                    if(( *(pr + i + i) & 0x400) != 0) {
                        realColumn[i] = realColumn[i - 1];
                        i = i + 1;
                        continue;
                    }
                    goto L19;
                }
            }
            if(pos >= i) {
                return j;
            }
            return realColumn[pos];
        }
    } else {
        if(pos > len) {
            goto L7;
        } else {
            return realColumn[pos];
        }
    }
}

int columnLen(Line* line, int column)
{// addr = 0x08079452  --  defined in 'etc.c' at line 539
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)

    i = 0;
    j = 0;
    while(line->len > i) {
        j = nextColumn(j, line->lineBuf + i, line->propBuf + i + i);
        if(j <= column) {
            i = i + 1;
            while(line->len > i && ( *(line->propBuf + i + i) & 0x400) != 0) {
                i = i + 1;
            }
            continue;
        }
        return i;
    }
    return line->len;
}

char* lastFileName(char* path)
{// addr = 0x080794E8  --  defined in 'etc.c' at line 557
    char* p;                               // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    q = path;
    p = q;
    while(( *p & 255) != 0) {
        if(( *p & 255) == 47) {
            q =  &(p[1]);
        }
        p =  &(p[1]);
    }
    return allocStr(q, -1);
}

char* mybasename(char* s)
{// addr = 0x08079532  --  defined in 'etc.c' at line 595
    char* p;                               // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    p = s;
    while(( *p & 255) != 0) {
        p =  &(p[1]);
    }
    while(s <= p && ( *p & 255) != 47) {
        p = p - 1;
    }
    if(( *p & 255) != 47) {
        p = s;
    } else {
        p =  &(p[1]);
    }
    return allocStr(p, -1);
}

char* mydirname(char* s)
{// addr = 0x08079591  --  defined in 'etc.c' at line 610
    char* p;                               // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    char* _t39;                            // _t39
    char* _t40;                            // _t40

    p = s;
    goto L2;
    do {
    } while();
L6:
    while(s != p) {
        if(( *p & 255) == 47) {
            p = p - 1;
            continue;
        }
L10:
        while(s != p && ( *p & 255) != 47) {
            p = p - 1;
        }
        if(( *p & 255) == 47) {
            while(s != p && ( *p & 255) == 47) {
                p = p - 1;
            }
            _t39 = s;
             *__esp = _t39;
            strlen();
            _t40 = p;
             *__esp = _t40;
            strlen();
            return allocStr(s, _t39 - _t40 + 1);
        }
        return 135048585;
    }
    goto L10;
L2:
    if(( *p & 255) != 0) {
        p =  &(p[1]);
        goto L2;
    } else {
        if(s != p) {
            p = p - 1;
        }
    }
    goto L6;
}

int next_status(char c, int* status)
{// addr = 0x08079647  --  defined in 'etc.c' at line 656
    char _v8;                              // _cfa_fffffff8

    _v8 = c;
    if( *status <= 15) {
        goto __eax;
    }
    return 0;
}

int read_token(Str buf, char** instr, int* status, int pre, int append)
{// addr = 0x0807999A  --  defined in 'etc.c' at line 798
    char* p;                               // _cfa_fffffff0
    int prev_status;                       // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(append == 0) {
        Strclear(buf);
    }
    if(( *( *instr) & 255) != 0) {
        p =  *instr;
        while(( *p & 255) != 0) {
            prev_status =  *status;
            next_status( *p & 255, status);
            if( *status > 15) {
                p =  &(p[1]);
                continue;
            }
            goto __eax;
        }
         *instr = p;
        return 1;
    } else {
        return 0;
    }
}

Str correct_irrtag(int status)
{// addr = 0x08079E3B  --  defined in 'etc.c' at line 884
    char c;                                // _cfa_fffffff3
    Str tmp;               // _cfa_ffffffec

    tmp = Strnew();
    if(status != 0) {
        if(status > 15) {
            return tmp;
        }
        goto __eax;
    }
    return tmp;
}

void add_auth_pass_entry(const struct auth_pass* ent, int netrc, int override)
{// addr = 0x08079EF2  --  defined in 'etc.c' at line 936
    struct auth_pass* newent;   // _cfa_fffffff0
    struct auth_pass* ep;   // _cfa_ffffffec
    struct auth_pass* _v36;   // _cfa_ffffffdc
    const struct auth_pass* _v40;   // _cfa_ffffffd8
    struct auth_pass* _t42;   // _t42

    if(ent->host != 0 || netrc != 0) {
        if(ent->is_proxy != 0 || ent->realm != 0 || netrc != 0) {
            if(ent->uname == 0) {
                goto L17;
            }
            _t42 = ent->pwd;
            if(_t42 == 0) {
                goto L17;
            }
             *__esp = 32;
            GC_malloc();
            newent = _t42;
            _v36 = 32;
            _v40 = ent;
             *__esp = newent;
            memcpy();
            if(override != 0) {
                newent->next = passwords;
                passwords = newent;
                return;
            }
            if(passwords != 0) {
                if(passwords->next != 0) {
                    ep = passwords;
                    while(ep->next != 0) {
                        ep = ep->next;
                    }
                    ep->next = newent;
                    return;
                }
                passwords->next = newent;
                return;
            } else {
                passwords = newent;
                return;
            }
        } else {
            goto L17;
        }
    } else {
L17:
        return;
    }
}

struct auth_pass* find_auth_pass_entry(char* host, int port, char* realm, char* uname, int is_proxy)
{// addr = 0x08079FDF  --  defined in 'etc.c' at line 963
    struct auth_pass* ent;   // _cfa_fffffff0
    char* _v40;                            // _cfa_ffffffd8
    intOrPtr _t55;                         // _t55
    intOrPtr _t58;                         // _t58
    intOrPtr _t63;                         // _t63

    ent = passwords;
L15:
    while(1) {
        if(ent == 0) {
            return 0;
        }
        if(ent->is_proxy != is_proxy || ent->bad == 1) {
L14:
            ent = ent->next;
            continue;
        } else {
            if(ent->host == 0) {
L5:
                if(ent->port == 0 || ent->port == port) {
                    if(ent->uname == 0 || uname == 0) {
L10:
                        if(ent->realm == 0 || realm == 0) {
L13:
                            return ent;
                        } else {
                            _t55 =  *(ent->realm);
                            _v40 = realm;
                             *__esp = _t55;
                            strcmp();
                            if(_t55 != 0) {
                                goto L14;
                            }
                            goto L13;
                        }
                    } else {
                        _t58 =  *(ent->uname);
                        _v40 = uname;
                         *__esp = _t58;
                        strcmp();
                        if(_t58 != 0) {
                            goto L14;
                        }
                        goto L10;
                    }
                } else {
                    goto L14;
                }
            }
            _t63 =  *(ent->host);
            _v40 = host;
             *__esp = _t63;
            strcasecmp();
            if(_t63 != 0) {
                goto L14;
            }
            goto L5;
        }
    }
}

int find_auth_user_passwd(ParsedURL* pu, char* realm, Str* uname, Str* pwd, int is_proxy)
{// addr = 0x0807A0BE  --  defined in 'etc.c' at line 981
    struct auth_pass* ent;   // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    if(pu->user == 0 || pu->pass == 0) {
        ent = find_auth_pass_entry(pu->host, pu->port, realm, pu->user, is_proxy);
        if(ent == 0) {
            return 0;
        }
         *uname = ent->uname;
         *pwd = ent->pwd;
        return 1;
    } else {
         *uname = Strnew_charp(pu->user);
         *pwd = Strnew_charp(pu->pass);
        return 1;
    }
}

void add_auth_user_passwd(ParsedURL* pu, char* realm, Str uname, Str pwd, int is_proxy)
{// addr = 0x0807A167  --  defined in 'etc.c' at line 1001
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    struct auth_pass ent;   // _cfa_ffffffd4
    intOrPtr _v52;                         // _cfa_ffffffcc (outparam)
    int _v56;                              // _cfa_ffffffc8 (outparam)

    _v52 = 32;
    _v56 = 0;
     *__esp =  &(ent.bad);
    memset();
    ent.is_proxy = is_proxy;
    ent.host = Strnew_charp(pu->host);
    ent.port = pu->port;
    ent.realm = Strnew_charp(realm);
    ent.uname = uname;
    ent.pwd = pwd;
    add_auth_pass_entry( &(ent.bad), 0, 1);
}

void invalidate_auth_user_passwd(ParsedURL* pu, char* realm, Str uname, Str pwd, int is_proxy)
{// addr = 0x0807A1DF  --  defined in 'etc.c' at line 1017
    struct auth_pass* ent;   // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    ent = find_auth_pass_entry(pu->host, pu->port, realm, 0, is_proxy);
    if(ent != 0) {
        ent->bad = 1;
        return;
    }
}

Str next_token(Str arg)
{// addr = 0x0807A227  --  defined in 'etc.c' at line 1042
    Str narg;              // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8

    narg = 0;
    if(arg == 0) {
L2:
        return 0;
    }
    if(arg->length != 0) {
        p = arg->ptr;
        q = p;
        do {
        } while(( *q & 255) != 0 && ( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) == 0);
        if(( *q & 255) == 0) {
L14:
            return narg;
        }
         *q = 0;
        q =  &(q[1]);
        while(( *q & 255) != 0 && ( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) != 0) {
            q =  &(q[1]);
        }
        if(( *q & 255) != 0) {
            narg = Strnew_charp(q);
        }
        goto L14;
    }
    goto L2;
}

void parsePasswd(FILE* fp, int netrc)
{// addr = 0x0807A2E1  --  defined in 'etc.c' at line 1061
    Str line;              // _cfa_fffffff0
    Str arg;               // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    struct auth_pass ent;   // _cfa_ffffffc8
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    char* _v72;                            // _cfa_ffffffb8 (outparam)
    char* _t119;                           // _t119
    char* _t123;                           // _t123
    char* _t128;                           // _t128
    char* _t129;                           // _t129
    char* _t130;                           // _t130
    char* _t134;                           // _t134
    char* _t135;                           // _t135
    char* _t138;                           // _t138
    char* _t149;                           // _t149
    char* _t151;                           // _t151
    char* _t154;                           // _t154
    char* _t156;                           // _t156
    char* _t160;                           // _t160
    char* _t161;                           // _t161

    line = 0;
    _v72 = 32;
     *__esp =  &(ent.bad);
    bzero();
    while(1) {
        arg = 0;
        if(line == 0 || line->length == 0) {
            line = Strfgets(fp);
        }
        if(line->length == 0) {
            add_auth_pass_entry( &(ent.bad), netrc, 0);
            return;
        }
L6:
        Strchop(line);
        Strremovefirstspaces(line);
        p = line->ptr;
        if(( *p & 255) == 35 || ( *p & 255) == 0) {
            goto L8;
        }
L9:
        arg = next_token(line);
        _v72 = "machine";
        _t119 = p;
         *__esp = _t119;
        strcmp();
        if(_t119 == 0) {
L13:
            add_auth_pass_entry( &(ent.bad), netrc, 0);
            _v72 = 32;
             *__esp =  &(ent.bad);
            bzero();
            if(netrc != 0) {
                ent.port = 21;
            }
            _v72 = "default";
            _t123 = p;
             *__esp = _t123;
            strcmp();
            if(_t123 == 0) {
                line = arg;
            } else {
                line = next_token(arg);
                ent.host = arg;
            }
L49:
            while(1) {
                arg = 0;
                if(line == 0 || line->length == 0) {
                    line = Strfgets(fp);
                }
                if(line->length == 0) {
                    add_auth_pass_entry( &(ent.bad), netrc, 0);
                    return;
                }
L6:
                Strchop(line);
                Strremovefirstspaces(line);
                p = line->ptr;
                if(( *p & 255) == 35 || ( *p & 255) == 0) {
                    goto L8;
                }
                goto L9;
            }
            goto L8;
        }
        _v72 = "host";
        _t128 = p;
         *__esp = _t128;
        strcmp();
        if(_t128 == 0) {
            goto L13;
        }
        if(netrc == 0) {
L19:
            if(netrc != 0) {
L23:
                if(netrc != 0) {
L26:
                    if(netrc != 0) {
L29:
                        if(netrc != 0) {
L32:
                            _v72 = "login";
                            _t129 = p;
                             *__esp = _t129;
                            strcmp();
                            if(_t129 != 0) {
                                _v72 = "password";
                                _t130 = p;
                                 *__esp = _t130;
                                strcmp();
                                if(_t130 == 0) {
L36:
                                    line = next_token(arg);
                                    ent.pwd = arg;
                                    goto L49;
                                }
                                _v72 = "passwd";
                                _t134 = p;
                                 *__esp = _t134;
                                strcmp();
                                if(_t134 != 0) {
                                    if(netrc == 0) {
L45:
                                        if(netrc == 0) {
L48:
                                            line = 0;
                                            continue;
                                        }
                                        _v72 = "account";
                                        _t135 = p;
                                         *__esp = _t135;
                                        strcmp();
                                        if(_t135 != 0) {
                                            goto L48;
                                        }
                                        line = next_token(arg);
                                        goto L49;
                                    }
                                    _v72 = "machdef";
                                    _t138 = p;
                                     *__esp = _t138;
                                    strcmp();
                                    if(_t138 != 0) {
                                        goto L45;
                                    }
                                    while(1) {
                                        line = Strfgets(fp);
                                        if(line->length == 0) {
                                            break;
                                        }
                                        if((line & 255) == 10) {
L44:
                                            line = 0;
                                            goto L49;
                                        }
                                    }
                                    goto L44;
                                }
                                goto L36;
                            }
                            line = next_token(arg);
                            ent.uname = arg;
                            continue;
                        }
                        _v72 = "realm";
                        _t149 = p;
                         *__esp = _t149;
                        strcmp();
                        if(_t149 != 0) {
                            goto L32;
                        }
                        line = 0;
                        ent.realm = arg;
                        goto L49;
                    }
                    _v72 = "path";
                    _t151 = p;
                     *__esp = _t151;
                    strcmp();
                    if(_t151 != 0) {
                        goto L29;
                    }
                    line = next_token(arg);
                    goto L49;
                }
                _v72 = "proxy";
                _t154 = p;
                 *__esp = _t154;
                strcmp();
                if(_t154 != 0) {
                    goto L26;
                }
                ent.is_proxy = 1;
                line = arg;
                goto L49;
            }
            _v72 = "port";
            _t156 = p;
             *__esp = _t156;
            strcmp();
            if(_t156 != 0 || arg == 0) {
                goto L23;
            } else {
                line = next_token(arg);
                _t160 = arg->ptr;
                 *__esp = _t160;
                atoi();
                ent.port = _t160;
                goto L49;
            }
        }
        _v72 = "default";
        _t161 = p;
         *__esp = _t161;
        strcmp();
        if(_t161 != 0) {
            goto L19;
        }
        goto L13;
L8:
        line = 0;
        goto L49;
    }
}

FILE* openSecretFile(char* fname)
{// addr = 0x0807A631  --  defined in 'etc.c' at line 1146
    char* efname;                          // _cfa_fffffff0
    _unknown_ _v88;                        // _cfa_ffffffa8
    struct stat st;       // _cfa_ffffff98
    _unknown_ _v116;                       // _cfa_ffffff8c (outparam)
    char* _v120;                           // _cfa_ffffff88 (outparam)
    FILE* _t23;           // _t23
    FILE** _t29;          // _t29

    if(fname != 0) {
        efname = expandPath(fname);
        if(__stat(efname,  &(st.st_dev)) >= 0) {
            if(disable_secret_security_check != 0 || (st.st_mode & 63) == 0) {
                _t23 = efname;
                _v120 = 135048920;
                 *__esp = _t23;
                fopen();
                return _t23;
            } else {
                if((fmInitialized & 255) == 0) {
                    _v120 = fname;
                    _t29 = Sprintf("SECURITY NOTE: file %s must not be accessible by others");
                    _v120 = __imp__stderr;
                     *__esp =  *_t29;
                    fputs();
                    _v120 = __imp__stderr;
                     *__esp = 10;
                    fputc();
                } else {
                    _v120 = fname;
                    message( *(Sprintf("SECURITY NOTE: file %s must not be accessible by others")), 0, 0);
                    refresh();
                }
                 *__esp = 2;
                sleep();
                return 0;
            }
        }
        return 0;
    }
    return 0;
}

void loadPasswd()
{// addr = 0x0807A73A  --  defined in 'etc.c' at line 1185
    FILE* fp;             // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    passwords = 0;
    fp = openSecretFile(passwd_file);
    if(fp != 0) {
        parsePasswd(fp, 0);
         *__esp = fp;
        fclose();
    }
    fp = openSecretFile("~/.netrc");
    if(fp != 0) {
        parsePasswd(fp, 1);
         *__esp = fp;
        fclose();
        return;
    }
}

char* last_modified(Buffer* buf)
{// addr = 0x0807A7B3  --  defined in 'etc.c' at line 1207
    TextListItem* ti;   // _cfa_fffffff0
    struct stat st;       // _cfa_ffffff98
    intOrPtr _v116;                        // _cfa_ffffff8c
    char* _v120;                           // _cfa_ffffff88 (outparam)
    char* _t30;                            // _t30
    char* _t36;                            // _t36

    if(buf->document_header == 0) {
        if(buf->currentURL != 4) {
            return "unknown";
        }
        if(__stat(buf->currentURL.file,  &(st.st_dev)) >= 0) {
            _t30 =  &(( &(st.st_dev))[8]);
             *__esp = _t30;
            ctime();
            return _t30;
        }
        return "unknown";
    }
    ti = buf->document_header->first;
    while(ti != 0) {
        _t36 = ti->ptr;
        _v116 = 15;
        _v120 = "Last-modified: ";
         *__esp = _t36;
        strncasecmp();
        if(_t36 != 0) {
            ti = ti->next;
            continue;
        }
        return  &(ti->ptr[0xf]);
    }
    return "unknown";
}

Str romanNum2(int l, int n)
{// addr = 0x0807A85F  --  defined in 'etc.c' at line 1236
    Str s;                 // _cfa_fffffff0

    s = Strnew();
    if(n <= 9) {
        goto __eax;
    }
    return s;
}

Str romanNumeral(int n)
{// addr = 0x0807AAFB  --  defined in 'etc.c' at line 1268
    Str r;                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1

    r = Strnew();
    if(n > 0) {
        if(n <= 3999) {
            Strcat(r, romanNum2(3, (n * 274877907 >> 32 >> 6) - (n >> 31)));
            Strcat(r, romanNum2(2, ((n - ((n * 274877907 >> 32 >> 6) - (n >> 31)) * 1000) * 1374389535 >> 32 >> 5) - (n - ((n * 274877907 >> 32 >> 6) - (n >> 31)) * 1000 >> 31)));
            Strcat(r, romanNum2(1, ((n - ((n * 1374389535 >> 32 >> 5) - (n >> 31)) * 100) * 1717986919 >> 32 >> 2) - (n - ((n * 1374389535 >> 32 >> 5) - (n >> 31)) * 100 >> 31)));
            Strcat(r, romanNum2(0, n - (1717986919 << 2) + (n * 1717986919 >> 32 >> 2) - (n >> 31) + (1717986919 << 2) + (n * 1717986919 >> 32 >> 2) - (n >> 31)));
            return r;
        }
        Strcat_charp(r, 135048996);
        return r;
    }
    return r;
}

Str romanAlphabet(int n)
{// addr = 0x0807AC6D  --  defined in 'etc.c' at line 1287
    char[13] buf;                          // _cfa_ffffffe2
    signed int _v16;                       // _cfa_fffffff0
    Str r;                 // _cfa_ffffffdc
    int l;                                 // _cfa_ffffffd8
    _unknown_ __esi;                       // r5
    int _t75;                              // _t75
    struct _Str* _t81;    // _t81

    _v16 =  *gs:0x14];
    r = Strnew();
    if(n > 0) {
        l = 0;
        while(n != 0) {
             *(__ebp + l - 26) = n - 1 - (((n - 1) * 1321528399 >> 32 >> 3) - (_t83 >> 31)) * 26 + 97;
            l = l + 1;
            n = ((n - 1) * 1321528399 >> 32 >> 3) - (n - 1 >> 31);
        }
        l = l - 1;
        while(l >= 0) {
            if(r->length + 1 >= r->area_size) {
                Strgrow(r);
            }
            _t75 = r->length;
             *((char*)(r->ptr + _t75)) =  *(__ebp + l - 26) & 255;
            r->length = _t75 + 1;
             *((char*)(r->ptr + r->length)) = 0;
            l = l - 1;
        }
        _t81 = r;
    } else {
        _t81 = r;
    }
    if((_v16 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return _t81;
    }
    return _t81;
}

void reset_signals()
{// addr = 0x0807AD75  --  defined in 'etc.c' at line 1313
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    mySignal(1, 0);
    mySignal(2, 0);
    mySignal(3, 0);
    mySignal(15, 0);
    mySignal(4, 0);
    mySignal(6, 0);
    mySignal(8, 0);
    mySignal(7, 0);
    mySignal(17, 1);
    mySignal(13, 1);
}

void close_all_fds_except(int i, int f)
{// addr = 0x0807AE45  --  defined in 'etc.c' at line 1342
    intOrPtr _v24;                         // _cfa_ffffffe8
    int _t15;                              // _t15

    _t15 = i;
    if(_t15 == 1) {
L4:
        _v24 = 1;
         *__esp = "/dev/null";
        open();
        _v24 = 1;
         *__esp = _t15;
        dup2();
        goto L5;
    } else {
        if(_t15 == 2) {
L5:
            _v24 = 1;
             *__esp = "/dev/null";
            open();
            _v24 = 2;
             *__esp = _t15;
            dup2();
        } else {
            if(_t15 == 0) {
                _v24 = 0;
                 *__esp = "/dev/null";
                open();
                _v24 = 0;
                 *__esp = _t15;
                dup2();
                goto L4;
            }
        }
    }
    i = 3;
    while(i <= 15) {
        if(i != f) {
             *__esp = i;
            close();
        }
        i = i + 1;
    }
}

void setup_child(int child, int i, int f)
{// addr = 0x0807AEF0  --  defined in 'etc.c' at line 1360
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    reset_signals();
    mySignal(2, 1);
    if(child == 0) {
        setpgrp();
    }
    close_tty();
    close_all_fds_except(i, f);
    QuietMessage = 1;
    fmInitialized = 0;
    TrapSignal = 0;
}

pid_t open_pipe_rw(FILE** fr, FILE** fw)
{// addr = 0x0807AF48  --  defined in 'etc.c' at line 1377
    pid_t pid;           // _cfa_fffffff0
    int[1]* _v20;                          // _cfa_ffffffec
    int[1] fdr;                            // _cfa_ffffffe8
    FILE* _v28;           // _cfa_ffffffe4
    int[1] fdw;                            // _cfa_ffffffe0
    intOrPtr _v56;                         // _cfa_ffffffc8
    int[1]* _t39;                          // _t39
    FILE* _t49;           // _t49
    FILE* _t54;           // _t54

    if(fr == 0) {
L2:
        if(fw == 0) {
L4:
            flush_tty();
            fork();
            pid = _t39;
            if(pid < 0) {
                if(fw != 0) {
                     *__esp = fdw;
                    close();
                     *__esp = _v28;
                    close();
                }
L22:
                if(fr != 0) {
                     *__esp = fdr;
                    close();
                     *__esp = _v20;
                    close();
                }
L25:
                return -1;
            }
            if(pid != 0) {
                if(fr != 0) {
                     *__esp = _v20;
                    close();
                    if( *fr != __imp__stdin) {
                        _t54 = fdr;
                        _v56 = 135048920;
                         *__esp = _t54;
                        fdopen();
                         *fr = _t54;
                    } else {
                        _v56 = 0;
                         *__esp = fdr;
                        dup2();
                    }
                }
                if(fw != 0) {
                     *__esp = fdw;
                    close();
                    if( *fw != __imp__stdout) {
                        _t49 = _v28;
                        _v56 = 135049009;
                         *__esp = _t49;
                        fdopen();
                         *fw = _t49;
                    } else {
                        _v56 = 1;
                         *__esp = _v28;
                        dup2();
                    }
                }
            } else {
                if(fr != 0) {
                     *__esp = fdr;
                    close();
                    _v56 = 1;
                     *__esp = _v20;
                    dup2();
                }
                if(fw != 0) {
                     *__esp = _v28;
                    close();
                    _v56 = 0;
                     *__esp = fdw;
                    dup2();
                }
            }
            return pid;
        }
        _t39 =  &fdw;
         *__esp =  &fdw;
        pipe();
        if( &fdw < 0) {
            goto L22;
        }
        goto L4;
    }
    _t39 =  &fdr;
     *__esp =  &fdr;
    pipe();
    if( &fdr < 0) {
        goto L25;
    }
    goto L2;
}

void myExec(char* command)
{// addr = 0x0807B0D1  --  defined in 'etc.c' at line 1436
    char* _v0;                             // _cfa_0
    int _v28;                              // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    char* _t13;                            // _t13
    _unknown_ _t17;                        // _t17

    mySignal(2, 0);
    _v28 = 0;
    _t13 = command;
    _v32 = _t13;
    _v36 = 135049011;
    _v40 = 135049014;
     *__esp = "/bin/sh";
    execl();
     *__esp = 127;
    exit();
    _push(_t17);
    __esp = __esp - 24;
    if(_v36 == 0) {
         *__esp = _v0;
        system();
        return;
    }
    flush_tty();
    fork();
    if(_t13 == 0) {
        setup_child(0, 0, -1);
        myExec(_v0);
        return;
    }
}

void mySystem(char* command, int background)
{// addr = 0x0807B122  --  defined in 'etc.c' at line 1444
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(background == 0) {
         *__esp = command;
        system();
        return;
    }
    flush_tty();
    fork();
    if(__eax == 0) {
        setup_child(0, 0, -1);
        myExec(command);
        return;
    }
}

Str myExtCommand(char* cmd, char* arg, int redirect)
{// addr = 0x0807B172  --  defined in 'etc.c' at line 1466
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    int set_arg;                           // _cfa_ffffffe8
    int _v44;                              // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    int _t68;                              // _t68

    tmp = 0;
    set_arg = 0;
    p = cmd;
    while(( *p & 255) != 0) {
        if(( *p & 255) != 37 || (p[1] & 255) != 115 || set_arg != 0) {
            if(tmp != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t68 = tmp->length;
                 *((char*)(tmp->ptr + _t68)) =  *p & 255;
                tmp->length = _t68 + 1;
                 *((char*)(tmp->ptr + tmp->length)) = 0;
            }
        } else {
            if(tmp == 0) {
                tmp = Strnew_charp_n(cmd, p - cmd);
            }
            Strcat_charp(tmp, arg);
            set_arg = 1;
            p =  &(p[1]);
        }
        p =  &(p[1]);
    }
    if(set_arg == 0) {
        if(redirect == 0) {
            _v48 = 0;
            _v52 = arg;
            _v56 = 135049032;
            tmp = Strnew_m_charp(cmd);
        } else {
            _v44 = 0;
            _v48 = arg;
            _v52 = ") < ";
            _v56 = cmd;
            tmp = Strnew_m_charp(135049030);
        }
    }
    return tmp;
}

Str myEditor(char* cmd, char* file, int line)
{// addr = 0x0807B2BD  --  defined in 'etc.c' at line 1495
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    int set_file;                          // _cfa_ffffffe8
    int set_line;                          // _cfa_ffffffe4
    int _v32;                              // _cfa_ffffffe0
    char* _v36;                            // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8 (outparam)
    int _t90;                              // _t90
    char* _t119;                           // _t119

    tmp = 0;
    set_file = 0;
    set_line = 0;
    p = cmd;
L19:
    while(1) {
        if(( *p & 255) == 0) {
            if(set_file == 0) {
                if(tmp == 0) {
                    tmp = Strnew_charp(cmd);
                }
                if(set_line == 0 && line > 1) {
                    _v40 = 135049037;
                    _t119 = cmd;
                     *__esp = _t119;
                    strcasestr();
                    if(_t119 != 0) {
                        _v40 = line;
                        Strcat(tmp, Sprintf(135049040));
                    }
                }
                _v32 = 0;
                _v36 = file;
                _v40 = 135049032;
                Strcat_m_charp(tmp);
            }
            return tmp;
        }
        if(( *p & 255) != 37 || (p[1] & 255) != 115) {
L7:
            if(( *p & 255) != 37 || (p[1] & 255) != 100 || set_line != 0 || line <= 0) {
                if(tmp != 0) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t90 = tmp->length;
                     *((char*)(tmp->ptr + _t90)) =  *p & 255;
                    tmp->length = _t90 + 1;
                     *((char*)(tmp->ptr + tmp->length)) = 0;
                }
            } else {
                if(tmp == 0) {
                    tmp = Strnew_charp_n(cmd, p - cmd);
                }
                _v40 = line;
                Strcat(tmp, Sprintf(135049034));
                set_line = 1;
                p =  &(p[1]);
            }
            goto L18;
        } else {
            if(set_file != 0) {
                goto L7;
            } else {
                if(tmp == 0) {
                    tmp = Strnew_charp_n(cmd, p - cmd);
                }
                Strcat_charp(tmp, file);
                set_file = 1;
                p =  &(p[1]);
L18:
                p =  &(p[1]);
                continue;
            }
        }
    }
}

char* expandName(char* name)
{// addr = 0x0807B4A9  --  defined in 'etc.c' at line 1539
    char* p;                               // _cfa_fffffff0
    struct passwd* passent;   // _cfa_ffffffec
    Str extpath;           // _cfa_ffffffe8
    char* q;                               // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    char* _v36;                            // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    char* _t63;                            // _t63
    struct passwd* _t64;   // _t64
    char* _t71;                            // _t71
    struct passwd* _t83;   // _t83

    extpath = 0;
    if(name == 0) {
        return 0;
    }
    p = name;
    if(( *p & 255) != 47) {
        return expandPath(p);
    } else {
        if((p[1] & 255) != 126 || ( *( &MYCTYPE_MAP + (p[2] & 0xff)) & 4) == 0 || personal_document_root == 0) {
L19:
            return name;
        } else {
            p =  &(p[2]);
            _v40 = 47;
            _t63 = p;
             *__esp = _t63;
            strchr();
            q = _t63;
            if(q == 0) {
                _t64 = p;
                 *__esp = _t64;
                getpwnam();
                passent = _t64;
                p = 135049045;
            } else {
                _t83 = allocStr(p, q - p);
                 *__esp = _t83;
                getpwnam();
                passent = _t83;
                p = q;
            }
            if(passent == 0) {
                goto L19;
            } else {
                _v32 = 0;
                _v36 = personal_document_root;
                _v40 = 135049046;
                extpath = Strnew_m_charp(passent->pw_dir);
                if(( *personal_document_root & 255) == 0 && ( *p & 255) == 47) {
                    p =  &(p[1]);
                }
                _t71 = extpath->ptr;
                _v40 = 135049046;
                 *__esp = _t71;
                strcmp();
                if(_t71 == 0 && ( *p & 255) == 47) {
                    p =  &(p[1]);
                }
                Strcat_charp(extpath, p);
                return extpath->ptr;
            }
        }
    }
}

char* file_to_url(char* file)
{// addr = 0x0807B61E  --  defined in 'etc.c' at line 1584
    Str tmp;               // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t59;                              // _t59

    file = expandPath(file);
    if(( *file & 255) != 47) {
        tmp = Strnew_charp(CurrentDir);
        if(tmp->length <= 0 || ( *(tmp->ptr + tmp->length - 1) & 255) != 47) {
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t59 = tmp->length;
             *((char*)(tmp->ptr + _t59)) = 47;
            tmp->length = _t59 + 1;
             *((char*)(tmp->ptr + tmp->length)) = 0;
        }
        Strcat_charp(tmp, file);
        file = tmp->ptr;
    }
    tmp = Strnew_charp("file://");
    Strcat_charp(tmp, file_quote(cleanupName(file)));
    return tmp->ptr;
}

char* url_unquote_conv(char* url, wc_ces charset)
{// addr = 0x0807B70F  --  defined in 'etc.c' at line 1637
    wc_uint8 old_auto_detect;   // _cfa_fffffff3
    Str tmp;               // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    old_auto_detect = WcOption.auto_detect & 255;
    tmp = Str_url_unquote(Strnew_charp(url), 0, 1);
    if(charset == 0 || charset == 256) {
        charset = SystemCharset;
    }
    WcOption.auto_detect = 2;
    tmp = convertLine(0, tmp, 0,  &charset, charset);
    WcOption.auto_detect = old_auto_detect & 255;
    return tmp->ptr;
}

Str tmpfname(int type, char* ext)
{// addr = 0x0807B7A1  --  defined in 'etc.c' at line 1664
    Str tmpf;              // _cfa_fffffff0
    char* _v40;                            // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    char* _t21;                            // _t21
    intOrPtr _t27;                         // _t27
    signed int _t30;                       // _t30

    if(ext == 0) {
        _t21 = 135049045;
    } else {
        _t21 = ext;
    }
    _t30 = type;
    _t27 =  *((intOrPtr*)( &tmpf_seq + _t30 * 4));
     *((intOrPtr*)( &tmpf_seq + _t30 * 4)) = _t27 + 1;
    _v40 = _t21;
    _v44 = _t27;
    _v48 = CurrentPid;
    _v52 =  *((intOrPtr*)( &tmpf_base + type * 4));
    _v56 = tmp_dir;
    tmpf = Sprintf("%s/w3m%s%d-%d%s");
    pushValue(fileToDelete, allocStr(tmpf->ptr, -1));
    return tmpf;
}

int get_day(char** s)
{// addr = 0x0807B839  --  defined in 'etc.c' at line 1681
    Str tmp;               // _cfa_fffffff0
    int day;                               // _cfa_ffffffec
    char* ss;                              // _cfa_ffffffe8

    tmp = Strnew();
    ss =  *s;
    if(( *( *s) & 255) != 0) {
        while(1) {
            s =  *s;
            if(__al == 0) {
                break;
            }
            s =  *s;
            __eax =  *( *s) & 255;
            __eax =  *( &MYCTYPE_MAP + __eax) & 255;
            __eax = __al & 255;
            if(__eax != 0) {
                tmp = tmp->length;
                __edx = tmp->length + 1;
                tmp = tmp->area_size;
                if(tmp->length + 1 >= tmp->area_size) {
                    __eax = tmp;
                    Strgrow(tmp);
                }
                __eax = tmp;
                __ecx = tmp->ptr;
                __eax = tmp;
                __edx = tmp->length;
                __edx = s;
                __eax =  *s;
                __edx[tmp->ptr] = __cl;
                __ecx =  &(__edx[1]);
                __edx = tmp;
                tmp->length = __ecx;
                __edx = __eax + 1;
                __eax = s;
                 *s = __edx;
                __eax = tmp;
                __edx = tmp->ptr;
                tmp = tmp->length;
                __eax = tmp->ptr + tmp->length;
                 *(tmp->ptr + tmp->length) = 0;
                continue;
            }
            break;
        }
        __eax = tmp;
        __eax = tmp->ptr;
         *__esp = __eax;
        atoi();
        day = __eax;
        if(day <= 0 || day > 31) {
            __eax = s;
            __edx = ss;
             *s = ss;
            __eax = -1;
            return -1;
        } else {
            __eax = day;
            return day;
        }
    }
    return -1;
}

int get_month(char** s)
{// addr = 0x0807B923  --  defined in 'etc.c' at line 1703
    Str tmp;               // _cfa_fffffff0
    int mon;                               // _cfa_ffffffec
    char* ss;                              // _cfa_ffffffe8
    intOrPtr _v36;                         // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8

    tmp = Strnew();
    ss =  *s;
    if(( *( *s) & 255) != 0) {
        while(1) {
            s =  *s;
            if(__al == 0) {
                break;
            }
            s =  *s;
            __eax =  *( *s) & 255;
            __eax =  *( &MYCTYPE_MAP + __eax) & 255;
            __eax = __al & 255;
            if(__eax != 0) {
                tmp = tmp->length;
                __edx = tmp->length + 1;
                tmp = tmp->area_size;
                if(tmp->length + 1 >= tmp->area_size) {
                    __eax = tmp;
                    Strgrow(tmp);
                }
                __eax = tmp;
                __ecx = tmp->ptr;
                __eax = tmp;
                __edx = tmp->length;
                __edx = s;
                __eax =  *s;
                __edx[tmp->ptr] = __cl;
                __ecx =  &(__edx[1]);
                __edx = tmp;
                tmp->length = __ecx;
                __edx = __eax + 1;
                __eax = s;
                 *s = __edx;
                __eax = tmp;
                __edx = tmp->ptr;
                tmp = tmp->length;
                __eax = tmp->ptr + tmp->length;
                 *(tmp->ptr + tmp->length) = 0;
                continue;
            }
            break;
        }
        tmp = tmp->length;
        if(tmp->length <= 0) {
            while(1) {
                s =  *s;
                if(__al == 0) {
                    break;
                }
                s =  *s;
                __eax =  *( *s) & 255;
                __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                __eax = __al & 255;
                if(__eax != 0) {
                    tmp = tmp->length;
                    __edx = tmp->length + 1;
                    tmp = tmp->area_size;
                    if(tmp->length + 1 >= tmp->area_size) {
                        __eax = tmp;
                        Strgrow(tmp);
                    }
                    __eax = tmp;
                    __ecx = tmp->ptr;
                    __eax = tmp;
                    __edx = tmp->length;
                    __edx = s;
                    __eax =  *s;
                    __edx[tmp->ptr] = __cl;
                    __ecx =  &(__edx[1]);
                    __edx = tmp;
                    tmp->length = __ecx;
                    __edx = __eax + 1;
                    __eax = s;
                     *s = __edx;
                    __eax = tmp;
                    __edx = tmp->ptr;
                    tmp = tmp->length;
                    __eax = tmp->ptr + tmp->length;
                     *(tmp->ptr + tmp->length) = 0;
                    continue;
                }
                break;
            }
            mon = 1;
            while(mon <= 12) {
                mon = mon - 1;
                __edx =  *( &monthtbl + (mon - 1) * 4);
                __eax = tmp;
                __eax = tmp->ptr;
                _v36 = 3;
                _v40 =  *( &monthtbl + (mon - 1) * 4);
                 *__esp = __eax;
                strncmp();
                if(__eax == 0) {
L22:
                    if(mon <= 0 || mon > 12) {
                        __eax = s;
                        __edx = ss;
                         *s = ss;
                        __eax = -1;
                        return -1;
                    } else {
                        __eax = mon;
                        return mon;
                    }
                }
                mon = mon + 1;
            }
            goto L22;
        }
        __eax = tmp;
        __eax = tmp->ptr;
         *__esp = __eax;
        atoi();
        mon = __eax;
        goto L22;
    }
    return -1;
}

int get_year(char** s)
{// addr = 0x0807BAE5  --  defined in 'etc.c' at line 1733
    Str tmp;               // _cfa_fffffff0
    int year;                              // _cfa_ffffffec
    char* ss;                              // _cfa_ffffffe8

    tmp = Strnew();
    ss =  *s;
    if(( *( *s) & 255) != 0) {
        while(1) {
            s =  *s;
            if(__al == 0) {
                break;
            }
            s =  *s;
            __eax =  *( *s) & 255;
            __eax =  *( &MYCTYPE_MAP + __eax) & 255;
            __eax = __al & 255;
            if(__eax != 0) {
                tmp = tmp->length;
                __edx = tmp->length + 1;
                tmp = tmp->area_size;
                if(tmp->length + 1 >= tmp->area_size) {
                    __eax = tmp;
                    Strgrow(tmp);
                }
                __eax = tmp;
                __ecx = tmp->ptr;
                __eax = tmp;
                __edx = tmp->length;
                __edx = s;
                __eax =  *s;
                __edx[tmp->ptr] = __cl;
                __ecx =  &(__edx[1]);
                __edx = tmp;
                tmp->length = __ecx;
                __edx = __eax + 1;
                __eax = s;
                 *s = __edx;
                __eax = tmp;
                __edx = tmp->ptr;
                tmp = tmp->length;
                __eax = tmp->ptr + tmp->length;
                 *(tmp->ptr + tmp->length) = 0;
                continue;
            }
            break;
        }
        tmp = tmp->length;
        if(tmp->length == 2) {
L11:
            __eax = tmp;
            __eax = tmp->ptr;
             *__esp = __eax;
            atoi();
            year = __eax;
            tmp = tmp->length;
            if(tmp->length == 2) {
                if(year <= 69) {
                    year = year + 2000;
                } else {
                    year = year + 1900;
                }
            }
            __eax = year;
            return year;
        }
        tmp = tmp->length;
        if(tmp->length == 4) {
            goto L11;
        }
        __eax = s;
        __edx = ss;
         *s = ss;
        __eax = -1;
        return -1;
    }
    return -1;
}

int get_time(char** s, int* hour, int* min, int* sec)
{// addr = 0x0807BBFA  --  defined in 'etc.c' at line 1760
    Str tmp;               // _cfa_fffffff0
    char* ss;                              // _cfa_ffffffec

    tmp = Strnew();
    ss =  *s;
    if(( *( *s) & 255) != 0) {
        while(1) {
            s =  *s;
            if(__al == 0) {
                break;
            }
            s =  *s;
            __eax =  *( *s) & 255;
            __eax =  *( &MYCTYPE_MAP + __eax) & 255;
            __eax = __al & 255;
            if(__eax != 0) {
                tmp = tmp->length;
                __edx = tmp->length + 1;
                tmp = tmp->area_size;
                if(tmp->length + 1 >= tmp->area_size) {
                    __eax = tmp;
                    Strgrow(tmp);
                }
                __eax = tmp;
                __ecx = tmp->ptr;
                __eax = tmp;
                __edx = tmp->length;
                __edx = s;
                __eax =  *s;
                __edx[tmp->ptr] = __cl;
                __ecx =  &(__edx[1]);
                __edx = tmp;
                tmp->length = __ecx;
                __edx = __eax + 1;
                __eax = s;
                 *s = __edx;
                __eax = tmp;
                __edx = tmp->ptr;
                tmp = tmp->length;
                __eax = tmp->ptr + tmp->length;
                 *(tmp->ptr + tmp->length) = 0;
                continue;
            }
            break;
        }
        s =  *s;
        if(__al == 58) {
            __eax = tmp;
            __eax = tmp->ptr;
             *__esp = __eax;
            atoi();
            __edx = hour;
             *hour = __eax;
            s =  *s;
            __edx =  &(( *s)[1]);
            __eax = s;
             *s =  &(( *s)[1]);
            __eax = tmp;
            Strclear(tmp);
            while(1) {
                s =  *s;
                if(__al == 0) {
                    break;
                }
                s =  *s;
                __eax =  *( *s) & 255;
                __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                __eax = __al & 255;
                if(__eax != 0) {
                    tmp = tmp->length;
                    __edx = tmp->length + 1;
                    tmp = tmp->area_size;
                    if(tmp->length + 1 >= tmp->area_size) {
                        __eax = tmp;
                        Strgrow(tmp);
                    }
                    __eax = tmp;
                    __ecx = tmp->ptr;
                    __eax = tmp;
                    __edx = tmp->length;
                    __edx = s;
                    __eax =  *s;
                    __edx[tmp->ptr] = __cl;
                    __ecx =  &(__edx[1]);
                    __edx = tmp;
                    tmp->length = __ecx;
                    __edx = __eax + 1;
                    __eax = s;
                     *s = __edx;
                    __eax = tmp;
                    __edx = tmp->ptr;
                    tmp = tmp->length;
                    __eax = tmp->ptr + tmp->length;
                     *(tmp->ptr + tmp->length) = 0;
                    continue;
                }
                break;
            }
            s =  *s;
            if(__al == 58) {
                __eax = tmp;
                __eax = tmp->ptr;
                 *__esp = __eax;
                atoi();
                __edx = min;
                 *min = __eax;
                s =  *s;
                __edx =  &(( *s)[1]);
                __eax = s;
                 *s =  &(( *s)[1]);
                __eax = tmp;
                Strclear(tmp);
                while(1) {
                    s =  *s;
                    if(__al == 0) {
                        break;
                    }
                    s =  *s;
                    __eax =  *( *s) & 255;
                    __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                    __eax = __al & 255;
                    if(__eax != 0) {
                        tmp = tmp->length;
                        __edx = tmp->length + 1;
                        tmp = tmp->area_size;
                        if(tmp->length + 1 >= tmp->area_size) {
                            __eax = tmp;
                            Strgrow(tmp);
                        }
                        __eax = tmp;
                        __ecx = tmp->ptr;
                        __eax = tmp;
                        __edx = tmp->length;
                        __edx = s;
                        __eax =  *s;
                        __edx[tmp->ptr] = __cl;
                        __ecx =  &(__edx[1]);
                        __edx = tmp;
                        tmp->length = __ecx;
                        __edx = __eax + 1;
                        __eax = s;
                         *s = __edx;
                        __eax = tmp;
                        __edx = tmp->ptr;
                        tmp = tmp->length;
                        __eax = tmp->ptr + tmp->length;
                         *(tmp->ptr + tmp->length) = 0;
                        continue;
                    }
                    break;
                }
                __eax = tmp;
                __eax = tmp->ptr;
                 *__esp = __eax;
                atoi();
                __edx = sec;
                 *sec = __eax;
                hour =  *hour;
                if( *hour < 0) {
L30:
                    __eax = s;
                    __edx = ss;
                     *s = ss;
                    __eax = -1;
                    return -1;
                }
                hour =  *hour;
                if( *hour > 23) {
                    goto L30;
                }
                min =  *min;
                if( *min < 0) {
                    goto L30;
                }
                min =  *min;
                if( *min > 59) {
                    goto L30;
                }
                sec =  *sec;
                if( *sec < 0) {
                    goto L30;
                }
                sec =  *sec;
                if( *sec <= 59) {
                    __eax = 0;
                    return 0;
                }
                goto L30;
            }
            __eax = s;
            __edx = ss;
             *s = ss;
            __eax = -1;
            return -1;
        }
        __eax = s;
        __edx = ss;
         *s = ss;
        __eax = -1;
        return -1;
    }
    return -1;
}

int get_zone(char** s, int* z_hour, int* z_min)
{// addr = 0x0807BEB5  --  defined in 'etc.c' at line 1801
    Str tmp;               // _cfa_fffffff0
    int zone;                              // _cfa_ffffffec
    char* ss;                              // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    char* _t91;                            // _t91
    int _t109;                             // _t109
    char* _t146;                           // _t146
    int _t171;                             // _t171
    int _t187;                             // _t187

    tmp = Strnew();
    ss =  *s;
    if(( *( *s) & 255) == 0) {
        return -1;
    }
    if(( *( *s) & 255) == 43 || ( *( *s) & 255) == 45) {
        if(tmp->length + 1 >= tmp->area_size) {
            Strgrow(tmp);
        }
        _t171 = tmp->length;
        _t91 =  *s;
         *((char*)(tmp->ptr + _t171)) =  *_t91 & 255;
        tmp->length = _t171 + 1;
         *s =  &(_t91[1]);
         *((char*)(tmp->ptr + tmp->length)) = 0;
L11:
        while(( *( *s) & 255) != 0 && ( *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 8) != 0) {
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t187 = tmp->length;
            _t146 =  *s;
             *((char*)(tmp->ptr + _t187)) =  *_t146 & 255;
            tmp->length = _t187 + 1;
             *s =  &(_t146[1]);
             *((char*)(tmp->ptr + tmp->length)) = 0;
        }
        if(tmp->length != 4 || ( *( &MYCTYPE_MAP + ( *ss & 0xff)) & 8) == 0) {
            if(tmp->length != 5 || ( *ss & 255) != 43 && ( *ss & 255) != 45) {
                 *s = ss;
                return -1;
            } else {
                goto L19;
            }
        } else {
L19:
            _t109 = tmp->ptr;
             *__esp = _t109;
            atoi();
            zone = _t109;
             *z_hour = (zone * 1374389535 >> 32 >> 5) - (zone >> 31);
             *z_min = zone - ((zone * 1374389535 >> 32 >> 5) - (_t166 >> 31)) * 100;
            return 0;
        }
    } else {
    }
    goto L11;
}

time_t mymktime(char* timestr)
{// addr = 0x0807C094  --  defined in 'etc.c' at line 1828
    char* s;                               // _cfa_fffffff0
    int day;                               // _cfa_ffffffec
    int mon;                               // _cfa_ffffffe8
    int year;                              // _cfa_ffffffe4
    int hour;                              // _cfa_ffffffe0
    int min;                               // _cfa_ffffffdc
    int sec;                               // _cfa_ffffffd8
    int z_hour;                            // _cfa_ffffffd4
    int z_min;                             // _cfa_ffffffd0
    int* _v64;                             // _cfa_ffffffc0
    int* _v68;                             // _cfa_ffffffbc
    int* _v72;                             // _cfa_ffffffb8

    z_hour = 0;
    z_min = 0;
    if(timestr == 0 || ( *timestr & 255) == 0) {
        return -1;
    }
    s = timestr;
    while(( *s & 255) != 0) {
        if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 4) != 0) {
            s =  &(s[1]);
            continue;
        }
L10:
        while(( *s & 255) != 0 && ( *( &MYCTYPE_MAP + ( *s & 0xff)) & 0xc) == 0) {
            s =  &(s[1]);
        }
        if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 8) == 0) {
            while(1) {
                s =  *s & 255;
                if(__al == 0) {
                    break;
                }
                s =  *s & 255;
                __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                __eax = __al & 255;
                if(__eax == 0) {
                    s =  &(s[1]);
                    s =  &(s[1]);
                    continue;
                }
                break;
            }
            __eax =  &s;
            mon = get_month( &s);
            if(mon != -1) {
                while(1) {
                    s =  *s & 255;
                    if(__al == 0) {
                        break;
                    }
                    s =  *s & 255;
                    __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                    __eax = __al & 255;
                    if(__eax == 0) {
                        s =  &(s[1]);
                        s =  &(s[1]);
                        continue;
                    }
                    break;
                }
                __eax =  &s;
                day = get_day( &s);
                if(day != -1) {
                    while(1) {
                        s =  *s & 255;
                        if(__al == 0) {
                            break;
                        }
                        s =  *s & 255;
                        __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                        __eax = __al & 255;
                        if(__eax == 0) {
                            s =  &(s[1]);
                            s =  &(s[1]);
                            continue;
                        }
                        break;
                    }
                    __eax =  &sec;
                    _v64 =  &sec;
                    __eax =  &min;
                    _v68 =  &min;
                    __eax =  &hour;
                    _v72 =  &hour;
                    __eax =  &s;
                     *__esp =  &s;
                    if(get_time() != -1) {
                        while(1) {
                            s =  *s & 255;
                            if(__al == 0) {
                                break;
                            }
                            s =  *s & 255;
                            __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                            __eax = __al & 255;
                            if(__eax == 0) {
                                s =  &(s[1]);
                                s =  &(s[1]);
                                continue;
                            }
                            break;
                        }
                        __eax =  &s;
                        year = get_year( &s);
                        if(year != -1) {
L66:
                            mon = mon - 3;
                            if(mon < 0) {
                                mon = mon + 12;
                                year = year - 1;
                            }
                            year = year * 1461;
                            __eax = year * 1461 - 2875248;
                            __edx = __eax + 3;
                            __eax = __eax < 0 ? __eax + 3 : __eax;
                            day = day + __eax;
                            mon = mon * 153;
                            __ecx = 2 + mon * 153;
                            __edx = 1717986919;
                            __eax = __ecx;
                            __edx = __eax * 1717986919 >> 32;
                            __eax = __eax * 1717986919;
                            __edx = __edx >> 1;
                            __eax = __ecx;
                            __eax = __ecx >> 31;
                            __eax = __edx - __eax;
                            day = day + __eax;
                            __edx = hour;
                            z_hour = hour - z_hour;
                            hour = hour - z_hour;
                            __edx = min;
                            __eax = z_min;
                            min = min - z_min;
                            __eax = min - z_min;
                            min = min - z_min;
                            __eax = day;
                            __edx = day * 86400;
                            hour = hour * 3600;
                            __edx = day * 86400 + hour * 3600;
                            __eax = min;
                            __eax = min << 2;
                            __eax = __eax << 4;
                            __edx = day * 86400 + hour * 3600 + __eax;
                            sec = __edx + sec;
                            return __edx + sec;
                        }
                        __eax = -1;
                        return -1;
                    }
                    __eax = -1;
                    return -1;
                }
                __eax = -1;
                return -1;
            }
            __eax = -1;
            return -1;
        }
        day = get_day( &s);
        if(day != -1) {
            while(1) {
                s =  *s & 255;
                if(__al == 0) {
                    break;
                }
                s =  *s & 255;
                __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                __eax = __al & 255;
                if(__eax == 0) {
                    s =  &(s[1]);
                    s =  &(s[1]);
                    continue;
                }
                break;
            }
            __eax =  &s;
            mon = get_month( &s);
            if(mon != -1) {
                while(1) {
                    s =  *s & 255;
                    if(__al == 0) {
                        break;
                    }
                    s =  *s & 255;
                    __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                    __eax = __al & 255;
                    if(__eax == 0) {
                        s =  &(s[1]);
                        s =  &(s[1]);
                        continue;
                    }
                    break;
                }
                __eax =  &s;
                year = get_year( &s);
                if(year != -1) {
                    while(1) {
                        s =  *s & 255;
                        if(__al == 0) {
                            break;
                        }
                        s =  *s & 255;
                        __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                        __eax = __al & 255;
                        if(__eax == 0) {
                            s =  &(s[1]);
                            s =  &(s[1]);
                            continue;
                        }
                        break;
                    }
                    s =  *s & 255;
                    if(__al != 0) {
                        __eax =  &sec;
                        _v64 =  &sec;
                        __eax =  &min;
                        _v68 =  &min;
                        __eax =  &hour;
                        _v72 =  &hour;
                        __eax =  &s;
                         *__esp =  &s;
                        if(get_time() != -1) {
                            while(1) {
                                s =  *s & 255;
                                if(__al == 0) {
                                    break;
                                }
                                s =  *s & 255;
                                __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                                __eax = __al & 255;
                                if(__eax != 0) {
                                    break;
                                }
                                s =  *s & 255;
                                if(__al == 43) {
                                    break;
                                }
                                s =  *s & 255;
                                if(__al != 45) {
                                    s =  &(s[1]);
                                    s =  &(s[1]);
                                    continue;
                                }
                                break;
                            }
                            __eax =  &z_min;
                            _v68 =  &z_min;
                            __eax =  &z_hour;
                            _v72 =  &z_hour;
                            __eax =  &s;
                             *__esp =  &s;
                            __eax = get_zone();
                            goto L66;
                        }
                        __eax = -1;
                        return -1;
                    }
                    hour = 0;
                    min = 0;
                    sec = 0;
                    goto L66;
                }
                __eax = -1;
                return -1;
            }
            __eax = -1;
            return -1;
        }
        return -1;
    }
    goto L10;
}

char* FQDN(char* host)
{// addr = 0x0807C4D9  --  defined in 'etc.c' at line 1927
    char* p;                               // _cfa_fffffff0
    int* af;                               // _cfa_ffffffec
    int error;                             // _cfa_ffffffe8
    struct addrinfo* res;   // _cfa_ffffffe4
    struct addrinfo* res0;   // _cfa_ffffffe0
    char* namebuf;                         // _cfa_ffffffdc
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    struct addrinfo hints;   // _cfa_ffffffbc
    struct addrinfo** _v80;   // _cfa_ffffffb0
    int* _v84;                             // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    char* _t48;                            // _t48
    int _t63;                              // _t63
    char* _t73;                            // _t73

    if(host != 0) {
        _v88 = "localhost";
        _t48 = host;
         *__esp = _t48;
        strcasecmp();
        if(_t48 != 0) {
            p = host;
            while(( *p & 255) != 0 && ( *p & 255) != 46) {
                p =  &(p[1]);
            }
            if(( *p & 255) != 46) {
                af =  &ai_family_order_table + (DNS_order + DNS_order + _t86 << 2);
                while(1) {
                    _v84 = 32;
                    _v88 = 0;
                     *__esp =  &(hints.ai_flags);
                    memset();
                    hints.ai_flags = 2;
                    hints.ai_family =  *af;
                    hints.ai_socktype = 1;
                    _t63 = host;
                    _v80 =  &res0;
                    _v84 =  &(hints.ai_flags);
                    _v88 = 0;
                     *__esp = _t63;
                    getaddrinfo();
                    error = _t63;
                    if(error == 0) {
                        goto L14;
                    }
                    if( *af != 0) {
L22:
                        af =  &(af[1]);
                        continue;
                    }
L24:
                    return 0;
L14:
                    res = res0;
                    while(res != 0) {
                        if(res->ai_canonname == 0) {
                            res = res->ai_next;
                            continue;
                        }
                        _t73 = res->ai_canonname;
                         *__esp = _t73;
                        strdup();
                        namebuf = _t73;
                         *__esp = res0;
                        freeaddrinfo();
                        return namebuf;
                    }
                     *__esp = res0;
                    freeaddrinfo();
                    if( *af == 0) {
                        goto L24;
                    }
                    goto L22;
                }
            }
            return host;
        }
        return host;
    }
    return 0;
}

_None* mySignal(int signal_number, _None* action)
{// addr = 0x0807C62B  --  defined in 'etc.c' at line 1992
    _unknown_ _v20;                        // _cfa_ffffffec
    struct sigaction new_action;   // _cfa_ffffff68
    struct sigaction old_action;   // _cfa_fffffedc
    union * _v308;            // _cfa_fffffecc
    union * _v312;            // _cfa_fffffec8

     *__esp =  &(new_action.__sigaction_handler) + 4;
    sigemptyset();
    new_action.__sigaction_handler = action;
    if(signal_number != 14) {
        new_action.sa_flags = 268435456;
    } else {
        new_action.sa_flags = 536870912;
    }
    _v308 =  &(old_action.__sigaction_handler);
    _v312 =  &(new_action.__sigaction_handler);
     *__esp = signal_number;
    sigaction();
    return old_action.__sigaction_handler;
}

void set_mark(Line* l, int pos, int epos)
{// addr = 0x0807C68C  --  defined in 'search.c' at line 9
    while(pos < epos && l->size > pos) {
         *(l->propBuf + pos + pos) =  *(l->propBuf + pos + pos) & 65535 | 1;
        pos = pos + 1;
    }
}

void init_migemo()
{// addr = 0x0807C6CE  --  defined in 'search.c' at line 22
    intOrPtr _v24;                         // _cfa_ffffffe8

    migemo_running = use_migemo;
    migemo_active = migemo_running;
    if(migemor != 0) {
         *__esp = migemor;
        fclose();
    }
    if(migemow != 0) {
         *__esp = migemow;
        fclose();
    }
    migemow = 0;
    migemor = migemow;
    if(migemo_pid != 0) {
        _v24 = 9;
         *__esp = migemo_pid;
        kill();
    }
    migemo_pid = 0;
}

int open_migemo(char* migemo_command)
{// addr = 0x0807C752  --  defined in 'search.c' at line 36
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    migemo_pid = open_pipe_rw( &migemor,  &migemow);
    if(migemo_pid < 0) {
        migemo_pid = 0;
        migemo_running = 0;
        migemo_active = migemo_running;
        return 0;
    }
    if(migemo_pid == 0) {
        setup_child(0, 2, -1);
        myExec(migemo_command);
    }
    return 1;
}

char* migemostr(char* str)
{// addr = 0x0807C7D7  --  defined in 'search.c' at line 55
    Str tmp;               // _cfa_fffffff0
    intOrPtr _v36;                         // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    FILE* _t24;           // _t24

    tmp = 0;
    if(migemor == 0 || migemow == 0) {
        if(open_migemo(migemo_command) != 0) {
            goto L4;
        }
        return str;
    } else {
L4:
        _v36 =  *(wc_Str_conv_strict(Strnew_charp(str), InnerCharset, SystemCharset));
        _v40 = "%s\n";
         *__esp = migemow;
        fprintf();
        while(1) {
            _t24 = migemow;
             *__esp = _t24;
            fflush();
            if(_t24 == 0) {
                break;
            }
            __errno_location();
            if(_t24->_flags == 4) {
                continue;
            }
L12:
            init_migemo();
            migemo_running = 0;
            migemo_active = migemo_running;
            return str;
        }
        tmp = wc_Str_conv(Strfgets(migemor), SystemCharset, InnerCharset);
        Strchop(tmp);
        if(tmp->length == 0) {
            goto L12;
        }
        return conv_search_string(tmp->ptr, SystemCharset);
    }
}

char* conv_search_string(char* str, wc_ces f_ces)
{// addr = 0x0807C8F4  --  defined in 'search.c' at line 87
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if((SearchConv & 255) != 0 && ( *135119012 & 255) == 0 && CurrentTab->currentBuffer->document_charset != f_ces) {
        str = wtf_conv_fit(str, CurrentTab->currentBuffer->document_charset);
    }
    return str;
}

int forwardSearch(Buffer* buf, char* str)
{// addr = 0x0807C948  --  defined in 'search.c' at line 97
    char* p;                               // _cfa_fffffff0
    char* first;                           // _cfa_ffffffec
    char* last;                            // _cfa_ffffffe8
    Line* l;              // _cfa_ffffffe4
    Line* begin;          // _cfa_ffffffe0
    int wrapped;                           // _cfa_ffffffdc
    int pos;                               // _cfa_ffffffd8
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    int _t231;                             // _t231

    wrapped = 0;
    if(migemo_active <= 0) {
        p = regexCompile(str, IgnoreCase);
        if(p == 0) {
            goto L6;
        } else {
            message(p, 0, 0);
            return 2;
        }
    }
    p = regexCompile(migemostr(str), IgnoreCase);
    if(p == 0) {
L6:
        l = buf->currentLine;
        if(l == 0) {
            return 2;
        }
        pos = buf->pos;
        if(l->bpos == 0) {
L13:
            begin = l;
            while(l->size > pos && ( *(l->propBuf + pos + pos) & 0x400) != 0) {
                pos = pos + 1;
            }
            if(l->size <= pos || regexMatch(l->lineBuf + pos, l->size - pos, 0) != 1) {
                l = l->next;
L28:
                while(1) {
                    if(l != 0) {
L36:
                        if(l->bpos != 0) {
L51:
                            l = l->next;
                            continue;
                        }
                        if(regexMatch(l->lineBuf, l->size, 1) != 1) {
                            if(wrapped == 0) {
                                goto L51;
                            }
                            if(l == begin) {
L54:
                                return 2;
                            }
                            goto L51;
                        }
                        matchedPosition( &first,  &last);
                        pos = first - l->lineBuf;
                        while(l->len <= pos && l->next != 0 && l->next->bpos != 0) {
                            pos = pos - l->len;
                            l = l->next;
                        }
                        buf->pos = pos;
                        buf->currentLine = l;
                        gotoLine(buf, l->linenumber);
                        arrangeCursor(buf);
                        set_mark(l, pos,  &(last[pos]) - first);
                        if(wrapped == 0) {
                            _t231 = 1;
                        } else {
                            _t231 = 5;
                        }
                        return _t231;
                    }
                    if(buf->pagerSource == 0) {
                        if(WrapSearch == 0) {
                            goto L54;
                        }
                        l = buf->firstLine;
                        wrapped = 1;
                        goto L36;
                    }
                    l = getNextPage(buf, 1);
                    if(l != 0) {
                        goto L36;
                    }
                    if(WrapSearch == 0 || wrapped != 0) {
                        goto L54;
                    } else {
                        l = buf->firstLine;
                        wrapped = 1;
                        goto L36;
                    }
                }
            } else {
                matchedPosition( &first,  &last);
                pos = first - l->lineBuf;
                while(l->len <= pos && l->next != 0 && l->next->bpos != 0) {
                    pos = pos - l->len;
                    l = l->next;
                }
                buf->pos = pos;
                if(buf->currentLine != l) {
                    gotoLine(buf, l->linenumber);
                }
                arrangeCursor(buf);
                set_mark(l, pos,  &(last[pos]) - first);
                return 1;
            }
        } else {
            pos = pos + l->bpos;
            while(l->bpos != 0 && l->prev != 0) {
                l = l->prev;
            }
            goto L13;
        }
    } else {
        p = regexCompile(str, IgnoreCase);
        if(p == 0) {
            goto L6;
        } else {
            message(p, 0, 0);
            return 2;
        }
    }
}

int backwardSearch(Buffer* buf, char* str)
{// addr = 0x0807CD41  --  defined in 'search.c' at line 192
    char* p;                               // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    char* found;                           // _cfa_ffffffe8
    char* found_last;                      // _cfa_ffffffe4
    char* first;                           // _cfa_ffffffe0
    char* last;                            // _cfa_ffffffdc
    Line* l;              // _cfa_ffffffd8
    Line* begin;          // _cfa_ffffffd4
    int wrapped;                           // _cfa_ffffffd0
    int pos;                               // _cfa_ffffffcc
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t286;                             // _t286

    wrapped = 0;
    if(migemo_active <= 0) {
        p = regexCompile(str, IgnoreCase);
        if(p == 0) {
            goto L6;
        } else {
            message(p, 0, 0);
            return 2;
        }
    }
    p = regexCompile(migemostr(str), IgnoreCase);
    if(p == 0) {
L6:
        l = buf->currentLine;
        if(l == 0) {
            return 2;
        }
        pos = buf->pos;
        if(l->bpos == 0) {
L13:
            begin = l;
            if(pos <= 0) {
L40:
                l = l->prev;
L41:
                while(1) {
L41:
                    if(l != 0) {
L44:
                        found = 0;
                        found_last = 0;
                        q = l->lineBuf;
                        while(regexMatch(q, l->lineBuf + l->size - q, l->lineBuf == q & 255) == 1) {
                            matchedPosition( &first,  &last);
                            found = first;
                            found_last = last;
                            if(q - l->lineBuf >= l->size) {
L53:
                                if(found == 0) {
                                    if(wrapped == 0 || l != begin) {
                                        l = l->prev;
                                        goto L41;
                                    } else {
L68:
                                        return 2;
                                    }
                                }
                                pos = found - l->lineBuf;
                                while(l->len <= pos && l->next != 0 && l->next->bpos != 0) {
                                    pos = pos - l->len;
                                    l = l->next;
                                }
                                buf->pos = pos;
                                gotoLine(buf, l->linenumber);
                                arrangeCursor(buf);
                                set_mark(l, pos,  &(found_last[pos]) - found);
                                if(wrapped == 0) {
                                    _t286 = 1;
                                } else {
                                    _t286 = 5;
                                }
                                return _t286;
                            }
                            q =  &(q[1]);
                            while(q - l->lineBuf < l->size && ( *(l->propBuf + q - l->lineBuf + q - l->lineBuf) & 0x400) != 0) {
                                q =  &(q[1]);
                            }
                        }
                        goto L53;
                    }
                    if(WrapSearch == 0) {
                        goto L68;
                    }
                    l = buf->lastLine;
                    wrapped = 1;
                    goto L44;
                }
            }
            pos = pos - 1;
            while(pos > 0 && ( *(l->propBuf + pos + pos) & 0x400) != 0) {
                pos = pos - 1;
            }
            p = l->lineBuf + pos;
            found = 0;
            found_last = 0;
            q = l->lineBuf;
            while(regexMatch(q, l->lineBuf + l->size - q, l->lineBuf == q & 255) == 1) {
                matchedPosition( &first,  &last);
                if(first <= p) {
                    found = first;
                    found_last = last;
                }
                if(q - l->lineBuf >= l->size) {
                    goto L31;
                } else {
                    q =  &(q[1]);
                    while(q - l->lineBuf < l->size && ( *(l->propBuf + q - l->lineBuf + q - l->lineBuf) & 0x400) != 0) {
                        q =  &(q[1]);
                    }
                    if(q > p) {
L31:
                        if(found == 0) {
                            goto L40;
                        }
                        pos = found - l->lineBuf;
                        while(l->len <= pos && l->next != 0 && l->next->bpos != 0) {
                            pos = pos - l->len;
                            l = l->next;
                        }
                        buf->pos = pos;
                        if(buf->currentLine != l) {
                            gotoLine(buf, l->linenumber);
                        }
                        arrangeCursor(buf);
                        set_mark(l, pos,  &(found_last[pos]) - found);
                        return 1;
                    }
                    continue;
                }
            }
            goto L31;
        } else {
            pos = pos + l->bpos;
            do {
            } while(l->bpos != 0 && l->prev != 0);
            goto L13;
        }
    } else {
        p = regexCompile(str, IgnoreCase);
        if(p == 0) {
            goto L6;
        } else {
            message(p, 0, 0);
            return 2;
        }
    }
}

char* inputLineHistSearch(char* prompt, char* def_str, int flag, Hist* hist, _None* incrfunc)
{// addr = 0x0807D230  --  defined in 'linein.c' at line 85
    unsigned char c;                       // _cfa_fffffff3
    int opos;                              // _cfa_ffffffec
    int x;                                 // _cfa_ffffffe8
    int y;                                 // _cfa_ffffffe4
    int lpos;                              // _cfa_ffffffe0
    int rpos;                              // _cfa_ffffffdc
    int epos;                              // _cfa_ffffffd8
    char* p;                               // _cfa_ffffffd4
    Str tmp;               // _cfa_ffffffd0
    char* q;                               // _cfa_ffffffcc
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ _v76;                        // _cfa_ffffffb4 (outparam)
    _unknown_ _v80;                        // _cfa_ffffffb0 (outparam)
    Lineprop[1023]* _v84;   // _cfa_ffffffac (outparam)
    _unknown_ _v88;                        // _cfa_ffffffa8 (outparam)
    _unknown_ __ebx;                       // r1
    struct _Str* _t191;   // _t191
    char* _t211;                           // _t211
    char* _t212;                           // _t212
    char* _t217;                           // _t217
    char* _t221;                           // _t221
    unsigned char _t245;                   // _t245

    is_passwd = 0;
    move_word = 1;
    CurrentHist = hist;
    if(hist == 0) {
        use_hist = 0;
    } else {
        use_hist = 1;
        strCurrentBuf = 0;
    }
    if((flag & 256) == 0) {
        if((flag & 32) == 0) {
            if((flag & 64) == 0) {
                if((flag & 128) == 0) {
                    cm_mode = 1;
                } else {
                    cm_mode = 2;
                }
            } else {
                cm_mode = 0;
                is_passwd = 1;
                move_word = 0;
            }
        } else {
            cm_mode = 4;
        }
    } else {
        cm_mode = 12;
    }
    opos = wtf_strwidth(prompt);
    epos = COLS - 2 - opos;
    if(epos < 0) {
        epos = 0;
    }
    lpos = (epos * 1431655766 >> 32) - (epos >> 31);
    rpos = ((epos + epos) * 1431655766 >> 32) - (epos + epos >> 31);
    offset = 0;
    if(def_str == 0) {
        strBuf = Strnew();
        CPos = 0;
        CLen = CPos;
    } else {
        strBuf = Strnew_charp(def_str);
        CPos = setStrType(strBuf,  &strProp);
        CLen = CPos;
    }
    i_cont = 1;
    i_broken = 0;
    i_quote = 0;
    cm_next = 0;
    cm_disp_next = -1;
    need_redraw = 0;
    wc_char_conv_init(wc_guess_8bit_charset(DisplayCharset), InnerCharset);
    do {
        x = calcPosition(strBuf->ptr,  &strProp, CLen, CPos, 0, 1);
        if(x - rpos <= offset) {
            if(x - lpos < offset) {
                if(x - lpos <= 0) {
                    offset = 0;
                } else {
                    offset = x - lpos;
                }
            }
        } else {
            y = calcPosition(strBuf->ptr,  &strProp, CLen, CLen, 0, 0);
            if(y - epos <= x - rpos) {
                if(y - epos > 0) {
                    offset = y - epos;
                }
            } else {
                offset = x - rpos;
            }
        }
        move(LINES - 1, 0);
        addstr(prompt);
        if(is_passwd == 0) {
            addStr(strBuf->ptr,  &strProp, CLen, offset, COLS - opos);
        } else {
            addPasswd(strBuf->ptr,  &strProp, CLen, offset, COLS - opos);
        }
        clrtoeolx();
        move(LINES - 1, opos + x - offset);
        refresh();
        while(1) {
            c = do_getch();
            cm_clear = 1;
            cm_disp_clear = 1;
            if(i_quote != 0) {
                goto L41;
            }
L32:
            if((cm_mode & 4) == 0 || c != 9 && c != 32) {
                if((cm_mode & 2) == 0 || c != 9) {
                    goto L41;
                } else {
                    goto L37;
                }
            } else {
L37:
                if(emacs_like_lineedit == 0 || cm_next == 0) {
                    _compl();
                    cm_disp_next = -1;
                } else {
                    _dcompl();
                    need_redraw = 1;
                }
L72:
                if(CLen == 0 || (flag & 512) == 0) {
                    break;
                } else {
L77:
                    if(CurrentTab != 0 && need_redraw != 0) {
                        displayBuffer(CurrentTab->currentBuffer, 1);
                    }
                    if(i_broken == 0) {
                        move(LINES - 1, 0);
                        refresh();
                        p = strBuf->ptr;
                        if((flag & 160) == 0) {
L87:
                            if(use_hist == 0 || (flag & 256) != 0 || ( *p & 255) == 0) {
L93:
                                if((flag & 32) == 0) {
                                    _v88 = -1;
                                    _t211 = p;
                                     *__esp = _t211;
                                    allocStr();
                                    return _t211;
                                }
                                _t212 = p;
                                __eax = expandPath(_t212);
                                return _t212;
                            } else {
                                _t217 = hist;
                                __eax = lastHist(_t217);
                                q = _t217;
                                if(q == 0) {
L92:
                                    __eax = pushHist(hist, p);
                                    goto L93;
                                }
                                _v88 = p;
                                _t221 = q;
                                 *__esp = _t221;
                                strcmp();
                                if(_t221 == 0) {
                                    goto L93;
                                }
                                goto L92;
                            }
                        }
                        while(( *p & 255) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                            p =  &(p[1]);
                        }
                        goto L87;
                    } else {
                        return 0;
                    }
                }
            }
L41:
            if(i_quote != 0 || CLen != CPos || (cm_mode & 4) == 0 && (cm_mode & 2) == 0 || c != 4) {
                if(i_quote != 0 || c != 127) {
                    if(i_quote != 0 || c > 31) {
                        _t191 = c & 255;
                        __eax = wc_char_conv(_t191);
                        tmp = _t191;
                        if(tmp != 0) {
L66:
                            i_quote = 0;
                            cm_next = 0;
                            cm_disp_next = -1;
                            if(tmp->length + CLen > 1024 || tmp->length == 0) {
                                do {
                                    c = do_getch();
                                    cm_clear = 1;
                                    cm_disp_clear = 1;
                                    if(i_quote != 0) {
                                        goto L41;
                                    }
                                    goto L32;
                                } while(tmp->length + CLen > 1024 || tmp->length == 0);
                                goto L68;
                            } else {
L68:
                                ins_char(tmp);
                                if(incrfunc != 0) {
                                    _v84 =  &strProp;
                                    _v88 = strBuf;
                                     *__esp = -1;
                                     *incrfunc();
                                }
                                goto L72;
                            }
                        }
                        i_quote = 1;
                        continue;
                    } else {
                        if(incrfunc == 0) {
L55:
                             *__esp = c & 255;
                             *((intOrPtr*)( *((intOrPtr*)( &InputKeymap + (c & 255) * 4))))();
L56:
                            if(incrfunc != 0 && c != 255 && c != 10) {
                                _v84 =  &strProp;
                                _v88 = strBuf;
                                 *__esp = -1;
                                 *incrfunc();
                            }
                            if(cm_clear != 0) {
                                cm_next = 0;
                            }
                            if(cm_disp_clear != 0) {
                                cm_disp_next = -1;
                            }
                            goto L72;
                        }
                        _v84 =  &strProp;
                        _v88 = strBuf;
                         *__esp = c & 255;
                        _t245 = incrfunc;
                         *_t245();
                        c = _t245;
                        if(c > 31) {
                            goto L56;
                        }
                        goto L55;
                    }
                } else {
                    _bs();
                    cm_next = 0;
                    cm_disp_next = -1;
                    goto L72;
                }
            } else {
                if(emacs_like_lineedit == 0) {
                    _dcompl();
                    need_redraw = 1;
                }
                goto L72;
            }
        }
    } while(i_cont != 0);
    goto L77;
}

void addPasswd(char* p, Lineprop* pr, int len, int offset, int limit)
{// addr = 0x0807D9AC  --  defined in 'linein.c' at line 319
    int rcol;                              // _cfa_fffffff0
    int ncol;                              // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    rcol = 0;
    ncol = calcPosition(p, pr, len, len, 0, 0);
    if(offset + limit < ncol) {
        ncol = offset + limit;
    }
    if(offset != 0) {
        addChar(123, 0);
        rcol = offset + 1;
    }
    while(rcol < ncol) {
        addChar(42, 0);
        rcol = rcol + 1;
    }
}

void addStr(char* p, Lineprop* pr, int len, int offset, int limit)
{// addr = 0x0807DA4D  --  defined in 'linein.c' at line 335
    int i;                                 // _cfa_fffffff0
    int rcol;                              // _cfa_ffffffec
    int ncol;                              // _cfa_ffffffe8
    int delta;                             // _cfa_ffffffe4
    short unsigned int _v40;               // _cfa_ffffffd8 (outparam)
    short unsigned int _v44;               // _cfa_ffffffd4 (outparam)
    int _v48;                              // _cfa_ffffffd0 (outparam)
    int _v52;                              // _cfa_ffffffcc (outparam)
    Lineprop* _v56;   // _cfa_ffffffc8 (outparam)

    i = 0;
    rcol = 0;
    delta = 1;
    if(offset != 0) {
        i = 0;
        while(i < len) {
            if(calcPosition(p, pr, len, i, 0, 0) <= offset) {
                i = i + 1;
                continue;
            }
L7:
            if(i >= len) {
                return;
            }
            while(1) {
                i = i + i;
                pr + i + i =  *(pr + i + i) & 65535;
                __eax = __ax & 65535;
                if(__eax == 0) {
                    break;
                }
                i = i + 1;
            }
            addChar(123, 0);
            offset = offset + 1;
            rcol = offset + 1;
            _v40 = 0;
            _v44 = 0;
            __eax = i;
            _v48 = i;
            __eax = len;
            _v52 = len;
            __eax = pr;
            _v56 = pr;
            __eax = p;
             *__esp = p;
            ncol = calcPosition();
            while(1) {
                __eax = rcol;
                if(rcol >= ncol) {
                    break;
                }
                addChar(32, 0);
                rcol = rcol + 1;
            }
L24:
            while(i < len) {
                delta = wtf_len( &(p[i]));
                ncol = calcPosition(p, pr, len, i + delta, 0, 0);
                if(ncol - offset <= limit) {
                    if((p[i] & 255) != 9) {
                        addMChar( &(p[i]),  *(pr + i + i) & 0xffff, delta);
                        rcol = ncol;
                    } else {
                        while(rcol < ncol) {
                            addChar(32, 0);
                            rcol = rcol + 1;
                        }
                    }
                    i = i + delta;
                    continue;
                }
                return;
            }
            return;
        }
        goto L7;
    }
    goto L24;
}

void ins_char(Str str)
{// addr = 0x0807DC34  --  defined in 'linein.c' at line 381
    Lineprop ctype;   // _cfa_fffffff2
    char* p;                               // _cfa_ffffffec
    char* ep;                              // _cfa_ffffffe8
    int len;                               // _cfa_ffffffe4

    p = str->ptr;
    ep =  &(p[str->length]);
    if(str->length + CLen <= 1023) {
L11:
        while(p < ep) {
            len =  *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff;
            ctype = ( *( &WTF_TYPE_MAP + ( *p & 0xff)) & 0xff) << 8;
            if(is_passwd != 0) {
                if((ctype & 0x100) != 0) {
                    ctype = 0;
                }
                if((ctype & 0x1000) != 0) {
                    ctype = 512;
                }
            }
            insC();
            strBuf->ptr[CPos] =  *p & 255;
            p =  &(p[1]);
             *((short*)(CPos +  &strProp + CPos)) = ctype & 65535;
            CPos = CPos + 1;
            len = len - 1;
            if(len != 0) {
                ctype = ctype & 0xf9 | 4;
                while(1) {
                    len = len - 1;
                    if(len == 0) {
                        goto L11;
                    }
                    insC();
                    strBuf->ptr[CPos] =  *p & 255;
                    p =  &(p[1]);
                     *((short*)(CPos +  &strProp + CPos)) = ctype & 65535;
                    CPos = CPos + 1;
                }
            }
        }
        return;
    }
}

void _esc()
{// addr = 0x0807DD7C  --  defined in 'linein.c' at line 416
    char c;                                // _cfa_fffffff3
    char _t7;                              // _t7
    char _t10;                             // _t10

    c = do_getch();
    _t7 = c;
    if(_t7 == 32) {
L25:
        if(emacs_like_lineedit == 0) {
            _rcompl();
            return;
        }
        _rdcompl();
        cm_clear = 0;
        need_redraw = 1;
        return;
    }
    if(_t7 > 32) {
        if(_t7 == 91) {
L13:
            c = do_getch();
            _t10 = c;
            if(_t10 == 66) {
                _next();
L24:
                return;
            }
            if(_t10 > 66) {
                if(_t10 == 67) {
                    _mvR();
                    goto L24;
                }
                if(_t10 == 68) {
                    _mvL();
                    return;
                }
                return;
            }
            if(_t10 == 65) {
                _prev();
                goto L24;
            }
            return;
        }
        if(_t7 > 91) {
            if(_t7 == 98) {
                if(emacs_like_lineedit == 0) {
                    return;
                }
                _mvLw();
                return;
            }
            if(_t7 == 102) {
                if(emacs_like_lineedit == 0) {
                    return;
                }
                _mvRw();
                return;
            }
L37:
            if(wc_char_conv(27) != 0 || wc_char_conv(c) != 0) {
L43:
                return;
            } else {
                i_quote = 1;
                return;
            }
        }
        if(_t7 == 79) {
            goto L13;
        }
        goto L37;
    }
    if(_t7 == 8) {
        if(emacs_like_lineedit == 0) {
            goto L43;
        }
        _bsw();
        return;
    }
    if(_t7 == 9) {
        goto L25;
    }
    if(_t7 == 4) {
        if(emacs_like_lineedit == 0) {
            _rdcompl();
        }
        need_redraw = 1;
        return;
    }
    goto L37;
}

void insC()
{// addr = 0x0807DEE7  --  defined in 'linein.c' at line 474
    int i;                                 // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    Strinsert_char(strBuf, CPos, 32);
    CLen = strBuf->length;
    i = CLen;
    while(i > CPos) {
         *((short*)(i +  &strProp + i)) =  *(i - 1 +  &strProp + i - 1) & 65535;
        i = i - 1;
    }
}

void delC()
{// addr = 0x0807DF4C  --  defined in 'linein.c' at line 486
    int i;                                 // _cfa_fffffff0
    int delta;                             // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    i = CPos;
    delta = 1;
    __edx = CLen;
    __eflags = CLen - CPos;
    if(__eflags != 0) {
        while(1) {
            __eax = delta;
            i = i + delta;
            __eax = CLen;
            __eflags = i + delta - CLen;
            if(i + delta >= CLen) {
                break;
            }
            __eax = delta;
            __edx = i;
            i + delta =  *(i + delta +  &strProp + i + delta) & 65535;
            __eax = __ax & 65535;
            __eax = __eax & 1024;
            __eflags = __eax;
            if(__eax != 0) {
                delta = delta + 1;
                continue;
            }
            break;
        }
        __eax = CPos;
        i = CPos;
        while(1) {
            __eax = CLen;
            __eflags = i - CLen;
            if(i >= CLen) {
                break;
            }
            __eax = i;
            __edx = delta;
            i + delta =  *(i + delta +  &strProp + i + delta) & 65535;
             *((short*)(i +  &strProp + i)) = __dx;
            i = i + 1;
            __eflags = i;
        }
        __edx = CPos;
        __eax = strBuf;
        Strdelete(strBuf, CPos, delta);
        __eax = CLen;
        __eax = CLen - delta;
        __eflags = __eax;
        CLen = __eax;
        return;
    }
}

void _mvL()
{// addr = 0x0807E00B  --  defined in 'linein.c' at line 505
    if(CPos > 0) {
        CPos = CPos - 1;
    }
    do {
    } while(CPos > 0 && ( *(CPos +  &strProp + CPos) & 0x400) != 0);
}

void _mvLw()
{// addr = 0x0807E05A  --  defined in 'linein.c' at line 516
    int first;                             // _cfa_fffffff0

    first = 1;
    while(CPos > 0) {
        if(first != 0 || terminated(strBuf->ptr[CPos - 1] & 0xff) == 0) {
            CPos = CPos - 1;
            first = 0;
            if(CPos > 0 && ( *(CPos +  &strProp + CPos) & 0x400) != 0) {
                CPos = CPos - 1;
            }
            if(move_word == 0) {
                break;
            }
            continue;
        } else {
            return;
        }
    }
}

void _mvRw()
{// addr = 0x0807E0ED  --  defined in 'linein.c' at line 532
    int first;                             // _cfa_fffffff0

    first = 1;
    while(CPos < CLen) {
        if(first != 0 || terminated(strBuf->ptr[CPos - 1] & 0xff) == 0) {
            CPos = CPos + 1;
            first = 0;
            if(CPos < CLen && ( *(CPos +  &strProp + CPos) & 0x400) != 0) {
                CPos = CPos + 1;
            }
            if(move_word == 0) {
                break;
            }
            continue;
        } else {
            return;
        }
    }
}

void _mvR()
{// addr = 0x0807E190  --  defined in 'linein.c' at line 548
    if(CPos < CLen) {
        CPos = CPos + 1;
    }
    do {
    } while(CPos < CLen && ( *(CPos +  &strProp + CPos) & 0x400) != 0);
}

void _bs()
{// addr = 0x0807E1EB  --  defined in 'linein.c' at line 559
    if(CPos > 0) {
        _mvL();
        delC();
        return;
    }
}

void _bsw()
{// addr = 0x0807E206  --  defined in 'linein.c' at line 568
    int t;                                 // _cfa_fffffff0
    int _t6;                               // _t6

    t = 0;
    while(CPos > 0 && t == 0) {
        _mvL();
        if(move_word == 0 || terminated(strBuf->ptr[CPos - 1] & 0xff) == 0) {
            _t6 = 0;
        } else {
            _t6 = 1;
        }
        t = _t6;
        delC();
    }
}

void _enter()
{// addr = 0x0807E26C  --  defined in 'linein.c' at line 579
    i_cont = 0;
}

void insertself(char c)
{// addr = 0x0807E27B  --  defined in 'linein.c' at line 585
    signed char _v16;                      // _cfa_fffffff0
    short _t12;                            // _t12
    int _t17;                              // _t17

    _v16 = c;
    if(CLen <= 1023) {
        insC();
        strBuf->ptr[CPos] = _v16 & 255;
        _t17 = CPos;
        if(is_passwd == 0) {
            _t12 = 256;
        } else {
            _t12 = 0;
        }
         *((short*)(_t17 +  &strProp + _t17)) = _t12;
        CPos = CPos + 1;
        return;
    }
}

void _quo()
{// addr = 0x0807E2E1  --  defined in 'linein.c' at line 596
    i_quote = 1;
}

void _mvB()
{// addr = 0x0807E2F0  --  defined in 'linein.c' at line 602
    CPos = 0;
}

void _mvE()
{// addr = 0x0807E2FF  --  defined in 'linein.c' at line 608
    CPos = CLen;
}

void killn()
{// addr = 0x0807E30E  --  defined in 'linein.c' at line 614
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    CLen = CPos;
    Strtruncate(strBuf, CLen);
}

void killb()
{// addr = 0x0807E337  --  defined in 'linein.c' at line 621
    while(CPos > 0) {
        _bs();
    }
}

void _inbrk()
{// addr = 0x0807E34F  --  defined in 'linein.c' at line 628
    i_cont = 0;
    i_broken = 1;
}

void _compl()
{// addr = 0x0807E368  --  defined in 'linein.c' at line 635
    next_compl(1);
}

void _rcompl()
{// addr = 0x0807E37C  --  defined in 'linein.c' at line 641
    next_compl(-1);
}

void _tcompl()
{// addr = 0x0807E390  --  defined in 'linein.c' at line 647
    if((cm_mode & 1) != 0) {
        cm_mode = 2;
        return;
    }
    if((cm_mode & 2) != 0) {
        cm_mode = 1;
        return;
    }
}

void next_compl(int next)
{// addr = 0x0807E3C3  --  defined in 'linein.c' at line 656
    int status;                            // _cfa_fffffff0
    int b;                                 // _cfa_ffffffec
    int a;                                 // _cfa_ffffffe8
    Str buf;               // _cfa_ffffffe4
    Str s;                 // _cfa_ffffffe0
    int _v48;                              // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc (outparam)
    char* _v56;                            // _cfa_ffffffc8 (outparam)

    if(cm_mode == 0) {
        return;
    }
    if((cm_mode & 1) != 0) {
        return;
    }
    cm_clear = 0;
    if(cm_next != 0) {
        s = doComplete(strBuf,  &status, next);
L15:
        if(next == 0) {
            return;
        }
        if(status != 0 && status != 3) {
            bell();
        }
        if(status == 2) {
            goto L26;
        } else {
            _v48 = 0;
            _v52 = CAfterBuf->ptr;
            _v56 = s->ptr;
            strBuf = Strnew_m_charp(CBeforeBuf->ptr);
            CLen = setStrType(strBuf,  &strProp);
            CPos = CBeforeBuf->length + s->length;
            if(CPos <= CLen) {
L26:
                return;
            }
            CPos = CLen;
            return;
        }
    }
    if((cm_mode & 4) == 0) {
        b = CPos - 1;
        while(b >= 0) {
            if(( *(strBuf->ptr + b) & 255) == 32 || ( *(strBuf->ptr + b) & 255) == 9) {
                if(b <= 0 || ( *(strBuf->ptr + b - 1) & 255) != 92) {
                    break;
                } else {
                    goto L10;
                }
            } else {
L10:
                b = b - 1;
                continue;
            }
        }
        b = b + 1;
        goto L13;
    } else {
        b = 0;
L13:
        a = CPos;
        CBeforeBuf = Strsubstr(strBuf, 0, b);
        buf = Strsubstr(strBuf, b, a - b);
        CAfterBuf = Strsubstr(strBuf, a, strBuf->length - a);
        s = doComplete(buf,  &status, next);
        goto L15;
    }
}

void _dcompl()
{// addr = 0x0807E5D4  --  defined in 'linein.c' at line 703
    next_dcompl(1);
}

void _rdcompl()
{// addr = 0x0807E5E8  --  defined in 'linein.c' at line 709
    next_dcompl(-1);
}

void next_dcompl(int next)
{// addr = 0x0807E5FC  --  defined in 'linein.c' at line 715
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int n;                                 // _cfa_ffffffe8
    int y;                                 // _cfa_ffffffe4
    Str f;                 // _cfa_ffffffe0
    char* p;                               // _cfa_ffffffdc
    int comment;                           // _cfa_ffffffd8
    int nline;                             // _cfa_ffffffd4
    _unknown_ _v116;                       // _cfa_ffffff8c
    struct stat st;       // _cfa_ffffff7c
    signed int _v144;                      // _cfa_ffffff70
    intOrPtr _v164;                        // _cfa_ffffff5c (outparam)
    char* _v168;                           // _cfa_ffffff58 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    char* _t148;                           // _t148
    char* _t209;                           // _t209
    char* _t210;                           // _t210
    char* _t211;                           // _t211
    struct _Str* _t224;   // _t224
    int _t285;                             // _t285

    if(cm_mode == 0) {
        return;
    }
    if((cm_mode & 1) != 0) {
        return;
    } else {
        cm_disp_clear = 0;
        if(CurrentTab != 0) {
            displayBuffer(CurrentTab->currentBuffer, 1);
        }
        if(LINES - 1 <= 2) {
            if(LINES == 1) {
                return;
            } else {
                comment = 0;
                nline = LINES - 1;
                goto L8;
            }
        } else {
            comment = 1;
            nline = LINES - 3;
L8:
            if(cm_disp_next < 0) {
                cm_next = 0;
                next_compl(0);
                if(NCFileBuf == 0) {
L74:
                    return;
                }
                cm_disp_next = 0;
                d.9104 = wc_Str_conv_strict(Strdup(CDirBuf), InnerCharset, SystemCharset);
                if(d.9104->length > 0 && (d.9104->length <= 0 || ( *( *d.9104 + d.9104->length - 1) & 255) != 47)) {
                    if(d.9104->length + 1 >= d.9104->area_size) {
                        Strgrow(d.9104);
                    }
                    _t224 = d.9104;
                    _t285 = _t224->length;
                     *((char*)( *d.9104 + _t285)) = 47;
                    _t224->length = _t285 + 1;
                     *((char*)( *d.9104 + d.9104->length)) = 0;
                }
                if((cm_mode & 8) != 0 && ( *( *d.9104) & 255) == 102) {
                    p =  *d.9104;
                    _v164 = 17;
                    _v168 = "file://localhost/";
                    _t209 = p;
                     *__esp = _t209;
                    strncmp();
                    if(_t209 != 0) {
                        _v164 = 8;
                        _v168 = "file:///";
                        _t210 = p;
                         *__esp = _t210;
                        strncmp();
                        if(_t210 != 0) {
                            _v164 = 6;
                            _v168 = "file:/";
                            _t211 = p;
                             *__esp = _t211;
                            strncmp();
                            if(_t211 == 0 && (p[6] & 255) != 47) {
                                p =  &(p[5]);
                            }
                        } else {
                            p =  &(p[7]);
                        }
                    } else {
                        p =  &(p[0x10]);
                    }
                    d.9104 = Strnew_charp(p);
                }
                len.9103 = 0;
                i = 0;
                while(i < NCFileBuf) {
                    _t148 = CFileBuf[i];
                     *__esp = _t148;
                    strlen();
                    n =  &(_t148[3]);
                    if(len.9103 < n) {
                        len.9103 = n;
                    }
                    i = i + 1;
                }
                _v144 = len.9103;
                col.9101 = COLS / _v144;
                if(col.9101 == 0) {
                    col.9101 = 1;
                }
                _v144 = col.9101;
                row = (NCFileBuf + col.9101 - 1) / _v144;
L41:
                if(comment == 0) {
                    if(row < nline) {
                        y = nline - row - 1;
                    } else {
                        row = nline;
                        y = 0;
                    }
                } else {
                    if(row <= nline) {
                        y = nline - row + 1;
                    } else {
                        row = nline;
                        y = 0;
                    }
                }
                if(y != 0) {
                    move(y - 1, 0);
                    clrtoeolx();
                }
                if(comment != 0) {
                    move(y, 0);
                    clrtoeolx();
                    bold();
                    addstr("----- Completion list -----");
                    boldend();
                    y = y + 1;
                }
                i = 0;
L63:
                while(i < row) {
                    j = 0;
                    while(j < col.9101) {
                        n = row * j + cm_disp_next + i;
                        if(n >= NCFileBuf) {
L62:
                            y = y + 1;
                            i = i + 1;
                            goto L63;
                        }
                        move(y, len.9103 * j);
                        clrtoeolx();
                        f = Strdup(d.9104);
                        Strcat_charp(f, CFileBuf[n]);
                        addstr( *(wc_Str_conv(Strnew_charp(CFileBuf[n]), SystemCharset, InnerCharset)));
                        if(__stat(expandPath(f->ptr),  &(st.st_dev)) != -1 && (st.st_mode & 61440) == 16384) {
                            addstr(135049226);
                        }
                        j = j + 1;
                    }
                    goto L62;
                }
                if(comment == 0 || LINES - 2 != y) {
                    goto L74;
                } else {
                    move(y, 0);
                    clrtoeolx();
                    bold();
                    if(emacs_like_lineedit == 0) {
                        addstr("----- Press CTRL-D to continue -----");
                    } else {
                        addstr("----- Press TAB to continue -----");
                    }
                    boldend();
                    return;
                }
            }
            if(next != 1) {
                if(next == -1) {
                    cm_disp_next = cm_disp_next - col.9101 * nline;
                    if(cm_disp_next < 0) {
                        cm_disp_next = 0;
                    }
                }
            } else {
                cm_disp_next = col.9101 * nline + cm_disp_next;
                if(cm_disp_next >= NCFileBuf) {
                    cm_disp_next = 0;
                }
            }
            _v144 = col.9101;
            row = (NCFileBuf - cm_disp_next + col.9101 - 1) / _v144;
            goto L41;
        }
    }
}

Str escape_spaces(Str s)
{// addr = 0x0807EBE9  --  defined in 'linein.c' at line 849
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t67;                              // _t67
    int _t79;                              // _t79

    tmp = 0;
    if(s != 0) {
        p = s->ptr;
        while(( *p & 255) != 0) {
            if(( *p & 255) == 32 || ( *p & 255) == 9) {
                if(tmp == 0) {
                    tmp = Strnew_charp_n(s->ptr, p - s->ptr);
                }
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t67 = tmp->length;
                 *((char*)(tmp->ptr + _t67)) = 92;
                tmp->length = _t67 + 1;
                 *((char*)(tmp->ptr + tmp->length)) = 0;
            }
            if(tmp != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t79 = tmp->length;
                 *((char*)(tmp->ptr + _t79)) =  *p & 255;
                tmp->length = _t79 + 1;
                 *((char*)(tmp->ptr + tmp->length)) = 0;
            }
            p =  &(p[1]);
        }
        if(tmp == 0) {
            return s;
        }
        return tmp;
    }
    return s;
}

Str unescape_spaces(Str s)
{// addr = 0x0807ED0B  --  defined in 'linein.c' at line 872
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t51;                              // _t51

    tmp = 0;
    if(s == 0) {
        return s;
    }
    p = s->ptr;
    while(( *p & 255) != 0) {
        if(( *p & 255) != 92 || (p[1] & 255) != 32 && (p[1] & 255) != 9) {
            if(tmp != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t51 = tmp->length;
                 *((char*)(tmp->ptr + _t51)) =  *p & 255;
                tmp->length = _t51 + 1;
                 *((char*)(tmp->ptr + tmp->length)) = 0;
            }
        } else {
            if(tmp == 0) {
                tmp = Strnew_charp_n(s->ptr, p - s->ptr);
            }
        }
        p =  &(p[1]);
    }
    if(tmp == 0) {
        return s;
    }
    return tmp;
}

Str doComplete(Str ifn, int* status, int next)
{// addr = 0x0807EDF7  --  defined in 'linein.c' at line 895
    int fl;                                // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    char* fn;                              // _cfa_ffffffe8
    char* p;                               // _cfa_ffffffe4
    DIR* d;                // _cfa_ffffffe0
    Directory* dir;   // _cfa_ffffffdc
    _unknown_ _v108;                       // _cfa_ffffff94
    struct stat st;       // _cfa_ffffff84
    signed int _v128;                      // _cfa_ffffff80
    intOrPtr _v144;                        // _cfa_ffffff70
    int _v148;                             // _cfa_ffffff6c (outparam)
    int _v152;                             // _cfa_ffffff68 (outparam)
    _unknown_ __ebx;                       // r1
    Str _t183;             // _t183
    char* _t189;                           // _t189
    char* _t190;                           // _t190
    char* _t191;                           // _t191
    Str _t202;             // _t202
    DIR* _t236;            // _t236
    int _t240;                             // _t240
    Directory* _t242;   // _t242
    char* _t244;                           // _t244
    char** _t248;                          // _t248
    char** _t251;                          // _t251
    char* _t252;                           // _t252
    char** _t269;                          // _t269
    char** _t271;                          // _t271
    Str _t309;             // _t309
    char* _t316;                           // _t316
    char* _t318;                           // _t318
    char* _t320;                           // _t320
    int _t368;                             // _t368
    int _t372;                             // _t372
    int _t391;                             // _t391

    if(cm_next != 0) {
        CFileName = Strnew_charp(CFileBuf[NCFileOffset]);
        _v128 = NCFileBuf;
        NCFileOffset = (NCFileOffset + next + NCFileBuf) % _v128;
         *status = 3;
        goto L52;
    } else {
        NCFileBuf = 0;
        ifn = wc_Str_conv_strict(ifn, InnerCharset, SystemCharset);
        if((cm_mode & 2) != 0) {
            ifn = unescape_spaces(ifn);
        }
        CompleteBuf = Strdup(ifn);
        while(CompleteBuf->length <= 0 || ( *(CompleteBuf->ptr + CompleteBuf->length - 1) & 255) != 47) {
            if(CompleteBuf->length > 0) {
                Strshrink(CompleteBuf, 1);
                continue;
            }
            break;
        }
        CDirBuf = Strdup(CompleteBuf);
        if((cm_mode & 8) == 0) {
L17:
            if(CompleteBuf->length == 0) {
                _t309 = CompleteBuf;
                _t391 = _t309->length;
                 *((char*)(CompleteBuf->ptr + _t391)) = 46;
                _t309->length = _t391 + 1;
                 *((char*)(CompleteBuf->ptr + CompleteBuf->length)) = 0;
            }
            if(CompleteBuf->length > 0 && ( *(CompleteBuf->ptr + CompleteBuf->length - 1) & 255) == 47 && CompleteBuf->length > 1) {
                Strshrink(CompleteBuf, 1);
            }
            _t236 = expandPath(CompleteBuf->ptr);
             *__esp = _t236;
            opendir();
            d = _t236;
            if(d != 0) {
                fn = lastFileName(ifn->ptr);
                _t240 = fn;
                 *__esp = _t240;
                strlen();
                fl = _t240;
                CFileName = Strnew();
                while(1) {
                    _t242 = d;
                     *__esp = _t242;
                    readdir();
                    dir = _t242;
                    if(dir == 0) {
                        break;
                    }
                    if(fl != 0) {
L38:
                        _v148 = fl;
                        _t244 = fn;
                        _v152 = _t244;
                         *__esp =  &(dir->d_name);
                        strncmp();
                        if(_t244 != 0) {
                            continue;
                        }
                        NCFileBuf = NCFileBuf + 1;
                        _t248 = CFileBuf;
                        _v152 = NCFileBuf * 4;
                         *__esp = _t248;
                        GC_realloc();
                        CFileBuf = _t248;
                        _t251 =  &(dir->d_name);
                         *__esp = _t251;
                        strlen();
                        _t252 =  &(_t251[0]);
                         *__esp = _t252;
                        GC_malloc_atomic();
                        CFileBuf[NCFileBuf - 1] = _t252;
                        _v152 =  &(dir->d_name);
                         *__esp = CFileBuf[NCFileBuf - 1];
                        strcpy();
                        if(NCFileBuf != 1) {
                            i = 0;
                            while((CFileName->ptr[i] & 255) == ( *(dir + i + 11) & 255)) {
                                i = i + 1;
                            }
                            Strtruncate(CFileName, i);
                            continue;
                        }
                        CFileName = Strnew_charp( &(dir->d_name));
                        continue;
                    }
                    _t269 =  &(dir->d_name);
                    _v152 = 135049301;
                     *__esp = _t269;
                    strcmp();
                    if(_t269 == 0) {
L37:
                        continue;
                    }
                    _t271 =  &(dir->d_name);
                    _v152 = 135049303;
                     *__esp = _t271;
                    strcmp();
                    if(_t271 != 0) {
                        goto L38;
                    }
                    goto L37;
                }
                 *__esp = d;
                closedir();
                if(NCFileBuf == 0) {
                    CompleteBuf = Strdup(ifn);
                     *status = 2;
                    if((cm_mode & 2) != 0) {
                        CompleteBuf = escape_spaces(CompleteBuf);
                    }
                    return CompleteBuf;
                }
                _v144 = strCmp;
                _v148 = 4;
                _v152 = NCFileBuf;
                 *__esp = CFileBuf;
                qsort();
                NCFileOffset = 0;
                if(NCFileBuf <= 1) {
                     *status = 0;
                } else {
                    cm_next = 1;
                     *status = 1;
                }
L52:
                CompleteBuf = Strdup(CDirBuf);
                if(CompleteBuf->length != 0 && (CompleteBuf->length <= 0 || ( *(CompleteBuf->ptr + CompleteBuf->length - 1) & 255) != 47)) {
                    if(CompleteBuf->length + 1 >= CompleteBuf->area_size) {
                        Strgrow(CompleteBuf);
                    }
                    _t202 = CompleteBuf;
                    _t372 = _t202->length;
                     *((char*)(CompleteBuf->ptr + _t372)) = 47;
                    _t202->length = _t372 + 1;
                     *((char*)(CompleteBuf->ptr + CompleteBuf->length)) = 0;
                }
                Strcat(CompleteBuf, CFileName);
                if( *status != 1) {
                    p = CompleteBuf->ptr;
                    if((cm_mode & 8) != 0) {
                        _v148 = 17;
                        _v152 = "file://localhost/";
                        _t189 = p;
                         *__esp = _t189;
                        strncmp();
                        if(_t189 != 0) {
                            _v148 = 8;
                            _v152 = "file:///";
                            _t190 = p;
                             *__esp = _t190;
                            strncmp();
                            if(_t190 != 0) {
                                _v148 = 6;
                                _v152 = "file:/";
                                _t191 = p;
                                 *__esp = _t191;
                                strncmp();
                                if(_t191 == 0 && (p[6] & 255) != 47) {
                                    p =  &(p[5]);
                                }
                            } else {
                                p =  &(p[7]);
                            }
                        } else {
                            p =  &(p[0x10]);
                        }
                    }
                    if(__stat(expandPath(p),  &(st.st_dev)) != -1 && (st.st_mode & 61440) == 16384) {
                        if(CompleteBuf->length + 1 >= CompleteBuf->area_size) {
                            Strgrow(CompleteBuf);
                        }
                        _t183 = CompleteBuf;
                        _t368 = _t183->length;
                         *((char*)(CompleteBuf->ptr + _t368)) = 47;
                        _t183->length = _t368 + 1;
                         *((char*)(CompleteBuf->ptr + CompleteBuf->length)) = 0;
                    }
                }
                if((cm_mode & 2) != 0) {
                    CompleteBuf = escape_spaces(CompleteBuf);
                }
                return wc_Str_conv(CompleteBuf, SystemCharset, InnerCharset);
            } else {
                CompleteBuf = Strdup(ifn);
                 *status = 2;
                if((cm_mode & 2) != 0) {
                    CompleteBuf = escape_spaces(CompleteBuf);
                }
                return CompleteBuf;
            }
        }
        _t316 = CompleteBuf->ptr;
        _v148 = 17;
        _v152 = "file://localhost/";
         *__esp = _t316;
        strncmp();
        if(_t316 != 0) {
            _t318 = CompleteBuf->ptr;
            _v148 = 8;
            _v152 = "file:///";
             *__esp = _t318;
            strncmp();
            if(_t318 != 0) {
                _t320 = CompleteBuf->ptr;
                _v148 = 6;
                _v152 = "file:/";
                 *__esp = _t320;
                strncmp();
                if(_t320 != 0 || (CompleteBuf->ptr[6] & 255) == 47) {
                    CompleteBuf = Strdup(ifn);
                     *status = 2;
                    return wc_Str_conv_strict(CompleteBuf, InnerCharset, SystemCharset);
                } else {
                    Strdelete(CompleteBuf, 0, 5);
                    goto L17;
                }
            } else {
                Strdelete(CompleteBuf, 0, 7);
                goto L17;
            }
        } else {
            Strdelete(CompleteBuf, 0, 16);
            goto L17;
        }
    }
}

void _prev()
{// addr = 0x0807F5AE  --  defined in 'linein.c' at line 1010
    Hist* hist;           // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    hist = CurrentHist;
    if(use_hist == 0) {
        return;
    }
    if(strCurrentBuf != 0) {
        p = prevHist(hist);
        if(p != 0) {
L6:
            if(DecodeURL != 0 && (cm_mode & 8) != 0) {
                p = url_unquote_conv(p, 0);
            }
            strBuf = Strnew_charp(p);
            CPos = setStrType(strBuf,  &strProp);
            CLen = CPos;
            offset = 0;
            return;
        }
        return;
    }
    p = lastHist(hist);
    if(p != 0) {
        strCurrentBuf = strBuf;
        goto L6;
    }
}

void _next()
{// addr = 0x0807F67A  --  defined in 'linein.c' at line 1036
    Hist* hist;           // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    hist = CurrentHist;
    if(use_hist == 0) {
        return;
    }
    if(strCurrentBuf != 0) {
        p = nextHist(hist);
        if(p == 0) {
            strBuf = strCurrentBuf;
            strCurrentBuf = 0;
        } else {
            if(DecodeURL != 0 && (cm_mode & 8) != 0) {
                p = url_unquote_conv(p, 0);
            }
            strBuf = Strnew_charp(p);
        }
        CPos = setStrType(strBuf,  &strProp);
        CLen = CPos;
        offset = 0;
        return;
    }
}

int setStrType(Str str, Lineprop* prop)
{// addr = 0x0807F73D  --  defined in 'linein.c' at line 1060
    Lineprop ctype;   // _cfa_fffffffa
    char* p;                               // _cfa_fffffff4
    char* ep;                              // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int len;                               // _cfa_ffffffe8

    p = str->ptr;
    ep =  &(p[str->length]);
    len = 1;
    i = 0;
L11:
    while(p < ep) {
        len =  *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff;
        if(i + len > 1024) {
L14:
            return i;
        }
        ctype = ( *( &WTF_TYPE_MAP + ( *p & 0xff)) & 0xff) << 8;
        if(is_passwd != 0) {
            if((ctype & 0x100) != 0) {
                ctype = 0;
            }
            if((ctype & 0x1000) != 0) {
                ctype = 512;
            }
        }
         *((short*)(prop + i + i)) = ctype & 65535;
        i = i + 1;
        p =  &(p[len]);
        len = len - 1;
        if(len != 0) {
            ctype = ctype & 0xf9 | 4;
            while(1) {
                len = len - 1;
                if(len == 0) {
                    goto L11;
                }
                 *((short*)(prop + i + i)) = ctype & 65535;
                i = i + 1;
            }
        }
    }
    goto L14;
}

int terminated(unsigned char c)
{// addr = 0x0807F846  --  defined in 'linein.c' at line 1097
    int* tp;                               // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    int[4] termchar;                       // _cfa_ffffffe4
    signed char _v40;                      // _cfa_ffffffd8

    _v40 = c;
    termchar = 47;
    _v24 = 38;
    _v20 = 63;
    _v16 = 32;
    _v12 = -1;
    tp =  &termchar;
    while( *tp > 0) {
        if((_v40 & 255) !=  *tp) {
            tp =  &(tp[1]);
            continue;
        }
        return 1;
    }
    return 0;
}

void _editor()
{// addr = 0x0807F8A5  --  defined in 'linein.c' at line 1112
    char* p;                               // _cfa_fffffff0
    char _v48;                             // _cfa_ffffffd0
    struct _Str* _v80;    // _cfa_ffffffb0
    FormItemList fi;   // _cfa_ffffffa8
    _unknown_ _v104;                       // _cfa_ffffff98 (outparam)
    _unknown_ __ebx;                       // r1
    struct _Str* _t45;    // _t45
    Str _t65;              // _t65
    signed int _t87;                       // _t87
    int _t91;                              // _t91

    if(is_passwd != 0) {
L16:
        return;
    }
    _v48 = 0;
    _v80 = Strdup(strBuf);
    if(_v80->length + 1 >= _v80->area_size) {
        Strgrow(_v80);
    }
    _t45 = _v80;
    _t87 = _t45->length;
    ( *_v80)[_t87] = 10;
    _t45->length = _t87 + 1;
    ( *_v80)[_v80->length] = 0;
    input_textarea( &fi);
    strBuf = Strnew();
    p =  *_v80;
    while(( *p & 255) != 0) {
        if(( *p & 255) != 13) {
            if(( *p & 255) != 10) {
                if(strBuf->length + 1 >= strBuf->area_size) {
                    Strgrow(strBuf);
                }
                _t65 = strBuf;
                _t91 = _t65->length;
                 *((char*)(strBuf->ptr + _t91)) =  *p & 255;
                _t65->length = _t91 + 1;
                 *((char*)(strBuf->ptr + strBuf->length)) = 0;
            }
        }
        p =  &(p[1]);
    }
    CPos = setStrType(strBuf,  &strProp);
    CLen = CPos;
    if(CurrentTab == 0) {
        goto L16;
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
}

int LUfactor(Matrix A, int* indexarray)
{// addr = 0x0807FA0C  --  defined in 'matrix.c' at line 69
    int dim;                               // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    int k;                                 // _cfa_ffffffe4
    int i_max;                             // _cfa_ffffffe0
    int k_max;                             // _cfa_ffffffdc
    Vector scale;       // _cfa_ffffffd8
    int tmp;                               // _cfa_ffffffd4
    double mx;                             // _cfa_ffffffcc
    double tmp;                            // _cfa_ffffffc4
    double tmp;                            // _cfa_ffffffbc
    double* _t232;                         // _t232
    double _t347;                          // _t347

    _t347 = __fp0;
    dim = A->dim;
    scale = new_vector(dim);
    i = 0;
    while(i < dim) {
        indexarray[i] = i;
        i = i + 1;
        __eflags = i;
    }
    i = 0;
    while(i < dim) {
        asm("fldz");
        mx = _t347;
        j = 0;
        while(1) {
            __eflags = j - dim;
            if(__eflags >= 0) {
                break;
            }
            asm("fabs");
            tmp =  *(A->me + (A->dim * i + j << 3));
            asm("fucomip st0, st1");
            st0 = tmp;
            if(i != 0) {
                mx = tmp;
            }
            j = j + 1;
            __eflags = j;
        }
        _t347 = mx;
        scale->ve[i] = _t347;
        i = i + 1;
        __eflags = i;
    }
    k_max = dim - 1;
    k = 0;
    while(k < k_max) {
        asm("fldz");
        mx = _t347;
        i_max = -1;
        i = k;
        while(1) {
            __eflags = i - dim;
            if(__eflags >= 0) {
                break;
            }
            asm("fabs");
            asm("fabs");
            _t347 = Tiny;
            asm("fmulp st1, st0");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            st0 = _t347;
            __eflags = __eflags >= 0;
            if(__eflags != 0) {
                asm("fabs");
                asm("fdivp st1, st0");
                tmp = scale->ve[i];
                _t347 = tmp;
                asm("fucomip st0, st1");
                st0 = _t347;
                if(__eflags != 0) {
                    _t347 = tmp;
                    mx = _t347;
                    i_max = i;
                }
            }
            i = i + 1;
            __eflags = i;
        }
        __eflags = i_max - -1;
        if(i_max != -1) {
            __eflags = i_max - k;
            if(i_max == k) {
L24:
                i = k + 1;
                while(1) {
                    __eflags = i - dim;
                    if(i >= dim) {
                        break;
                    }
                    _t232 = A->me + (A->dim * i + k << 3);
                    asm("fdivp st1, st0");
                     *_t232 =  *(A->me + (A->dim + 1 << 3) * k);
                    _t347 =  *_t232;
                    tmp = _t347;
                    j = k + 1;
                    while(1) {
                        __eflags = j - dim;
                        if(j >= dim) {
                            break;
                        }
                        _t347 =  *(A->me + (A->dim * k + j << 3)) * tmp;
                        asm("fsubp st1, st0");
                         *(A->me + (A->dim * i + j << 3)) = _t347;
                        j = j + 1;
                        __eflags = j;
                    }
                    i = i + 1;
                    __eflags = i;
                }
L30:
                k = k + 1;
                __eflags = k;
                continue;
            }
            tmp = indexarray[i_max];
            indexarray[i_max] = indexarray[k];
            indexarray[k] = tmp;
            j = 0;
            while(1) {
                __eflags = j - dim;
                if(j >= dim) {
                    goto L24;
                }
                tmp =  *(A->me + (A->dim * i_max + j << 3));
                 *(A->me + (A->dim * i_max + j << 3)) =  *(A->me + (A->dim * k + j << 3));
                _t347 = tmp;
                 *(A->me + (A->dim * k + j << 3)) = _t347;
                j = j + 1;
                __eflags = j;
            }
            goto L24;
        }
        asm("fldz");
         *(A->me + (A->dim + 1 << 3) * k) = _t347;
        goto L30;
    }
    return 0;
}

int LUsolve(Matrix A, int* indexarray, Vector b, Vector x)
{// addr = 0x0807FD68  --  defined in 'matrix.c' at line 128
    int i;                                 // _cfa_fffffff0
    int dim;                               // _cfa_ffffffec
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    __fp0 = __fp0;
    dim = A->dim;
    i = 0;
    while(i < dim) {
        __fp0 = b->ve[indexarray[i]];
        x->ve[i] = __fp0;
        i = i + 1;
    }
    asm("fld1");
    if(Lsolve(A, x, x, __fp0) == -1) {
L5:
        return -1;
    }
    asm("fldz");
    if(Usolve(A, x, x, __fp0) != -1) {
        return 0;
    }
    goto L5;
}

Matrix LUinverse(Matrix A, int* indexarray, Matrix out)
{// addr = 0x0807FE0A  --  defined in 'matrix.c' at line 155
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int dim;                               // _cfa_ffffffe8
    Vector tmp;         // _cfa_ffffffe4
    Vector tmp2;        // _cfa_ffffffe0
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    __fp0 = __fp0;
    dim = A->dim;
    if(out == 0) {
        out = new_matrix(dim);
    }
    tmp = new_vector(dim);
    tmp2 = new_vector(dim);
    i = 0;
    while(i < dim) {
        j = 0;
        while(j < dim) {
            asm("fldz");
            tmp->ve[j] = __fp0;
            j = j + 1;
        }
        asm("fld1");
        tmp->ve[i] = __fp0;
        if(LUsolve(A, indexarray, tmp, tmp2) != -1) {
            j = 0;
            while(j < dim) {
                __fp0 = tmp2->ve[j];
                 *(out->me + (out->dim * j + i << 3)) = __fp0;
                j = j + 1;
            }
            i = i + 1;
            continue;
        }
        return 0;
    }
    return out;
}

int Usolve(Matrix mat, Vector b, Vector out, double diag)
{// addr = 0x0807FF0A  --  defined in 'matrix.c' at line 182
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    int i_lim;                             // _cfa_fffffff0
    int dim;                               // _cfa_ffffffec
    double sum;                            // _cfa_ffffffe4
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed long long _v44;                 // _cfa_ffffffd4
    int _t69;                              // _t69
    int _t92;                              // _t92
    double _t129;                          // _t129

    _v44 = diag;
    _v40 = _a20;
    dim = mat->dim;
    i = dim - 1;
    while(i >= 0) {
        _t69 =  &(b->ve[i]);
        __eflags = _t69;
        _t129 =  *_t69;
        asm("fldz");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        st0 = _t129;
        if(__eflags != 0 || __eflags != 0) {
L7:
            i_lim = i;
            while(i >= 0) {
                sum = b->ve[i];
                j = i + 1;
                while(1) {
                    __eflags = j - i_lim;
                    if(__eflags > 0) {
                        break;
                    }
                    asm("fmulp st1, st0");
                    asm("fsubrp st1, st0");
                    sum = sum;
                    j = j + 1;
                    __eflags = j;
                }
                asm("fldz");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                st0 = _v44;
                if(__eflags != 0 || __eflags != 0) {
                    _t92 =  &(out->ve[i]);
                    __eflags = _t92;
                     *_t92 = sum / _v44;
                    goto L17;
                } else {
                    asm("fabs");
                    asm("fabs");
                    asm("fmulp st1, st0");
                    asm("fucomip st0, st1");
                    st0 = Tiny;
                    if(__eflags == 0) {
                        asm("fdivrp st1, st0");
                        out->ve[i] = sum;
L17:
                        i = i - 1;
                        __eflags = i;
                        continue;
                    }
                    return -1;
                }
            }
            return 0;
        } else {
            asm("fldz");
            out->ve[i] = _t129;
            i = i - 1;
            __eflags = i;
            continue;
        }
    }
    goto L7;
}

int Lsolve(Matrix mat, Vector b, Vector out, double diag)
{// addr = 0x08080075  --  defined in 'matrix.c' at line 217
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    int i_lim;                             // _cfa_fffffff0
    int dim;                               // _cfa_ffffffec
    double sum;                            // _cfa_ffffffe4
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed long long _v44;                 // _cfa_ffffffd4
    int _t69;                              // _t69
    int _t92;                              // _t92
    double _t129;                          // _t129

    _v44 = diag;
    _v40 = _a20;
    dim = mat->dim;
    i = 0;
    while(i < dim) {
        _t69 =  &(b->ve[i]);
        __eflags = _t69;
        _t129 =  *_t69;
        asm("fldz");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        st0 = _t129;
        if(__eflags != 0 || __eflags != 0) {
L7:
            i_lim = i;
            while(i < dim) {
                sum = b->ve[i];
                j = i_lim;
                while(1) {
                    __eflags = j - i;
                    if(__eflags >= 0) {
                        break;
                    }
                    asm("fmulp st1, st0");
                    asm("fsubrp st1, st0");
                    sum = sum;
                    j = j + 1;
                    __eflags = j;
                }
                asm("fldz");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                st0 = _v44;
                if(__eflags != 0 || __eflags != 0) {
                    _t92 =  &(out->ve[i]);
                    __eflags = _t92;
                     *_t92 = sum / _v44;
                    goto L17;
                } else {
                    asm("fabs");
                    asm("fabs");
                    asm("fmulp st1, st0");
                    asm("fucomip st0, st1");
                    st0 = Tiny;
                    if(__eflags == 0) {
                        asm("fdivrp st1, st0");
                        out->ve[i] = sum;
L17:
                        i = i + 1;
                        __eflags = i;
                        continue;
                    }
                    return -1;
                }
            }
            return 0;
        } else {
            asm("fldz");
            out->ve[i] = _t129;
            i = i + 1;
            __eflags = i;
            continue;
        }
    }
    goto L7;
}

Matrix new_matrix(int n)
{// addr = 0x080801DF  --  defined in 'matrix.c' at line 252
    Matrix mat;         // _cfa_fffffff0
    double* _t13;                          // _t13

     *__esp = 8;
    GC_malloc();
    mat = __eax;
    mat->dim = n;
    _t13 = n * n << 3;
     *__esp = _t13;
    GC_malloc_atomic();
    mat->me = _t13;
    return mat;
}

Vector new_vector(int n)
{// addr = 0x0808021B  --  defined in 'matrix.c' at line 267
    Vector vec;         // _cfa_fffffff0
    double* _t11;                          // _t11

     *__esp = 8;
    GC_malloc();
    vec = __eax;
    vec->dim = n;
    _t11 = n << 3;
     *__esp = _t11;
    GC_malloc_atomic();
    vec->ve = _t11;
    return vec;
}

double weight(int x)
{// addr = 0x08080253  --  defined in 'table.c' at line 70
    int _v16;                              // _cfa_fffffff0
    long long _v28;                        // _cfa_ffffffe4
    double _t6;                            // _t6
    double _t8;                            // _t8

    _t6 = COLS;
    if(x >= _t6) {
        _v16 = COLS;
        asm("fild dword [ebp-0xc]");
        _v28 = __fp0;
        asm("fild dword [ebp+0x8]");
        _t8 = COLS;
        _v16 = _t8;
        asm("fild dword [ebp-0xc]");
        asm("fdivp st1, st0");
         *__esp = __fp0;
        log();
        asm("fld1");
        asm("faddp st1, st0");
        return _t8;
    }
    asm("fild dword [ebp+0x8]");
    return _t6;
}

double weight2(int a)
{// addr = 0x08080297  --  defined in 'table.c' at line 80
    intOrPtr _v8;                          // _cfa_fffffff8

    asm("fild dword [ebp+0x8]");
    __eax = COLS;
    _v8 = __eax;
    asm("fild dword [ebp-0x4]");
    asm("fdivp st1, st0");
    asm("fmulp st1, st0");
    asm("fld1");
    asm("faddp st1, st0");
    return __eax;
}

int bsearch_2short(short int e1, short int* ent1, short int e2, short int* ent2, int base, short int* indexarray, int nent)
{// addr = 0x080802BB  --  defined in 'table.c' at line 104
    int n;                                 // _cfa_fffffff8
    int k;                                 // _cfa_fffffff4
    int e;                                 // _cfa_fffffff0
    int nn;                                // _cfa_ffffffec
    int idx;                               // _cfa_ffffffe8
    int ne;                                // _cfa_ffffffe4
    signed short _v40;                     // _cfa_ffffffd8
    short _v44;                            // _cfa_ffffffd4

    _v40 = e1;
    _v44 = e2;
    n = nent;
    k = 0;
    e = _v40 * base + _v44;
    while(n > 0) {
        nn = (n >> 31) + n >> 1;
        idx =  *(indexarray + k + nn + k + nn) & 65535;
        ne = ( *(ent1 + idx + idx) & 65535) * base + ( *(ent2 + idx + idx) & 65535);
        if(ne != e) {
            if(ne >= e) {
                n = nn;
            } else {
                n = n +  !nn;
                k = k + nn + 1;
            }
            continue;
        }
        k = k + nn;
        break;
    }
    return k;
}

int bsearch_double(double e, double* ent, short int* indexarray, int nent)
{// addr = 0x08080377  --  defined in 'table.c' at line 131
    int n;                                 // _cfa_fffffff8
    int k;                                 // _cfa_fffffff4
    int nn;                                // _cfa_fffffff0
    int idx;                               // _cfa_ffffffec
    double ne;                             // _cfa_ffffffe4
    double* _v40;                          // _cfa_ffffffd8
    long long _v44;                        // _cfa_ffffffd4
    int _t50;                              // _t50

    _v44 = e;
    _v40 = ent;
    n =  *(__ebp + 24);
    k = 0;
    while(1) {
        __eflags = n;
        if(n <= 0) {
            break;
        }
        nn = (n >> 31) + n >> 1;
        idx =  *(k + nn + k + nn + nent) & 65535;
        _t50 = indexarray + (idx << 3);
        __eflags = _t50;
        ne =  *_t50;
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        st0 = _v44;
        if(__eflags != 0 || __eflags != 0) {
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            st0 = _v44;
            if(__eflags == 0) {
                n = nn;
            } else {
                n = n +  !nn;
                k = k + nn + 1;
            }
            continue;
        } else {
            k = k + nn;
            break;
        }
    }
    return k;
}

int ceil_at_intervals(int x, int step)
{// addr = 0x0808041A  --  defined in 'table.c' at line 156
    int mo;                                // _cfa_fffffff8

    mo = x % step;
    if(mo <= 0) {
        if(mo < 0) {
            x = x - mo;
        }
    } else {
        x = x + step - mo;
    }
    return x;
}

int floor_at_intervals(int x, int step)
{// addr = 0x08080456  --  defined in 'table.c' at line 167
    int mo;                                // _cfa_fffffff8

    mo = x % step;
    if(mo <= 0) {
        if(mo < 0) {
            x = x + step - mo;
        }
    } else {
        x = x - mo;
    }
    return x;
}

int table_colspan(struct table* t, int row, int col)
{// addr = 0x08080492  --  defined in 'table.c' at line 221
    int i;                                 // _cfa_fffffff8

    i = col + 1;
    while(t->maxcol >= i && ( *(t->tabattr[row] + i + i) & 1) != 0) {
        i = i + 1;
    }
    return i - col;
}

int table_rowspan(struct table* t, int row, int col)
{// addr = 0x080804E4  --  defined in 'table.c' at line 229
    int i;                                 // _cfa_fffffff8

    if(t->tabattr[row] == 0) {
        return 0;
    }
    i = row + 1;
    while(t->maxrow >= i && t->tabattr[i] != 0 && ( *(t->tabattr[i] + col + col) & 2) != 0) {
        i = i + 1;
    }
    return i - row;
}

int minimum_cellspacing(int border_mode)
{// addr = 0x08080565  --  defined in 'table.c' at line 240
    int _t2;                               // _t2

    _t2 = border_mode;
    if(_t2 == 0) {
        return 1;
    }
    if(_t2 < 0 || _t2 > 3) {
        return 0;
    } else {
        return symbol_width;
    }
}

int table_border_width(struct table* t)
{// addr = 0x0808058D  --  defined in 'table.c' at line 256
    int _t16;                              // _t16

    _t16 = t->border_mode;
    if(_t16 > 2) {
        if(_t16 == 3) {
L7:
            return t->cellspacing * t->maxcol;
        }
L8:
        return 0;
    }
    if(_t16 >= 1) {
        return t->maxcol * t->cellspacing + t->cellpadding + symbol_width + t->cellpadding + symbol_width;
    }
    if(_t16 == 0) {
        goto L7;
    }
    goto L8;
}

struct table* newTable()
{// addr = 0x080805E9  --  defined in 'table.c' at line 272
    struct table* t;     // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    struct table* _t81;   // _t81
    struct table* _t82;   // _t82
    struct table* _t83;   // _t83
    struct _Str* _t84;    // _t84
    Str* _t85;             // _t85

     *__esp = 716;
    GC_malloc();
    t = __eax;
    _t81 = t;
    _t81->max_rowsize = 50;
     *__esp = 200;
    GC_malloc();
    _t82 = t;
    _t82->tabdata = _t81;
     *__esp = 200;
    GC_malloc();
    _t83 = t;
    _t83->tabattr = _t82;
     *__esp = 100;
    GC_malloc_atomic();
    _t84 = t;
     *(_t84 + 676) = _t83;
     *__esp = 200;
    GC_malloc();
    _t85 = t;
    _t85[0x14] = _t84;
     *__esp = 200;
    GC_malloc();
    t->tridvalue = _t85;
    i = 0;
    while(i <= 49) {
        t->tabdata[i] = 0;
        t->tabattr[i] = 0;
         *((short*)(t->tabheight + i + i)) = 0;
        t->tabidvalue[i] = 0;
         *(t->tridvalue + (i << 2)) = 0;
        i = i + 1;
    }
    j = 0;
    while(j <= 49) {
         *((short*)(t->maxrow + (j + 40) * 2)) = 0;
         *((short*)(t->maxcol + (j + 88) * 2)) = 0;
         *((short*)(t + (j + 144) * 2)) = 0;
        j = j + 1;
    }
    t->cell.maxcell = 65535;
    t->cell.icell = 65535;
    t->ntable = 0;
    t->tables_size = 0;
    t->tables = 0;
    t->matrix = 0;
    t->vector = 0;
    t->linfo.prevchar = Strnew_size(8);
    Strcopy_charp_n(t->linfo.prevchar, 135049312, 0);
    t->trattr = 0;
    t->caption = Strnew();
    t->suspended_data = 0;
    t->id = 0;
    return t;
}

void check_row(struct table* t, int row)
{// addr = 0x080807E9  --  defined in 'table.c' at line 329
    int i;                                 // _cfa_fffffff0
    int r;                                 // _cfa_ffffffec
    GeneralList*** tabdata;   // _cfa_ffffffe8
    table_attr** tabattr;   // _cfa_ffffffe4
    short int* tabheight;                  // _cfa_ffffffe0
    Str** tabidvalue;      // _cfa_ffffffdc
    Str* tridvalue;        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ _t144;                       // _t144
    GeneralList*** _t147;   // _t147
    table_attr** _t149;   // _t149
    short int* _t151;                      // _t151
    Str** _t153;           // _t153
    Str* _t155;            // _t155
    _unknown_ _t228;                       // _t228

    if(t->max_rowsize <= row) {
        _t228 = row + 1;
        _t144 = t->max_rowsize + t->max_rowsize;
        _t145 = _t228 - _t144 >= 0 ? _t228 : _t144;
        r = _t228 - _t144 >= 0 ? _t228 : _t144;
        _t147 = r << 2;
         *__esp = _t147;
        GC_malloc();
        tabdata = _t147;
        _t149 = r << 2;
         *__esp = _t149;
        GC_malloc();
        tabattr = _t149;
        _t151 = r + r;
         *__esp = _t151;
        GC_malloc_atomic();
        tabheight = _t151;
        _t153 = r << 2;
         *__esp = _t153;
        GC_malloc();
        tabidvalue = _t153;
        _t155 = r << 2;
         *__esp = _t155;
        GC_malloc();
        tridvalue = _t155;
        i = 0;
        while(t->max_rowsize > i) {
            tabdata[i] = t->tabdata[i];
            tabattr[i] = t->tabattr[i];
             *((short*)(tabheight + i + i)) =  *(t->tabheight + i + i) & 65535;
            tabidvalue[i] = t->tabidvalue[i];
             *(tridvalue + (i << 2)) =  *(t->tridvalue + (i << 2));
            i = i + 1;
        }
        while(i < r) {
            tabdata[i] = 0;
            tabattr[i] = 0;
             *((short*)(tabheight + i + i)) = 0;
            tabidvalue[i] = 0;
             *(tridvalue + (i << 2)) = 0;
            i = i + 1;
        }
        t->tabdata = tabdata;
        t->tabattr = tabattr;
        t->tabheight = tabheight;
        t->tabidvalue = tabidvalue;
        t->tridvalue = tridvalue;
        t->max_rowsize = r;
    }
    if(t->tabdata[row] == 0) {
         *__esp = 200;
        GC_malloc();
        t->tabdata[row] = t->tabdata;
         *__esp = 100;
        GC_malloc_atomic();
        t->tabattr[row] = t->tabattr;
         *__esp = 200;
        GC_malloc();
        t->tabidvalue[row] = t->tabidvalue;
        i = 0;
        while(i <= 49) {
            t->tabdata[row][i] = 0;
             *((short*)(t->tabattr[row] + i + i)) = 0;
            t->tabidvalue[row][i] = 0;
            i = i + 1;
        }
    }
}

void pushdata(struct table* t, int row, int col, char* data)
{// addr = 0x08080A82  --  defined in 'table.c' at line 394
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    const char* _t29;   // _t29

    check_row(t, row);
    if(t->tabdata[row][col] == 0) {
        t->tabdata[row][col] = newGeneralList();
    }
    if(data == 0) {
        _t29 = 135049312;
    } else {
        _t29 = data;
    }
    pushValue(t->tabdata[row][col], allocStr(_t29, -1));
}

void suspend_or_pushdata(struct table* tbl, char* line)
{// addr = 0x08080B25  --  defined in 'table.c' at line 404
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    const char* _t26;   // _t26

    if((tbl->flag & 4) == 0) {
        if(tbl->suspended_data == 0) {
            tbl->suspended_data = newGeneralList();
        }
        if(line == 0) {
            _t26 = 135049312;
        } else {
            _t26 = line;
        }
        pushValue(tbl->suspended_data, allocStr(_t26, -1));
        return;
    }
    pushdata(tbl, tbl->row, tbl->col, line);
}

int visible_length(char* str)
{// addr = 0x08080BB3  --  defined in 'table.c' at line 423
    int len;                               // _cfa_fffffff0
    int n;                                 // _cfa_ffffffec
    int max_len;                           // _cfa_ffffffe8
    int status;                            // _cfa_ffffffe4
    int prev_status;                       // _cfa_ffffffe0
    Str tagbuf;            // _cfa_ffffffdc
    char* t;                               // _cfa_ffffffd8
    char* r2;                              // _cfa_ffffffd4
    int amp_len;                           // _cfa_ffffffd0
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t168;                             // _t168
    _unknown_ _t192;                       // _t192
    int _t203;                             // _t203
    int _t214;                             // _t214

    len = 0;
    max_len = 0;
    status = 0;
    prev_status = status;
    tagbuf = Strnew();
    amp_len = 0;
    t = str;
    while(( *str & 255) != 0) {
        if(status != 1) {
            if(status == 2 || status == 4 || status == 3 || status == 5 || status == 15) {
                Strcat_charp_n(tagbuf, str, n);
            } else {
                if(status != 6) {
                    if(status != 0 || prev_status != 6) {
                        if(status != 0 || prev_status != 2 && prev_status != 1 && prev_status != 5 && prev_status != 15) {
                            if(( *str & 255) != 9) {
                                if(( *str & 255) == 13 || ( *str & 255) == 10) {
                                    len = len - 1;
                                    if(len > max_len) {
                                        max_len = len;
                                    }
                                    len = 0;
                                }
                            } else {
                                len = len - 1;
                                do {
                                    len = len + 1;
                                } while((visible_length_offset + len) % Tabstop != 0);
                            }
                        }
                    } else {
                        Strcat_charp_n(tagbuf, str, n);
                        r2 = tagbuf->ptr;
                        t = getescapecmd( &r2);
                        if(( *r2 & 255) != 0 || ( *t & 255) != 13 && ( *t & 255) != 10) {
                            _t168 = wtf_strwidth(t);
                            len = len + _t168 + wtf_strwidth(r2);
                        } else {
                            if(len > max_len) {
                                max_len = len;
                            }
                            len = 0;
                        }
                    }
                } else {
                    if(prev_status != 0) {
                        Strcat_charp_n(tagbuf, str, n);
                        amp_len = amp_len + 1;
                    } else {
                        Strclear(tagbuf);
                        len = len - 1;
                        amp_len = 0;
                    }
                }
            }
            goto L42;
        } else {
            Strclear(tagbuf);
            Strcat_charp_n(tagbuf, str, n);
L42:
            str =  &(str[n]);
            continue;
        }
    }
    if(status == 6) {
        r2 = tagbuf->ptr;
        t = getescapecmd( &r2);
        if(( *t & 255) != 13 && ( *t & 255) != 10) {
            _t214 = wtf_strwidth(t);
            len = len + _t214 + wtf_strwidth(r2);
        }
    }
    _t203 = len;
    _t204 = max_len - _t203 >= 0 ? max_len : _t203;
    return max_len - _t203 >= 0 ? max_len : _t203;
}

int visible_length_plain(char* str)
{// addr = 0x08080EB9  --  defined in 'table.c' at line 510
    int len;                               // _cfa_fffffff8
    int max_len;                           // _cfa_fffffff4
    signed int _t53;                       // _t53
    int _t67;                              // _t67

    len = 0;
    max_len = 0;
    while(( *str & 255) != 0) {
        if(( *str & 255) != 9) {
            if(( *str & 255) == 13 || ( *str & 255) == 10) {
                if(len > max_len) {
                    max_len = len;
                }
                len = 0;
                str =  &(str[1]);
            } else {
                if(( *135119023 & 255) == 0) {
                    _t53 = ( *( &WTF_WIDTH_MAP + ( *str & 0xff)) & 255) != 0 & 255;
                } else {
                    _t53 =  *( &WTF_WIDTH_MAP + ( *str & 0xff)) & 0xff;
                }
                len = len + _t53;
                str =  &(str[ *( &WTF_LEN_MAP + ( *str & 0xff)) & 0xff]);
            }
            continue;
        } else {
            goto L2;
        }
        do {
        } while();
        continue;
L2:
        len = len + 1;
        if((visible_length_offset + len) % Tabstop != 0) {
            goto L2;
        } else {
            str =  &(str[1]);
        }
    }
    _t67 = len;
    _t68 = max_len - _t67 >= 0 ? max_len : _t67;
    return max_len - _t67 >= 0 ? max_len : _t67;
}

int maximum_visible_length(char* str, int offset)
{// addr = 0x08080F9E  --  defined in 'table.c' at line 541
    visible_length_offset = offset;
    return visible_length(str);
}

int maximum_visible_length_plain(char* str, int offset)
{// addr = 0x08080FB9  --  defined in 'table.c' at line 548
    visible_length_offset = offset;
    return visible_length_plain(str);
}

void align(TextLine* lbuf, int width, int mode)
{// addr = 0x08080FD4  --  defined in 'table.c' at line 555
    int i;                                 // _cfa_fffffff0
    int l;                                 // _cfa_ffffffec
    int l1;                                // _cfa_ffffffe8
    int l2;                                // _cfa_ffffffe4
    Str buf;               // _cfa_ffffffe0
    Str line;              // _cfa_ffffffdc
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    int _t156;                             // _t156
    int _t166;                             // _t166
    int _t186;                             // _t186
    int _t207;                             // _t207
    int _t223;                             // _t223
    int _t237;                             // _t237

    line = lbuf->line;
    if(line->length == 0) {
        i = 0;
        while(i < width) {
            if(line->length + 1 >= line->area_size) {
                Strgrow(line);
            }
            _t237 = line->length;
             *((char*)(line->ptr + _t237)) = 32;
            line->length = _t237 + 1;
             *((char*)(line->ptr + line->length)) = 0;
            i = i + 1;
        }
        lbuf->pos = width;
        return;
    }
    buf = Strnew();
    l = width - (lbuf->pos & 65535);
    _t156 = mode;
    if(_t156 == 1) {
        Strcat(buf, line);
        i = 0;
        while(i < l) {
            if(buf->length + 1 >= buf->area_size) {
                Strgrow(buf);
            }
            _t166 = buf->length;
             *((char*)(buf->ptr + _t166)) = 32;
            buf->length = _t166 + 1;
             *((char*)(buf->ptr + buf->length)) = 0;
            i = i + 1;
        }
        goto L33;
    } else {
        if(_t156 == 2) {
            i = 0;
            while(i < l) {
                if(buf->length + 1 >= buf->area_size) {
                    Strgrow(buf);
                }
                _t186 = buf->length;
                 *((char*)(buf->ptr + _t186)) = 32;
                buf->length = _t186 + 1;
                 *((char*)(buf->ptr + buf->length)) = 0;
                i = i + 1;
            }
            Strcat(buf, line);
            goto L33;
        } else {
            if(_t156 != 0) {
            } else {
                l1 = (l >> 31) + l >> 1;
                l2 = l - l1;
                i = 0;
                while(i < l1) {
                    if(buf->length + 1 >= buf->area_size) {
                        Strgrow(buf);
                    }
                    _t207 = buf->length;
                     *((char*)(buf->ptr + _t207)) = 32;
                    buf->length = _t207 + 1;
                     *((char*)(buf->ptr + buf->length)) = 0;
                    i = i + 1;
                }
                Strcat(buf, line);
                i = 0;
                while(i < l2) {
                    if(buf->length + 1 >= buf->area_size) {
                        Strgrow(buf);
                    }
                    _t223 = buf->length;
                     *((char*)(buf->ptr + _t223)) = 32;
                    buf->length = _t223 + 1;
                     *((char*)(buf->ptr + buf->length)) = 0;
                    i = i + 1;
                }
L33:
                lbuf->line = buf;
                if((lbuf->pos & 65535) < width) {
                    lbuf->pos = width;
                    return;
                }
            }
        }
    }
}

void print_item(struct table* t, int row, int col, int width, Str buf)
{// addr = 0x08081299  --  defined in 'table.c' at line 597
    int alignment;                         // _cfa_fffffff0
    TextLine* lbuf;   // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(t->tabdata[row] == 0) {
        lbuf = 0;
    } else {
        lbuf = popValue(t->tabdata[row][col]);
    }
    if(lbuf == 0) {
        lbuf = newTextLine(0, 0);
        align(lbuf, width, 0);
        Strcat(buf, lbuf->line);
        return;
    } else {
        check_row(t, row);
        alignment = 0;
        if(( *(t->tabattr[row] + col + col) & 0x30) != 0) {
            if(( *(t->tabattr[row] + col + col) & 0x30) != 32) {
                if(( *(t->tabattr[row] + col + col) & 0x30) == 16) {
                    alignment = 0;
                }
            } else {
                alignment = 2;
            }
        } else {
            alignment = 1;
        }
        align(lbuf, width, alignment);
        Strcat(buf, lbuf->line);
        return;
    }
}

void print_sep(struct table* t, int row, int type, int maxcol, Str buf)
{// addr = 0x08081401  --  defined in 'table.c' at line 632
    int forbid;                            // _cfa_fffffff0
    int rule_mode;                         // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    int k;                                 // _cfa_ffffffe4
    int l;                                 // _cfa_ffffffe0
    int m;                                 // _cfa_ffffffdc
    int w;                                 // _cfa_ffffffd8
    signed int _v48;                       // _cfa_ffffffd0
    _unknown_ _v76;                        // _cfa_ffffffb4 (outparam)
    _unknown_ _v80;                        // _cfa_ffffffb0 (outparam)
    _unknown_ _v84;                        // _cfa_ffffffac (outparam)
    _unknown_ _v88;                        // _cfa_ffffffa8 (outparam)
    char _t215;                            // _t215
    char _t251;                            // _t251
    char _t330;                            // _t330
    char _t337;                            // _t337
    int _t349;                             // _t349
    int _t368;                             // _t368
    int _t391;                             // _t391
    int _t409;                             // _t409

    if(row >= 0) {
        check_row(t, row);
    }
    check_row(t, row + 1);
    if(type == 0 || type == 2) {
        if(t->border_mode != 2) {
            goto L6;
        } else {
            rule_mode = 2;
            goto L7;
        }
    } else {
L6:
        rule_mode = 1;
L7:
        forbid = 1;
        if(type != 0) {
            if(type != 2) {
                if(( *(t->tabattr[row + 1]) & 2) != 0) {
                    forbid = forbid | 4;
                }
            } else {
                forbid = forbid | 8;
            }
        } else {
            forbid = forbid | 2;
        }
        if(t->border_mode != 3) {
            _t409 = symbol_width;
            if(t->border_mode != 2) {
                _t337 = forbid;
            } else {
                _t337 = forbid + 16;
            }
            push_symbol(buf, _t337, _t409, 1);
        }
        i = 0;
        while(i <= maxcol) {
            forbid = 10;
            if(type == 2 || ( *(t->tabattr[row + 1] + i + i) & 2) == 0) {
                w = ( *(t->maxrow + (i + 40) * 2) & 65535) + t->cellpadding + t->cellpadding;
                if(symbol_width == 2) {
                    _v48 = symbol_width;
                    w = (w + 1) / _v48;
                }
                _t349 = symbol_width;
                if(rule_mode != 2) {
                    _t215 = forbid;
                } else {
                    _t215 = forbid + 16;
                }
                push_symbol(buf, _t215, _t349, w);
            } else {
                if(( *(t->tabattr[row + 1] + i + i) & 1) != 0) {
L39:
                    if(i < maxcol) {
                        forbid = 0;
                        if(type != 0) {
                            if(( *(t->tabattr[row] + i + 1 + i + 1) & 1) != 0) {
                                forbid = forbid | 2;
                            }
                        } else {
                            forbid = forbid | 2;
                        }
                        if(type != 2) {
                            if(( *(t->tabattr[row + 1] + i + 1 + i + 1) & 1) != 0) {
                                forbid = forbid | 8;
                            }
                            if(( *(t->tabattr[row + 1] + i + 1 + i + 1) & 2) != 0) {
                                forbid = forbid | 4;
                            }
                            if(( *(t->tabattr[row + 1] + i + i) & 2) != 0) {
                                forbid = forbid | 1;
                            }
                        } else {
                            forbid = forbid | 8;
                        }
                        if(forbid != 15) {
                            _t391 = symbol_width;
                            if(rule_mode != 2) {
                                _t251 = forbid;
                            } else {
                                _t251 = forbid + 16;
                            }
                            push_symbol(buf, _t251, _t391, 1);
                        }
                    }
                    i = i + 1;
                    continue;
                }
                k = row;
                while(k >= 0 && t->tabattr[k] != 0 && ( *(t->tabattr[k] + i + i) & 2) != 0) {
                    k = k - 1;
                }
                m = ( *(t->maxrow + (i + 40) * 2) & 65535) + t->cellpadding + t->cellpadding;
                l = i + 1;
                while(t->maxcol >= l && ( *(t->tabattr[row] + l + l) & 1) != 0) {
                    m = m + t->cellspacing + ( *(t->maxrow + (l + 40) * 2) & 65535);
                    l = l + 1;
                }
                print_item(t, k, i, m, buf);
            }
            goto L39;
        }
        forbid = 4;
        if(type == 0) {
            forbid = forbid | 2;
        }
        if(type == 2) {
            forbid = forbid | 8;
        }
        if(( *(t->tabattr[row + 1] + maxcol + maxcol) & 2) != 0) {
            forbid = forbid | 1;
        }
        if(t->border_mode == 3) {
            return;
        } else {
            _t368 = symbol_width;
            if(t->border_mode != 2) {
                _t330 = forbid;
            } else {
                _t330 = forbid + 16;
            }
            push_symbol(buf, _t330, _t368, 1);
            return;
        }
    }
}

int get_spec_cell_width(struct table* tbl, int row, int col)
{// addr = 0x08081881  --  defined in 'table.c' at line 719
    int i;                                 // _cfa_fffffff0
    int w;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    w =  *(tbl->maxrow + (col + 40) * 2) & 65535;
    i = col + 1;
    while(tbl->maxcol >= i) {
        check_row(tbl, row);
        if(( *(tbl->tabattr[row] + i + i) & 1) != 0) {
            w = w + tbl->cellspacing + ( *(tbl->maxrow + (i + 40) * 2) & 65535);
            i = i + 1;
            continue;
        }
L6:
        return w;
    }
    goto L6;
}

void do_refill(struct table* tbl, int row, int col, int maxlimit)
{// addr = 0x0808190E  --  defined in 'table.c' at line 735
    TextList* orgdata;   // _cfa_ffffffe0
    TextListItem* l;   // _cfa_ffffffdc
    int colspan;                           // _cfa_ffffffd8
    int icell;                             // _cfa_ffffffd4
    int id;                                // _cfa_ffffffd0
    char* p;                               // _cfa_ffffffcc
    struct parsed_tag* tag;   // _cfa_ffffffc8
    int alignment;                         // _cfa_ffffffc4
    TextLineListItem* ti;   // _cfa_ffffffc0
    struct table* t;     // _cfa_ffffffbc
    int limit;                             // _cfa_ffffffb8
    int rowspan;                           // _cfa_ffffffb4
    struct table_cell* cell;   // _cfa_ffffffb0
    int k;                                 // _cfa_ffffffac
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ _v112;                       // _cfa_ffffff90
    _unknown_ _v116;                       // _cfa_ffffff8c
    _unknown_ _v128;                       // _cfa_ffffff80
    struct html_feed_environ h_env;   // _cfa_ffffff7c
    struct environment[19] envs;   // _cfa_fffffe3c
    _unknown_ _v728;                       // _cfa_fffffd28
    _unknown_ _v776;                       // _cfa_fffffcf8
    struct readbuffer obuf;   // _cfa_fffffcec
    _unknown_ _v804;                       // _cfa_fffffcdc (outparam)
    _unknown_ _v808;                       // _cfa_fffffcd8 (outparam)
    _unknown_ _v812;                       // _cfa_fffffcd4 (outparam)
    _unknown_ _v816;                       // _cfa_fffffcd0 (outparam)
    intOrPtr _v820;                        // _cfa_fffffccc (outparam)
    char* _v824;                           // _cfa_fffffcc8 (outparam)
    _unknown_ __ebx;                       // r1
    char* _t310;                           // _t310

    if( *((intOrPtr*)(tbl->tabdata.col + (row << 2))) == 0) {
        return;
    }
    if( *( *((intOrPtr*)(tbl->tabdata.col + (row << 2))) + (col << 2)) == 0) {
        goto L57;
    } else {
        orgdata =  *( *((intOrPtr*)(tbl->tabdata.col + (row << 2))) + (col << 2));
         *( *((intOrPtr*)(tbl->tabdata.col + (row << 2))) + (col << 2)) = newGeneralList();
        init_henv( &(h_env.obuf),  &(obuf.line),  &envs, 20,  *( *((intOrPtr*)(tbl->tabdata.col + (row << 2))) + (col << 2)), get_spec_cell_width(tbl, row, col), 0);
        obuf.flag = obuf.flag | 131072;
        if(h_env.limit > maxlimit) {
            h_env.limit = maxlimit;
        }
        if(tbl->border_mode.col != 0) {
            if(tbl->vcellpadding.col > 0) {
                do_blankline( &(h_env.obuf),  &(obuf.line), 0, 0, h_env.limit);
            }
        }
        l = orgdata->first;
        while(l != 0) {
            _t310 = l->ptr;
            _v820 = 10;
            _v824 = "<table_alt";
             *__esp = _t310;
            strncasecmp();
            if(_t310 != 0 || (l->ptr->prev & 255) != 62 && ( *( &MYCTYPE_MAP + (l->ptr->prev & 0xff)) & 2) == 0) {
                HTMLlineproc0(l->ptr,  &(h_env.obuf), 1);
                goto L35;
            } else {
                id = -1;
                p = l->ptr;
                tag = parse_tag( &p, 1);
                if(tag != 0) {
                    parsedtag_get_value(tag, 64,  &id);
                }
                if(id < 0) {
L35:
                    l = l->next;
                    continue;
                }
                if((tbl->ntable.col & 65535) <= id) {
                    goto L35;
                } else {
                    t =  *(tbl->tables.col + (id << 4));
                    limit = ((tbl->tables.col + (id << 4))[2] & 65535) + t->total_width;
                     *(tbl->tables.col + (id << 4)) = 0;
                    save_fonteffect( &(h_env.obuf), h_env.obuf);
                    flushline( &(h_env.obuf),  &(obuf.line), 0, 2, h_env.limit);
                    if(t->vspace > 0 && (obuf.flag & 8192) == 0) {
                        do_blankline( &(h_env.obuf),  &(obuf.line), 0, 0, h_env.limit);
                    }
                    if(( *(h_env.obuf + 12) & 112) != 32) {
                        if(( *(h_env.obuf + 12) & 112) != 64) {
                            alignment = 1;
                        } else {
                            alignment = 2;
                        }
                    } else {
                        alignment = 0;
                    }
                    if(alignment == 1) {
L27:
                        appendGeneralList(h_env.buf, (tbl->tables.col + (id << 4))[3]);
                        if(h_env.maxlimit < limit) {
                            h_env.maxlimit = limit;
                        }
                        restore_fonteffect( &(h_env.obuf), h_env.obuf);
                        obuf.flag = obuf.flag & 223;
                        h_env.blank_lines = 0;
                        if(t->vspace > 0) {
                            do_blankline( &(h_env.obuf),  &(obuf.line), 0, 0, h_env.limit);
                            obuf.flag = obuf.flag | 32;
                        }
                        goto L35;
                    } else {
                        ti =  *((tbl->tables.col + (id << 4))[3]);
                        while(ti != 0) {
                            align(ti->ptr, h_env.limit, alignment);
                            ti = ti->next;
                        }
                        goto L27;
                    }
                }
            }
        }
        if(obuf.status != 0) {
            obuf.status = 7;
            HTMLlineproc0(135049324,  &(h_env.obuf), 1);
        }
        completeHTMLstream( &(h_env.obuf),  &(obuf.line));
        flushline( &(h_env.obuf),  &(obuf.line), 0, 2, h_env.limit);
        if(tbl->border_mode.col != 0) {
            if(tbl->vcellpadding.col <= 0) {
                purgeline( &(h_env.obuf));
            } else {
                if((obuf.flag & 8192) == 0) {
                    do_blankline( &(h_env.obuf),  &(obuf.line), 0, 0, h_env.limit);
                }
            }
        } else {
            rowspan = table_rowspan(tbl, row, col);
            if(row + rowspan > tbl->maxrow.col) {
                if(tbl->vspace.col > 0) {
                    purgeline( &(h_env.obuf));
                }
            } else {
                if(tbl->vcellpadding.col > 0 && (obuf.flag & 8192) == 0) {
                    do_blankline( &(h_env.obuf),  &(obuf.line), 0, 0, h_env.limit);
                }
            }
        }
        colspan = table_colspan(tbl, row, col);
        if(colspan <= 1) {
            if(( *(tbl->maxcol + (col + 88) * 2) & 65535) >= h_env.maxlimit) {
                goto L57;
            }
             *(tbl->maxcol + (col + 88) * 2) = h_env.maxlimit;
            return;
        } else {
            cell =  &(tbl->cell);
            k = bsearch_2short(colspan,  &(cell->colspan), col, cell, 50,  &(cell->index), (cell->maxcell & 65535) + 1);
            icell =  *(cell + (k + 40) * 2) & 65535;
            if((cell->col[icell + 96] & 65535) >= h_env.maxlimit) {
L57:
                return;
            }
            cell->col[icell + 96] = h_env.maxlimit;
            return;
        }
    }
}

int table_rule_width(struct table* t)
{// addr = 0x08081FAE  --  defined in 'table.c' at line 842
    if(t->border_mode != 0) {
        return symbol_width;
    }
    return 1;
}

void check_cell_width(short int* tabwidth, short int* cellwidth, short int* col, short int* colspan, short int maxcell, short int* indexarray, int space, int dir)
{// addr = 0x08081FC9  --  defined in 'table.c' at line 850
    int i;                                 // _cfa_fffffff4
    int j;                                 // _cfa_fffffff0
    int k;                                 // _cfa_ffffffec
    int bcol;                              // _cfa_ffffffe8
    int ecol;                              // _cfa_ffffffe4
    int swidth;                            // _cfa_ffffffe0
    int width;                             // _cfa_ffffffdc
    int w;                                 // _cfa_ffffffd8
    int r;                                 // _cfa_ffffffd4
    short _v60;                            // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    _unknown_ __ebx;                       // r1

    _v60 = maxcell;
    k = 0;
    while(_v60 >= k) {
        j =  *(indexarray + k + k) & 65535;
        if(( *(cellwidth + j + j) & 65535) <= 0) {
L17:
            k = k + 1;
            continue;
        }
        bcol =  *(col + j + j) & 65535;
        ecol = ( *(colspan + j + j) & 65535) + bcol;
        swidth = 0;
        i = bcol;
        while(i < ecol) {
            swidth = swidth + ( *(tabwidth + i + i) & 65535);
            i = i + 1;
        }
        width = ( *(cellwidth + j + j) & 65535) + (1 - ( *(colspan + j + j) & 65535)) * space;
        if(width <= swidth) {
            goto L17;
        }
        _v68 =  *(colspan + j + j) & 65535;
        w = (width - swidth) / _v68;
        _v64 =  *(colspan + j + j) & 65535;
        r = (width - swidth) % _v64;
        i = bcol;
        while(i < ecol) {
             *(tabwidth + i + i) = ( *(tabwidth + i + i) & 65535) + w;
            i = i + 1;
        }
        if(dir == 1 && r > 0) {
            r =  *(colspan + j + j) & 65535;
        }
        i = 1;
        while(i <= r) {
             *(tabwidth + ecol - i + ecol - i) = ( *(tabwidth + ecol - i + ecol - i) & 65535) + 1;
            i = i + 1;
        }
        goto L17;
    }
}

void check_minimum_width(struct table* t, short int* tabwidth)
{// addr = 0x0808216A  --  defined in 'table.c' at line 883
    int i;                                 // _cfa_ffffffec
    struct table_cell* cell;   // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ __ebx;                       // r1

    cell =  &(t->cell);
    i = 0;
    while(t->maxcol >= i) {
        if(( *(tabwidth + i + i) & 65535) < ( *(t->maxcol + (i + 88) * 2) & 65535)) {
             *(tabwidth + i + i) =  *(t->maxcol + (i + 88) * 2) & 65535;
        }
        i = i + 1;
    }
    check_cell_width(tabwidth,  &(cell->minimum_width), cell,  &(cell->colspan), cell->maxcell & 65535,  &(cell->index), t->cellspacing, 0);
}

void check_maximum_width(struct table* t)
{// addr = 0x08082228  --  defined in 'table.c' at line 898
    struct table_cell* cell;   // _cfa_fffffff8
    int i;                                 // _cfa_fffffff4
    int j;                                 // _cfa_fffffff0
    int bcol;                              // _cfa_ffffffec
    int ecol;                              // _cfa_ffffffe8
    int swidth;                            // _cfa_ffffffe4
    int width;                             // _cfa_ffffffe0

    cell =  &(t->cell);
    cell->necell = 0;
    j = 0;
    while((cell->maxcell & 65535) >= j) {
        bcol =  *(cell + j * 2) & 65535;
        ecol = ( *(cell->col + (j + 16) * 2) & 65535) + bcol;
        swidth = 0;
        i = bcol;
        while(i < ecol) {
            swidth = swidth + ( *(t->maxrow + (i + 40) * 2) & 65535);
            i = i + 1;
        }
        width = ( *(cell->col + (j + 80) * 2) & 65535) + t->cellspacing * (1 - ( *(cell->col + (j + 16) * 2) & 65535));
        if(width > swidth) {
             *((short*)(cell->col + ((cell->necell & 65535) + 56) * 2)) = j;
            cell->necell = (cell->necell & 65535) + 1;
        }
        j = j + 1;
    }
}

void set_integered_width(struct table* t, double* dwidth, short int* iwidth)
{// addr = 0x0808232A  --  defined in 'table.c' at line 929
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int k;                                 // _cfa_ffffffe8
    int n;                                 // _cfa_ffffffe4
    int bcol;                              // _cfa_ffffffe0
    int ecol;                              // _cfa_ffffffdc
    int step;                              // _cfa_ffffffd8
    short int* indexarray;                 // _cfa_ffffffd4
    char* fixed;                           // _cfa_ffffffd0
    double* mod;                           // _cfa_ffffffcc
    struct table_cell* cell;   // _cfa_ffffffc8
    int rulewidth;                         // _cfa_ffffffc4
    int ii;                                // _cfa_ffffffc0
    int nn;                                // _cfa_ffffffbc
    char* idx;                             // _cfa_ffffffb8
    int ii;                                // _cfa_ffffffb4
    int ii;                                // _cfa_ffffffb0
    int kk;                                // _cfa_ffffffac
    int w;                                 // _cfa_ffffffa8
    int width;                             // _cfa_ffffffa4
    int m;                                 // _cfa_ffffffa0
    int ii;                                // _cfa_ffffff9c
    int ii;                                // _cfa_ffffff98
    int ii;                                // _cfa_ffffff94
    double sum;                            // _cfa_ffffff8c
    double x;                              // _cfa_ffffff84
    double nsum;                           // _cfa_ffffff7c
    int _v144;                             // _cfa_ffffff70
    _unknown_ _v146;                       // _cfa_ffffff6e
    short _v148;                           // _cfa_ffffff6c
    short _v150;                           // _cfa_ffffff6a
    _unknown_ _v172;                       // _cfa_ffffff54 (outparam)
    _unknown_ _v176;                       // _cfa_ffffff50 (outparam)
    _unknown_ _v180;                       // _cfa_ffffff4c (outparam)
    intOrPtr _v184;                        // _cfa_ffffff48 (outparam)
    _unknown_ __ebx;                       // r1
    short int* _t329;                      // _t329
    double* _t333;                         // _t333
    char* _t368;                           // _t368
    struct table* _t377;   // _t377
    int _t418;                             // _t418
    struct table* _t424;   // _t424
    int _t428;                             // _t428
    char* _t429;                           // _t429
    struct table_cell* _t430;   // _t430
    struct table_cell* _t476;   // _t476
    struct table_cell* _t495;   // _t495
    int _t516;                             // _t516
    int _t528;                             // _t528
    int _t558;                             // _t558
    signed int _t573;                      // _t573
    signed int _t603;                      // _t603
    signed int _t606;                      // _t606
    double _t623;                          // _t623

    _t623 = __fp0;
    asm("fldz");
    sum = __fp0;
    asm("fldz");
    x = __fp0;
    cell =  &(t->cell);
    rulewidth = table_rule_width(t);
    _t329 =  &((t->maxcol + 1)[t->maxcol + 1]);
     *__esp = _t329;
    GC_malloc_atomic();
    indexarray = _t329;
    _t333 = t->maxcol + 1 << 3;
     *__esp = _t333;
    GC_malloc_atomic();
    mod = _t333;
    i = 0;
    goto L2;
    do {
    } while();
L9:
    while(t->maxcol >= k) {
        x = mod[k];
        sum = sum + x;
        i = bsearch_double(x, mod, indexarray, k);
        __eflags = k - i;
        if(k <= i) {
L8:
             *((short*)(indexarray + i + i)) = k;
            k = k + 1;
            __eflags = k;
            continue;
        } else {
            ii = k;
            do {
                __eflags = ii - i;
            } while(ii > i);
            goto L8;
        }
    }
    _t368 = t->maxcol + 1;
     *__esp = _t368;
    GC_malloc_atomic();
    fixed = _t368;
    _v184 = t->maxcol + 1;
     *__esp = fixed;
    bzero();
    step = 0;
    while(step <= 1) {
        i = 0;
        while(1) {
L83:
            __eflags = t->maxcol - i;
            if(__eflags < 0) {
                break;
            }
            asm("fucomip st0, st1");
            st0 =  *135050696;
            if(i != 0) {
                return;
            }
            n = 0;
            while(1) {
                _t377 = t;
                __eflags = i + n - _t377->maxcol;
                if(i + n > _t377->maxcol) {
                    break;
                }
                ii =  *(indexarray + i + n + i + n) & 65535;
                __eflags = n;
                if(__eflags != 0) {
                    asm("fabs");
                    asm("fxch st0, st1");
                    asm("fucomip st0, st1");
                    st0 =  *135050704;
                    if(__eflags != 0) {
L21:
                        k = 0;
                        while(1) {
                            __eflags = k - n;
                            if(k >= n) {
                                break;
                            }
                            ii =  *(indexarray + i + k + i + k) & 65535;
                            __eflags = (fixed[ii] & 255) - 1;
                            if((fixed[ii] & 255) <= 1) {
                                _t419 = ii;
                                _t424 = t;
                                _t573 = ii + 88;
                                __eflags = ( *(iwidth + ii + _t419) & 65535) - rulewidth - ( *(_t424->maxcol + _t573 * 2) & 65535);
                                if(( *(iwidth + ii + _t419) & 65535) - rulewidth < ( *(_t424->maxcol + _t573 * 2) & 65535)) {
                                    _t428 =  &(fixed[ii]);
                                    __eflags = _t428;
                                     *_t428 = 2;
                                }
                            }
                            __eflags = fixed[ii] & 255;
                            if((fixed[ii] & 255) <= 0) {
                                __eflags = ( *(iwidth + ii + ii) & 65535) - rulewidth - ( *(t->maxrow + (ii + 40) * 2) & 65535);
                                if(__eflags < 0) {
                                    asm("fild dword [ebp-0x38]");
                                    asm("fsubp st1, st0");
                                    asm("fxch st0, st1");
                                    asm("fucomip st0, st1");
                                    st0 =  *135050696;
                                    if(__eflags != 0) {
                                        _t418 =  &(fixed[ii]);
                                        __eflags = _t418;
                                         *_t418 = 1;
                                    }
                                }
                            }
                            k = k + 1;
                            __eflags = k;
                        }
                        _t429 = n;
                         *__esp = _t429;
                        GC_malloc_atomic();
                        idx = _t429;
                        k = 0;
                        while(1) {
                            _t430 = cell;
                            __eflags = (_t430->maxcell & 65535) - k;
                            if((_t430->maxcell & 65535) <= k) {
                                break;
                            }
                            j =  *(cell + (k + 40) * 2) & 65535;
                            bcol =  *(cell + j * 2) & 65535;
                            ecol = ( *(cell->col + (j + 16) * 2) & 65535) + bcol;
                            m = 0;
                            kk = 0;
                            while(1) {
                                __eflags = kk - n;
                                if(kk >= n) {
                                    break;
                                }
                                ii =  *(indexarray + i + kk + i + kk) & 65535;
                                __eflags = ii - bcol;
                                if(ii >= bcol) {
                                    __eflags = ii - ecol;
                                    if(ii < ecol) {
                                        idx[m] = ii;
                                        m = m + 1;
                                        __eflags = m;
                                    }
                                }
                                kk = kk + 1;
                                __eflags = kk;
                            }
                            __eflags = m;
                            if(m == 0) {
L68:
                                k = k + 1;
                                __eflags = k;
                                continue;
                            }
                            width = t->cellspacing * (( *(cell->col + (j + 16) * 2) & 65535) - 1);
                            kk = bcol;
                            while(1) {
                                __eflags = kk - ecol;
                                if(kk >= ecol) {
                                    break;
                                }
                                width = width + ( *(iwidth + kk + kk) & 65535);
                                kk = kk + 1;
                                __eflags = kk;
                            }
                            w = 0;
                            kk = 0;
                            while(1) {
                                __eflags = kk - m;
                                if(kk >= m) {
                                    break;
                                }
                                __eflags = (fixed[idx[kk] & 255] & 255) - 1;
                                if((fixed[idx[kk] & 255] & 255) <= 1) {
                                    w = w + rulewidth;
                                    __eflags = w;
                                }
                                kk = kk + 1;
                                __eflags = kk;
                            }
                            _t476 = cell;
                            _t603 = j + 96;
                            __eflags = width - w - ( *(_t476->col + _t603 * 2) & 65535);
                            if(width - w >= ( *(_t476->col + _t603 * 2) & 65535)) {
L53:
                                w = 0;
                                kk = 0;
                                while(1) {
                                    __eflags = kk - m;
                                    if(kk >= m) {
                                        break;
                                    }
                                    __eflags = fixed[idx[kk] & 255] & 255;
                                    if(__eflags <= 0) {
                                        asm("fild dword [ebp-0x38]");
                                        asm("fsubp st1, st0");
                                        asm("fxch st0, st1");
                                        asm("fucomip st0, st1");
                                        st0 =  *135050696;
                                        if(__eflags != 0) {
                                            w = w + rulewidth;
                                            __eflags = w;
                                        }
                                    }
                                    kk = kk + 1;
                                    __eflags = kk;
                                }
                                _t495 = cell;
                                _t606 = j + 80;
                                __eflags = width - w - ( *(_t495->col + _t606 * 2) & 65535);
                                if(width - w >= ( *(_t495->col + _t606 * 2) & 65535)) {
                                    goto L68;
                                }
                                kk = 0;
                                while(1) {
                                    __eflags = kk - m;
                                    if(kk >= m) {
                                        break;
                                    }
                                    __eflags = fixed[idx[kk] & 255] & 255;
                                    if(__eflags <= 0) {
                                        asm("fild dword [ebp-0x38]");
                                        asm("fsubp st1, st0");
                                        asm("fxch st0, st1");
                                        asm("fucomip st0, st1");
                                        st0 =  *135050696;
                                        if(__eflags != 0) {
                                            _t516 =  &(fixed[idx[kk] & 255]);
                                            __eflags = _t516;
                                             *_t516 = 1;
                                        }
                                    }
                                    kk = kk + 1;
                                    __eflags = kk;
                                }
                                goto L68;
                            }
                            kk = 0;
                            while(1) {
                                __eflags = kk - m;
                                if(kk >= m) {
                                    goto L53;
                                }
                                __eflags = (fixed[idx[kk] & 255] & 255) - 1;
                                if((fixed[idx[kk] & 255] & 255) <= 1) {
                                    _t528 =  &(fixed[idx[kk] & 255]);
                                    __eflags = _t528;
                                     *_t528 = 2;
                                }
                                kk = kk + 1;
                                __eflags = kk;
                            }
                            goto L53;
                        }
                        nn = 0;
                        k = 0;
                        while(1) {
                            __eflags = k - n;
                            if(__eflags >= 0) {
                                break;
                            }
                            ii =  *(indexarray + i + k + i + k) & 65535;
                            __eflags = (fixed[ii] & 255) - step;
                            if((fixed[ii] & 255) <= step) {
                                nn = nn + 1;
                                __eflags = nn;
                            }
                            k = k + 1;
                            __eflags = k;
                        }
                        _v144 = nn * rulewidth;
                        asm("fild dword [ebp-0x8c]");
                        asm("fsubrp st1, st0");
                        nsum = sum;
                        asm("fldz");
                        asm("fucomip st0, st1");
                        st0 = nsum;
                        __eflags = __eflags > 0;
                        if(__eflags == 0) {
L77:
                            k = 0;
                            while(1) {
                                __eflags = k - n;
                                if(k >= n) {
                                    break;
                                }
                                ii =  *(indexarray + i + k + i + k) & 65535;
                                __eflags = (fixed[ii] & 255) - step;
                                if((fixed[ii] & 255) <= step) {
                                     *(iwidth + ii + ii) = ( *(iwidth + ii + ii) & 65535) - rulewidth;
                                    _t558 =  &(fixed[ii]);
                                    __eflags = _t558;
                                     *_t558 = 3;
                                }
                                k = k + 1;
                                __eflags = k;
                            }
                            sum = nsum;
                            i = i + n;
                            __eflags = i;
                            goto L83;
                        }
                        asm("fabs");
                        asm("fabs");
                        asm("fucomip st0, st1");
                        st0 = nsum;
                        if(__eflags != 0) {
                            return;
                        }
                        goto L77;
                    }
L17:
                    n = n + 1;
                    __eflags = n;
                    continue;
                }
                x = mod[ii];
                goto L17;
            }
            goto L21;
        }
        step = step + 1;
        __eflags = step;
    }
    return;
L2:
    if(t->maxcol >= i) {
         *__esp = dwidth[i];
        ceil();
        asm("fnstcw word [ebp-0x8e]");
        _v148 = 12;
        asm("fldcw word [ebp-0x90]");
        asm("fistp dword [ebp-0x8c]");
        asm("fldcw word [ebp-0x8e]");
         *(iwidth + i + i) = ceil_at_intervals(_v144, rulewidth);
        _v150 =  *(iwidth + i + i) & 65535;
        asm("fild word [ebp-0x92]");
        _t623 = dwidth[i];
        asm("fsubp st1, st0");
        mod[i] = _t623;
        i = i + 1;
        __eflags = i;
        goto L2;
    } else {
        asm("fldz");
        sum = _t623;
        k = 0;
    }
    goto L9;
}

double correlation_coefficient(double sxx, double syy, double sxy)
{// addr = 0x08082A0A  --  defined in 'table.c' at line 1051
    double coe;                            // _cfa_ffffffec
    double tmp;                            // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    signed long long _v36;                 // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed long long _v44;                 // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    double _v52;                           // _cfa_ffffffcc
    double _t32;                           // _t32
    double _t33;                           // _t33
    _unknown_ _t34;                        // _t34
    _unknown_ _t35;                        // _t35
    double _t41;                           // _t41

    _v36 = sxx;
    _v32 = syy;
    _v44 = sxy;
    _v40 = _a16;
    _v52 = _a20;
    _v48 = _a24;
    tmp = _v36 * _v44;
    asm("fxch st0, st1");
    asm("fucomip st0, st1");
    st0 = tmp;
    _t35 = _t34 > 0;
    if(_t35 != 0) {
        tmp = Tiny;
    }
    _t41 = tmp;
    asm("fsqrt");
    asm("fucomi st0, st0");
    if(_t35 != 0) {
        st0 = _t41;
        goto L6;
    } else {
        if(_t35 == 0) {
L7:
            asm("fdivrp st1, st0");
            coe = _v52;
            asm("fld1");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            st0 = coe;
            _t32 = _t35 > 0;
            if(_t32 == 0) {
                asm("fld1");
                asm("fchs");
                asm("fucomip st0, st1");
                st0 = coe;
                _t33 = __eflags > 0;
                __eflags = _t33;
                if(_t33 == 0) {
                    return _t33;
                }
                asm("fld1");
                asm("fchs");
                return _t33;
            }
            asm("fld1");
            return _t32;
        }
        st0 = _t41;
L6:
         *__esp = tmp;
        sqrt();
        goto L7;
    }
}

double correlation_coefficient2(double sxx, double syy, double sxy)
{// addr = 0x08082AB3  --  defined in 'table.c' at line 1066
    double coe;                            // _cfa_ffffffec
    double tmp;                            // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    long long _v52;                        // _cfa_ffffffcc
    signed long long _v60;                 // _cfa_ffffffc4
    double _t35;                           // _t35
    double _t36;                           // _t36
    _unknown_ _t37;                        // _t37
    _unknown_ _t38;                        // _t38
    double _t49;                           // _t49

    _v36 = sxx;
    _v32 = syy;
    _v44 = sxy;
    _v40 = _a16;
    _v52 = _a20;
    _v48 = _a24;
    asm("fmulp st1, st0");
    asm("faddp st1, st0");
    tmp =  *135050712 * _v36;
    asm("fxch st0, st1");
    asm("fucomip st0, st1");
    st0 = tmp;
    _t38 = _t37 > 0;
    if(_t38 != 0) {
        tmp = Tiny;
    }
    _v60 = _v36 - _v52;
    _t49 = tmp;
     *__esp = _t49;
    sqrt();
    asm("fdivr qword [ebp-0x38]");
    coe = _t49;
    asm("fld1");
    asm("fxch st0, st1");
    asm("fucomip st0, st1");
    st0 = coe;
    _t35 = _t38 > 0;
    if(_t35 == 0) {
        asm("fld1");
        asm("fchs");
        asm("fucomip st0, st1");
        st0 = coe;
        _t36 = __eflags > 0;
        __eflags = _t36;
        if(_t36 == 0) {
            return _t36;
        }
        asm("fld1");
        asm("fchs");
        return _t36;
    } else {
        asm("fld1");
        return _t35;
    }
}

double recalc_width(double old, double swidth, int cwidth, double sxx, double syy, double sxy, int is_inclusive)
{// addr = 0x08082B62  --  defined in 'table.c' at line 1081
    double delta;                          // _cfa_ffffffec
    double rat;                            // _cfa_ffffffe4
    double coe;                            // _cfa_ffffffdc
    double w;                              // _cfa_ffffffd4
    double ww;                             // _cfa_ffffffcc
    double wmin;                           // _cfa_ffffffc4
    double coe1;                           // _cfa_ffffffbc
    double wmin;                           // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    signed long long _v84;                 // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    double _v92;                           // _cfa_ffffffa4
    int _v96;                              // _cfa_ffffffa0
    signed int _v100;                      // _cfa_ffffff9c
    intOrPtr _v104;                        // _cfa_ffffff98
    signed int _v108;                      // _cfa_ffffff94
    intOrPtr _v112;                        // _cfa_ffffff90
    signed int _v116;                      // _cfa_ffffff8c
    signed long long _v140;                // _cfa_ffffff74
    signed long long _v148;                // _cfa_ffffff6c
    double _t92;                           // _t92
    double _t94;                           // _t94
    double _t97;                           // _t97
    double _t101;                          // _t101
    _unknown_ _t102;                       // _t102
    _unknown_ _t103;                       // _t103
    double _t110;                          // _t110
    signed long long _t111;                // _t111
    double _t125;                          // _t125
    double _t143;                          // _t143
    double _t149;                          // _t149

    _v84 = old;
    _v80 = swidth;
    _v92 = cwidth;
    _v88 = sxx;
    _v100 = sxy;
    _v96 = is_inclusive;
    _v108 = _a32;
    _v104 = _a36;
    _v116 = _a40;
    _v112 = _a44;
    asm("fild dword [ebp+0x18]");
    asm("fsubrp st1, st0");
    delta = _v92;
    rat = _v116 / _v100;
    _v140 = _v116;
    _v148 = _v108;
    _t110 = _v100;
     *__esp = _t110;
    correlation_coefficient();
    coe = _t110;
    _t111 = _v84;
    asm("fldz");
    asm("fucomip st0, st1");
    st0 = _t111;
    _t103 = _t102 > 0;
    if(_t103 != 0) {
        asm("fldz");
        _v84 = _t111;
    }
    asm("fabs");
    asm("fucomip st0, st1");
    st0 =  *135050720;
    _t92 = _t103 > 0;
    if(_t92 == 0) {
        w = rat * _v84;
        ww = delta;
        asm("fldz");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        st0 = w;
        __eflags = __eflags > 0;
        if(__eflags == 0) {
             *__esp = _v108;
            sqrt();
            asm("fmulp st1, st0");
            asm("fabs");
            asm("fmulp st1, st0");
            wmin = coe;
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            st0 =  *135050760;
            _t94 = __eflags > 0;
            __eflags = _t94;
            if(__eflags == 0) {
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                st0 =  *135050768;
                __eflags = __eflags > 0;
                if(__eflags != 0) {
                    wmin =  *135050768;
                }
                _t125 = ww;
                asm("fldz");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                st0 = _t125;
                __eflags = __eflags > 0;
                if(__eflags != 0) {
                    asm("fldz");
                    ww = _t125;
                }
                ww = ww - wmin;
L23:
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                st0 = ww;
                _t97 = __eflags > 0;
                __eflags = _t97;
                if(_t97 == 0) {
                    return _t97;
                }
                return _t97;
            }
            return _t94;
        }
        asm("fld1");
        asm("fsubrp st1, st0");
         *__esp = coe * coe * _v108;
        sqrt();
        asm("fmulp st1, st0");
        wmin =  *135050728;
        asm("fucomip st0, st1");
        st0 =  *135050736;
        __eflags = __eflags > 0;
        if(__eflags == 0) {
L11:
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            st0 =  *135050752;
            __eflags = __eflags > 0;
            if(__eflags != 0) {
                wmin =  *135050752;
            }
            _t143 = ww;
            asm("fldz");
            asm("fucomip st0, st1");
            st0 = _t143;
            __eflags = __eflags > 0;
            if(__eflags != 0) {
                asm("fldz");
                ww = _t143;
            }
            ww = ww + wmin;
            goto L23;
        }
        __eflags = syy;
        if(__eflags <= 0) {
            goto L11;
        }
        __eflags =  *((intOrPtr*)(__ebp + 52));
        if(__eflags == 0) {
            goto L11;
        }
        _v140 = _v116;
        _v148 = _v108;
        _t149 = _v100;
         *__esp = _t149;
        correlation_coefficient2();
        coe1 = _t149;
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        st0 =  *135050744;
        _t101 = __eflags > 0;
        __eflags = _t101;
        if(__eflags != 0) {
L10:
            asm("fldz");
            return _t101;
        }
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        st0 =  *135050744;
        _t101 = __eflags > 0;
        __eflags = _t101;
        if(__eflags == 0) {
            goto L11;
        }
        goto L10;
    } else {
        return _t92;
    }
}

int check_compressible_cell(struct table* t, MAT* minv, double* newwidth, double* swidth, short int* cwidth, double totalwidth, double* Sxx, int icol, int icell, double sxx, int corr)
{// addr = 0x08082D94  --  defined in 'table.c' at line 1122
    struct table_cell* cell;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    int k;                                 // _cfa_ffffffe4
    int m;                                 // _cfa_ffffffe0
    int bcol;                              // _cfa_ffffffdc
    int ecol;                              // _cfa_ffffffd8
    int span;                              // _cfa_ffffffd4
    int rulewidth;                         // _cfa_ffffffd0
    int bcol1;                             // _cfa_ffffffcc
    int ecol1;                             // _cfa_ffffffc8
    int is_inclusive;                      // _cfa_ffffffc4
    int is_inclusive;                      // _cfa_ffffffc0
    int nwidth;                            // _cfa_ffffffbc
    double delta;                          // _cfa_ffffffb4
    double owidth;                         // _cfa_ffffffac
    double dmax;                           // _cfa_ffffffa4
    double dmin;                           // _cfa_ffffff9c
    double sxy;                            // _cfa_ffffff94
    double* _v112;                         // _cfa_ffffff90
    double _v116;                          // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    int _v124;                             // _cfa_ffffff84
    _unknown_ _v126;                       // _cfa_ffffff82
    short _v128;                           // _cfa_ffffff80
    int _v132;                             // _cfa_ffffff7c
    short _v134;                           // _cfa_ffffff7a
    int _v144;                             // _cfa_ffffff70
    double _v152;                          // _cfa_ffffff68
    double _v160;                          // _cfa_ffffff60
    long long _v168;                       // _cfa_ffffff58 (outparam)
    signed int _v172;                      // _cfa_ffffff54 (outparam)
    _unknown_ _v176;                       // _cfa_ffffff50 (outparam)
    long long _v180;                       // _cfa_ffffff4c (outparam)
    _unknown_ _v184;                       // _cfa_ffffff48 (outparam)
    int _t277;                             // _t277
    double _t456;                          // _t456
    double _t457;                          // _t457
    double _t463;                          // _t463
    double _t473;                          // _t473
    long long _t474;                       // _t474
    double _t475;                          // _t475
    double _t476;                          // _t476
    double _t482;                          // _t482
    long long _t483;                       // _t483
    double _t484;                          // _t484
    double _t487;                          // _t487
    long long _t488;                       // _t488
    double _t489;                          // _t489
    double _t492;                          // _t492
    long long _t493;                       // _t493
    double _t494;                          // _t494

    _v116 = totalwidth;
    _v112 = Sxx;
    _v124 = corr;
    _v120 = _a48;
    cell =  &(t->cell);
    rulewidth = table_rule_width(t);
    asm("fucomip st0, st1");
    st0 =  *135050776;
    if(__eflags <= 0) {
        return  *(__ebp + 56);
    }
    __eflags = icell;
    if(icell < 0) {
        __eflags = sxx;
        if(sxx < 0) {
            owidth = _v116;
            delta = _v116;
            bcol = 0;
            _t277 = t->maxcol + 1;
            __eflags = _t277;
            ecol = _t277;
        } else {
            owidth = swidth[sxx];
            _v134 =  *(cwidth + sxx + sxx) & 65535;
            asm("fild word [ebp-0x82]");
            asm("fsubp st1, st0");
            delta = swidth[sxx];
            bcol =  *(cell + sxx * 2) & 65535;
            ecol = ( *(cell->col + (sxx + 16) * 2) & 65535) + bcol;
        }
    } else {
        owidth = newwidth[icell];
        _v134 =  *(t->maxrow + (icell + 40) * 2) & 65535;
        asm("fild word [ebp-0x82]");
        asm("fsubp st1, st0");
        delta = newwidth[icell];
        bcol = icell;
        ecol = bcol + 1;
    }
    _t456 = delta;
    dmin = _t456;
    asm("fld1");
    asm("fchs");
    dmax = _t456;
    k = 0;
    while(1) {
        __eflags = (cell->maxcell & 65535) - k;
        if(__eflags < 0) {
            break;
        }
        is_inclusive = 0;
        _t457 = dmin;
        asm("fldz");
        asm("fucomip st0, st1");
        st0 = _t457;
        __eflags = __eflags >= 0;
        if(__eflags != 0) {
L43:
            asm("fldz");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            st0 = dmax;
            __eflags = __eflags > 0;
            if(__eflags != 0) {
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                st0 = dmax;
                if(__eflags != 0) {
                    dmin = dmax;
                }
            }
            span = ecol - bcol;
            __eflags = t->maxcol + 1 - span;
            if(__eflags != 0) {
L48:
                __eflags = t->maxcol + 1 - span;
                if(__eflags == 0) {
                    goto L51;
                }
                asm("fild dword [ebp-0x2c]");
                asm("fmulp st1, st0");
                asm("fucomip st0, st1");
                st0 = dmin;
                if(__eflags == 0) {
                    goto L51;
                }
                goto L50;
            } else {
                asm("fldz");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                st0 = dmin;
                if(__eflags != 0) {
L50:
                    _t463 =  *135050696;
                    asm("faddp st1, st0");
                     *__esp = _t463;
                    floor();
                    asm("fnstcw word [ebp-0x7a]");
                    _v128 = 12;
                    asm("fldcw word [ebp-0x7c]");
                    asm("fistp dword [ebp-0x80]");
                    asm("fldcw word [ebp-0x7a]");
                    nwidth = ceil_at_intervals(_v132, rulewidth);
                    asm("fld1");
                    correct_table_matrix(t, bcol, ecol - bcol, nwidth, _t463);
                    _t263 = __ebp + 56;
                     *_t263 =  *(__ebp + 56) + 1;
                    __eflags =  *_t263;
L51:
                    return  *(__ebp + 56);
                }
                goto L48;
            }
        }
        j =  *(cell + (k + 40) * 2) & 65535;
        __eflags = j - sxx;
        if(j == sxx) {
            goto L23;
        } else {
            bcol1 =  *(cell + j * 2) & 65535;
            ecol1 = ( *(cell->col + (j + 16) * 2) & 65535) + bcol1;
            asm("fldz");
            sxy = _t457;
            m = bcol1;
            while(1) {
                __eflags = m - ecol1;
                if(m >= ecol1) {
                    break;
                }
                i = bcol;
                while(1) {
                    __eflags = i - ecol;
                    if(i >= ecol) {
                        break;
                    }
                    asm("faddp st1, st0");
                    sxy = sxy;
                    i = i + 1;
                    __eflags = i;
                }
                m = m + 1;
                __eflags = m;
            }
            __eflags = bcol1 - bcol;
            if(__eflags >= 0) {
                __eflags = ecol1 - ecol;
                if(__eflags <= 0) {
                    is_inclusive = 1;
                }
            }
            asm("fldz");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            st0 = sxy;
            if(_t277 == 0) {
                _v144 = is_inclusive;
                _t473 = sxy;
                _v152 = _t473;
                asm("fxch st0, st1");
                _v160 = _t473;
                _t474 = _v124;
                _v168 = _t474;
                _v172 =  *(cwidth + j + j) & 65535;
                _v180 = _t474;
                _t475 = dmax;
                 *__esp = _t475;
                recalc_width();
                dmax = _t475;
            } else {
                _v144 = is_inclusive;
                _t492 = sxy;
                _v152 = _t492;
                asm("fxch st0, st1");
                _v160 = _t492;
                _t493 = _v124;
                _v168 = _t493;
                _v172 =  *(cwidth + j + j) & 65535;
                _v180 = _t493;
                _t494 = dmin;
                 *__esp = _t494;
                recalc_width();
                dmin = _t494;
            }
L23:
            k = k + 1;
            __eflags = k;
            continue;
        }
    }
    m = 0;
    while(1) {
        __eflags = t->maxcol - m;
        if(__eflags < 0) {
            break;
        }
        is_inclusive = 0;
        _t476 = dmin;
        asm("fldz");
        asm("fucomip st0, st1");
        st0 = _t476;
        __eflags = __eflags >= 0;
        if(__eflags != 0) {
            goto L43;
        }
        __eflags = m - icell;
        if(m == icell) {
L38:
            m = m + 1;
            __eflags = m;
            continue;
        }
        asm("fldz");
        sxy = _t476;
        i = bcol;
        while(1) {
            __eflags = i - ecol;
            if(i >= ecol) {
                break;
            }
            asm("faddp st1, st0");
            sxy = sxy;
            i = i + 1;
            __eflags = i;
        }
        __eflags = m - bcol;
        if(__eflags >= 0) {
            __eflags = m - ecol;
            if(__eflags < 0) {
                is_inclusive = 1;
            }
        }
        asm("fldz");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        st0 = sxy;
        if(__eflags == 0) {
            _v144 = is_inclusive;
            _t482 = sxy;
            _v152 = _t482;
            asm("fxch st0, st1");
            _v160 = _t482;
            _t483 = _v124;
            _v168 = _t483;
            _v172 =  *(t->maxrow + (m + 40) * 2) & 65535;
            _v180 = _t483;
            _t484 = dmax;
             *__esp = _t484;
            recalc_width();
            dmax = _t484;
        } else {
            _v144 = is_inclusive;
            _t487 = sxy;
            _v152 = _t487;
            asm("fxch st0, st1");
            _v160 = _t487;
            _t488 = _v124;
            _v168 = _t488;
            _v172 =  *(t->maxrow + (m + 40) * 2) & 65535;
            _v180 = _t488;
            _t489 = dmin;
             *__esp = _t489;
            recalc_width();
            dmin = _t489;
        }
        goto L38;
    }
    goto L43;
}

int check_table_width(struct table* t, double* newwidth, MAT* minv, int itr)
{// addr = 0x080832E2  --  defined in 'table.c' at line 1216
    short int orgwidth;                    // <nowhere>
    short int corwidth;                    // <nowhere>
    short int cwidth;                      // <nowhere>
    double swidth;                         // <nowhere>
    char _v16;                             // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    int i;                                 // _cfa_ffffffdc
    int j;                                 // _cfa_ffffffd8
    int k;                                 // _cfa_ffffffd4
    int m;                                 // _cfa_ffffffd0
    int bcol;                              // _cfa_ffffffcc
    int ecol;                              // _cfa_ffffffc8
    int corr;                              // _cfa_ffffffc4
    struct table_cell* cell;   // _cfa_ffffffc0
    double* Sxx;                           // _cfa_ffffffbc
    int nwidth;                            // _cfa_ffffffb8
    int mwidth;                            // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    signed int _v84;                       // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    short int* _v92;                       // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    short int* _v100;                      // _cfa_ffffff9c
    intOrPtr _v104;                        // _cfa_ffffff98
    double* _v108;                         // _cfa_ffffff94
    double twidth;                         // _cfa_ffffff8c
    double sxy;                            // _cfa_ffffff84
    double stotal;                         // _cfa_ffffff7c
    double sx;                             // _cfa_ffffff74
    double w;                              // _cfa_ffffff6c
    double sx;                             // _cfa_ffffff64
    double w;                              // _cfa_ffffff5c
    struct table* _v176;   // _cfa_ffffff50
    double* _v180;                         // _cfa_ffffff4c
    MAT* _v184;            // _cfa_ffffff48
    _unknown_ _v186;                       // _cfa_ffffff46
    short _v188;                           // _cfa_ffffff44
    signed short _v192;                    // _cfa_ffffff40
    signed int _v200;                      // _cfa_ffffff38
    signed char _v204;                     // _cfa_ffffff34
    signed int _v208;                      // _cfa_ffffff30
    signed int _v212;                      // _cfa_ffffff2c
    signed int _v216;                      // _cfa_ffffff28
    signed char _v220;                     // _cfa_ffffff24
    signed int _v224;                      // _cfa_ffffff20
    signed int _v228;                      // _cfa_ffffff1c
    signed int _v232;                      // _cfa_ffffff18
    signed char _v236;                     // _cfa_ffffff14
    signed int _v240;                      // _cfa_ffffff10
    signed int _v244;                      // _cfa_ffffff0c
    signed int _v248;                      // _cfa_ffffff08
    signed char _v252;                     // _cfa_ffffff04
    signed int _v256;                      // _cfa_ffffff00
    signed int _v260;                      // _cfa_fffffefc
    signed int _v264;                      // _cfa_fffffef8
    signed char _v268;                     // _cfa_fffffef4
    signed int _v272;                      // _cfa_fffffef0
    signed int _v276;                      // _cfa_fffffeec
    signed int _v280;                      // _cfa_fffffee8
    signed char _v284;                     // _cfa_fffffee4
    signed int _v288;                      // _cfa_fffffee0
    signed int _v292;                      // _cfa_fffffedc
    signed int _v296;                      // _cfa_fffffed8
    signed char _v300;                     // _cfa_fffffed4
    signed int _v304;                      // _cfa_fffffed0
    signed int _v308;                      // _cfa_fffffecc
    signed int _v312;                      // _cfa_fffffec8
    signed char _v316;                     // _cfa_fffffec4
    char _v328;                            // _cfa_fffffeb8
    _unknown_ _v332;                       // _cfa_fffffeb4 (outparam)
    _unknown_ _v340;                       // _cfa_fffffeac (outparam)
    _unknown_ _v344;                       // _cfa_fffffea8 (outparam)
    _unknown_ _v348;                       // _cfa_fffffea4 (outparam)
    _unknown_ _v352;                       // _cfa_fffffea0 (outparam)
    _unknown_ _v360;                       // _cfa_fffffe98 (outparam)
    _unknown_ _v364;                       // _cfa_fffffe94 (outparam)
    _unknown_ _v368;                       // _cfa_fffffe90 (outparam)
    _unknown_ _v372;                       // _cfa_fffffe8c (outparam)
    _unknown_ _v376;                       // _cfa_fffffe88 (outparam)
    _unknown_ __ebx;                       // r1
    double* __edi;                         // r4
    _unknown_ __esi;                       // r5
    signed int _t565;                      // _t565
    signed int _t569;                      // _t569
    signed int _t586;                      // _t586
    signed int _t590;                      // _t590
    signed int _t608;                      // _t608
    signed int _t612;                      // _t612
    signed int _t630;                      // _t630
    signed int _t634;                      // _t634
    double* _t671;                         // _t671
    struct table* _t737;   // _t737
    int _t751;                             // _t751
    struct table* _t752;   // _t752
    signed int _t775;                      // _t775
    struct table* _t776;   // _t776
    struct table* _t836;   // _t836
    signed int _t890;                      // _t890
    signed int _t891;                      // _t891
    signed int _t892;                      // _t892
    signed int _t893;                      // _t893
    signed int _t894;                      // _t894
    signed int _t910;                      // _t910
    signed int _t979;                      // _t979
    int _t1010;                            // _t1010
    double _t1056;                         // _t1056
    double _t1069;                         // _t1069
    double _t1072;                         // _t1072
    double _t1079;                         // _t1079
    double _t1087;                         // _t1087

    __esp = __esp - 364;
    _v176 = t;
    _v180 = newwidth;
    _v184 = minv;
    _v32 =  *gs:0x14];
    __edi = __esp;
    corr = 0;
    cell =  &(_v176->cell);
    _t891 = _v176->maxcol + 1;
    _v80 = _t891 - 1;
    _t565 = _t891 & 255;
    _v204 = _t565 << 4 & 255;
    _v200 = (0 << 32 | _t565) << 4 & 15;
    _v212 = _t891 & 255;
    _v208 = 0;
    _t569 = _v212;
    _v220 = _t569 << 4 & 255;
    _v216 = (_v208 << 32 | _t569) << 4 & 15;
    __esp = __esp - (_t891 + _t891 + 0x1e >> 4 << 4);
    _v84 =  &_v328 + 15 >> 4 << 4;
    _t892 = _v176->maxcol + 1;
    _v88 = _t892 - 1;
    _v228 = _t892 & 255;
    _v224 = 0;
    _t586 = _v228;
    _v236 = _t586 << 4 & 255;
    _v232 = (_v224 << 32 | _t586) << 4 & 15;
    _v244 = _t892 & 255;
    _v240 = 0;
    _t590 = _v244;
    _v252 = _t590 << 4 & 255;
    _v248 = (_v240 << 32 | _t590) << 4 & 15;
    __esp = __esp - (_t892 + _t892 + 0x1e >> 4 << 4);
    _v92 =  &_v328 + 15 >> 4 << 4;
    _t893 = (cell->maxcell & 65535) + 1;
    _v96 = _t893 - 1;
    _v260 = _t893 & 255;
    _v256 = 0;
    _t608 = _v260;
    _v268 = _t608 << 4 & 255;
    _v264 = (_v256 << 32 | _t608) << 4 & 15;
    _v276 = _t893 & 255;
    _v272 = 0;
    _t612 = _v276;
    _v284 = _t612 << 4 & 255;
    _v280 = (_v272 << 32 | _t612) << 4 & 15;
    __esp = __esp - (_t893 + _t893 + 0x1e >> 4 << 4);
    _v100 =  &_v328 + 15 >> 4 << 4;
    _t894 = (cell->maxcell & 65535) + 1;
    _v104 = _t894 - 1;
    _v292 = _t894 & 255;
    _v288 = 0;
    _t630 = _v292;
    _v300 = _t630 << 6 & 255;
    _v296 = (_v288 << 32 | _t630) << 6 & 15;
    _v308 = _t894 & 255;
    _v304 = 0;
    _t634 = _v308;
    _v316 = _t634 << 6 & 255;
    _v312 = (_v304 << 32 | _t634) << 6 & 15;
    __esp = __esp - ((_t894 << 3) + 0x1e >> 4 << 4);
    _v108 =  &_v328 + 15 >> 4 << 4;
    asm("fldz");
    twidth = __fp0;
    asm("fldz");
    stotal = __fp0;
    i = 0;
    while(_v176->maxcol >= i) {
        do {
        } while();
        continue;
L3:
        __eflags = m - i;
        if(m < i) {
            _t1056 = stotal;
            asm("faddp st1, st0");
            stotal = _t1056;
            m = m + 1;
            __eflags = m;
            goto L3;
        } else {
            i = i + 1;
            __eflags = i;
        }
    }
    _t671 = (cell->maxcell & 65535) + 1 << 3;
     *__esp = _t671;
    GC_malloc_atomic();
    Sxx = _t671;
    k = 0;
    while((cell->maxcell & 65535) >= k) {
        j =  *(cell + (k + 40) * 2) & 65535;
        bcol =  *(cell + j * 2) & 65535;
        ecol = ( *(cell->col + (j + 16) * 2) & 65535) + bcol;
        asm("fldz");
        _v108[j] = _t1056;
        i = bcol;
        while(1) {
            __eflags = i - ecol;
            if(i >= ecol) {
                break;
            }
            _t1056 = _v180[i];
            asm("faddp st1, st0");
            _v108[j] = _t1056;
            i = i + 1;
            __eflags = i;
        }
        _v100[j] = ( *(cell->col + (j + 80) * 2) & 65535) + _v176->cellspacing * (1 - ( *(cell->col + (j + 16) * 2) & 65535));
        asm("fldz");
        Sxx[j] = _t1056;
        i = bcol;
        while(1) {
            __eflags = i - ecol;
            if(i >= ecol) {
                break;
            }
            _t1056 =  *( *_v184 + (_v184->dim + 1 << 3) * i);
            asm("faddp st1, st0");
            Sxx[j] = _t1056;
            m = bcol;
            while(1) {
                __eflags = m - ecol;
                if(m > ecol) {
                    break;
                }
                __eflags = m - i;
                if(m < i) {
                    _t1010 = _v184->dim * i + m << 3;
                    __eflags = _t1010;
                    _t1056 =  *((long long*)( *_v184 + _t1010)) + st0;
                    asm("faddp st1, st0");
                    Sxx[j] = _t1056;
                }
                m = m + 1;
                __eflags = m;
            }
            i = i + 1;
            __eflags = i;
        }
        k = k + 1;
        __eflags = k;
    }
    corr = check_compressible_cell(_v176, _v184, _v180, _v108, _v100, twidth, Sxx, -1, -1, stotal, corr);
    if(itr > 9 || corr <= 0) {
        k = cell->maxcell & 65535;
        while(1) {
            __eflags = k;
            if(k < 0) {
                break;
            }
            j =  *(cell + (k + 40) * 2) & 65535;
            corr = check_compressible_cell(_v176, _v184, _v180, _v108, _v100, twidth, Sxx, -1, j, Sxx[j], corr);
            __eflags = itr - 9;
            if(itr > 9) {
L27:
                k = k - 1;
                __eflags = k;
                continue;
            }
            __eflags = corr;
            if(corr <= 0) {
                goto L27;
            }
            _t751 = corr;
            goto L84;
        }
        i = 0;
        while(1) {
            _t737 = _v176;
            __eflags = _t737->maxcol - i;
            if(_t737->maxcol < i) {
                break;
            }
            corr = check_compressible_cell(_v176, _v184, _v180, _v108, _v100, twidth, Sxx, i, -1,  *( *_v184 + (_v184->dim + 1 << 3) * i), corr);
            __eflags = itr - 9;
            if(itr > 9) {
L33:
                i = i + 1;
                __eflags = i;
                continue;
            }
            __eflags = corr;
            if(corr <= 0) {
                goto L33;
            }
            _t751 = corr;
            goto L84;
        }
        i = 0;
        while(1) {
            _t752 = _v176;
            __eflags = _t752->maxcol - i;
            if(_t752->maxcol < i) {
                break;
            }
            _t890 = i;
            asm("faddp st1, st0");
             *__esp =  *135050696;
            floor();
            asm("fnstcw word [ebp-0xb6]");
            _v188 = 12;
            asm("fldcw word [ebp-0xb8]");
            asm("fistp dword [ebp-0xbc]");
            asm("fldcw word [ebp-0xb6]");
             *(_v84 + _t890 * 2) = _v192;
            _v92[i] =  *(_v84 + _t890 * 2) & 65535;
            i = i + 1;
            __eflags = i;
        }
        check_minimum_width(_v176, _v92);
        i = 0;
        while(1) {
            __eflags = _v176->maxcol - i;
            if(__eflags < 0) {
                break;
            }
            _t1069 =  *( *_v184 + (_v184->dim + 1 << 3) * i);
             *__esp = _t1069;
            sqrt();
            sx = _t1069;
            asm("fucomip st0, st1");
            st0 =  *135050784;
            if(m != 0) {
L54:
                i = i + 1;
                __eflags = i;
                continue;
            }
            _t979 = i;
            _t775 = _v84;
            _t776 = _v176;
            _t910 = i + 88;
            __eflags = ( *(_t775 + _t979 * 2) & 65535) - ( *(_t776->maxcol + _t910 * 2) & 65535);
            if(( *(_t775 + _t979 * 2) & 65535) >= ( *(_t776->maxcol + _t910 * 2) & 65535)) {
                goto L54;
            }
            __eflags = (_v92[i] & 65535) - ( *(_v176->maxcol + (i + 88) * 2) & 65535);
            if(__eflags != 0) {
                goto L54;
            }
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            st0 =  *135050696;
            if(__eflags == 0) {
                _t1087 =  *135050736;
                asm("fmulp st1, st0");
            } else {
                _t1087 =  *135050696;
            }
            w = _t1087;
            asm("fldz");
            sxy = _t1087;
            m = 0;
            while(1) {
                __eflags = _v176->maxcol - m;
                if(__eflags < 0) {
                    break;
                }
                __eflags = m - i;
                if(m != i) {
                    asm("faddp st1, st0");
                    sxy = sxy;
                }
                m = m + 1;
                __eflags = m;
            }
            asm("fldz");
            asm("fucomip st0, st1");
            st0 = sxy;
            if(__eflags != 0) {
                correct_table_matrix(_v176, i, 1,  *(_v176->maxcol + (i + 88) * 2) & 65535, w);
                corr = corr + 1;
            }
            goto L54;
        }
        k = 0;
        while(1) {
            __eflags = (cell->maxcell & 65535) - k;
            if(__eflags < 0) {
                break;
            }
            nwidth = 0;
            j =  *(cell + (k + 40) * 2) & 65535;
            _t1072 = Sxx[j];
             *__esp = _t1072;
            sqrt();
            sx = _t1072;
            asm("fucomip st0, st1");
            st0 =  *135050784;
            if(__eflags != 0) {
L79:
                k = k + 1;
                __eflags = k;
                continue;
            }
            bcol =  *(cell + j * 2) & 65535;
            ecol = ( *(cell->col + (j + 16) * 2) & 65535) + bcol;
            i = bcol;
            while(1) {
                __eflags = i - ecol;
                if(__eflags >= 0) {
                    break;
                }
                nwidth = nwidth + (_v92[i] & 65535);
                i = i + 1;
                __eflags = i;
            }
            mwidth = ( *(cell->col + (j + 96) * 2) & 65535) + _v176->cellspacing * (1 - ( *(cell->col + (j + 16) * 2) & 65535));
            asm("fild dword [ebp-0x48]");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            st0 = _v108[j];
            if(__eflags == 0) {
                goto L79;
            }
            __eflags = mwidth - nwidth;
            if(__eflags != 0) {
                goto L79;
            }
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            st0 =  *135050696;
            if(__eflags == 0) {
                _t1079 =  *135050736;
                asm("fmulp st1, st0");
            } else {
                _t1079 =  *135050696;
            }
            w = _t1079;
            asm("fldz");
            sxy = _t1079;
            i = bcol;
            while(1) {
                __eflags = i - ecol;
                if(__eflags >= 0) {
                    break;
                }
                m = 0;
                while(1) {
                    _t836 = _v176;
                    __eflags = _t836->maxcol - m;
                    if(_t836->maxcol < m) {
                        break;
                    }
                    __eflags = m - bcol;
                    if(m < bcol) {
L70:
                        asm("faddp st1, st0");
                        sxy = sxy;
L72:
                        m = m + 1;
                        __eflags = m;
                        continue;
                    }
                    __eflags = m - ecol;
                    if(m < ecol) {
                        goto L72;
                    }
                    goto L70;
                }
                i = i + 1;
                __eflags = i;
            }
            asm("fldz");
            asm("fucomip st0, st1");
            st0 = sxy;
            if(__eflags != 0) {
                correct_table_matrix(_v176, bcol,  *(cell->col + (j + 16) * 2) & 65535, mwidth, w);
                corr = corr + 1;
            }
            goto L79;
        }
        __eflags = itr - 9;
        if(itr <= 9) {
            _t751 = corr;
        } else {
            _t751 = 0;
        }
        goto L84;
    } else {
        _t751 = corr;
L84:
        __esp = __edi;
        if((_v32 ^  *gs:0x14]) != 0) {
            __stack_chk_fail();
        }
         &_v16 =  &_v16;
        return _t751;
    }
}

void check_table_height(struct table* t)
{// addr = 0x08083EF8  --  defined in 'table.c' at line 1473
    int i;                                 // _cfa_ffffffe0
    int j;                                 // _cfa_ffffffdc
    int k;                                 // _cfa_ffffffd8
    int space;                             // _cfa_ffffffd4
    int t_dep;                             // _cfa_ffffffd0
    int rowspan;                           // _cfa_ffffffcc
    int c;                                 // _cfa_ffffffc8
    int idx;                               // _cfa_ffffffc4
    int ii;                                // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v70;                        // _cfa_ffffffba
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ _v76;                        // _cfa_ffffffb4
    _unknown_ _v80;                        // _cfa_ffffffb0
    struct  cell;             // _cfa_ffffffac
    int _v96;                              // _cfa_ffffffa0
    int _v100;                             // _cfa_ffffff9c
    short int* _v112;                      // _cfa_ffffff90
    int _v128;                             // _cfa_ffffff80
    int _v132;                             // _cfa_ffffff7c (outparam)
    short int* _v136;                      // _cfa_ffffff78 (outparam)
    signed int _v140;                      // _cfa_ffffff74 (outparam)
    short int* _v144;                      // _cfa_ffffff70 (outparam)
    short int* _v148;                      // _cfa_ffffff6c (outparam)
    short int* _v152;                      // _cfa_ffffff68 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ _t270;                       // _t270
    short int* _t274;                      // _t274
    short int* _t277;                      // _t277
    short int* _t280;                      // _t280
    short int* _t283;                      // _t283
    _unknown_ _t285;                       // _t285
    short int* _t289;                      // _t289
    short int* _t292;                      // _t292
    short int* _t295;                      // _t295
    short int* _t298;                      // _t298
    int _t313;                             // _t313
    _unknown_ _t369;                       // _t369

    space = 0;
    cell.size = 0;
    cell.maxcell = 65535;
    j = 0;
    while(t->maxrow >= j) {
        if(t->tabattr[j] == 0) {
            goto L34;
        } else {
            i = 0;
            while(t->maxcol >= i) {
                if(( *(t->tabattr[j] + i + i) & 3) != 0) {
                    goto L30;
                } else {
                    if(t->tabdata[j][i] != 0) {
                        t_dep = t->tabdata[j][i]->nitem & 65535;
                    } else {
                        t_dep = 0;
                    }
                    rowspan = table_rowspan(t, j, i);
                    if(rowspan <= 1) {
                        if(( *(t->tabheight + j + j) & 65535) < t_dep) {
                             *(t->tabheight + j + j) = t_dep;
                        }
                        goto L30;
                    } else {
                        c = (cell.maxcell & 65535) + 1;
                        _v96 = t->maxrow + 1;
                        k = bsearch_2short(rowspan, cell.rowspan, j, cell.row, _v96, cell.indexarray, c);
                        if((cell.maxcell & 65535) >= k) {
                            idx =  *(cell.indexarray + k + k) & 65535;
                            if(( *(cell.row + idx + idx) & 65535) == j && ( *(cell.rowspan + idx + idx) & 65535) == rowspan) {
                                c = idx;
                            }
                        }
                        if(c > 999) {
L30:
                            i = i + 1;
                            continue;
                        }
                        if((cell.size & 65535) <= c) {
                            if((cell.size & 65535) != 0) {
                                _t369 = c + 1;
                                _t270 = (cell.size & 65535) + 20;
                                _t271 = _t369 - _t270 >= 0 ? _t369 : _t270;
                                cell.size = _t369 - _t270 >= 0 ? _t369 : _t270;
                                _t274 = cell.row;
                                _v152 = (cell.size & 65535) + (cell.size & 65535);
                                 *__esp = _t274;
                                GC_realloc();
                                cell.row = _t274;
                                _t277 = cell.rowspan;
                                _v152 = (cell.size & 65535) + (cell.size & 65535);
                                 *__esp = _t277;
                                GC_realloc();
                                cell.rowspan = _t277;
                                _t280 = cell.indexarray;
                                _v152 = (cell.size & 65535) + (cell.size & 65535);
                                 *__esp = _t280;
                                GC_realloc();
                                cell.indexarray = _t280;
                                _t283 = cell.height;
                                _v152 = (cell.size & 65535) + (cell.size & 65535);
                                 *__esp = _t283;
                                GC_realloc();
                                cell.height = _t283;
                            } else {
                                _t285 = c + 1;
                                _t286 = _t285 - 20 < 0 ? 20 : _t285;
                                cell.size = _t285 - 20 < 0 ? 20 : _t285;
                                _t289 = (cell.size & 65535) + (cell.size & 65535);
                                 *__esp = _t289;
                                GC_malloc_atomic();
                                cell.row = _t289;
                                _t292 = (cell.size & 65535) + (cell.size & 65535);
                                 *__esp = _t292;
                                GC_malloc_atomic();
                                cell.rowspan = _t292;
                                _t295 = (cell.size & 65535) + (cell.size & 65535);
                                 *__esp = _t295;
                                GC_malloc_atomic();
                                cell.indexarray = _t295;
                                _t298 = (cell.size & 65535) + (cell.size & 65535);
                                 *__esp = _t298;
                                GC_malloc_atomic();
                                cell.height = _t298;
                            }
                        }
                        if((cell.maxcell & 65535) >= c) {
L23:
                            if(( *(cell.height + c + c) & 65535) < t_dep) {
                                 *(cell.height + c + c) = t_dep;
                            }
                            goto L30;
                        } else {
                            cell.maxcell = (cell.maxcell & 65535) + 1;
                             *((short*)(cell.row + (cell.maxcell & 65535) + (cell.maxcell & 65535))) = j;
                             *((short*)(cell.rowspan + (cell.maxcell & 65535) + (cell.maxcell & 65535))) = rowspan;
                             *((short*)(cell.height + (cell.maxcell & 65535) + (cell.maxcell & 65535))) = 0;
                            if((cell.maxcell & 65535) <= k) {
L22:
                                 *(cell.indexarray + k + k) = cell.maxcell & 65535;
                                goto L23;
                            }
                            ii = cell.maxcell & 65535;
                            while(ii > k) {
                                 *((short*)(cell.indexarray + ii + ii)) =  *(cell.indexarray + ii - 1 + ii - 1) & 65535;
                                ii = ii - 1;
                            }
                            goto L22;
                        }
                    }
                }
            }
L34:
            j = j + 1;
            continue;
        }
    }
    _t313 = t->border_mode;
    if(_t313 == 0) {
        space = 0;
    } else {
        if(_t313 >= 0 && _t313 <= 3) {
            space = 1;
        }
    }
    _v112 = t->tabheight;
    _v128 = 1;
    _v100 = space;
    _v132 = _v100;
    _v136 = cell.indexarray;
    _v140 = cell.maxcell & 65535;
    _v144 = cell.rowspan;
    _v148 = cell.row;
    _v152 = cell.height;
     *__esp = _v112;
    check_cell_width();
}

int get_table_width(struct table* t, short int* orgwidth, short int* cellwidth, int flag)
{// addr = 0x08084329  --  defined in 'table.c' at line 1572
    short int newwidth;                    // <nowhere>
    short int ccellwidth;                  // <nowhere>
    char _v16;                             // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    int i;                                 // _cfa_ffffffdc
    int swidth;                            // _cfa_ffffffd8
    struct table_cell* cell;   // _cfa_ffffffd4
    int rulewidth;                         // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    short int* _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    short int* _v64;                       // _cfa_ffffffc0
    struct table* _v80;   // _cfa_ffffffb0
    short int* _v84;                       // _cfa_ffffffac
    short int* _v88;                       // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    short int* _v100;                      // _cfa_ffffff9c
    signed int _v104;                      // _cfa_ffffff98
    signed char _v108;                     // _cfa_ffffff94
    signed int _v112;                      // _cfa_ffffff90
    signed int _v116;                      // _cfa_ffffff8c
    signed int _v120;                      // _cfa_ffffff88
    signed char _v124;                     // _cfa_ffffff84
    signed int _v128;                      // _cfa_ffffff80
    signed int _v132;                      // _cfa_ffffff7c
    signed int _v136;                      // _cfa_ffffff78
    signed char _v140;                     // _cfa_ffffff74
    signed int _v144;                      // _cfa_ffffff70
    signed int _v148;                      // _cfa_ffffff6c
    signed int _v152;                      // _cfa_ffffff68
    char _v156;                            // _cfa_ffffff64
    _unknown_ _v160;                       // _cfa_ffffff60 (outparam)
    _unknown_ _v164;                       // _cfa_ffffff5c (outparam)
    _unknown_ _v168;                       // _cfa_ffffff58 (outparam)
    _unknown_ _v172;                       // _cfa_ffffff54 (outparam)
    _unknown_ _v176;                       // _cfa_ffffff50 (outparam)
    _unknown_ _v180;                       // _cfa_ffffff4c (outparam)
    _unknown_ _v184;                       // _cfa_ffffff48 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t212;                      // _t212
    signed int _t216;                      // _t216
    int _t259;                             // _t259
    signed int _t268;                      // _t268
    signed int _t272;                      // _t272
    signed int _t349;                      // _t349
    _unknown_ _t371;                       // _t371
    signed int _t394;                      // _t394

    __esp = __esp - 172;
    _v80 = t;
    _v84 = orgwidth;
    _v88 = cellwidth;
    _v32 =  *gs:0x14];
    _v92 = __esp;
    _t394 = _v80->maxcol + 1;
    _v52 = _t394 - 1;
    _t212 = _t394 & 255;
    _v108 = _t212 << 4 & 255;
    _v104 = (0 << 32 | _t212) << 4 & 15;
    _v116 = _t394 & 255;
    _v112 = 0;
    _t216 = _v116;
    _v124 = _t216 << 4 & 255;
    _v120 = (_v112 << 32 | _t216) << 4 & 15;
    __esp = __esp - (_t394 + _t394 + 0x1e >> 4 << 4);
    _v56 =  &_v156 + 15 >> 4 << 4;
    cell =  &(_v80->cell);
    rulewidth = table_rule_width(_v80);
    i = 0;
    while(_v80->maxcol >= i) {
        _t371 = ( *(_v84 + i + i) & 65535) >= 0 ?  *(_v84 + i + i) & 65535 : 0;
        _v56[i] = 0;
        i = i + 1;
    }
    if((flag & 2) == 0) {
        check_cell_width(_v56, _v88, cell,  &(cell->colspan), cell->maxcell & 65535,  &(cell->index), _v80->cellspacing, 0);
    } else {
        _v96 = __esp;
        _t349 = (cell->maxcell & 65535) + 1;
        _v60 = _t349 - 1;
        _v132 = _t349 & 255;
        _v128 = 0;
        _t268 = _v132;
        _v140 = _t268 << 4 & 255;
        _v136 = (_v128 << 32 | _t268) << 4 & 15;
        _v148 = _t349 & 255;
        _v144 = 0;
        _t272 = _v148;
        _v156 = _t272 << 4 & 255;
        _v152 = (_v144 << 32 | _t272) << 4 & 15;
        __esp = __esp - (_t349 + _t349 + 0x1e >> 4 << 4);
        _v64 =  &_v156 + 15 >> 4 << 4;
        i = 0;
        while(_v80->maxcol >= i) {
            if((_v56[i] & 65535) < ( *(_v80 + (i + 144) * 2) & 65535)) {
                _v56[i] =  *(_v80 + (i + 144) * 2) & 65535;
            }
            i = i + 1;
        }
        i = 0;
        while((cell->maxcell & 65535) >= i) {
            _v64[i] =  *(_v88 + i + i) & 65535;
            if((_v64[i] & 65535) < (cell->col[i + 120] & 65535)) {
                _v64[i] = cell->col[i + 120] & 65535;
            }
            i = i + 1;
        }
        _v100 =  &(cell->colspan);
        check_cell_width(_v56, _v64, cell, _v100, cell->maxcell & 65535,  &(cell->index), _v80->cellspacing, 0);
        __esp = _v96;
    }
    if((flag & 1) != 0) {
        check_minimum_width(_v80, _v56);
    }
    swidth = 0;
    i = 0;
    while(_v80->maxcol >= i) {
        swidth = swidth + ceil_at_intervals(_v56[i] & 65535, rulewidth);
        i = i + 1;
    }
    swidth = swidth + table_border_width(_v80);
    _t259 = swidth;
    __esp = _v92;
    if((_v32 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
    }
     &_v16 =  &_v16;
    return _t259;
}

void renderCoTable(struct table* tbl, int maxlimit)
{// addr = 0x08084705  --  defined in 'table.c' at line 1628
    struct table* t;     // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int col;                               // _cfa_ffffffe8
    int row;                               // _cfa_ffffffe4
    int indent;                            // _cfa_ffffffe0
    int maxwidth;                          // _cfa_ffffffdc
    _unknown_ _v68;                        // _cfa_ffffffbc
    struct html_feed_environ h_env;   // _cfa_ffffffac
    struct environment[19] envs;   // _cfa_fffffe6c
    struct readbuffer obuf;   // _cfa_fffffd1c
    _unknown_ _v756;                       // _cfa_fffffd0c (outparam)
    _unknown_ _v760;                       // _cfa_fffffd08 (outparam)
    _unknown_ _v764;                       // _cfa_fffffd04 (outparam)
    _unknown_ _v768;                       // _cfa_fffffd00 (outparam)
    _unknown_ _v772;                       // _cfa_fffffcfc (outparam)
    _unknown_ _v776;                       // _cfa_fffffcf8 (outparam)

    i = 0;
    while((tbl->ntable & 65535) > i) {
        t = tbl->tables[i].ptr;
        col =  &(tbl->tables[i])->col & 65535;
        row =  &(tbl->tables[i])->row & 65535;
        indent =  &(tbl->tables[i])->indent & 65535;
        init_henv( &(h_env.obuf),  &(obuf.line),  &envs, 20,  &(tbl->tables[i])->buf, get_spec_cell_width(tbl, row, col), indent);
        check_row(tbl, row);
        if(h_env.limit > maxlimit) {
            h_env.limit = maxlimit;
        }
        if(t->total_width != 0) {
            if(t->total_width <= 0) {
                t->total_width = ( ~(t->total_width) * h_env.limit * 1374389535 >> 32 >> 5) - ( ~(t->total_width) * h_env.limit >> 31);
                maxwidth = t->total_width;
            } else {
                maxwidth = t->total_width;
            }
        } else {
            maxwidth = h_env.limit - indent;
        }
        renderTable(t, maxwidth,  &(h_env.obuf));
        i = i + 1;
    }
}

void make_caption(struct table* t, struct html_feed_environ* h_env)
{// addr = 0x0808488F  --  defined in 'table.c' at line 1659
    int limit;                             // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4
    struct html_feed_environ henv;   // _cfa_ffffffc0
    struct environment[19] envs;   // _cfa_fffffe80
    struct readbuffer obuf;   // _cfa_fffffd30
    _unknown_ _v740;                       // _cfa_fffffd1c (outparam)
    _unknown_ _v744;                       // _cfa_fffffd18 (outparam)
    _unknown_ _v748;                       // _cfa_fffffd14 (outparam)
    _unknown_ _v752;                       // _cfa_fffffd10 (outparam)
    _unknown_ _v756;                       // _cfa_fffffd0c (outparam)
    _unknown_ _v760;                       // _cfa_fffffd08 (outparam)

    if(t->caption->length > 0) {
        if(t->total_width <= 0) {
            limit = h_env->limit;
        } else {
            limit = t->total_width;
        }
        init_henv( &(henv.obuf),  &(obuf.line),  &envs, 20, newGeneralList(), limit,  &(h_env->envs[h_env->envc])->indent & 255);
        HTMLlineproc0("<center>",  &(henv.obuf), 1);
        HTMLlineproc0( *(t->caption),  &(henv.obuf), 0);
        HTMLlineproc0("</center>",  &(henv.obuf), 1);
        if(t->total_width < henv.maxlimit) {
            t->total_width = henv.maxlimit;
        }
        limit = h_env->limit;
        h_env->limit = t->total_width;
        HTMLlineproc0("<center>", h_env, 1);
        HTMLlineproc0( *(t->caption), h_env, 0);
        HTMLlineproc0("</center>", h_env, 1);
        h_env->limit = limit;
        return;
    }
}

void renderTable(struct table* t, int max_width, struct html_feed_environ* h_env)
{// addr = 0x08084A06  --  defined in 'table.c' at line 1690
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int w;                                 // _cfa_ffffffe8
    int r;                                 // _cfa_ffffffe4
    int h;                                 // _cfa_ffffffe0
    Str renderbuf;         // _cfa_ffffffdc
    int itr;                               // _cfa_ffffffd8
    VEC* newwidth;         // _cfa_ffffffd4
    MAT* mat;              // _cfa_ffffffd0
    MAT* minv;             // _cfa_ffffffcc
    PERM* pivot;          // _cfa_ffffffc8
    int width;                             // _cfa_ffffffc4
    int rulewidth;                         // _cfa_ffffffc0
    Str vrulea;            // _cfa_ffffffbc
    Str vruleb;            // _cfa_ffffffb8
    Str vrulec;            // _cfa_ffffffb4
    Str idtag;             // _cfa_ffffffb0
    TextLineList* l;   // _cfa_ffffffac
    int k;                                 // _cfa_ffffffa8
    short int[49] new_tabwidth;            // _cfa_ffffff44
    _unknown_ _v204;                       // _cfa_ffffff34 (outparam)
    _unknown_ _v208;                       // _cfa_ffffff30 (outparam)
    signed int _v212;                      // _cfa_ffffff2c (outparam)
    char* _v216;                           // _cfa_ffffff28 (outparam)
    _unknown_ __ebx;                       // r1
    PERM* _t733;          // _t733
    int _t928;                             // _t928
    int _t939;                             // _t939
    char _t1128;                           // _t1128
    int _t1138;                            // _t1138
    int _t1150;                            // _t1150
    int _t1162;                            // _t1162
    char _t1173;                           // _t1173
    int _t1183;                            // _t1183
    int _t1337;                            // _t1337
    int _t1353;                            // _t1353

    vrulea = 0;
    vruleb = 0;
    vrulec = 0;
    t->total_height = 0;
    if(t->maxcol < 0) {
        make_caption(t, h_env);
        return;
    }
    if(t->sloppy_width > max_width) {
        max_width = t->sloppy_width;
    }
    rulewidth = table_rule_width(t);
    max_width = max_width - table_border_width(t);
    if(rulewidth > 1) {
        max_width = floor_at_intervals(max_width, rulewidth);
    }
    if(max_width < rulewidth) {
        max_width = rulewidth;
    }
    check_maximum_width(t);
    if(t->maxcol != 0) {
        set_table_matrix(t, max_width);
        itr = 0;
        mat = new_matrix(t->maxcol + 1);
        _t733 = t->maxcol + 1 << 2;
         *__esp = _t733;
        GC_malloc();
        pivot = _t733;
        newwidth = new_vector(t->maxcol + 1);
        minv = new_matrix(t->maxcol + 1);
        do {
            _v212 = t->matrix->dim * t->matrix->dim * 8;
            _v216 = mat->me;
             *__esp = t->matrix->me;
            bcopy();
            LUfactor(mat, pivot);
            LUsolve(mat, pivot, t->vector, newwidth);
            LUinverse(mat, pivot, minv);
            itr = itr + 1;
        } while(check_table_width(t, newwidth->ve, minv, itr) != 0);
        set_integered_width(t, newwidth->ve,  &new_tabwidth);
        check_minimum_width(t,  &new_tabwidth);
        newwidth = 0;
        pivot = 0;
        mat = 0;
        minv = 0;
        t->matrix = 0;
        t->vector = 0;
        i = 0;
        while(t->maxcol >= i) {
             *(t->maxrow + (i + 40) * 2) =  *(__ebp + i * 2 - 184) & 65535;
            i = i + 1;
        }
        goto L22;
    } else {
        if((t->tabwidth & 65535) > max_width) {
            t->tabwidth = max_width;
        }
        if(t->total_width <= 0) {
            if((t->fixed_width & 65535) > 0) {
                t->tabwidth = t->fixed_width & 65535;
            }
        } else {
            t->tabwidth = max_width;
        }
        if((t->tabwidth & 65535) < (t->minimum_width & 65535)) {
            t->tabwidth = t->minimum_width & 65535;
        }
L22:
        check_minimum_width(t,  &(t->tabwidth));
        i = 0;
        while(t->maxcol >= i) {
             *(t->maxrow + (i + 40) * 2) = ceil_at_intervals( *(t->maxrow + (i + 40) * 2) & 65535, rulewidth);
            i = i + 1;
        }
        renderCoTable(t, h_env->limit);
        i = 0;
        while(t->maxcol >= i) {
            j = 0;
            while(t->maxrow >= j) {
                check_row(t, j);
                if(( *(t->tabattr[j] + i + i) & 2) == 0) {
                    do_refill(t, j, i, h_env->limit);
                }
                j = j + 1;
            }
            i = i + 1;
        }
        check_minimum_width(t,  &(t->tabwidth));
        t->total_width = 0;
        i = 0;
        while(t->maxcol >= i) {
             *(t->maxrow + (i + 40) * 2) = ceil_at_intervals( *(t->maxrow + (i + 40) * 2) & 65535, rulewidth);
            t->total_width = t->total_width + ( *(t->maxrow + (i + 40) * 2) & 65535);
            i = i + 1;
        }
        t->total_width = t->total_width + table_border_width(t);
        check_table_height(t);
        i = 0;
        while(t->maxcol >= i) {
            j = 0;
            while(t->maxrow >= j) {
                if(( *(t->tabattr[j] + i + i) & 2) != 0) {
L61:
                    j = j + 1;
                    continue;
                }
                if(( *(t->tabattr[j] + i + i) & 0x100) != 0) {
                    goto L61;
                }
                if(t->tabdata[j][i] == 0) {
                    goto L61;
                }
                h =  *(t->tabheight + j + j) & 65535;
                k = j + 1;
                while(t->maxrow >= k) {
                    if(( *(t->tabattr[k] + i + i) & 2) == 0) {
L50:
                        h = h - (t->tabdata[j][i]->nitem & 65535);
                        if(( *(t->tabattr[j] + i + i) & 0x200) != 0) {
                            h = (h >> 31) + h >> 1;
                        }
                        if(h <= 0) {
                        } else {
                            l = newGeneralList();
                            k = 0;
                            while(k < h) {
                                pushValue(l, newTextLine(0, 0));
                                k = k + 1;
                            }
                            t->tabdata[j][i] = appendGeneralList(l, t->tabdata[j][i]);
                        }
                        goto L61;
                    }
                    h = h + ( *(t->tabheight + k + k) & 65535);
                    if(t->border_mode - 1 <= 2) {
                        h = h + 1;
                    }
                    k = k + 1;
                }
                goto L50;
            }
            i = i + 1;
        }
        width = t->total_width;
        make_caption(t, h_env);
        HTMLlineproc0("<pre for_table>", h_env, 1);
        if(t->id != 0) {
            _v216 = html_quote( *(t->id));
            idtag = Sprintf("<_id id="%s">");
            HTMLlineproc0(idtag->ptr, h_env, 1);
        }
        if(t->border_mode - 1 <= 1) {
            renderbuf = Strnew();
            print_sep(t, -1, 0, t->maxcol, renderbuf);
            push_render_image(renderbuf, width, t->total_width, h_env);
            t->total_height = t->total_height + 1;
        }
        vruleb = Strnew();
        _t928 = t->border_mode;
        if(_t928 > 2) {
            if(_t928 == 3) {
                goto L91;
            }
        } else {
            if(_t928 >= 1) {
                vrulea = Strnew();
                vrulec = Strnew();
                _t1337 = symbol_width;
                if(t->border_mode != 2) {
                    _t1128 = 5;
                } else {
                    _t1128 = 21;
                }
                push_symbol(vrulea, _t1128, _t1337, 1);
                i = 0;
                while(t->cellpadding > i) {
                    if(vrulea->length + 1 >= vrulea->area_size) {
                        Strgrow(vrulea);
                    }
                    _t1138 = vrulea->length;
                     *((char*)(vrulea->ptr + _t1138)) = 32;
                    vrulea->length = _t1138 + 1;
                     *((char*)(vrulea->ptr + vrulea->length)) = 0;
                    if(vruleb->length + 1 >= vruleb->area_size) {
                        Strgrow(vruleb);
                    }
                    _t1150 = vruleb->length;
                     *((char*)(vruleb->ptr + _t1150)) = 32;
                    vruleb->length = _t1150 + 1;
                     *((char*)(vruleb->ptr + vruleb->length)) = 0;
                    if(vrulec->length + 1 >= vrulec->area_size) {
                        Strgrow(vrulec);
                    }
                    _t1162 = vrulec->length;
                     *((char*)(vrulec->ptr + _t1162)) = 32;
                    vrulec->length = _t1162 + 1;
                     *((char*)(vrulec->ptr + vrulec->length)) = 0;
                    i = i + 1;
                }
                _t1353 = symbol_width;
                if(t->border_mode != 2) {
                    _t1173 = 5;
                } else {
                    _t1173 = 21;
                }
                push_symbol(vrulec, _t1173, _t1353, 1);
L91:
                push_symbol(vruleb, 5, symbol_width, 1);
                i = 0;
                while(t->cellpadding > i) {
                    if(vruleb->length + 1 >= vruleb->area_size) {
                        Strgrow(vruleb);
                    }
                    _t939 = vruleb->length;
                     *((char*)(vruleb->ptr + _t939)) = 32;
                    vruleb->length = _t939 + 1;
                     *((char*)(vruleb->ptr + vruleb->length)) = 0;
                    i = i + 1;
                }
L102:
                r = 0;
                while(t->maxrow >= r) {
                    h = 0;
                    while(( *(t->tabheight + r + r) & 65535) > h) {
                        renderbuf = Strnew();
                        if(t->border_mode == 1 || t->border_mode == 2) {
                            Strcat(renderbuf, vrulea);
                        }
                        if( *(t->tridvalue + (r << 2)) != 0 && h == 0) {
                            _v216 = html_quote( *( *(t->tridvalue + (r << 2))));
                            idtag = Sprintf("<_id id="%s">");
                            Strcat(renderbuf, idtag);
                        }
                        i = 0;
                        while(t->maxcol >= i) {
                            check_row(t, r);
                            if( *(t->tabidvalue[r] + (i << 2)) != 0 && h == 0) {
                                _v216 = html_quote( *( *(t->tabidvalue[r] + (i << 2))));
                                idtag = Sprintf("<_id id="%s">");
                                Strcat(renderbuf, idtag);
                            }
                            if(( *(t->tabattr[r] + i + i) & 1) != 0) {
L127:
                                if(t->maxcol > i && ( *(t->tabattr[r] + i + 1 + i + 1) & 1) == 0) {
                                    Strcat(renderbuf, vruleb);
                                }
                                i = i + 1;
                                continue;
                            } else {
                                w =  *(t->maxrow + (i + 40) * 2) & 65535;
                                j = i + 1;
                                while(t->maxcol >= j && ( *(t->tabattr[r] + j + j) & 1) != 0) {
                                    w = w + t->cellspacing + ( *(t->maxrow + (j + 40) * 2) & 65535);
                                    j = j + 1;
                                }
                                if(( *(t->tabattr[r] + i + i) & 2) == 0) {
                                    print_item(t, r, i, w, renderbuf);
                                    goto L127;
                                }
                                j = r - 1;
                                while(j >= 0 && t->tabattr[j] != 0 && ( *(t->tabattr[j] + i + i) & 2) != 0) {
                                    j = j - 1;
                                }
                                print_item(t, j, i, w, renderbuf);
                                goto L127;
                            }
                        }
                        if(t->border_mode - 1 <= 1) {
                            Strcat(renderbuf, vrulec);
                            t->total_height = t->total_height + 1;
                        }
                        push_render_image(renderbuf, width, t->total_width, h_env);
                        h = h + 1;
                    }
                    if(t->maxrow > r && t->border_mode != 0) {
                        renderbuf = Strnew();
                        print_sep(t, r, 1, t->maxcol, renderbuf);
                        push_render_image(renderbuf, width, t->total_width, h_env);
                    }
                    t->total_height = t->total_height + ( *(t->tabheight + r + r) & 65535);
                    r = r + 1;
                }
                if(t->border_mode - 1 <= 1) {
                    renderbuf = Strnew();
                    print_sep(t, t->maxrow, 2, t->maxcol, renderbuf);
                    push_render_image(renderbuf, width, t->total_width, h_env);
                    t->total_height = t->total_height + 1;
                }
                if(t->total_height == 0) {
                    renderbuf = Strnew_charp(135049375);
                    t->total_height = t->total_height + 1;
                    t->total_width = 1;
                    push_render_image(renderbuf, 1, t->total_width, h_env);
                }
                HTMLlineproc0("</pre>", h_env, 1);
                return;
            }
            if(_t928 == 0) {
                i = 0;
                while(t->cellspacing > i) {
                    if(vruleb->length + 1 >= vruleb->area_size) {
                        Strgrow(vruleb);
                    }
                    _t1183 = vruleb->length;
                     *((char*)(vruleb->ptr + _t1183)) = 32;
                    vruleb->length = _t1183 + 1;
                     *((char*)(vruleb->ptr + vruleb->length)) = 0;
                    i = i + 1;
                }
                goto L102;
            }
        }
        goto L102;
    }
}

struct table* begin_table(int border, int spacing, int padding, int vspace)
{// addr = 0x0808594A  --  defined in 'table.c' at line 1972
    struct table* t;     // _cfa_fffffff0
    int mincell;                           // _cfa_ffffffec
    int rcellspacing;                      // _cfa_ffffffe8
    int mincell_pixels;                    // _cfa_ffffffe4
    int ppc;                               // _cfa_ffffffe0
    _unknown_ _v46;                        // _cfa_ffffffd2
    short _v48;                            // _cfa_ffffffd0
    int _t114;                             // _t114
    int _t122;                             // _t122

    mincell = minimum_cellspacing(border);
    asm("fild dword [ebp-0x10]");
    asm("fmulp st1, st0");
    asm("faddp st1, st0");
     *__esp =  *135050696;
    floor();
    asm("fnstcw word [ebp-0x2a]");
    _v48 = 12;
    asm("fldcw word [ebp-0x2c]");
    asm("fistp dword [ebp-0x18]");
    asm("fldcw word [ebp-0x2a]");
    asm("faddp st1, st0");
     *__esp =  *135050696;
    floor();
    asm("fnstcw word [ebp-0x2a]");
    _v48 = 12;
    asm("fldcw word [ebp-0x2c]");
    asm("fistp dword [ebp-0x1c]");
    asm("fldcw word [ebp-0x2a]");
    t = newTable();
    t->col = -1;
    t->row = t->col;
    t->maxcol = -1;
    t->maxrow = -1;
    t->border_mode = border;
    t->flag = 0;
    if(border == 3) {
        t->flag = t->flag | 2;
    }
    rcellspacing = padding + padding + spacing;
    _t114 = border;
    if(_t114 == 0) {
        t->cellpadding = rcellspacing - mincell_pixels;
    } else {
        if(_t114 >= 0 && _t114 <= 3) {
            t->cellpadding = padding - ((mincell_pixels - 4 >> 31) + mincell_pixels - 4 >> 1);
        }
    }
    if(t->cellpadding < ppc) {
        if(t->cellpadding <= 0) {
            t->cellpadding = 0;
        } else {
            t->cellpadding = 1;
        }
    } else {
        t->cellpadding = t->cellpadding / ppc;
    }
    _t122 = border;
    if(_t122 == 0) {
        t->cellspacing = t->cellpadding + mincell;
    } else {
        if(_t122 >= 0 && _t122 <= 3) {
            t->cellspacing = t->cellpadding + t->cellpadding + mincell;
        }
    }
    if(border != 0) {
        if(vspace >= ppc) {
            t->vspace = 1;
        } else {
            t->vspace = 0;
        }
    } else {
        if(((rcellspacing >> 31) + rcellspacing >> 1) + vspace > 1) {
            t->vspace = 1;
        } else {
            t->vspace = 0;
        }
    }
    if(border != 0) {
        if(ppc - 1 + ppc - 1 <= padding) {
            t->vcellpadding = 1;
        } else {
            t->vcellpadding = 0;
        }
    } else {
        if(rcellspacing > 4) {
            t->vcellpadding = 1;
        } else {
            t->vcellpadding = 0;
        }
    }
    return t;
}

void end_table(struct table* tbl)
{// addr = 0x08085B72  --  defined in 'table.c' at line 2046
    struct table_cell* cell;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int rulewidth;                         // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1

    cell =  &(tbl->cell);
    rulewidth = table_rule_width(tbl);
    if(rulewidth > 1) {
        if(tbl->total_width > 0) {
            tbl->total_width = ceil_at_intervals(tbl->total_width, rulewidth);
        }
        i = 0;
        while(tbl->maxcol >= i) {
             *(tbl->maxcol + (i + 88) * 2) = ceil_at_intervals( *(tbl->maxcol + (i + 88) * 2) & 65535, rulewidth);
             *(tbl->maxrow + (i + 40) * 2) = ceil_at_intervals( *(tbl->maxrow + (i + 40) * 2) & 65535, rulewidth);
            if(( *(tbl + (i + 144) * 2) & 65535) > 0) {
                 *(tbl + (i + 144) * 2) = ceil_at_intervals( *(tbl + (i + 144) * 2) & 65535, rulewidth);
            }
            i = i + 1;
        }
        i = 0;
        while((cell->maxcell & 65535) >= i) {
             *(cell->col + (i + 96) * 2) = ceil_at_intervals( *(cell->col + (i + 96) * 2) & 65535, rulewidth);
             *(cell->col + (i + 80) * 2) = ceil_at_intervals( *(cell->col + (i + 80) * 2) & 65535, rulewidth);
            if(( *(cell->col + (i + 120) * 2) & 65535) > 0) {
                 *(cell->col + (i + 120) * 2) = ceil_at_intervals( *(cell->col + (i + 120) * 2) & 65535, rulewidth);
            }
            i = i + 1;
        }
    }
    tbl->sloppy_width = get_table_width(tbl,  &(tbl->fixed_width),  &(tbl->cell.fixed_width), 1);
    if(tbl->total_width > tbl->sloppy_width) {
        tbl->sloppy_width = tbl->total_width;
        return;
    }
}

void check_minimum0(struct table* t, int min)
{// addr = 0x08085D9E  --  defined in 'table.c' at line 2076
    int i;                                 // _cfa_fffffff0
    int w;                                 // _cfa_ffffffec
    int ww;                                // _cfa_ffffffe8
    struct table_cell* cell;   // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(t->col < 0) {
        return;
    }
    if(( *(t->maxrow + (t->col + 40) * 2) & 65535) < 0) {
L17:
        return;
    }
    check_row(t, t->row);
    w = table_colspan(t, t->row, t->col);
    min = min + t->indent;
    if(w != 1) {
        cell =  &(t->cell);
        ww = 0;
        if((cell->icell & 65535) >= 0 && ( *(cell->col + ((cell->icell & 65535) + 96) * 2) & 65535) < min) {
             *(cell->col + ((cell->icell & 65535) + 96) * 2) = min;
        }
    } else {
        ww = min;
    }
    i = t->col;
    while(t->maxcol >= i) {
        if(t->col == i || ( *(t->tabattr[t->row] + i + i) & 1) != 0) {
            if(( *(t->maxcol + (i + 88) * 2) & 65535) < ww) {
                 *(t->maxcol + (i + 88) * 2) = ww;
            }
            i = i + 1;
            continue;
        } else {
            return;
        }
    }
    goto L17;
}

int setwidth0(struct table* t, struct table_mode* mode)
{// addr = 0x08085EE6  --  defined in 'table.c' at line 2105
    int w;                                 // _cfa_fffffff0
    int width;                             // _cfa_ffffffec
    struct table_cell* cell;   // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    width = t->tabcontentssize;
    cell =  &(t->cell);
    if(t->col < 0) {
        return -1;
    }
    if(( *(t->maxrow + (t->col + 40) * 2) & 65535) >= 0) {
        check_row(t, t->row);
        if((t->linfo.prev_spaces & 255) > 0) {
            width = width - (t->linfo.prev_spaces & 255);
        }
        w = table_colspan(t, t->row, t->col);
        if(w != 1) {
            if((cell->icell & 65535) >= 0 && ( *(cell->col + ((cell->icell & 65535) + 80) * 2) & 65535) < width) {
                 *(cell->col + ((cell->icell & 65535) + 80) * 2) = width;
            }
        } else {
            if(( *(t->maxrow + (t->col + 40) * 2) & 65535) < width) {
                 *(t->maxrow + (t->col + 40) * 2) = width;
            }
        }
        return width;
    } else {
        return -1;
    }
}

void setwidth(struct table* t, struct table_mode* mode)
{// addr = 0x08086002  --  defined in 'table.c' at line 2131
    int width;                             // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    width = setwidth0(t, mode);
    if(width < 0) {
L7:
        return;
    }
    if(( *(t->tabattr[t->row] + t->col + t->col) & 4) != 0) {
        check_minimum0(t, width);
    }
    if((mode->pre_mode & 641) == 0 || (mode->nobr_offset & 65535) < 0) {
        goto L7;
    } else {
        check_minimum0(t, width - (mode->nobr_offset & 65535));
        return;
    }
}

void addcontentssize(struct table* t, int width)
{// addr = 0x0808609F  --  defined in 'table.c' at line 2146
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(t->col < 0) {
        return;
    }
    if(( *(t->maxrow + (t->col + 40) * 2) & 65535) >= 0) {
        check_row(t, t->row);
        t->tabcontentssize = t->tabcontentssize + width;
        return;
    }
}

void clearcontentssize(struct table* t, struct table_mode* mode)
{// addr = 0x080860F2  --  defined in 'table.c' at line 2160
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    table_close_anchor0(t, mode);
    mode->nobr_offset = 0;
    t->linfo.prev_spaces = 255;
    Strcopy_charp_n(t->linfo.prevchar, 135049375, 1);
    t->linfo = 0;
    t->linfo.length = 0;
    t->tabcontentssize = 0;
}

void begin_cell(struct table* t, struct table_mode* mode)
{// addr = 0x08086162  --  defined in 'table.c' at line 2172
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    clearcontentssize(t, mode);
    mode->indent_level = 0;
    mode->nobr_level = 0;
    mode->pre_mode = 0;
    t->indent = 0;
    t->flag = t->flag | 4;
    if(t->suspended_data != 0) {
        check_row(t, t->row);
        if(t->tabdata[t->row][t->col] == 0) {
            t->tabdata[t->row][t->col] = newGeneralList();
        }
        appendGeneralList(t->tabdata[t->row][t->col], t->suspended_data);
        t->suspended_data = 0;
        return;
    }
}

void check_rowcol(struct table* tbl, struct table_mode* mode)
{// addr = 0x08086268  --  defined in 'table.c' at line 2192
    int row;                               // _cfa_fffffff0
    int col;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    row = tbl->row;
    col = tbl->col;
    if((tbl->flag & 1) == 0) {
        tbl->col = -1;
    }
    if(tbl->row == -1) {
        tbl->row = 0;
    }
    if(tbl->col == -1) {
        tbl->col = 0;
    }
    while(1) {
        check_row(tbl, tbl->row);
        while(tbl->col <= 49 && ( *(tbl->tabattr[tbl->row] + tbl->col + tbl->col) & 3) != 0) {
            tbl->col = tbl->col + 1;
        }
        if(tbl->col > 49) {
            tbl->col = 0;
            tbl->row = tbl->row + 1;
            continue;
        }
        if(tbl->row > tbl->maxrow) {
            tbl->maxrow = tbl->row;
        }
        if(tbl->col > tbl->maxcol) {
            tbl->maxcol = tbl->col;
        }
        if(tbl->row != row || tbl->col != col) {
            begin_cell(tbl, mode);
        }
        tbl->flag = tbl->flag | 4;
        return;
    }
}

int skip_space(struct table* t, char* line, struct table_linfo* linfo, int checkminimum)
{// addr = 0x080863EA  --  defined in 'table.c' at line 2227
    Lineprop ctype;   // _cfa_fffffff2
    Lineprop prev_ctype;   // _cfa_fffffff0
    int skip;                              // _cfa_ffffffec
    int s;                                 // _cfa_ffffffe8
    Str prevchar;          // _cfa_ffffffe4
    int w;                                 // _cfa_ffffffe0
    int min;                               // _cfa_ffffffdc
    char* save;                            // _cfa_ffffffd8
    char* c;                               // _cfa_ffffffd4
    int ec;                                // _cfa_ffffffd0
    int len;                               // _cfa_ffffffcc
    int wlen;                              // _cfa_ffffffc8
    int plen;                              // _cfa_ffffffc4
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    int _t151;                             // _t151
    char* _t222;                           // _t222

    skip = 0;
    s = linfo->prev_spaces & 255;
    prev_ctype = linfo->prev_ctype & 65535;
    prevchar = linfo->prevchar;
    w = linfo->length & 65535;
    min = 1;
    if(( *line & 255) == 60) {
        _t222 = line;
         *__esp = _t222;
        strlen();
        if((line[_t222 - 1] & 255) == 62) {
            if(checkminimum != 0) {
                check_minimum0(t, visible_length(line));
            }
            return 0;
        }
    }
    while(( *line & 255) != 0) {
        save = line;
        c = line;
        ctype = ( *( &WTF_TYPE_MAP + ( *line & 0xff)) & 0xff) << 8;
        if(( *135119023 & 255) == 0) {
            _t151 = ( *( &WTF_WIDTH_MAP + ( *line & 0xff)) & 255) != 0 & 255;
        } else {
            _t151 =  *( &WTF_WIDTH_MAP + ( *line & 0xff)) & 0xff;
        }
        len = _t151;
        plen =  *( &WTF_LEN_MAP + ( *line & 0xff)) & 0xff;
        wlen = plen;
        if(min < w) {
            min = w;
        }
        if(ctype != 0 || ( *( &MYCTYPE_MAP + ( *c & 0xff)) & 2) == 0) {
            if(( *c & 255) == 38) {
                ec = getescapechar( &line);
                if(ec >= 0) {
                    c = conv_entity(ec);
                    ctype = ( *( &WTF_TYPE_MAP + ( *c & 0xff)) & 0xff) << 8;
                    len = wtf_strwidth(c);
                    wlen = line - save;
                    plen =  *( &WTF_LEN_MAP + ( *c & 0xff)) & 0xff;
                }
            }
            if(prevchar->length == 0 || is_boundary(prevchar->ptr, c) == 0) {
                w = w + len;
            } else {
                w = len;
            }
            if(s > 0) {
                if(ctype != 2560 || prev_ctype != 2560) {
                    skip = skip + s - 1;
                } else {
                    skip = skip + s;
                }
            }
            s = 0;
            prev_ctype = ctype & 65535;
        } else {
            w = 0;
            s = s + 1;
        }
        Strcopy_charp_n(prevchar, c, plen);
        line =  &(save[wlen]);
    }
    if(s <= 1) {
        linfo->prev_spaces = s;
    } else {
        skip = skip + s - 1;
        linfo->prev_spaces = 1;
    }
    linfo->prev_ctype = prev_ctype & 65535;
    linfo->prevchar = prevchar;
    if(checkminimum != 0) {
        if(min < w) {
            min = w;
        }
        linfo->length = w;
        check_minimum0(t, min);
    }
    return skip;
}

void feed_table_inline_tag(struct table* tbl, char* line, struct table_mode* mode, int width)
{// addr = 0x080866C5  --  defined in 'table.c' at line 2307
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    check_rowcol(tbl, mode);
    pushdata(tbl, tbl->row, tbl->col, line);
    if(width >= 0) {
        check_minimum0(tbl, width);
        addcontentssize(tbl, width);
        setwidth(tbl, mode);
        return;
    }
}

void feed_table_block_tag(struct table* tbl, char* line, struct table_mode* mode, int indent, int cmd)
{// addr = 0x08086740  --  defined in 'table.c' at line 2320
    int offset;                            // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if((mode->indent_level & 255) > 0 || indent != -1) {
        setwidth(tbl, mode);
        feed_table_inline_tag(tbl, line, mode, -1);
        clearcontentssize(tbl, mode);
        if(indent != 1) {
            if(indent == -1) {
                mode->indent_level = (mode->indent_level & 255) - 1;
                if((mode->indent_level & 255) <= 9) {
                    tbl->indent = tbl->indent - IndentIncr;
                }
            }
        } else {
            mode->indent_level = (mode->indent_level & 255) + 1;
            if((mode->indent_level & 255) <= 10) {
                tbl->indent = tbl->indent + IndentIncr;
            }
        }
        offset = tbl->indent;
        if(cmd == 19 && (mode->indent_level & 255) > 0 && (mode->indent_level & 255) <= 10) {
            offset = offset - IndentIncr;
        }
        if(tbl->indent <= 0) {
            goto L15;
        } else {
            check_minimum0(tbl, 0);
            addcontentssize(tbl, offset);
            return;
        }
    } else {
L15:
        return;
    }
}

void table_close_select(struct table* tbl, struct table_mode* mode, int width)
{// addr = 0x0808686B  --  defined in 'table.c' at line 2351
    Str tmp;               // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    tmp = process_n_select();
    mode->pre_mode = mode->pre_mode & 239;
    mode->end_tag = 0;
    feed_table1(tbl, tmp, mode, width);
}

void table_close_textarea(struct table* tbl, struct table_mode* mode, int width)
{// addr = 0x080868B1  --  defined in 'table.c' at line 2360
    Str tmp;               // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    tmp = process_n_textarea();
    mode->pre_mode = mode->pre_mode & 247;
    mode->end_tag = 0;
    feed_table1(tbl, tmp, mode, width);
}

void table_close_anchor0(struct table* tbl, struct table_mode* mode)
{// addr = 0x080868F7  --  defined in 'table.c' at line 2369
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if((mode->pre_mode & 16777216) == 0) {
L8:
        return;
    }
    mode->pre_mode = mode->pre_mode & -16777217;
    if(tbl->tabcontentssize == (mode->anchor_offset & 65535)) {
        check_minimum0(tbl, 1);
        addcontentssize(tbl, 1);
        setwidth(tbl, mode);
        return;
    }
    if((tbl->linfo.prev_spaces & 255) <= 0 || tbl->tabcontentssize - 1 != (mode->anchor_offset & 65535) || (tbl->linfo.prev_spaces & 255) <= 0) {
        goto L8;
    } else {
        tbl->linfo.prev_spaces = 255;
        return;
    }
}

int feed_table_tag(struct table* tbl, char* line, struct table_mode* mode, int width, struct parsed_tag* tag)
{// addr = 0x080869AD  --  defined in 'table.c' at line 2412
    char* p;                               // _cfa_ffffffd8
    int colspan;                           // _cfa_ffffffd0
    int rowspan;                           // _cfa_ffffffcc
    int col;                               // _cfa_ffffffc8
    int prev_col;                          // _cfa_ffffffc4
    int i;                                 // _cfa_ffffffc0
    int j;                                 // _cfa_ffffffbc
    int k;                                 // _cfa_ffffffb8
    int v;                                 // _cfa_ffffffb4
    int v0;                                // _cfa_ffffffb0
    int w;                                 // _cfa_ffffffac
    int id;                                // _cfa_ffffffa8
    Str tok;               // _cfa_ffffffa4
    Str tmp;               // _cfa_ffffffa0
    Str anchor;            // _cfa_ffffff9c
    table_attr align;   // _cfa_ffffffe2
    table_attr valign;   // _cfa_ffffffe0
    int ii;                                // _cfa_ffffff98
    Str tmp;               // _cfa_ffffff94
    struct table* tbl1;   // _cfa_ffffff90
    int cmd;                               // _cfa_ffffffdc
    struct table_cell* cell;   // _cfa_ffffffd4
    _unknown_ _v156;                       // _cfa_ffffff64 (outparam)
    _unknown_ _v160;                       // _cfa_ffffff60 (outparam)
    _unknown_ _v164;                       // _cfa_ffffff5c (outparam)
    _unknown_ _v168;                       // _cfa_ffffff58 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    int _t84;                              // _t84

    cell =  &(tbl->cell);
    cmd = tag->tagid & 0xff;
    if((mode->pre_mode & 8) == 0) {
        if((mode->pre_mode & 2048) == 0) {
            if((mode->pre_mode & 2) == 0) {
                if((mode->pre_mode & 4) == 0) {
                    if((mode->pre_mode & 4096) == 0) {
                        if((mode->caption & 255) == 0) {
                            if((mode->pre_mode & 1) == 0) {
L29:
                                if(cmd > 140) {
                                    return 1;
                                }
                                goto __eax;
                            }
                            _t84 = cmd;
                            if(_t84 < 50 || _t84 > 51 && _t84 + -128 > 1) {
                                goto L29;
                            } else {
                                return 0;
                            }
                        }
                        if(cmd - 31 > 59) {
                            return 1;
                        }
                        goto __eax;
                    }
                    if(cmd - 31 > 59) {
                        return 1;
                    }
                    goto __eax;
                }
                if((mode->end_tag & 0xff) != cmd) {
                    return 4;
                }
                mode->pre_mode = mode->pre_mode & -5;
                mode->end_tag = 0;
                return 0;
            }
            if((mode->end_tag & 0xff) != cmd) {
                return 4;
            }
            mode->pre_mode = mode->pre_mode & -3;
            mode->end_tag = 0;
            return 0;
        }
        if(cmd - 31 > 59) {
            return 1;
        }
        goto __eax;
    }
    if((mode->end_tag & 0xff) == cmd) {
        mode->pre_mode = mode->pre_mode & -9;
        mode->end_tag = 0;
        feed_table_block_tag(tbl, line, mode, 0, cmd);
        return 0;
    }
    return 4;
}

int feed_table(struct table* tbl, char* line, struct table_mode* mode, int width, int internal)
{// addr = 0x0808822A  --  defined in 'table.c' at line 3090
    int i;                                 // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    Str tmp;               // _cfa_ffffffe8
    struct table_linfo* linfo;   // _cfa_ffffffe4
    struct parsed_tag* tag;   // _cfa_ffffffe0
    char* q;                               // _cfa_ffffffdc
    char* r;                               // _cfa_ffffffd8
    int ec;                                // _cfa_ffffffd4
    int nl;                                // _cfa_ffffffd0
    _unknown_ _v76;                        // _cfa_ffffffb4 (outparam)
    _unknown_ _v80;                        // _cfa_ffffffb0 (outparam)
    intOrPtr _v84;                         // _cfa_ffffffac (outparam)
    char* _v88;                            // _cfa_ffffffa8 (outparam)
    char* _t345;                           // _t345
    char* _t387;                           // _t387
    char* _t454;                           // _t454
    int _t467;                             // _t467
    char* _t476;                           // _t476
    int _t483;                             // _t483
    char* _t492;                           // _t492
    char* _t493;                           // _t493
    int _t497;                             // _t497
    int _t509;                             // _t509
    char* _t518;                           // _t518
    int _t528;                             // _t528
    int _t541;                             // _t541
    char* _t550;                           // _t550
    int _t587;                             // _t587

    linfo =  &(tbl->linfo);
    if(( *line & 255) != 60 || (line[1] & 255) == 0 || ( *( &MYCTYPE_MAP + (line[1] & 0xff)) & 4) == 0 && (line[1] & 255) != 47 && (line[1] & 255) != 33 && (line[1] & 255) != 63 && (line[1] & 255) != 0 && (line[1] & 255) != 95) {
        if((mode->pre_mode & 3145728) == 0) {
            goto L28;
        }
        return -1;
    } else {
        p = line;
        tag = parse_tag( &p, internal);
        if(tag == 0) {
            if((mode->pre_mode & 6158) == 0) {
                return -1;
            }
L28:
            if((mode->caption & 255) == 0) {
                if((mode->pre_mode & 2) == 0) {
                    if((mode->pre_mode & 4) == 0) {
                        if((mode->pre_mode & 2048) == 0) {
                            if((mode->pre_mode & 4096) == 0) {
                                if((mode->pre_mode & 8) != 0) {
L78:
                                    if((mode->pre_mode & 527) != 0) {
                                        if((mode->pre_mode & 512) == 0) {
                                            check_rowcol(tbl, mode);
                                            while(( *line & 255) != 0) {
                                                nl = 0;
                                                _v88 = 13;
                                                _t345 = line;
                                                 *__esp = _t345;
                                                strchr();
                                                p = _t345;
                                                if(p != 0) {
L98:
                                                    if(( *p & 255) == 13 && (p[1] & 255) == 10) {
                                                        p =  &(p[1]);
                                                    }
                                                    if((p[1] & 255) == 0) {
                                                        p = line;
                                                        line = 135049312;
                                                    } else {
                                                        p =  &(p[1]);
                                                        tmp = Strnew_charp_n(line, p - line);
                                                        line = p;
                                                        p = tmp->ptr;
                                                    }
                                                    nl = 1;
L106:
                                                    if((mode->pre_mode & 8) == 0) {
                                                        i = maximum_visible_length(p, tbl->tabcontentssize);
                                                    } else {
                                                        i = maximum_visible_length_plain(p, tbl->tabcontentssize);
                                                    }
                                                    addcontentssize(tbl, i);
                                                    setwidth(tbl, mode);
                                                    if(nl != 0) {
                                                        clearcontentssize(tbl, mode);
                                                    }
                                                    pushdata(tbl, tbl->row, tbl->col, p);
                                                    continue;
                                                }
                                                _v88 = 10;
                                                _t387 = line;
                                                 *__esp = _t387;
                                                strchr();
                                                p = _t387;
                                                if(p == 0) {
                                                    p = line;
                                                    line = 135049312;
                                                    goto L106;
                                                }
                                                goto L98;
                                            }
L113:
                                            return -1;
                                        }
                                        check_rowcol(tbl, mode);
                                        if((mode->nobr_offset & 65535) < 0) {
                                            mode->nobr_offset = tbl->tabcontentssize;
                                        }
                                        addcontentssize(tbl, maximum_visible_length(line, tbl->tabcontentssize));
                                        setwidth(tbl, mode);
                                        pushdata(tbl, tbl->row, tbl->col, line);
                                        goto L113;
                                    }
                                    if((tbl->flag & 4) == 0) {
L84:
                                        while(( *( &MYCTYPE_MAP + ( *line & 0xff)) & 2) != 0) {
                                            line =  &(line[1]);
                                        }
L85:
                                        if(( *line & 255) != 0) {
                                            check_rowcol(tbl, mode);
                                            if((mode->pre_mode & 128) != 0 && (mode->nobr_offset & 65535) < 0) {
                                                mode->nobr_offset = tbl->tabcontentssize;
                                            }
                                            i = skip_space(tbl, line, linfo, (mode->pre_mode & 128) == 0 & 255);
                                            addcontentssize(tbl, visible_length(line) - i);
                                            setwidth(tbl, mode);
                                            pushdata(tbl, tbl->row, tbl->col, line);
                                            goto L113;
                                        }
                                        return -1;
                                    }
                                    if((linfo->prev_spaces & 255) == 0) {
                                        goto L85;
                                    }
                                    goto L84;
                                }
                                if(( *line & 255) != 60) {
L41:
                                    _v88 = 38;
                                    _t454 = line;
                                     *__esp = _t454;
                                    strchr();
                                    if(_t454 == 0) {
                                        goto L78;
                                    }
                                    tmp = Strnew();
                                    p = line;
                                    while(( *p & 255) != 0) {
                                        if(( *p & 255) != 38) {
                                            if(tmp->length + 1 >= tmp->area_size) {
                                                Strgrow(tmp);
                                            }
                                            _t467 = tmp->length;
                                             *((char*)(tmp->ptr + _t467)) =  *p & 255;
                                            tmp->length = _t467 + 1;
                                             *((char*)(tmp->ptr + tmp->length)) = 0;
                                            p =  &(p[1]);
                                            continue;
                                        }
                                        _t476 = p;
                                        _v84 = 5;
                                        _v88 = 135050668;
                                         *__esp = _t476;
                                        strncasecmp();
                                        if(_t476 == 0) {
L47:
                                            if(tmp->length + 1 >= tmp->area_size) {
                                                Strgrow(tmp);
                                            }
                                            _t483 = tmp->length;
                                             *((char*)(tmp->ptr + _t483)) =  *p & 255;
                                            tmp->length = _t483 + 1;
                                             *((char*)(tmp->ptr + tmp->length)) = 0;
                                            p =  &(p[1]);
                                            continue;
                                        }
                                        _t492 = p;
                                        _v84 = 4;
                                        _v88 = 135050674;
                                         *__esp = _t492;
                                        strncasecmp();
                                        if(_t492 == 0) {
                                            goto L47;
                                        }
                                        _t493 = p;
                                        _v84 = 4;
                                        _v88 = 135050679;
                                         *__esp = _t493;
                                        strncasecmp();
                                        if(_t493 != 0) {
                                            q = p;
                                            ec = getescapechar( &p);
                                            _t497 = ec;
                                            if(_t497 == 38) {
                                                Strcat_charp(tmp, 135050668);
                                                continue;
                                            }
                                            if(_t497 > 38) {
                                                if(_t497 == 60) {
                                                    Strcat_charp(tmp, 135050679);
                                                    continue;
                                                }
                                                if(_t497 == 62) {
                                                    Strcat_charp(tmp, 135050674);
                                                    continue;
                                                }
L64:
                                                r = conv_entity(ec);
                                                if(r == 0) {
L70:
                                                    if(tmp->length + 1 >= tmp->area_size) {
                                                        Strgrow(tmp);
                                                    }
                                                    _t509 = tmp->length;
                                                     *((char*)(tmp->ptr + _t509)) =  *q & 255;
                                                    tmp->length = _t509 + 1;
                                                     *((char*)(tmp->ptr + tmp->length)) = 0;
                                                    p =  &(q[1]);
                                                    continue;
                                                }
                                                _t518 = r;
                                                 *__esp = _t518;
                                                strlen();
                                                if(_t518 != 1 || ( *r & 0xff) != ec) {
                                                    goto L70;
                                                } else {
                                                    if(tmp->length + 1 >= tmp->area_size) {
                                                        Strgrow(tmp);
                                                    }
                                                    _t528 = tmp->length;
                                                     *((char*)(tmp->ptr + _t528)) =  *r & 255;
                                                    tmp->length = _t528 + 1;
                                                     *((char*)(tmp->ptr + tmp->length)) = 0;
                                                    continue;
                                                }
                                            }
                                            if(_t497 == -1) {
                                                goto L70;
                                            }
                                            if(_t497 == 13) {
                                                if(tmp->length + 1 >= tmp->area_size) {
                                                    Strgrow(tmp);
                                                }
                                                _t541 = tmp->length;
                                                 *((char*)(tmp->ptr + _t541)) = 10;
                                                tmp->length = _t541 + 1;
                                                 *((char*)(tmp->ptr + tmp->length)) = 0;
                                                continue;
                                            }
                                            goto L64;
                                        }
                                        goto L47;
                                    }
                                    line = tmp->ptr;
                                    goto L78;
                                }
                                _t550 = line;
                                 *__esp = _t550;
                                strlen();
                                if((line[_t550 - 1] & 255) == 62) {
                                    goto L78;
                                }
                                goto L41;
                            }
                            feed_select(line);
                            return -1;
                        }
                        feed_textarea(line);
                        return -1;
                    }
                    return -1;
                }
                return -1;
            }
            Strcat_charp(tbl->caption, line);
            return -1;
        }
        _t587 = feed_table_tag(tbl, line, mode, width, tag);
        if(_t587 == 2) {
            return 1;
        }
        if(_t587 > 2) {
            if(_t587 == 3) {
                return 0;
            }
            if(_t587 == 4) {
            } else {
L20:
                if((tag->need_reconstruct & 255) != 0) {
                    line =  *(parsedtag2str(tag));
                }
            }
            goto L28;
        } else {
            if(_t587 == 0) {
                return -1;
            } else {
                goto L20;
            }
        }
    }
}

void feed_table1(struct table* tbl, Str tok, struct table_mode* mode, int width)
{// addr = 0x08088AE3  --  defined in 'table.c' at line 3257
    Str tokbuf;            // _cfa_fffffff0
    int status;                            // _cfa_ffffffec
    char* line;                            // _cfa_ffffffe8
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    if(tok != 0) {
        tokbuf = Strnew();
        status = 0;
        line = tok->ptr;
        while(read_token(tokbuf,  &line,  &status, mode->pre_mode & 2575, 0) != 0) {
            feed_table(tbl, tokbuf->ptr, mode, width, 1);
        }
        return;
    }
}

void pushTable(struct table* tbl, struct table* tbl1)
{// addr = 0x08088B6A  --  defined in 'table.c' at line 3273
    int col;                               // _cfa_fffffff0
    int row;                               // _cfa_ffffffec
    struct table_in* tmp;   // _cfa_ffffffe8
    signed int _v36;                       // _cfa_ffffffdc
    struct table_in* _v40;   // _cfa_ffffffd8 (outparam)
    struct table_in* _t162;   // _t162

    col = tbl->col;
    row = tbl->row;
    if((tbl->ntable & 65535) >= (tbl->tables_size & 65535)) {
        tbl->tables_size = (tbl->tables_size & 65535) + 20;
        _t162 = (tbl->tables_size & 65535) << 4;
         *__esp = _t162;
        GC_malloc();
        tmp = _t162;
        if(tbl->tables != 0) {
            _v36 = (tbl->ntable & 65535) << 4;
            _v40 = tmp;
             *__esp = tbl->tables;
            bcopy();
        }
        tbl->tables = tmp;
    }
     *(tbl->tables + ((tbl->ntable & 65535) << 4)) = tbl1;
    (tbl->tables + ((tbl->ntable & 65535) << 4))[1] = col;
    (tbl->tables + ((tbl->ntable & 65535) << 4))[1] = row;
    (tbl->tables + ((tbl->ntable & 65535) << 4))[2] = tbl->indent;
    (tbl->tables + ((tbl->ntable & 65535) << 4))[3] = newGeneralList();
    check_row(tbl, row);
    if(col + 1 > tbl->maxcol || ( *( *((intOrPtr*)(tbl->tabattr + (row << 2))) + col + 1 + col + 1) & 1) == 0) {
        (tbl->tables + ((tbl->ntable & 65535) << 4))[2] = 65535;
    } else {
        (tbl->tables + ((tbl->ntable & 65535) << 4))[2] = tbl->cell.icell & 65535;
    }
    tbl->ntable = (tbl->ntable & 65535) + 1;
}

int correct_table_matrix(struct table* t, int col, int cspan, int a, double b)
{// addr = 0x08088D64  --  defined in 'table.c' at line 3305
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    int ecol;                              // _cfa_fffffff0
    double w;                              // _cfa_ffffffe4
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4

    _v44 = b;
    _v40 = _a24;
    ecol = col + cspan;
    asm("fld1");
    asm("fdivrp st1, st0");
    w = _v44 * _v44;
    i = col;
    while(i < ecol) {
        asm("fild dword [ebp+0x14]");
        asm("faddp st1, st0");
         *(t->vector->ve + (i << 3)) =  *(t->vector->ve + (i << 3)) * w;
        j = i;
        while(j < ecol) {
             *((long long*)(t->matrix->me + (t->matrix->dim * i + j << 3))) =  *((long long*)(t->matrix->me + (t->matrix->dim * i + j << 3))) + w;
             *((long long*)(t->matrix->me + (t->matrix->dim * j + i << 3))) =  *((long long*)(t->matrix->me + (t->matrix->dim * i + j << 3)));
            j = j + 1;
        }
        i = i + 1;
    }
    return i;
}

void correct_table_matrix2(struct table* t, int col, int cspan, double s, double b)
{// addr = 0x08088E96  --  defined in 'table.c' at line 3322
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    int ecol;                              // _cfa_fffffff0
    int size;                              // _cfa_ffffffec
    double w;                              // _cfa_ffffffe4
    double ss;                             // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed long long _t113;                // _t113

    _v44 = s;
    _v40 = b;
    _v52 = _a24;
    _v48 = _a28;
    ecol = col + cspan;
    size = t->maxcol + 1;
    _t113 = _v52 * _v52;
    asm("fld1");
    asm("fdivrp st1, st0");
    w = _t113;
    i = 0;
    while(i < size) {
        while(j < size) {
            if(i < col || i >= ecol) {
L7:
                if(i < col || i >= ecol) {
                    if(j < col || j >= ecol) {
                        ss = _v44 * _v44;
                        goto L13;
                    } else {
                        goto L11;
                    }
                } else {
L11:
                    asm("fld1");
                    asm("fchs");
                    ss = (_t113 - _v44) * _v44;
                    goto L13;
                }
            } else {
                if(j < col || j >= ecol) {
                    goto L7;
                } else {
                    asm("fld1");
                    asm("fld1");
                    asm("fmulp st1, st0");
                    ss = _t113 - _v44 - _v44;
L13:
                    _t113 = w * ss;
                    asm("faddp st1, st0");
                     *(t->matrix->me + (t->matrix->dim * i + j << 3)) = _t113;
                    j = j + 1;
                    continue;
                }
            }
        }
        i = i + 1;
    }
}

void correct_table_matrix3(struct table* t, int col, char* flags, double s, double b)
{// addr = 0x08088FCE  --  defined in 'table.c' at line 3344
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    int size;                              // _cfa_fffffff0
    int flg;                               // _cfa_ffffffec
    double ss;                             // _cfa_ffffffe4
    double w;                              // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed long long _t128;                // _t128

    _v44 = s;
    _v40 = b;
    _v52 = _a24;
    _v48 = _a28;
    size = t->maxcol + 1;
    _t128 = _v52 * _v52;
    asm("fld1");
    asm("fdivrp st1, st0");
    w = _t128;
    flg = (flags[col] & 255) == 0 & 255;
    i = 0;
    while(i < size) {
        if(flg == 0 || (flags[i] & 255) != 0) {
            if(flg != 0) {
                goto L25;
            }
            if((flags[i] & 255) == 0) {
                goto L25;
            }
            goto L5;
        } else {
L5:
            j = i;
            while(j < size) {
                if(flg == 0 || (flags[j] & 255) != 0) {
                    if(flg != 0) {
                        goto L20;
                    }
                    if((flags[j] & 255) == 0) {
                        goto L20;
                    }
                    goto L10;
                } else {
L10:
                    if(i != col || j != col) {
                        if(i == col || j == col) {
                            asm("fld1");
                            asm("fchs");
                            ss = (_t128 - _v44) * _v44;
                        } else {
                            ss = _v44 * _v44;
                        }
                    } else {
                        asm("fld1");
                        asm("fld1");
                        asm("fmulp st1, st0");
                        ss = _t128 - _v44 - _v44;
                    }
                    _t128 = w * ss;
                    asm("faddp st1, st0");
                     *(t->matrix->me + (t->matrix->dim * i + j << 3)) = _t128;
L20:
                    j = j + 1;
                    continue;
                }
            }
L25:
            i = i + 1;
            continue;
        }
    }
}

void correct_table_matrix4(struct table* t, int col, int cspan, char* flags, double s, double b)
{// addr = 0x08089156  --  defined in 'table.c' at line 3371
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    int ecol;                              // _cfa_fffffff0
    int size;                              // _cfa_ffffffec
    double ss;                             // _cfa_ffffffe4
    double w;                              // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed long long _t135;                // _t135

    _v44 = s;
    _v40 = b;
    _v52 = _a28;
    _v48 = _a32;
    ecol = col + cspan;
    size = t->maxcol + 1;
    _t135 = _v52 * _v52;
    asm("fld1");
    asm("fdivrp st1, st0");
    w = _t135;
    i = 0;
    while(i < size) {
        if((flags[i] & 255) == 0) {
L4:
            j = i;
            while(j < size) {
                if((flags[j] & 255) == 0) {
L8:
                    if(i < col || i >= ecol || j < col) {
L13:
                        if(i < col || i >= ecol) {
                            if(j < col || j >= ecol) {
                                ss = _v44 * _v44;
                                goto L19;
                            } else {
                                goto L17;
                            }
                        } else {
L17:
                            asm("fld1");
                            asm("fchs");
                            ss = (_t135 - _v44) * _v44;
                            goto L19;
                        }
                    } else {
                        if(j >= ecol) {
                            goto L13;
                        } else {
                            asm("fld1");
                            asm("fld1");
                            asm("fmulp st1, st0");
                            ss = _t135 - _v44 - _v44;
L19:
                            _t135 = w * ss;
                            asm("faddp st1, st0");
                             *(t->matrix->me + (t->matrix->dim * i + j << 3)) = _t135;
L22:
                            j = j + 1;
                            continue;
                        }
                    }
                }
                if(j < col) {
                    goto L22;
                }
                if(j >= ecol) {
                    goto L22;
                }
                goto L8;
            }
L27:
            i = i + 1;
            continue;
        }
        if(i < col) {
            goto L27;
        }
        if(i >= ecol) {
            goto L27;
        }
        goto L4;
    }
}

void set_table_matrix0(struct table* t, int maxwidth)
{// addr = 0x080892E4  --  defined in 'table.c' at line 3398
    double we;                             // <nowhere>
    char expand;                           // <nowhere>
    char _v16;                             // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    int size;                              // _cfa_ffffffdc
    int i;                                 // _cfa_ffffffd8
    int j;                                 // _cfa_ffffffd4
    int k;                                 // _cfa_ffffffd0
    int bcol;                              // _cfa_ffffffcc
    int ecol;                              // _cfa_ffffffc8
    int width;                             // _cfa_ffffffc4
    struct table_cell* cell;   // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    signed int _v72;                       // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    char* _v80;                            // _cfa_ffffffb0
    double w0;                             // _cfa_ffffffa4
    double w1;                             // _cfa_ffffff9c
    double w;                              // _cfa_ffffff94
    double s;                              // _cfa_ffffff8c
    double b;                              // _cfa_ffffff84
    struct table* _v128;   // _cfa_ffffff80
    _unknown_ _v130;                       // _cfa_ffffff7e
    short _v132;                           // _cfa_ffffff7c
    int _v136;                             // _cfa_ffffff78
    short _v138;                           // _cfa_ffffff76
    struct table** _v144;   // _cfa_ffffff70
    signed int _v148;                      // _cfa_ffffff6c
    signed int _v152;                      // _cfa_ffffff68
    signed int _v156;                      // _cfa_ffffff64
    signed int _v160;                      // _cfa_ffffff60
    signed char _v164;                     // _cfa_ffffff5c
    signed int _v168;                      // _cfa_ffffff58
    signed int _v172;                      // _cfa_ffffff54
    signed int _v176;                      // _cfa_ffffff50
    signed char _v180;                     // _cfa_ffffff4c
    signed int _v184;                      // _cfa_ffffff48
    signed int _v188;                      // _cfa_ffffff44
    signed int _v192;                      // _cfa_ffffff40
    signed char _v196;                     // _cfa_ffffff3c
    char _v204;                            // _cfa_ffffff34
    double _v212;                          // _cfa_ffffff2c (outparam)
    _unknown_ _v216;                       // _cfa_ffffff28 (outparam)
    double _v220;                          // _cfa_ffffff24 (outparam)
    char* _v224;                           // _cfa_ffffff20 (outparam)
    signed int _v228;                      // _cfa_ffffff1c (outparam)
    int _v232;                             // _cfa_ffffff18 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t340;                      // _t340
    signed int _t355;                      // _t355
    signed int _t359;                      // _t359
    struct table_cell* _t383;   // _t383
    int _t422;                             // _t422
    struct table_cell* _t426;   // _t426
    signed int _t506;                      // _t506
    char* _t555;                           // _t555
    _unknown_ _t573;                       // _t573
    double _t578;                          // _t578
    double _t580;                          // _t580
    double _t587;                          // _t587
    double _t596;                          // _t596
    double _t601;                          // _t601

    _t578 = __fp0;
    __esp = __esp - 220;
    _v128 = t;
    _v32 =  *gs:0x14];
    _v144 = __esp;
    size = _v128->maxcol + 1;
    _v148 = size;
    _v68 = _v148 - 1;
    _v156 = _v148 & 255;
    _v152 = 0;
    _t340 = _v156;
    _v164 = _t340 << 6 & 255;
    _v160 = (_v152 << 32 | _t340) << 6 & 15;
    __esp = __esp - ((_v148 << 3) + 0x1e >> 4 << 4);
    _v72 =  &_v204 + 15 >> 4 << 4;
    _t506 = size;
    _v76 = _t506 - 1;
    _v172 = _t506 & 255;
    _v168 = 0;
    _t355 = _v172;
    _v180 = _t355 << 3 & 255;
    _v176 = (_v168 << 32 | _t355) << 3 & 15;
    _v188 = _t506 & 255;
    _v184 = 0;
    _t359 = _v188;
    _v196 = _t359 << 3 & 255;
    _v192 = (_v184 << 32 | _t359) << 3 & 15;
    __esp = __esp - (_t506 + 0x1e >> 4 << 4);
    _v80 =  &_v204 + 15 >> 4 << 4;
    cell =  &(_v128->cell);
    asm("fldz");
    w0 = __fp0;
    i = 0;
    while(1) {
        _t573 = i - size;
        if(_t573 >= 0) {
            break;
        }
        weight( *(_v128->maxrow + (i + 40) * 2) & 65535);
         *((long long*)(_v72 + i * 8)) = _t578;
        _t578 = w0;
        asm("faddp st1, st0");
        w0 = _t578;
        i = i + 1;
        __eflags = i;
    }
    _t580 = w0;
    asm("fldz");
    asm("fucomip st0, st1");
    st0 = _t580;
    if(_t573 < 0) {
        asm("fld1");
        w0 = _t580;
    }
    if((cell->necell & 65535) != 0) {
        _v232 = size;
         *__esp = _v80;
        bzero();
        k = 0;
        while(1) {
            _t383 = cell;
            __eflags = (_t383->necell & 65535) - k;
            if((_t383->necell & 65535) <= k) {
                break;
            }
            j =  *(cell->col + (k + 56) * 2) & 65535;
            bcol =  *(cell + j * 2) & 65535;
            ecol = ( *(cell->col + (j + 16) * 2) & 65535) + bcol;
            width = ( *(cell->col + (j + 80) * 2) & 65535) + _v128->cellspacing * (1 - ( *(cell->col + (j + 16) * 2) & 65535));
            asm("fldz");
            w1 = _t580;
            i = bcol;
            while(1) {
                __eflags = i - ecol;
                if(i >= ecol) {
                    break;
                }
                _v138 =  *(_v128->maxrow + (i + 40) * 2) & 65535;
                asm("fild word [ebp-0x86]");
                asm("faddp st1, st0");
                _t580 = w1;
                asm("faddp st1, st0");
                w1 = _t580;
                _v80[i] = (_v80[i] & 255) + 1;
                i = i + 1;
                __eflags = i;
            }
            i = bcol;
            while(1) {
                __eflags = i - ecol;
                if(__eflags >= 0) {
                    break;
                }
                asm("fild dword [ebp-0x38]");
                _v138 =  *(_v128->maxrow + (i + 40) * 2) & 65535;
                asm("fild word [ebp-0x86]");
                asm("faddp st1, st0");
                asm("fmulp st1, st0");
                asm("fnstcw word [ebp-0x7e]");
                _v132 = 12;
                asm("fldcw word [ebp-0x80]");
                asm("fistp dword [ebp-0x84]");
                asm("fldcw word [ebp-0x7e]");
                weight(_v136);
                w =  *135050784 / w1;
                _t580 = w;
                asm("fucomip st0, st1");
                st0 = _t580;
                if(i != 0) {
                    _t580 = w;
                     *((long long*)(_v72 + i * 8)) = _t580;
                }
                i = i + 1;
                __eflags = i;
            }
            k = k + 1;
            __eflags = k;
        }
        asm("fldz");
        w0 = _t580;
        asm("fldz");
        w1 = _t580;
        i = 0;
        while(1) {
            __eflags = i - size;
            if(__eflags >= 0) {
                break;
            }
            asm("faddp st1, st0");
            w0 = w0;
            _t422 = i;
            _t555 = _v80;
            __eflags = _t555[_t422] & 255;
            if((_t555[_t422] & 255) == 0) {
                asm("faddp st1, st0");
                w1 = w1;
            }
            i = i + 1;
            __eflags = i;
        }
        _t587 = w0;
        asm("fldz");
        asm("fucomip st0, st1");
        st0 = _t587;
        if(__eflags != 0) {
            asm("fld1");
            w0 = _t587;
        }
        k = 0;
        while(1) {
            _t426 = cell;
            __eflags = (_t426->necell & 65535) - k;
            if((_t426->necell & 65535) <= k) {
                break;
            }
            j =  *(cell->col + (k + 56) * 2) & 65535;
            bcol =  *(cell + j * 2) & 65535;
            width = ( *(cell->col + (j + 80) * 2) & 65535) + _v128->cellspacing * (1 - ( *(cell->col + (j + 16) * 2) & 65535));
            weight(width);
            w = _t587;
            asm("fdivrp st1, st0");
            s = w;
            asm("fild dword [ebp+0xc]");
            asm("fnstcw word [ebp-0x7e]");
            _v132 = 12;
            asm("fldcw word [ebp-0x80]");
            asm("fistp dword [ebp-0x84]");
            asm("fldcw word [ebp-0x7e]");
            weight2(_v136);
            asm("fmulp st1, st0");
            b =  *135050792;
            _v212 = b;
            _t587 = s;
            _v220 = _t587;
            _v224 = _v80;
            _v228 =  *(cell->col + (j + 16) * 2) & 65535;
            _v232 = bcol;
             *__esp = _v128;
            correct_table_matrix4();
            k = k + 1;
            __eflags = k;
        }
        i = 0;
        while(1) {
            __eflags = i - size;
            if(i >= size) {
                goto L43;
            }
            __eflags = _v80[i] & 255;
            if(__eflags != 0) {
                _t596 = w0 - w1;
                asm("fld1");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                st0 = _t596;
                if(__eflags == 0) {
                    asm("fld1");
                } else {
                    _t596 = w0 - w1;
                }
                asm("fdivp st1, st0");
                s = _t596;
                weight2(maxwidth);
                asm("fmulp st1, st0");
                b =  *135050792;
            } else {
                _t601 = w1;
                asm("fld1");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                st0 = _t601;
                if(__eflags == 0) {
                    asm("fld1");
                } else {
                    _t601 = w1;
                }
                asm("fdivp st1, st0");
                s = _t601;
                asm("fild dword [ebp+0xc]");
                asm("fnstcw word [ebp-0x7e]");
                _v132 = 12;
                asm("fldcw word [ebp-0x80]");
                asm("fistp dword [ebp-0x84]");
                asm("fldcw word [ebp-0x7e]");
                weight2(_v136);
                asm("fmulp st1, st0");
                b =  *135050792;
            }
            correct_table_matrix3(_v128, i, _v80, s, b);
            i = i + 1;
            __eflags = i;
        }
    } else {
        i = 0;
        while(i < size) {
            s =  *(_v72 + i * 8) / w0;
            asm("fild dword [ebp+0xc]");
            asm("fnstcw word [ebp-0x7e]");
            _v132 = 12;
            asm("fldcw word [ebp-0x80]");
            asm("fistp dword [ebp-0x84]");
            asm("fldcw word [ebp-0x7e]");
            weight2(_v136);
            asm("fmulp st1, st0");
            b =  *135050792;
            correct_table_matrix2(_v128, i, 1, s, b);
            i = i + 1;
            __eflags = i;
        }
    }
L43:
    __esp = _v144;
    if((_v32 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
    }
    __esp =  &_v16;
    __esp =  &_v16;
}

void check_relative_width(struct table* t, int maxwidth)
{// addr = 0x080899B4  --  defined in 'table.c' at line 3483
    int i;                                 // _cfa_fffffff0
    int size;                              // _cfa_ffffffec
    double* rcolwidth;                     // _cfa_ffffffe8
    struct table_cell* cell;   // _cfa_ffffffe4
    int n_leftcol;                         // _cfa_ffffffe0
    int j;                                 // _cfa_ffffffdc
    int k;                                 // _cfa_ffffffd8
    int n_leftcell;                        // _cfa_ffffffd4
    int j;                                 // _cfa_ffffffd0
    int k;                                 // _cfa_ffffffcc
    double rel_total;                      // _cfa_ffffffc4
    double w;                              // _cfa_ffffffbc
    double r;                              // _cfa_ffffffb4
    double r;                              // _cfa_ffffffac
    _unknown_ _v94;                        // _cfa_ffffffa2
    short _v96;                            // _cfa_ffffffa0
    signed int _v98;                       // _cfa_ffffff9e
    intOrPtr _v104;                        // _cfa_ffffff98
    double* _t234;                         // _t234
    _unknown_ _t242;                       // _t242
    _unknown_ _t244;                       // _t244
    struct table_cell* _t255;   // _t255
    struct table_cell* _t275;   // _t275
    int _t281;                             // _t281
    int _t285;                             // _t285
    struct table* _t308;   // _t308
    struct table_cell* _t319;   // _t319
    struct table_cell* _t324;   // _t324
    signed int _t336;                      // _t336
    signed int _t338;                      // _t338
    signed int _t340;                      // _t340
    _unknown_ _t348;                       // _t348
    _unknown_ _t350;                       // _t350
    signed int _t352;                      // _t352
    signed int _t357;                      // _t357
    signed int _t359;                      // _t359
    signed int _t362;                      // _t362
    signed int _t374;                      // _t374
    int _t391;                             // _t391
    _unknown_ _t392;                       // _t392
    double _t397;                          // _t397
    double _t401;                          // _t401
    double _t408;                          // _t408
    signed long long _t411;                // _t411

    _t397 = __fp0;
    asm("fldz");
    rel_total = __fp0;
    size = t->maxcol.col + 1;
    _t234 = size << 3;
     *__esp = _t234;
    GC_malloc();
    rcolwidth = _t234;
    cell =  &(t->cell);
    n_leftcol = 0;
    i = 0;
    goto L2;
    do {
    } while();
    do {
        goto L10;
    } while(i < size);
    i = 0;
    while((cell->maxcell & 65535) >= i) {
        _t255 = cell;
        _t352 = i + 120;
        __eflags =  *(_t255->col + _t352 * 2) & 65535;
        if(( *(_t255->col + _t352 * 2) & 65535) >= 0) {
L31:
            i = i + 1;
            __eflags = i;
            continue;
        }
        _v98 =  *(cell->col + (i + 120) * 2) & 65535;
        asm("fild word [ebp-0x5e]");
        _t408 =  *135050800;
        asm("fdivp st1, st0");
        w = _t408;
        n_leftcell = 0;
        k =  *(cell + i * 2) & 65535;
        asm("fldz");
        r = _t408;
        j = 0;
        while(1) {
            __eflags = ( *(cell->col + (i + 16) * 2) & 65535) - j;
            if(__eflags <= 0) {
                break;
            }
            asm("fldz");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            st0 = rcolwidth[j + k];
            if(i == 0) {
                n_leftcell = n_leftcell + 1;
                __eflags = n_leftcell;
            } else {
                asm("faddp st1, st0");
                r = r;
            }
            j = j + 1;
            __eflags = j;
        }
        __eflags = n_leftcell;
        if(__eflags != 0) {
            _t411 = r;
            asm("fucomip st0, st1");
            st0 = _t411;
            if(__eflags != 0) {
                _v98 =  *(cell->col + (i + 16) * 2) & 65535;
                asm("fild word [ebp-0x5e]");
                _v104 = ( *(cell->col + (i + 16) * 2) & 65535) - n_leftcell;
                asm("fild dword [ebp-0x64]");
                asm("fdivp st1, st0");
                w = _t411 * r;
                asm("fmulp st1, st0");
                asm("fnstcw word [ebp-0x5a]");
                _v96 = 12;
                asm("fldcw word [ebp-0x5c]");
                asm("fistp word [ebp-0x5e]");
                asm("fldcw word [ebp-0x5a]");
                _t340 = i + 120;
                __eflags = _t340;
                 *((short*)(cell->col + _t340 * 2)) = _v98 & 65535;
            }
            j = 0;
            while(1) {
                _t275 = cell;
                _t374 = i + 16;
                __eflags = ( *(_t275->col + _t374 * 2) & 65535) - j;
                if(( *(_t275->col + _t374 * 2) & 65535) <= j) {
                    goto L31;
                }
                _t281 =  &(rcolwidth[j + k]);
                __eflags = _t281;
                asm("fldz");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                st0 =  *_t281;
                if(__eflags == 0 && __eflags == 0) {
                    _t285 =  &(rcolwidth[j + k]);
                    __eflags = _t285;
                    asm("fild dword [ebp-0x28]");
                    asm("fdivp st1, st0");
                     *_t285 = w - r;
                }
                j = j + 1;
                __eflags = j;
            }
            goto L31;
        }
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        st0 = r;
        if(__eflags != 0 || __eflags != 0) {
            asm("fmulp st1, st0");
            asm("fnstcw word [ebp-0x5a]");
            _v96 = 12;
            asm("fldcw word [ebp-0x5c]");
            asm("fistp word [ebp-0x5e]");
            asm("fldcw word [ebp-0x5a]");
             *(cell->col + (i + 120) * 2) = _v98 & 65535;
        }
        goto L31;
    }
    i = 0;
    while(i < size) {
        asm("faddp st1, st0");
        rel_total = rel_total;
        i = i + 1;
        __eflags = i;
    }
    _t391 = n_leftcol;
    if(_t391 != 0) {
L38:
        _t401 =  *135050808;
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        st0 = _t401;
        if(_t392 > 0) {
L55:
            return;
        }
L39:
        i = 0;
        while(i < size) {
            _t401 = rcolwidth[i] / rel_total;
            rcolwidth[i] = _t401;
            i = i + 1;
            __eflags = i;
        }
        i = 0;
        while(i < size) {
            _t308 = t;
            _t357 = i + 144;
            __eflags =  *(_t308 + _t357 * 2) & 65535;
            if(( *(_t308 + _t357 * 2) & 65535) < 0) {
                _t401 =  *135050800;
                asm("fmulp st1, st0");
                asm("fnstcw word [ebp-0x5a]");
                _v96 = 12;
                asm("fldcw word [ebp-0x5c]");
                asm("fistp word [ebp-0x5e]");
                asm("fldcw word [ebp-0x5a]");
                _t338 = i + 144;
                __eflags = _t338;
                 *((short*)(t + _t338 * 2)) = _v98 & 65535;
            }
            i = i + 1;
            __eflags = i;
        }
        i = 0;
        while((cell->maxcell & 65535) >= i) {
            _t319 = cell;
            _t359 = i + 120;
            __eflags =  *(_t319->col + _t359 * 2) & 65535;
            if(( *(_t319->col + _t359 * 2) & 65535) >= 0) {
L53:
                i = i + 1;
                __eflags = i;
                continue;
            }
            k =  *(cell + i * 2) & 65535;
            asm("fldz");
            r = _t401;
            j = 0;
            while(1) {
                _t324 = cell;
                _t362 = i + 16;
                __eflags = ( *(_t324->col + _t362 * 2) & 65535) - j;
                if(( *(_t324->col + _t362 * 2) & 65535) <= j) {
                    break;
                }
                asm("faddp st1, st0");
                r = r;
                j = j + 1;
                __eflags = j;
            }
            _t401 =  *135050800;
            asm("fmulp st1, st0");
            asm("fnstcw word [ebp-0x5a]");
            _v96 = 12;
            asm("fldcw word [ebp-0x5c]");
            asm("fistp word [ebp-0x5e]");
            asm("fldcw word [ebp-0x5a]");
            _t336 = i + 120;
            __eflags = _t336;
             *((short*)(cell->col + _t336 * 2)) = _v98 & 65535;
            goto L53;
        }
        goto L55;
    }
    _t401 =  *135050744;
    asm("fucomip st0, st1");
    st0 = _t401;
    _t392 = _t391 > 0;
    if(_t392 != 0) {
        goto L39;
    }
    goto L38;
L2:
    if(i < size) {
        asm("fldz");
        rcolwidth[i] = _t397;
        i = i + 1;
        __eflags = i;
        goto L2;
    } else {
        i = 0;
    }
L10:
}

void set_table_matrix(struct table* t, int width)
{// addr = 0x08089E51  --  defined in 'table.c' at line 3566
    int size;                              // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    int a;                                 // _cfa_ffffffe4
    struct table_cell* cell;   // _cfa_ffffffe0
    double b;                              // _cfa_ffffffd4
    double s;                              // _cfa_ffffffcc
    short _v62;                            // _cfa_ffffffc2
    _unknown_ _v64;                        // _cfa_ffffffc0
    short _v66;                            // _cfa_ffffffbe
    int _v72;                              // _cfa_ffffffb8
    double _v88;                           // _cfa_ffffffa8 (outparam)
    _unknown_ _v92;                        // _cfa_ffffffa4 (outparam)
    double _v96;                           // _cfa_ffffffa0 (outparam)
    signed int _v100;                      // _cfa_ffffff9c (outparam)
    signed int _v104;                      // _cfa_ffffff98 (outparam)
    signed int _t223;                      // _t223
    signed int _t251;                      // _t251
    signed int _t299;                      // _t299
    signed int _t307;                      // _t307
    double _t313;                          // _t313

    size = t->maxcol + 1;
    cell =  &(t->cell);
    if(size <= 0) {
        return;
    }
    t->matrix = new_matrix(size);
    t->vector = new_vector(size);
    i = 0;
    while(i < size) {
        j = i;
        while(j < size) {
            asm("fldz");
             *(t->matrix->me + (t->matrix->dim * i + j << 3)) = _t313;
            j = j + 1;
        }
        asm("fldz");
        t->vector->ve[i] = _t313;
        i = i + 1;
    }
    check_relative_width(t, width);
    i = 0;
    while(i < size) {
        if(( *(t + (i + 144) * 2) & 65535) <= 0) {
            if(( *(t + (i + 144) * 2) & 65535) < 0) {
                _v62 =  *(t + (i + 144) * 2) & 65535;
                asm("fild word [ebp-0x3a]");
                asm("fdivp st1, st0");
                s =  *135050800;
                asm("fild dword [ebp+0xc]");
                asm("fnstcw word [ebp-0x3c]");
                _v66 = 12;
                asm("fldcw word [ebp-0x3e]");
                asm("fistp dword [ebp-0x44]");
                asm("fldcw word [ebp-0x3c]");
                weight2(_v72);
                asm("fmulp st1, st0");
                b =  *135050696;
                _v88 = b;
                _t313 = s;
                _v96 = _t313;
                _v100 = 1;
                _v104 = i;
                 *__esp = t;
                correct_table_matrix2();
            }
        } else {
            _t307 =  *(t->maxcol + (i + 88) * 2) & 65535;
            _t223 =  *(t + (i + 144) * 2) & 65535;
            _t224 = _t307 - _t223 >= 0 ? _t307 : _t223;
            _t225 = _t307 - _t223 >= 0 ? _t307 : _t223;
            a = _t307 - _t223 >= 0 ? _t307 : _t223;
            weight2(a);
            asm("fmulp st1, st0");
            b =  *135050696;
            _t313 = b;
            correct_table_matrix(t, i, 1, a, _t313);
        }
        i = i + 1;
    }
    j = 0;
    while((cell->maxcell & 65535) >= j) {
        if(( *(cell->col + (j + 120) * 2) & 65535) <= 0) {
            if(( *(cell->col + (j + 120) * 2) & 65535) < 0) {
                _v62 =  *(cell->col + (j + 120) * 2) & 65535;
                asm("fild word [ebp-0x3a]");
                asm("fdivp st1, st0");
                s =  *135050800;
                asm("fild dword [ebp+0xc]");
                asm("fnstcw word [ebp-0x3c]");
                _v66 = 12;
                asm("fldcw word [ebp-0x3e]");
                asm("fistp dword [ebp-0x44]");
                asm("fldcw word [ebp-0x3c]");
                weight2(_v72);
                asm("fmulp st1, st0");
                b =  *135050696;
                _v88 = b;
                _t313 = s;
                _v96 = _t313;
                _v100 =  *(cell->col + (j + 16) * 2) & 65535;
                _v104 =  *(cell + j * 2) & 65535;
                 *__esp = t;
                correct_table_matrix2();
            }
        } else {
            _t299 =  *(cell->col + (j + 96) * 2) & 65535;
            _t251 =  *(cell->col + (j + 120) * 2) & 65535;
            _t252 = _t299 - _t251 >= 0 ? _t299 : _t251;
            _t253 = _t299 - _t251 >= 0 ? _t299 : _t251;
            a = _t299 - _t251 >= 0 ? _t299 : _t251;
            weight2(a);
            asm("fmulp st1, st0");
            b =  *135050696;
            _t313 = b;
            correct_table_matrix(t,  *(cell + j * 2) & 65535,  *(cell->col + (j + 16) * 2) & 65535, a, _t313);
        }
        j = j + 1;
    }
    set_table_matrix0(t, width);
    if(t->total_width <= 0) {
        weight2(width);
        b = _t313 + st0;
    } else {
        weight2(width);
        asm("fmulp st1, st0");
        b =  *135050816;
    }
    correct_table_matrix(t, 0, size, width, b);
}

void writeLocalCookie()
{// addr = 0x0808A210  --  defined in 'local.c' at line 31
    FILE* f;              // _cfa_fffffff0
    FILE* _v32;           // _cfa_ffffffe0
    int _v36;                              // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    FILE* _t18;           // _t18

    if(no_rc_dir != 0) {
        return;
    }
    if(Local_cookie_file != 0) {
        return;
    }
    Local_cookie_file =  *(tmpfname(4, 0));
    set_environ("LOCAL_COOKIE_FILE", Local_cookie_file);
    _t18 = Local_cookie_file;
    _v40 = "wb";
     *__esp = _t18;
    fopen();
    f = _t18;
    if(f != 0) {
        localCookie();
        _v32 = f;
        _v36 = Local_cookie->length;
        _v40 = 1;
         *__esp = Local_cookie->ptr;
        fwrite();
         *__esp = f;
        fclose();
        _v40 = 384;
         *__esp = Local_cookie_file;
        chmod();
        return;
    }
}

Str localCookie()
{// addr = 0x0808A2DB  --  defined in 'local.c' at line 52
    signed int _v16;                       // _cfa_fffffff0
    char[255] hostname;                    // _cfa_fffffef0
    char[255]* _v292;                      // _cfa_fffffedc
    char[255]* _v296;                      // _cfa_fffffed8
    char[255]* _t13;                       // _t13
    struct _Str* _t15;    // _t15

    _v16 =  *gs:0x14];
    if(Local_cookie == 0) {
        _v296 = 256;
         *__esp =  &hostname;
        gethostname();
         *__esp = 1;
        GC_malloc();
         *__esp = 0;
        time();
        _t13 =  &hostname +  &hostname;
         *__esp = _t13;
        srand48();
        lrand48();
        _v292 =  &hostname;
        _v296 = _t13;
        Local_cookie = Sprintf("%ld%s");
        _t15 = Local_cookie;
    } else {
        _t15 = Local_cookie;
    }
    if((_v16 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return _t15;
    }
    return _t15;
}

Str loadLocalDir(char* dname)
{// addr = 0x0808A37E  --  defined in 'local.c' at line 65
    signed int _v16;                       // _cfa_fffffff0
    char[1023] lbuf;                       // _cfa_fffffbf0
    Str tmp;               // _cfa_fffffbec
    DIR* d;                // _cfa_fffffbe8
    Directory* dir;   // _cfa_fffffbe4
    char** flist;                          // _cfa_fffffbe0
    char* p;                               // _cfa_fffffbdc
    char* qdir;                            // _cfa_fffffbd8
    Str fbuf;              // _cfa_fffffbd4
    int i;                                 // _cfa_fffffbd0
    int l;                                 // _cfa_fffffbcc
    int nrow;                              // _cfa_fffffbc8
    int n;                                 // _cfa_fffffbc4
    int maxlen;                            // _cfa_fffffbc0
    int nfile;                             // _cfa_fffffbbc
    int nfile_max;                         // _cfa_fffffbb8
    Str dirname;           // _cfa_fffffbb4
    _unknown_ _v1172;                      // _cfa_fffffb6c
    struct stat st;       // _cfa_fffffb5c
    _unknown_ _v1260;                      // _cfa_fffffb14
    struct stat lst;      // _cfa_fffffb04
    char* _v1280;                          // _cfa_fffffb00
    signed int _v1296;                     // _cfa_fffffaf0
    struct _Str* _v1312;   // _cfa_fffffae0
    char* _v1316;                          // _cfa_fffffadc
    char* _v1320;                          // _cfa_fffffad8
    char* _v1324;                          // _cfa_fffffad4
    struct _Str* _v1328;   // _cfa_fffffad0
    char* _v1332;                          // _cfa_fffffacc (outparam)
    char* _v1336;                          // _cfa_fffffac8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    DIR* _t271;            // _t271
    int _t282;                             // _t282
    char* _t296;                           // _t296
    char** _t299;                          // _t299
    Directory* _t300;   // _t300
    _unknown_ _t309;                       // _t309
    _unknown_ _t314;                       // _t314
    char* _t323;                           // _t323
    int _t334;                             // _t334
    char* _t356;                           // _t356
    char* _t364;                           // _t364
    int _t374;                             // _t374
    char* _t380;                           // _t380
    int _t390;                             // _t390
    int _t407;                             // _t407
    int _t420;                             // _t420
    struct _Str* _t439;   // _t439

    _v1280 = dname;
    _v16 =  *gs:0x14];
    fbuf = Strnew();
    nrow = 0;
    n = 0;
    maxlen = 0;
    nfile_max = 100;
    _t271 = _v1280;
     *__esp = _t271;
    opendir();
    d = _t271;
    if(d != 0) {
        dirname = Strnew_charp(_v1280);
        if(dirname->length <= 0 || ( *(dirname->ptr + dirname->length - 1) & 255) != 47) {
            if(dirname->length + 1 >= dirname->area_size) {
                Strgrow(dirname);
            }
            _t282 = dirname->length;
             *((char*)(dirname->ptr + _t282)) = 47;
            dirname->length = _t282 + 1;
             *((char*)(dirname->ptr + dirname->length)) = 0;
        }
        qdir = html_quote( *(wc_Str_conv(dirname, SystemCharset, InnerCharset)));
        _t296 = html_quote(file_quote(dirname->ptr));
        _v1312 = 0;
        _v1316 = "</H1>\n";
        _v1320 = qdir;
        _v1324 = "</TITLE>\n</HEAD>\n<BODY>\n<H1>Directory list of ";
        _v1328 = qdir;
        _v1332 = "">\n<TITLE>Directory list of ";
        _v1336 = _t296;
        tmp = Strnew_m_charp("<HTML>\n<HEAD>\n<BASE HREF="file://");
        _t299 = nfile_max << 2;
         *__esp = _t299;
        GC_malloc();
        flist = _t299;
        nfile = 0;
        do {
            _t300 = d;
             *__esp = _t300;
            readdir();
            dir = _t300;
        } while(dir != 0);
        if(multicolList != 0) {
            _v1296 = maxlen + 2;
            l = COLS / _v1296;
            if(l == 0) {
                l = 1;
            }
            nrow = (n + l - 1) / l;
            n = 1;
            Strcat_charp(tmp, "<TABLE CELLPADDING=0>\n<TR VALIGN=TOP>\n");
        }
        _v1328 = strCmp;
        _v1332 = 4;
        _v1336 = nfile;
         *__esp = flist;
        qsort();
        i = 0;
        while(i < nfile) {
            p = flist[i];
            _v1336 = 135051011;
            _t323 = p;
             *__esp = _t323;
            strcmp();
            if(_t323 != 0) {
                Strcopy(fbuf, dirname);
                if(fbuf->length <= 0 || ( *(fbuf->ptr + fbuf->length - 1) & 255) != 47) {
                    if(fbuf->length + 1 >= fbuf->area_size) {
                        Strgrow(fbuf);
                    }
                    _t334 = fbuf->length;
                     *((char*)(fbuf->ptr + _t334)) = 47;
                    fbuf->length = _t334 + 1;
                     *((char*)(fbuf->ptr + fbuf->length)) = 0;
                }
                Strcat_charp(fbuf, p);
                if(__lstat(fbuf->ptr,  &(lst.st_dev)) >= 0) {
                    if(__stat(fbuf->ptr,  &(st.st_dev)) >= 0) {
                        if(multicolList == 0) {
                            if((lst.st_mode & 61440) != 40960) {
                                if((st.st_mode & 61440) != 16384) {
                                    Strcat_charp(tmp, "[FILE] ");
                                } else {
                                    Strcat_charp(tmp, "[DIR]&nbsp; ");
                                }
                            } else {
                                Strcat_charp(tmp, "[LINK] ");
                            }
                        } else {
                            if(n == 1) {
                                Strcat_charp(tmp, "<TD><NOBR>");
                            }
                        }
                        _t356 = html_quote(file_quote(p));
                        _v1328 = 0;
                        _v1332 = _t356;
                        _v1336 = "<A HREF="";
                        Strcat_m_charp(tmp);
                        if((st.st_mode & 61440) == 16384) {
                            if(tmp->length + 1 >= tmp->area_size) {
                                Strgrow(tmp);
                            }
                            _t420 = tmp->length;
                             *((char*)(tmp->ptr + _t420)) = 47;
                            tmp->length = _t420 + 1;
                             *((char*)(tmp->ptr + tmp->length)) = 0;
                        }
                        _t364 = html_quote( *(wc_Str_conv(Strnew_charp(p), SystemCharset, InnerCharset)));
                        _v1328 = 0;
                        _v1332 = _t364;
                        _v1336 = "">";
                        Strcat_m_charp(tmp);
                        if((st.st_mode & 61440) == 16384) {
                            if(tmp->length + 1 >= tmp->area_size) {
                                Strgrow(tmp);
                            }
                            _t407 = tmp->length;
                             *((char*)(tmp->ptr + _t407)) = 47;
                            tmp->length = _t407 + 1;
                             *((char*)(tmp->ptr + tmp->length)) = 0;
                        }
                        Strcat_charp(tmp, "</A>");
                        if(multicolList == 0) {
                            if((lst.st_mode & 61440) == 40960) {
                                _t374 = fbuf->ptr;
                                _v1332 = 1024;
                                _v1336 =  &lbuf;
                                 *__esp = _t374;
                                readlink();
                                l = _t374;
                                if(l > 0) {
                                     *((char*)(__ebp + l - 1036)) = 0;
                                    _t380 = html_quote( *(wc_Str_conv(Strnew_charp( &lbuf), SystemCharset, InnerCharset)));
                                    _v1328 = 0;
                                    _v1332 = _t380;
                                    _v1336 = " -> ";
                                    Strcat_m_charp(tmp);
                                    if((st.st_mode & 61440) == 16384) {
                                        if(tmp->length + 1 >= tmp->area_size) {
                                            Strgrow(tmp);
                                        }
                                        _t390 = tmp->length;
                                         *((char*)(tmp->ptr + _t390)) = 47;
                                        tmp->length = _t390 + 1;
                                         *((char*)(tmp->ptr + tmp->length)) = 0;
                                    }
                                }
                            }
                            Strcat_charp(tmp, "<br>\n");
                        } else {
                            n = n + 1;
                            if(n == nrow) {
                                Strcat_charp(tmp, "<BR>\n");
                            } else {
                                Strcat_charp(tmp, "</NOBR></TD>\n");
                                n = 1;
                            }
                        }
                    }
                }
            }
            i = i + 1;
        }
        if(multicolList != 0) {
            Strcat_charp(tmp, "</TR>\n</TABLE>\n");
        }
        Strcat_charp(tmp, "</BODY>\n</HTML>\n");
        _t439 = tmp;
        goto L63;
    } else {
        _t439 = 0;
L63:
        if((_v16 ^  *gs:0x14]) == 0) {
            return _t439;
        }
        __stack_chk_fail();
        return _t439;
    }
}

int check_local_cgi(char* file, int status)
{// addr = 0x0808AC49  --  defined in 'local.c' at line 191
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ _v76;                        // _cfa_ffffffb4
    _unknown_ _v84;                        // _cfa_ffffffac
    struct stat st;       // _cfa_ffffff9c
    _unknown_ _v120;                       // _cfa_ffffff88 (outparam)
    _unknown_ __ebx;                       // r1
    signed int _t15;                       // _t15

    if(status != 1 && status != 2) {
        return -1;
    }
    if(__stat(file,  &(st.st_dev)) >= 0) {
        _t15 = st.st_mode & 61440;
        if(_t15 != 16384) {
            geteuid();
            if(st.st_uid != _t15) {
L9:
                getegid();
                if(st.st_gid != _t15 || (st.st_mode & 8) == 0) {
                    if((st.st_mode & 1) == 0) {
                        return -1;
                    }
                    goto L12;
                } else {
L12:
                    return 0;
                }
            }
            _t15 = st.st_mode & 64;
            if(_t15 != 0) {
                goto L12;
            }
            goto L9;
        }
        return -1;
    }
    return -1;
}

void set_environ(char* var, char* value)
{// addr = 0x0808ACDE  --  defined in 'local.c' at line 209
    intOrPtr _v20;                         // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8

    if(var == 0 || value == 0) {
        return;
    } else {
        _v20 = 1;
        _v24 = value;
         *__esp = var;
        setenv();
        return;
    }
}

void set_cgi_environ(char* name, char* fn, char* req_uri)
{// addr = 0x0808AD0C  --  defined in 'local.c' at line 261
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    set_environ("SERVER_SOFTWARE", w3m_version);
    set_environ("SERVER_PROTOCOL", "HTTP/1.0");
    set_environ("SERVER_NAME", "localhost");
    set_environ("SERVER_PORT", "80");
    set_environ("REMOTE_HOST", "localhost");
    set_environ("REMOTE_ADDR", "127.0.0.1");
    set_environ("GATEWAY_INTERFACE", "CGI/1.1");
    set_environ("SCRIPT_NAME", name);
    set_environ("SCRIPT_FILENAME", fn);
    set_environ("REQUEST_URI", req_uri);
}

Str checkPath(char* fn, char* path)
{// addr = 0x0808ADDA  --  defined in 'local.c' at line 277
    char* p;                               // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    struct stat st;       // _cfa_ffffff94
    intOrPtr _v120;                        // _cfa_ffffff88 (outparam)
    char* _t50;                            // _t50
    char* _t51;                            // _t51
    int _t62;                              // _t62

    while(( *path & 255) != 0) {
        _v120 = 58;
        _t50 = path;
         *__esp = _t50;
        strchr();
        p = _t50;
        if(p == 0) {
            _t51 = path;
        } else {
            _t51 = allocStr(path, p - path);
        }
        tmp = Strnew_charp(expandPath(_t51));
        if(tmp->length <= 0 || ( *(tmp->ptr + tmp->length - 1) & 255) != 47) {
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t62 = tmp->length;
             *((char*)(tmp->ptr + _t62)) = 47;
            tmp->length = _t62 + 1;
             *((char*)(tmp->ptr + tmp->length)) = 0;
        }
        Strcat_charp(tmp, fn);
        if(__stat(tmp->ptr,  &(st.st_dev)) != 0) {
            if(p == 0) {
L18:
                return 0;
            }
            path =  &(p[1]);
            while(( *path & 255) == 58) {
                path =  &(path[1]);
            }
            continue;
        } else {
            return tmp;
        }
    }
    goto L18;
}

int cgi_filename(char* uri, char** fn, char** name, char** path_info)
{// addr = 0x0808AF07  --  defined in 'local.c' at line 300
    Str tmp;               // _cfa_fffffff0
    int offset;                            // _cfa_ffffffec
    Str tmp2;              // _cfa_ffffffe8
    int _v36;                              // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    int _t137;                             // _t137
    char* _t143;                           // _t143
    char* _t148;                           // _t148
    int _t163;                             // _t163
    char* _t176;                           // _t176
    char* _t183;                           // _t183
    char* _t216;                           // _t216
    char* _t218;                           // _t218

     *fn = uri;
     *name = uri;
     *path_info = 0;
    if(cgi_bin == 0) {
L7:
        tmp = Strnew_charp(w3m_lib_dir());
        if(tmp->length <= 0 || ( *(tmp->ptr + tmp->length - 1) & 255) != 47) {
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t137 = tmp->length;
             *((char*)(tmp->ptr + _t137)) = 47;
            tmp->length = _t137 + 1;
             *((char*)(tmp->ptr + tmp->length)) = 0;
        }
        _v36 = 6;
        _v40 = "/$LIB/";
        _t143 = uri;
         *__esp = _t143;
        strncmp();
        if(_t143 != 0) {
            _v36 = tmp->length;
            _v40 = tmp->ptr;
            _t148 = uri;
             *__esp = _t148;
            strncmp();
            if(_t148 != 0) {
                if(( *uri & 255) != 47 || document_root == 0) {
                    return 0;
                } else {
                    tmp2 = Strnew_charp(document_root);
                    if(tmp2->length <= 0 || ( *(tmp2->ptr + tmp2->length - 1) & 255) != 47) {
                        if(tmp2->length + 1 >= tmp2->area_size) {
                            Strgrow(tmp2);
                        }
                        _t163 = tmp2->length;
                         *((char*)(tmp2->ptr + _t163)) = 47;
                        tmp2->length = _t163 + 1;
                         *((char*)(tmp2->ptr + tmp2->length)) = 0;
                    }
                    Strcat_charp(tmp2,  &(uri[1]));
                    _t176 = tmp2->ptr;
                    _v36 = tmp->length;
                    _v40 = tmp->ptr;
                     *__esp = _t176;
                    strncmp();
                    if(_t176 == 0) {
                        uri = tmp2->ptr;
                         *name = uri;
                        offset = tmp->length;
                        goto L27;
                    } else {
                        return 0;
                    }
                }
            }
            offset = tmp->length;
            goto L27;
        } else {
            offset = 6;
L27:
            _t183 =  &(uri[offset]);
            _v40 = 47;
             *__esp = _t183;
            strchr();
             *path_info = _t183;
            if( *path_info != 0) {
                 *name = allocStr(uri,  *path_info - uri);
            }
            Strcat_charp(tmp,  &(( *name)[offset]));
             *fn = tmp->ptr;
            return 1;
        }
    }
    _v36 = 9;
    _v40 = "/cgi-bin/";
    _t216 = uri;
     *__esp = _t216;
    strncmp();
    if(_t216 != 0) {
        goto L7;
    } else {
        offset = 9;
        _t218 =  &(uri[offset]);
        _v40 = 47;
         *__esp = _t218;
        strchr();
         *path_info = _t218;
        if( *path_info != 0) {
             *name = allocStr(uri,  *path_info - uri);
        }
        tmp = checkPath( &(( *name)[offset]), cgi_bin);
        if(tmp != 0) {
             *fn = tmp->ptr;
            return 2;
        }
        return 0;
    }
}

FILE* localcgi_post(char* uri, char* qstr, FormList* request, char* referer)
{// addr = 0x0808B234  --  defined in 'local.c' at line 356
    FILE* fr;             // _cfa_fffffff0
    FILE* fw;             // _cfa_ffffffec
    int status;                            // _cfa_ffffffe8
    pid_t pid;           // _cfa_ffffffe4
    char* file;                            // _cfa_ffffffe0
    char* name;                            // _cfa_ffffffdc
    char* path_info;                       // _cfa_ffffffd8
    char* tmpf;                            // _cfa_ffffffd4
    FILE* _v60;           // _cfa_ffffffc4
    FILE* _v64;           // _cfa_ffffffc0 (outparam)
    char* _v68;                            // _cfa_ffffffbc (outparam)
    char* _v72;                            // _cfa_ffffffb8 (outparam)
    int _t120;                             // _t120
    char* _t123;                           // _t123
    char* _t129;                           // _t129
    FILE* _t130;          // _t130
    FILE* _t132;          // _t132
    FILE* _t166;          // _t166

    fr = 0;
    fw = 0;
    file = uri;
    name = uri;
    path_info = 0;
    tmpf = 0;
    status = cgi_filename(uri,  &file,  &name,  &path_info);
    if(check_local_cgi(file, status) < 0) {
        return 0;
    }
    writeLocalCookie();
    if(request == 0 || request->enctype == 1) {
L6:
        pid = open_pipe_rw( &fr, 0);
        if(pid >= 0) {
            if(pid == 0) {
                if(fw == 0) {
                    _t120 = -1;
                } else {
                    _t120 = fw;
                     *__esp = _t120;
                    fileno();
                }
                setup_child(1, 2, _t120);
                if(qstr != 0) {
                    _v64 = 0;
                    _v68 = qstr;
                    _v72 = 135051332;
                    uri =  *(Strnew_m_charp(uri));
                }
                set_cgi_environ(name, file, uri);
                if(path_info != 0) {
                    set_environ("PATH_INFO", path_info);
                }
                if(referer != 0 && referer != -1) {
                    set_environ("HTTP_REFERER", referer);
                }
                if(request == 0) {
                    set_environ("REQUEST_METHOD", "GET");
                    if(qstr == 0) {
                        _t123 = 135051494;
                    } else {
                        _t123 = qstr;
                    }
                    set_environ("QUERY_STRING", _t123);
                    _v68 = __imp__stdin;
                    _v72 = 135051454;
                     *__esp = "/dev/null";
                    freopen();
                } else {
                    set_environ("REQUEST_METHOD", "POST");
                    if(qstr != 0) {
                        set_environ("QUERY_STRING", qstr);
                    }
                    _v72 = request->length;
                    set_environ("CONTENT_LENGTH",  *(Sprintf("%d")));
                    if(request->enctype != 1) {
                        set_environ("CONTENT_TYPE", "application/x-www-form-urlencoded");
                        _v64 = fw;
                        _v68 = request->length;
                        _v72 = 1;
                         *__esp = request->body;
                        fwrite();
                         *__esp = fw;
                        fclose();
                        _v68 = __imp__stdin;
                        _v72 = 135051454;
                         *__esp = tmpf;
                        freopen();
                    } else {
                        _v72 = request->boundary;
                        set_environ("CONTENT_TYPE",  *(Sprintf("multipart/form-data; boundary=%s")));
                        _v68 = __imp__stdin;
                        _v72 = 135051454;
                         *__esp = request->body;
                        freopen();
                    }
                }
                 *__esp = mydirname(file);
                chdir();
                _t129 = mybasename(file);
                _v68 = 0;
                _v72 = _t129;
                 *__esp = file;
                execl();
                __errno_location();
                _t130 =  *_t129;
                 *__esp = _t130;
                strerror();
                _t132 = mybasename(file);
                _v60 = _t130;
                _v64 = _t132;
                _v68 = file;
                _v72 = "execl("%s", "%s", NULL): %s\n";
                 *__esp = __imp__stderr;
                fprintf();
                 *__esp = 1;
                exit();
                return _t132;
            }
            if(fw != 0) {
                 *__esp = fw;
                fclose();
            }
            return fr;
        }
        return 0;
    } else {
        tmpf =  *(tmpfname(0, 0));
        _t166 = tmpf;
        _v72 = 135051330;
         *__esp = _t166;
        fopen();
        fw = _t166;
        if(fw != 0) {
            goto L6;
        }
        return 0;
    }
}

struct form_list* newFormList(char* action, char* method, char* charset, char* enctype, char* target, char* name, struct form_list* _next)
{// addr = 0x0808B5F0  --  defined in 'form.c' at line 38
    struct form_list* l;   // _cfa_fffffff0
    Str a;                 // _cfa_ffffffec
    int m;                                 // _cfa_ffffffe8
    int e;                                 // _cfa_ffffffe4
    wc_ces c;           // _cfa_ffffffe0
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    char* _t61;                            // _t61

    _t61 = Strnew_charp(action);
    a = _t61;
    m = 0;
    e = 0;
    c = 0;
    if(method == 0) {
L2:
        m = 0;
L7:
        if(enctype != 0) {
            _v56 = "multipart/form-data";
            _t61 = enctype;
             *__esp = _t61;
            strcasecmp();
            if(_t61 == 0) {
                e = 1;
                if(m == 0) {
                    m = 1;
                }
            }
        }
        if(charset != 0) {
            _t61 = wc_guess_charset(charset, 0);
            c = _t61;
        }
         *__esp = 52;
        GC_malloc();
        l = _t61;
        l->lastitem = 0;
        l->item = l->lastitem;
        l->action = a;
        l->method = m;
        l->charset = c;
        l->enctype = e;
        l->target = target;
        l->name = name;
        l->next = _next;
        l->nitems = 0;
        l->body = 0;
        l->length = 0;
        return l;
    }
    _v56 = "get";
    _t61 = method;
     *__esp = _t61;
    strcasecmp();
    if(_t61 != 0) {
        _v56 = "post";
        _t61 = method;
         *__esp = _t61;
        strcasecmp();
        if(_t61 != 0) {
            _v56 = "internal";
            _t61 = method;
             *__esp = _t61;
            strcasecmp();
            if(_t61 == 0) {
                m = 2;
            }
        } else {
            m = 1;
        }
        goto L7;
    }
    goto L2;
}

struct form_item_list* formList_addInput(struct form_list* fl, struct parsed_tag* tag)
{// addr = 0x0808B750  --  defined in 'form.c' at line 89
    struct form_item_list* item;   // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    struct form_item_list* _t177;   // _t177
    int _t201;                             // _t201
    int _t206;                             // _t206
    int _t217;                             // _t217
    int _t266;                             // _t266

    if(fl == 0) {
        return 0;
    }
     *__esp = 72;
    GC_malloc();
    item = _t177;
    item->type = -1;
    item->size = -1;
    item->rows = 0;
    item->init_checked = 0;
    item->checked = item->init_checked;
    item->accept = 0;
    item->name = 0;
    item->init_value = 0;
    item->value = item->init_value;
    item->readonly = 0;
    if(parsedtag_get_value(tag, 33,  &p) != 0) {
        item->type = formtype(p);
        if(item->size < 0) {
            if(item->type == 0 || item->type == 11 || item->type == 1) {
                item->size = 40;
            }
        }
    }
    if(parsedtag_get_value(tag, 25,  &p) != 0) {
        item->name = Strnew_charp(p);
    }
    if(parsedtag_get_value(tag, 36,  &p) != 0) {
        item->init_value = Strnew_charp(p);
        item->value = item->init_value;
    }
    if(tag->map == 0 || (tag->map[0xc] & 255) == 75) {
L16:
        _t201 = 0;
        goto L17;
    } else {
        if((tag->attrid[tag->map[0xc] & 0xff] & 255) == 0) {
            goto L16;
        } else {
            _t201 = 1;
L17:
            item->init_checked = _t201;
            item->checked = item->init_checked;
            if(tag->map == 0 || (tag->map[1] & 255) == 75 || (tag->attrid[tag->map[1] & 0xff] & 255) == 0) {
                _t206 = 0;
            } else {
                _t206 = 1;
            }
            item->accept = _t206;
            parsedtag_get_value(tag, 30,  &(item->size));
            parsedtag_get_value(tag, 22,  &(item->maxlength));
            if(tag->map == 0 || (tag->map[0x2b] & 255) == 75 || (tag->attrid[tag->map[0x2b] & 0xff] & 255) == 0) {
                _t217 = 0;
            } else {
                _t217 = 1;
            }
            item->readonly = _t217;
            if(parsedtag_get_value(tag, 73,  &i) != 0) {
                item->init_value =  *(textarea_str + (i << 2));
                item->value = item->init_value;
            }
            if(parsedtag_get_value(tag, 72,  &i) != 0) {
                item->select_option =  *(select_option + (i << 3));
            }
            if(parsedtag_get_value(tag, 28,  &p) != 0) {
                _t266 = p;
                 *__esp = _t266;
                atoi();
                item->rows = _t266;
            }
            if(item->type != -1) {
                if(item->type == 8) {
                    chooseSelectOption(item, item->select_option);
                    item->init_selected = item->selected;
                    item->init_value = item->value;
                    item->init_label = item->label;
                }
                if(item->type != 11 || item->value == 0 || item->value->length == 0) {
                    item->parent = fl;
                    item->next = 0;
                    if(fl->item != 0) {
                        fl->lastitem->next = item;
                        fl->lastitem = item;
                    } else {
                        fl->lastitem = item;
                        fl->item = fl->lastitem;
                    }
                    if(item->type != 6) {
                        fl->nitems =  &(fl->nitems->type);
                        return item;
                    } else {
                        return 0;
                    }
                } else {
                    return 0;
                }
            } else {
                return 0;
            }
        }
    }
}

char* form2str(FormItemList* fi)
{// addr = 0x0808BB58  --  defined in 'form.c' at line 174
    Str tmp;               // _cfa_fffffff0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    struct _Str* _v44;    // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    struct _Str* _v52;    // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8 (outparam)

    tmp = Strnew();
    if(fi->type != 8) {
        if(fi->type != 9) {
            Strcat_charp(tmp, "input type=");
        }
    }
    Strcat_charp(tmp,  *( &_formtypetbl + fi->type * 4));
    if(fi->name != 0 && fi->name->length != 0) {
        _v44 = 0;
        _v48 = 135051732;
        _v52 =  *(fi->name);
        _v56 = " name="";
        Strcat_m_charp(tmp);
    }
    if(fi->type == 3 || fi->type == 2 || fi->type == 8) {
        if(fi->value != 0) {
            _v44 = 0;
            _v48 = 135051732;
            _v52 =  *(fi->value);
            _v56 = " value="";
            Strcat_m_charp(tmp);
        }
    }
    _v36 = 0;
    _v40 = 135051751;
    _v44 =  *(fi->parent->action);
    _v48 = 135051753;
    _v52 =  *((intOrPtr*)( &_formmethodtbl + fi->parent->method * 4));
    _v56 = 135051755;
    Strcat_m_charp(tmp);
    return tmp->ptr;
}

int formtype(char* typestr)
{// addr = 0x0808BC9A  --  defined in 'form.c' at line 192
    int i;                                 // _cfa_fffffff0
    intOrPtr _v40;                         // _cfa_ffffffd8
    char* _t17;                            // _t17

    i = 0;
    while( *((intOrPtr*)( &_formtypetbl + i * 4)) != 0) {
        _v40 =  *((intOrPtr*)( &_formtypetbl + i * 4));
        _t17 = typestr;
         *__esp = _t17;
        strcasecmp();
        if(_t17 != 0) {
            i = i + 1;
            continue;
        }
        return i;
    }
    return -1;
}

void formRecheckRadio(Anchor* a, Buffer* buf, FormItemList* fi)
{// addr = 0x0808BCE4  --  defined in 'form.c' at line 203
    int i;                                 // _cfa_fffffff0
    Anchor* a2;         // _cfa_ffffffec
    FormItemList* f2;   // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ _t62;                        // _t62

    i = 0;
    while(buf->formitem->nanchor > i) {
        i = i + 1;
    }
    fi->checked = 1;
    formUpdateBuffer(a, buf, fi);
}

void formResetBuffer(Buffer* buf, AnchorList* formitem)
{// addr = 0x0808BDC2  --  defined in 'form.c' at line 223
    int i;                                 // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    FormItemList* f1;   // _cfa_ffffffe8
    FormItemList* f2;   // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    struct _Str* _t123;   // _t123
    signed int _t125;                      // _t125
    signed int _t126;                      // _t126
    struct _Str* _t172;   // _t172

    if(buf == 0) {
        return;
    }
    if(buf->formitem == 0) {
        return;
    }
    if(formitem != 0) {
        i = 0;
        while(buf->formitem->nanchor > i) {
            if(formitem->nanchor > i) {
                a = buf->formitem->anchors + (i << 2 << 4) - (i << 2);
                if((a->y.line & 65535) != a->start.line) {
                    goto L24;
                } else {
                    f1 = a->url;
                    f2 =  *(formitem->anchors + (i << 2 << 4) - (i << 2));
                    if(f1->type == f2->type) {
                        if(f2->name == 0) {
                            _t172 = 135051758;
                        } else {
                            _t172 =  *(f2->name);
                        }
                        if(f1->name == 0) {
                            _t123 = 135051758;
                        } else {
                            _t123 =  *(f1->name);
                        }
                        _v40 = _t172;
                         *__esp = _t123;
                        strcmp();
                        if(_t123 == 0) {
                            _t125 = f1->type;
                            if(_t125 <= 11) {
                                _t126 = 1 << _t125;
                                if((_t126 & 2563) != 0) {
                                    f1->value = f2->value;
                                    f1->init_value = f2->init_value;
                                    goto L21;
                                } else {
                                    if((_t126 & 256) != 0) {
                                        f1->select_option = f2->select_option;
                                        f1->value = f2->value;
                                        f1->label = f2->label;
                                        f1->selected = f2->selected;
                                        f1->init_value = f2->init_value;
                                        f1->init_label = f2->init_label;
                                        f1->init_selected = f2->init_selected;
                                        goto L21;
                                    } else {
                                        if((_t126 & 12) != 0) {
                                            f1->checked = f2->checked;
                                            f1->init_checked = f2->init_checked;
L21:
                                            formUpdateBuffer(a, buf, f1);
                                        } else {
                                        }
                                    }
                                }
                            }
L24:
                            i = i + 1;
                            continue;
                        }
                    }
                }
                goto L31;
            } else {
                return;
            }
L32:
        }
    }
L31:
    return;
    goto L32;
}

int form_update_line(Line* line, char** str, int spos, int epos, int width, int newline, int password)
{// addr = 0x0808BFC3  --  defined in 'form.c' at line 273
    Lineprop c_type;   // _cfa_fffffff2
    Lineprop effect;   // _cfa_fffffff0
    int c_len;                             // _cfa_ffffffec
    int c_width;                           // _cfa_ffffffe8
    int w;                                 // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    int len;                               // _cfa_ffffffdc
    int pos;                               // _cfa_ffffffd8
    char* p;                               // _cfa_ffffffd4
    char* buf;                             // _cfa_ffffffd0
    Lineprop* prop;   // _cfa_ffffffcc
    int _v68;                              // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    char* _t255;                           // _t255
    Lineprop* _t257;   // _t257
    int _t325;                             // _t325
    char _t362;                            // _t362
    int _t390;                             // _t390
    char* _t452;                           // _t452

    c_len = 1;
    c_width = 1;
    p =  *str;
    w = 0;
    pos = 0;
    while(( *p & 255) != 0) {
        if(w < width) {
            c_type = ( *( &WTF_TYPE_MAP + ( *p & 0xff)) & 0xff) << 8;
            c_len =  *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff;
            if(( *135119023 & 255) == 0) {
                _t390 = ( *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 255) != 0 & 255;
            } else {
                _t390 =  *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 0xff;
            }
            c_width = _t390;
            if(c_type != 256) {
                if(password == 0) {
                    if((c_type & 0x1000) == 0) {
                        if(w + c_width > width) {
                            break;
                        }
                        w = w + c_width;
                        pos = pos + c_len;
L16:
                        p =  &(p[c_len]);
                        continue;
                    }
                    w = w + 1;
                    pos = pos + 1;
                    goto L16;
                }
                if(w + c_width > width) {
                    break;
                }
                w = w + c_width;
                pos = pos + c_width;
                goto L16;
            }
            if(newline == 0 || ( *p & 255) != 10) {
                if(( *p & 255) != 13) {
                    w = w + 1;
                    pos = pos + 1;
                }
                goto L16;
            } else {
                break;
            }
        }
        break;
    }
    pos = pos + width - w;
    len = line->len + pos + spos - epos;
    _t255 = len;
     *__esp = _t255;
    GC_malloc();
    buf = _t255;
    _t257 = len + len;
     *__esp = _t257;
    GC_malloc();
    prop = _t257;
    _v68 = spos;
    _v72 = buf;
     *__esp = line->lineBuf;
    bcopy();
    _v68 = spos + spos;
    _v72 = prop;
     *__esp = line->propBuf;
    bcopy();
    effect =  *(line->propBuf + spos + spos) & 0xc0;
    p =  *str;
    w = 0;
    pos = spos;
    while(( *p & 255) != 0) {
        if(w < width) {
            c_type = ( *( &WTF_TYPE_MAP + ( *p & 0xff)) & 0xff) << 8;
            c_len =  *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff;
            if(( *135119023 & 255) == 0) {
                _t325 = ( *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 255) != 0 & 255;
            } else {
                _t325 =  *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 0xff;
            }
            c_width = _t325;
            if(c_type != 256) {
                if(password == 0) {
                    if((c_type & 0x1000) == 0) {
                        if(w + c_width <= width) {
                            buf[pos] =  *p & 255;
                             *(prop + pos + pos) = c_type & 65535 | effect & 65535;
                            pos = pos + 1;
                            c_type = c_type & 0xf9 | 4;
                            i = 1;
                            while(i < c_len) {
                                buf[pos] = p[i] & 255;
                                 *(prop + pos + pos) = c_type & 65535 | effect & 65535;
                                pos = pos + 1;
                                i = i + 1;
                            }
                            w = w + c_width;
                            goto L51;
                        }
                        goto L55;
                    }
                    buf[pos] = 32;
                     *(prop + pos + pos) = effect & 65535;
                    pos = pos + 1;
                    w = w + 1;
                    goto L51;
                }
                if(w + c_width <= width) {
                    i = 0;
                    while(i < c_width) {
                        buf[pos] = 42;
                         *(prop + pos + pos) = effect & 65535;
                        pos = pos + 1;
                        w = w + 1;
                        i = i + 1;
                    }
                    goto L51;
                }
                goto L55;
            } else {
                if(newline == 0 || ( *p & 255) != 10) {
                    if(( *p & 255) != 13) {
                        _t452 =  &(buf[pos]);
                        if(password == 0) {
                            _t362 = 32;
                        } else {
                            _t362 = 42;
                        }
                         *_t452 = _t362;
                         *(prop + pos + pos) = effect & 65535;
                        pos = pos + 1;
                        w = w + 1;
                    }
L51:
                    p =  &(p[c_len]);
                    continue;
                } else {
L55:
L57:
                    while(w < width) {
                        buf[pos] = 32;
                         *(prop + pos + pos) = effect & 65535;
                        pos = pos + 1;
                        w = w + 1;
                    }
                    if(newline == 0) {
L69:
                         *str = p;
                        _v68 = line->len - epos;
                        _v72 =  &(buf[pos]);
                         *__esp = line->lineBuf + epos;
                        bcopy();
                        _v68 = line->len - epos + line->len - epos;
                        _v72 = prop + pos + pos;
                         *__esp = line->propBuf + epos + epos;
                        bcopy();
                        line->lineBuf = buf;
                        line->propBuf = prop;
                        line->len = len;
                        line->size = len;
                        return pos;
                    }
                    if(FoldTextarea != 0) {
L65:
                        if(( *p & 255) == 13) {
                            p =  &(p[1]);
                        }
                        if(( *p & 255) == 10) {
                            p =  &(p[1]);
                        }
                        goto L69;
                    }
                    while(( *p & 255) != 0 && ( *p & 255) != 13 && ( *p & 255) != 10) {
                        p =  &(p[1]);
                    }
                    goto L65;
                }
            }
        }
        goto L57;
    }
    goto L57;
}

void formUpdateBuffer(Anchor* a, Buffer* buf, FormItemList* form)
{// addr = 0x0808C4B8  --  defined in 'form.c' at line 412
    char* p;                               // _cfa_ffffffe0
    int spos;                              // _cfa_ffffffdc
    int epos;                              // _cfa_ffffffd8
    int rows;                              // _cfa_ffffffd4
    int c_rows;                            // _cfa_ffffffd0
    int pos;                               // _cfa_ffffffcc
    int col;                               // _cfa_ffffffc8
    Line* l;              // _cfa_ffffffc4
    int n;                                 // _cfa_ffffffc0
    Buffer save;        // _cfa_fffffebc
    _unknown_ _v340;                       // _cfa_fffffeac (outparam)
    _unknown_ _v344;                       // _cfa_fffffea8 (outparam)
    _unknown_ _v348;                       // _cfa_fffffea4 (outparam)
    _unknown_ _v352;                       // _cfa_fffffea0 (outparam)
    _unknown_ _v356;                       // _cfa_fffffe9c (outparam)
    _unknown_ _v360;                       // _cfa_fffffe98 (outparam)
    _unknown_ __ebx;                       // r1
    signed int _t206;                      // _t206
    signed int _t214;                      // _t214
    signed int _t218;                      // _t218
    int _t230;                             // _t230

    col = 0;
    copyBuffer( &save, buf);
    gotoLine(buf, a->start);
    _t206 = form->type;
    if(_t206 > 11 || (1 << _t206 & 2831) == 0) {
        spos = a->start.pos + 1;
        epos = a->end.pos - 1;
    } else {
        spos = a->start.pos;
        epos = a->end.pos;
    }
    _t214 = form->type;
    if(_t214 > 11) {
L40:
        copyBuffer(buf,  &save);
        arrangeLine(buf);
        return;
    } else {
        _t218 = 1 << _t214;
        if((_t218 & 2819) != 0) {
            if(form->type != 8) {
                p =  *(form->value);
            } else {
                p =  *(form->label);
                updateSelectOption(form, form->select_option);
            }
            l = buf->currentLine;
            if(form->type != 9) {
L26:
                if(form->rows == 0) {
                    _t230 = 1;
                } else {
                    _t230 = form->rows;
                }
                rows = _t230;
                col = calcPosition(l->lineBuf, l->propBuf, l->len, a->start.pos, 0, 0);
                c_rows = 0;
                while(c_rows < rows) {
                    if(rows <= 1) {
L33:
                        pos = form_update_line(l,  &p, spos, epos, calcPosition(l->lineBuf, l->propBuf, l->len, epos, 0, 0) - col, rows - 1 > 0 & 255, form->type == 1 & 255);
                        if(pos != epos) {
                            shiftAnchorPosition(buf->href, buf->hmarklist, a->start, spos, pos - epos);
                            shiftAnchorPosition(buf->name, buf->hmarklist, a->start, spos, pos - epos);
                            shiftAnchorPosition(buf->img, buf->hmarklist, a->start, spos, pos - epos);
                            shiftAnchorPosition(buf->formitem, buf->hmarklist, a->start, spos, pos - epos);
                        }
                        c_rows = c_rows + 1;
                        l = l->next;
                        continue;
                    }
                    pos = columnPos(l, col);
                    a = retrieveAnchor(buf->formitem, l->linenumber, pos);
                    if(a == 0) {
                        goto L40;
                    }
                    spos = a->start.pos;
                    epos = a->end.pos;
                    goto L33;
                }
                goto L40;
            } else {
                n = (a->y & 65535) - buf->currentLine->linenumber;
                if(n <= 0) {
                    if(n >= 0) {
L25:
                        if(l == 0) {
                            goto L40;
                        }
                        goto L26;
                    }
                    while(l != 0 && n != 0) {
                        l = l->prev;
                        n = n + 1;
                    }
                    goto L25;
                }
                while(l != 0) {
                    if(n != 0) {
                        l = l->prev;
                        n = n - 1;
                        continue;
                    }
                    goto L25;
                }
                goto L25;
            }
        }
        if((_t218 & 12) != 0) {
            if(form->checked == 0) {
                buf->currentLine->lineBuf[spos] = 32;
            } else {
                buf->currentLine->lineBuf[spos] = 42;
            }
        }
        goto L40;
    }
}

Str textfieldrep(Str s, int width)
{// addr = 0x0808C8CE  --  defined in 'form.c' at line 502
    Lineprop c_type;   // _cfa_fffffff2
    Str n;                 // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    int j;                                 // _cfa_ffffffe4
    int k;                                 // _cfa_ffffffe0
    int c_len;                             // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    signed int _t152;                      // _t152
    int _t184;                             // _t184
    int _t197;                             // _t197
    int _t211;                             // _t211

    n = Strnew_size(width + 2);
    j = 0;
    i = 0;
    while(s->length > i) {
        c_type = ( *( &WTF_TYPE_MAP + (s->ptr[i] & 0xff)) & 0xff) << 8;
        c_len =  *( &WTF_LEN_MAP + (s->ptr[i] & 0xff)) & 0xff;
        if((s->ptr[i] & 255) == 13) {
            goto L24;
        } else {
            if(( *135119023 & 255) == 0) {
                _t152 = ( *( &WTF_WIDTH_MAP + (s->ptr[i] & 0xff)) & 255) != 0 & 255;
            } else {
                _t152 =  *( &WTF_WIDTH_MAP + (s->ptr[i] & 0xff)) & 0xff;
            }
            k = _t152 + j;
            if(k <= width) {
                if(c_type != 256) {
                    if((c_type & 0x1000) == 0) {
                        if((s->ptr[i] & 255) != 38) {
                            if((s->ptr[i] & 255) != 60) {
                                if((s->ptr[i] & 255) != 62) {
                                    Strcat_charp_n(n,  &(s->ptr[i]), c_len);
                                } else {
                                    Strcat_charp(n, 135051770);
                                }
                            } else {
                                Strcat_charp(n, 135051765);
                            }
                        } else {
                            Strcat_charp(n, 135051759);
                        }
                    } else {
                        if(n->length + 1 >= n->area_size) {
                            Strgrow(n);
                        }
                        _t184 = n->length;
                         *((char*)(n->ptr + _t184)) = 32;
                        n->length = _t184 + 1;
                         *((char*)(n->ptr + n->length)) = 0;
                    }
                } else {
                    if(n->length + 1 >= n->area_size) {
                        Strgrow(n);
                    }
                    _t197 = n->length;
                     *((char*)(n->ptr + _t197)) = 32;
                    n->length = _t197 + 1;
                     *((char*)(n->ptr + n->length)) = 0;
                }
                j = k;
L24:
                i = i + c_len;
                continue;
            }
L30:
            while(j < width) {
                if(n->length + 1 >= n->area_size) {
                    Strgrow(n);
                }
                _t211 = n->length;
                 *((char*)(n->ptr + _t211)) = 32;
                n->length = _t211 + 1;
                 *((char*)(n->ptr + n->length)) = 0;
                j = j + 1;
            }
            return n;
        }
    }
    goto L30;
}

void form_fputs_decode(Str s, FILE* f)
{// addr = 0x0808CB78  --  defined in 'form.c' at line 539
    char* p;                               // _cfa_fffffff0
    Str z;                 // _cfa_ffffffec
    FILE* _v32;           // _cfa_ffffffe0
    int _v36;                              // _cfa_ffffffdc (outparam)
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    int _t53;                              // _t53

    z = Strnew();
    p = s->ptr;
    while(( *p & 255) != 0) {
        if(( *p & 255) == 13 && (p[1] & 255) == 10) {
            p =  &(p[1]);
        }
        if(z->length + 1 >= z->area_size) {
            Strgrow(z);
        }
        _t53 = z->length;
         *((char*)(z->ptr + _t53)) =  *p & 255;
        z->length = _t53 + 1;
         *((char*)(z->ptr + z->length)) = 0;
        p =  &(p[1]);
    }
    z = wc_Str_conv_strict(z, InnerCharset, DisplayCharset);
    _v32 = f;
    _v36 = z->length;
    _v40 = 1;
     *__esp = z->ptr;
    fwrite();
}

void input_textarea(FormItemList* fi)
{// addr = 0x0808CC57  --  defined in 'form.c' at line 567
    wc_uint8 auto_detect;   // _cfa_fffffff3
    char* tmpf;                            // _cfa_ffffffec
    Str tmp;               // _cfa_ffffffe8
    FILE* f;              // _cfa_ffffffe4
    wc_ces charset;     // _cfa_ffffffe0
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    intOrPtr _v72;                         // _cfa_ffffffb8 (outparam)
    FILE* _t71;           // _t71
    FILE* _t80;           // _t80

    tmpf =  *(tmpfname(0, 0));
    charset = DisplayCharset;
    _t71 = tmpf;
    _v72 = 135051775;
     *__esp = _t71;
    fopen();
    f = _t71;
    if(f == 0) {
        disp_err_message("Can't open temporary file", 0);
        return;
    }
    if(fi->value != 0) {
        form_fputs_decode(fi->value, f);
    }
     *__esp = f;
    fclose();
    fmTerm();
     *__esp =  *(myEditor(Editor, tmpf, 1));
    system();
    fmInit();
    if(fi->readonly != 0) {
L19:
         *__esp = tmpf;
        unlink();
        return;
    }
    _t80 = tmpf;
    _v72 = 135051803;
     *__esp = _t80;
    fopen();
    f = _t80;
    if(f != 0) {
        fi->value = Strnew();
        auto_detect = WcOption.auto_detect & 255;
        WcOption.auto_detect = 2;
        while(1) {
            tmp = Strfgets(f);
            if(tmp->length <= 0) {
                break;
            }
            if(tmp->length != 1 || ( *(tmp->ptr + tmp->length - 1) & 255) != 10) {
                if(tmp->length > 1 && ( *(tmp->ptr + tmp->length - 1) & 255) == 10 && ( *(tmp->ptr + tmp->length - 2) & 255) != 13) {
                    Strshrink(tmp, 1);
                    Strcat_charp(tmp, 135051805);
                }
            } else {
                tmp = Strnew_charp(135051805);
            }
            tmp = convertLine(0, tmp, 0,  &charset, DisplayCharset);
            Strcat(fi->value, tmp);
        }
        WcOption.auto_detect = auto_detect & 255;
         *__esp = f;
        fclose();
        goto L19;
    }
    disp_err_message("Can't open temporary file", 0);
    goto L19;
}

void do_internal(char* action, char* data)
{// addr = 0x0808CE8B  --  defined in 'form.c' at line 626
    int i;                                 // _cfa_fffffff0
    char* _v40;                            // _cfa_ffffffd8
    struct parsed_tagarg* _t22;   // _t22

    i = 0;
    while( *( &internal_action + i * 8) != 0) {
        _t22 =  *( &internal_action + i * 8);
        _v40 = action;
         *__esp = _t22;
        strcasecmp();
        if(_t22 != 0) {
            i = i + 1;
            continue;
        }
        if( *((intOrPtr*)(135091940 + i * 8)) != 0) {
             *__esp = cgistr2tagarg(data);
             *((intOrPtr*)( *((intOrPtr*)(135091940 + i * 8))))();
            return;
        }
        return;
    }
}

void addSelectOption(FormSelectOption* fso, Str value, Str label, int chk)
{// addr = 0x0808CEFD  --  defined in 'form.c' at line 641
    FormSelectOptionItem* o;   // _cfa_fffffff0

     *__esp = 16;
    GC_malloc();
    o = __eax;
    if(value == 0) {
        value = label;
    }
    o->value = value;
    Strremovefirstspaces(label);
    Strremovetrailingspaces(label);
    o->label = label;
    o->checked = chk;
    o->next = 0;
    if(fso->first != 0) {
        fso->last->next = o;
        fso->last = o;
        return;
    } else {
        fso->last = o;
        fso->first = fso->last;
        return;
    }
}

void chooseSelectOption(FormItemList* fi, FormSelectOptionItem* item)
{// addr = 0x0808CF8E  --  defined in 'form.c' at line 662
    FormSelectOptionItem* opt;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    fi->selected = 0;
    if(item != 0) {
        fi->value = item->value;
        fi->label = item->label;
        i = 0;
        opt = item;
        while(opt != 0) {
            if(opt->checked == 0) {
                i = i + 1;
                opt = opt->next;
                continue;
            }
            fi->value = opt->value;
            fi->label = opt->label;
            fi->selected = i;
            break;
        }
        updateSelectOption(fi, item);
        return;
    }
    fi->value = Strnew_size(0);
    fi->label = Strnew_size(0);
}

void updateSelectOption(FormItemList* fi, FormSelectOptionItem* item)
{// addr = 0x0808D043  --  defined in 'form.c' at line 687
    int i;                                 // _cfa_fffffff8

    if(fi == 0) {
        return;
    }
    if(item != 0) {
        i = 0;
        while(item != 0) {
            if(fi->selected != i) {
                item->checked = 0;
            } else {
                item->checked = 1;
            }
            i = i + 1;
            item = item->next;
        }
        return;
    }
}

int formChooseOptionByMenu(struct form_item_list* fi, int x, int y)
{// addr = 0x0808D09A  --  defined in 'form.c' at line 702
    int i;                                 // _cfa_fffffff0
    int n;                                 // _cfa_ffffffec
    int selected;                          // _cfa_ffffffe8
    int init_select;                       // _cfa_ffffffe4
    FormSelectOptionItem* opt;   // _cfa_ffffffe0
    char** label;                          // _cfa_ffffffdc
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    char** _t78;                           // _t78

    selected = -1;
    init_select = fi->selected;
    n = 0;
    opt = fi->select_option;
    while(opt != 0) {
        n = n + 1;
        opt = opt->next;
    }
    _t78 = n + 1 << 2;
     *__esp = _t78;
    GC_malloc();
    label = _t78;
    i = 0;
    opt = fi->select_option;
    while(opt != 0) {
        label[i] =  *(opt->label);
        i = i + 1;
        opt = opt->next;
    }
    label[n] = 0;
    optionMenu(x, y, label,  &selected, init_select, 0);
    if(selected >= 0) {
        i = 0;
        opt = fi->select_option;
        while(opt != 0) {
            if(i != selected) {
                i = i + 1;
                opt = opt->next;
                continue;
            }
            fi->selected = selected;
            fi->value = opt->value;
            fi->label = opt->label;
            break;
        }
        updateSelectOption(fi, fi->select_option);
        return 1;
    }
    return 0;
}

void form_write_data(FILE* f, char* boundary, char* name, char* value)
{// addr = 0x0808D1D8  --  defined in 'form.c' at line 732
    char* _v20;                            // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8

    _v20 = boundary;
    _v24 = "--%s\n";
     *__esp = f;
    fprintf();
    _v20 = name;
    _v24 = "Content-Disposition: form-data; name="%s"\n\n";
     *__esp = f;
    fprintf();
    _v20 = value;
    _v24 = "%s\n";
     *__esp = f;
    fprintf();
}

void form_write_from_file(FILE* f, char* boundary, char* name, char* filename, char* file)
{// addr = 0x0808D231  --  defined in 'form.c' at line 740
    FILE* fd;             // _cfa_fffffff0
    int c;                                 // _cfa_ffffffec
    char* type;                            // _cfa_ffffffe8
    _unknown_ _v96;                        // _cfa_ffffffa0
    struct stat st;       // _cfa_ffffff90
    FILE* _v128;          // _cfa_ffffff80
    char* _v132;                           // _cfa_ffffff7c
    FILE* _v136;          // _cfa_ffffff78 (outparam)
    char* _t45;                            // _t45
    FILE* _t52;           // _t52
    int _t53;                              // _t53

    _v132 = boundary;
    _v136 = "--%s\n";
     *__esp = f;
    fprintf();
    _v128 = mybasename(filename);
    _v132 = name;
    _v136 = "Content-Disposition: form-data; name="%s"; filename="%s"\n";
     *__esp = f;
    fprintf();
    type = guessContentType(file);
    if(type == 0) {
        _t45 = "application/octet-stream";
    } else {
        _t45 = type;
    }
    _v132 = _t45;
    _v136 = "Content-Type: %s\n\n";
     *__esp = f;
    fprintf();
    if(__lstat(file,  &(st.st_dev)) >= 0) {
        if((st.st_mode & 61440) == 16384) {
        } else {
            _t52 = file;
            _v136 = 135051803;
             *__esp = _t52;
            fopen();
            fd = _t52;
            if(fd != 0) {
                while(1) {
                    _t53 = fd;
                     *__esp = _t53;
                    fgetc();
                    c = _t53;
                    if(c == -1) {
                        break;
                    }
                    _v136 = f;
                     *__esp = c;
                    fputc();
                }
                 *__esp = fd;
                fclose();
            }
        }
    }
    _v128 = f;
    _v132 = 2;
    _v136 = 1;
     *__esp = 135051805;
    fwrite();
}

struct pre_form* add_pre_form(struct pre_form* prev, char* url, char* name, char* action)
{// addr = 0x0808D356  --  defined in 'form.c' at line 790
    struct pre_form* new;   // _cfa_fffffff0
    int l;                                 // _cfa_ffffffec
    ParsedURL pu;    // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    char* _t58;                            // _t58
    char* _t59;                            // _t59
    int _t75;                              // _t75

    if(prev == 0) {
         *__esp = 24;
        GC_malloc();
        PreForm = __eax;
        new = PreForm;
    } else {
         *__esp = 24;
        GC_malloc();
        prev->next = __eax;
        new = prev->next;
    }
    if(url == 0 || ( *url & 255) != 47) {
        if(url != 0) {
            parseURL2(url,  &pu, 0);
            new->url =  *(parsedURL2Str( &pu));
            new->re_url = 0;
        }
    } else {
        _t75 = url;
         *__esp = _t75;
        strlen();
        l = _t75;
        if(l <= 1 || (url[l - 1] & 255) != 47) {
            new->url =  &(url[1]);
        } else {
            new->url = allocStr( &(url[1]), l - 2);
        }
        new->re_url = newRegex(new->url, 0, 0, 0);
        if(new->re_url == 0) {
            new->url = 0;
        }
    }
    if(name == 0 || ( *name & 255) == 0) {
        _t58 = 0;
    } else {
        _t58 = name;
    }
    new->name = _t58;
    if(action == 0 || ( *action & 255) == 0) {
        _t59 = 0;
    } else {
        _t59 = action;
    }
    new->action = _t59;
    new->item = 0;
    new->next = 0;
    return new;
}

struct pre_form_item* add_pre_form_item(struct pre_form* pf, struct pre_form_item* prev, int type, char* name, char* value, char* checked)
{// addr = 0x0808D4D8  --  defined in 'form.c' at line 822
    struct pre_form_item* new;   // _cfa_fffffff0
    intOrPtr _v40;                         // _cfa_ffffffd8
    struct pre_form_item* _t36;   // _t36
    char* _t48;                            // _t48
    char* _t50;                            // _t50
    char* _t51;                            // _t51

    if(pf != 0) {
        if(prev == 0) {
             *__esp = 20;
            GC_malloc();
            pf->item = _t36;
            new = pf->item;
        } else {
             *__esp = 20;
            GC_malloc();
            prev->next = _t36;
            new = prev->next;
        }
        new->type = type;
        new->name = name;
        new->value = value;
        if(checked == 0 || ( *checked & 255) == 0) {
L11:
            new->checked = 1;
            goto L12;
        } else {
            _v40 = 135051973;
            _t48 = checked;
             *__esp = _t48;
            strcmp();
            if(_t48 == 0) {
L10:
                new->checked = 0;
L12:
                new->next = 0;
                return new;
            }
            _v40 = 135051975;
            _t50 = checked;
             *__esp = _t50;
            strcasecmp();
            if(_t50 != 0) {
                goto L10;
            }
            _v40 = 135051979;
            _t51 = checked;
             *__esp = _t51;
            strcasecmp();
            if(_t51 != 0) {
                goto L11;
            }
            goto L10;
        }
    }
    return 0;
}

void loadPreForm()
{// addr = 0x0808D5C4  --  defined in 'form.c' at line 863
    FILE* fp;             // _cfa_fffffff0
    Str line;              // _cfa_ffffffec
    Str textarea;          // _cfa_ffffffe8
    struct pre_form* pf;   // _cfa_ffffffe4
    struct pre_form_item* pi;   // _cfa_ffffffe0
    int type;                              // _cfa_ffffffdc
    char* name;                            // _cfa_ffffffd8
    char* p;                               // _cfa_ffffffd4
    char* s;                               // _cfa_ffffffd0
    char* arg;                             // _cfa_ffffffcc
    struct pre_form* prev;   // _cfa_ffffffc8
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ _v76;                        // _cfa_ffffffb4 (outparam)
    _unknown_ _v80;                        // _cfa_ffffffb0 (outparam)
    int _v84;                              // _cfa_ffffffac (outparam)
    char* _v88;                            // _cfa_ffffffa8 (outparam)
    char* _t172;                           // _t172
    char* _t173;                           // _t173
    char* _t174;                           // _t174
    char* _t175;                           // _t175
    char* _t176;                           // _t176
    char* _t187;                           // _t187
    char* _t188;                           // _t188
    char* _t189;                           // _t189
    char* _t190;                           // _t190
    char* _t191;                           // _t191
    char* _t192;                           // _t192
    char* _t193;                           // _t193
    char* _t194;                           // _t194
    char* _t218;                           // _t218
    char* _t245;                           // _t245

    line = 0;
    textarea = 0;
    pf = 0;
    pi = 0;
    type = -1;
    name = 0;
    PreForm = 0;
    fp = openSecretFile(pre_form_file);
    if(fp == 0) {
        return;
    } else {
        goto L1;
    }
    while(1) {
L1:
        line = Strfgets(fp);
        if(line->length == 0) {
             *__esp = fp;
            fclose();
            return;
        }
L3:
        if(textarea == 0) {
            goto L7;
        }
L4:
        _t245 = line->ptr;
        _v84 = 9;
        _v88 = "/textarea";
         *__esp = _t245;
        strncmp();
        if(_t245 != 0 || ( *( &MYCTYPE_MAP + ( *(line->ptr + 9) & 0xff)) & 2) == 0) {
            Strcat(textarea, line);
L57:
            while(1) {
L1:
                line = Strfgets(fp);
                if(line->length == 0) {
                     *__esp = fp;
                    fclose();
                    return;
                }
L3:
                if(textarea == 0) {
                    goto L7;
                }
                goto L4;
            }
        }
L7:
        Strchop(line);
        Strremovefirstspaces(line);
        p = line->ptr;
        if(( *p & 255) == 35 || ( *p & 255) == 0) {
        } else {
            s = getWord( &p);
            arg = getWord( &p);
            _v88 = "url";
            _t172 = s;
             *__esp = _t172;
            strcmp();
            if(_t172 != 0) {
                if(pf != 0) {
                    _v88 = "form";
                    _t173 = s;
                     *__esp = _t173;
                    strcmp();
                    if(_t173 != 0) {
                        _v88 = "text";
                        _t174 = s;
                         *__esp = _t174;
                        strcmp();
                        if(_t174 != 0) {
                            _v88 = "file";
                            _t175 = s;
                             *__esp = _t175;
                            strcmp();
                            if(_t175 != 0) {
                                _v88 = "passwd";
                                _t176 = s;
                                 *__esp = _t176;
                                strcmp();
                                if(_t176 == 0) {
L38:
                                    type = 1;
L56:
                                    s = getQWord( &p);
                                    pi = add_pre_form_item(pf, pi, type, arg, s, getQWord( &p));
                                    continue;
                                }
                                _v88 = "password";
                                _t187 = s;
                                 *__esp = _t187;
                                strcmp();
                                if(_t187 != 0) {
                                    _v88 = "checkbox";
                                    _t188 = s;
                                     *__esp = _t188;
                                    strcmp();
                                    if(_t188 != 0) {
                                        _v88 = "radio";
                                        _t189 = s;
                                         *__esp = _t189;
                                        strcmp();
                                        if(_t189 != 0) {
                                            _v88 = "submit";
                                            _t190 = s;
                                             *__esp = _t190;
                                            strcmp();
                                            if(_t190 != 0) {
                                                _v88 = "image";
                                                _t191 = s;
                                                 *__esp = _t191;
                                                strcmp();
                                                if(_t191 != 0) {
                                                    _v88 = "select";
                                                    _t192 = s;
                                                     *__esp = _t192;
                                                    strcmp();
                                                    if(_t192 != 0) {
                                                        _v88 = "textarea";
                                                        _t193 = s;
                                                         *__esp = _t193;
                                                        strcmp();
                                                        if(_t193 != 0) {
                                                            if(textarea == 0 || name == 0) {
L55:
                                                            } else {
                                                                _v88 = "/textarea";
                                                                _t194 = s;
                                                                 *__esp = _t194;
                                                                strcmp();
                                                                if(_t194 != 0) {
                                                                    goto L55;
                                                                }
                                                                pi = add_pre_form_item(pf, pi, type, name, textarea->ptr, 0);
                                                                textarea = 0;
                                                                name = 0;
                                                            }
                                                            goto L57;
                                                        }
                                                        type = 9;
                                                        name =  *(Strnew_charp(arg));
                                                        textarea = Strnew();
                                                        goto L57;
                                                    }
                                                    type = 8;
                                                    goto L56;
                                                }
                                                type = 7;
                                                goto L56;
                                            }
                                            type = 4;
                                            goto L56;
                                        }
                                        type = 3;
                                        goto L56;
                                    }
                                    type = 2;
                                    goto L56;
                                }
                                goto L38;
                            }
                            type = 11;
                            goto L56;
                        }
                        type = 0;
                        goto L56;
                    }
                    if(arg != 0 && ( *arg & 255) != 0) {
                        s = getQWord( &p);
                        p = getQWord( &p);
                        if(p == 0 || ( *p & 255) == 0) {
                            p = s;
                            s = 0;
                        }
                        if(pf->item == 0) {
                            pf->name = s;
                            if(p == 0 || ( *p & 255) == 0) {
                                _t218 = 0;
                            } else {
                                _t218 = p;
                            }
                            pf->action = _t218;
                        } else {
                            prev = pf;
                            pf = add_pre_form(prev, 135051758, s, p);
                            pf->url = prev->url;
                            pf->re_url = prev->re_url;
                        }
                        pi = pf->item;
                    }
                } else {
                }
            } else {
                if(arg != 0 && ( *arg & 255) != 0) {
                    p = getQWord( &p);
                    pf = add_pre_form(pf, arg, 0, p);
                    pi = pf->item;
                }
            }
        }
        goto L57;
    }
}

void preFormUpdateBuffer(Buffer* buf)
{// addr = 0x0808DA7C  --  defined in 'form.c' at line 965
    FormSelectOptionItem* opt;   // _cfa_ffffffd8
    int j;                                 // _cfa_ffffffd4
    struct pre_form* pf;   // _cfa_fffffff0
    struct pre_form_item* pi;   // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    Anchor* a;          // _cfa_ffffffe4
    FormList* fl;     // _cfa_ffffffe0
    FormItemList* fi;   // _cfa_ffffffdc
    Str url;               // _cfa_ffffffd0
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    char* _v72;                            // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    char* _t122;                           // _t122
    struct form_item_list* _t162;   // _t162
    struct form_item_list* _t171;   // _t171
    struct form_item_list* _t181;   // _t181
    char* _t190;                           // _t190
    char* _t195;                           // _t195

    if(buf == 0) {
        return;
    }
    if(buf->formitem.scheme == 0) {
        return;
    }
    if(PreForm == 0) {
        return;
    } else {
        pf = PreForm;
        while(pf != 0) {
            if(pf->re_url == 0) {
                if(pf->url == 0) {
L54:
                    pf = pf->next;
                    continue;
                }
                _t122 =  *(parsedURL2Str( &(buf->currentURL)));
                _v72 = pf->url;
                 *__esp = _t122;
                strcmp();
                if(_t122 != 0) {
                    goto L54;
                }
L9:
                i = 0;
                while( *((intOrPtr*)(buf->formitem.scheme + 4)) > i) {
                    a =  *(buf->formitem.scheme) + (i << 2 << 4) - (i << 2);
                    fi = a->url;
                    fl = fi->parent;
                    if(pf->name == 0) {
L13:
                        if(pf->action == 0) {
L16:
                            pi = pf->item;
                            while(pi != 0) {
                                if(pi->type != fi->type) {
L42:
                                    pi = pi->next;
                                    continue;
                                }
                                if(pi->type == 4 || pi->type == 7) {
                                    if(pi->name == 0 || (pi & 255) == 0) {
L24:
                                        if(pi->value == 0 || (pi & 255) == 0) {
L28:
                                            buf->submit.scheme = a;
                                            goto L42;
                                        } else {
                                            if(fi->value == 0) {
                                                goto L42;
                                            }
                                            _t162 = fi->value->item;
                                            _v72 = pi->value;
                                             *__esp = _t162;
                                            strcmp();
                                            if(_t162 != 0) {
                                                goto L42;
                                            }
                                            goto L28;
                                        }
                                    } else {
                                        if(fi->name == 0) {
                                            goto L42;
                                        }
                                        _t171 = fi->name->item;
                                        _v72 = pi->name;
                                         *__esp = _t171;
                                        strcmp();
                                        if(_t171 != 0) {
                                            goto L42;
                                        }
                                        goto L24;
                                    }
                                } else {
                                    if(pi->name == 0) {
                                        goto L42;
                                    }
                                    if(fi->name == 0) {
                                        goto L42;
                                    }
                                    _t181 = fi->name->item;
                                    _v72 = pi->name;
                                     *__esp = _t181;
                                    strcmp();
                                    if(_t181 != 0) {
                                        goto L42;
                                    }
                                    if(pi->type > 11) {
                                        goto L42;
                                    }
                                    goto __eax;
                                }
                            }
L49:
                            i = i + 1;
                            continue;
                        }
                        if(fl->action == 0) {
                            goto L49;
                        }
                        _t190 =  *(fl->action);
                        _v72 = pf->action;
                         *__esp = _t190;
                        strcmp();
                        if(_t190 != 0) {
                            goto L49;
                        }
                        goto L16;
                    }
                    if(fl->name == 0) {
                        goto L49;
                    }
                    _t195 = fl->name;
                    _v72 = pf->name;
                     *__esp = _t195;
                    strcmp();
                    if(_t195 != 0) {
                        goto L49;
                    }
                    goto L13;
                }
                goto L54;
            }
            url = parsedURL2Str( &(buf->currentURL));
            if(RegexMatch(pf->re_url, url->ptr, url->length, 1) != 0) {
                goto L9;
            }
            goto L54;
        }
        return;
    }
}

MapList* searchMapList(Buffer* buf, char* name)
{// addr = 0x0808DF40  --  defined in 'map.c' at line 9
    MapList* ml;       // _cfa_fffffff0
    char* _v40;                            // _cfa_ffffffd8
    struct _Str* _t17;    // _t17

    if(name != 0) {
        ml = buf->maplist;
        while(ml != 0) {
            _t17 = ml->name->name;
            _v40 = name;
             *__esp = _t17;
            strcmp();
            if(_t17 == 0) {
L8:
                return ml;
            }
            ml = ml->next;
        }
        goto L8;
    }
    return 0;
}

int inMapArea(MapArea* a, int x, int y)
{// addr = 0x0808DF8F  --  defined in 'map.c' at line 24
    int i;                                 // _cfa_fffffff0
    double r1;                             // _cfa_ffffffe4
    double r2;                             // _cfa_ffffffdc
    double s;                              // _cfa_ffffffd4
    double c;                              // _cfa_ffffffcc
    double t;                              // _cfa_ffffffc4
    int _v64;                              // _cfa_ffffffc0
    double _v84;                           // _cfa_ffffffac
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    signed int _t138;                      // _t138
    MapArea* _t139;    // _t139
    MapArea* _t144;    // _t144
    MapArea* _t149;    // _t149
    MapArea* _t154;    // _t154
    signed int _t180;                      // _t180
    MapArea* _t181;    // _t181
    MapArea* _t185;    // _t185
    int _t317;                             // _t317
    int _t321;                             // _t321
    signed int _t329;                      // _t329
    double _t404;                          // _t404
    signed long long _t406;                // _t406
    signed long long _t408;                // _t408

    __eflags = a;
    if(a == 0) {
        return 0;
    }
    _t138 = a->shape & 255;
    __eflags = _t138 - 2;
    if(_t138 == 2) {
        _t139 = a;
        __eflags = (_t139 & 65535) - x;
        if((_t139 & 65535) > x) {
L39:
            return 0;
        }
        _t144 = a;
        __eflags = (_t144->coords[1] & 65535) - y;
        if((_t144->coords[1] & 65535) > y) {
            goto L39;
        }
        _t149 = a;
        __eflags = (_t149->coords[2] & 65535) - x;
        if((_t149->coords[2] & 65535) < x) {
            goto L39;
        }
        _t154 = a;
        __eflags = (_t154->coords[3] & 65535) - y;
        if((_t154->coords[3] & 65535) < y) {
            goto L39;
        }
        return 1;
    }
    __eflags = _t138 - 2;
    if(_t138 > 2) {
        __eflags = _t138 - 3;
        if(_t138 == 3) {
            _t329 = (x - (a & 65535)) * (x - (a & 65535));
            _t180 = (y - (a->coords[1] & 65535)) * (y - (a->coords[1] & 65535));
            _t181 = a;
            _t185 = a;
            __eflags = _t329 + _t180 - (_t185->coords[2] & 65535) * (_t181->coords[2] & 65535);
            if(_t329 + _t180 > (_t185->coords[2] & 65535) * (_t181->coords[2] & 65535)) {
                goto L39;
            }
            return 1;
        }
        __eflags = _t138 - 4;
        if(_t138 == 4) {
            asm("fldz");
            t = __fp0;
            i = 0;
            while(1) {
                __eflags = a->ncoords - i;
                if(__eflags <= 0) {
                    break;
                }
                _v64 = x - ( *(a->coords + i + i) & 65535);
                asm("fild dword [ebp-0x3c]");
                _v64 = x - ( *(a->coords + i + i) & 65535);
                asm("fild dword [ebp-0x3c]");
                asm("fmulp st1, st0");
                _v64 = y - ( *(a->coords + i + 1 + i + 1) & 65535);
                asm("fild dword [ebp-0x3c]");
                _t317 = y - ( *(a->coords + i + 1 + i + 1) & 65535);
                __eflags = _t317;
                _v64 = _t317;
                asm("fild dword [ebp-0x3c]");
                asm("fmulp st1, st0");
                asm("faddp st1, st0");
                _t404 = st0;
                asm("fsqrt");
                asm("fucomi st0, st0");
                if(__eflags != 0) {
                    st0 = _t404;
L21:
                     *__esp = _t404;
                    sqrt();
L23:
                    r1 = _t404;
                    _v64 = x - ( *(a->coords + i + 2 + i + 2) & 65535);
                    asm("fild dword [ebp-0x3c]");
                    _v64 = x - ( *(a->coords + i + 2 + i + 2) & 65535);
                    asm("fild dword [ebp-0x3c]");
                    asm("fmulp st1, st0");
                    _v64 = y - ( *(a->coords + i + 3 + i + 3) & 65535);
                    asm("fild dword [ebp-0x3c]");
                    _t321 = y - ( *(a->coords + i + 3 + i + 3) & 65535);
                    __eflags = _t321;
                    _v64 = _t321;
                    asm("fild dword [ebp-0x3c]");
                    asm("fmulp st1, st0");
                    asm("faddp st1, st0");
                     *__esp = _t404;
                    sqrt();
                    r2 = _t404;
                    asm("fldz");
                    asm("fxch st0, st1");
                    asm("fucomip st0, st1");
                    st0 = r1;
                    if(__eflags != 0 || __eflags != 0) {
                        _t406 = r2;
                        asm("fldz");
                        asm("fxch st0, st1");
                        asm("fucomip st0, st1");
                        st0 = _t406;
                        if(__eflags != 0 || __eflags != 0) {
                            _v64 = x - ( *(a->coords + i + i) & 65535);
                            asm("fild dword [ebp-0x3c]");
                            _v64 = y - ( *(a->coords + i + 3 + i + 3) & 65535);
                            asm("fild dword [ebp-0x3c]");
                            asm("fmulp st1, st0");
                            _v64 = x - ( *(a->coords + i + 2 + i + 2) & 65535);
                            asm("fild dword [ebp-0x3c]");
                            _v64 = y - ( *(a->coords + i + 1 + i + 1) & 65535);
                            asm("fild dword [ebp-0x3c]");
                            asm("fmulp st1, st0");
                            asm("fsubp st1, st0");
                            _t408 = _t406 / r1 / r2;
                            s = _t408;
                            _v64 = x - ( *(a->coords + i + i) & 65535);
                            asm("fild dword [ebp-0x3c]");
                            _v64 = x - ( *(a->coords + i + 2 + i + 2) & 65535);
                            asm("fild dword [ebp-0x3c]");
                            asm("fmulp st1, st0");
                            _v64 = y - ( *(a->coords + i + 1 + i + 1) & 65535);
                            asm("fild dword [ebp-0x3c]");
                            _v64 = y - ( *(a->coords + i + 3 + i + 3) & 65535);
                            asm("fild dword [ebp-0x3c]");
                            asm("fmulp st1, st0");
                            asm("faddp st1, st0");
                            c = _t408 / r1 / r2;
                            _v84 = c;
                             *__esp = s;
                            atan2();
                            asm("faddp st1, st0");
                            t = t;
                            i = i + 2;
                            __eflags = i;
                            continue;
                        } else {
                            goto L27;
                        }
                    } else {
L27:
                        return 1;
                    }
                }
                if(__eflags == 0) {
                    st1 = _t404;
                    goto L23;
                }
                st0 = _t404;
                goto L21;
            }
            asm("fabs");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            st0 =  *135053344;
            if(__eflags == 0) {
                goto L39;
            }
            return 1;
        }
        goto L39;
    }
    __eflags = _t138 - 1;
    if(_t138 == 1) {
        return 1;
    }
    goto L39;
}

int nearestMapArea(MapList* ml, int x, int y)
{// addr = 0x0808E3E5  --  defined in 'map.c' at line 75
    ListItem* al;     // _cfa_fffffff8
    MapArea* a;        // _cfa_fffffff4
    int i;                                 // _cfa_fffffff0
    int l;                                 // _cfa_ffffffec
    int n;                                 // _cfa_ffffffe8
    int min;                               // _cfa_ffffffe4
    int limit;                             // _cfa_ffffffe0
    _unknown_ _v38;                        // _cfa_ffffffda
    short _v40;                            // _cfa_ffffffd8

    n = -1;
    min = -1;
    asm("fmulp st1, st0");
    asm("fmulp st1, st0");
    asm("faddp st1, st0");
    asm("fnstcw word [ebp-0x22]");
    _v40 = 12;
    asm("fldcw word [ebp-0x24]");
    asm("fistp dword [ebp-0x1c]");
    asm("fldcw word [ebp-0x22]");
    if(ml == 0 || ml->area == 0) {
        return n;
    }
    i = 0;
    al = ml->area->first;
    while(al != 0) {
        a = al->ptr;
        if(a != 0) {
            l = ((a->center_x & 65535) - x) * ((a->center_x & 65535) - x) + ((a->center_y & 65535) - y) * ((a->center_y & 65535) - y);
            if(min < 0 || l < min) {
                if(l < limit) {
                    n = i;
                    min = l;
                }
            }
        }
        i = i + 1;
        al = al->next;
    }
    return n;
}

int searchMapArea(Buffer* buf, MapList* ml, Anchor* a_img)
{// addr = 0x0808E4DD  --  defined in 'map.c' at line 99
    ListItem* al;     // _cfa_fffffff0
    MapArea* a;        // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    int n;                                 // _cfa_ffffffe4
    int px;                                // _cfa_ffffffe0
    int py;                                // _cfa_ffffffdc
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    if(ml == 0 || ml->area == 0 || (ml->area->nitem & 65535) == 0) {
        return -1;
    }
    if(getMapXY(buf, a_img,  &px,  &py) == 0) {
        return -1;
    }
    n =  ~(ml->area->nitem & 65535);
    i = 0;
    al = ml->area->first;
    while(al != 0) {
        a = al->ptr;
        if(a != 0) {
            if(n < 0 && inMapArea(a, px, py) != 0) {
                if((a->shape & 255) != 1) {
                    n = i;
                } else {
                    if( ~(ml->area->nitem & 65535) == n) {
                        n =  ~i;
                    }
                }
            }
        }
        i = i + 1;
        al = al->next;
    }
    if( ~(ml->area->nitem & 65535) != n) {
        if(n >= 0) {
            return n;
        }
        return  ~n;
    }
    return nearestMapArea(ml, px, py);
}

MapArea* retrieveCurrentMapArea(Buffer* buf)
{// addr = 0x0808E611  --  defined in 'map.c' at line 132
    Anchor* a_img;      // _cfa_fffffff0
    Anchor* a_form;     // _cfa_ffffffec
    FormItemList* fi;   // _cfa_ffffffe8
    MapList* ml;       // _cfa_ffffffe4
    ListItem* al;     // _cfa_ffffffe0
    MapArea* a;        // _cfa_ffffffdc
    int i;                                 // _cfa_ffffffd8
    int n;                                 // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    char* _t80;                            // _t80

    a_img = retrieveCurrentImg(buf);
    if(a_img == 0 || a_img->image == 0 || a_img->image->map == 0) {
        return 0;
    } else {
        a_form = retrieveCurrentForm(buf);
        if(a_form == 0 || a_form->url == 0) {
            return 0;
        }
        fi = a_form->url;
        if(fi == 0 || fi->parent == 0 || fi->parent->item == 0) {
            return 0;
        }
        fi = fi->parent->item;
        if(fi->value == 0) {
            _t80 = 0;
        } else {
            _t80 =  *(fi->value);
        }
        ml = searchMapList(buf, _t80);
        if(ml != 0) {
            n = searchMapArea(buf, ml, a_img);
            if(n >= 0) {
                i = 0;
                al = ml->area->first;
                while(al != 0) {
                    a = al->ptr;
                    if(a == 0 || i != n) {
                        i = i + 1;
                        al = al->next;
                        continue;
                    } else {
                        return a;
                    }
                }
                return 0;
            }
            return 0;
        } else {
            return 0;
        }
    }
}

int getMapXY(Buffer* buf, Anchor* a, int* x, int* y)
{// addr = 0x0808E756  --  defined in 'map.c' at line 166
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ _v18;                        // _cfa_ffffffee
    short _v20;                            // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    if(buf == 0) {
L5:
        return 0;
    }
    if(a == 0 || a->image == 0 || x == 0 || y == 0) {
        goto L5;
    } else {
        _v16 = buf->currentColumn + (buf->cursorX & 65535) - calcPosition(buf->currentLine->lineBuf, buf->currentLine->propBuf, buf->currentLine->len, a->start.pos, 0, 0);
        asm("fild dword [ebp-0xc]");
        asm("faddp st1, st0");
        asm("fmulp st1, st0");
        asm("fnstcw word [ebp-0xe]");
        _v20 = 12;
        asm("fldcw word [ebp-0x10]");
        asm("fistp dword [ebp-0xc]");
        asm("fldcw word [ebp-0xe]");
         *x = _v16 - (a->image->xoffset & 65535);
        _v16 = buf->currentLine->linenumber - (a->image->y & 65535);
        asm("fild dword [ebp-0xc]");
        asm("faddp st1, st0");
        asm("fmulp st1, st0");
        asm("fldcw word [ebp-0x10]");
        asm("fistp dword [ebp-0xc]");
        asm("fldcw word [ebp-0xe]");
         *y = _v16 - (a->image->yoffset & 65535);
        if( *x <= 0) {
             *x = 1;
        }
        if( *y <= 0) {
             *y = 1;
        }
        return 1;
    }
}

Anchor* retrieveCurrentMap(Buffer* buf)
{// addr = 0x0808E8A4  --  defined in 'map.c' at line 184
    Anchor* a;          // _cfa_fffffff0
    FormItemList* fi;   // _cfa_ffffffec
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _t29;                         // _t29

    a = retrieveCurrentForm(buf);
    if(a == 0 || a->url == 0) {
        return 0;
    } else {
        fi = a->url;
        if(fi->parent->method != 2) {
L6:
            return 0;
        }
        _t29 =  *(fi->parent->action);
        _v40 = 135052056;
         *__esp = _t29;
        strcmp();
        if(_t29 != 0) {
            goto L6;
        }
        return a;
    }
}

MapArea* follow_map_menu(Buffer* buf, char* name, Anchor* a_img, int x, int y)
{// addr = 0x0808E90F  --  defined in 'map.c' at line 201
    MapList* ml;       // _cfa_fffffff0
    ListItem* al;     // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    int selected;                          // _cfa_ffffffe4
    int initial;                           // _cfa_ffffffe0
    MapArea* a;        // _cfa_ffffffdc
    char** label;                          // _cfa_ffffffd8
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    char** _t97;                           // _t97
    char* _t137;                           // _t137
    char** _t141;                          // _t141

    selected = -1;
    initial = 0;
    ml = searchMapList(buf, name);
    if(ml == 0 || ml->area == 0 || (ml->area->nitem & 65535) == 0) {
        return 0;
    }
    initial = searchMapArea(buf, ml, a_img);
    if(initial >= 0) {
        if(image_map_list != 0) {
            goto L8;
        }
        selected = initial;
        goto L18;
    } else {
        initial = 0;
L8:
        _t97 = (ml->area->nitem & 65535) + 1 << 2;
         *__esp = _t97;
        GC_malloc();
        label = _t97;
        i = 0;
        al = ml->area->first;
        while(al != 0) {
            a = al->ptr;
            if(a == 0) {
                label[i] = 135052060;
L15:
                i = i + 1;
                al = al->next;
                continue;
            }
            _t141 =  &(label[i]);
            if((a & 255) == 0) {
                _t137 = a->url;
            } else {
                _t137 = a->alt;
            }
             *_t141 = _t137;
            goto L15;
        }
        label[ml->area->nitem & 65535] = 0;
        optionMenu(x, y, label,  &selected, initial, 0);
L18:
        if(selected < 0) {
L25:
            return 0;
        }
        i = 0;
        al = ml->area->first;
        while(al != 0) {
            if(al->ptr == 0 || i != selected) {
                i = i + 1;
                al = al->next;
                continue;
            } else {
                return al->ptr;
            }
        }
        goto L25;
    }
}

MapArea* newMapArea(char* url, char* target, char* alt, char* shape, char* coords)
{// addr = 0x0808EABC  --  defined in 'map.c' at line 301
    MapArea* a;        // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    int max;                               // _cfa_ffffffe4
    char _v36;                             // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    char _t221;                            // _t221
    char _t233;                            // _t233
    char _t235;                            // _t235
    char* _t333;                           // _t333
    char* _t334;                           // _t334
    char* _t335;                           // _t335
    char* _t336;                           // _t336

     *__esp = 28;
    GC_malloc();
    a = __eax;
    a->url = url;
    a->target = target;
    if(alt == 0) {
        _t221 = 135052060;
    } else {
        _t221 = alt;
    }
    a->alt = _t221;
    a->shape = 2;
    if(shape != 0) {
        _v40 = "default";
        _t333 = shape;
         *__esp = _t333;
        strcasecmp();
        if(_t333 != 0) {
            _v36 = 4;
            _v40 = "rect";
            _t334 = shape;
             *__esp = _t334;
            strncasecmp();
            if(_t334 != 0) {
                _v36 = 4;
                _v40 = "circ";
                _t335 = shape;
                 *__esp = _t335;
                strncasecmp();
                if(_t335 != 0) {
                    _v36 = 4;
                    _v40 = "poly";
                    _t336 = shape;
                     *__esp = _t336;
                    strncasecmp();
                    if(_t336 != 0) {
                        a->shape = 0;
                    } else {
                        a->shape = 4;
                    }
                } else {
                    a->shape = 3;
                }
            } else {
                a->shape = 2;
            }
        } else {
            a->shape = 1;
        }
    }
    a->coords = 0;
    a->ncoords = 0;
    a->center_x = 0;
    a->center_y = 0;
    if((a->shape & 255) == 0 || (a->shape & 255) == 1) {
        return a;
    }
    if(coords != 0) {
        _t233 = a->shape & 255;
        if(_t233 != 2) {
            _t235 = a->shape & 255;
            if(_t235 == 3) {
                 *__esp = 6;
                GC_malloc();
                a->coords = _t235;
                a->ncoords = 3;
            }
        } else {
             *__esp = 8;
            GC_malloc();
            a->coords = _t233;
            a->ncoords = 4;
        }
        max = a->ncoords;
        i = 0;
        p = coords;
        while((a->shape & 255) == 4 || a->ncoords > i) {
            if(( *p & 255) != 0) {
                while(1) {
                    p =  *p & 255;
                    __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                    __eax = __al & 255;
                    if(__eax == 0) {
                        break;
                    }
                    p =  &(p[1]);
                }
                p =  *p & 255;
                __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                __eax = __al & 255;
                if(__eax != 0) {
L29:
                    a = a->shape & 255;
                    if(__al == 4) {
                        __eax = max;
                        if(max <= i) {
                            if(i == 0) {
                                __eax = 6;
                            } else {
                                __eax = i;
                                __eax = i + i;
                            }
                            max = __eax;
                            max = max + 2;
                            __eax = max + 2 + max + 2;
                            __edx = max + 2 + max + 2;
                            __eax = a;
                            __eax = a->coords;
                            _v40 = max + 2 + max + 2;
                             *__esp = __eax;
                            GC_realloc();
                            __edx = __eax;
                            __eax = a;
                            a->coords = __edx;
                        }
                        a = a->ncoords;
                        __edx = a->ncoords + 1;
                        __eax = a;
                        a->ncoords = a->ncoords + 1;
                    }
                    a = a->coords;
                    i = i + i;
                    __eax = p;
                     *__esp = p;
                    atoi();
                     *((short*)(a->coords + i + i)) = __ax;
                    i = i + 1;
                    p =  *p & 255;
                    if(__al == 45) {
L38:
                        p =  &(p[1]);
                        goto L41;
                    } else {
                        p =  *p & 255;
                        if(__al != 43) {
                            while(1) {
L41:
                                p =  *p & 255;
                                __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                                __eax = __al & 255;
                                if(__eax == 0) {
                                    break;
                                }
                                p =  &(p[1]);
                            }
                            p =  *p & 255;
                            if(__al == 44) {
                                while(1) {
L48:
                                    p =  *p & 255;
                                    __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                                    __eax = __al & 255;
                                    if(__eax == 0) {
                                        break;
                                    }
                                    p =  &(p[1]);
                                }
                                p =  *p & 255;
                                if(__al == 44) {
                                    p =  &(p[1]);
                                }
                                continue;
                            }
                            p =  *p & 255;
                            __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                            __eax = __al & 255;
                            if(__eax != 0) {
                                goto L48;
                            }
                            break;
                        }
                        goto L38;
                    }
                }
                p =  *p & 255;
                if(__al == 45) {
                    goto L29;
                }
                p =  *p & 255;
                if(__al != 43) {
                    break;
                }
                goto L29;
            }
            break;
        }
        if(a->ncoords != i || (a->shape & 255) == 4 && a->ncoords <= 5) {
            a->shape = 0;
            a->coords = 0;
            a->ncoords = 0;
            return a;
        } else {
            if((a->shape & 255) == 4) {
                a->ncoords = ((a->ncoords >> 31) + a->ncoords >> 1) + ((a->ncoords >> 31) + a->ncoords >> 1);
                 *((short*)(a->coords + a->ncoords + a->ncoords)) =  *(a->coords) & 65535;
                 *((short*)(a->coords + a->ncoords + 1 + a->ncoords + 1)) =  *(a->coords + 2) & 65535;
            }
            if((a->shape & 255) != 3) {
                i = 0;
                while((a->ncoords >> 31) + a->ncoords >> 1 > i) {
                    a->center_x = (a->center_x & 65535) + ( *(a->coords + (i << 2)) & 65535);
                    a->center_y = (a->center_y & 65535) + ( *(a->coords + i + i + 1 + i + i + 1) & 65535);
                    i = i + 1;
                }
                a->center_x = (a->center_x & 65535) / ((a->ncoords >> 31) + a->ncoords >> 1);
                a->center_y = (a->center_y & 65535) / ((a->ncoords >> 31) + a->ncoords >> 1);
                goto L68;
            } else {
                a->center_x =  *(a->coords) & 65535;
                a->center_y =  *(a->coords + 2) & 65535;
L68:
                return a;
            }
        }
    }
    a->shape = 0;
    return a;
}

void append_map_info(Buffer* buf, Str tmp, FormItemList* fi)
{// addr = 0x0808EFA6  --  defined in 'map.c' at line 399
    MapList* ml;       // _cfa_fffffff0
    ListItem* al;     // _cfa_ffffffec
    MapArea* a;        // _cfa_ffffffe8
    char* p;                               // _cfa_ffffffe4
    char* q;                               // _cfa_ffffffe0
    ParsedURL pu;    // _cfa_ffffffb8
    char* _v92;                            // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    char* _v100;                           // _cfa_ffffff9c
    char* _v104;                           // _cfa_ffffff98
    intOrPtr _v108;                        // _cfa_ffffff94
    char* _v112;                           // _cfa_ffffff90
    char* _v116;                           // _cfa_ffffff8c (outparam)
    char* _v120;                           // _cfa_ffffff88 (outparam)
    char* _t57;                            // _t57
    char* _t82;                            // _t82
    char* _t83;                            // _t83

    if(fi->value == 0) {
        _t57 = 0;
    } else {
        _t57 =  *(fi->value);
    }
    ml = searchMapList(buf, _t57);
    if(ml != 0) {
        _v112 = 0;
        _v116 = "<tr valign=top><td colspan=2><table>";
        _v120 = "<tr valign=top><td colspan=2>Links of current image map";
        Strcat_m_charp(tmp);
        al = ml->area->first;
        while(al != 0) {
            a = al->ptr;
            if(a != 0) {
                parseURL2(a->url,  &pu, baseURL(buf));
                q = html_quote( *(parsedURL2Str( &pu)));
                if(DecodeURL == 0) {
                    p = html_quote(a->url);
                } else {
                    p = html_quote(url_unquote_conv(a->url, buf->document_charset));
                }
                if((a & 255) == 0) {
                    _t82 = mybasename(a->url);
                } else {
                    _t82 = a->alt;
                }
                _t83 = html_quote(_t82);
                _v92 = 0;
                _v96 = 135052180;
                _v100 = p;
                _v104 = "</a><td>";
                _v108 = _t83;
                _v112 = "">";
                _v116 = q;
                _v120 = "<tr valign=top><td>&nbsp;&nbsp;<td><a href="";
                Strcat_m_charp(tmp);
            }
            al = al->next;
        }
        Strcat_charp(tmp, "</table>");
        return;
    }
}

void append_link_info(Buffer* buf, Str html, LinkList* link)
{// addr = 0x0808F13E  --  defined in 'map.c' at line 434
    LinkList* l;      // _cfa_fffffff0
    char* url;                             // _cfa_ffffffec
    ParsedURL pu;    // _cfa_ffffffc4
    char* _v68;                            // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    char* _v76;                            // _cfa_ffffffb4
    char* _v80;                            // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac (outparam)
    char* _v88;                            // _cfa_ffffffa8 (outparam)
    char* _t72;                            // _t72
    char* _t95;                            // _t95

    if(link == 0) {
        return;
    }
    Strcat_charp(html, "<hr width=50%><h1>Link information</h1><table>\n");
    l = link;
    while(l != 0) {
        if(l->url == 0) {
            url = "(empty)";
        } else {
            parseURL2(l->url,  &pu, baseURL(buf));
            url = html_quote( *(parsedURL2Str( &pu)));
        }
        if(l->title == 0) {
            _t72 = "(empty)";
        } else {
            _t72 = html_quote(l->title);
        }
        _v68 = 0;
        _v72 = "</a><td>";
        _v76 = _t72;
        _v80 = "">";
        _v84 = url;
        _v88 = "<tr valign=top><td><a href="";
        Strcat_m_charp(html);
        if((l->type & 255) != 1) {
            if((l->type & 255) == 2) {
                Strcat_charp(html, "[Rev]");
            }
        } else {
            Strcat_charp(html, "[Rel]");
        }
        if(l->url != 0) {
            if(DecodeURL == 0) {
                url = html_quote(l->url);
            } else {
                url = html_quote(url_unquote_conv(l->url, buf->document_charset));
            }
        } else {
            url = "(empty)";
        }
        _v80 = 0;
        _v84 = url;
        _v88 = "<td>";
        Strcat_m_charp(html);
        if(l->ctype != 0) {
            _t95 = html_quote(l->ctype);
            _v76 = 0;
            _v80 = 135052354;
            _v84 = _t95;
            _v88 = 135052356;
            Strcat_m_charp(html);
        }
        Strcat_charp(html, 135052180);
        l = l->next;
    }
    Strcat_charp(html, "</table>\n");
}

void append_frame_info(Buffer* buf, Str html, struct frameset* set, int level)
{// addr = 0x0808F33D  --  defined in 'map.c' at line 474
    char* p;                               // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    int j;                                 // _cfa_ffffffe4
    union frameset_element frame;   // _cfa_ffffffe0
    int _v60;                              // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0 (outparam)
    char* _v68;                            // _cfa_ffffffbc (outparam)
    char* _v72;                            // _cfa_ffffffb8 (outparam)
    signed int _t80;                       // _t80

    if(set != 0) {
        i = 0;
        while(set->row * set->col > i) {
            frame = set->frame[i];
            if(frame == 0) {
L19:
                i = i + 1;
                continue;
            }
            _t80 =  *frame & 255;
            if(_t80 < 0) {
                goto L19;
            }
            if(_t80 <= 1) {
                if( *(frame + 8) == 0) {
                    goto L19;
                }
                Strcat_charp(html, "<pre_int>");
                j = 0;
                while(j < level) {
                    Strcat_charp(html, "   ");
                    j = j + 1;
                }
                q = html_quote( *(frame + 8));
                _v60 = 0;
                _v64 = "">";
                _v68 = q;
                _v72 = "<a href="";
                Strcat_m_charp(html);
                if( *(frame + 4) != 0) {
                    p = html_quote(url_unquote_conv( *(frame + 4), buf->document_charset));
                    Strcat_charp(html, p);
                }
                if(DecodeURL == 0) {
                    p = q;
                } else {
                    p = html_quote(url_unquote_conv( *(frame + 8), buf->document_charset));
                }
                _v60 = 0;
                _v64 = "</a></pre_int><br>\n";
                _v68 = p;
                _v72 = 135052413;
                Strcat_m_charp(html);
                goto L19;
            }
            if(_t80 == 2) {
                append_frame_info(buf, html, frame, level + 1);
            }
            goto L19;
        }
        return;
    }
}

Buffer* page_info_panel(Buffer* buf)
{// addr = 0x0808F50B  --  defined in 'map.c' at line 526
    signed int _v32;                       // _cfa_ffffffe0
    char[15] charset;                      // _cfa_ffffffd0
    Str tmp;               // _cfa_ffffffcc
    Anchor* a;          // _cfa_ffffffc8
    TextListItem* ti;   // _cfa_ffffffc4
    struct frameset* f_set;   // _cfa_ffffffc0
    int all;                               // _cfa_ffffffbc
    char* p;                               // _cfa_ffffffb8
    char* q;                               // _cfa_ffffffb4
    wc_ces_list* list;   // _cfa_ffffffb0
    Buffer* newbuf;     // _cfa_ffffffac
    FormItemList* fi;   // _cfa_ffffffa8
    ParsedURL pu;    // _cfa_ffffff80
    Buffer* _v144;      // _cfa_ffffff70
    int _v164;                             // _cfa_ffffff5c
    char* _v168;                           // _cfa_ffffff58
    char* _v172;                           // _cfa_ffffff54
    char* _v176;                           // _cfa_ffffff50
    int _v180;                             // _cfa_ffffff4c
    char* _v184;                           // _cfa_ffffff48
    char* _v188;                           // _cfa_ffffff44
    char* _v192;                           // _cfa_ffffff40 (outparam)
    char[15]* _v196;                       // _cfa_ffffff3c (outparam)
    char* _v200;                           // _cfa_ffffff38 (outparam)
    _unknown_ __ebx;                       // r1
    char* __edi;                           // r4
    char* _t257;                           // _t257
    char* _t260;                           // _t260
    char** _t266;                          // _t266
    char[15]** _t268;                      // _t268
    Buffer* _t294;      // _t294
    char[15]* _t317;                       // _t317
    char[15]* _t337;                       // _t337
    char* _t395;                           // _t395
    char* _t410;                           // _t410
    char* _t421;                           // _t421

    _v144 = buf;
    _v32 =  *gs:0x14];
    tmp = Strnew_size(1024);
    f_set = 0;
    Strcat_charp(tmp, "<html><head><title>Information about current page</title></head><body><h1>Information about current page</h1>\n");
    if(_v144 == 0) {
        goto L48;
    } else {
        all = _v144->allLine;
        if(all == 0) {
            if(_v144->lastLine != 0) {
                all = _v144->lastLine->linenumber;
            }
        }
        Strcat_charp(tmp, "<form method=internal action=charset>");
        p =  *(parsedURL2Str( &(_v144->currentURL)));
        if(DecodeURL != 0) {
            p = url_unquote_conv(p, 0);
        }
        __edi = html_quote(last_modified(_v144));
        if(_v144->real_type == 0) {
            _t410 = "unknown";
        } else {
            _t410 = html_quote(_v144->real_type);
        }
        _t257 = html_quote(p);
        _t260 = html_quote(_v144->buffername);
        _v164 = 0;
        _v168 = __edi;
        _v172 = "<tr valign=top><td nowrap>Last Modified<td>";
        _v176 = _t410;
        _v180 = "<tr valign=top><td nowrap>Document Type<td>";
        _v184 = _t257;
        _v188 = "<tr valign=top><td nowrap>Current URL<td>";
        _v192 = _t260;
        _v196 = "<tr valign=top><td nowrap>Title<td>";
        _v200 = "<table cellpadding=0>";
        Strcat_m_charp(tmp);
        if(_v144->document_charset == InnerCharset) {
L17:
            _v200 = _v144->trbyte;
            _t266 = Sprintf("%d");
            _v200 = all;
            _t268 = Sprintf("%d");
            _v184 = 0;
            _v188 =  *_t266;
            _v192 = "<tr valign=top><td nowrap>Transferred bytes<td>";
            _v196 =  *_t268;
            _v200 = "<tr valign=top><td nowrap>Number of lines<td>";
            Strcat_m_charp(tmp);
            a = retrieveCurrentAnchor(_v144);
            if(a != 0) {
                parseURL2(a->url,  &pu, baseURL(_v144));
                p =  *(parsedURL2Str( &pu));
                q = html_quote(p);
                if(DecodeURL == 0) {
                    p = q;
                } else {
                    p = html_quote(url_unquote_conv(p, _v144->document_charset));
                }
                _v180 = 0;
                _v184 = "</a>";
                _v188 = p;
                _v192 = "">";
                _v196 = q;
                _v200 = "<tr valign=top><td nowrap>URL of current anchor<td><a href="";
                Strcat_m_charp(tmp);
            }
            a = retrieveCurrentImg(_v144);
            if(a != 0) {
                parseURL2(a->url,  &pu, baseURL(_v144));
                p =  *(parsedURL2Str( &pu));
                q = html_quote(p);
                if(DecodeURL == 0) {
                    p = q;
                } else {
                    p = html_quote(url_unquote_conv(p, _v144->document_charset));
                }
                _v180 = 0;
                _v184 = "</a>";
                _v188 = p;
                _v192 = "">";
                _v196 = q;
                _v200 = "<tr valign=top><td nowrap>URL of current image<td><a href="";
                Strcat_m_charp(tmp);
            }
            a = retrieveCurrentForm(_v144);
            if(a != 0) {
                fi = a->url;
                p = form2str(fi);
                if(DecodeURL == 0) {
                    p = html_quote(p);
                } else {
                    p = html_quote(url_unquote_conv(p, _v144->document_charset));
                }
                _v192 = 0;
                _v196 = p;
                _v200 = "<tr valign=top><td nowrap>Method/type of current form&nbsp;<td>";
                Strcat_m_charp(tmp);
                if(fi->parent->method == 2) {
                    _t337 =  *(fi->parent->action);
                    _v200 = 135052056;
                     *__esp = _t337;
                    strcmp();
                    if(_t337 == 0) {
                        append_map_info(_v144, tmp, fi->parent->item);
                    }
                }
            }
            Strcat_charp(tmp, "</table>\n");
            Strcat_charp(tmp, "</form>");
            append_link_info(_v144, tmp, _v144->linklist);
            if(_v144->document_header == 0) {
L39:
                if(_v144->frameset == 0) {
                    if((_v144->bufferprop & 2) != 0 && _v144->nextBuffer != 0 && _v144->nextBuffer->frameset != 0) {
                        f_set = _v144->nextBuffer->frameset;
                    }
                } else {
                    f_set = _v144->frameset;
                }
                if(f_set != 0) {
                    Strcat_charp(tmp, "<hr width=50%><h1>Frame information</h1>\n");
                    append_frame_info(_v144, tmp, f_set, 0);
                }
L48:
                Strcat_charp(tmp, "</body></html>");
                newbuf = loadHTMLString(tmp);
                if(newbuf != 0) {
                    newbuf->document_charset = _v144->document_charset;
                }
                _t294 = newbuf;
                if((_v32 ^  *gs:0x14]) == 0) {
                    return _t294;
                } else {
                    __stack_chk_fail();
                    return _t294;
                }
            } else {
                Strcat_charp(tmp, "<hr width=50%><h1>Header information</h1><pre>\n");
                ti =  *(_v144->document_header);
                while(ti != 0) {
                    _t317 = html_quote(ti->ptr);
                    _v188 = 0;
                    _v192 = "</pre_int>\n";
                    _v196 = _t317;
                    _v200 = "<pre_int>";
                    Strcat_m_charp(tmp);
                    ti = ti->next;
                }
                Strcat_charp(tmp, "</pre>\n");
                goto L39;
            }
        } else {
            list = wc_get_ces_list();
            Strcat_charp(tmp, "<tr><td nowrap>Document Charset<td><select name=charset>");
            while(list->name != 0) {
                _v196 = list->id;
                _v200 = "%d";
                 *__esp =  &charset;
                sprintf();
                _t421 = list->desc;
                if(_v144->document_charset != list->id) {
                    _t395 = 135052839;
                } else {
                    _t395 = " selected>";
                }
                _v184 = 0;
                _v188 = _t421;
                _v192 = _t395;
                _v196 =  &charset;
                _v200 = "<option value=";
                Strcat_m_charp(tmp);
                list = list + 12;
            }
            Strcat_charp(tmp, "</select>");
            Strcat_charp(tmp, "<tr><td><td><input type=submit value=Change>");
            goto L17;
        }
    }
}

void KeyAbort(int _dummy)
{// addr = 0x0808FC0C  --  defined in 'frame.c' at line 12
    signed char* _v0;                      // _cfa_0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed char* _v28;                     // _cfa_ffffffe4
    signed char* _v32;                     // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v44;                       // _cfa_ffffffd4
    intOrPtr _v80;                         // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    _unknown_ __ebx;                       // r1
    signed int _t57;                       // _t57
    signed int _t61;                       // _t61
    signed int _t64;                       // _t64
    signed int _t70;                       // _t70
    signed int _t88;                       // _t88
    _unknown_ _t94;                        // _t94

    _v24 = 1;
     *__esp =  &AbortLoading;
    siglongjmp();
    _push(_t94);
    _push(_t89);
    __esp = __esp - 52;
    _v44 = 1;
    if(_v24 == 0) {
        _v0 = 135053360;
    } else {
        _v28 = _v0;
        while(1) {
            _v84 = 44;
            _t88 = _v28;
             *__esp = _t88;
            strchr();
            _v28 = _t88;
            if(_v28 == 0) {
                break;
            }
            _v20 = _v20 + 1;
            _v28 =  &(_v28[1]);
        }
    }
    _t57 = _v20 << 2;
     *__esp = _t57;
    GC_malloc();
    _v36 = _t57;
    _v20 = 0;
    _v28 = _v0;
L9:
    while(( *_v28 & 255) == 0 || ( *( &MYCTYPE_MAP + ( *_v28 & 0xff)) & 2) == 0) {
        _t61 = _v28;
        _v80 = 10;
        _v84 =  &_v32;
         *__esp = _t61;
        strtol();
        _v24 = _t61;
        _t64 =  *_v32 & 255;
        if(_t64 == 37) {
            _t89 = (_v20 << 2) + _v36;
            _v84 = _v24;
             *((_v20 << 2) + _v36) =  *(Sprintf(135053362));
            _v20 = _v20 + 1;
        } else {
            if(_t64 == 42) {
                 *((_v20 << 2) + _v36) = 135053360;
                _v20 = _v20 + 1;
            } else {
                _t89 = (_v20 << 2) + _v36;
                _v84 = _v24;
                 *((_v20 << 2) + _v36) =  *(Sprintf(135053367));
                _v20 = _v20 + 1;
            }
        }
        _t70 = _v32;
        _v84 = 44;
         *__esp = _t70;
        strchr();
        _v28 = _t70;
        if(_v28 != 0) {
            _v28 =  &(_v28[1]);
            continue;
        }
         *_dummy = _v36;
        __esp =  &(__esp[0xd]);
        _pop(__ebx);
        return;
    }
    _v28 = _v28 + 1;
    goto L9;
}

int parseFrameSetLength(char* s, char*** ret)
{// addr = 0x0808FC26  --  defined in 'frame.c' at line 18
    int i;                                 // _cfa_fffffff0
    int len;                               // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    char* q;                               // _cfa_ffffffe4
    char** lv;                             // _cfa_ffffffe0
    intOrPtr _v52;                         // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    char** _t56;                           // _t56
    int _t60;                              // _t60
    signed int _t63;                       // _t63
    char* _t69;                            // _t69
    char* _t87;                            // _t87

    i = 1;
    if(s == 0) {
        s = 135053360;
L6:
        _t56 = i << 2;
         *__esp = _t56;
        GC_malloc();
        lv = _t56;
        i = 0;
        p = s;
L8:
        while(( *p & 255) == 0 || ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
            _t60 = p;
            _v52 = 10;
            _v56 =  &q;
             *__esp = _t60;
            strtol();
            len = _t60;
            _t63 =  *q & 255;
            if(_t63 == 37) {
                _v56 = len;
                lv[i] =  *(Sprintf(135053362));
                i = i + 1;
            } else {
                if(_t63 == 42) {
                    lv[i] = 135053360;
                    i = i + 1;
                } else {
                    _v56 = len;
                    lv[i] =  *(Sprintf(135053367));
                    i = i + 1;
                }
            }
            _t69 = q;
            _v56 = 44;
             *__esp = _t69;
            strchr();
            p = _t69;
            if(p != 0) {
                p =  &(p[1]);
                continue;
            } else {
                 *ret = lv;
                return i;
            }
        }
        p =  &(p[1]);
        goto L8;
    }
    p = s;
    while(1) {
        _v56 = 44;
        _t87 = p;
         *__esp = _t87;
        strchr();
        p = _t87;
        if(p == 0) {
            break;
        }
        i = i + 1;
        p =  &(p[1]);
    }
    goto L6;
}

struct frameset* newFrameSet(struct parsed_tag* tag)
{// addr = 0x0808FD83  --  defined in 'frame.c' at line 58
    struct frameset* f;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    char* cols;                            // _cfa_ffffffe8
    char* rows;                            // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    union frameset_element* _t68;   // _t68

    cols = 0;
    rows = 0;
     *__esp = 36;
    GC_malloc();
    f = __eax;
    f->attr = 2;
    f->name = 0;
    f->currentURL = 0;
    parsedtag_get_value(tag, 13,  &cols);
    parsedtag_get_value(tag, 28,  &rows);
    f->col = parseFrameSetLength(cols,  &(f->width));
    f->row = parseFrameSetLength(rows,  &(f->height));
    f->i = 0;
    i = f->col * f->row;
    _t68 = i << 2;
     *__esp = _t68;
    GC_malloc();
    f->frame = _t68;
    do {
        i = i - 1;
        f->frame[i] = 0;
    } while(i != 0);
    return f;
}

struct frame_body* newFrame(struct parsed_tag* tag, Buffer* buf)
{// addr = 0x0808FE7F  --  defined in 'frame.c' at line 82
    struct frame_body* body;   // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    struct frame_body* _v40;   // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5

     *__esp = 36;
    GC_malloc();
    body = __eax;
    _v40 = 36;
     *__esp = body;
    bzero();
    body->attr = 0;
    body->flags = 0;
    body->baseURL = baseURL(buf);
    if(tag == 0) {
L6:
        return body;
    }
    if(parsedtag_get_value(tag, 31,  &p) != 0) {
        body->url = url_quote( *(wc_Str_conv_strict(Strnew_charp(remove_space(p)), InnerCharset, buf->document_charset)));
    }
    if(parsedtag_get_value(tag, 25,  &p) != 0 && ( *p & 255) != 95) {
        body->name = url_quote( *(wc_Str_conv_strict(Strnew_charp(p), InnerCharset, buf->document_charset)));
    }
    goto L6;
}

void unloadFrame(struct frame_body* b)
{// addr = 0x0808FF9D  --  defined in 'frame.c' at line 102
    b->attr = 0;
}

void deleteFrame(struct frame_body* b)
{// addr = 0x0808FFA8  --  defined in 'frame.c' at line 108
    intOrPtr _v24;                         // _cfa_ffffffe8

    if(b != 0) {
        unloadFrame(b);
        _v24 = 36;
         *__esp = b;
        bzero();
        return;
    }
}

void addFrameSetElement(struct frameset* f, union frameset_element element)
{// addr = 0x0808FFD7  --  defined in 'frame.c' at line 117
    int i;                                 // _cfa_fffffff8

    if(f == 0) {
        return;
    }
    i = f->i;
    if(f->row * f->col > i) {
        f->frame[i] = element;
        f->i = f->i + 1;
        return;
    }
}

void deleteFrameSet(struct frameset* f)
{// addr = 0x0809002B  --  defined in 'frame.c' at line 131
    int i;                                 // _cfa_fffffff0

    if(f != 0) {
        i = 0;
        while(f->row * f->col > i) {
            deleteFrameSetElement(f->frame[i]);
            i = i + 1;
        }
        f->name = 0;
        f->currentURL = 0;
        return;
    }
}

void deleteFrameSetElement(union frameset_element e)
{// addr = 0x0809008A  --  defined in 'frame.c' at line 146
    signed int _t8;                        // _t8

    if(e != 0) {
        _t8 =  *e & 255;
        if(_t8 == 1) {
            deleteFrame(e);
L8:
            return;
        }
        if(_t8 == 2) {
            deleteFrameSet(e);
            return;
        }
        if(_t8 == 0) {
            goto L8;
        }
        return;
    }
}

struct frame_body* copyFrame(struct frame_body* ob)
{// addr = 0x080900D1  --  defined in 'frame.c' at line 166
    struct frame_body* rb;   // _cfa_fffffff0
    struct frame_body* _v36;   // _cfa_ffffffdc
    struct frame_body* _v40;   // _cfa_ffffffd8

     *__esp = 36;
    GC_malloc();
    rb = __eax;
    _v36 = 36;
    _v40 = rb;
     *__esp = ob;
    bcopy();
    return rb;
}

struct frameset* copyFrameSet(struct frameset* of)
{// addr = 0x08090105  --  defined in 'frame.c' at line 176
    struct frameset* rf;   // _cfa_fffffff0
    int n;                                 // _cfa_ffffffec
    signed int _v36;                       // _cfa_ffffffdc
    char** _v40;                           // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    char** _t76;                           // _t76
    char** _t85;                           // _t85
    union frameset_element* _t93;   // _t93
    signed int _t104;                      // _t104

     *__esp = 36;
    GC_malloc();
    rf = __eax;
    n = of->row * of->col;
    _v36 = 36;
    _v40 = rf;
     *__esp = of;
    bcopy();
    _t76 = rf->col << 2;
     *__esp = _t76;
    GC_malloc();
    rf->width = _t76;
    _v36 = rf->col * 4;
    _v40 = rf->width;
     *__esp = of->width;
    bcopy();
    _t85 = rf->row << 2;
     *__esp = _t85;
    GC_malloc();
    rf->height = _t85;
    _v36 = rf->row * 4;
    _v40 = rf->height;
     *__esp = of->height;
    bcopy();
    _t93 = n << 2;
     *__esp = _t93;
    GC_malloc();
    rf->frame = _t93;
    while(n != 0) {
        n = n - 1;
        if(of->frame[n] == 0) {
            goto L9;
        } else {
            _t104 =  *(of->frame[n]) & 255;
            if(_t104 < 0) {
L9:
                rf->frame[n] = 0;
            } else {
                if(_t104 <= 1) {
                    rf->frame[n] = copyFrame(of->frame[n]);
                } else {
                    if(_t104 == 2) {
                        rf->frame[n] = copyFrameSet(of->frame[n]);
                    } else {
                        goto L9;
                    }
                }
            }
        }
    }
    return rf;
}

void flushFrameSet(struct frameset* fs)
{// addr = 0x080902A2  --  defined in 'frame.c' at line 213
    int n;                                 // _cfa_fffffff0
    _unknown_ _t31;                        // _t31

    n = fs->i;
    do {
    } while(n != 0);
}

void pushFrameTree(struct frameset_queue** fqpp, struct frameset* fs, Buffer* buf)
{// addr = 0x0809032D  --  defined in 'frame.c' at line 238
    struct frameset_queue* rfq;   // _cfa_fffffff0
    struct frameset_queue* cfq;   // _cfa_ffffffec
    struct frameset_queue* _t56;   // _t56
    long int _t57;                         // _t57
    long int _t58;                         // _t58
    int _t59;                              // _t59
    int _t60;                              // _t60
    struct _anchorList* _t61;   // _t61

    _t56 =  *fqpp;
    cfq = _t56;
    if(fs == 0) {
        return;
    }
     *__esp = 32;
    GC_malloc();
    rfq = _t56;
    if(buf == 0 || buf->currentLine == 0) {
        _t57 = 1;
    } else {
        _t57 = buf->currentLine->linenumber;
    }
    rfq->linenumber = _t57;
    if(buf == 0 || buf->topLine == 0) {
        _t58 = 1;
    } else {
        _t58 = buf->topLine->linenumber;
    }
    rfq->top_linenumber = _t58;
    if(buf == 0) {
        _t59 = 0;
    } else {
        _t59 = buf->pos;
    }
    rfq->pos = _t59;
    if(buf == 0) {
        _t60 = 0;
    } else {
        _t60 = buf->currentColumn;
    }
    rfq->currentColumn = _t60;
    if(buf == 0) {
        _t61 = 0;
    } else {
        _t61 = buf->formitem;
    }
    rfq->formitem = _t61;
    rfq->back = cfq;
    if(cfq == 0) {
        rfq->next = cfq;
    } else {
        rfq->next = cfq->next;
        if(cfq->next != 0) {
            cfq->next->back = rfq;
        }
        cfq->next = rfq;
    }
    rfq->frameset = fs;
     *fqpp = rfq;
}

struct frameset* popFrameTree(struct frameset_queue** fqpp)
{// addr = 0x08090441  --  defined in 'frame.c' at line 268
    struct frameset_queue* rfq;   // _cfa_fffffff0
    struct frameset_queue* cfq;   // _cfa_ffffffec
    struct frameset* rfs;   // _cfa_ffffffe8
    intOrPtr _v40;                         // _cfa_ffffffd8

    rfq = 0;
    cfq =  *fqpp;
    rfs = 0;
    if(cfq != 0) {
        rfs = cfq->frameset;
        if(cfq->next != 0) {
            rfq = cfq->next;
            rfq->back = cfq->back;
        }
        if(cfq->back != 0) {
            rfq = cfq->back;
            rfq->next = cfq->next;
        }
         *fqpp = rfq;
        _v40 = 32;
         *__esp = cfq;
        bzero();
        return rfs;
    }
    return rfs;
}

void resetFrameElement(union frameset_element* f_element, Buffer* buf, char* referer, FormList* request)
{// addr = 0x080904CB  --  defined in 'frame.c' at line 289
    char* f_name;                          // _cfa_fffffff0
    struct frame_body* f_body;   // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    f_name =  *( *f_element + 4);
    if(buf->frameset == 0) {
        f_body = newFrame(0, buf);
        f_body->attr = 1;
        f_body->name = f_name;
        f_body->url =  *(parsedURL2Str( &(buf->currentURL)));
        f_body->source = buf->sourcefile;
        buf->sourcefile = 0;
        if(buf->mailcap_source != 0) {
            f_body->source = buf->mailcap_source;
            buf->mailcap_source = 0;
        }
        f_body->type = buf->type;
        f_body->referer = referer;
        f_body->request = request;
        deleteFrameSetElement( *f_element);
         *f_element = f_body;
        return;
    }
    deleteFrameSetElement( *f_element);
     *f_element = buf->frameset;
    _t92 = f_element;
     *__esp = 40;
    GC_malloc();
     *( *_t92 + 8) = f_element;
    copyParsedURL( *( *f_element + 8),  &(buf->currentURL));
    buf->frameset = popFrameTree( &(buf->frameQ));
     *( *f_element + 4) = f_name;
}

struct frameset* frame_download_source(struct frame_body* b, ParsedURL* currentURL, ParsedURL* baseURL, int flag)
{// addr = 0x0809061A  --  defined in 'frame.c' at line 325
    Buffer* buf;        // _cfa_fffffff0
    struct frameset* ret_frameset;   // _cfa_ffffffec
    ParsedURL url;   // _cfa_ffffffc4
    FormList* _v76;   // _cfa_ffffffb4
    signed int _v80;                       // _cfa_ffffffb0
    _unknown_ _v84;                        // _cfa_ffffffac (outparam)
    _unknown_ _v88;                        // _cfa_ffffffa8 (outparam)
    FormList* __ebx;   // r1
    _unknown_ __esi;                       // r5
    _None _t102;                           // _t102
    ParsedURL* _t128;   // _t128
    signed int _t156;                      // _t156

    ret_frameset = 0;
    if(b == 0 || b->url == 0 || (b & 255) == 0) {
        return 0;
    }
    if(b->baseURL != 0) {
        baseURL = b->baseURL;
    }
    parseURL2(b->url,  &url, currentURL);
    if(url.scheme == 4) {
        b->flags = 0;
    }
    is_redisplay = 1;
    w3m_dump = w3m_dump | 32;
    __ebx = b->request;
    _t156 = flag | 4;
    __ecx = b->referer;
    if(baseURL == 0) {
        _t102 = currentURL;
    } else {
        _t102 = baseURL;
    }
    _v76 = __ebx;
    _v80 = _t156;
    buf = loadGeneralFile(b->url, _t102, __ecx);
    w3m_dump = w3m_dump & -33;
    is_redisplay = 0;
    if(buf == 0 || buf == 1) {
        b->source = 0;
        b->flags = buf == 1;
        return 0;
    } else {
        b->url =  *(parsedURL2Str( &(buf->currentURL)));
        b->type = buf->type;
        b->source = buf->sourcefile;
        buf->sourcefile = 0;
        if(buf->mailcap_source != 0) {
            b->source = buf->mailcap_source;
            buf->mailcap_source = 0;
        }
        b->attr = 1;
        if(buf->frameset != 0) {
            ret_frameset = buf->frameset;
            _t128 = ret_frameset;
            _t128->user = b->name;
             *__esp = 40;
            GC_malloc();
            ret_frameset->currentURL = _t128;
            copyParsedURL(ret_frameset->currentURL,  &(buf->currentURL));
            buf->frameset = popFrameTree( &(buf->frameQ));
        }
        discardBuffer(buf);
        return ret_frameset;
    }
}

int createFrameFile(struct frameset* f, FILE* f1, Buffer* current, int level, int force_reload)
{// addr = 0x0809081D  --  defined in 'frame.c' at line 402
    wc_ces c;           // _cfa_ffffff68
    Str s_tmp;             // _cfa_ffffff70
    int refresh_interval;                  // _cfa_ffffff6c
    int r;                                 // _cfa_ffffffe0
    int c;                                 // _cfa_ffffffdc
    int t_stack;                           // _cfa_ffffffd8
    wc_ces charset;     // _cfa_ffffffd4
    wc_ces doc_charset;   // _cfa_ffffffd0
    char* d_target;                        // _cfa_ffffffcc
    char* p_target;                        // _cfa_ffffffc8
    char* s_target;                        // _cfa_ffffffc4
    char* t_target;                        // _cfa_ffffffc0
    ParsedURL* currentURL;   // _cfa_ffffffbc
    _None prevtrap;                        // _cfa_ffffffb8
    int flag;                              // _cfa_ffffffb4
    union frameset_element frame;   // _cfa_ffffffb0
    struct frameset* f_frameset;   // _cfa_ffffffac
    int i;                                 // _cfa_ffffffa8
    char* p;                               // _cfa_ffffffa4
    int status;                            // _cfa_ffffffa0
    Str tok;               // _cfa_ffffff9c
    int pre_mode;                          // _cfa_ffffff98
    int end_tag;                           // _cfa_ffffff94
    Str tmp;               // _cfa_ffffff90
    int is_tag;                            // _cfa_ffffff8c
    char* q;                               // _cfa_ffffff88
    struct parsed_tag* tag;   // _cfa_ffffff84
    Str tmp;               // _cfa_ffffff80
    char* q;                               // _cfa_ffffff7c
    int j;                                 // _cfa_ffffff78
    int a_target;                          // _cfa_ffffff74
    union input_stream* _v180;   // _cfa_ffffff4c
    URLFile f2;        // _cfa_ffffff48
    ParsedURL base;   // _cfa_ffffff20
    ParsedURL url;   // _cfa_fffffef8
    _unknown_ _v284;                       // _cfa_fffffee4 (outparam)
    FILE* _v288;          // _cfa_fffffee0 (outparam)
    int _v292;                             // _cfa_fffffedc (outparam)
    char* _v296;                           // _cfa_fffffed8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ _t539;                       // _t539
    ParsedURL* _t544;   // _t544
    signed int _t566;                      // _t566
    char* _t578;                           // _t578
    FILE** _t634;         // _t634
    FILE* _t642;          // _t642
    FILE* _t645;          // _t645
    signed int _t667;                      // _t667
    signed int _t668;                      // _t668
    FILE* _t725;          // _t725
    FILE* _t729;          // _t729
    char* _t774;                           // _t774
    char* _t777;                           // _t777
    FILE* _t843;          // _t843
    FILE* _t855;          // _t855
    char* _t871;                           // _t871
    int _t917;                             // _t917

    prevtrap = 0;
    if(f == 0) {
        return -1;
    }
    if(level == 0) {
        _v296 = 1;
         *__esp =  &AbortLoading;
        __sigsetjmp();
        if(_t539 != 0) {
            if((TrapSignal & 255) != 0) {
                if((fmInitialized & 255) != 0) {
                    term_raw();
                }
                if(prevtrap != 0) {
                    mySignal(2, prevtrap);
                }
            }
            return -1;
        }
        if((TrapSignal & 255) != 0) {
            prevtrap = mySignal(2, KeyAbort);
            if((fmInitialized & 255) != 0) {
                term_cbreak();
            }
        }
        f->name = 135053370;
    }
    if(level > 7) {
        _v288 = f1;
        _v292 = 26;
        _v296 = 1;
         *__esp = "Too many frameset tasked.\n";
        fwrite();
        return -1;
    }
    if(level != 0) {
        _v288 = f1;
        _v292 = 16;
        _v296 = 1;
         *__esp = "<table hborder>\n";
        fwrite();
    } else {
        _v292 = html_quote(current->buffername);
        _v296 = "<html><head><title>%s</title></head><body>\n";
         *__esp = f1;
        fprintf();
        _v288 = f1;
        _v292 = 29;
        _v296 = 1;
         *__esp = "<table hborder width="100%">\n";
        fwrite();
    }
    if(f->currentURL == 0) {
        _t544 =  &(current->currentURL);
    } else {
        _t544 = f->currentURL;
    }
    currentURL = _t544;
    r = 0;
    while(f->row > r) {
        while(f->col > c) {
            i = f->col * r + c;
            p = 135053512;
            status = 0;
            tok = Strnew();
            pre_mode = 0;
            end_tag = 0;
            frame = f->frame[i];
            if(frame != 0) {
                _v288 = f1;
                _v292 = 3;
                _v296 = 1;
                 *__esp = "<td";
                fwrite();
                if( *(frame + 4) != 0) {
                    _v292 = html_quote( *(frame + 4));
                    _v296 = " id="_%s"";
                     *__esp = f1;
                    fprintf();
                }
                if(r == 0) {
                    _v292 = f->width[c];
                    _v296 = " width="%s"";
                     *__esp = f1;
                    fprintf();
                }
                _v288 = f1;
                _v292 = 2;
                _v296 = 1;
                 *__esp = ">\n";
                fwrite();
                flag = 0;
                if(force_reload != 0) {
                    flag = flag | 1;
                    if(( *frame & 255) == 1) {
                        unloadFrame(frame);
                    }
                }
                _t566 =  *frame & 255;
                if(_t566 == 1) {
L42:
                    init_stream( &f2, 4, 0);
                    if( *(frame + 16) != 0) {
                         *__esp = f1;
                        fflush();
                        examineFile( *(frame + 16),  &f2);
                    }
                    if(_v180 != 0) {
                        parseURL2( *(frame + 8),  &base, currentURL);
                        p_target = f->name;
                        s_target =  *(frame + 4);
                        t_target = "_blank";
                        if((TargetSelf & 255) == 0) {
                            _t578 = t_target;
                        } else {
                            _t578 = s_target;
                        }
                        d_target = _t578;
                        charset = 256;
                        if(current->document_charset == 256) {
                            doc_charset = DocumentCharset;
                        } else {
                            doc_charset = current->document_charset;
                        }
                        t_stack = 0;
                        if( *(frame + 20) == 0) {
L66:
                            is_tag = 0;
                            do {
                                if(( *p & 255) != 0) {
                                    goto L70;
                                }
                                tmp = StrmyISgets(_v180);
                                if(tmp->length == 0) {
L73:
                                    if(tok->length == 0) {
                                        goto L150;
                                    }
                                    if(( *(tok->ptr) & 255) == 60) {
                                        if(( *(tok->ptr + 1) & 255) == 0 || ( *( &MYCTYPE_MAP + ( *(tok->ptr + 1) & 0xff)) & 4) == 0 && ( *(tok->ptr + 1) & 255) != 47 && ( *(tok->ptr + 1) & 255) != 33 && ( *(tok->ptr + 1) & 255) != 63 && ( *(tok->ptr + 1) & 255) != 0 && ( *(tok->ptr + 1) & 255) != 95) {
                                            if((pre_mode & 2062) == 0) {
                                                _v292 = 0;
                                                _v296 = p;
                                                p =  *(Strnew_m_charp(tok->ptr + 1));
                                                tok = Strnew_charp("&lt;");
                                            }
                                        } else {
                                            is_tag = 1;
                                        }
                                    }
                                    if(is_tag == 0) {
L106:
                                        if(is_tag == 0) {
                                            if((pre_mode & 8) == 0) {
                                                if((pre_mode & 2048) == 0) {
                                                    _v288 = f1;
                                                    _v292 = tok->length;
                                                    _v296 = 1;
                                                     *__esp = tok->ptr;
                                                    fwrite();
                                                } else {
                                                    _t642 = html_quote(html_unquote(tok->ptr));
                                                    _v296 = f1;
                                                     *__esp = _t642;
                                                    fputs();
                                                }
                                            } else {
                                                _t645 = html_quote(tok->ptr);
                                                _v296 = f1;
                                                 *__esp = _t645;
                                                fputs();
                                            }
                                            goto L148;
                                        }
                                        q = tok->ptr;
                                        a_target = 0;
                                        tag = parse_tag( &q, 0);
                                        if(tag == 0) {
                                            goto L148;
                                        }
                                        if((tag->tagid & 0xff) - 14 > 83) {
                                            j = 0;
                                            while(( *(((tag->tagid & 0xff) + (tag->tagid & 0xff) + _t983 << 2) + 135107784) & 0xff) > j) {
                                                _t667 = ( *(tag->attrid + j) & 0xff) - 3;
                                                if(_t667 <= 29) {
                                                    _t668 = 1 << _t667;
                                                    if((_t668 & 268468225) != 0) {
                                                        if( *(tag->value + (j << 2)) != 0) {
                                                             *(tag->value + (j << 2)) = url_quote( *(wc_Str_conv_strict(Strnew_charp(remove_space( *(tag->value + (j << 2)))), InnerCharset, charset)));
                                                            tag->need_reconstruct = 1;
                                                            parseURL2( *(tag->value + (j << 2)),  &url,  &base);
                                                            if(url.scheme != 255 && url.scheme != 254) {
                                                                a_target = a_target | 1;
                                                                 *(tag->value + (j << 2)) =  *(parsedURL2Str( &url));
                                                                parsedtag_set_value(tag, 71,  *(parsedURL2Str( &base)));
                                                                if(( *(tag->attrid + j) & 255) == 3) {
                                                                    if(charset != 256) {
                                                                        parsedtag_set_value(tag, 11, wc_ces_to_charset(charset));
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        if((_t668 & 4325376) != 0) {
                                                            if( *(tag->value + (j << 2)) != 0) {
                                                                parsedtag_set_value(tag, 67, s_target);
                                                            }
                                                        } else {
                                                            if((_t668 & 536870912) != 0) {
                                                                if( *(tag->value + (j << 2)) != 0) {
                                                                    a_target = a_target | 2;
                                                                    _t725 =  *(tag->value + (j << 2));
                                                                    _v296 = "_self";
                                                                     *__esp = _t725;
                                                                    strcasecmp();
                                                                    if(_t725 != 0) {
                                                                        _t729 =  *(tag->value + (j << 2));
                                                                        _v296 = "_parent";
                                                                         *__esp = _t729;
                                                                        strcasecmp();
                                                                        if(_t729 == 0) {
                                                                            parsedtag_set_value(tag, 32, p_target);
                                                                        }
                                                                    } else {
                                                                        parsedtag_set_value(tag, 32, s_target);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                j = j + 1;
                                            }
                                            if(a_target == 1) {
                                                parsedtag_set_value(tag, 32, d_target);
                                            }
                                            if((tag->need_reconstruct & 255) != 0) {
                                                tok = parsedtag2str(tag);
                                            }
                                            _v288 = f1;
                                            _v292 = tok->length;
                                            _v296 = 1;
                                             *__esp = tok->ptr;
                                            fwrite();
                                            goto L148;
                                        }
                                        goto __eax;
                                    } else {
                                        if((pre_mode & 2062) == 0) {
                                            if((pre_mode & 4096) == 0) {
                                                goto L106;
                                            }
                                            q = tok->ptr;
                                            tag = parse_tag( &q, 0);
                                            if(tag == 0) {
                                                goto L106;
                                            }
                                            if((tag->tagid & 0xff) == end_tag || (tag->tagid & 255) == 43) {
                                                if((tag->tagid & 255) == 43) {
                                                    _v288 = f1;
                                                    _v292 = 9;
                                                    _v296 = 1;
                                                     *__esp = "</SELECT>";
                                                    fwrite();
                                                }
                                                pre_mode = 0;
                                                end_tag = 0;
                                                goto L106;
                                            } else {
                                                if(t_stack == 0 || (tag->tagid & 0xff) - 31 > 59) {
                                                    goto L106;
                                                } else {
                                                    goto __eax;
                                                }
                                            }
                                        }
                                        q = tok->ptr;
                                        tag = parse_tag( &q, 0);
                                        if(tag == 0 || (tag->tagid & 0xff) != end_tag) {
                                            _t774 = tok->ptr;
                                            _v292 = 4;
                                            _v296 = "<!--";
                                             *__esp = _t774;
                                            strncmp();
                                            if(_t774 != 0) {
                                                _t777 =  &(tok->ptr[1]);
                                                _v296 = 60;
                                                 *__esp = _t777;
                                                strchr();
                                                q = _t777;
                                                if(q != 0) {
                                                    tok = Strnew_charp_n(tok->ptr, q - tok->ptr);
                                                    _v292 = 0;
                                                    _v296 = p;
                                                    p =  *(Strnew_m_charp(q));
                                                    status = 0;
                                                }
                                            }
                                            is_tag = 0;
                                            goto L106;
                                        } else {
                                            if((pre_mode & 8) == 0) {
                                                pre_mode = 0;
                                                end_tag = 0;
                                                goto L106;
                                            }
                                            _v288 = f1;
                                            _v292 = 12;
                                            _v296 = 1;
                                             *__esp = "</PRE_PLAIN>";
                                            fwrite();
                                            pre_mode = 0;
                                            end_tag = 0;
L148:
                                            Strclear(tok);
                                            goto L150;
                                        }
                                    }
                                }
                                tmp = convertLine(0, tmp, 2,  &charset, doc_charset);
                                p = tmp->ptr;
L70:
                                read_token(tok,  &p,  &status, 1, status != 0 & 255);
                            } while(status != 0);
                            goto L73;
                        } else {
                            _t843 =  *(frame + 20);
                            _v296 = "text/plain";
                             *__esp = _t843;
                            strcasecmp();
                            if(_t843 != 0) {
                                do {
                                    goto L66;
L150:
                                } while(( *p & 255) != 0 || (_v180->base.stream.cur & 255) == 0);
                                if((pre_mode & 8) == 0) {
                                    if((pre_mode & 2048) == 0) {
                                        if((pre_mode & 4096) == 0) {
                                            if((pre_mode & 6) != 0) {
                                                if(status != 0) {
                                                    _t634 = correct_irrtag(status);
                                                    _v296 = f1;
                                                     *__esp =  *_t634;
                                                    fputs();
                                                }
                                                if((pre_mode & 2) == 0) {
                                                    if((pre_mode & 4) != 0) {
                                                        _v288 = f1;
                                                        _v292 = 9;
                                                        _v296 = 1;
                                                         *__esp = "</STYLE>\n";
                                                        fwrite();
                                                    }
                                                } else {
                                                    _v288 = f1;
                                                    _v292 = 10;
                                                    _v296 = 1;
                                                     *__esp = "</SCRIPT>\n";
                                                    fwrite();
                                                }
                                            }
                                        } else {
                                            _v288 = f1;
                                            _v292 = 17;
                                            _v296 = 1;
                                             *__esp = "</SELECT></FORM>\n";
                                            fwrite();
                                        }
                                    } else {
                                        _v288 = f1;
                                        _v292 = 19;
                                        _v296 = 1;
                                         *__esp = "</TEXTAREA></FORM>\n";
                                        fwrite();
                                    }
                                } else {
                                    _v288 = f1;
                                    _v292 = 13;
                                    _v296 = 1;
                                     *__esp = "</PRE_PLAIN>\n";
                                    fwrite();
                                }
                                while(1) {
                                    t_stack = t_stack - 1;
                                    if(t_stack == 0) {
                                        break;
                                    }
                                    _v288 = f1;
                                    _v292 = 9;
                                    _v296 = 1;
                                     *__esp = "</TABLE>\n";
                                    fwrite();
                                }
                                if(ISclose(_v180) == 0) {
                                    _v180 = 0;
                                }
                                goto L177;
                            }
                            _v288 = f1;
                            _v292 = 6;
                            _v296 = 1;
                             *__esp = "<pre>\n";
                            fwrite();
                            while(1) {
                                tmp = StrmyISgets(_v180);
                                if(tmp->length == 0) {
                                    break;
                                }
                                tmp = convertLine(0, tmp, 2,  &charset, doc_charset);
                                _t855 = html_quote(tmp->ptr);
                                _v296 = f1;
                                 *__esp = _t855;
                                fputs();
                            }
                            _v288 = f1;
                            _v292 = 7;
                            _v296 = 1;
                             *__esp = "</pre>\n";
                            fwrite();
                            if(ISclose(_v180) == 0) {
                                _v180 = 0;
                            }
                            goto L177;
                        }
                    } else {
                         *frame = 0;
                        if(( *(frame + 1) & 1) == 0) {
                            if( *(frame + 8) == 0) {
                                if( *(frame + 4) == 0) {
                                    _t871 = "(no name)";
                                } else {
                                    _t871 = html_quote( *(frame + 4));
                                }
                                _v292 = _t871;
                                _v296 = "This frame (%s) contains no src attribute";
                                 *__esp = f1;
                                fprintf();
                            } else {
                                _v292 = html_quote( *(frame + 8));
                                _v296 = "Can't open %s";
                                 *__esp = f1;
                                fprintf();
                            }
                        } else {
                            _v292 = html_quote( *(frame + 8));
                            _v296 = "Open %s with other method";
                             *__esp = f1;
                            fprintf();
                        }
L177:
                        _v288 = f1;
                        _v292 = 6;
                        _v296 = 1;
                         *__esp = "</td>\n";
                        fwrite();
                        goto L178;
                    }
                }
                if(_t566 == 2) {
L171:
                    if( *(frame + 4) == 0 && f->name != 0) {
                        _v292 = i;
                        _v296 = f->name;
                         *(frame + 4) =  *(Sprintf("%s_%d"));
                    }
                    createFrameFile(frame, f1, current, level + 1, force_reload);
                    goto L177;
                }
                if(_t566 == 0) {
                    if( *(frame + 4) == 0 && f->name != 0) {
                        _v292 = i;
                        _v296 = f->name;
                         *(frame + 4) =  *(Sprintf("%s_%d"));
                    }
                     *__esp = f1;
                    fflush();
                    f_frameset = frame_download_source(frame, currentURL, current->baseURL, flag);
                    if(f_frameset == 0) {
                        goto L42;
                    } else {
                        deleteFrame(frame);
                        frame = f_frameset;
                        f->frame[i] = frame;
                        goto L171;
                    }
                } else {
                    _t917 = html_quote(f->name);
                    _v288 = i + 1;
                    _v292 = _t917;
                    _v296 = "Frameset "%s" frame %d: type unrecognized";
                     *__esp = f1;
                    fprintf();
                    goto L177;
                }
            } else {
                _v288 = f1;
                _v292 = 11;
                _v296 = 1;
                 *__esp = "<td>\n</td>\n";
                fwrite();
L178:
                c = c + 1;
                continue;
            }
        }
        _v288 = f1;
        _v292 = 6;
        _v296 = 1;
         *__esp = "</tr>\n";
        fwrite();
        r = r + 1;
    }
    _v288 = f1;
    _v292 = 9;
    _v296 = 1;
     *__esp = "</table>\n";
    fwrite();
    if(level == 0) {
        _v288 = f1;
        _v292 = 15;
        _v296 = 1;
         *__esp = "</body></html>\n";
        fwrite();
        if((TrapSignal & 255) != 0) {
            if((fmInitialized & 255) != 0) {
                term_raw();
            }
            if(prevtrap != 0) {
                mySignal(2, prevtrap);
            }
        }
    }
    return 0;
}

Buffer* renderFrame(Buffer* Cbuf, int force_reload)
{// addr = 0x08091F71  --  defined in 'frame.c' at line 879
    Str tmp;               // _cfa_fffffff0
    FILE* f;              // _cfa_ffffffec
    Buffer* buf;        // _cfa_ffffffe8
    int flag;                              // _cfa_ffffffe4
    struct frameset* fset;   // _cfa_ffffffe0
    wc_ces doc_charset;   // _cfa_ffffffdc
    Buffer* _v60;       // _cfa_ffffffc4 (outparam)
    int _v64;                              // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    intOrPtr _v72;                         // _cfa_ffffffb8 (outparam)
    FILE* _t54;           // _t54

    doc_charset = DocumentCharset;
    tmp = tmpfname(2, 135054624);
    _t54 = tmp->ptr;
    _v72 = 135054630;
     *__esp = _t54;
    fopen();
    f = _t54;
    if(f == 0) {
        return 0;
    }
    fset = Cbuf->frameset.scheme;
    if(fset == 0 || createFrameFile(fset, f, Cbuf, 0, force_reload) < 0) {
        return 0;
    } else {
         *__esp = f;
        fclose();
        flag = 2;
        if(Cbuf->currentURL.is_nocache != 0) {
            flag = flag | 1;
        }
        renderFrameSet = Cbuf->frameset.scheme;
        flushFrameSet(renderFrameSet);
        DocumentCharset = InnerCharset;
        _v60 = 0;
        _v64 = flag;
        buf = loadGeneralFile(tmp->ptr, 0, 0);
        DocumentCharset = doc_charset;
        renderFrameSet = 0;
        if(buf == 0 || buf == 1) {
            return 0;
        } else {
            buf->sourcefile.scheme = tmp->ptr;
            buf->document_charset.scheme = Cbuf->document_charset.scheme;
            copyParsedURL( &(buf->currentURL),  &(Cbuf->currentURL));
            preFormUpdateBuffer(buf);
            return buf;
        }
    }
}

union frameset_element* search_frame(struct frameset* fset, char* name)
{// addr = 0x080920F0  --  defined in 'frame.c' at line 925
    int i;                                 // _cfa_fffffff0
    union frameset_element* e;   // _cfa_ffffffec
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    intOrPtr _t50;                         // _t50

    e = 0;
    i = 0;
    while(fset->row * fset->col > i) {
        e =  &(fset->frame[i]);
        if( *e == 0) {
L8:
            i = i + 1;
            continue;
        }
        if( *((intOrPtr*)( *e + 4)) == 0) {
L5:
            if(( *( *e) & 255) != 2) {
                goto L8;
            }
            e = search_frame( *e, name);
            if(e == 0) {
                goto L8;
            }
            return e;
        }
        _t50 =  *((intOrPtr*)( *e + 4));
        _v40 = name;
         *__esp = _t50;
        strcmp();
        if(_t50 != 0) {
            goto L5;
        }
        return e;
    }
    return 0;
}

int compare_table(struct rc_search_table* a, struct rc_search_table* b)
{// addr = 0x080921A0  --  defined in 'rc.c' at line 706
    char* _v24;                            // _cfa_ffffffe8
    int _t8;                               // _t8

    _t8 = a->param->name;
    _v24 = b->param->name;
     *__esp = _t8;
    strcmp();
    return _t8;
}

void create_option_search_table()
{// addr = 0x080921C2  --  defined in 'rc.c' at line 712
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int k;                                 // _cfa_ffffffe8
    int diff1;                             // _cfa_ffffffe4
    int diff2;                             // _cfa_ffffffe0
    char* p;                               // _cfa_ffffffdc
    char* q;                               // _cfa_ffffffd8
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    struct rc_search_table* _t90;   // _t90

    RC_table_size = 0;
    j = 0;
    while( *((intOrPtr*)( &sections + j * 8)) != 0) {
        while( *((intOrPtr*)( *((intOrPtr*)(135096292 + j * 8)) + (i + i + _t144 << 3))) != 0) {
            i = i + 1;
            RC_table_size = RC_table_size + 1;
        }
        j = j + 1;
    }
    _t90 = RC_table_size << 3;
     *__esp = _t90;
    GC_malloc();
    RC_search_table = _t90;
    k = 0;
    j = 0;
    while( *((intOrPtr*)( &sections + j * 8)) != 0) {
        i = 0;
        while( *((intOrPtr*)( *((intOrPtr*)(135096292 + j * 8)) + (i + i + _t145 << 3))) != 0) {
            RC_search_table[k].param =  *((intOrPtr*)(135096292 + j * 8)) + (i + i + _t148 << 3);
            k = k + 1;
            i = i + 1;
        }
        j = j + 1;
    }
    _v48 = compare_table;
    _v52 = 8;
    _v56 = RC_table_size;
     *__esp = RC_search_table;
    qsort();
    diff2 = 0;
    diff1 = diff2;
    i = 0;
    while(RC_table_size - 1 > i) {
        p = RC_search_table[i].param->name;
        q = RC_search_table[i + 1].param->name;
        j = 0;
        while((p[j] & 255) != 0 && (q[j] & 255) != 0 && (p[j] & 255) == (q[j] & 255)) {
            j = j + 1;
        }
        diff1 = j;
        if(diff1 <= diff2) {
             &(RC_search_table[i])->uniq_pos = diff2 + 1;
        } else {
             &(RC_search_table[i])->uniq_pos = diff1 + 1;
        }
        diff2 = diff1;
        i = i + 1;
    }
}

struct param_ptr* search_param(char* name)
{// addr = 0x080923C2  --  defined in 'rc.c' at line 757
    size_t b;           // _cfa_fffffff0
    size_t e;           // _cfa_ffffffec
    size_t i;           // _cfa_ffffffe8
    int cmp;                               // _cfa_ffffffe4
    int len;                               // _cfa_ffffffe0
    int _v52;                              // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    int _t38;                              // _t38
    int _t49;                              // _t49

    _t38 = name;
     *__esp = _t38;
    strlen();
    len = _t38;
    b = 0;
    e = RC_table_size - 1;
    while(b <= e) {
        i = b + e >> 1;
        _v52 = len;
        _v56 = RC_search_table[i].param->name;
        _t49 = name;
         *__esp = _t49;
        strncmp();
        cmp = _t49;
        if(cmp != 0) {
            if(cmp >= 0) {
                b = i + 1;
                continue;
            }
            if(i != 0) {
                e = i - 1;
                continue;
            }
            return 0;
        }
        if(( &(RC_search_table[i])->uniq_pos & 65535) > len) {
            while(1) {
                RC_search_table =  &(RC_search_table[i]);
                RC_search_table[i].param = RC_search_table[i].param->name;
                _v56 = RC_search_table[i].param->name;
                __eax = name;
                 *__esp = __eax;
                strcmp();
                cmp = __eax;
                if(cmp > 0) {
                    break;
                }
                if(cmp != 0) {
                    if(i != 0) {
                        i = i - 1;
                        continue;
                    }
                    __eax = 0;
                    return 0;
                }
                RC_search_table =  &(RC_search_table[i]);
                __eax = RC_search_table[i].param;
                return RC_search_table[i].param;
            }
            __eax = 0;
            return 0;
        }
        return RC_search_table[i].param;
    }
    return 0;
}

void show_params(FILE* fp)
{// addr = 0x080924EF  --  defined in 'rc.c' at line 797
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int l;                                 // _cfa_ffffffe8
    char* t;                               // _cfa_ffffffe4
    char* cmt;                             // _cfa_ffffffe0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    int _v60;                              // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc (outparam)
    int _v72;                              // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    signed int _t129;                      // _t129
    char* _t130;                           // _t130
    intOrPtr* _t135;                       // _t135
    char* _t150;                           // _t150
    char* _t156;                           // _t156

    t = 0;
    OptionCharset = SystemCharset;
    _v64 = fp;
    _v68 = 26;
    _v72 = 1;
     *__esp = "\nconfiguration parameters\n";
    fwrite();
    j = 0;
    while( *( &sections + j * 8) != 0) {
        if(OptionEncode != 0) {
            cmt =  *( &sections + j * 8);
        } else {
            _t156 =  *( &sections + j * 8);
             *__esp = _t156;
            gettext();
            cmt =  *(wc_Str_conv(Strnew_charp(_t156), OptionCharset, InnerCharset));
        }
        _v64 =  *(wc_Str_conv_strict(Strnew_charp(cmt), InnerCharset, SystemCharset));
        _v68 = j;
        _v72 = "  section[%d]: %s\n";
         *__esp = fp;
        fprintf();
        i = 0;
        while( *((intOrPtr*)( *((intOrPtr*)(135096292 + j * 8)) + (i + i + _t177 << 3))) != 0) {
            if( *((intOrPtr*)( *((intOrPtr*)(135096292 + j * 8)) + (i + i + _t178 << 3) + 4)) <= 10) {
                goto __eax;
            }
            if(OptionEncode != 0) {
                cmt =  *( *((intOrPtr*)(135096292 + j * 8)) + (i + i + _t179 << 3) + 16);
            } else {
                _t150 =  *( *((intOrPtr*)(135096292 + j * 8)) + (i + i + _t184 << 3) + 16);
                 *__esp = _t150;
                gettext();
                cmt =  *(wc_Str_conv(Strnew_charp(_t150), OptionCharset, InnerCharset));
            }
            _t129 =  *( *((intOrPtr*)(135096292 + j * 8)) + (i + i + _t180 << 3));
             *__esp = _t129;
            strlen();
            _t130 = t;
             *__esp = _t130;
            strlen();
            l = 30 -  &(_t130[_t129]);
            if(l < 0) {
                l = 1;
            }
            _t135 = wc_Str_conv_strict(Strnew_charp(cmt), InnerCharset, SystemCharset);
            _t182 = i;
            _v52 =  *_t135;
            _v56 = 135061114;
            _v60 = l;
            _v64 = t;
            _v68 =  *( *((intOrPtr*)(135096292 + j * 8)) + (i + _t182 + _t182 << 3));
            _v72 = "    -o %s=<%s>%*s%s\n";
             *__esp = fp;
            fprintf();
            i = i + 1;
        }
        j = j + 1;
    }
}

int str_to_bool(char* value, int old)
{// addr = 0x080927EA  --  defined in 'rc.c' at line 877
    signed int _t16;                       // _t16

    if(value != 0) {
        if(( *( &MYCTYPE_MAP + ( *value & 0xff)) & 4) == 0) {
            _t16 =  *value & 255;
        } else {
            _t16 =  *value & 255 | 32;
        }
        if(_t16 - 33 > 87) {
            return 1;
        } else {
            goto __eax;
        }
    }
    return 1;
}

int str_to_color(char* value)
{// addr = 0x08092905  --  defined in 'rc.c' at line 905
    signed int _t16;                       // _t16

    if(value != 0) {
        if(( *( &MYCTYPE_MAP + ( *value & 0xff)) & 4) == 0) {
            _t16 =  *value & 255;
        } else {
            _t16 =  *value & 255 | 32;
        }
        if(_t16 - 48 > 73) {
            return 8;
        } else {
            goto __eax;
        }
    }
    return 8;
}

int set_param(char* name, char* value)
{// addr = 0x080929D0  --  defined in 'rc.c' at line 946
    double ppc;                            // _cfa_ffffffe4
    struct param_ptr* p;   // _cfa_fffffff0
    _unknown_ __ebx;                       // r1

    if(value != 0) {
        p = search_param(name);
        if(p != 0) {
            if(p->type > 10) {
                return 1;
            }
            goto __eax;
        }
        return 0;
    }
    return 0;
}

int set_param_option(char* option)
{// addr = 0x08092C20  --  defined in 'rc.c' at line 1015
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    char* _t75;                            // _t75
    int _t115;                             // _t115

    tmp = Strnew();
    p = option;
    while(( *p & 255) != 0) {
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
L11:
            while(( *p & 255) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                p =  &(p[1]);
            }
            if(( *p & 255) != 61) {
L18:
                Strlower(tmp);
                if(set_param(tmp->ptr, p) != 0) {
L30:
                    return 1;
                }
                q = tmp->ptr;
                _v36 = 2;
                _v40 = 135061856;
                _t75 = q;
                 *__esp = _t75;
                strncmp();
                if(_t75 != 0) {
                    if(( *(tmp->ptr) & 255) != 45) {
                        return 0;
                    }
                    q =  &(q[1]);
L26:
                    if(set_param(q, 135054688) != 0) {
                        goto L30;
                    }
                    return 0;
                }
                q =  &(q[2]);
                if(( *q & 255) == 45 || ( *q & 255) == 95) {
                    q =  &(q[1]);
                }
                goto L26;
            }
            p =  &(p[1]);
            while(( *p & 255) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                p =  &(p[1]);
            }
            goto L18;
        }
        if(( *p & 255) != 61) {
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t115 = tmp->length;
             *((char*)(tmp->ptr + _t115)) =  *p & 255;
            tmp->length = _t115 + 1;
            p =  &(p[1]);
             *((char*)(tmp->ptr + tmp->length)) = 0;
            continue;
        }
        goto L11;
    }
    goto L11;
}

char* get_param_option(char* name)
{// addr = 0x08092DCD  --  defined in 'rc.c' at line 1050
    struct param_ptr* p;   // _cfa_fffffff0

    p = search_param(name);
    if(p == 0) {
        return 0;
    }
    return  *(to_str(p));
}

void interpret_rc(FILE* f)
{// addr = 0x08092DFD  --  defined in 'rc.c' at line 1059
    Str line;              // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t68;                              // _t68

    while(1) {
L1:
        line = Strfgets(f);
        Strchop(line);
        if(line->length == 0) {
            break;
        }
        Strremovefirstspaces(line);
        if((line & 255) != 35) {
            tmp = Strnew();
            p = line->ptr;
            while(( *p & 255) != 0) {
                if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t68 = tmp->length;
                     *((char*)(tmp->ptr + _t68)) =  *p & 255;
                    tmp->length = _t68 + 1;
                    p =  &(p[1]);
                     *((char*)(tmp->ptr + tmp->length)) = 0;
                    continue;
                }
L13:
                while(( *p & 255) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                    p =  &(p[1]);
                }
                Strlower(tmp);
                set_param(tmp->ptr, p);
                goto L1;
            }
            goto L13;
        }
    }
}

void parse_proxy()
{// addr = 0x08092F21  --  defined in 'rc.c' at line 1085
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(non_null(HTTP_proxy) != 0) {
        parseURL(HTTP_proxy,  &HTTP_proxy_parsed, 0);
    }
    if(non_null(GOPHER_proxy) != 0) {
        parseURL(GOPHER_proxy,  &GOPHER_proxy_parsed, 0);
    }
    if(non_null(FTP_proxy) != 0) {
        parseURL(FTP_proxy,  &FTP_proxy_parsed, 0);
    }
    if(non_null(NO_proxy) != 0) {
        NO_proxy_domains = make_domain_list(NO_proxy);
        return;
    }
}

void parse_cookie()
{// addr = 0x08092FD6  --  defined in 'rc.c' at line 1105
    if(non_null(cookie_reject_domains) != 0) {
        Cookie_reject_domains = make_domain_list(cookie_reject_domains);
    }
    if(non_null(cookie_accept_domains) != 0) {
        Cookie_accept_domains = make_domain_list(cookie_accept_domains);
        return;
    }
}

void sync_with_option()
{// addr = 0x08093024  --  defined in 'rc.c' at line 1140
    signed int _t4;                        // _t4

    if(PagerMax < LINES) {
        PagerMax = LINES;
    }
    WrapSearch = WrapDefault;
    parse_proxy();
    parse_cookie();
    initMailcap();
    initMimeTypes();
    initURIMethods();
    init_migemo();
    if((fmInitialized & 255) != 0 && displayImage != 0) {
        initImage();
    }
    loadPasswd();
    loadPreForm();
    _t4 = AcceptLang;
    if(_t4 == 0) {
L7:
         *__esp = "en;q=1.0";
        gettext();
        AcceptLang = _t4;
L8:
        if(AcceptEncoding == 0 || ( *AcceptEncoding & 255) == 0) {
            AcceptEncoding = acceptableEncoding();
        }
        if(AcceptMedia == 0 || ( *AcceptMedia & 255) == 0) {
            AcceptMedia = acceptableMimeTypes();
        }
        if((fmInitialized & 255) == 0) {
            return;
        } else {
            initKeymap(0);
            initMouseAction();
            initMenu();
            return;
        }
    }
    _t4 =  *AcceptLang & 255;
    if(_t4 != 0) {
        goto L8;
    }
    goto L7;
}

void init_rc()
{// addr = 0x08093115  --  defined in 'rc.c' at line 1190
    int i;                                 // _cfa_fffffff0
    FILE* f;              // _cfa_ffffffec
    _unknown_ _v92;                        // _cfa_ffffffa4
    struct stat st;       // _cfa_ffffff94
    char* _v116;                           // _cfa_ffffff8c
    char* _v120;                           // _cfa_ffffff88 (outparam)
    _unknown_ __ebx;                       // r1
    int _t37;                              // _t37
    intOrPtr* _t42;                        // _t42
    FILE* _t49;           // _t49
    FILE* _t50;           // _t50
    FILE* _t51;           // _t51
    int _t59;                              // _t59
    signed int _t60;                       // _t60
    signed int _t61;                       // _t61
    char* _t68;                            // _t68

    if(rc_dir != 0) {
L18:
        _t49 = etcFile("w3mconfig");
        _v120 = "rt";
         *__esp = _t49;
        fopen();
        f = _t49;
        if(f != 0) {
            interpret_rc(f);
             *__esp = f;
            fclose();
        }
        _t50 = confFile("config");
        _v120 = "rt";
         *__esp = _t50;
        fopen();
        f = _t50;
        if(f != 0) {
            interpret_rc(f);
             *__esp = f;
            fclose();
        }
        _t51 = config_file;
        _v120 = "rt";
         *__esp = _t51;
        fopen();
        f = _t51;
        if(f == 0) {
L32:
            return;
        } else {
            interpret_rc(f);
             *__esp = f;
            fclose();
            return;
        }
    }
    rc_dir = expandPath("~/.w3m");
    _t37 = rc_dir;
     *__esp = _t37;
    strlen();
    i = _t37;
    if(i > 1 && (rc_dir[i - 1] & 255) == 47) {
        rc_dir[i - 1] = 0;
    }
    display_charset_str = wc_get_ces_list();
    document_charset_str = display_charset_str;
    system_charset_str = display_charset_str;
    _t42 = __stat(rc_dir,  &(st.st_dev));
    if(_t42 >= 0) {
L10:
        if((st.st_mode & 61440) == 16384) {
            if((st.st_mode & 128) != 0) {
                no_rc_dir = 0;
                tmp_dir = rc_dir;
                if(config_file == 0) {
                    config_file = rcFile("config");
                }
                create_option_search_table();
                goto L18;
            }
            _t59 = __imp__stderr;
            _v116 = rc_dir;
            _v120 = "%s is not writable!";
             *__esp = _t59;
            fprintf();
L24:
            no_rc_dir = 1;
             *__esp = "TMPDIR";
            getenv();
            tmp_dir = _t59;
            _t60 = tmp_dir;
            if(_t60 == 0) {
L26:
                 *__esp = "TMP";
                getenv();
                tmp_dir = _t60;
                _t61 = tmp_dir;
                if(_t61 == 0) {
L28:
                     *__esp = "TEMP";
                    getenv();
                    tmp_dir = _t61;
                    if(tmp_dir == 0 || ( *tmp_dir & 255) == 0) {
                        tmp_dir = "/tmp";
                        return;
                    } else {
                        goto L32;
                    }
                }
                _t61 =  *tmp_dir & 255;
                if(_t61 != 0) {
                    goto L32;
                }
                goto L28;
            }
            _t60 =  *tmp_dir & 255;
            if(_t60 != 0) {
                goto L32;
            }
            goto L26;
        }
        _t59 = __imp__stderr;
        _v116 = rc_dir;
        _v120 = "%s is not a directory!";
         *__esp = _t59;
        fprintf();
        goto L24;
    }
    __errno_location();
    if( *_t42 != 2) {
        _t59 = __imp__stderr;
        _v116 = rc_dir;
        _v120 = "Can't open config directory (%s)!";
         *__esp = _t59;
        fprintf();
        goto L24;
    }
    _t68 = rc_dir;
    _v120 = 448;
     *__esp = _t68;
    mkdir();
    if(_t68 >= 0) {
        __stat(rc_dir,  &(st.st_dev));
        goto L10;
    }
    _t59 = __imp__stderr;
    _v116 = rc_dir;
    _v120 = "Can't create config directory (%s)!";
     *__esp = _t59;
    fprintf();
    goto L24;
}

Str to_str(struct param_ptr* p)
{// addr = 0x08093413  --  defined in 'rc.c' at line 1280
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5

    if(p->type <= 10) {
        goto __eax;
    }
    return 0;
}

Buffer* load_option_panel()
{// addr = 0x08093526  --  defined in 'rc.c' at line 1314
    Str src;               // _cfa_ffffffe0
    struct param_ptr* p;   // _cfa_ffffffdc
    struct sel_c* s;     // _cfa_ffffffd8
    wc_ces_list* c;   // _cfa_ffffffd4
    int x;                                 // _cfa_ffffffd0
    int i;                                 // _cfa_ffffffcc
    Str tmp;               // _cfa_ffffffc8
    Buffer* buf;        // _cfa_ffffffc4
    _unknown_ _v62;                        // _cfa_ffffffc2
    short _v64;                            // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc
    int _v84;                              // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    char* _v92;                            // _cfa_ffffffa4
    char* _v96;                            // _cfa_ffffffa0
    int _v100;                             // _cfa_ffffff9c
    char* _v104;                           // _cfa_ffffff98
    int _v108;                             // _cfa_ffffff94
    char* _v112;                           // _cfa_ffffff90
    char* _v116;                           // _cfa_ffffff8c (outparam)
    char* _v120;                           // _cfa_ffffff88 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    char* _t245;                           // _t245
    int _t270;                             // _t270
    int _t273;                             // _t273
    char* _t275;                           // _t275
    int _t302;                             // _t302
    char* _t320;                           // _t320
    char* _t339;                           // _t339
    int _t346;                             // _t346
    int _t361;                             // _t361
    char* _t375;                           // _t375
    char* _t384;                           // _t384
    char* _t397;                           // _t397
    char* _t404;                           // _t404
    char* _t410;                           // _t410
    char* _t412;                           // _t412
    char* _t425;                           // _t425

    _t245 = optionpanel_str;
    if(_t245 == 0) {
         *__esp = "External Viewer Setup";
        gettext();
        _t410 = html_quote( *(localCookie()));
        _v112 = _t245;
        _v116 = _t410;
        _v120 = w3m_version;
        optionpanel_str = Sprintf("<html><head><title>Option Setting Panel</title></head><body><h1 align=center>Option Setting Panel<br>(w3m version %s)</b></h1><form method=post action="file:///$LIB/w3mhelperpanel"><input type=hidden name=mode value=panel><input type=hidden name=cookie value="%s"><input type=submit value="%s"></form><br><form method=internal action=option>");
    }
    OptionCharset = SystemCharset;
    if(OptionEncode != 0) {
L18:
        src = Strdup(optionpanel_str);
        Strcat_charp(src, "<table><tr><td>");
        i = 0;
        while( *( &sections + i * 8) != 0) {
            _v108 = 0;
            _v112 = "</h1>";
            _v116 =  *( &sections + i * 8);
            _v120 = "<h1>";
            Strcat_m_charp(src);
            p =  *(135096292 + i * 8);
            Strcat_charp(src, "<table width=100% cellpadding=0>");
            while(p->name != 0) {
                _v112 = 0;
                _v116 = p->comment;
                _v120 = "<tr><td>";
                Strcat_m_charp(src);
                asm("fmulp st1, st0");
                asm("fnstcw word [ebp-0x3a]");
                _v64 = 12;
                asm("fldcw word [ebp-0x3c]");
                asm("fistp dword [ebp-0x40]");
                asm("fldcw word [ebp-0x3a]");
                _v120 = _v68;
                Strcat(src, Sprintf("</td><td width=%d>"));
                _t270 = p->inputtype;
                if(_t270 == 1) {
                    _t273 =  *(to_str(p));
                     *__esp = _t273;
                    atoi();
                    x = _t273;
                    if(x == 0) {
                        _t425 = " checked";
                    } else {
                        _t425 = 135062232;
                    }
                    _t412 = p->name;
                    if(x == 0) {
                        _t275 = 135062232;
                    } else {
                        _t275 = " checked";
                    }
                    _v84 = 0;
                    _v88 = ">NO";
                    _v92 = _t425;
                    _v96 = " value=0";
                    _v100 = _t412;
                    _v104 = ">YES&nbsp;&nbsp;<input type=radio name=";
                    _v108 = _t275;
                    _v112 = " value=1";
                    _v116 = p->name;
                    _v120 = "<input type=radio name=";
                    Strcat_m_charp(src);
L54:
                    Strcat_charp(src, "</td></tr>\n");
                    p = p + 24;
                    continue;
                }
                if(_t270 > 1) {
                    if(_t270 == 2) {
                        tmp = to_str(p);
                        _v108 = 0;
                        _v112 = 135062329;
                        _v116 = p->name;
                        _v120 = "<select name=";
                        Strcat_m_charp(src);
                        s = p->select;
                        while(s->text != 0) {
                            Strcat_charp(src, "<option value=");
                            _v120 = s->cvalue;
                            Strcat(src, Sprintf("%s\n"));
                            if(p->type == 3) {
L38:
                                if(p->type != 3 || s->value != (tmp & 255)) {
L41:
                                    if(src->length + 1 >= src->area_size) {
                                        Strgrow(src);
                                    }
                                    _t302 = src->length;
                                     *((char*)(src->ptr + _t302)) = 62;
                                    src->length = _t302 + 1;
                                     *((char*)(src->ptr + src->length)) = 0;
                                    Strcat_charp(src, s->text);
                                    s = s + 12;
                                    continue;
                                } else {
L40:
                                    Strcat_charp(src, " selected");
                                    goto L41;
                                }
                            }
                            _t320 = tmp->ptr;
                             *__esp = _t320;
                            atoi();
                            if(s->value == _t320) {
                                goto L40;
                            }
                            goto L38;
                        }
                        Strcat_charp(src, "</select>");
                        goto L54;
                    }
                    if(_t270 == 3) {
                        tmp = to_str(p);
                        _v108 = 0;
                        _v112 = 135062329;
                        _v116 = p->name;
                        _v120 = "<select name=";
                        Strcat_m_charp(src);
                        c =  *(p->select);
                        while(c->desc != 0) {
                            Strcat_charp(src, "<option value=");
                            _v120 = c->name;
                            Strcat(src, Sprintf("%s\n"));
                            _t339 = tmp->ptr;
                             *__esp = _t339;
                            atoi();
                            if(c->id == _t339) {
                                Strcat_charp(src, " selected");
                            }
                            if(src->length + 1 >= src->area_size) {
                                Strgrow(src);
                            }
                            _t346 = src->length;
                             *((char*)(src->ptr + _t346)) = 62;
                            src->length = _t346 + 1;
                             *((char*)(src->ptr + src->length)) = 0;
                            Strcat_charp(src, c->desc);
                            c = c + 12;
                        }
                        Strcat_charp(src, "</select>");
                        goto L54;
                    }
                    goto L54;
                }
                if(_t270 == 0) {
                    _t361 = html_quote( *(to_str(p)));
                    _v100 = 0;
                    _v104 = "">";
                    _v108 = _t361;
                    _v112 = " value="";
                    _v116 = p->name;
                    _v120 = "<input type=text name=";
                    Strcat_m_charp(src);
                }
                goto L54;
            }
            Strcat_charp(src, "<tr><td></td><td><p><input type=submit value="OK"></td></tr>");
            Strcat_charp(src, "</table><hr width=50%>");
            i = i + 1;
        }
        Strcat_charp(src, "</table></form></body></html>");
        buf = loadHTMLString(src);
        if(buf != 0) {
            buf->document_charset = OptionCharset;
        }
        return buf;
    } else {
        optionpanel_str = wc_Str_conv(optionpanel_str, OptionCharset, InnerCharset);
        i = 0;
        while( *( &sections + i * 8) != 0) {
            _t375 =  *( &sections + i * 8);
             *__esp = _t375;
            gettext();
             *( &sections + i * 8) =  *(wc_Str_conv(Strnew_charp(_t375), OptionCharset, InnerCharset));
            p =  *(135096292 + i * 8);
            while(p->name != 0) {
                _t384 = p->comment;
                 *__esp = _t384;
                gettext();
                p->comment =  *(wc_Str_conv(Strnew_charp(_t384), OptionCharset, InnerCharset));
                if(p->inputtype != 2 || p->select ==  &colorstr) {
L10:
                    p = p + 24;
                    continue;
                } else {
                    s = p->select;
                    while(s->text != 0) {
                        _t397 = s->text;
                         *__esp = _t397;
                        gettext();
                        s->text =  *(wc_Str_conv(Strnew_charp(_t397), OptionCharset, InnerCharset));
                        s = s + 12;
                    }
                    goto L10;
                }
            }
            i = i + 1;
        }
        s =  &colorstr;
        while(s->text != 0) {
            _t404 = s->text;
             *__esp = _t404;
            gettext();
            s->text =  *(wc_Str_conv(Strnew_charp(_t404), OptionCharset, InnerCharset));
            s = s + 12;
        }
        OptionEncode = 1;
        goto L18;
    }
}

void panel_set_option(struct parsed_tagarg* arg)
{// addr = 0x08093C71  --  defined in 'rc.c' at line 1440
    FILE* f;              // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* _v32;                            // _cfa_ffffffe0
    char* _v36;                            // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    FILE* _t31;           // _t31

    f = 0;
    if(no_rc_dir == 0) {
        _t31 = config_file;
        _v40 = "wt";
         *__esp = _t31;
        fopen();
        f = _t31;
        if(f == 0) {
            disp_message("Can't write option!", 0);
        }
    } else {
        disp_message("There's no ~/.w3m directory... config not saved", 0);
    }
    while(arg != 0) {
        if(arg->value != 0) {
            p =  *(wc_Str_conv_strict(Strnew_charp(arg->value), InnerCharset, SystemCharset));
            if(set_param(arg->arg, p) != 0 && f != 0) {
                _v32 = p;
                _v36 = arg->arg;
                _v40 = "%s %s\n";
                 *__esp = f;
                fprintf();
            }
        }
        arg = arg->next;
    }
    if(f != 0) {
         *__esp = f;
        fclose();
    }
    sync_with_option();
    backBf();
}

char* rcFile(char* base)
{// addr = 0x08093D8E  --  defined in 'rc.c' at line 1472
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v20;                            // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8

    if(base != 0) {
        if(( *base & 255) == 47 || ( *base & 255) == 46 && ((base[1] & 255) == 47 || (base[1] & 255) == 46 && (base[2] & 255) == 47) || ( *base & 255) == 126 && (base[1] & 255) == 47) {
            return expandPath(base);
        } else {
            goto L9;
        }
    }
L9:
    _v16 = 0;
    _v20 = base;
    _v24 = "/";
    return expandPath( *(Strnew_m_charp(rc_dir)));
}

char* auxbinFile(char* base)
{// addr = 0x08093E29  --  defined in 'rc.c' at line 1485
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v20;                            // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    char* _t5;                             // _t5

    _t5 = w3m_auxbin_dir();
    _v16 = 0;
    _v20 = base;
    _v24 = "/";
    return expandPath( *(Strnew_m_charp(_t5)));
}

char* etcFile(char* base)
{// addr = 0x08093E5F  --  defined in 'rc.c' at line 1499
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v20;                            // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    char* _t5;                             // _t5

    _t5 = w3m_etc_dir();
    _v16 = 0;
    _v20 = base;
    _v24 = "/";
    return expandPath( *(Strnew_m_charp(_t5)));
}

char* confFile(char* base)
{// addr = 0x08093E95  --  defined in 'rc.c' at line 1505
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v20;                            // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    char* _t5;                             // _t5

    _t5 = w3m_conf_dir();
    _v16 = 0;
    _v20 = base;
    _v24 = "/";
    return expandPath( *(Strnew_m_charp(_t5)));
}

void new_menu(Menu* menu, MenuItem* item)
{// addr = 0x08093ECC  --  defined in 'menu.c' at line 303
    int i;                                 // _cfa_fffffff0
    int l;                                 // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8

    menu->cursorX = 0;
    menu->cursorY = 0;
    menu->x = 0;
    menu->y = 0;
    menu->nitem = 0;
    menu->item = item;
    menu->initial = 0;
    menu->select = 0;
    menu->offset = 0;
    menu->active = 0;
    if(item != 0) {
        i = 0;
        while( *((intOrPtr*)(item + (i << 5))) != 0) {
            i = i + 1;
        }
        menu->nitem = i;
        menu->height = menu->nitem;
        i = 0;
        while(i <= 127) {
             *((intOrPtr*)(menu->cursorX + (i + 12) * 4)) =  *((intOrPtr*)( &MenuKeymap + i * 4));
            i = i + 1;
        }
        menu->width = 0;
        i = 0;
        while(menu->nitem > i) {
            p =  *(item + (i << 5) + 24);
            if(p == 0) {
L14:
                l = wtf_strwidth( *(item + (i << 5) + 4));
                if(menu->width < l) {
                    menu->width = l;
                }
                i = i + 1;
                continue;
            }
            while(( *p & 255) != 0) {
                if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 0x11) != 0) {
                     *((intOrPtr*)(menu->cursorX + (( *p & 255) + 12) * 4)) = mSelect;
                     *(menu->cursorX + (( *p & 255) + 140) * 4) = i;
                }
                p =  &(p[1]);
            }
            goto L14;
        }
        return;
    }
}

void geom_menu(Menu* menu, int x, int y, int mselect)
{// addr = 0x08094062  --  defined in 'menu.c' at line 345
    int win_x;                             // _cfa_fffffff4
    int win_y;                             // _cfa_fffffff0
    int win_w;                             // _cfa_ffffffec
    int win_h;                             // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4

    menu->select = mselect;
    if(menu->width % FRAME_WIDTH != 0) {
        _v28 = FRAME_WIDTH;
        menu->width = (menu->width / _v28 + 1) * FRAME_WIDTH;
    }
    win_x = menu->x - FRAME_WIDTH;
    win_w = menu->width + FRAME_WIDTH + FRAME_WIDTH;
    if(win_x + win_w > COLS) {
        win_x = COLS - win_w;
    }
    if(win_x < 0) {
        win_x = 0;
        if(win_w > COLS) {
            menu->width = 0 - FRAME_WIDTH + 0 - FRAME_WIDTH + COLS;
            menu->width = menu->width - menu->width % FRAME_WIDTH;
            win_w = menu->width + FRAME_WIDTH + FRAME_WIDTH;
        }
    }
    menu->x = FRAME_WIDTH + win_x;
    win_y = menu->y - mselect - 1;
    win_h = menu->height + 2;
    if(win_y + win_h > LINES - 1) {
        win_y = LINES - 1 - win_h;
    }
    if(win_y < 0) {
        win_y = 0;
        if(win_y + win_h > LINES - 1) {
            win_h = LINES - 1 - win_y;
            menu->height = win_h - 2;
            if(menu->height <= mselect) {
                menu->offset = mselect - menu->height + 1;
            }
        }
    }
    menu->y = win_y + 1;
}

void draw_all_menu(Menu* menu)
{// addr = 0x08094220  --  defined in 'menu.c' at line 384
    if(menu->parent != 0) {
        draw_all_menu(menu->parent);
    }
    draw_menu(menu);
}

void draw_menu(Menu* menu)
{// addr = 0x08094249  --  defined in 'menu.c' at line 392
    int x;                                 // _cfa_fffffff0
    int y;                                 // _cfa_ffffffec
    int w;                                 // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    int j;                                 // _cfa_ffffffe0
    signed int _v48;                       // _cfa_ffffffd0
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)

    x = menu->x - FRAME_WIDTH;
    w = menu->width + FRAME_WIDTH + FRAME_WIDTH;
    y = menu->y - 1;
    if(menu->offset != 0) {
        if(graph_mode != 0) {
            graphstart();
        }
        move(y, x);
        addstr(FRAME[5]);
        if(graph_mode != 0) {
            graphend();
        }
        i = FRAME_WIDTH;
        while(w - FRAME_WIDTH > i) {
            move(y, x + i);
            addstr(135063018);
            i = i + 1;
        }
        if(graph_mode != 0) {
            graphstart();
        }
        move(y, x + i);
        addstr(FRAME[5]);
        if(graph_mode != 0) {
            graphend();
        }
        _t174 = w;
        _v48 = FRAME_WIDTH;
        i = FRAME_WIDTH * (((w >> 31) + _t174 >> 1) - 1) / _v48;
        move(y, x + i);
        addstr(135063020);
L20:
        j = 0;
        while(menu->height > j) {
            y = y + 1;
            if(graph_mode != 0) {
                graphstart();
            }
            move(y, x);
            addstr(FRAME[5]);
            if(graph_mode != 0) {
                graphend();
            }
            draw_menu_item(menu, menu->offset + j);
            if(graph_mode != 0) {
                graphstart();
            }
            move(y, x + w - FRAME_WIDTH);
            addstr(FRAME[5]);
            if(graph_mode != 0) {
                graphend();
            }
            j = j + 1;
        }
        y = y + 1;
        if(menu->offset + menu->height != menu->nitem) {
            if(graph_mode != 0) {
                graphstart();
            }
            move(y, x);
            addstr(FRAME[5]);
            if(graph_mode != 0) {
                graphend();
            }
            i = FRAME_WIDTH;
            while(w - FRAME_WIDTH > i) {
                move(y, x + i);
                addstr(135063018);
                i = i + 1;
            }
            if(graph_mode != 0) {
                graphstart();
            }
            move(y, x + i);
            addstr(FRAME[5]);
            if(graph_mode != 0) {
                graphend();
            }
            _t232 = w;
            _v48 = FRAME_WIDTH;
            i = FRAME_WIDTH * (((w >> 31) + _t232 >> 1) - 1) / _v48;
            move(y, x + i);
            addstr(135063020);
            return;
        }
        if(graph_mode != 0) {
            graphstart();
        }
        move(y, x);
        addstr(FRAME[9]);
        i = FRAME_WIDTH;
        while(w - FRAME_WIDTH > i) {
            move(y, x + i);
            addstr(FRAME[0xa]);
            i = i + FRAME_WIDTH;
        }
        move(y, x + i);
        addstr(FRAME[0xc]);
        if(graph_mode == 0) {
            return;
        }
        graphend();
        return;
    }
    if(graph_mode != 0) {
        graphstart();
    }
    move(y, x);
    addstr(FRAME[3]);
    i = FRAME_WIDTH;
    while(w - FRAME_WIDTH > i) {
        move(y, x + i);
        addstr(FRAME[0xa]);
        i = i + FRAME_WIDTH;
    }
    move(y, x + i);
    addstr(FRAME[6]);
    if(graph_mode != 0) {
        graphend();
    }
    goto L20;
}

void draw_menu_item(Menu* menu, int mselect)
{// addr = 0x0809473B  --  defined in 'menu.c' at line 456
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ __ebx;                       // r1

    move(menu->y + mselect - menu->offset, menu->x);
    addnstr_sup( *(menu->item + (mselect << 5) + 4), menu->width);
}

int select_menu(Menu* menu, int mselect)
{// addr = 0x08094794  --  defined in 'menu.c' at line 463
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ __ebx;                       // r1

    if(mselect < 0 || menu->nitem <= mselect) {
        return -1;
    }
    if(menu->offset <= mselect) {
        if(menu->offset + menu->height <= mselect) {
            down_menu(menu, mselect - menu->offset - menu->height + 1);
        }
    } else {
        up_menu(menu, menu->offset - mselect);
    }
    if(menu->select >= menu->offset && menu->select < menu->offset + menu->height) {
        draw_menu_item(menu, menu->select);
    }
    menu->select = mselect;
    standout();
    draw_menu_item(menu, menu->select);
    standend();
    move(menu->y + mselect - menu->offset, menu->x);
    toggle_stand();
    refresh();
    return menu->select;
}

void goto_menu(Menu* menu, int mselect, int down)
{// addr = 0x080948BD  --  defined in 'menu.c' at line 489
    int select_in;                         // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(menu->nitem > mselect) {
        if(mselect < 0) {
            mselect = 0;
        }
    } else {
        mselect = menu->nitem - 1;
    }
    select_in = mselect;
    while( *((intOrPtr*)(menu->item + (mselect << 5))) == 1) {
        if(down > 0) {
            mselect = mselect + 1;
            if(mselect >= menu->nitem) {
                down_menu(menu, select_in - menu->select);
                mselect = menu->select;
                break;
            }
            continue;
        }
        if(down < 0) {
            mselect = mselect - 1;
            if(mselect < 0) {
                up_menu(menu, menu->select - select_in);
                mselect = menu->select;
                break;
            }
            continue;
        }
        return;
    }
    select_menu(menu, mselect);
}

void up_menu(Menu* menu, int n)
{// addr = 0x08094992  --  defined in 'menu.c' at line 520
    if(n < 0) {
        return;
    }
    if(menu->offset != 0) {
        menu->offset = menu->offset - n;
        if(menu->offset < 0) {
            menu->offset = 0;
        }
        draw_menu(menu);
        return;
    }
}

void down_menu(Menu* menu, int n)
{// addr = 0x080949E0  --  defined in 'menu.c' at line 532
    if(n < 0) {
        return;
    }
    if(menu->offset + menu->height != menu->nitem) {
        menu->offset = menu->offset + n;
        if(menu->offset + menu->height > menu->nitem) {
            menu->offset = menu->nitem - menu->height;
        }
        draw_menu(menu);
        return;
    }
}

int action_menu(Menu* menu)
{// addr = 0x08094A54  --  defined in 'menu.c' at line 544
    char c;                                // _cfa_fffffff3
    int mselect;                           // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    int _v28;                              // _cfa_ffffffe4
    Menu* _v32;           // _cfa_ffffffe0
    int _v36;                              // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    int _v44;                              // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    MenuItem item;    // _cfa_ffffffcc
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    int _t80;                              // _t80
    int* _t90;                             // _t90

    if(menu->active == 0) {
        if(menu->parent != 0) {
             *(menu->parent + 48) = 0;
        }
        return 0;
    }
    draw_all_menu(menu);
    select_menu(menu, menu->select);
L7:
    while(1) {
L7:
        while(1) {
            if(use_mouse != 0) {
                mouse_active();
            }
            c = do_getch();
            if(use_mouse != 0) {
                mouse_inactive();
            }
            if(c != 255) {
L13:
                if(( *( &MYCTYPE_MAP + (c & 0xff)) & 0x11) == 0) {
                    continue;
                }
                _t80 = c;
                 *__esp = _t80;
                 *((intOrPtr*)( *((intOrPtr*)(menu->cursorX + (c + 12) * 4))))();
                mselect = _t80;
                if(mselect == -1) {
                    continue;
                }
                goto L17;
            } else {
                mselect = X_Mouse_Selection;
                if(mselect != -1) {
L17:
                    if(mselect < 0 || menu->nitem <= mselect) {
                        if(mselect == -3 && menu->parent != 0) {
                             *(menu->parent + 48) = 0;
                        }
                        goto L31;
                    } else {
                        _t90 = menu->item + (mselect << 5);
                        item.type =  *_t90;
                        _v48 = _t90[1];
                        _v44 = _t90[2];
                        _v40 = _t90[3];
                        _v36 = _t90[4];
                        _v32 = _t90[5];
                        _v28 = _t90[6];
                        _v24 = _t90[7];
                        if((item.type & 8) == 0) {
                            if(menu->parent != 0) {
                                menu->parent->active = 0;
                            }
                            if((item.type & 2) != 0) {
                                 *_v44 = _v40;
                            }
                            if((item.type & 4) != 0) {
                                CurrentKey = -1;
                                CurrentKeyData = 0;
                                CurrentCmdData = _v24;
                                 *_v36();
                                CurrentCmdData = 0;
                            }
L31:
                            return 0;
                        }
                        popup_menu(menu, _v32);
                        return 1;
                    }
                }
                goto L13;
            }
        }
    }
}

void popup_menu(Menu* parent, Menu* menu)
{// addr = 0x08094C1B  --  defined in 'menu.c' at line 607
    int active;                            // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    active = 1;
    if(menu->item == 0) {
        return;
    }
    if(menu->nitem == 0) {
        return;
    }
    if(menu->active == 0) {
        __imp__gpm_handler = gpm_process_menu_mouse;
        menu->parent = parent;
        menu->select = menu->initial;
        menu->offset = 0;
        menu->active = 1;
        if(parent != 0) {
            menu->cursorX = parent->cursorX;
            menu->cursorY = parent->cursorY;
            guess_menu_xy(parent, menu->width,  &(menu->x),  &(menu->y));
        }
        geom_menu(menu, menu->x, menu->y, menu->select);
        CurrentMenu = menu;
        while(active != 0) {
            active = action_menu(CurrentMenu);
            displayBuffer(CurrentTab->currentBuffer, 1);
        }
        menu->active = 0;
        CurrentMenu = parent;
        if(CurrentMenu == 0) {
            __imp__gpm_handler = gpm_process_mouse;
            return;
        }
    }
}

void guess_menu_xy(Menu* parent, int width, int* x, int* y)
{// addr = 0x08094D5C  --  defined in 'menu.c' at line 655
     *x = parent->x + parent->width + FRAME_WIDTH - 1;
    if( *x + width + FRAME_WIDTH > COLS) {
         *x = COLS - width - FRAME_WIDTH;
        if(parent->x + ((parent->width >> 31) + parent->width >> 1) >  *x) {
            _t64 = parent->width;
            if(parent->x + ((parent->width >> 31) + _t64 >> 1) > (COLS >> 31) + COLS >> 1) {
                 *x = parent->x - width - FRAME_WIDTH + 1;
            }
        }
    }
     *y = parent->y + parent->select - parent->offset;
}

void new_option_menu(Menu* menu, char** label, int* variable, _None* func)
{// addr = 0x08094E38  --  defined in 'menu.c' at line 668
    int i;                                 // _cfa_fffffff0
    int nitem;                             // _cfa_ffffffec
    char** p;                              // _cfa_ffffffe8
    MenuItem* item;   // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    MenuItem* _t64;   // _t64

    if(label == 0) {
        return;
    }
    if( *label != 0) {
        i = 0;
        p = label;
        while( *p != 0) {
            i = i + 1;
            p =  &(p[1]);
        }
        nitem = i;
        _t64 = nitem + 1 << 5;
         *__esp = _t64;
        GC_malloc();
        item = _t64;
        i = 0;
        p = label;
        while(i < nitem) {
            if(func == 0) {
                 *((intOrPtr*)(item + (i << 5))) = 2;
            } else {
                 *((intOrPtr*)(item + (i << 5))) = 6;
            }
             *(item + (i << 5) + 4) =  *p;
             *(item + (i << 5) + 8) = variable;
             *(item + (i << 5) + 12) = i;
             *(item + (i << 5) + 16) = func;
             *(item + (i << 5) + 20) = 0;
             *((intOrPtr*)(item + (i << 5) + 24)) = 135062802;
            i = i + 1;
            p =  &(p[1]);
        }
         *(item + (nitem << 5)) = 0;
        new_menu(menu, item);
        return;
    }
}

void set_menu_frame()
{// addr = 0x08094F62  --  defined in 'menu.c' at line 700
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(graph_ok() != 0) {
        graph_mode = 1;
        FRAME_WIDTH = 1;
        FRAME =  &graph_symbol;
        return;
    }
    graph_mode = 0;
    FRAME_WIDTH = 0;
    FRAME = get_symbol(DisplayCharset,  &FRAME_WIDTH);
    if(( *135119023 & 255) == 0) {
        FRAME_WIDTH = 1;
        return;
    }
}

int mEsc(char c)
{// addr = 0x08094FD6  --  defined in 'menu.c' at line 733
    signed char _v16;                      // _cfa_fffffff0
    int _t11;                              // _t11

    _v16 = c;
    _v16 = do_getch();
    _t11 = _v16;
     *__esp = _t11;
     *((intOrPtr*)( *((intOrPtr*)( &MenuEscKeymap + _v16 * 4))))();
    return _t11;
}

int mEscB(char c)
{// addr = 0x08095000  --  defined in 'menu.c' at line 740
    signed int _v16;                       // _cfa_fffffff0
    int _t19;                              // _t19

    _v16 = c;
    _v16 = do_getch();
    if(( *( &MYCTYPE_MAP + (_v16 & 0xff)) & 8) == 0) {
        _t19 = _v16;
         *__esp = _t19;
         *((intOrPtr*)( *((intOrPtr*)( &MenuEscBKeymap + _v16 * 4))))();
        return _t19;
    }
    return mEscD(_v16);
}

int mEscD(char c)
{// addr = 0x08095050  --  defined in 'menu.c' at line 750
    int d;                                 // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    int _t29;                              // _t29

    _v32 = c;
    d = _v32 - 48;
    _v32 = do_getch();
    if(( *( &MYCTYPE_MAP + (_v32 & 0xff)) & 8) != 0) {
        d = (d << 2) + d + (d << 2) + d + _v32 - 48;
        _v32 = do_getch();
    }
    if(_v32 != 126) {
        return -1;
    } else {
        _t29 = _v32;
         *__esp = _t29;
         *((intOrPtr*)( *((intOrPtr*)( &MenuEscDKeymap + d * 4))))();
        return _t29;
    }
}

int mNull(char c)
{// addr = 0x080950CB  --  defined in 'menu.c' at line 767
    char _v8;                              // _cfa_fffffff8

    _v8 = c;
    return -1;
}

int mSelect(char c)
{// addr = 0x080950DE  --  defined in 'menu.c' at line 773
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v16 = c;
    if(( *( &MYCTYPE_MAP + (_v16 & 0xff)) & 0x11) == 0) {
        return -1;
    }
    return select_menu(CurrentMenu,  *(CurrentMenu->cursorX + (_v16 + 140) * 4));
}

int mDown(char c)
{// addr = 0x0809512F  --  defined in 'menu.c' at line 782
    char _v16;                             // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v16 = c;
    if(CurrentMenu->select < CurrentMenu->nitem - 1) {
        goto_menu(CurrentMenu, CurrentMenu->select + 1, 1);
        return -1;
    }
    return -1;
}

int mUp(char c)
{// addr = 0x08095184  --  defined in 'menu.c' at line 791
    char _v16;                             // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v16 = c;
    if(CurrentMenu->select > 0) {
        goto_menu(CurrentMenu, CurrentMenu->select - 1, -1);
        return -1;
    }
    return -1;
}

int mLast(char c)
{// addr = 0x080951CE  --  defined in 'menu.c' at line 800
    char _v16;                             // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v16 = c;
    goto_menu(CurrentMenu, CurrentMenu->nitem - 1, -1);
    return -1;
}

int mTop(char c)
{// addr = 0x08095205  --  defined in 'menu.c' at line 807
    char _v16;                             // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v16 = c;
    goto_menu(CurrentMenu, 0, 1);
    return -1;
}

int mNext(char c)
{// addr = 0x08095235  --  defined in 'menu.c' at line 814
    int mselect;                           // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    _v32 = c;
    mselect = CurrentMenu->select + CurrentMenu->height;
    if(CurrentMenu->nitem > mselect) {
        down_menu(CurrentMenu, CurrentMenu->height);
        goto_menu(CurrentMenu, mselect, -1);
        return -1;
    }
    return mLast(_v32);
}

int mPrev(char c)
{// addr = 0x080952AE  --  defined in 'menu.c' at line 826
    int mselect;                           // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    _v32 = c;
    mselect = CurrentMenu->select - CurrentMenu->height;
    if(mselect >= 0) {
        up_menu(CurrentMenu, CurrentMenu->height);
        goto_menu(CurrentMenu, mselect, 1);
        return -1;
    }
    return mTop(_v32);
}

int mFore(char c)
{// addr = 0x08095323  --  defined in 'menu.c' at line 838
    char _v16;                             // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v16 = c;
    if(CurrentMenu->select < CurrentMenu->nitem - 1) {
        goto_menu(CurrentMenu, CurrentMenu->select + CurrentMenu->height - 1, CurrentMenu->height + 1);
        return -1;
    }
    return -1;
}

int mBack(char c)
{// addr = 0x0809538A  --  defined in 'menu.c' at line 848
    char _v16;                             // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1

    _v16 = c;
    if(CurrentMenu->select > 0) {
        goto_menu(CurrentMenu, CurrentMenu->select - CurrentMenu->height + 1,  !(CurrentMenu->height));
        return -1;
    }
    return -1;
}

int mLineU(char c)
{// addr = 0x080953EF  --  defined in 'menu.c' at line 858
    int mselect;                           // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    _v32 = c;
    mselect = CurrentMenu->select;
    if(CurrentMenu->nitem > mselect) {
        if(CurrentMenu->offset + CurrentMenu->height < CurrentMenu->nitem) {
            down_menu(CurrentMenu, 1);
            if(CurrentMenu->offset > mselect) {
                mselect = mselect + 1;
            }
        } else {
            mselect = mselect + 1;
        }
        goto_menu(CurrentMenu, mselect, 1);
        return -1;
    }
    return mLast(_v32);
}

int mLineD(char c)
{// addr = 0x0809548E  --  defined in 'menu.c' at line 876
    int mselect;                           // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    _v32 = c;
    mselect = CurrentMenu->select;
    if(mselect > 0) {
        if(CurrentMenu->offset > 0) {
            up_menu(CurrentMenu, 1);
            if(CurrentMenu->offset + CurrentMenu->height <= mselect) {
                mselect = mselect - 1;
            }
        } else {
            mselect = mselect - 1;
        }
        goto_menu(CurrentMenu, mselect, -1);
        return -1;
    }
    return mTop(_v32);
}

int mOk(char c)
{// addr = 0x0809551F  --  defined in 'menu.c' at line 894
    int mselect;                           // _cfa_fffffff8
    char _v24;                             // _cfa_ffffffe8

    _v24 = c;
    mselect = CurrentMenu->select;
    if( *((intOrPtr*)(CurrentMenu->item + (mselect << 5))) != 1) {
        return mselect;
    }
    return -1;
}

int mCancel(char c)
{// addr = 0x08095559  --  defined in 'menu.c' at line 904
    char _v8;                              // _cfa_fffffff8

    _v8 = c;
    return -2;
}

int mClose(char c)
{// addr = 0x0809556C  --  defined in 'menu.c' at line 910
    char _v8;                              // _cfa_fffffff8

    _v8 = c;
    return -3;
}

int mSusp(char c)
{// addr = 0x0809557F  --  defined in 'menu.c' at line 916
    char _v16;                             // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v16 = c;
    susp();
    draw_all_menu(CurrentMenu);
    select_menu(CurrentMenu, CurrentMenu->select);
    return -1;
}

int menuForwardSearch(Menu* menu, char* str, int from)
{// addr = 0x080955BD  --  defined in 'menu.c' at line 929
    int i;                                 // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    p = regexCompile(str, IgnoreCase);
    if(p == 0) {
        if(from < 0) {
            from = 0;
        }
        i = from;
        while(menu->nitem > i) {
            if( *((intOrPtr*)(menu->item + (i << 5))) == 1 || regexMatch( *(menu->item + (i << 5) + 4), -1, 1) != 1) {
                i = i + 1;
                continue;
            } else {
                return i;
            }
        }
        return -1;
    }
    message(p, 0, 0);
    return -1;
}

int menu_search_forward(Menu* menu, int from)
{// addr = 0x08095675  --  defined in 'menu.c' at line 947
    char* str;                             // _cfa_fffffff0
    int found;                             // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    str = inputLineHistSearch("Forward: ", 0, 16, TextHist, 0);
    if(str != 0) {
        if(( *str & 255) == 0) {
            str = SearchString;
        }
    }
    if(str == 0 || ( *str & 255) == 0) {
        return -1;
    }
    SearchString = str;
    str = conv_search_string(str, DisplayCharset);
    menuSearchRoutine = menuForwardSearch;
    found = menuForwardSearch(menu, str, from + 1);
    if(WrapSearch != 0 && found == -1) {
        found = menuForwardSearch(menu, str, 0);
    }
    if(found < 0) {
        disp_message("Not found", 1);
        return -1;
    } else {
        return found;
    }
}

int mSrchF(char c)
{// addr = 0x08095777  --  defined in 'menu.c' at line 969
    int mselect;                           // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    _v32 = c;
    mselect = menu_search_forward(CurrentMenu, CurrentMenu->select);
    if(mselect >= 0) {
        goto_menu(CurrentMenu, mselect, 1);
    }
    return -1;
}

int menuBackwardSearch(Menu* menu, char* str, int from)
{// addr = 0x080957C8  --  defined in 'menu.c' at line 979
    int i;                                 // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    p = regexCompile(str, IgnoreCase);
    if(p == 0) {
        if(menu->nitem <= from) {
            from = menu->nitem - 1;
        }
        i = from;
        while(i >= 0) {
            if( *((intOrPtr*)(menu->item + (i << 5))) == 1 || regexMatch( *(menu->item + (i << 5) + 4), -1, 1) != 1) {
                i = i - 1;
                continue;
            } else {
                return i;
            }
        }
        return -1;
    }
    message(p, 0, 0);
    return -1;
}

int menu_search_backward(Menu* menu, int from)
{// addr = 0x08095885  --  defined in 'menu.c' at line 997
    char* str;                             // _cfa_fffffff0
    int found;                             // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    str = inputLineHistSearch("Backward: ", 0, 16, TextHist, 0);
    if(str != 0) {
        if(( *str & 255) == 0) {
            str = SearchString;
        }
    }
    if(str == 0 || ( *str & 255) == 0) {
        return -1;
    }
    SearchString = str;
    str = conv_search_string(str, DisplayCharset);
    menuSearchRoutine = menuBackwardSearch;
    found = menuBackwardSearch(menu, str, from - 1);
    if(WrapSearch != 0 && found == -1) {
        found = menuBackwardSearch(menu, str, menu->nitem);
    }
    if(found < 0) {
        disp_message("Not found", 1);
        return -1;
    } else {
        return found;
    }
}

int mSrchB(char c)
{// addr = 0x08095989  --  defined in 'menu.c' at line 1019
    int mselect;                           // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    _v32 = c;
    mselect = menu_search_backward(CurrentMenu, CurrentMenu->select);
    if(mselect >= 0) {
        goto_menu(CurrentMenu, mselect, -1);
    }
    return -1;
}

int menu_search_next_previous(Menu* menu, int from, int reverse)
{// addr = 0x080959DA  --  defined in 'menu.c' at line 1029
    int found;                             // _cfa_fffffff0
    char* str;                             // _cfa_ffffffec
    signed int _v36;                       // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    int _t39;                              // _t39
    int _t43;                              // _t43
    int _t52;                              // _t52

    if(menuSearchRoutine != 0) {
        str = conv_search_string(SearchString, DisplayCharset);
        if(reverse != 0) {
            reverse = 1;
        }
        if(menuSearchRoutine == menuBackwardSearch) {
            reverse = reverse ^ 1;
        }
        if(reverse == 0) {
            _t39 = 1;
        } else {
            _t39 = -1;
        }
        from = from + _t39;
        _v36 = from;
        _v40 = str;
        _t43 = menu;
         *__esp = _t43;
         *((intOrPtr*)( *((intOrPtr*)(reverse * 4 +  &routine.8886))))();
        found = _t43;
        if(WrapSearch != 0 && found == -1) {
            _v36 = menu->nitem * reverse;
            _v40 = str;
            _t52 = menu;
             *__esp = _t52;
             *((intOrPtr*)( *((intOrPtr*)(reverse * 4 +  &routine.8886))))();
            found = _t52;
        }
        if(found < 0) {
            disp_message("Not found", 1);
            return -1;
        } else {
            return found;
        }
    }
    disp_message("No previous regular expression", 1);
    return -1;
}

int mSrchN(char c)
{// addr = 0x08095AD5  --  defined in 'menu.c' at line 1056
    int mselect;                           // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    _v32 = c;
    mselect = menu_search_next_previous(CurrentMenu, CurrentMenu->select, 0);
    if(mselect >= 0) {
        goto_menu(CurrentMenu, mselect, 1);
    }
    return -1;
}

int mSrchP(char c)
{// addr = 0x08095B2E  --  defined in 'menu.c' at line 1066
    int mselect;                           // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    _v32 = c;
    mselect = menu_search_next_previous(CurrentMenu, CurrentMenu->select, 1);
    if(mselect >= 0) {
        goto_menu(CurrentMenu, mselect, -1);
    }
    return -1;
}

int mMouse_scroll_line()
{// addr = 0x08095B87  --  defined in 'menu.c' at line 1087
    int i;                                 // _cfa_fffffff8

    i = 0;
    if(relative_wheel_scroll == 0) {
        i = fixed_wheel_scroll_count;
    } else {
        i = ((relative_wheel_scroll_ratio * CurrentMenu->height + 99) * 1374389535 >> 32 >> 5) - (relative_wheel_scroll_ratio * CurrentMenu->height + 99 >> 31);
    }
    if(i == 0) {
        return 1;
    } else {
        return i;
    }
}

int process_mMouse(int btn, int x, int y)
{// addr = 0x08095BE6  --  defined in 'menu.c' at line 1098
    char c;                                // _cfa_fffffff3
    Menu* menu;           // _cfa_ffffffec
    int mselect;                           // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t124;                             // _t124

    c = 32;
    menu = CurrentMenu;
    if(x < 0 || x >= COLS || y < 0 || LINES - 1 < y) {
        return -1;
    }
    if(btn != 3) {
        if(btn != 64) {
            if(btn != 65) {
                goto L57;
            }
            i = 0;
            while(mMouse_scroll_line() > i) {
                mLineU(c);
                i = i + 1;
            }
            goto L57;
        }
        i = 0;
        while(mMouse_scroll_line() > i) {
            mLineD(c);
            i = i + 1;
        }
        goto L57;
    } else {
        _t124 = press_btn.8969;
        if(_t124 == 2) {
L13:
            if(menu->x - FRAME_WIDTH > x || menu->x + menu->width + FRAME_WIDTH <= x || menu->y - 1 > y || menu->y + menu->height + 1 <= y) {
                return -2;
            }
            if(menu->x - FRAME_WIDTH > x || menu->x <= x) {
                if(menu->x + menu->width > x || menu->x + menu->width + FRAME_WIDTH <= x) {
                    if(press_y.8971 <= y) {
                        if(press_y.8971 >= y) {
                            if(menu->y - 1 != y) {
                                if(menu->y + menu->height != y) {
                                    mselect = y - menu->y + menu->offset;
                                    if( *((intOrPtr*)(menu->item + (mselect << 5))) != 1) {
                                        return select_menu(menu, mselect);
                                    }
                                    return -1;
                                }
                                mNext(c);
                                return -1;
                            }
                            mPrev(c);
                            return -1;
                        }
                        i = 0;
                        while(y - press_y.8971 > i) {
                            mLineD(c);
                            i = i + 1;
                        }
                        return -1;
                    } else {
                        i = 0;
                        goto L26;
                        do {
                        } while();
L26:
                        if(press_y.8971 - y > i) {
                            mLineU(c);
                            i = i + 1;
                        } else {
                            return -1;
                        }
                        goto L26;
                    }
                } else {
                    goto L22;
                }
            } else {
L22:
                return -1;
            }
        }
        if(_t124 > 2) {
            if(_t124 == 3) {
                i = 0;
                while(mMouse_scroll_line() > i) {
                    mLineD(c);
                    i = i + 1;
                }
L57:
                if(btn != 3 || press_btn.8969 == -1) {
                    press_btn.8969 = btn;
                    press_x.8970 = x;
                    press_y.8971 = y;
                } else {
                    press_btn.8969 = -1;
                }
                return -1;
            }
            if(_t124 == 4) {
                i = 0;
                while(mMouse_scroll_line() > i) {
                    mLineU(c);
                    i = i + 1;
                }
            } else {
            }
            goto L57;
        }
        if(_t124 == 0) {
            goto L13;
        } else {
            goto L57;
        }
    }
}

int mMouse(char c)
{// addr = 0x08095F06  --  defined in 'menu.c' at line 1181
    int btn;                               // _cfa_fffffff0
    int x;                                 // _cfa_ffffffec
    int y;                                 // _cfa_ffffffe8
    char _v32;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    _v32 = c;
    btn = (do_getch() & 255) - 32;
    x = (do_getch() & 255) - 33;
    if(x < 0) {
        x = x + 256;
    }
    y = (do_getch() & 255) - 33;
    if(y < 0) {
        y = y + 256;
    }
    return process_mMouse(btn, x, y);
}

int gpm_process_menu_mouse(Gpm_Event* event, _Unknown_base* data)
{// addr = 0x08095F71  --  defined in 'menu.c' at line 1208
    int btn;                               // _cfa_fffffff0
    int x;                                 // _cfa_ffffffec
    int y;                                 // _cfa_ffffffe8
    intOrPtr _v36;                         // _cfa_ffffffdc (outparam)
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    short* _t39;                           // _t39
    short* _t43;                           // _t43
    signed int _t51;                       // _t51

    btn = -1;
    if((event->type & 8) == 0) {
        if((event->type & 4) == 0) {
             *135774721 = 2;
            _t39 =  &(__imp___gpm_arg[2]);
             *_t39 = (event->x & 65535) + __imp__gpm_zerobased;
             *__imp___gpm_arg =  *_t39 & 65535;
            _t43 =  &(__imp___gpm_arg[3]);
             *_t43 = (event->y & 65535) + __imp__gpm_zerobased;
            __imp___gpm_arg[1] =  *_t43 & 65535;
            __imp___gpm_arg[4] = 3;
            _v36 = 135774721;
            _v40 = 21532;
             *__esp = __imp__gpm_consolefd;
            ioctl();
            return 0;
        } else {
            _t51 = event->buttons & 0xff;
            if(_t51 == 2) {
                btn = 1;
            } else {
                if(_t51 == 4) {
                    btn = 0;
                } else {
                    if(_t51 == 1) {
                        btn = 2;
                    }
                }
            }
            goto L11;
        }
    } else {
        btn = 3;
L11:
        x = event->x & 65535;
        y = event->y & 65535;
        X_Mouse_Selection = process_mMouse(btn, x - 1, y - 1);
        return -1;
    }
}

void popupMenu(int x, int y, Menu* menu)
{// addr = 0x080960B8  --  defined in 'menu.c' at line 1271
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    set_menu_frame();
    initSelectMenu();
    initSelTabMenu();
    menu->cursorX = (CurrentTab->currentBuffer->cursorX & 65535) + (CurrentTab->currentBuffer->rootX & 65535);
    menu->cursorY = (CurrentTab->currentBuffer->cursorY & 65535) + (CurrentTab->currentBuffer->rootY & 65535);
    menu->x = FRAME_WIDTH + x + 1;
    menu->y = y + 2;
    popup_menu(0, menu);
}

void mainMenu(int x, int y)
{// addr = 0x08096147  --  defined in 'menu.c' at line 1287
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    popupMenu(x, y,  &MainMenu);
}

void mainMn()
{// addr = 0x08096169  --  defined in 'menu.c' at line 1292
    Menu* menu;           // _cfa_fffffff0
    char* data;                            // _cfa_ffffffec
    int n;                                 // _cfa_ffffffe8
    int x;                                 // _cfa_ffffffe4
    int y;                                 // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    menu =  &MainMenu;
    x = (CurrentTab->currentBuffer->cursorX & 65535) + (CurrentTab->currentBuffer->rootX & 65535);
    y = (CurrentTab->currentBuffer->cursorY & 65535) + (CurrentTab->currentBuffer->rootY & 65535);
    data = searchKeyData();
    if(data == 0) {
L3:
        if( *135792272 != 0) {
            x =  *135792276;
            y =  *135792280;
        }
        popupMenu(x, y, menu);
        return;
    }
    n = getMenuN(w3mMenuList, data);
    if(n >= 0) {
        menu =  *(w3mMenuList + (n + n + _t65 << 2) + 4);
        goto L3;
    }
}

void selMn()
{// addr = 0x08096237  --  defined in 'menu.c' at line 1320
    int x;                                 // _cfa_fffffff0
    int y;                                 // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    x = (CurrentTab->currentBuffer->cursorX & 65535) + (CurrentTab->currentBuffer->rootX & 65535);
    y = (CurrentTab->currentBuffer->cursorY & 65535) + (CurrentTab->currentBuffer->rootY & 65535);
    if( *135792272 != 0) {
        x =  *135792276;
        y =  *135792280;
    }
    popupMenu(x, y,  &SelectMenu);
}

void initSelectMenu()
{// addr = 0x080962B6  --  defined in 'menu.c' at line 1335
    int i;                                 // _cfa_fffffff0
    int nitem;                             // _cfa_ffffffec
    int len;                               // _cfa_ffffffe8
    int l;                                 // _cfa_ffffffe4
    Buffer* buf;        // _cfa_ffffffe0
    Str str;               // _cfa_ffffffdc
    char** label;                          // _cfa_ffffffd8
    char* p;                               // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    char** _t185;                          // _t185
    ParsedURL _t204;   // _t204
    char* _t206;                           // _t206
    int _t213;                             // _t213
    int _t232;                             // _t232
    int _t257;                             // _t257
    int _t266;                             // _t266
    int _t282;                             // _t282

    len = 0;
    SelectV = -1;
    i = 0;
    buf = CurrentTab->firstBuffer;
    do {
    } while(buf != 0);
    nitem = i;
    _t185 = nitem + 2 << 2;
     *__esp = _t185;
    GC_malloc();
    label = _t185;
    i = 0;
    buf = CurrentTab->firstBuffer;
    while(i < nitem) {
        _v56 = buf->buffername;
        str = Sprintf("<%s>");
        if(buf->filename != 0) {
            _t204 = buf->currentURL;
            if(_t204 == 4) {
                _t206 = buf->currentURL.file;
                _v56 = 135063092;
                 *__esp = _t206;
                strcmp();
                if(_t206 != 0) {
                    if(str->length + 1 >= str->area_size) {
                        Strgrow(str);
                    }
                    _t213 = str->length;
                     *((char*)(str->ptr + _t213)) = 32;
                    str->length = _t213 + 1;
                     *((char*)(str->ptr + str->length)) = 0;
                    Strcat_charp(str,  *(wc_Str_conv(Strnew_charp(buf->currentURL.real_file), SystemCharset, InnerCharset)));
                }
            } else {
                if(_t204 != 254) {
                    if(str->length + 1 >= str->area_size) {
                        Strgrow(str);
                    }
                    _t232 = str->length;
                     *((char*)(str->ptr + _t232)) = 32;
                    str->length = _t232 + 1;
                     *((char*)(str->ptr + str->length)) = 0;
                    p =  *(parsedURL2Str( &(buf->currentURL)));
                    if(DecodeURL != 0) {
                        p = url_unquote_conv(p, 0);
                    }
                    Strcat_charp(str, p);
                }
            }
        }
        label[i] = str->ptr;
        if(str->length > len) {
            len = str->length;
        }
        i = i + 1;
        buf = buf->nextBuffer;
    }
    l = wtf_strwidth(comment.9275);
    if(l + 4 > len) {
        len = l + 4;
    }
    if(0 - FRAME_WIDTH + 0 - FRAME_WIDTH + COLS < len) {
        len = 0 - FRAME_WIDTH + 0 - FRAME_WIDTH + COLS;
    }
    if(len <= 1) {
        _t257 = 0;
    } else {
        _t257 = (len - l + 1 >> 31) + len - l + 1 >> 1;
    }
    len = _t257;
    str = Strnew();
    i = 0;
    while(i < len) {
        if(str->length + 1 >= str->area_size) {
            Strgrow(str);
        }
        _t266 = str->length;
         *((char*)(str->ptr + _t266)) = 45;
        str->length = _t266 + 1;
         *((char*)(str->ptr + str->length)) = 0;
        i = i + 1;
    }
    Strcat_charp(str, comment.9275);
    i = 0;
    while(i < len) {
        if(str->length + 1 >= str->area_size) {
            Strgrow(str);
        }
        _t282 = str->length;
         *((char*)(str->ptr + _t282)) = 45;
        str->length = _t282 + 1;
         *((char*)(str->ptr + str->length)) = 0;
        i = i + 1;
    }
    label[nitem] = str->ptr;
    label[nitem + 1] = 0;
    new_option_menu( &SelectMenu, label,  &SelectV, smChBuf);
     *135779364 = SelectV;
     *135779332 = (CurrentTab->currentBuffer->cursorX & 65535) + (CurrentTab->currentBuffer->rootX & 65535);
     *135779336 = (CurrentTab->currentBuffer->cursorY & 65535) + (CurrentTab->currentBuffer->rootY & 65535);
     *135779652 = smDelBuf;
     *((intOrPtr*)( *135779360 + (nitem << 5))) = 1;
}

void smChBuf()
{// addr = 0x08096722  --  defined in 'menu.c' at line 1403
    int i;                                 // _cfa_fffffff0
    Buffer* buf;        // _cfa_ffffffec

    if(SelectV < 0) {
        return;
    }
    if( *135779356 > SelectV) {
        i = 0;
        buf = CurrentTab->firstBuffer;
        while(i < SelectV) {
            i = i + 1;
            buf = buf->nextBuffer;
        }
        CurrentTab->currentBuffer = buf;
        buf = CurrentTab->firstBuffer;
        while(buf != 0) {
            if(CurrentTab->currentBuffer != buf) {
                deleteImage(buf);
                if(clear_buffer != 0) {
                    tmpClearBuffer(buf);
                }
            }
            buf = buf->nextBuffer;
        }
        return;
    }
}

int smDelBuf(char c)
{// addr = 0x080967D1  --  defined in 'menu.c' at line 1424
    int i;                                 // _cfa_fffffff0
    int x;                                 // _cfa_ffffffec
    int y;                                 // _cfa_ffffffe8
    int mselect;                           // _cfa_ffffffe4
    Buffer* buf;        // _cfa_ffffffe0
    char _v48;                             // _cfa_ffffffd0
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t90;                              // _t90
    int _t115;                             // _t115

    _v48 = c;
    if(CurrentMenu->select < 0 || CurrentMenu->select >=  *135779356) {
        return -1;
    } else {
        i = 0;
        buf = CurrentTab->firstBuffer;
        while(CurrentMenu->select > i) {
            i = i + 1;
            buf = buf->nextBuffer;
        }
        if(CurrentTab->currentBuffer == buf) {
            CurrentTab->currentBuffer = buf->nextBuffer;
        }
        CurrentTab->firstBuffer = deleteBuffer(CurrentTab->firstBuffer, buf);
        if(CurrentTab->currentBuffer == 0) {
            CurrentTab->currentBuffer = nthBuffer(CurrentTab->firstBuffer, i - 1);
        }
        if(CurrentTab->firstBuffer == 0) {
            CurrentTab->firstBuffer = nullBuffer();
            CurrentTab->currentBuffer = CurrentTab->firstBuffer;
        }
        x = CurrentMenu->x;
        y = CurrentMenu->y;
        mselect = CurrentMenu->select;
        initSelectMenu();
        CurrentMenu->x = x;
        CurrentMenu->y = y;
        geom_menu(CurrentMenu, x, y, 0);
        _t115 = CurrentMenu->nitem - 2;
        _t90 = mselect;
        _t91 = _t115 - _t90 <= 0 ? _t115 : _t90;
        CurrentMenu->select = _t115 - _t90 <= 0 ? _t115 : _t90;
        displayBuffer(CurrentTab->currentBuffer, 1);
        draw_all_menu(CurrentMenu);
        select_menu(CurrentMenu, CurrentMenu->select);
        return -1;
    }
}

void tabMn()
{// addr = 0x0809698C  --  defined in 'menu.c' at line 1467
    int x;                                 // _cfa_fffffff0
    int y;                                 // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    x = (CurrentTab->currentBuffer->cursorX & 65535) + (CurrentTab->currentBuffer->rootX & 65535);
    y = (CurrentTab->currentBuffer->cursorY & 65535) + (CurrentTab->currentBuffer->rootY & 65535);
    if( *135792272 != 0) {
        x =  *135792276;
        y =  *135792280;
    }
    popupMenu(x, y,  &SelTabMenu);
}

void initSelTabMenu()
{// addr = 0x08096A0B  --  defined in 'menu.c' at line 1482
    int i;                                 // _cfa_fffffff0
    int nitem;                             // _cfa_ffffffec
    int len;                               // _cfa_ffffffe8
    int l;                                 // _cfa_ffffffe4
    TabBuffer* tab;   // _cfa_ffffffe0
    Buffer* buf;        // _cfa_ffffffdc
    Str str;               // _cfa_ffffffd8
    char** label;                          // _cfa_ffffffd4
    char* p;                               // _cfa_ffffffd0
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    int _v72;                              // _cfa_ffffffb8 (outparam)
    char** _t166;                          // _t166
    int _t186;                             // _t186
    char* _t188;                           // _t188
    int _t195;                             // _t195
    int _t217;                             // _t217
    int _t225;                             // _t225
    int _t234;                             // _t234
    int _t250;                             // _t250

    len = 0;
    SelTabV = -1;
    i = 0;
    tab = LastTab;
    do {
    } while(tab != 0);
    nitem = i;
    _t166 = nitem + 2 << 2;
     *__esp = _t166;
    GC_malloc();
    label = _t166;
    i = 0;
    tab = LastTab;
    while(i < nitem) {
        buf = tab->currentBuffer;
        _v72 = buf->buffername.scheme;
        str = Sprintf("<%s>");
        if(buf->filename != 0) {
            _t186 = buf->currentURL.scheme;
            if(_t186 == 4) {
                _t188 = buf->currentURL.file;
                _v72 = 135063092;
                 *__esp = _t188;
                strcmp();
                if(_t188 != 0) {
                    if(str->length + 1 >= str->area_size) {
                        Strgrow(str);
                    }
                    _t195 = str->length;
                     *((char*)(str->ptr + _t195)) = 32;
                    str->length = _t195 + 1;
                     *((char*)(str->ptr + str->length)) = 0;
                    Strcat_charp(str,  *(wc_Str_conv(Strnew_charp(buf->currentURL.real_file), SystemCharset, InnerCharset)));
                }
            } else {
                if(_t186 != 254) {
                    p =  *(parsedURL2Str( &(buf->currentURL)));
                    if(DecodeURL != 0) {
                        p = url_unquote_conv(p, 0);
                    }
                    Strcat_charp(str, p);
                }
            }
        }
        label[i] = str->ptr;
        if(str->length > len) {
            len = str->length;
        }
        i = i + 1;
        tab = tab->prevTab;
    }
    _t217 = comment.9583;
     *__esp = _t217;
    strlen();
    l = _t217;
    if(l + 4 > len) {
        len = l + 4;
    }
    if(0 - FRAME_WIDTH + 0 - FRAME_WIDTH + COLS < len) {
        len = 0 - FRAME_WIDTH + 0 - FRAME_WIDTH + COLS;
    }
    if(len <= 1) {
        _t225 = 0;
    } else {
        _t225 = (len - l + 1 >> 31) + len - l + 1 >> 1;
    }
    len = _t225;
    str = Strnew();
    i = 0;
    while(i < len) {
        if(str->length + 1 >= str->area_size) {
            Strgrow(str);
        }
        _t234 = str->length;
         *((char*)(str->ptr + _t234)) = 45;
        str->length = _t234 + 1;
         *((char*)(str->ptr + str->length)) = 0;
        i = i + 1;
    }
    Strcat_charp(str, comment.9583);
    i = 0;
    while(i < len) {
        if(str->length + 1 >= str->area_size) {
            Strgrow(str);
        }
        _t250 = str->length;
         *((char*)(str->ptr + _t250)) = 45;
        str->length = _t250 + 1;
         *((char*)(str->ptr + str->length)) = 0;
        i = i + 1;
    }
    label[nitem] = str->ptr;
    label[nitem + 1] = 0;
    new_option_menu( &SelTabMenu, label,  &SelTabV, smChTab);
     *135780452 = SelTabV;
     *135780420 = (CurrentTab->currentBuffer->cursorX & 65535) + (CurrentTab->currentBuffer->rootX & 65535);
     *135780424 = (CurrentTab->currentBuffer->cursorY & 65535) + (CurrentTab->currentBuffer->rootY & 65535);
     *135780740 = smDelTab;
     *((intOrPtr*)( *135780448 + (nitem << 5))) = 1;
}

void smChTab()
{// addr = 0x08096E29  --  defined in 'menu.c' at line 1551
    int i;                                 // _cfa_fffffff0
    TabBuffer* tab;   // _cfa_ffffffec
    Buffer* buf;        // _cfa_ffffffe8

    if(SelTabV < 0) {
        return;
    }
    if( *135780444 <= SelTabV) {
        return;
    }
    i = 0;
    tab = LastTab;
    while(i < SelTabV && tab != 0) {
        i = i + 1;
        tab = tab->prevTab;
    }
    CurrentTab = tab;
    tab = LastTab;
    while(tab != 0) {
        if(tab != CurrentTab) {
            buf = tab->currentBuffer;
            deleteImage(buf);
            if(clear_buffer != 0) {
                tmpClearBuffer(buf);
            }
        }
        tab = tab->prevTab;
    }
}

int smDelTab(char c)
{// addr = 0x08096EDB  --  defined in 'menu.c' at line 1575
    int i;                                 // _cfa_fffffff0
    int x;                                 // _cfa_ffffffec
    int y;                                 // _cfa_ffffffe8
    int mselect;                           // _cfa_ffffffe4
    TabBuffer* tab;   // _cfa_ffffffe0
    char _v48;                             // _cfa_ffffffd0
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    int _t62;                              // _t62
    int _t78;                              // _t78

    _v48 = c;
    if(CurrentMenu->select < 0 || CurrentMenu->select >=  *135780444) {
        return -1;
    }
    i = 0;
    tab = LastTab;
    while(CurrentMenu->select > i && tab != 0) {
        i = i + 1;
        tab = tab->prevTab;
    }
    deleteTab(tab);
    x = CurrentMenu->x;
    y = CurrentMenu->y;
    mselect = CurrentMenu->select;
    initSelTabMenu();
    CurrentMenu->x = x;
    CurrentMenu->y = y;
    geom_menu(CurrentMenu, x, y, 0);
    _t78 = CurrentMenu->nitem - 2;
    _t62 = mselect;
    _t63 = _t78 - _t62 <= 0 ? _t78 : _t62;
    CurrentMenu->select = _t78 - _t62 <= 0 ? _t78 : _t62;
    displayBuffer(CurrentTab->currentBuffer, 1);
    draw_all_menu(CurrentMenu);
    select_menu(CurrentMenu, CurrentMenu->select);
    return -1;
}

void optionMenu(int x, int y, char** label, int* variable, int initial, _None* func)
{// addr = 0x0809700A  --  defined in 'menu.c' at line 1611
    int _v1052;                            // _cfa_fffffbe4
    int _v1072;                            // _cfa_fffffbd0
    int _v1076;                            // _cfa_fffffbcc
    int _v1080;                            // _cfa_fffffbc8
    int _v1084;                            // _cfa_fffffbc4
    Menu menu;            // _cfa_fffffbc0
    _unknown_ _v1104;                      // _cfa_fffffbb0 (outparam)
    _unknown_ _v1108;                      // _cfa_fffffbac (outparam)
    _unknown_ _v1112;                      // _cfa_fffffba8 (outparam)

    set_menu_frame();
    new_option_menu( &menu, label, variable, func);
    _v1084 = COLS - 1;
    _v1080 = LINES - 1;
    _v1076 = x;
    _v1072 = y;
    _v1052 = initial;
    popup_menu(0,  &menu);
}

void interpret_menu(FILE* mf)
{// addr = 0x0809708A  --  defined in 'menu.c' at line 1633
    Str line;              // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* s;                               // _cfa_ffffffe8
    int in_menu;                           // _cfa_ffffffe4
    int nmenu;                             // _cfa_ffffffe0
    int nitem;                             // _cfa_ffffffdc
    int type;                              // _cfa_ffffffd8
    MenuItem* item;   // _cfa_ffffffd4
    wc_ces charset;     // _cfa_ffffffd0
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    signed int _v72;                       // _cfa_ffffffb8 (outparam)
    FILE* _t81;           // _t81
    char* _t98;                            // _t98
    char* _t99;                            // _t99
    char* _t107;                           // _t107
    MenuItem* _t136;   // _t136

    in_menu = 0;
    nmenu = 0;
    nitem = 0;
    item = 0;
    charset = SystemCharset;
    while(1) {
        _t81 = mf;
         *__esp = _t81;
        feof();
        if(_t81 != 0) {
            break;
        }
        line = Strfgets(mf);
        Strchop(line);
        Strremovefirstspaces(line);
        if(line->length == 0) {
            continue;
        }
        line = wc_Str_conv(line, charset, InnerCharset);
        p = line->ptr;
        s = getWord( &p);
        if(( *s & 255) == 35) {
            continue;
        }
        if(in_menu == 0) {
            _v72 = 135063094;
            _t98 = s;
             *__esp = _t98;
            strcmp();
            if(_t98 != 0) {
                _v72 = "charset";
                _t99 = s;
                 *__esp = _t99;
                strcmp();
                if(_t99 == 0) {
L16:
                    s = getQWord( &p);
                    if(( *s & 255) != 0) {
                        charset = wc_guess_charset(s, charset);
                    }
                    continue;
                }
                _v72 = "encoding";
                _t107 = s;
                 *__esp = _t107;
                strcmp();
                if(_t107 != 0) {
                    continue;
                }
                goto L16;
            }
            s = getQWord( &p);
            if(( *s & 255) != 0) {
                in_menu = 1;
                nmenu = getMenuN(w3mMenuList, s);
                if(nmenu == -1) {
                    nmenu = addMenuList( &w3mMenuList, s);
                } else {
                    _t128 = nmenu + nmenu + _t154 << 2;
                     *__esp = 32;
                    GC_malloc();
                     *(w3mMenuList + _t128 + 8) = nmenu + nmenu + _t154 << 2;
                }
                item =  *(w3mMenuList + (nmenu + nmenu + _t149 << 2) + 8);
                nitem = 0;
                 *(item + (nitem << 5)) = 0;
            }
        } else {
            type = setMenuItem(item + (nitem << 5), s, p);
            if(type != -1) {
                if(type != 0) {
                    nitem = nitem + 1;
                    _v72 = nitem + 1 << 5;
                    _t136 = item;
                     *__esp = _t136;
                    GC_realloc();
                    item = _t136;
                     *(w3mMenuList + (nmenu + nmenu + _t152 << 2) + 8) = item;
                     *(item + (nitem << 5)) = 0;
                } else {
                    in_menu = 0;
                }
            }
        }
    }
}

void initMenu()
{// addr = 0x08097311  --  defined in 'menu.c' at line 1694
    FILE* mf;             // _cfa_fffffff0
    MenuList* list;   // _cfa_ffffffec
    MenuItem* item;   // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    FILE* _t57;           // _t57
    FILE* _t58;           // _t58
    char* _t75;                            // _t75

     *__esp = 36;
    GC_malloc();
    w3mMenuList = __eax;
    w3mMenuList->id = "Main";
    w3mMenuList->menu =  &MainMenu;
    w3mMenuList->item =  &MainMenuItem;
     *((intOrPtr*)(w3mMenuList + 12)) = "Select";
     *(w3mMenuList + 0x10) =  &SelectMenu;
     *((intOrPtr*)(w3mMenuList + 0x14)) = 0;
     *((intOrPtr*)(w3mMenuList + 24)) = "SelectTab";
     *(w3mMenuList + 0x1c) =  &SelTabMenu;
     *((intOrPtr*)(w3mMenuList + 0x20)) = 0;
     *((intOrPtr*)(w3mMenuList + 36)) = 0;
    if(MainMenuEncode == 0) {
        MainMenuCharset = SystemCharset;
        item =  &MainMenuItem;
        while(item->type != 0) {
            _t75 = item->label;
             *__esp = _t75;
            gettext();
            item->label =  *(wc_Str_conv(Strnew_charp(_t75), MainMenuCharset, InnerCharset));
            item = item + 32;
        }
        MainMenuEncode = 1;
    }
    _t57 = confFile(135063094);
    _v40 = "rt";
     *__esp = _t57;
    fopen();
    mf = _t57;
    if(mf != 0) {
        interpret_menu(mf);
         *__esp = mf;
        fclose();
    }
    _t58 = rcFile(135063094);
    _v40 = "rt";
     *__esp = _t58;
    fopen();
    mf = _t58;
    if(mf != 0) {
        interpret_menu(mf);
         *__esp = mf;
        fclose();
    }
    list = w3mMenuList;
    while(list->id != 0) {
        if(list->item != 0) {
            new_menu(list->menu, list->item);
        }
        list = list + 12;
    }
}

int setMenuItem(MenuItem* item, char* type, char* line)
{// addr = 0x080974DB  --  defined in 'menu.c' at line 1742
    char* label;                           // _cfa_fffffff0
    char* func;                            // _cfa_ffffffec
    char* popup;                           // _cfa_ffffffe8
    char* keys;                            // _cfa_ffffffe4
    char* data;                            // _cfa_ffffffe0
    int f;                                 // _cfa_ffffffdc
    int n;                                 // _cfa_ffffffd8
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    char* _t73;                            // _t73
    char* _t74;                            // _t74
    char* _t75;                            // _t75
    char* _t76;                            // _t76

    if(type == 0 || ( *type & 255) == 0) {
        return -1;
    } else {
        _v56 = "end";
        _t73 = type;
         *__esp = _t73;
        strcmp();
        if(_t73 != 0) {
            _v56 = "nop";
            _t74 = type;
             *__esp = _t74;
            strcmp();
            if(_t74 != 0) {
                _v56 = "func";
                _t75 = type;
                 *__esp = _t75;
                strcmp();
                if(_t75 != 0) {
                    _v56 = "popup";
                    _t76 = type;
                     *__esp = _t76;
                    strcmp();
                    if(_t76 != 0) {
                        return -1;
                    }
                    label = getQWord( &line);
                    popup = getQWord( &line);
                    keys = getQWord( &line);
                    if(( *popup & 255) != 0) {
                        item->type = 8;
                        item->label = label;
                        n = getMenuN(w3mMenuList, popup);
                        if(n == -1) {
                            n = addMenuList( &w3mMenuList, popup);
                        }
                        item->popup =  *(w3mMenuList + (n + n + _t130 << 2) + 4);
                        item->keys = keys;
                        return 8;
                    }
                    return -1;
                }
                label = getQWord( &line);
                func = getWord( &line);
                keys = getQWord( &line);
                data = getQWord( &line);
                if(( *func & 255) != 0) {
                    item->type = 4;
                    item->label = label;
                    f = getFuncList(func);
                    _t116 = f >= 0 ? f : 0;
                    item->func =  *(135103140 + (f >= 0 ? f : 0) * 8);
                    item->keys = keys;
                    item->data = data;
                    return 4;
                }
                return -1;
            }
            item->type = 1;
            item->label = getQWord( &line);
            return 1;
        }
        item->type = 0;
        return 0;
    }
}

int addMenuList(MenuList** mlist, char* id)
{// addr = 0x080976ED  --  defined in 'menu.c' at line 1792
    int n;                                 // _cfa_fffffff0
    MenuList* list;   // _cfa_ffffffec
    intOrPtr _v40;                         // _cfa_ffffffd8
    MenuList* _t35;   // _t35
    char* _t43;                            // _t43
    MenuItem* _t44;   // _t44

    list =  *mlist;
    n = 0;
    while(list->id != 0) {
        list = list + 12;
        n = n + 1;
    }
    _t49 = n;
    _t35 =  *mlist;
    _v40 = (n + _t49 + _t49 << 2) + 24;
     *__esp = _t35;
    GC_realloc();
     *mlist = _t35;
    list =  *mlist + (n + n + _t52 << 2);
    _t43 = list;
     *_t43 = id;
     *__esp = 1076;
    GC_malloc();
    _t44 = list;
    _t44->label = _t43;
     *__esp = 32;
    GC_malloc();
    list->item = _t44;
     *(list + 12) = 0;
    return n;
}

int getMenuN(MenuList* list, char* id)
{// addr = 0x08097796  --  defined in 'menu.c' at line 1808
    int n;                                 // _cfa_fffffff0
    char* _v40;                            // _cfa_ffffffd8
    char* _t15;                            // _t15

    n = 0;
    while(list->id != 0) {
        _v40 = list->id;
        _t15 = id;
         *__esp = _t15;
        strcmp();
        if(_t15 != 0) {
            list = list + 12;
            n = n + 1;
            continue;
        }
        return n;
    }
    return -1;
}

LinkList* link_menu(Buffer* buf)
{// addr = 0x080977DA  --  defined in 'menu.c' at line 1822
    LinkList* l;      // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int nitem;                             // _cfa_ffffffe8
    int len;                               // _cfa_ffffffe4
    int linkV;                             // _cfa_ffffffe0
    char** label;                          // _cfa_ffffffdc
    Str str;               // _cfa_ffffffd8
    char* p;                               // _cfa_ffffffd4
    LinkList* _v1084;   // _cfa_fffffbc4
    intOrPtr _v1104;                       // _cfa_fffffbb0
    intOrPtr _v1108;                       // _cfa_fffffbac
    intOrPtr _v1112;                       // _cfa_fffffba8
    intOrPtr _v1116;                       // _cfa_fffffba4
    Menu menu;            // _cfa_fffffba0
    _unknown_ _v1136;                      // _cfa_fffffb90 (outparam)
    _unknown_ _v1140;                      // _cfa_fffffb8c (outparam)
    _unknown_ _v1144;                      // _cfa_fffffb88 (outparam)
    char** _t116;                          // _t116
    char* _t121;                           // _t121

    len = 0;
    linkV = -1;
    if(buf->linklist == 0) {
        return 0;
    }
    i = 0;
    l = buf->linklist;
    while(l != 0) {
        i = i + 1;
        l = l->next;
    }
    nitem = i;
    _t116 = nitem + 1 << 2;
     *__esp = _t116;
    GC_malloc();
    label = _t116;
    i = 0;
    l = buf->linklist;
    while(l != 0) {
        if(l->title == 0) {
            _t121 = "(empty)";
        } else {
            _t121 = l->title;
        }
        str = Strnew_charp(_t121);
        if((l->type & 255) != 1) {
            if((l->type & 255) != 2) {
                Strcat_charp(str, 135063018);
            } else {
                Strcat_charp(str, " [Rev] ");
            }
        } else {
            Strcat_charp(str, " [Rel] ");
        }
        if(l->url != 0) {
            if(DecodeURL == 0) {
                p = l->url;
            } else {
                p = url_unquote_conv(l->url, buf->document_charset);
            }
        } else {
            p = 135062802;
        }
        Strcat_charp(str, p);
        label[i] = str->ptr;
        if(str->length > len) {
            len = str->length;
        }
        i = i + 1;
        l = l->next;
    }
    label[nitem] = 0;
    set_menu_frame();
    new_option_menu( &menu, label,  &linkV, 0);
    _v1084 = 0;
    _v1116 = (buf->cursorX & 65535) + (buf->rootX & 65535);
    _v1112 = (buf->cursorY & 65535) + (buf->rootY & 65535);
    _v1108 = _v1116 + FRAME_WIDTH + 1;
    _v1104 = _v1112 + 2;
    popup_menu(0,  &menu);
    if(linkV >= 0) {
        i = 0;
        l = buf->linklist;
        while(l != 0) {
            if(i != linkV) {
                i = i + 1;
                l = l->next;
                continue;
            }
            return l;
        }
        return 0;
    }
    return 0;
}

Anchor* accesskey_menu(Buffer* buf)
{// addr = 0x08097A58  --  defined in 'menu.c' at line 1882
    unsigned char c;                       // _cfa_fffffff3
    AnchorList* al;   // _cfa_ffffffec
    Anchor* a;          // _cfa_ffffffe8
    Anchor** ap;        // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    int n;                                 // _cfa_ffffffdc
    int nitem;                             // _cfa_ffffffd8
    int key;                               // _cfa_ffffffd4
    char** label;                          // _cfa_ffffffd0
    char* t;                               // _cfa_ffffffcc
    int _v1092;                            // _cfa_fffffbbc
    intOrPtr _v1112;                       // _cfa_fffffba8
    intOrPtr _v1116;                       // _cfa_fffffba4
    intOrPtr _v1120;                       // _cfa_fffffba0
    intOrPtr _v1124;                       // _cfa_fffffb9c
    Menu menu;            // _cfa_fffffb98
    _unknown_ _v1136;                      // _cfa_fffffb90 (outparam)
    char* _v1140;                          // _cfa_fffffb8c (outparam)
    signed int _v1144;                     // _cfa_fffffb88 (outparam)
    _unknown_ __ebx;                       // r1
    char** _t212;                          // _t212
    Anchor** _t214;     // _t214
    char* _t238;                           // _t238
    unsigned char _t296;                   // _t296
    unsigned char _t305;                   // _t305
    char** _t344;                          // _t344

    al = buf->href;
    nitem = 0;
    key = -1;
    if(al == 0) {
        return 0;
    }
    i = 0;
    while(al->nanchor > i) {
        i = i + 1;
    }
    if(nitem != 0) {
        _t212 = nitem + 1 << 2;
         *__esp = _t212;
        GC_malloc();
        label = _t212;
        _t214 = nitem << 2;
         *__esp = _t214;
        GC_malloc();
        ap = _t214;
        i = 0;
        n = 0;
        while(al->nanchor > i) {
            a = al->anchors + (i << 2 << 4) - (i << 2);
            if((a->slave & 255) == 0 && (a->accesskey & 255) != 0 && ( *( &MYCTYPE_MAP + (a->accesskey & 0xff)) & 0x11) != 0) {
                t = getAnchorText(buf, al, a);
                _t344 =  &(label[n]);
                if(t == 0) {
                    _t238 = 135062802;
                } else {
                    _t238 = t;
                }
                _v1140 = _t238;
                _v1144 = a->accesskey & 0xff;
                 *_t344 =  *(Sprintf("%c: %s"));
                ap[n] = a;
                n = n + 1;
            }
            i = i + 1;
        }
        label[nitem] = 0;
        new_option_menu( &menu, label,  &key, 0);
        _v1092 = 0;
        _v1124 = (buf->cursorX & 65535) + (buf->rootX & 65535);
        _v1120 = (buf->cursorY & 65535) + (buf->rootY & 65535);
        _v1116 = _v1124 + FRAME_WIDTH + 1;
        _v1112 = _v1120 + 2;
        i = 0;
        while(i <= 127) {
             *(__ebp + (i + 140) * 4 - 1120) = -1;
            i = i + 1;
        }
        i = 0;
        while(i < nitem) {
            c = ap[i]->accesskey & 255;
             *((intOrPtr*)(__ebp + ((c & 255) + 12) * 4 - 1120)) = mSelect;
             *(__ebp + ((c & 255) + 140) * 4 - 1120) = i;
            i = i + 1;
        }
        i = 0;
        while(i < nitem) {
            c = ap[i]->accesskey & 255;
            if(( *( &MYCTYPE_MAP + (c & 255)) & 4) != 0) {
                if( *((intOrPtr*)(__ebp + (n + 140) * 4 - 1120)) < 0) {
                    if(( *( &MYCTYPE_MAP + (c & 255)) & 4) == 0) {
                        _t296 = c & 255;
                    } else {
                        _t296 = c & 255 | 32;
                    }
                    c = _t296;
                     *((intOrPtr*)(__ebp + ((c & 255) + 12) * 4 - 1120)) = mSelect;
                     *(__ebp + ((c & 255) + 140) * 4 - 1120) = i;
                    if(( *( &MYCTYPE_MAP + (c & 255)) & 4) == 0) {
                        _t305 = c & 255;
                    } else {
                        _t305 = c & 0xdf;
                    }
                    c = _t305;
                     *((intOrPtr*)(__ebp + ((c & 255) + 12) * 4 - 1120)) = mSelect;
                     *(__ebp + ((c & 255) + 140) * 4 - 1120) = i;
                }
            }
            i = i + 1;
        }
        a = retrieveCurrentAnchor(buf);
        if(a == 0 || (a->accesskey & 255) == 0 || ( *( &MYCTYPE_MAP + (a->accesskey & 0xff)) & 0x11) == 0) {
L49:
            popup_menu(0,  &menu);
            if(key < 0) {
                return 0;
            }
            return ap[key];
        } else {
            i = 0;
            while(i < nitem) {
                if(a->hseq != ap[i]->hseq) {
                    i = i + 1;
                    continue;
                }
                _v1092 = i;
                goto L49;
            }
            goto L49;
        }
    }
    return 0;
}

int lmGoto(char c)
{// addr = 0x08097EBD  --  defined in 'menu.c' at line 1963
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v16 = c;
    if(( *( &MYCTYPE_MAP + (_v16 & 0xff)) & 0x11) != 0 &&  *(CurrentMenu->cursorX + (_v16 + 140) * 4) >= 0) {
        goto_menu(CurrentMenu, CurrentMenu->nitem - 1, -1);
        goto_menu(CurrentMenu, (( *(CurrentMenu->cursorX + (_v16 + 140) * 4) << 2) +  *(CurrentMenu->cursorX + (_v16 + 140) * 4) << 2) +  *(CurrentMenu->cursorX + (_v16 + 140) * 4), 1);
    }
    return -1;
}

int lmSelect(char c)
{// addr = 0x08097F5F  --  defined in 'menu.c' at line 1973
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v16 = c;
    if(( *( &MYCTYPE_MAP + (_v16 & 0xff)) & 0x11) == 0) {
        return -1;
    }
    return select_menu(CurrentMenu, (((CurrentMenu->select * -2045222521 >> 32) + (CurrentMenu->select - -2045222521 >> 1) >> 4 << 2) + ((CurrentMenu->select * -2045222521 >> 32) + (CurrentMenu->select - -2045222521 >> 1) >> 4) << 2) + _t47 +  *((intOrPtr*)(CurrentMenu->cursorX + (_v16 + 140) * 4)));
}

Anchor* list_menu(Buffer* buf)
{// addr = 0x08097FE3  --  defined in 'menu.c' at line 1983
    unsigned char c;                       // _cfa_fffffff3
    AnchorList* al;   // _cfa_ffffffec
    Anchor* a;          // _cfa_ffffffe8
    Anchor** ap;        // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    int n;                                 // _cfa_ffffffdc
    int nitem;                             // _cfa_ffffffd8
    int key;                               // _cfa_ffffffd4
    int two;                               // _cfa_ffffffd0
    char** label;                          // _cfa_ffffffcc
    char* t;                               // _cfa_ffffffc8
    int _v1096;                            // _cfa_fffffbb8
    intOrPtr _v1116;                       // _cfa_fffffba4
    intOrPtr _v1120;                       // _cfa_fffffba0
    intOrPtr _v1124;                       // _cfa_fffffb9c
    intOrPtr _v1128;                       // _cfa_fffffb98
    Menu menu;            // _cfa_fffffb94
    char* _v1136;                          // _cfa_fffffb90 (outparam)
    signed int _v1140;                     // _cfa_fffffb8c (outparam)
    char* _v1144;                          // _cfa_fffffb88 (outparam)
    _unknown_ __ebx;                       // r1
    char** _t210;                          // _t210
    Anchor** _t212;     // _t212

    al = buf->href;
    nitem = 0;
    key = -1;
    two = 0;
    if(al == 0) {
        return 0;
    }
    i = 0;
    while(al->nanchor > i) {
        a = al->anchors + (i << 2 << 4) - (i << 2);
        if((a->slave & 255) == 0) {
            nitem = nitem + 1;
        }
        i = i + 1;
    }
    if(nitem != 0) {
        if(nitem > 20) {
            two = 1;
        }
        _t210 = nitem + 1 << 2;
         *__esp = _t210;
        GC_malloc();
        label = _t210;
        _t212 = nitem << 2;
         *__esp = _t212;
        GC_malloc();
        ap = _t212;
        i = 0;
        n = 0;
        while(al->nanchor > i) {
            a = al->anchors + (i << 2 << 4) - (i << 2);
            if((a->slave & 255) != 0) {
L22:
                i = i + 1;
                continue;
            }
            t = getAnchorText(buf, al, a);
            if(t == 0) {
                t = 135062802;
            }
            if(two == 0 || n <= 692) {
                if(two == 0) {
                    _v1140 = t;
                    _v1144 = ((char*)("abcdefgimopqrstuvwxyz"))[n] & 255;
                    label[n] =  *(Sprintf("%c: %s"));
                } else {
                    _t346 = n;
                    _v1136 = t;
                    _v1140 = ((char*)("abcdefgimopqrstuvwxyz"))[n - (((_t346 * -2045222521 >> 32) + (_t346 - -2045222521 >> 1) >> 4 << 2) + ((_t346 * -2045222521 >> 32) + (_t346 - -2045222521 >> 1) >> 4) << 2) + ((_t346 * -2045222521 >> 32) + (_t346 - -2045222521 >> 1) >> 4)] & 255;
                    _v1144 = ((char*)("1234567890ABCDEFGHILMOPQRSTUVWXYZ"))[(n * -2045222521 >> 32) + (n - -2045222521 >> 1) >> 4] & 255;
                    label[n] =  *(Sprintf("%c%c: %s"));
                }
            } else {
                _v1144 = t;
                label[n] =  *(Sprintf("  : %s"));
            }
            ap[n] = a;
            n = n + 1;
            goto L22;
        }
        label[nitem] = 0;
        set_menu_frame();
        set_menu_frame();
        new_option_menu( &menu, label,  &key, 0);
        _v1096 = 0;
        _v1128 = (buf->cursorX & 65535) + (buf->rootX & 65535);
        _v1124 = (buf->cursorY & 65535) + (buf->rootY & 65535);
        _v1120 = _v1128 + FRAME_WIDTH + 1;
        _v1116 = _v1124 + 2;
        i = 0;
        while(i <= 127) {
             *(__ebp + (i + 140) * 4 - 1124) = -1;
            i = i + 1;
        }
        if(two == 0) {
            i = 0;
            while(i < nitem) {
                c = ("abcdefgimopqrstuvwxyz")[i] & 255;
                 *((intOrPtr*)(__ebp + ((c & 255) + 12) * 4 - 1124)) = mSelect;
                 *(__ebp + ((c & 255) + 140) * 4 - 1124) = i;
                i = i + 1;
            }
L38:
            a = retrieveCurrentAnchor(buf);
            if(a == 0) {
L44:
                popup_menu(0,  &menu);
                if(key < 0) {
                    return 0;
                }
                return ap[key];
            }
            i = 0;
            while(i < nitem) {
                if(a->hseq != ap[i]->hseq) {
                    i = i + 1;
                    continue;
                }
                _v1096 = i;
                goto L44;
            }
            goto L44;
        }
        i = 0;
        while(i <= 32) {
            c = ("1234567890ABCDEFGHILMOPQRSTUVWXYZ")[i] & 255;
             *((intOrPtr*)(__ebp + ((c & 255) + 12) * 4 - 1124)) = lmGoto;
             *(__ebp + ((c & 255) + 140) * 4 - 1124) = i;
            i = i + 1;
        }
        i = 0;
        while(i <= 20) {
            c = ((char*)("abcdefgimopqrstuvwxyz"))[i] & 255;
             *((intOrPtr*)(__ebp + ((c & 255) + 12) * 4 - 1124)) = lmSelect;
             *(__ebp + ((c & 255) + 140) * 4 - 1124) = i;
            i = i + 1;
        }
        goto L38;
    }
    return 0;
}

int mailcapMatch(struct mailcap* mcap, char* type)
{// addr = 0x08098458  --  defined in 'mailcap.c' at line 19
    char* cap;                             // _cfa_fffffff8
    char* p;                               // _cfa_fffffff4
    int level;                             // _cfa_fffffff0
    signed int _t65;                       // _t65

    cap = mcap->type;
    p = cap;
    while(( *p & 255) != 47) {
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 4) == 0) {
            __edx =  *p & 255;
        } else {
            __edx =  *p & 255 | 32;
        }
        if(( *( &MYCTYPE_MAP + ( *type & 0xff)) & 4) == 0) {
            _t65 =  *type & 255;
        } else {
            _t65 =  *type & 255 | 32;
        }
        if(__edx == _t65) {
            type =  &(type[1]);
            p =  &(p[1]);
            continue;
        } else {
            return 0;
        }
    }
    if(( *type & 255) == 47) {
        p =  &(p[1]);
        type =  &(type[1]);
        if((mcap->flags & 4) == 0) {
            level = 0;
        } else {
            level = 1;
        }
        if(( *p & 255) != 42) {
            while(1) {
                p =  *p & 255;
                if(__al == 0) {
                    break;
                }
                p =  *p & 255;
                __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                __eax = __al & 255;
                if(__eax == 0) {
                    p =  *p & 255;
                    __edx = __al;
                } else {
                    p =  *p & 255;
                     *p & 255 = __al;
                }
                type =  *type & 255;
                __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                __eax = __al & 255;
                if(__eax == 0) {
                    type =  *type & 255;
                    __eax = __al;
                } else {
                    type =  *type & 255;
                    __eax =  *type & 255 | 32;
                    __eax = __al;
                }
                if(__edx == __eax) {
                    p =  &(p[1]);
                    type =  &(type[1]);
                    continue;
                } else {
                    __eax = 0;
                    return 0;
                }
            }
            type =  *type & 255;
            if(( *type & 255) == 0) {
                level = level + 20;
                return level + 20;
            }
            __eax = 0;
            return 0;
        } else {
            return level + 10;
        }
    }
    return 0;
}

struct mailcap* searchMailcap(struct mailcap* table, char* type)
{// addr = 0x080985E5  --  defined in 'mailcap.c' at line 50
    int level;                             // _cfa_fffffff0
    struct mailcap* mcap;   // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    Str command;           // _cfa_ffffffe4
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    char* _v56;                            // _cfa_ffffffc8 (outparam)

    level = 0;
    mcap = 0;
    if(table != 0) {
        while(1) {
            table = table->type;
            if(table->type == 0) {
                break;
            }
            __eax = type;
            _v56 = type;
            __eax = table;
             *__esp = table;
            i = mailcapMatch();
            __eax = i;
            if(i <= level) {
L7:
                table = table + 24;
                continue;
            }
            __eax = table;
            __eax = table->test;
            if(table->test == 0) {
L5:
                __eax = i;
                level = i;
                __eax = table;
                mcap = table;
                goto L7;
            }
            __eax = table;
            __eax = table->test;
            command = unquote_mailcap(table->test, type, 0, 0, 0);
            __eax = command;
            __eax = command->ptr;
             *__esp = __eax;
            system();
            if(__eax != 0) {
                goto L7;
            }
            goto L5;
        }
        __eax = mcap;
        return mcap;
    }
    __eax = 0;
    return 0;
}

int matchMailcapAttr(char* p, char* attr, int len, Str* value)
{// addr = 0x0809869D  --  defined in 'mailcap.c' at line 75
    int quoted;                            // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    int _v36;                              // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    char* _t65;                            // _t65
    struct _Str* _t99;    // _t99
    int _t139;                             // _t139

    q = 0;
    _v36 = len;
    _v40 = attr;
    _t65 = p;
     *__esp = _t65;
    strncasecmp();
    if(_t65 != 0) {
L31:
        return 0;
    } else {
        p =  &(p[len]);
        while(( *p & 255) != 0) {
            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                p =  &(p[1]);
                continue;
            }
            break;
        }
        if(value == 0) {
            if(( *p & 255) == 0 || ( *p & 255) == 59) {
                return 1;
            } else {
                goto L31;
            }
        }
         *value = Strnew();
        if(( *p & 255) != 61) {
L27:
            return 1;
        } else {
            p =  &(p[1]);
            goto L9;
            do {
            } while();
L22:
            while(( *p & 255) != 0 && (quoted != 0 || ( *p & 255) != 59)) {
                if(quoted != 0 || ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
                    q = p;
                }
                if(quoted == 0) {
                    if(( *p & 255) == 92) {
                        quoted = 1;
                    }
                } else {
                    quoted = 0;
                }
                if( *value->length + 1 >=  *value->area_size) {
                    Strgrow( *value);
                }
                _t99 =  *value;
                _t139 = _t99->length;
                 *((char*)( *( *value) + _t139)) =  *p & 255;
                _t99->length = _t139 + 1;
                 *((char*)( *( *value) +  *value->length)) = 0;
                p =  &(p[1]);
            }
            if(q != 0) {
                Strshrink( *value, p - q - 1);
            }
            goto L27;
L9:
            if(( *p & 255) == 0 || ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
                quoted = 0;
            } else {
                p =  &(p[1]);
                goto L9;
            }
            goto L22;
        }
    }
}

int extractMailcapEntry(char* mcap_entry, struct mailcap* mcap)
{// addr = 0x08098871  --  defined in 'mailcap.c' at line 114
    int j;                                 // _cfa_fffffff0
    int k;                                 // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    int quoted;                            // _cfa_ffffffe4
    Str tmp;               // _cfa_ffffffe0
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    intOrPtr _v56;                         // _cfa_ffffffc8 (outparam)
    int _t156;                             // _t156
    int _t169;                             // _t169

    _v56 = 24;
     *__esp = mcap;
    bzero();
    p = mcap_entry;
    while(( *p & 255) != 0) {
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
            p =  &(p[1]);
            continue;
        }
        break;
    }
    k = -1;
    j = 0;
    while((p[j] & 255) != 0) {
        if((p[j] & 255) != 59) {
            if(( *( &MYCTYPE_MAP + (p[j] & 0xff)) & 2) == 0) {
                k = j;
            }
            j = j + 1;
            continue;
        }
        break;
    }
    if(k < 0) {
        _t156 = j;
    } else {
        _t156 = k + 1;
    }
    mcap->type = allocStr(p, _t156);
    if((p[j] & 255) == 0) {
        return 0;
    }
    p =  &(p[j + 1]);
    goto L17;
    do {
    } while();
    do {
        goto L28;
    } while((p[j] & 255) != 0 && (quoted != 0 || (p[j] & 255) != 59));
    if(k < 0) {
        _t169 = j;
    } else {
        _t169 = k + 1;
    }
    mcap->viewer = allocStr(p, _t169);
    p =  &(p[j]);
    while(( *p & 255) == 59) {
        p =  &(p[1]);
        while(( *p & 255) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
            p =  &(p[1]);
        }
        if(matchMailcapAttr(p, "needsterminal", 13, 0) == 0) {
            if(matchMailcapAttr(p, "copiousoutput", 13, 0) == 0) {
                if(matchMailcapAttr(p, "x-htmloutput", 12, 0) != 0 || matchMailcapAttr(p, "htmloutput", 10, 0) != 0) {
                    mcap->flags = mcap->flags | 4;
                } else {
                    if(matchMailcapAttr(p, "test", 4,  &tmp) == 0) {
                        if(matchMailcapAttr(p, "nametemplate", 12,  &tmp) == 0) {
                            if(matchMailcapAttr(p, "edit", 4,  &tmp) != 0) {
                                mcap->edit = allocStr(tmp->ptr, tmp->length);
                            }
                        } else {
                            mcap->nametemplate = allocStr(tmp->ptr, tmp->length);
                        }
                    } else {
                        mcap->test = allocStr(tmp->ptr, tmp->length);
                    }
                }
            } else {
                mcap->flags = mcap->flags | 2;
            }
        } else {
            mcap->flags = mcap->flags | 1;
        }
        quoted = 0;
        while(( *p & 255) != 0 && (quoted != 0 || ( *p & 255) != 59)) {
            if(quoted == 0) {
                if(( *p & 255) == 92) {
                    quoted = 1;
                }
            } else {
                quoted = 0;
            }
            p =  &(p[1]);
        }
    }
    return 1;
L17:
    if(( *p & 255) == 0 || ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
        k = -1;
        quoted = 0;
        j = 0;
    } else {
        p =  &(p[1]);
        goto L17;
    }
L28:
}

struct mailcap* loadMailcap(char* filename)
{// addr = 0x08098C6A  --  defined in 'mailcap.c' at line 183
    FILE* f;              // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int n;                                 // _cfa_ffffffe8
    Str tmp;               // _cfa_ffffffe4
    struct mailcap* mcap;   // _cfa_ffffffe0
    struct _Str* _v52;    // _cfa_ffffffcc
    struct _Str* _v56;    // _cfa_ffffffc8 (outparam)
    FILE* _t59;           // _t59
    struct mailcap* _t73;   // _t73

    _t59 = expandPath(filename);
    _v56 = 135063403;
     *__esp = _t59;
    fopen();
    f = _t59;
    if(f == 0) {
        return 0;
    }
    i = 0;
    while(1) {
        tmp = Strfgets(f);
        if(tmp->length <= 0) {
            break;
        }
        if(( *(tmp->ptr) & 255) != 35) {
            i = 1 + i;
        }
    }
    _v52 = 0;
    _v56 = 0;
     *__esp = f;
    fseek();
    n = i;
    _t73 = 1 + n + 1 + n + _t89 << 3;
     *__esp = _t73;
    GC_malloc();
    mcap = _t73;
    i = 0;
    while(1) {
L20:
        tmp = Strfgets(f);
        if(tmp->length <= 0) {
            break;
        }
        if(( *(tmp->ptr) & 255) != 35) {
            while(1) {
L11:
                tmp = tmp->length;
                if(tmp->length <= 0) {
                    __eax = 0;
                } else {
                    __eax = tmp;
                    __edx = tmp->ptr;
                    tmp = tmp->length;
                    tmp->length - 1 = tmp->ptr + tmp->length - 1;
                    __eax =  *(tmp->ptr + tmp->length - 1) & 255;
                    __eax = __al & 255;
                }
                __eax =  *(__eax +  &MYCTYPE_MAP) & 255;
                __eax = __al & 255;
                if(__eax != 0) {
                    break;
                }
                tmp = tmp->length;
                if(tmp->length <= 0) {
L18:
                    __edx = i;
                    __edx =  &(__edx[__edx]);
                    __eax =  &(( &(__edx[__edx]))[__edx]);
                    __eax =  &(( &(__edx[__edx]))[__edx]) << 3;
                    __edx = __eax;
                    __edx = __eax + mcap;
                    tmp = tmp->ptr;
                    if(extractMailcapEntry(tmp->ptr, __edx) != 0) {
                        i = 1 + i;
                    }
                    goto L20;
                }
                __eax = tmp;
                __edx = tmp->ptr;
                tmp = tmp->length;
                tmp->length - 1 = tmp->ptr + tmp->length - 1;
                if(__al != 92) {
                    goto L18;
                }
                _v56 = 1;
                __eax = tmp;
                 *__esp = tmp;
                Strshrink();
                __eax = f;
                _v56 = Strfgets(f);
                __eax = tmp;
                 *__esp = tmp;
                Strcat();
            }
            _v56 = 1;
            __eax = tmp;
             *__esp = tmp;
            Strshrink();
            goto L11;
        }
    }
    _t90 = i;
    _v56 = 24;
     *__esp = mcap + (i + _t90 + _t90 << 3);
    bzero();
     *__esp = f;
    fclose();
    return mcap;
}

void initMailcap()
{// addr = 0x08098E46  --  defined in 'mailcap.c' at line 223
    TextListItem* tl;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    struct mailcap** _t19;   // _t19

    if(non_null(mailcap_files) == 0) {
        mailcap_list = 0;
    } else {
        mailcap_list = make_domain_list(mailcap_files);
    }
    if(mailcap_list != 0) {
        _t19 = (mailcap_list->nitem & 65535) << 2;
         *__esp = _t19;
        GC_malloc();
        UserMailcap = _t19;
        i = 0;
        tl = mailcap_list->first;
        while(tl != 0) {
            UserMailcap[i] = loadMailcap(tl->ptr);
            i = i + 1;
            tl = tl->next;
        }
        return;
    }
}

char* acceptableMimeTypes()
{// addr = 0x08098EEB  --  defined in 'mailcap.c' at line 241
    TextList* l;      // _cfa_fffffff0
    Hash_si* mhash;    // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    struct mailcap* mp;   // _cfa_ffffffe0
    char* mt;                              // _cfa_ffffffdc
    int _v52;                              // _cfa_ffffffcc (outparam)
    char* _v56;                            // _cfa_ffffffc8 (outparam)

    if(types == 0) {
        l = newGeneralList();
        mhash = newHash_si(16);
        putHash_si(mhash, 135063405, 1);
        pushValue(l, allocStr(135063410, -1));
        putHash_si(mhash, 135063410, 1);
        i = 0;
        while((mailcap_list->nitem & 65535) > i) {
            mp = UserMailcap[i];
            if(mp != 0) {
                while(1) {
                    mp = mp->type;
                    if(mp->type == 0) {
                        break;
                    }
                    __eax = mp;
                    __eax = mp->type;
                    _v56 = 47;
                     *__esp = __eax;
                    strchr();
                    p = __eax;
                    if(p != 0) {
                        mp = mp->type;
                        mp = mp->type;
                        mt = allocStr(mp->type, p - mp->type);
                        _v52 = 0;
                        __eax = mt;
                        _v56 = mt;
                        __eax = mhash;
                         *__esp = mhash;
                        if(getHash_si() == 0) {
                            _v56 = -1;
                            __eax = mt;
                             *__esp = mt;
                            pushValue(l, allocStr());
                            _v52 = 1;
                            __eax = mt;
                            _v56 = mt;
                            __eax = mhash;
                             *__esp = mhash;
                            putHash_si();
                        }
                    }
                    mp = mp + 24;
                }
L12:
                i = i + 1;
                continue;
            }
            goto L12;
        }
        types = Strnew();
        Strcat_charp(types, "text/html, text/*;q=0.5");
        while(1) {
            p = popValue(l);
            if(p == 0) {
                break;
            }
            Strcat_charp(types, ", ");
            Strcat_charp(types, p);
            Strcat_charp(types, "/*");
        }
        return types->ptr;
    }
    return types->ptr;
}

struct mailcap* searchExtViewer(char* type)
{// addr = 0x080990E3  --  defined in 'mailcap.c' at line 286
    struct mailcap* p;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(mailcap_list == 0) {
L8:
        return searchMailcap( &DefaultMailcap, type);
    }
    i = 0;
    while((mailcap_list->nitem & 65535) > i) {
        p = searchMailcap(UserMailcap[i], type);
        if(p == 0) {
            i = i + 1;
            continue;
        }
        return p;
    }
    goto L8;
}

Str quote_mailcap(char* s, int flag)
{// addr = 0x08099152  --  defined in 'mailcap.c' at line 312
    Str d;                 // _cfa_fffffff0
    int _t54;                              // _t54
    int _t73;                              // _t73

    d = Strnew();
L1:
    while(1) {
        if(( *s & 255) <= 96) {
            goto __eax;
        }
        if(flag == 0 && ( *( &MYCTYPE_MAP + ( *s & 0xff)) & 0xc) == 0) {
            if(d->length + 1 >= d->area_size) {
                Strgrow(d);
            }
            _t73 = d->length;
             *((char*)(d->ptr + _t73)) = 92;
            d->length = _t73 + 1;
             *((char*)(d->ptr + d->length)) = 0;
        }
        if(d->length + 1 >= d->area_size) {
            Strgrow(d);
        }
        _t54 = d->length;
         *((char*)(d->ptr + _t54)) =  *s & 255;
        d->length = _t54 + 1;
         *((char*)(d->ptr + d->length)) = 0;
        s =  &(s[1]);
    }
}

Str unquote_mailcap_loop(char* qstr, char* type, char* name, char* attr, int* mc_stat, int flag0)
{// addr = 0x0809930F  --  defined in 'mailcap.c' at line 352
    Str str;               // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    Str test;              // _cfa_ffffffe8
    Str then;              // _cfa_ffffffe4
    char* p;                               // _cfa_ffffffe0
    int status;                            // _cfa_ffffffdc
    int prev_status;                       // _cfa_ffffffd8
    int sp;                                // _cfa_ffffffd4
    int flag;                              // _cfa_ffffffd0
    char* q;                               // _cfa_ffffffcc
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    char* _v72;                            // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t218;                             // _t218
    int _t235;                             // _t235
    signed int _t246;                      // _t246
    Str _t268;             // _t268
    signed int _t275;                      // _t275
    Str _t286;             // _t286
    char* _t294;                           // _t294
    int _t331;                             // _t331
    int _t349;                             // _t349
    Str _t362;             // _t362
    int _t404;                             // _t404
    int _t408;                             // _t408
    int _t425;                             // _t425

    status = 0;
    prev_status = 0;
    sp = 0;
    if(mc_stat != 0) {
         *mc_stat = 0;
    }
    if(qstr == 0) {
        return 0;
    }
    str = Strnew();
    then = 0;
    test = then;
    tmp = test;
    flag = flag0;
    p = qstr;
    while(( *p & 255) != 0) {
        if(status != 3) {
            if(( *p & 255) != 92) {
                _t218 = status;
                if(_t218 == 1) {
                    if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 4) == 0) {
                        if(( *p & 255) != 123) {
                            if(( *p & 255) == 37) {
                                if(str->length + 1 >= str->area_size) {
                                    Strgrow(str);
                                }
                                _t235 = str->length;
                                 *((char*)(str->ptr + _t235)) =  *p & 255;
                                str->length = _t235 + 1;
                                 *((char*)(str->ptr + str->length)) = 0;
                            }
                        } else {
                            status = 2;
                            then = 0;
                            test = then;
                            tmp = Strnew();
                        }
                    } else {
                        _t246 =  *p & 255;
                        if(_t246 == 115) {
                            if(name != 0) {
                                Strcat_charp(str,  *(quote_mailcap(name, flag)));
                                if(mc_stat != 0) {
                                     *mc_stat =  *mc_stat | 1;
                                }
                            }
                        } else {
                            if(_t246 == 116) {
                                if(type != 0) {
                                    Strcat_charp(str,  *(quote_mailcap(type, flag)));
                                    if(mc_stat != 0) {
                                         *mc_stat =  *mc_stat | 2;
                                    }
                                }
                            }
                        }
                        status = 0;
                    }
                    goto L79;
                }
                if(_t218 == 2) {
                    if(sp > 0 || ( *p & 255) == 123) {
                        if(tmp->length + 1 >= tmp->area_size) {
                            Strgrow(tmp);
                        }
                        _t268 = tmp;
                        _t404 = _t268->length;
                         *((char*)(tmp->ptr + _t404)) =  *p & 255;
                        _t268->length = _t404 + 1;
                         *((char*)(tmp->ptr + tmp->length)) = 0;
                        _t275 =  *p & 255;
                        if(_t275 == 123) {
                            sp = sp + 1;
                        } else {
                            if(_t275 == 125) {
                                sp = sp - 1;
                            }
                        }
                    } else {
                        if(( *p & 255) != 125) {
                            if(tmp->length + 1 >= tmp->area_size) {
                                Strgrow(tmp);
                            }
                            _t286 = tmp;
                            _t408 = _t286->length;
                             *((char*)(tmp->ptr + _t408)) =  *p & 255;
                            _t286->length = _t408 + 1;
                             *((char*)(tmp->ptr + tmp->length)) = 0;
                        } else {
                            if(attr != 0) {
                                _v72 = tmp->ptr;
                                _t294 = attr;
                                 *__esp = _t294;
                                strcasestr();
                                q = _t294;
                                if(q != 0 && (q == attr || ( *( &MYCTYPE_MAP + ( *(q - 1) & 0xff)) & 2) != 0 || ( *(q - 1) & 255) == 59) && matchattr(q, tmp->ptr, tmp->length,  &tmp) != 0) {
                                    Strcat_charp(str,  *(quote_mailcap(tmp->ptr, flag)));
                                    if(mc_stat != 0) {
                                         *mc_stat =  *mc_stat | 4;
                                    }
                                }
                            }
                            status = 0;
                        }
                    }
                    goto L79;
                }
                if(_t218 != 0) {
                    goto L79;
                }
                if(( *p & 255) != 37) {
                    if(( *p & 255) != 39) {
                        if(( *p & 255) == 34) {
                            if(flag0 != 0 || (flag & 2) == 0) {
                                if(flag == 0) {
                                    flag = flag | 2;
                                }
                            } else {
                                flag = flag & -3;
                            }
                        }
                    } else {
                        if(flag0 != 0 || (flag & 1) == 0) {
                            if(flag == 0) {
                                flag = flag | 1;
                            }
                        } else {
                            flag = flag & -2;
                        }
                    }
                    if(str->length + 1 >= str->area_size) {
                        Strgrow(str);
                    }
                    _t331 = str->length;
                     *((char*)(str->ptr + _t331)) =  *p & 255;
                    str->length = _t331 + 1;
                     *((char*)(str->ptr + str->length)) = 0;
                } else {
                    status = 1;
                }
            } else {
                prev_status = status;
                status = 3;
            }
            goto L79;
        } else {
            if(prev_status != 2) {
                if(str->length + 1 >= str->area_size) {
                    Strgrow(str);
                }
                _t349 = str->length;
                 *((char*)(str->ptr + _t349)) =  *p & 255;
                str->length = _t349 + 1;
                 *((char*)(str->ptr + str->length)) = 0;
            } else {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t362 = tmp;
                _t425 = _t362->length;
                 *((char*)(tmp->ptr + _t425)) =  *p & 255;
                _t362->length = _t425 + 1;
                 *((char*)(tmp->ptr + tmp->length)) = 0;
            }
            status = prev_status;
L79:
            p =  &(p[1]);
            continue;
        }
    }
    return str;
}

Str unquote_mailcap(char* qstr, char* type, char* name, char* attr, int* mc_stat)
{// addr = 0x08099846  --  defined in 'mailcap.c' at line 468
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    return unquote_mailcap_loop(qstr, type, name, attr, mc_stat, 0);
}

void initImage()
{// addr = 0x08099880  --  defined in 'image.c' at line 39
    if(activeImage == 0) {
        if(getCharSize() != 0) {
            activeImage = 1;
            return;
        }
    }
}

int getCharSize()
{// addr = 0x080998A7  --  defined in 'image.c' at line 48
    FILE* f;              // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    int w;                                 // _cfa_ffffffe8
    int h;                                 // _cfa_ffffffe4
    int _v32;                              // _cfa_ffffffe0
    signed int _v34;                       // _cfa_ffffffde
    short _v36;                            // _cfa_ffffffdc
    int* _v48;                             // _cfa_ffffffd0
    int* _v52;                             // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    char* _t44;                            // _t44
    FILE* _t48;           // _t48
    char* _t50;                            // _t50

    w = 0;
    h = 0;
    set_environ("W3M_TTY", ttyname_tty());
    tmp = Strnew();
    _t44 = Imgdisplay;
    _v56 = 47;
     *__esp = _t44;
    strchr();
    if(_t44 == 0) {
        _t50 = w3m_auxbin_dir();
        _v48 = 0;
        _v52 = 135063848;
        _v56 = _t50;
        Strcat_m_charp(tmp);
    }
    _v48 = 0;
    _v52 = " -test 2>/dev/null";
    _v56 = Imgdisplay;
    Strcat_m_charp(tmp);
    _t48 = tmp->ptr;
    _v56 = 135063869;
     *__esp = _t48;
    popen();
    f = _t48;
    if(f != 0) {
        while(1) {
            __eax = 135063871;
            _v48 =  &h;
            _v52 =  &w;
            _v56 = 135063871;
            __eax = f;
             *__esp = __eax;
            fscanf();
            if(__eax >= 0) {
                break;
            }
            __eax = f;
             *__esp = __eax;
            feof();
            if(__eax != 0) {
L10:
                __eax = f;
                 *__esp = f;
                pclose();
                __eax = w;
                if(w <= 0) {
L12:
                    __eax = 0;
                    return 0;
                }
                __eax = h;
                if(h > 0) {
                    __eax = set_pixel_per_char;
                    if(set_pixel_per_char == 0) {
                        __eax = w;
                        _v32 = w;
                        asm("fild dword [ebp-0x1c]");
                        __eax = COLS;
                        _v32 = COLS;
                        asm("fild dword [ebp-0x1c]");
                        asm("fdivp st1, st0");
                        asm("faddp st1, st0");
                        asm("fnstcw word [ebp-0x1e]");
                        __eax = _v34 & 65535;
                        _v36 = _v34 & 65535;
                        asm("fldcw word [ebp-0x20]");
                        asm("fistp dword [ebp-0x1c]");
                        asm("fldcw word [ebp-0x1e]");
                        __eax = _v32;
                        _v32 = _v32;
                        asm("fild dword [ebp-0x1c]");
                        pixel_per_char =  *135063984;
                    }
                    __eax = set_pixel_per_line;
                    if(set_pixel_per_line == 0) {
                        __eax = h;
                        _v32 = h;
                        asm("fild dword [ebp-0x1c]");
                        __eax = LINES;
                        _v32 = LINES;
                        asm("fild dword [ebp-0x1c]");
                        asm("fdivp st1, st0");
                        asm("faddp st1, st0");
                        asm("fnstcw word [ebp-0x1e]");
                        __eax = _v34 & 65535;
                        _v36 = _v34 & 65535;
                        asm("fldcw word [ebp-0x20]");
                        asm("fistp dword [ebp-0x1c]");
                        asm("fldcw word [ebp-0x1e]");
                        __eax = _v32;
                        _v32 = _v32;
                        asm("fild dword [ebp-0x1c]");
                        pixel_per_line =  *135063984;
                    }
                    __eax = 1;
                    return 1;
                }
                goto L12;
            }
        }
        goto L10;
    } else {
        return 0;
    }
}

void termImage()
{// addr = 0x08099A5E  --  defined in 'image.c' at line 78
    FILE* _v16;           // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8

    if(activeImage != 0) {
        clearImage();
        if(Imgdisplay_wf != 0) {
            _v16 = Imgdisplay_wf;
            _v20 = 3;
            _v24 = 1;
             *__esp = 135063877;
            fwrite();
             *__esp = Imgdisplay_wf;
            fflush();
        }
        closeImgdisplay();
        return;
    }
}

int openImgdisplay()
{// addr = 0x08099AB9  --  defined in 'image.c' at line 91
    char* cmd;                             // _cfa_fffffff0
    int _v32;                              // _cfa_ffffffe0
    char* _v36;                            // _cfa_ffffffdc (outparam)
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    char* _t16;                            // _t16
    char* _t19;                            // _t19

    Imgdisplay_pid = open_pipe_rw( &Imgdisplay_rf,  &Imgdisplay_wf);
    if(Imgdisplay_pid < 0) {
        Imgdisplay_pid = 0;
        activeImage = 0;
        return 0;
    }
    if(Imgdisplay_pid == 0) {
        setup_child(0, 2, -1);
        _t16 = Imgdisplay;
        _v40 = 47;
         *__esp = _t16;
        strchr();
        if(_t16 != 0) {
            cmd = Imgdisplay;
        } else {
            _t19 = w3m_auxbin_dir();
            _v32 = 0;
            _v36 = Imgdisplay;
            _v40 = 135063848;
            cmd =  *(Strnew_m_charp(_t19));
        }
        myExec(cmd);
    }
    activeImage = 1;
    return 1;
}

void closeImgdisplay()
{// addr = 0x08099B96  --  defined in 'image.c' at line 116
    intOrPtr _v24;                         // _cfa_ffffffe8

    if(Imgdisplay_rf != 0) {
         *__esp = Imgdisplay_rf;
        fclose();
    }
    if(Imgdisplay_wf != 0) {
         *__esp = Imgdisplay_wf;
        fclose();
    }
    if(Imgdisplay_pid != 0) {
        _v24 = 9;
         *__esp = Imgdisplay_pid;
        kill();
    }
    Imgdisplay_rf = 0;
    Imgdisplay_wf = 0;
    Imgdisplay_pid = 0;
}

void addImage(ImageCache* cache, int x, int y, int sx, int sy, int w, int h)
{// addr = 0x08099C06  --  defined in 'image.c' at line 130
    TerminalImage* i;   // _cfa_fffffff0
    signed int _v40;                       // _cfa_ffffffd8
    int _t43;                              // _t43
    TerminalImage* _t45;   // _t45

    if(activeImage != 0) {
        if(n_terminal_image >= max_terminal_image) {
            if(max_terminal_image == 0) {
                _t43 = 8;
            } else {
                _t43 = max_terminal_image + max_terminal_image;
            }
            max_terminal_image = _t43;
            _t45 = terminal_image;
            _v40 = max_terminal_image << 4;
             *__esp = _t45;
            GC_realloc();
            terminal_image = _t45;
        }
        i = terminal_image + (n_terminal_image << 4);
        i->cache = cache;
        i->x = x;
        i->y = y;
        i->sx = sx;
        i->sy = sy;
        i->width = w;
        i->height = h;
        n_terminal_image = n_terminal_image + 1;
        return;
    }
}

void syncImage()
{// addr = 0x08099CD9  --  defined in 'image.c' at line 153
    FILE* _v16;           // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    FILE* _t9;            // _t9
    FILE* _t10;           // _t10
    FILE* _t11;           // _t11

    _v16 = Imgdisplay_wf;
    _v20 = 3;
    _v24 = 1;
     *__esp = 135063881;
    fwrite();
    _v16 = Imgdisplay_wf;
    _v20 = 3;
    _v24 = 1;
     *__esp = 135063885;
    fwrite();
    while(1) {
        _t9 = Imgdisplay_wf;
         *__esp = _t9;
        fflush();
        if(_t9 == 0) {
            break;
        }
        _t10 = Imgdisplay_wf;
         *__esp = _t10;
        ferror();
        if(_t10 != 0) {
L6:
            closeImgdisplay();
            image_index = image_index + 1000;
            n_terminal_image = 0;
            return;
        }
    }
    _t11 = Imgdisplay_rf;
     *__esp = _t11;
    fgetc();
    if(_t11 == 0) {
        goto L6;
    }
}

void drawImage()
{// addr = 0x08099D88  --  defined in 'image.c' at line 171
    int j;                                 // _cfa_ffffffe0
    int draw;                              // _cfa_ffffffdc
    TerminalImage* i;   // _cfa_ffffffd8
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v80;                       // _cfa_ffffffb0
    signed int _v100;                      // _cfa_ffffff9c
    signed int _v104;                      // _cfa_ffffff98
    signed int _v108;                      // _cfa_ffffff94
    signed int _v112;                      // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    signed int _v124;                      // _cfa_ffffff84
    signed int _v128;                      // _cfa_ffffff80
    intOrPtr _v132;                        // _cfa_ffffff7c
    FILE* _v136;          // _cfa_ffffff78
    signed int _t113;                      // _t113
    signed int _t118;                      // _t118
    signed int _t148;                      // _t148

    draw = 0;
    if(activeImage == 0) {
        return;
    }
    if(n_terminal_image == 0) {
        return;
    }
    j = 0;
    while(j < n_terminal_image) {
        i = terminal_image + (j << 4);
        if(( *(i->cache + 20) & 1) != 0) {
            if((i->width & 65535) <= 0) {
            } else {
                if((i->height & 65535) <= 0) {
                } else {
                    if(Imgdisplay_rf == 0 || Imgdisplay_wf == 0) {
                        if(openImgdisplay() == 0) {
                            return;
                        }
                    }
                    if( *(i->cache + 24) <= 0) {
                        _v128 = Imgdisplay_wf;
                        _v132 = 2;
                        _v136 = 1;
                         *__esp = 135063892;
                        fwrite();
                    } else {
                         *(i->cache + 24) =  ~( *(i->cache + 24));
                        _v128 = Imgdisplay_wf;
                        _v132 = 2;
                        _v136 = 1;
                         *__esp = 135063889;
                        fwrite();
                    }
                    _v64 = i->width & 65535;
                    _v60 = i->sy & 65535;
                    _v56 = i->sx & 65535;
                    _t113 =  *(i->cache + 30) & 65535;
                    _t114 = _t113 < 0 ? 0 : _t113;
                    _t115 = _t113 < 0 ? 0 : _t113;
                    _v52 = _t113 < 0 ? 0 : _t113;
                    _t118 =  *(i->cache + 28) & 65535;
                    _t119 = _t118 < 0 ? 0 : _t118;
                    _t120 = _t118 < 0 ? 0 : _t118;
                    _v48 = _t118 < 0 ? 0 : _t118;
                    _t148 =  !( *(i->cache + 24));
                    _v80 = _t148 * 274877907 >> 32 >> 6;
                    _v100 = i->height & 65535;
                    _v104 = _v64;
                    _v108 = _v60;
                    _v112 = _v56;
                    _v116 = _v52;
                    _v120 = _v48;
                    _v124 = i->y & 65535;
                    _v128 = i->x & 65535;
                    _v132 = _t148 - (_v80 - (_t148 >> 31)) * 1000 + 1;
                    _v136 = "%d;%d;%d;%d;%d;%d;%d;%d;%d;";
                     *__esp =  &buf.8642;
                    sprintf();
                    _v136 = Imgdisplay_wf;
                     *__esp =  &buf.8642;
                    fputs();
                    _v136 = Imgdisplay_wf;
                     *__esp = i->cache->file;
                    fputs();
                    _v136 = Imgdisplay_wf;
                     *__esp = 10;
                    fputc();
                    draw = 1;
                }
            }
        }
        j = j + 1;
    }
    if(draw != 0) {
        syncImage();
        touch_cursor();
        refresh();
        return;
    }
}

void clearImage()
{// addr = 0x0809A012  --  defined in 'image.c' at line 214
    int j;                                 // _cfa_fffffff0
    TerminalImage* i;   // _cfa_ffffffec
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    FILE* _v56;           // _cfa_ffffffc8

    if(activeImage == 0) {
        return;
    }
    if(n_terminal_image == 0) {
        return;
    }
    if(Imgdisplay_wf != 0) {
        j = 0;
        while(j < n_terminal_image) {
            i = terminal_image + (j << 4);
            if(( *(i->cache + 20) & 1) != 0) {
                if((i->width & 65535) > 0) {
                    if((i->height & 65535) > 0) {
                        _v40 = i->height & 65535;
                        _v44 = i->width & 65535;
                        _v48 = i->y & 65535;
                        _v52 = i->x & 65535;
                        _v56 = "6;%d;%d;%d;%d\n";
                         *__esp =  &buf.8728;
                        sprintf();
                        _v56 = Imgdisplay_wf;
                         *__esp =  &buf.8728;
                        fputs();
                    }
                }
            }
            j = j + 1;
        }
        syncImage();
        n_terminal_image = 0;
        return;
    }
    n_terminal_image = 0;
}

void deleteImage(Buffer* buf)
{// addr = 0x0809A12E  --  defined in 'image.c' at line 253
    AnchorList* al;   // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(buf == 0) {
        return;
    }
    al = buf->img;
    if(al == 0) {
        return;
    } else {
        i = 0;
        a = al->anchors;
        while(al->nanchor > i) {
            if(a->image != 0 && a->image->cache != 0 && (a->image->cache->loaded & 255) != 0 && (a->image->cache->loaded & 4) == 0 && a->image->cache->index < 0) {
                 *__esp = a->image->cache->file;
                unlink();
            }
            i = i + 1;
            a = a + 60;
        }
        loadImage(0, 1);
        return;
    }
}

void getAllImage(Buffer* buf)
{// addr = 0x0809A1F4  --  defined in 'image.c' at line 275
    AnchorList* al;   // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    ParsedURL* current;   // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    image_buffer = buf;
    if(buf == 0) {
        return;
    }
    buf->image_loaded = 1;
    al = buf->img;
    if(al == 0) {
        return;
    }
    current = baseURL(buf);
    i = 0;
    a = al->anchors;
    while(al->nanchor > i) {
        if(a->image != 0) {
            a->image->cache = getImage(a->image, current, buf->image_flag & 255);
            if(a->image->cache != 0 && (a->image->cache->loaded & 255) == 0) {
                buf->image_loaded = 0;
            }
        }
        i = i + 1;
        a = a + 60;
    }
}

void showImageProgress(Buffer* buf)
{// addr = 0x0809A2C9  --  defined in 'image.c' at line 301
    AnchorList* al;   // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    int l;                                 // _cfa_ffffffe4
    int n;                                 // _cfa_ffffffe0
    int _v52;                              // _cfa_ffffffcc (outparam)
    int _v56;                              // _cfa_ffffffc8 (outparam)

    if(buf == 0) {
        return;
    }
    al = buf->img;
    if(al == 0) {
        goto L14;
    } else {
        i = 0;
        l = 0;
        n = 0;
        a = al->anchors;
        while(al->nanchor > i) {
            if(a->image != 0 && a->hseq >= 0) {
                n = n + 1;
                if(a->image->cache != 0 && (a->image->cache->loaded & 1) != 0) {
                    l = l + 1;
                }
            }
            i = i + 1;
            a = a + 60;
        }
        if(n == 0) {
L14:
            return;
        }
        _v52 = n;
        _v56 = l;
        message( *(Sprintf("%d/%d images loaded")), (buf->cursorX & 65535) + (buf->rootX & 65535), (buf->cursorY & 65535) + (buf->rootY & 65535));
        refresh();
        return;
    }
}

void loadImage(Buffer* buf, int flag)
{// addr = 0x0809A3CE  --  defined in 'image.c' at line 327
    ImageCache* cache;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int draw;                              // _cfa_ffffffe8
    Buffer* b;          // _cfa_ffffffe4
    struct stat st;       // _cfa_ffffff8c
    Buffer* _v140;      // _cfa_ffffff74
    Buffer* _v144;      // _cfa_ffffff70
    intOrPtr _v148;                        // _cfa_ffffff6c (outparam)
    char* _v152;                           // _cfa_ffffff68 (outparam)
    ImageCache** _t111;   // _t111
    int _t138;                             // _t138
    int _t163;                             // _t163
    char* _t184;                           // _t184

    draw = 0;
    if(maxLoadImage <= 8) {
        if(maxLoadImage <= 0) {
            maxLoadImage = 1;
        }
    } else {
        maxLoadImage = 8;
    }
    if(n_load_image == 0) {
        n_load_image = maxLoadImage;
    }
    _t111 = image_cache;
    if(_t111 == 0) {
         *__esp = 32;
        GC_malloc();
        image_cache = _t111;
        _v152 = 32;
         *__esp = image_cache;
        bzero();
    }
    i = 0;
    do {
    } while(i < n_load_image);
    if(buf != image_buffer) {
        _t138 = 0;
    } else {
        _t138 = maxLoadImage;
    }
    i = _t138;
    while(i < n_load_image) {
        cache = image_cache[i];
        if(cache != 0) {
            if(cache->pid != 0) {
                _v152 = 9;
                 *__esp = cache->pid;
                kill();
                cache->pid = 0;
            }
             *__esp = cache->touch;
            unlink();
            image_cache[i] = 0;
        }
        i = i + 1;
    }
    if(flag != 1) {
        if(draw != 0 && image_buffer != 0) {
            drawImage();
            showImageProgress(image_buffer);
        }
        image_buffer = buf;
        if(image_list == 0) {
            return;
        } else {
            i = 0;
            while(i < n_load_image) {
                if(image_cache[i] != 0) {
L62:
                    i = i + 1;
                    continue;
                }
                while(1) {
                    cache = popValue(image_list);
                    if(cache == 0) {
                        break;
                    }
                    if((cache->loaded & 255) != 0) {
                        continue;
                    }
                    _t163 = cache;
                    image_cache[i] = _t163;
                    flush_tty();
                    fork();
                    cache->pid = _t163;
                    if(cache->pid != 0) {
L59:
                        if(cache->pid >= 0) {
                            goto L62;
                        }
                        cache->pid = 0;
                        return;
                    }
                    setup_child(0, 0, -1);
                    image_source = cache->file;
                    _v140 = 0;
                    _v144 = 0;
                    b = loadGeneralFile(cache->url, cache->current, 0);
                    if(b == 0 || b->real_type == 0) {
L57:
                         *__esp = cache->file;
                        unlink();
                        goto L58;
                    } else {
                        _t184 = b->real_type;
                        _v148 = 6;
                        _v152 = "image/";
                         *__esp = _t184;
                        strncasecmp();
                        if(_t184 == 0) {
L58:
                            _v152 = cache->touch;
                             *__esp = cache->file;
                            symlink();
                             *__esp = 0;
                            exit();
                            goto L59;
                        }
                        goto L57;
                    }
                }
                i = 0;
                while(i < n_load_image) {
                    if(image_cache[i] != 0) {
                        return;
                    }
                    i = i + 1;
                }
                image_list = 0;
                image_file = 0;
                if(image_buffer == 0) {
                    return;
                }
                displayBuffer(image_buffer, 0);
                return;
            }
            return;
        }
    }
    image_list = 0;
    image_file = 0;
    n_load_image = maxLoadImage;
    image_buffer = 0;
}

ImageCache* getImage(Image* image, ParsedURL* current, int flag)
{// addr = 0x0809A815  --  defined in 'image.c' at line 462
    Str key;               // _cfa_fffffff0
    ImageCache* cache;   // _cfa_ffffffec
    struct stat st;       // _cfa_ffffff94
    char* _v112;                           // _cfa_ffffff90
    signed int _v116;                      // _cfa_ffffff8c (outparam)
    signed int _v120;                      // _cfa_ffffff88 (outparam)
    ImageCache* _t102;   // _t102

    key = 0;
    if(activeImage == 0) {
        return 0;
    }
    if(image_hash == 0) {
        image_hash = newHash_sv(100);
    }
    if(image->cache == 0) {
        _v112 = image->url;
        _v116 = image->height & 65535;
        _v120 = image->width & 65535;
        key = Sprintf("%d;%d;%s");
        _t102 = getHash_sv(image_hash, key->ptr, 0);
        cache = _t102;
    } else {
        _t102 = image->cache;
        cache = _t102;
    }
    if(cache != 0) {
        _t102 = cache->index;
        if(_t102 != 0) {
            _t102 = (cache->index ^ cache->index >> 31) - (cache->index >> 31);
            if(_t102 <= image_index - 1000) {
                if(__stat(cache->file,  &(st.st_dev)) != 0) {
                    cache->loaded = 0;
                }
                _t102 = cache;
                _t102->index = 0;
            }
        }
    }
    if(cache != 0) {
L17:
        if(flag != 1) {
            if((cache->loaded & 255) == 0) {
                if(image_file == 0) {
                    image_file = newHash_sv(100);
                }
                if(getHash_sv(image_file, cache->file, 0) == 0) {
                    putHash_sv(image_file, cache->file, cache);
                    if(image_list == 0) {
                        image_list = newGeneralList();
                    }
                    pushValue(image_list, cache);
                }
            }
            if(cache->index == 0) {
                image_index = image_index + 1;
                cache->index = image_index;
            }
        }
        if((cache->loaded & 1) != 0) {
            getImageSize(cache);
        }
        return cache;
    } else {
        if(flag != 1) {
             *__esp = 32;
            GC_malloc();
            cache = _t102;
            cache->url = image->url;
            cache->current = current;
            cache->file =  *(tmpfname(0, image->ext));
            cache->touch =  *(tmpfname(0, 0));
            cache->pid = 0;
            cache->index = 0;
            cache->loaded = 0;
            cache->width = image->width & 65535;
            cache->height = image->height & 65535;
            putHash_sv(image_hash, key->ptr, cache);
            goto L17;
        }
        return 0;
    }
}

int getImageSize(ImageCache* cache)
{// addr = 0x0809AAB9  --  defined in 'image.c' at line 520
    Str tmp;               // _cfa_fffffff0
    FILE* f;              // _cfa_ffffffec
    int w;                                 // _cfa_ffffffe8
    int h;                                 // _cfa_ffffffe4
    int tmp;                               // _cfa_ffffffe0
    int tmp;                               // _cfa_ffffffdc
    short _v46;                            // _cfa_ffffffd2
    int _v52;                              // _cfa_ffffffcc
    _unknown_ _v54;                        // _cfa_ffffffca
    short _v56;                            // _cfa_ffffffc8
    int _v76;                              // _cfa_ffffffb4
    char* _v80;                            // _cfa_ffffffb0
    signed int _v84;                       // _cfa_ffffffac (outparam)
    int _v88;                              // _cfa_ffffffa8 (outparam)
    char* _t121;                           // _t121
    char* _t124;                           // _t124
    FILE* _t127;          // _t127
    int _t129;                             // _t129

    w = 0;
    h = 0;
    if(activeImage == 0) {
        return 0;
    }
    if(cache == 0 || (cache->loaded & 1) == 0 || (cache->width & 65535) > 0 && (cache->height & 65535) > 0) {
        return 0;
    }
    tmp = Strnew();
    _t121 = Imgdisplay;
    _v88 = 47;
     *__esp = _t121;
    strchr();
    if(_t121 == 0) {
        _t129 = w3m_auxbin_dir();
        _v80 = 0;
        _v84 = 135063848;
        _v88 = _t129;
        Strcat_m_charp(tmp);
    }
    _t124 = shell_quote(cache->file);
    __edx = Imgdisplay;
    _v76 = 0;
    _v80 = _t124;
    _v84 = " -size ";
    _v88 = Imgdisplay;
    Strcat_m_charp(tmp);
    _t127 = tmp->ptr;
    _v88 = 135063869;
     *__esp = _t127;
    popen();
    f = _t127;
    if(f != 0) {
        while(1) {
            __eax = 135063871;
            __edx =  &h;
            _v80 =  &h;
            __edx =  &w;
            _v84 =  &w;
            _v88 = 135063871;
            __eax = f;
             *__esp = __eax;
            fscanf();
            if(__eax >= 0) {
                break;
            }
            __eax = f;
             *__esp = __eax;
            feof();
            if(__eax != 0) {
L17:
                __eax = f;
                 *__esp = f;
                pclose();
                __eax = w;
                if(w <= 0) {
L19:
                    __eax = 0;
                    return 0;
                }
                __eax = h;
                if(h > 0) {
                    __eax = w;
                    _v52 = w;
                    asm("fild dword [ebp-0x30]");
                    asm("fmulp st1, st0");
                    asm("fdivp st1, st0");
                    asm("faddp st1, st0");
                    asm("fnstcw word [ebp-0x32]");
                    _v56 = __ax;
                    asm("fldcw word [ebp-0x34]");
                    asm("fistp dword [ebp-0x30]");
                    asm("fldcw word [ebp-0x32]");
                    __eax = _v52;
                    w = _v52;
                    __eax = w;
                    if(w == 0) {
                        w = 1;
                    }
                    __eax = h;
                    _v52 = h;
                    asm("fild dword [ebp-0x30]");
                    asm("fmulp st1, st0");
                    asm("fdivp st1, st0");
                    asm("faddp st1, st0");
                    asm("fldcw word [ebp-0x34]");
                    asm("fistp dword [ebp-0x30]");
                    asm("fldcw word [ebp-0x32]");
                    __eax = _v52;
                    h = _v52;
                    __eax = h;
                    if(h == 0) {
                        h = 1;
                    }
                    cache = cache->width & 65535;
                    if(__ax >= 0) {
L27:
                        cache = cache->width & 65535;
                        if(__ax >= 0) {
                            cache = cache->height & 65535;
                            if(__ax < 0) {
                                cache = cache->width & 65535;
                                _v46 = __ax;
                                asm("fild word [ebp-0x2a]");
                                __eax = h;
                                _v52 = h;
                                asm("fild dword [ebp-0x30]");
                                asm("fmulp st1, st0");
                                __eax = w;
                                _v52 = w;
                                asm("fild dword [ebp-0x30]");
                                asm("fdivp st1, st0");
                                asm("faddp st1, st0");
                                asm("fldcw word [ebp-0x34]");
                                asm("fistp dword [ebp-0x20]");
                                asm("fldcw word [ebp-0x32]");
                                2048 = tmp - 2048 <= 0 ? tmp : 2048;
                                __edx = tmp - 2048 <= 0 ? tmp : 2048;
                                __eax = cache;
                                cache->height = tmp - 2048 <= 0 ? tmp : 2048;
                            }
                        } else {
                            cache = cache->height & 65535;
                            _v46 = __ax;
                            asm("fild word [ebp-0x2a]");
                            __eax = w;
                            _v52 = w;
                            asm("fild dword [ebp-0x30]");
                            asm("fmulp st1, st0");
                            __eax = h;
                            _v52 = h;
                            asm("fild dword [ebp-0x30]");
                            asm("fdivp st1, st0");
                            asm("faddp st1, st0");
                            asm("fldcw word [ebp-0x34]");
                            asm("fistp dword [ebp-0x1c]");
                            asm("fldcw word [ebp-0x32]");
                            2048 = tmp - 2048 <= 0 ? tmp : 2048;
                            __edx = tmp - 2048 <= 0 ? tmp : 2048;
                            __eax = cache;
                            cache->width = tmp - 2048 <= 0 ? tmp : 2048;
                        }
                        goto L31;
                    } else {
                        cache = cache->height & 65535;
                        if(__ax >= 0) {
                            goto L27;
                        }
                        __eax = w;
                        __edx = 2048;
                        __eax = w - 2048 > 0 ? 2048 : w;
                        __edx = w - 2048 > 0 ? 2048 : w;
                        __eax = cache;
                        cache->width = __dx;
                        __eax = h;
                        __edx = 2048;
                        __eax = h - 2048 > 0 ? 2048 : h;
                        __edx = h - 2048 > 0 ? 2048 : h;
                        __eax = cache;
                        cache->height = h - 2048 > 0 ? 2048 : h;
L31:
                        cache = cache->width & 65535;
                        if(__ax == 0) {
                            __eax = cache;
                            cache->width = 1;
                        }
                        cache = cache->height & 65535;
                        if((cache->height & 65535) == 0) {
                            __eax = cache;
                            cache->height = 1;
                        }
                        cache = cache;
                        __eax = cache->height & 65535;
                        __edx = cache->height & 65535;
                        __eax = cache;
                        __eax = cache->width & 65535;
                        __ax = __eax;
                        _v80 = cache->url;
                        _v84 = cache->height & 65535;
                        _v88 = __eax;
                        tmp = Sprintf("%d;%d;%s");
                        __eax = tmp;
                        __edx = tmp->ptr;
                        __eax = image_hash;
                        putHash_sv(image_hash, tmp->ptr, cache);
                        __eax = 1;
                        return 1;
                    }
                }
                goto L19;
            }
        }
        goto L17;
    } else {
        return 0;
    }
}

void encode_symbol(symbol_set* s)
{// addr = 0x0809AE2C  --  defined in 'symbol.c' at line 72
    int i;                                 // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    i = 0;
    while( *(s->item + (i << 2)) != 0) {
        if(( *( *(s->item + (i << 2))) & 255) != 0) {
             *(s->item + (i << 2)) =  *(wc_Str_conv(Strnew_charp( *(s->item + (i << 2))), s->ces, InnerCharset));
        }
        i = i + 1;
    }
    s->encode = 1;
}

char** get_symbol(wc_ces charset, int* width)
{// addr = 0x0809AEC2  --  defined in 'symbol.c' at line 84
    charset_symbol_set* p;   // _cfa_fffffff0
    symbol_set* s;   // _cfa_ffffffec
    symbol_set* _t58;   // _t58

    s = 0;
    if(charset != save_charset || save_symbol == 0) {
L4:
        save_charset = charset;
        p =  &charset_symbol_list;
        while(p->charset != 0) {
            if(p->charset != charset ||  *width != 0 &&  *width != (p->symbol->width & 255)) {
                p = p + 8;
                continue;
            } else {
                s = p->symbol;
                break;
            }
        }
        if(s == 0) {
            if( *width != 2) {
                _t58 =  &alt_symbol_set;
            } else {
                _t58 =  &alt2_symbol_set;
            }
            s = _t58;
        }
        if(s != save_symbol) {
            if((s->encode & 255) == 0) {
                encode_symbol(s);
            }
            save_symbol = s;
        }
         *width = s->width & 255;
        return s->item;
    } else {
        if( *width != (save_symbol->width & 255)) {
            goto L4;
        } else {
             *width = save_symbol->width & 255;
            return save_symbol->item;
        }
    }
}

char** set_symbol(int width)
{// addr = 0x0809AFC5  --  defined in 'symbol.c' at line 114
    symbol_set* s;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    Str tmp;               // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    char** _t53;                           // _t53

    s =  &alt_symbol_set;
    if(width != save_width) {
        if(symbol_buf != 0) {
L7:
            i = 0;
            while(s->item[i] != 0) {
                tmp = Strnew_size(4);
                if(width != 2) {
                    wtf_push(tmp, 2048, i + 32);
                } else {
                    wtf_push(tmp, 34816, i + 32);
                }
                symbol_buf[i] = tmp->ptr;
                i = i + 1;
            }
            save_width = width;
            return symbol_buf;
        }
        i = 0;
        while(s->item[i] != 0) {
            i = i + 1;
        }
        _t53 = i << 2;
         *__esp = _t53;
        GC_malloc();
        symbol_buf = _t53;
        goto L7;
    }
    return symbol_buf;
}

void push_symbol(Str str, char symbol, int width, int n)
{// addr = 0x0809B0B9  --  defined in 'symbol.c' at line 150
    char[1] buf;                           // _cfa_fffffff2
    char* p;                               // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    signed int _v56;                       // _cfa_ffffffc8 (outparam)
    signed int _t52;                       // _t52

    _v32 = symbol;
    if(width != 2) {
        p =  *( &alt_symbol + _v32 * 4);
    } else {
        p =  *( &alt2_symbol + _v32 * 4);
    }
    i = 0;
    while(i <= 1 && ( *p & 255) != 0) {
        __edx = i;
        if(( *p & 255) == 32) {
            _t52 = -96;
        } else {
            _t52 =  *p & 255;
        }
         *((char*)(__ebp + __edx - 10)) = _t52;
        i = i + 1;
        p =  &(p[1]);
    }
    _v56 = _v32;
    Strcat(str, Sprintf("<_SYMBOL TYPE=%d>"));
    while(n > 0) {
        Strcat_charp_n(str,  &buf, i);
        n = n - 1;
    }
    Strcat_charp(str, "</_SYMBOL>");
}

char* conv_entity(unsigned int c)
{// addr = 0x0809B188  --  defined in 'entity.c' at line 35
    char b;                                // _cfa_fffffff3
    wc_uchar[6] utf8;   // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1

    b = c;
    if(c > 31) {
        if(c > 126) {
            if(c > 159) {
                if(c != 160) {
                    if(c > 255) {
                        if(c < 0) {
                            return 135064828;
                        }
                        wc_ucs_to_utf8(c,  &utf8);
                        return  *(wc_Str_conv(Strnew_charp( &utf8), 3178565, InnerCharset));
                    }
                    if((UseAltEntity & 255) == 0) {
                        return  *(wc_Str_conv(Strnew_charp_n( &b, 1), 1049089, InnerCharset));
                    }
                    return  *( &alt_latin1 + (c - 160) * 4);
                }
                return 135064736;
            }
            return 135065021;
        }
        return  *(Strnew_charp_n( &b, 1));
    }
    return 135065021;
}

void writestr(char* s)
{// addr = 0x0809B290  --  defined in 'terms.c' at line 459
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8

    _v20 = write1;
    _v24 = 1;
     *__esp = s;
    tputs();
}

int set_tty()
{// addr = 0x0809B2B3  --  defined in 'terms.c' at line 507
    char* ttyn;                            // _cfa_fffffff0
    struct w3m_term_info* p;   // _cfa_ffffffec
    char* term;                            // _cfa_ffffffe8
    struct w3m_term_info* p;   // _cfa_ffffffe4
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    int _t31;                              // _t31
    FILE* _t33;           // _t33
    char* _t35;                            // _t35
    char* _t40;                            // _t40
    char* _t41;                            // _t41
    char* _t46;                            // _t46
    char* _t48;                            // _t48

     *__esp = 0;
    isatty();
    if(__eax == 0) {
        ttyn = "/dev/tty";
    } else {
         *__esp = 0;
        ttyname();
        ttyn = __eax;
    }
    _v40 = 2;
    _t31 = ttyn;
     *__esp = _t31;
    open();
    tty = _t31;
    if(tty < 0) {
        tty = 2;
    }
    _t33 = tty;
    _v40 = 135065070;
     *__esp = _t33;
    fdopen();
    ttyf = _t33;
    _v40 =  &d_ioval;
     *__esp = tty;
    tcgetattr();
    _t35 = displayTitleTerm;
    if(_t35 != 0) {
        p =  &w3m_term_info_list;
        while(1) {
            _t35 = p->term;
            if(_t35 == 0) {
                goto L11;
            }
            _t46 = p->term;
             *__esp = _t46;
            strlen();
            _t48 = displayTitleTerm;
            _v36 = _t46;
            _v40 = p->term;
             *__esp = _t48;
            strncmp();
            if(_t48 != 0) {
                p = p + 12;
                continue;
            } else {
                _t35 = p->title_str;
                title_str = _t35;
            }
            goto L11;
        }
    }
L11:
     *__esp = 135065072;
    getenv();
    term = _t35;
    if(term != 0) {
        p =  &w3m_term_info_list;
        while(p->term != 0) {
            _t40 = p->term;
             *__esp = _t40;
            strlen();
            _v36 = _t40;
            _v40 = p->term;
            _t41 = term;
             *__esp = _t41;
            strncmp();
            if(_t41 != 0) {
                p = p + 12;
                continue;
            } else {
                is_xterm = p->mouse_flag;
            }
            goto L17;
        }
    }
L17:
    return 0;
}

void ttymode_set(int mode, int imode)
{// addr = 0x0809B3FC  --  defined in 'terms.c' at line 552
    signed int _v16;                       // _cfa_fffffff0
    signed int _v64;                       // _cfa_ffffffc0
    TerminalMode ioval;   // _cfa_ffffffb4
    struct termios* _v84;   // _cfa_ffffffac
    struct termios* _v88;   // _cfa_ffffffa8
    int _t24;                              // _t24
    _unknown_ _t25;                        // _t25
    _unknown_ _t26;                        // _t26

    _v16 =  *gs:0x14];
    _v88 =  &ioval;
     *__esp = tty;
    tcgetattr();
    _v64 = mode | _v64;
    ioval.c_iflag = imode | ioval.c_iflag;
    do {
        _t24 = tty;
        _v84 =  &ioval;
        _v88 = 0;
         *__esp = _t24;
        tcsetattr();
    } while(_t24 == -1);
    if((_v16 ^  *gs:0x14]) == 0) {
        return;
    }
    __stack_chk_fail();
}

void ttymode_reset(int mode, int imode)
{// addr = 0x0809B4B6  --  defined in 'terms.c' at line 573
    signed int _v16;                       // _cfa_fffffff0
    signed int _v64;                       // _cfa_ffffffc0
    TerminalMode ioval;   // _cfa_ffffffb4
    struct termios* _v84;   // _cfa_ffffffac
    struct termios* _v88;   // _cfa_ffffffa8
    int _t26;                              // _t26
    _unknown_ _t27;                        // _t27
    _unknown_ _t28;                        // _t28

    _v16 =  *gs:0x14];
    _v88 =  &ioval;
     *__esp = tty;
    tcgetattr();
    _v64 =  !mode & _v64;
    ioval.c_iflag =  !imode & ioval.c_iflag;
    do {
        _t26 = tty;
        _v84 =  &ioval;
        _v88 = 0;
         *__esp = _t26;
        tcsetattr();
    } while(_t26 == -1);
    if((_v16 ^  *gs:0x14]) == 0) {
        return;
    }
    __stack_chk_fail();
}

void set_cc(int spec, int val)
{// addr = 0x0809B574  --  defined in 'terms.c' at line 595
    signed int _v16;                       // _cfa_fffffff0
    TerminalMode ioval;   // _cfa_ffffffb4
    struct termios* _v84;   // _cfa_ffffffac
    struct termios* _v88;   // _cfa_ffffffa8
    int _t17;                              // _t17
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19

    _v16 =  *gs:0x14];
    _v88 =  &ioval;
     *__esp = tty;
    tcgetattr();
     *((char*)(__ebp + spec - 55)) = val;
    do {
        _t17 = tty;
        _v84 =  &ioval;
        _v88 = 0;
         *__esp = _t17;
        tcsetattr();
    } while(_t17 == -1);
    if((_v16 ^  *gs:0x14]) == 0) {
        return;
    }
    __stack_chk_fail();
}

void close_tty()
{// addr = 0x0809B61B  --  defined in 'terms.c' at line 611
    if(tty > 2) {
         *__esp = tty;
        close();
        return;
    }
}

char* ttyname_tty()
{// addr = 0x0809B63A  --  defined in 'terms.c' at line 618
    __eax = tty;
     *__esp = __eax;
    ttyname();
    return __eax;
}

void reset_tty()
{// addr = 0x0809B64F  --  defined in 'terms.c' at line 624
    struct termios* _v20;   // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8

    writestr(T_op);
    writestr(T_me);
    if(Do_not_use_ti_te == 0) {
        if(T_te == 0 || ( *T_te & 255) == 0) {
            writestr(T_cl);
        } else {
            writestr(T_te);
        }
    }
    writestr(T_se);
    flush_tty();
    _v20 =  &d_ioval;
    _v24 = 0;
     *__esp = tty;
    tcsetattr();
    close_tty();
}

void reset_exit(int _dummy)
{// addr = 0x0809B6DF  --  defined in 'terms.c' at line 641
    if(mouseActive != 0) {
        mouse_end();
    }
    reset_tty();
    w3m_exit(0);
}

void error_dump(int _dummy)
{// addr = 0x0809B706  --  defined in 'terms.c' at line 653
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _t19;                        // _t19

    mySignal(6, 0);
    reset_tty();
    abort();
    _push(_t19);
    __esp = __esp - 24;
    mySignal(1, reset_exit);
    mySignal(2, reset_exit);
    mySignal(3, reset_exit);
    mySignal(15, reset_exit);
    mySignal(4, error_dump);
    mySignal(6, error_dump);
    mySignal(8, error_dump);
    mySignal(7, error_dump);
}

void set_int()
{// addr = 0x0809B72A  --  defined in 'terms.c' at line 662
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    mySignal(1, reset_exit);
    mySignal(2, reset_exit);
    mySignal(3, reset_exit);
    mySignal(15, reset_exit);
    mySignal(4, error_dump);
    mySignal(6, error_dump);
    mySignal(8, error_dump);
    mySignal(7, error_dump);
}

void setgraphchar()
{// addr = 0x0809B7D2  --  defined in 'terms.c' at line 679
    int c;                                 // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int n;                                 // _cfa_ffffffe8
    int _t24;                              // _t24

    c = 0;
    while(c <= 95) {
         *((char*)( &gcmap + c)) = c + 32;
        c = c + 1;
    }
    if(T_ac != 0) {
        _t24 = T_ac;
         *__esp = _t24;
        strlen();
        n = _t24;
        i = 0;
        while(n - 1 > i) {
            c = (T_ac[i] & 255) - 32;
            if(c >= 0 && c <= 95) {
                 *((char*)( &gcmap + c)) = T_ac[i + 1] & 255;
            }
            i = i + 2;
        }
        return;
    }
}

void getTCstr()
{// addr = 0x0809B86E  --  defined in 'terms.c' at line 701
    char* ent;                             // _cfa_fffffff0
    char* suc;                             // _cfa_ffffffec
    char* pt;                              // _cfa_ffffffe8
    int r;                                 // _cfa_ffffffe4
    int _v32;                              // _cfa_ffffffe0
    char* _v36;                            // _cfa_ffffffdc
    char** _v40;                           // _cfa_ffffffd8 (outparam)
    char* _t220;                           // _t220
    int _t221;                             // _t221
    char** _t231;                          // _t231

    _t220 = __eax;
    pt =  &funcstr;
     *__esp = 135065072;
    getenv();
    if(__eax == 0) {
        _t220 = 0;
    } else {
         *__esp = 135065072;
        getenv();
    }
    ent = _t220;
    if(ent == 0) {
        _v32 = __imp__stderr;
        _v36 = 16;
        _v40 = 1;
         *__esp = "TERM is not set\n";
        fwrite();
        reset_exit(0);
    }
    _t221 = ent;
    _v40 = _t221;
     *__esp =  &bp;
    tgetent();
    r = _t221;
    if(r != 1) {
        _v36 = ent;
        _v40 = "Can't find termcap entry %s\n";
         *__esp = __imp__stderr;
        fprintf();
        reset_exit(0);
    }
    T_ce = pt;
    _v40 =  &pt;
     *__esp = "ce";
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_ce = allocStr(suc, -1);
    } else {
        T_ce = 135065234;
    }
    T_cd = pt;
    _v40 =  &pt;
     *__esp = "cd";
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_cd = allocStr(suc, -1);
    } else {
        T_cd = 135065234;
    }
    T_kr = pt;
    _t231 =  &pt;
    _v40 =  &pt;
     *__esp = "nd";
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        _t231 = allocStr(suc, -1);
        T_kr =  &pt;
    } else {
        T_kr = 135065234;
    }
    if(suc == 0) {
        T_kr = pt;
        _t231 =  &pt;
        _v40 =  &pt;
         *__esp = "kr";
        tgetstr();
        suc =  &pt;
        if(suc != 0) {
            _t231 = allocStr(suc, -1);
            T_kr =  &pt;
        } else {
            T_kr = 135065234;
        }
    }
     *__esp = "bs";
    tgetflag();
    if(_t231 == 0) {
        T_kl = pt;
        _v40 =  &pt;
         *__esp = 135065249;
        tgetstr();
        suc =  &pt;
        if(suc != 0) {
            T_kl = allocStr(suc, -1);
        } else {
            T_kl = 135065234;
        }
        if(suc == 0) {
            T_kl = pt;
            _v40 =  &pt;
             *__esp = 135065252;
            tgetstr();
            suc =  &pt;
            if(suc != 0) {
                T_kl = allocStr(suc, -1);
            } else {
                T_kl = 135065234;
            }
        }
        if(suc == 0) {
            T_kl = pt;
            _v40 =  &pt;
             *__esp = 135065255;
            tgetstr();
            suc =  &pt;
            if(suc != 0) {
                T_kl = allocStr(suc, -1);
            } else {
                T_kl = 135065234;
            }
        }
    } else {
        T_kl = 135065247;
    }
    T_cr = pt;
    _v40 =  &pt;
     *__esp = 135065258;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_cr = allocStr(suc, -1);
    } else {
        T_cr = 135065234;
    }
    T_ta = pt;
    _v40 =  &pt;
     *__esp = 135065261;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_ta = allocStr(suc, -1);
    } else {
        T_ta = 135065234;
    }
    T_sc = pt;
    _v40 =  &pt;
     *__esp = 135065264;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_sc = allocStr(suc, -1);
    } else {
        T_sc = 135065234;
    }
    T_rc = pt;
    _v40 =  &pt;
     *__esp = 135065267;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_rc = allocStr(suc, -1);
    } else {
        T_rc = 135065234;
    }
    T_so = pt;
    _v40 =  &pt;
     *__esp = 135065270;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_so = allocStr(suc, -1);
    } else {
        T_so = 135065234;
    }
    T_se = pt;
    _v40 =  &pt;
     *__esp = 135065273;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_se = allocStr(suc, -1);
    } else {
        T_se = 135065234;
    }
    T_us = pt;
    _v40 =  &pt;
     *__esp = 135065276;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_us = allocStr(suc, -1);
    } else {
        T_us = 135065234;
    }
    T_ue = pt;
    _v40 =  &pt;
     *__esp = 135065279;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_ue = allocStr(suc, -1);
    } else {
        T_ue = 135065234;
    }
    T_md = pt;
    _v40 =  &pt;
     *__esp = 135065282;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_md = allocStr(suc, -1);
    } else {
        T_md = 135065234;
    }
    T_me = pt;
    _v40 =  &pt;
     *__esp = 135065285;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_me = allocStr(suc, -1);
    } else {
        T_me = 135065234;
    }
    T_cl = pt;
    _v40 =  &pt;
     *__esp = 135065288;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_cl = allocStr(suc, -1);
    } else {
        T_cl = 135065234;
    }
    T_cm = pt;
    _v40 =  &pt;
     *__esp = 135065291;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_cm = allocStr(suc, -1);
    } else {
        T_cm = 135065234;
    }
    T_al = pt;
    _v40 =  &pt;
     *__esp = 135065294;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_al = allocStr(suc, -1);
    } else {
        T_al = 135065234;
    }
    T_sr = pt;
    _v40 =  &pt;
     *__esp = 135065297;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_sr = allocStr(suc, -1);
    } else {
        T_sr = 135065234;
    }
    T_ti = pt;
    _v40 =  &pt;
     *__esp = 135065300;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_ti = allocStr(suc, -1);
    } else {
        T_ti = 135065234;
    }
    T_te = pt;
    _v40 =  &pt;
     *__esp = 135065303;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_te = allocStr(suc, -1);
    } else {
        T_te = 135065234;
    }
    T_nd = pt;
    _v40 =  &pt;
     *__esp = "nd";
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_nd = allocStr(suc, -1);
    } else {
        T_nd = 135065234;
    }
    T_eA = pt;
    _v40 =  &pt;
     *__esp = 135065306;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_eA = allocStr(suc, -1);
    } else {
        T_eA = 135065234;
    }
    T_as = pt;
    _v40 =  &pt;
     *__esp = 135065309;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_as = allocStr(suc, -1);
    } else {
        T_as = 135065234;
    }
    T_ae = pt;
    _v40 =  &pt;
     *__esp = 135065312;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_ae = allocStr(suc, -1);
    } else {
        T_ae = 135065234;
    }
    T_ac = pt;
    _v40 =  &pt;
     *__esp = 135065315;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_ac = allocStr(suc, -1);
    } else {
        T_ac = 135065234;
    }
    T_op = pt;
    _v40 =  &pt;
     *__esp = 135065318;
    tgetstr();
    suc =  &pt;
    if(suc != 0) {
        T_op = allocStr(suc, -1);
    } else {
        T_op = 135065234;
    }
    COLS = 0;
    LINES = COLS;
    setlinescols();
    setgraphchar();
}

void setlinescols()
{// addr = 0x0809C199  --  defined in 'terms.c' at line 777
    char* p;                               // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v26;                        // _cfa_ffffffe6
    struct winsize wins;   // _cfa_ffffffe4
    short unsigned int* _v36;              // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    int _t22;                              // _t22
    char* _t23;                            // _t23
    char* _t24;                            // _t24
    int _t25;                              // _t25
    int _t26;                              // _t26
    int _t29;                              // _t29
    int _t31;                              // _t31

    _t22 = tty;
    _v36 =  &(wins.ws_row);
    _v40 = 21523;
     *__esp = _t22;
    ioctl();
    i = _t22;
    if(i >= 0 && (wins.ws_row & 65535) != 0 && (wins.ws_col & 65535) != 0) {
        LINES = wins.ws_row & 0xffff;
        COLS = wins.ws_col & 0xffff;
    }
    _t23 = LINES;
    if(_t23 <= 0) {
         *__esp = 135065321;
        getenv();
        p = _t23;
        if(p != 0) {
            _t31 = p;
             *__esp = _t31;
            atoi();
            i = _t31;
            if(i >= 0) {
                LINES = i;
            }
        }
    }
    _t24 = COLS;
    if(_t24 <= 0) {
         *__esp = "COLUMNS";
        getenv();
        p = _t24;
        if(p != 0) {
            _t29 = p;
             *__esp = _t29;
            atoi();
            i = _t29;
            if(i >= 0) {
                COLS = i;
            }
        }
    }
    _t25 = LINES;
    if(_t25 <= 0) {
         *__esp = "li";
        tgetnum();
        LINES = _t25;
    }
    _t26 = COLS;
    if(_t26 <= 0) {
         *__esp = "co";
        tgetnum();
        COLS = _t26;
    }
    if(COLS > 400) {
        COLS = 400;
    }
    if(LINES > 200) {
        LINES = 200;
        return;
    }
}

void setupscreen()
{// addr = 0x0809C2C4  --  defined in 'terms.c' at line 823
    int i;                                 // _cfa_fffffff0
    signed int _v40;                       // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    signed int _t66;                       // _t66
    Screen** _t79;      // _t79
    Screen* _t86;       // _t86
    Screen** _t88;      // _t88

    if(LINES + 1 > max_LINES) {
        max_LINES = LINES + 1;
        max_COLS = 0;
        _t86 = max_LINES + max_LINES + _t111 << 2;
         *__esp = _t86;
        GC_malloc();
        ScreenElem = _t86;
        _t88 = max_LINES << 2;
         *__esp = _t88;
        GC_malloc();
        ScreenImage = _t88;
    }
    if(COLS + 1 > max_COLS) {
        max_COLS = COLS + 1;
        i = 0;
        while(i < max_LINES) {
            _t108 = i;
            _t66 = max_COLS << 2;
             *__esp = _t66;
            GC_malloc();
             *(ScreenElem + (i + _t108 + _t108 << 2)) = _t66;
            _t109 = i;
            _v40 = max_COLS * 4;
             *__esp =  *(ScreenElem + (i + _t109 + _t109 << 2));
            bzero();
            _t110 = i;
            _t79 = max_COLS + max_COLS;
             *__esp = _t79;
            GC_malloc();
             *(ScreenElem + (i + _t110 + _t110 << 2) + 4) = _t79;
            i = i + 1;
        }
    }
    i = 0;
    while(i < LINES) {
        ScreenImage[i] = ScreenElem + (i + i + _t102 << 2);
         *(ScreenImage[i]->lineprop) = 8;
        ScreenImage[i]->isdirty = 0;
        i = i + 1;
    }
    while(i < max_LINES) {
         *((short*)(ScreenElem + (i + i + _t107 << 2) + 8)) = 2;
        i = i + 1;
    }
    clear();
}

int initscr()
{// addr = 0x0809C480  --  defined in 'terms.c' at line 861
    if(set_tty() >= 0) {
        set_int();
        getTCstr();
        if(T_ti != 0 && Do_not_use_ti_te == 0) {
            writestr(T_ti);
        }
        setupscreen();
        return 0;
    }
    return -1;
}

int write1(char c)
{// addr = 0x0809C4CB  --  defined in 'terms.c' at line 874
    char _v16;                             // _cfa_fffffff0
    FILE* _v40;           // _cfa_ffffffd8

    _v16 = c;
    _v40 = ttyf;
     *__esp = _v16;
    _IO_putc();
    return 0;
}

void move(int line, int column)
{// addr = 0x0809C4F4  --  defined in 'terms.c' at line 884
    if(line >= 0 && line < LINES) {
        CurLine = line;
    }
    if(column < 0 || column >= COLS) {
        return;
    } else {
        CurColumn = column;
        return;
    }
}

int need_redraw(char* c1, l_prop pr1, char* c2, l_prop pr2)
{// addr = 0x0809C529  --  defined in 'terms.c' at line 900
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    char* _v40;                            // _cfa_ffffffd8
    char* _t18;                            // _t18

    _v16 = pr1;
    _v20 = pr2;
    if(c1 == 0 || c2 == 0) {
L3:
        return 1;
    } else {
        _v40 = c2;
        _t18 = c1;
         *__esp = _t18;
        strcmp();
        if(_t18 == 0) {
            if(( *c1 & 255) != 32) {
                if(((_v20 & 65535 ^ _v16 & 65535) & 0xffdf) == 0) {
                    return 0;
                }
                return 1;
            }
            return (_v20 & 65535 ^ _v16 & 65535) & 0xff1f;
        }
        goto L3;
    }
}

void addch(char c)
{// addr = 0x0809C5A6  --  defined in 'terms.c' at line 930
    char _v16;                             // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v16 = c;
    addmch( &_v16, 1);
}

void addmch(char* pc, size_t len)
{// addr = 0x0809C5C7  --  defined in 'terms.c' at line 936
    char c;                                // _cfa_fffffff3
    l_prop l;           // _cfa_fffffff0
    l_prop* pr;         // _cfa_ffffffec
    int dest;                              // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    short int* dirty;                      // _cfa_ffffffe0
    char** p;                              // _cfa_ffffffdc
    int width;                             // _cfa_ffffffd8
    signed int _v48;                       // _cfa_ffffffd0
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    intOrPtr _v68;                         // _cfa_ffffffbc (outparam)
    char* _v72;                            // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t261;                             // _t261
    char* _t338;                           // _t338
    char* _t380;                           // _t380
    char* _t406;                           // _t406
    char* _t432;                           // _t432
    char* _t458;                           // _t458
    char* _t479;                           // _t479
    char* _t539;                           // _t539
    char* _t584;                           // _t584

    c =  *pc & 255;
    if(( *135119023 & 255) == 0) {
        _t261 = ( *( &WTF_WIDTH_MAP + ( *pc & 0xff)) & 255) != 0 & 255;
    } else {
        _t261 =  *( &WTF_WIDTH_MAP + ( *pc & 0xff)) & 0xff;
    }
    width = _t261;
    if(tmp.8815 == 0) {
        tmp.8815 = Strnew();
    }
    Strcopy_charp_n(tmp.8815, pc, len);
    pc =  *tmp.8815;
    if(CurColumn == COLS) {
        wrap();
    }
    if(CurColumn >= COLS) {
        return;
    }
    p =  *(ScreenImage[CurLine]);
    pr = ScreenImage[CurLine]->lineprop;
    dirty =  &(ScreenImage[CurLine]->isdirty);
    if(( *(pr + CurColumn + CurColumn) & 8) == 0) {
L16:
        if(c == 9 || c == 10 || c == 13 || c == 8) {
            CurrentMode = CurrentMode & 65535 | 192;
        } else {
            if(len <= 1) {
                if(( *( &MYCTYPE_MAP + (c & 0xff)) & 1) != 0) {
                    return;
                }
                CurrentMode = CurrentMode & 0x3f;
L25:
                i = CurColumn + width - 1;
                if(i >= COLS) {
L37:
                    if(CurColumn + width <= COLS) {
L43:
                        if(( *(pr + CurColumn + CurColumn) & 0xc0) != 128) {
L50:
                            if((CurrentMode & 0xc0) == 192) {
                                if(c != 9) {
                                    if(c != 10) {
                                        if(c != 13) {
                                            if(c != 8 || CurColumn <= 0) {
L83:
                                                return;
                                            } else {
                                                CurColumn = CurColumn - 1;
                                                while(CurColumn > 0) {
                                                    if(( *(pr + CurColumn + CurColumn) & 0xc0) == 128) {
                                                        CurColumn = CurColumn - 1;
                                                        continue;
                                                    }
                                                    return;
                                                }
                                                goto L83;
                                            }
                                        }
                                        CurColumn = 0;
                                        return;
                                    }
                                    wrap();
                                    return;
                                }
                                _v48 = tab_step;
                                dest = tab_step * (CurColumn + tab_step) / _v48;
                                if(dest >= COLS) {
                                    wrap();
                                    touch_line();
                                    dest = tab_step;
                                    p =  *(ScreenImage[CurLine]);
                                    pr = ScreenImage[CurLine]->lineprop;
                                }
                                i = CurColumn;
                                while(i < dest) {
                                    if(need_redraw(p[i],  *(pr + i + i) & 0xffff, 135065341, CurrentMode & 0xffff) != 0) {
                                        _t338 = p[i];
                                        _v72 = 2;
                                         *__esp = _t338;
                                        GC_realloc();
                                        p[i] = _t338;
                                        _v68 = 1;
                                        _v72 = 135065341;
                                         *__esp = p[i];
                                        memcpy();
                                        p[i][1] = 0;
                                         *(pr + i + i) = CurrentMode & 65535 |  *(pr + i + i) & 0x20;
                                        touch_line();
                                        touch_column(i);
                                    }
                                    i = i + 1;
                                }
                                CurColumn = i;
                                return;
                            }
                            if(need_redraw(p[CurColumn],  *(pr + CurColumn + CurColumn) & 0xffff, pc, CurrentMode & 0xffff) == 0) {
L59:
                                CurColumn = CurColumn + width;
                                return;
                            }
                            _t380 = p[CurColumn];
                            _v72 = len + 1;
                             *__esp = _t380;
                            GC_realloc();
                            p[CurColumn] = _t380;
                            _v68 = len;
                            _v72 = pc;
                             *__esp = p[CurColumn];
                            strncpy();
                            p[CurColumn][len] = 0;
                             *(pr + CurColumn + CurColumn) = CurrentMode & 65535 |  *(pr + CurColumn + CurColumn) & 0x20;
                            touch_line();
                            touch_column(CurColumn);
                            CurrentMode = CurrentMode & 0x3f | 128;
                            i = CurColumn + 1;
                            while(CurColumn + width > i) {
                                _t406 = p[i];
                                _v72 = 2;
                                 *__esp = _t406;
                                GC_realloc();
                                p[i] = _t406;
                                _v68 = 1;
                                _v72 = 135065341;
                                 *__esp = p[i];
                                memcpy();
                                p[i][1] = 0;
                                 *(pr + i + i) =  *(pr + CurColumn + CurColumn) & 0x3f |  *(pr + i + i) & 0x20 | 128;
                                touch_column(i);
                                i = i + 1;
                            }
                            while(i < COLS && ( *(pr + i + i) & 0xc0) == 128) {
                                _t432 = p[i];
                                _v72 = 2;
                                 *__esp = _t432;
                                GC_realloc();
                                p[i] = _t432;
                                _v68 = 1;
                                _v72 = 135065341;
                                 *__esp = p[i];
                                memcpy();
                                p[i][1] = 0;
                                 *(pr + i + i) =  *(pr + i + i) & 0x3f;
                                touch_column(i);
                                i = i + 1;
                            }
                            goto L59;
                        }
                        touch_line();
                        i = CurColumn - 1;
                        while(i >= 0) {
                            l =  *(pr + i + i) & 0xc0;
                            _t458 = p[i];
                            _v72 = 2;
                             *__esp = _t458;
                            GC_realloc();
                            p[i] = _t458;
                            _v68 = 1;
                            _v72 = 135065341;
                             *__esp = p[i];
                            memcpy();
                            p[i][1] = 0;
                             *(pr + i + i) =  *(pr + i + i) & 0x3f;
                            touch_column(i);
                            if(l != 128) {
                                goto L50;
                            }
                            i = i - 1;
                        }
                        goto L50;
                    }
                    touch_line();
                    i = CurColumn;
                    while(i < COLS) {
                        _t479 = p[i];
                        _v72 = 2;
                         *__esp = _t479;
                        GC_realloc();
                        p[i] = _t479;
                        _v68 = 1;
                        _v72 = 135065341;
                         *__esp = p[i];
                        memcpy();
                        p[i][1] = 0;
                         *(pr + i + i) =  *(pr + i + i) & 0x3f;
                        touch_column(i);
                        i = i + 1;
                    }
                    wrap();
                    if(CurColumn + width > COLS) {
                        goto L83;
                    }
                    p =  *(ScreenImage[CurLine]);
                    pr = ScreenImage[CurLine]->lineprop;
                    goto L43;
                }
                if(( *(pr + i + i) & 4) == 0 || need_redraw(p[i],  *(pr + i + i) & 0xffff, pc, CurrentMode & 0xffff) == 0) {
                    if(( *(pr + i + i) & 2) == 0 || (CurrentMode & 2) != 0) {
                        goto L37;
                    } else {
                        goto L30;
                    }
                } else {
L30:
                    touch_line();
                    i = i + 1;
                    if(i >= COLS) {
                        goto L37;
                    }
                    touch_column(i);
                    if(( *(pr + i + i) & 8) == 0) {
                        i = i + 1;
                        while(i < COLS && ( *(pr + i + i) & 0xc0) == 128) {
                            touch_column(i);
                            i = i + 1;
                        }
                        goto L37;
                    }
                    _t539 = p[i];
                    _v72 = 2;
                     *__esp = _t539;
                    GC_realloc();
                    p[i] = _t539;
                    _v68 = 1;
                    _v72 = 135065341;
                     *__esp = p[i];
                    memcpy();
                    p[i][1] = 0;
                     *(pr + i + i) =  *(pr + i + i) & 0x20;
                    goto L37;
                }
            }
            CurrentMode = CurrentMode & 0x3f | 64;
        }
        goto L25;
    }
    if(c != 32) {
L12:
        i = CurColumn;
        while(i >= 0) {
            if(( *(pr + i + i) & 8) != 0) {
                _t584 = p[i];
                _v72 = 2;
                 *__esp = _t584;
                GC_realloc();
                p[i] = _t584;
                _v68 = 1;
                _v72 = 135065341;
                 *__esp = p[i];
                memcpy();
                p[i][1] = 0;
                 *(pr + i + i) =  *(pr + i + i) & 0x20;
                i = i - 1;
                continue;
            }
            goto L16;
        }
        goto L16;
    } else {
        if((CurrentMode & 0xff1f) != 0) {
            goto L12;
        } else {
            CurColumn = CurColumn + 1;
            return;
        }
    }
}

void wrap()
{// addr = 0x0809D009  --  defined in 'terms.c' at line 1110
    if(LINES - 1 != CurLine) {
        CurLine = CurLine + 1;
        CurColumn = 0;
        return;
    }
}

void touch_column(int col)
{// addr = 0x0809D039  --  defined in 'terms.c' at line 1119
    if(col < 0 || col >= COLS) {
        return;
    } else {
         *(ScreenImage[CurLine]->lineprop + col + col) =  *(ScreenImage[CurLine]->lineprop + col + col) & 65535 | 32;
        return;
    }
}

void touch_line()
{// addr = 0x0809D090  --  defined in 'terms.c' at line 1126
    int i;                                 // _cfa_fffffff8

    if((ScreenImage[CurLine]->isdirty & 1) == 0) {
        i = 0;
        while(i < COLS) {
             *(ScreenImage[CurLine]->lineprop + i + i) =  *(ScreenImage[CurLine]->lineprop + i + i) & 0xffdf;
            i = i + 1;
        }
        ScreenImage[CurLine]->isdirty = ScreenImage[CurLine]->isdirty & 65535 | 1;
        return;
    }
}

void standout()
{// addr = 0x0809D143  --  defined in 'terms.c' at line 1138
    CurrentMode = CurrentMode & 65535 | 1;
}

void standend()
{// addr = 0x0809D158  --  defined in 'terms.c' at line 1144
    CurrentMode = CurrentMode & 0xfffe;
}

void toggle_stand()
{// addr = 0x0809D16D  --  defined in 'terms.c' at line 1150
    int i;                                 // _cfa_fffffff8
    l_prop* pr;         // _cfa_fffffff4

    pr = ScreenImage[CurLine]->lineprop;
     *(pr + CurColumn + CurColumn) =  *(pr + CurColumn + CurColumn) & 65535 ^ 1;
    if(( *(pr + CurColumn + CurColumn) & 0xc0) != 128) {
        i = CurColumn + 1;
        while(( *(pr + i + i) & 0xc0) == 128) {
             *(pr + i + i) =  *(pr + i + i) & 65535 ^ 1;
            i = i + 1;
        }
    }
}

void bold()
{// addr = 0x0809D20B  --  defined in 'terms.c' at line 1166
    CurrentMode = CurrentMode & 65535 | 4;
}

void boldend()
{// addr = 0x0809D220  --  defined in 'terms.c' at line 1172
    CurrentMode = CurrentMode & 0xfffb;
}

void underline()
{// addr = 0x0809D235  --  defined in 'terms.c' at line 1178
    CurrentMode = CurrentMode & 65535 | 2;
}

void underlineend()
{// addr = 0x0809D24A  --  defined in 'terms.c' at line 1184
    CurrentMode = CurrentMode & 0xfffd;
}

void graphstart()
{// addr = 0x0809D25F  --  defined in 'terms.c' at line 1190
    CurrentMode = CurrentMode & 65535 | 16;
}

void graphend()
{// addr = 0x0809D274  --  defined in 'terms.c' at line 1196
    CurrentMode = CurrentMode & 0xffef;
}

int graph_ok()
{// addr = 0x0809D289  --  defined in 'terms.c' at line 1202
    if((UseGraphicChar & 255) == 0) {
        return 0;
    }
    if(( *T_as & 255) == 0 || ( *T_ae & 255) == 0 || ( *T_ac & 255) == 0) {
        return 0;
    } else {
        return 1;
    }
}

void setfcolor(int color)
{// addr = 0x0809D2D0  --  defined in 'terms.c' at line 1210
    CurrentMode = CurrentMode & 0xf0;
    if((color & 15) <= 7) {
        CurrentMode = CurrentMode & 65535 | (color & 7 | 8) << 8;
        return;
    }
}

char* color_seq(int colmode)
{// addr = 0x0809D30D  --  defined in 'terms.c' at line 1218
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8

    _v20 = (colmode >> 8 & 7) + 30;
    _v24 = 135065343;
     *__esp =  &seqbuf;
    sprintf();
    return  &seqbuf;
}

void setbcolor(int color)
{// addr = 0x0809D33F  --  defined in 'terms.c' at line 1227
    CurrentMode = CurrentMode & 0xfff;
    if((color & 15) <= 7) {
        CurrentMode = CurrentMode & 65535 | (color & 7 | 8) << 12;
        return;
    }
}

char* bcolor_seq(int colmode)
{// addr = 0x0809D37D  --  defined in 'terms.c' at line 1235
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8

    _v20 = (colmode >> 12 & 7) + 40;
    _v24 = 135065343;
     *__esp =  &seqbuf.9632;
    sprintf();
    return  &seqbuf.9632;
}

void refresh()
{// addr = 0x0809D3AF  --  defined in 'terms.c' at line 1252
    l_prop mode;        // _cfa_fffffff2
    l_prop color;       // _cfa_fffffff0
    l_prop bcolor;      // _cfa_ffffffee
    int line;                              // _cfa_ffffffe8
    int col;                               // _cfa_ffffffe4
    int pcol;                              // _cfa_ffffffe0
    int pline;                             // _cfa_ffffffdc
    int moved;                             // _cfa_ffffffd8
    char** pc;                             // _cfa_ffffffd4
    l_prop* pr;         // _cfa_ffffffd0
    short int* dirty;                      // _cfa_ffffffcc
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    int _v68;                              // _cfa_ffffffbc (outparam)
    int _v72;                              // _cfa_ffffffb8 (outparam)
    char* _t251;                           // _t251
    _unknown_ _t311;                       // _t311
    char _t379;                            // _t379
    char* _t443;                           // _t443
    char* _t493;                           // _t493
    int _t496;                             // _t496
    char* _t499;                           // _t499
    char* _t541;                           // _t541

    pline = CurLine;
    moved = 0;
    mode = 0;
    color = 0;
    bcolor = 0;
    wc_putc_init(InnerCharset, DisplayCharset);
    line = 0;
    while(LINES - 1 >= line) {
        dirty =  &(ScreenImage[line]->isdirty);
        if(( *dirty & 1) == 0) {
L102:
             *dirty =  *dirty & 0xfff3;
            if((mode & 0xff17) != 0) {
                if((mode & 0xff00) != 0) {
                    writestr(T_op);
                }
                if((mode & 0x10) != 0) {
                    writestr(T_ae);
                    wc_putc_clear_status();
                }
                writestr(T_me);
                mode = mode & 232;
            }
            line = line + 1;
            continue;
        } else {
             *dirty =  *dirty & 0xfffe;
            pc =  *(ScreenImage[line]);
            pr = ScreenImage[line]->lineprop;
            col = 0;
            while(col < COLS && ( *(pr + col + col) & 8) == 0) {
                if(( *dirty & 4) == 0 || (ScreenImage[line]->eol & 65535) > col) {
                    if(( *(pr + col + col) & 0x20) != 0) {
                        break;
                    } else {
                        goto L10;
                    }
                } else {
                    if(need_redraw(pc[col],  *(pr + col + col) & 0xffff, 135065341, 0) == 0) {
L10:
                        col = col + 1;
                        continue;
                    } else {
                        break;
                    }
                }
            }
            if(( *dirty & 0xc) == 0) {
                pcol = col;
            } else {
                pcol = ScreenImage[line]->eol & 65535;
                if(pcol >= COLS) {
                     *dirty =  *dirty & 0xfff3;
                    pcol = col;
                }
            }
            if(LINES - 2 <= line || line - 1 != pline || pcol != 0) {
                _t251 = T_cm;
                _v68 = line;
                _v72 = pcol;
                 *__esp = _t251;
                tgoto();
                writestr(_t251);
                moved = 1;
L31:
                if(( *dirty & 0xc) != 0) {
                    writestr(T_ce);
                    if(col != pcol) {
                        _t493 = T_cm;
                        _v68 = line;
                        _v72 = col;
                         *__esp = _t493;
                        tgoto();
                        writestr(_t493);
                    }
                }
                pline = line;
                pcol = col;
                while(col < COLS) {
                    if(( *(pr + col + col) & 8) != 0) {
L96:
                        if(col == COLS) {
                            moved = 0;
                        }
                        while(col < COLS && ( *(pr + col + col) & 8) == 0) {
                             *(pr + col + col) =  *(pr + col + col) & 65535 | 8;
                            col = col + 1;
                        }
                        goto L102;
                    }
                    if(( *(pr + col + col) & 1) != 0 || (mode & 1) == 0) {
                        if(( *(pr + col + col) & 2) != 0 || (mode & 2) == 0) {
                            if(( *(pr + col + col) & 4) != 0 || (mode & 4) == 0) {
                                if(( *(pr + col + col) & 0xf00) != 0 || (mode & 0xf00) == 0) {
                                    if(( *(pr + col + col) & 0xf000) != 0 || (mode & 0xf000) == 0) {
                                        if(( *(pr + col + col) & 0x10) != 0 || (mode & 0x10) == 0) {
                                            goto L54;
                                        } else {
                                            goto L48;
                                        }
                                    } else {
                                        goto L48;
                                    }
                                } else {
                                    goto L48;
                                }
                            } else {
                                goto L48;
                            }
                        } else {
                            goto L48;
                        }
                    } else {
L48:
                        if((mode & 0xf00) != 0 || (mode & 0xf000) != 0) {
                            writestr(T_op);
                        }
                        if((mode & 0x10) != 0) {
                            writestr(T_ae);
                        }
                        writestr(T_me);
                        mode = mode & 232;
L54:
                        if(( *dirty & 4) == 0 || (ScreenImage[line]->eol & 65535) > col) {
                            _t311 = ( *(pr + col + col) & 0x20) != 0;
                        } else {
                            _t311 = need_redraw(pc[col],  *(pr + col + col) & 0xffff, 135065341, 0) != 0;
                        }
                        if(_t311 == 0) {
L92:
                            col = col + 1;
                            continue;
                        }
                        if(col - 1 != pcol) {
                            if(pcol != col) {
                                _t443 = T_cm;
                                _v68 = line;
                                _v72 = col;
                                 *__esp = _t443;
                                tgoto();
                                writestr(_t443);
                            }
                        } else {
                            writestr(T_nd);
                        }
                        if(( *(pr + col + col) & 1) != 0 && (mode & 1) == 0) {
                            writestr(T_so);
                            mode = mode | 1;
                        }
                        if(( *(pr + col + col) & 2) != 0 && (mode & 2) == 0) {
                            writestr(T_us);
                            mode = mode | 2;
                        }
                        if(( *(pr + col + col) & 4) != 0 && (mode & 4) == 0) {
                            writestr(T_md);
                            mode = mode | 4;
                        }
                        if(( *(pr + col + col) & 0xf00) != 0 && (( *(pr + col + col) & 65535 ^ mode) & 0xf00) != 0) {
                            color =  *(pr + col + col) & 0xf00;
                            mode = color & 65535 | mode & 0xf0;
                            writestr(color_seq(color & 65535));
                        }
                        if(( *(pr + col + col) & 0xf000) != 0 && (( *(pr + col + col) & 65535 ^ mode) & 0xf000) != 0) {
                            bcolor =  *(pr + col + col) & 0xf000;
                            mode = bcolor & 65535 | mode & 0xfff;
                            writestr(bcolor_seq(bcolor & 65535));
                        }
                        if(( *(pr + col + col) & 0x10) != 0 && (mode & 0x10) == 0) {
                            wc_putc_end(ttyf);
                            if(graph_enabled == 0) {
                                graph_enabled = 1;
                                writestr(T_eA);
                            }
                            writestr(T_as);
                            mode = mode | 16;
                        }
                        if(( *(pr + col + col) & 0x10) == 0) {
                            if(( *(pr + col + col) & 0xc0) != 128) {
                                wc_putc(pc[col], ttyf);
                            }
                        } else {
                            if(( *(pc[col]) & 255) <= 31 || ( *(pc[col]) & 255) < 0) {
                                _t379 =  *(pc[col]) & 255;
                            } else {
                                _t379 =  *( &gcmap + ( *(pc[col]) & 255) - 32) & 255;
                            }
                            write1(_t379);
                        }
                        pcol = col + 1;
                        goto L92;
                    }
                }
                goto L96;
            } else {
                _t496 = moved;
                if(_t496 == 1) {
                    write1(10);
                    write1(13);
L28:
                    goto L31;
                }
                if(_t496 == 2) {
                    moved = 1;
                    goto L31;
                }
                if(_t496 != 0) {
                    goto L31;
                } else {
                    _t499 = T_cm;
                    _v68 = line;
                    _v72 = 0;
                     *__esp = _t499;
                    tgoto();
                    writestr(_t499);
                    moved = 1;
                    goto L28;
                }
            }
        }
    }
    wc_putc_end(ttyf);
    _t541 = T_cm;
    _v68 = CurLine;
    _v72 = CurColumn;
     *__esp = _t541;
    tgoto();
    writestr(_t541);
    flush_tty();
}

void clear()
{// addr = 0x0809DBFF  --  defined in 'terms.c' at line 1451
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    l_prop* p;          // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    writestr(T_cl);
    move(0, 0);
    i = 0;
    while(i < LINES) {
        ScreenImage[i]->isdirty = 0;
        p = ScreenImage[i]->lineprop;
        j = 0;
        while(j < COLS) {
             *((short*)(p + j + j)) = 8;
            j = j + 1;
        }
        i = i + 1;
    }
    CurrentMode = 0;
}

void clrtoeol()
{// addr = 0x0809DC96  --  defined in 'terms.c' at line 1581
    int i;                                 // _cfa_fffffff8
    l_prop* lprop;      // _cfa_fffffff4

    lprop = ScreenImage[CurLine]->lineprop;
    if(( *(lprop + CurColumn + CurColumn) & 8) != 0) {
L10:
        return;
    }
    if((ScreenImage[CurLine]->isdirty & 0xc) == 0 || (ScreenImage[CurLine]->eol & 65535) > CurColumn) {
        ScreenImage[CurLine]->eol = CurColumn;
    }
    ScreenImage[CurLine]->isdirty = ScreenImage[CurLine]->isdirty & 65535 | 8;
    touch_line();
    i = CurColumn;
    while(i < COLS) {
        if(( *(lprop + i + i) & 8) == 0) {
             *(lprop + i + i) = 40;
            i = i + 1;
            continue;
        }
        return;
    }
    goto L10;
}

void clrtoeol_with_bcolor()
{// addr = 0x0809DD9F  --  defined in 'terms.c' at line 1602
    l_prop pr;          // _cfa_fffffff2
    int i;                                 // _cfa_ffffffec
    int cli;                               // _cfa_ffffffe8
    int cco;                               // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if((CurrentMode & 0xf000) != 0) {
        cli = CurLine;
        cco = CurColumn;
        pr = CurrentMode & 65535;
        CurrentMode = CurrentMode & 0xf020;
        i = CurColumn;
        while(i < COLS) {
            addch(32);
            i = i + 1;
        }
        move(cli, cco);
        CurrentMode = pr & 65535;
        return;
    }
    clrtoeol();
}

void clrtoeolx()
{// addr = 0x0809DE2D  --  defined in 'terms.c' at line 1622
    clrtoeol_with_bcolor();
}

void clrtobot_eol(_None* clrtoeol)
{// addr = 0x0809DE3A  --  defined in 'terms.c' at line 1636
    int l;                                 // _cfa_fffffff0
    int c;                                 // _cfa_ffffffec

    l = CurLine;
    c = CurColumn;
     *clrtoeol();
    CurColumn = 0;
    CurLine = CurLine + 1;
    while(CurLine < LINES) {
         *clrtoeol();
        CurLine = CurLine + 1;
    }
    CurLine = l;
    CurColumn = c;
}

void clrtobot()
{// addr = 0x0809DEA1  --  defined in 'terms.c' at line 1652
    clrtobot_eol(clrtoeol);
}

void clrtobotx()
{// addr = 0x0809DEB6  --  defined in 'terms.c' at line 1658
    clrtobot_eol(clrtoeolx);
}

void addstr(char* s)
{// addr = 0x0809DECB  --  defined in 'terms.c' at line 1675
    int len;                               // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    while(( *s & 255) != 0) {
        len = wtf_len(s);
        addmch(s, len);
        s =  &(s[len]);
    }
}

void addnstr(char* s, int n)
{// addr = 0x0809DF05  --  defined in 'terms.c' at line 1692
    int i;                                 // _cfa_fffffff0
    int len;                               // _cfa_ffffffec
    int width;                             // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t31;                              // _t31

    i = 0;
    while(( *s & 255) != 0) {
        if(( *135119023 & 255) == 0) {
            _t31 = ( *( &WTF_WIDTH_MAP + ( *s & 0xff)) & 255) != 0 & 255;
        } else {
            _t31 =  *( &WTF_WIDTH_MAP + ( *s & 0xff)) & 0xff;
        }
        width = _t31;
        if(i + width <= n) {
            len = wtf_len(s);
            addmch(s, len);
            s =  &(s[len]);
            i = i + width;
            continue;
        }
        return;
    }
}

void addnstr_sup(char* s, int n)
{// addr = 0x0809DF98  --  defined in 'terms.c' at line 1714
    int i;                                 // _cfa_fffffff0
    int len;                               // _cfa_ffffffec
    int width;                             // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t35;                              // _t35

    i = 0;
    while(( *s & 255) != 0) {
        if(( *135119023 & 255) == 0) {
            _t35 = ( *( &WTF_WIDTH_MAP + ( *s & 0xff)) & 255) != 0 & 255;
        } else {
            _t35 =  *( &WTF_WIDTH_MAP + ( *s & 0xff)) & 0xff;
        }
        width = _t35;
        if(i + width <= n) {
            len = wtf_len(s);
            addmch(s, len);
            s =  &(s[len]);
            i = i + width;
            continue;
        } else {
L10:
            while(i < n) {
                addch(32);
                i = i + 1;
            }
            return;
        }
        goto L10;
    }
    goto L10;
}

void crmode()
{// addr = 0x0809E049  --  defined in 'terms.c' at line 1738
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    ttymode_reset(2, 1024);
    ttymode_set(1, 0);
    set_cc(6, 1);
}

void nocrmode()
{// addr = 0x0809E08D  --  defined in 'terms.c' at line 1756
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    ttymode_set(2, 0);
    set_cc(6, 4);
}

void term_echo()
{// addr = 0x0809E0BD  --  defined in 'terms.c' at line 1773
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    ttymode_set(8, 0);
}

void term_noecho()
{// addr = 0x0809E0D9  --  defined in 'terms.c' at line 1779
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    ttymode_reset(8, 0);
}

void term_raw()
{// addr = 0x0809E0F5  --  defined in 'terms.c' at line 1785
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    ttymode_reset(32779, 5120);
    set_cc(6, 1);
}

void term_cooked()
{// addr = 0x0809E125  --  defined in 'terms.c' at line 1807
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    ttymode_set(32779, 0);
    set_cc(6, 4);
}

void term_cbreak()
{// addr = 0x0809E155  --  defined in 'terms.c' at line 1831
    term_cooked();
    term_noecho();
}

void term_title(char* s)
{// addr = 0x0809E167  --  defined in 'terms.c' at line 1838
    char* _v20;                            // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8

    if((fmInitialized & 255) != 0) {
        if(title_str != 0) {
            _v20 = s;
            _v24 = title_str;
             *__esp = ttyf;
            fprintf();
            return;
        }
    }
}

char getch()
{// addr = 0x0809E1A5  --  defined in 'terms.c' at line 1859
    char c;                                // _cfa_fffffff3
    intOrPtr _v36;                         // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    int _t5;                               // _t5
    intOrPtr* _t6;                         // _t6

    while(1) {
        _t5 = tty;
        _v36 = 1;
        _v40 =  &c;
         *__esp = _t5;
        read();
        if(_t5 > 0) {
            break;
        }
        __errno_location();
        _t6 =  *_t5;
        if(_t6 == 4) {
            continue;
        } else {
            __errno_location();
            if( *_t6 == 11) {
                continue;
            } else {
                quitfm();
            }
        }
        break;
    }
    return c & 255;
}

char wgetch(_Unknown_base* p)
{// addr = 0x0809E1F6  --  defined in 'terms.c' at line 1882
    char c;                                // _cfa_fffffff3
    intOrPtr _v36;                         // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    int _t5;                               // _t5
    intOrPtr* _t6;                         // _t6

    while(1) {
        _t5 = tty;
        _v36 = 1;
        _v40 =  &c;
         *__esp = _t5;
        read();
        if(_t5 > 0) {
            break;
        }
        __errno_location();
        _t6 =  *_t5;
        if(_t6 == 4) {
            continue;
        } else {
            __errno_location();
            if( *_t6 == 11) {
                continue;
            } else {
                quitfm();
            }
        }
        break;
    }
    return c & 255;
}

int do_getch()
{// addr = 0x0809E247  --  defined in 'terms.c' at line 1898
    int _t1;                               // _t1

    _t1 = is_xterm;
    if(_t1 == 0) {
         *__esp = 0;
        Gpm_Wgetch();
        return _t1;
    }
    return getch();
}

void bell()
{// addr = 0x0809E26E  --  defined in 'terms.c' at line 1959
    write1(7);
}

void skip_escseq()
{// addr = 0x0809E282  --  defined in 'terms.c' at line 1965
    int c;                                 // _cfa_fffffff0

    c = getch();
    if(c == 91 || c == 79) {
        c = getch();
        if(is_xterm == 0) {
L8:
            while(( *( &MYCTYPE_MAP + (c & 255)) & 8) != 0) {
                c = getch();
            }
            goto L9;
        }
        if(c != 77) {
            goto L8;
        }
        getch();
        getch();
        getch();
        return;
    } else {
L9:
        return;
    }
}

int sleep_till_anykey(int sec, int purge)
{// addr = 0x0809E2F4  --  defined in 'terms.c' at line 1986
    signed int _v32;                       // _cfa_ffffffe0
    TerminalMode ioval;   // _cfa_ffffffa4
    int er;                                // _cfa_ffffffa0
    int c;                                 // _cfa_ffffff9c
    int ret;                               // _cfa_ffffff98
    int __d0;                              // _cfa_ffffff94
    int __d1;                              // _cfa_ffffff90
    _unknown_ _v116;                       // _cfa_ffffff8c
    struct timeval tim;   // _cfa_ffffff88
    fd_set rfd;         // _cfa_ffffff08
    long int* _v268;                       // _cfa_fffffef4
    int _v272;                             // _cfa_fffffef0
    struct termios* _v276;   // _cfa_fffffeec
    int _v280;                             // _cfa_fffffee8
    _unknown_ __edi;                       // r4
    int _t44;                              // _t44
    int _t56;                              // _t56
    int _t57;                              // _t57

    _v32 =  *gs:0x14];
    _v280 =  &ioval;
     *__esp = tty;
    tcgetattr();
    term_raw();
    tim.tv_sec = sec;
    tim.tv_usec = 0;
    asm("cld");
    _push(32 << 2);
    _push(0);
    _push( &rfd);
    memset();
    __esp =  &(__esp[3]);
    __d0 = 0;
    __d1 =  &rfd + 32;
    _t44 = tty;
    _t45 = _t44 < 0 ? _t44 + 31 : _t44;
    _t46 = (_t44 < 0 ? _t44 + 31 : _t44) >> 5;
     *(__ebp + ((_t44 < 0 ? _t44 + 31 : _t44) >> 5) * 4 - 244) = 1 << (tty + (tty >> 31 >> 27) & 31) - (tty >> 31 >> 27) |  *(__ebp + ((_t44 < 0 ? _t44 + 31 : _t44) >> 5) * 4 - 244);
    _v268 =  &(tim.tv_sec);
    _v272 = 0;
    _v276 = 0;
    _v280 =  &rfd;
     *__esp = tty + 1;
    select();
    ret =  &rfd;
    if(ret > 0 && purge != 0) {
        c = getch();
        if(c == 27) {
            skip_escseq();
        }
    }
    _t56 = tty;
    _v276 =  &ioval;
    _v280 = 0;
     *__esp = _t56;
    tcsetattr();
    er = _t56;
    if(er == -1) {
        __errno_location();
        _v280 =  *_t56;
         *__esp = "Error occured: errno=%d\n";
        printf();
        reset_exit(0);
    }
    _t57 = ret;
    if((_v32 ^  *gs:0x14]) == 0) {
        return _t57;
    } else {
        __stack_chk_fail();
        return _t57;
    }
}

void mouse_init()
{// addr = 0x0809E44F  --  defined in 'terms.c' at line 2027
    int r;                                 // _cfa_fffffff0
    short _v26;                            // _cfa_ffffffe6
    short _v28;                            // _cfa_ffffffe4
    short _v30;                            // _cfa_ffffffe2
    Gpm_Connect conn;   // _cfa_ffffffe0
    FILE* _v48;           // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8

    if(mouseActive == 0) {
        conn.eventMask = 65535;
        _v30 = 0;
        _v26 = 0;
        _v28 = 0;
        _v56 = 0;
         *__esp =  &conn;
        Gpm_Open();
        r =  &conn;
        if(r != -2) {
            if(r >= 0) {
                __imp__gpm_handler = gpm_process_mouse;
                is_xterm = 0;
            }
        } else {
            Gpm_Close();
            is_xterm = 3;
        }
        if(is_xterm != 0) {
            _v48 = ttyf;
            _v52 = 16;
            _v56 = 1;
             *__esp = 135065349;
            fwrite();
            flush_tty();
        }
        mouseActive = 1;
        return;
    }
}

void mouse_end()
{// addr = 0x0809E505  --  defined in 'terms.c' at line 2063
    FILE* _v16;           // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8

    if(mouseActive != 0) {
        if(is_xterm == 0) {
            Gpm_Close();
        } else {
            _v16 = ttyf;
            _v20 = 16;
            _v24 = 1;
             *__esp = 135065366;
            fwrite();
            flush_tty();
        }
        mouseActive = 0;
        return;
    }
}

void mouse_active()
{// addr = 0x0809E55F  --  defined in 'terms.c' at line 2175
    if(mouseActive == 0) {
        mouse_init();
        return;
    }
}

void mouse_inactive()
{// addr = 0x0809E575  --  defined in 'terms.c' at line 2182
    if(mouseActive == 0 || is_xterm == 0) {
        return;
    } else {
        mouse_end();
        return;
    }
}

void flush_tty()
{// addr = 0x0809E594  --  defined in 'terms.c' at line 2191
    if(ttyf != 0) {
         *__esp = ttyf;
        fflush();
        return;
    }
}

void touch_cursor()
{// addr = 0x0809E5B2  --  defined in 'terms.c' at line 2199
    int i;                                 // _cfa_fffffff8

    touch_line();
    i = CurColumn;
    while(i >= 0) {
        touch_column(i);
        if(( *(ScreenImage[CurLine]->lineprop + i + i) & 0xc0) == 128) {
            i = i - 1;
            continue;
        }
L6:
        i = CurColumn + 1;
        while(i < COLS) {
            if(( *(ScreenImage[CurLine]->lineprop + i + i) & 0xc0) == 128) {
                touch_column(i);
                i = i + 1;
                continue;
            }
            return;
        }
        return;
    }
    goto L6;
}

struct table2* loadMimeTypes(char* filename)
{// addr = 0x0809E668  --  defined in 'url.c' at line 153
    FILE* f;              // _cfa_fffffff0
    char* d;                               // _cfa_ffffffec
    char* type;                            // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    int n;                                 // _cfa_ffffffe0
    Str tmp;               // _cfa_ffffffdc
    struct table2* mtypes;   // _cfa_ffffffd8
    struct table2* _v52;   // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    FILE* _t65;           // _t65
    char* _t75;                            // _t75
    struct table2* _t82;   // _t82
    char* _t92;                            // _t92

    _t65 = expandPath(filename);
    _v56 = 135065742;
     *__esp = _t65;
    fopen();
    f = _t65;
    if(f != 0) {
        n = 0;
        while(1) {
            tmp = Strfgets(f);
            if(tmp->length <= 0) {
                break;
            }
            d = tmp->ptr;
            if(( *d & 255) == 35) {
                continue;
            }
            _v56 = 135065744;
            _t75 = d;
             *__esp = _t75;
            strtok();
            d = _t75;
            if(d == 0) {
                continue;
            }
            _v56 = 135065744;
             *__esp = 0;
            strtok();
            d = 135065744;
            i = 0;
            while(d != 0) {
                _v56 = 135065744;
                 *__esp = 0;
                strtok();
                d = 135065744;
                i = i + 1;
            }
            n = n + i;
        }
        _v52 = 0;
        _v56 = 0;
         *__esp = f;
        fseek();
        _t82 = n + 1 << 3;
         *__esp = _t82;
        GC_malloc();
        mtypes = _t82;
        i = 0;
        while(1) {
            tmp = Strfgets(f);
            if(tmp->length <= 0) {
                break;
            }
            d = tmp->ptr;
            if(( *d & 255) == 35) {
                continue;
            }
            _v56 = 135065744;
            _t92 = d;
             *__esp = _t92;
            strtok();
            type = _t92;
            if(type == 0) {
                continue;
            } else {
                goto L13;
            }
            while(1) {
L13:
                _v56 = 135065744;
                 *__esp = 0;
                strtok();
                d = 135065744;
                if(d == 0) {
                    break;
                }
                mtypes[i].item1 =  *(Strnew_charp(d));
                 &(mtypes[i])->item2 =  *(Strnew_charp(type));
                i = i + 1;
            }
        }
        mtypes[i].item1 = 0;
         &(mtypes[i])->item2 = 0;
         *__esp = f;
        fclose();
        return mtypes;
    }
    return 0;
}

void initMimeTypes()
{// addr = 0x0809E854  --  defined in 'url.c' at line 203
    int i;                                 // _cfa_fffffff0
    TextListItem* tl;   // _cfa_ffffffec
    struct table2** _t19;   // _t19

    if(non_null(mimetypes_files) == 0) {
        mimetypes_list = 0;
    } else {
        mimetypes_list = make_domain_list(mimetypes_files);
    }
    if(mimetypes_list != 0) {
        _t19 = (mimetypes_list->nitem & 65535) << 2;
         *__esp = _t19;
        GC_malloc();
        UserMimeTypes = _t19;
        i = 0;
        tl = mimetypes_list->first;
        while(tl != 0) {
            UserMimeTypes[i] = loadMimeTypes(tl->ptr);
            i = i + 1;
            tl = tl->next;
        }
        return;
    }
}

char* DefaultFile(int scheme)
{// addr = 0x0809E8F9  --  defined in 'url.c' at line 220
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    int _t5;                               // _t5

    _t5 = scheme;
    if(_t5 == 1) {
        return allocStr(135065751, -1);
    }
    if(_t5 > 1) {
        if(_t5 > 5) {
L9:
            return 0;
        }
        return allocStr(135065749, -1);
    }
    if(_t5 == 0) {
        return allocStr(135065749, -1);
    }
    goto L9;
}

void KeyAbort(int _dummy)
{// addr = 0x0809E962  --  defined in 'url.c' at line 242
    intOrPtr _v0;                          // _cfa_0
    char _v17;                             // _cfa_ffffffef
    intOrPtr _v20;                         // _cfa_ffffffec
    char _v24;                             // _cfa_ffffffe8
    char _v28;                             // _cfa_ffffffe4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v64;                         // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc
    intOrPtr _t16;                         // _t16
    char _t17;                             // _t17
    _unknown_ _t22;                        // _t22

    _v24 = 1;
     *__esp =  &AbortLoading;
    siglongjmp();
    _push(_t22);
    __esp = __esp - 40;
    _t16 = _v20;
    _v68 = 135065742;
     *__esp = _t16;
    fopen();
    _v48 = _t16;
    if(_v48 != 0) {
        while(1) {
            _t17 = _v24;
             *__esp = _t17;
            fgetc();
            _v28 = _t17;
            if(_v28 == -1) {
                break;
            }
            _v17 = _v28;
            _v64 = 1;
            _v68 =  &_v17;
             *__esp = _v0;
            write();
        }
         *__esp = _v24;
        fclose();
        return;
    }
}

void write_from_file(int sock, char* file)
{// addr = 0x0809E97C  --  defined in 'url.c' at line 418
    char[0] buf;                           // _cfa_fffffff3
    FILE* fd;             // _cfa_ffffffec
    int c;                                 // _cfa_ffffffe8
    intOrPtr _v36;                         // _cfa_ffffffdc
    char[0]* _v40;                         // _cfa_ffffffd8
    FILE* _t15;           // _t15
    int _t16;                              // _t16

    _t15 = file;
    _v40 = 135065742;
     *__esp = _t15;
    fopen();
    fd = _t15;
    if(fd != 0) {
        while(1) {
            _t16 = fd;
             *__esp = _t16;
            fgetc();
            c = _t16;
            if(c == -1) {
                break;
            }
            buf = c;
            _v36 = 1;
            _v40 =  &buf;
             *__esp = sock;
            write();
        }
         *__esp = fd;
        fclose();
        return;
    }
}

ParsedURL* baseURL(Buffer* buf)
{// addr = 0x0809E9E2  --  defined in 'url.c' at line 434
    if((buf->bufferprop & 0x10) == 0) {
        if(buf->baseURL == 0) {
            return  &(buf->currentURL);
        }
        return buf->baseURL;
    }
    return 0;
}

int openSocket(const char* hostname, char* remoteport_name, short unsigned int remoteport_num)
{// addr = 0x0809EA1D  --  defined in 'url.c' at line 449
    _None sock;                            // _cfa_fffffff0
    int* af;                               // _cfa_ffffffec
    struct addrinfo* res0;   // _cfa_ffffffe8
    struct addrinfo* res;   // _cfa_ffffffe4
    int error;                             // _cfa_ffffffe0
    char* hname;                           // _cfa_ffffffdc
    _None prevtrap;                        // _cfa_ffffffd8
    Str portbuf;           // _cfa_ffffffd4
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    struct addrinfo hints;   // _cfa_ffffffb4
    signed short _v80;                     // _cfa_ffffffb0
    struct addrinfo** _v96;   // _cfa_ffffffa0
    int _v100;                             // _cfa_ffffff9c (outparam)
    int _v104;                             // _cfa_ffffff98 (outparam)
    _unknown_ __ebx;                       // r1
    char* _t101;                           // _t101
    int _t123;                             // _t123
    struct sockaddr* _t129;   // _t129
    int _t148;                             // _t148
    int _t153;                             // _t153
    char* _t156;                           // _t156
    char* _t163;                           // _t163
    char* _t166;                           // _t166
    char* _t167;                           // _t167

    _v80 = remoteport_num;
    sock = -1;
    prevtrap = 0;
    _t101 = fmInitialized & 255;
    if(_t101 != 0) {
        _t101 =  *(Sprintf("Opening socket..."));
        message(_t101, 0, 0);
        refresh();
    }
    _v104 = 1;
     *__esp =  &AbortLoading;
    __sigsetjmp();
    if(_t101 == 0) {
        if((TrapSignal & 255) != 0) {
            prevtrap = mySignal(2, KeyAbort);
            if((fmInitialized & 255) != 0) {
                term_cbreak();
            }
        }
        if(hostname == 0) {
            goto L49;
        }
        hname = hostname;
        if(hname == 0 || ( *hname & 255) != 91) {
L13:
            af =  &ai_family_order_table + (DNS_order + DNS_order + _t181 << 2);
            while(1) {
                _v100 = 32;
                _v104 = 0;
                 *__esp =  &(hints.ai_flags);
                memset();
                hints.ai_family =  *af;
                hints.ai_socktype = 1;
                if(_v80 == 0) {
                    error = -1;
                } else {
                    _v104 = _v80 & 65535;
                    portbuf = Sprintf("%d");
                    _t153 = hname;
                    _v96 =  &res0;
                    _v100 =  &(hints.ai_flags);
                    _v104 = portbuf->ptr;
                     *__esp = _t153;
                    getaddrinfo();
                    error = _t153;
                }
                if(error != 0 && remoteport_name != 0 && ( *remoteport_name & 255) != 0) {
                    _t148 = hname;
                    _v96 =  &res0;
                    _v100 =  &(hints.ai_flags);
                    _v104 = remoteport_name;
                     *__esp = _t148;
                    getaddrinfo();
                    error = _t148;
                }
                if(error == 0) {
                    goto L24;
                }
                if( *af != 0) {
L40:
                    af =  &(af[1]);
                    continue;
                }
                goto L49;
L24:
                sock = -1;
                res = res0;
                while(res != 0) {
                    _t123 = res->ai_family;
                    _v100 = res->ai_protocol;
                    _v104 = res->ai_socktype;
                     *__esp = _t123;
                    socket();
                    sock = _t123;
                    if(sock < 0) {
L29:
                        res = res->ai_next;
                        continue;
                    }
                    _t129 = res->ai_addr;
                    _v100 = res->ai_addrlen;
                    _v104 = _t129;
                     *__esp = sock;
                    connect();
                    if(_t129 >= 0) {
L33:
                        if(sock >= 0) {
                             *__esp = res0;
                            freeaddrinfo();
                            if((TrapSignal & 255) != 0) {
                                if((fmInitialized & 255) != 0) {
                                    term_raw();
                                }
                                if(prevtrap != 0) {
                                    mySignal(2, prevtrap);
                                }
                            }
                            return sock;
                        }
                         *__esp = res0;
                        freeaddrinfo();
                        if( *af != 0) {
                            goto L40;
                        }
                        goto L49;
                    }
                     *__esp = sock;
                    close();
                    sock = -1;
                    goto L29;
                }
                goto L33;
            }
        } else {
            _t156 = hname;
             *__esp = _t156;
            strlen();
            if((hname[_t156 - 1] & 255) != 93) {
                goto L13;
            }
            hname = allocStr( &(hostname[1]), -1);
            _t163 = hname;
             *__esp = _t163;
            strlen();
            hname[_t163 - 1] = 0;
            _v104 = "0123456789abcdefABCDEF:.";
            _t166 = hname;
             *__esp = _t166;
            strspn();
            _t167 = hname;
             *__esp = _t167;
            strlen();
            if(_t166 != _t167) {
                goto L49;
            }
            goto L13;
        }
    } else {
        if(sock >= 0) {
             *__esp = sock;
            close();
        }
L49:
        if((TrapSignal & 255) != 0) {
            if((fmInitialized & 255) != 0) {
                term_raw();
            }
            if(prevtrap != 0) {
                mySignal(2, prevtrap);
            }
        }
        return -1;
    }
}

char* copyPath(char* orgpath, int length, int option)
{// addr = 0x0809ED8B  --  defined in 'url.c' at line 640
    Str tmp;               // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t65;                              // _t65
    int _t72;                              // _t72
    int _t80;                              // _t80

    tmp = Strnew();
    while(( *orgpath & 255) != 0 && length != 0) {
        if(( *( &MYCTYPE_MAP + ( *orgpath & 0xff)) & 2) == 0) {
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t65 = tmp->length;
             *((char*)(tmp->ptr + _t65)) =  *orgpath & 255;
            tmp->length = _t65 + 1;
             *((char*)(tmp->ptr + tmp->length)) = 0;
        } else {
            _t72 = option;
            if(_t72 != 1) {
                if(_t72 == 2) {
                    Strcat_charp(tmp, "%20");
                } else {
                    if(_t72 == 0) {
                        if(tmp->length + 1 >= tmp->area_size) {
                            Strgrow(tmp);
                        }
                        _t80 = tmp->length;
                         *((char*)(tmp->ptr + _t80)) =  *orgpath & 255;
                        tmp->length = _t80 + 1;
                         *((char*)(tmp->ptr + tmp->length)) = 0;
                    }
                }
            }
        }
        orgpath =  &(orgpath[1]);
        length = length - 1;
    }
    return tmp->ptr;
}

void parseURL(char* url, ParsedURL* p_url, ParsedURL* current)
{// addr = 0x0809EEAF  --  defined in 'url.c' at line 666
    char* p;                               // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    Str tmp;               // _cfa_ffffffe8
    char* cgi;                             // _cfa_ffffffe4
    int _v36;                              // _cfa_ffffffdc (outparam)
    signed int _v40;                       // _cfa_ffffffd8 (outparam)
    char* _t391;                           // _t391
    char* _t441;                           // _t441
    char* _t490;                           // _t490
    signed int _t512;                      // _t512
    int _t531;                             // _t531
    signed int _t545;                      // _t545
    signed int _t566;                      // _t566
    signed int _t592;                      // _t592
    char* _t605;                           // _t605
    int _t643;                             // _t643

    url = url_quote(url);
    p = url;
    p_url->scheme = 254;
    p_url->port = 0;
    p_url->user = 0;
    p_url->pass = 0;
    p_url->host = 0;
    p_url->is_nocache = 0;
    p_url->file = 0;
    p_url->real_file = 0;
    p_url->query = 0;
    p_url->label = 0;
    if(( *url & 255) == 0 || ( *url & 255) == 35) {
        if(current != 0) {
            copyParsedURL(p_url, current);
        }
L122:
        if(p_url->scheme != 254) {
            if(( *p & 255) != 35) {
                p_url->label = 0;
                return;
            }
            p_url->label = allocStr( &(p[1]), -1);
            return;
        }
        p_url->scheme = 4;
        p_url->file = allocStr(p, -1);
        p_url->label = 0;
        return;
    } else {
        p_url->scheme = getURLScheme( &p);
        if(p_url->scheme != 254) {
            if(p_url->scheme == 255) {
                p_url->file = allocStr(url, -1);
                return;
            }
            if(( *p & 255) != 47 || (p[1] & 255) != 47) {
                p_url->host = 0;
                if(p_url->scheme == 255) {
                    p_url->port = 0;
                } else {
                    p_url->port =  *( &DefaultPort + p_url->scheme * 4);
                }
                goto L59;
            } else {
                if(p_url->scheme != 4) {
L23:
                    p =  &(p[2]);
                    goto L24;
                }
                if((p[2] & 255) == 47 || (p[2] & 255) == 126) {
                    p =  &(p[2]);
                    goto L59;
                } else {
                    goto L23;
                }
            }
        } else {
            if(current == 0) {
                p_url->scheme = 4;
            } else {
                if(current->scheme <= 10) {
                    goto __eax;
                }
                p_url->scheme = current->scheme;
            }
            p = url;
            _t605 = p;
            _v36 = 2;
            _v40 = "//";
             *__esp = _t605;
            strncmp();
            if(_t605 != 0) {
L59:
                if(p_url->scheme == 4 && p_url->user == 0 && p_url->host != 0 && (p_url & 255) != 0) {
                    _t490 = p_url->host;
                    _v40 = "localhost";
                     *__esp = _t490;
                    strcmp();
                    if(_t490 != 0) {
                        p_url->scheme = 2;
                        if(p_url->port == 0) {
                            p_url->port =  *135102632;
                        }
                    }
                }
                if(( *p & 255) == 0 || ( *p & 255) == 35 || ( *p & 255) == 63) {
                    if(p_url->host != 0) {
                        goto L71;
                    } else {
                        p_url->file = 135065832;
                        goto L115;
                    }
                } else {
L71:
                    q = p;
                    if(p_url->scheme == 1) {
                        if(( *q & 255) == 47) {
                            q =  &(q[1]);
                        }
                        if(( *q & 255) != 0 && ( *q & 255) != 47 && (q[1] & 255) != 47 && (q[2] & 255) == 47) {
                            q =  &(q[1]);
                        }
                    }
                    if(( *p & 255) == 47) {
                        p =  &(p[1]);
                    }
                    if(( *p & 255) == 0 || ( *p & 255) == 35 || ( *p & 255) == 63) {
                        p_url->file = DefaultFile(p_url->scheme);
                        goto L115;
                    } else {
                        if(p_url->scheme != 1 || ( *p & 255) != 82) {
                            _t391 = p;
                            _v40 = 63;
                             *__esp = _t391;
                            strchr();
                            cgi = _t391;
L99:
                            while(( *p & 255) == 0 || ( *p & 255) == 35 || p == cgi) {
                                if(( *p & 255) != 35 || p_url->scheme != 4) {
L111:
                                    if(p_url->scheme == 4 || p_url->scheme == 254) {
                                        p_url->file = copyPath(q, p - q, 0);
                                    } else {
                                        p_url->file = copyPath(q, p - q, 1);
                                    }
                                    goto L115;
                                } else {
                                    if(p <= q || ( *(p - 1) & 255) != 47 || cgi != 0 && p >= cgi) {
                                        if((p[1] & 255) == 0) {
                                            p =  &(p[1]);
                                        }
                                        goto L111;
                                    } else {
                                        p =  &(p[1]);
                                        continue;
                                    }
                                }
                            }
                            p =  &(p[1]);
                            goto L99;
                        } else {
                            p =  &(p[1]);
                            tmp = Strnew();
                            if(tmp->length + 1 >= tmp->area_size) {
                                Strgrow(tmp);
                            }
                            _t643 = tmp->length;
                            _t441 = p;
                             *((char*)(tmp->ptr + _t643)) =  *_t441 & 255;
                            tmp->length = _t643 + 1;
                            p =  &(_t441[1]);
                             *((char*)(tmp->ptr + tmp->length)) = 0;
                            while(( *p & 255) != 0 && ( *p & 255) != 47) {
                                p =  &(p[1]);
                            }
                            Strcat_charp(tmp, p);
                            while(( *p & 255) != 0) {
                                p =  &(p[1]);
                            }
                            p_url->file = copyPath(tmp->ptr, -1, 1);
L115:
                            if(( *p & 255) != 63) {
                                goto L122;
                            }
                            p =  &(p[1]);
                            q = p;
                            while(( *p & 255) != 0 && ( *p & 255) != 35) {
                                p =  &(p[1]);
                            }
                            p_url->query = copyPath(q, p - q, 0);
                            goto L122;
                        }
                    }
                }
            } else {
                p =  &(p[2]);
                goto L24;
                do {
                    do {
L53:
                        if(( *p & 255) != 64) {
                            tmp = Strnew_charp_n(q, p - q);
                            _t531 = tmp->ptr;
                             *__esp = _t531;
                            atoi();
                            p_url->port = _t531;
                            goto L59;
                        } else {
                            p_url->pass = copyPath(q, p - q, 0);
                            p =  &(p[1]);
                            q = p;
                            p_url->user = p_url->host;
                            p_url->host = 0;
L24:
                            q = p;
                            if(( *q & 255) != 91) {
                                break;
                            } else {
                                p =  &(p[1]);
                                goto L27;
                            }
                        }
                    } while();
L38:
                    while(( *p & 255) != 0) {
                        _t566 =  *p & 255;
                        _v40 = _t566;
                         *__esp = ":/?#";
                        strchr();
                        if(_t566 == 0) {
                            p =  &(p[1]);
                            continue;
                        }
                        break;
                    }
                    _t512 =  *p & 255;
                    if(_t512 == 58) {
                        p_url->host = copyPath(q, p - q, 1);
                        p =  &(p[1]);
                        q = p;
                        while(( *p & 255) != 0) {
                            _t545 =  *p & 255;
                            _v40 = _t545;
                             *__esp = "/?#";
                            strchr();
                            if(_t545 == 0) {
                                p =  &(p[1]);
                                continue;
                            }
                            goto L53;
                        }
                        goto L53;
                    }
                    if(_t512 > 58) {
                        if(_t512 == 63) {
L57:
                            p_url->host = copyPath(q, p - q, 1);
                            p_url->port =  *( &DefaultPort + p_url->scheme * 4);
                            goto L59;
                        }
                        goto L47;
                    }
                    if(_t512 == 35 || _t512 == 47 || _t512 == 0) {
                        goto L57;
                    } else {
                        goto L59;
                    }
                    do {
L27:
                    } while(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 0x28) != 0 || ( *p & 255) == 58 || ( *p & 255) == 46);
                    if(( *p & 255) != 93) {
L33:
                        p = q;
                        goto L38;
                    }
                    if((p[1] & 255) == 0) {
                        goto L38;
                    }
                    _t592 = p[1] & 255;
                    _v40 = _t592;
                     *__esp = ":/?#";
                    strchr();
                    if(_t592 != 0) {
                        goto L38;
                    }
                    goto L33;
L47:
                } while(_t512 == 64);
                goto L59;
            }
        }
    }
}

void copyParsedURL(ParsedURL* p, ParsedURL* q)
{// addr = 0x0809F763  --  defined in 'url.c' at line 960
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    char* _t68;                            // _t68
    char* _t71;                            // _t71
    char* _t74;                            // _t74
    char* _t77;                            // _t77
    char* _t80;                            // _t80
    char* _t83;                            // _t83
    char* _t86;                            // _t86

    p->scheme = q->scheme;
    p->port = q->port;
    p->is_nocache = q->is_nocache;
    if(q->user == 0) {
        _t68 = 0;
    } else {
        _t68 = allocStr(q->user, -1);
    }
    p->user = _t68;
    if(q->pass == 0) {
        _t71 = 0;
    } else {
        _t71 = allocStr(q->pass, -1);
    }
    p->pass = _t71;
    if(q->host == 0) {
        _t74 = 0;
    } else {
        _t74 = allocStr(q->host, -1);
    }
    p->host = _t74;
    if(q->file == 0) {
        _t77 = 0;
    } else {
        _t77 = allocStr(q->file, -1);
    }
    p->file = _t77;
    if(q->real_file == 0) {
        _t80 = 0;
    } else {
        _t80 = allocStr(q->real_file, -1);
    }
    p->real_file = _t80;
    if(q->label == 0) {
        _t83 = 0;
    } else {
        _t83 = allocStr(q->label, -1);
    }
    p->label = _t83;
    if(q->query == 0) {
        _t86 = 0;
    } else {
        _t86 = allocStr(q->query, -1);
    }
    p->query = _t86;
}

void parseURL2(char* url, ParsedURL* pu, ParsedURL* current)
{// addr = 0x0809F8C8  --  defined in 'url.c' at line 975
    char* p;                               // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    int relative_uri;                      // _cfa_ffffffe8
    char* q;                               // _cfa_ffffffe4
    char* _v36;                            // _cfa_ffffffdc (outparam)
    char _v40;                             // _cfa_ffffffd8 (outparam)
    char* _t238;                           // _t238
    char* _t240;                           // _t240
    char* _t243;                           // _t243
    char* _t267;                           // _t267
    char* _t269;                           // _t269
    char* _t272;                           // _t272
    char* _t314;                           // _t314
    int _t325;                             // _t325
    char* _t410;                           // _t410
    char* _t412;                           // _t412
    char* _t418;                           // _t418

    relative_uri = 0;
    parseURL(url, pu, current);
    if(pu->scheme == 11) {
        return;
    }
    if(pu->scheme == 9 || pu->scheme == 10) {
        if(pu->file == 0) {
L9:
            pu->scheme = 9;
            return;
        }
        _t238 = pu->file;
        _v40 = 64;
         *__esp = _t238;
        strchr();
        if(_t238 != 0) {
            goto L9;
        }
        _t240 = pu->file;
        _v40 = 47;
         *__esp = _t240;
        strchr();
        p = _t240;
        if(p == 0) {
L8:
            pu->scheme = 10;
            return;
        }
        _t243 =  &(p[1]);
        _v40 = 45;
         *__esp = _t243;
        strchr();
        if(_t243 != 0 || (p[1] & 255) == 0) {
            goto L8;
        } else {
            goto L9;
        }
    } else {
        if(pu->scheme == 7) {
L12:
            if(pu->file != 0) {
                if((pu & 255) == 47) {
                    pu->file = allocStr( &(pu->file[1]), -1);
                }
            }
            if(pu->file == 0) {
L21:
                pu->scheme = 7;
L22:
                if(current == 0) {
                    return;
                }
                if(current->scheme == 7 || current->scheme == 8) {
                    if(pu->host == 0) {
                        pu->host = current->host;
                        pu->port = current->port;
                        return;
                    }
L85:
                    return;
                } else {
                    return;
                }
            }
            _t267 = pu->file;
            _v40 = 64;
             *__esp = _t267;
            strchr();
            if(_t267 != 0) {
                goto L21;
            }
            _t269 = pu->file;
            _v40 = 47;
             *__esp = _t269;
            strchr();
            p = _t269;
            if(p == 0) {
L20:
                pu->scheme = 8;
                goto L22;
            }
            _t272 =  &(p[1]);
            _v40 = 45;
             *__esp = _t272;
            strchr();
            if(_t272 != 0 || (p[1] & 255) == 0) {
                goto L20;
            } else {
                goto L21;
            }
        }
        if(pu->scheme != 8) {
            if(pu->scheme == 4) {
                q = expandName(file_unquote(pu->file));
                pu->file = file_quote(q);
            }
            if(current == 0 || pu->scheme != current->scheme && (pu->scheme != 2 || current->scheme != 3) && (pu->scheme != 4 || current->scheme != 5) || pu->host != 0) {
L63:
                if(pu->file == 0) {
                    goto L85;
                }
                if(pu->scheme != 4 || (pu & 255) == 47) {
L73:
                    if(pu->scheme != 0) {
                        if(pu->scheme != 1 && (pu & 255) == 47) {
                            pu->file = cleanupName(pu->file);
                        }
                    } else {
                        if(relative_uri != 0) {
                            pu->file = cleanupName(pu->file);
                        }
                    }
                    goto L79;
                } else {
                    _t314 = pu->file;
                    _v40 = 135065886;
                     *__esp = _t314;
                    strcmp();
                    if(_t314 == 0) {
                        goto L73;
                    }
                    tmp = Strnew_charp(CurrentDir);
                    if(tmp->length <= 0 || ( *(tmp->ptr + tmp->length - 1) & 255) != 47) {
                        if(tmp->length + 1 >= tmp->area_size) {
                            Strgrow(tmp);
                        }
                        _t325 = tmp->length;
                         *((char*)(tmp->ptr + _t325)) = 47;
                        tmp->length = _t325 + 1;
                         *((char*)(tmp->ptr + tmp->length)) = 0;
                    }
                    Strcat_charp(tmp, file_unquote(pu->file));
                    pu->file = file_quote(cleanupName(tmp->ptr));
L79:
                    if(pu->scheme != 4) {
                        goto L85;
                    }
                    pu->real_file = cleanupName(file_unquote(pu->file));
                    return;
                }
            } else {
                pu->user = current->user;
                pu->pass = current->pass;
                pu->host = current->host;
                pu->port = current->port;
                if(pu->file == 0 || (pu & 255) == 0) {
                    pu->file = current->file;
                    if(pu->query == 0) {
                        pu->query = current->query;
                    }
                    goto L63;
                } else {
                    if(pu->scheme != 255) {
L43:
                        if(pu->scheme == 1 || (pu & 255) == 47) {
                            if(pu->scheme == 1) {
                                if((pu & 255) == 47) {
                                    p = pu->file;
                                    pu->file = allocStr( &(p[1]), -1);
                                }
                            }
                            goto L63;
                        } else {
                            p = pu->file;
                            if(current->file == 0) {
L54:
L58:
                                goto L63;
                            } else {
                                tmp = Strnew_charp(current->file);
                                while(tmp->length > 0) {
                                    if(tmp->length <= 0 || ( *(tmp->ptr + tmp->length - 1) & 255) != 47) {
                                        Strshrink(tmp, 1);
                                        continue;
                                    } else {
                                        break;
                                    }
                                }
                                Strcat_charp(tmp, p);
                                pu->file = tmp->ptr;
                                relative_uri = 1;
                                goto L54;
                            }
                        }
                    }
                    _t410 = pu->file;
                    _v40 = 58;
                     *__esp = _t410;
                    strchr();
                    if(_t410 != 0 || current == 0) {
                        goto L43;
                    } else {
                        _t412 = current->file;
                        _v40 = 58;
                         *__esp = _t412;
                        strchr();
                        p = _t412;
                        if(p == 0) {
                            goto L43;
                        } else {
                            _t418 = allocStr(current->file, p - current->file);
                            _v36 = pu->file;
                            _v40 = _t418;
                            pu->file =  *(Sprintf(135065880));
                            goto L58;
                        }
                    }
                }
            }
        }
        goto L12;
    }
}

Str _parsedURL2Str(ParsedURL* pu, int pass)
{// addr = 0x0809FEC0  --  defined in 'url.c' at line 1158
    Str tmp;               // _cfa_fffffff0
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    int _t270;                             // _t270
    int _t302;                             // _t302
    int _t318;                             // _t318
    int _t336;                             // _t336
    int _t359;                             // _t359
    int _t382;                             // _t382
    int _t402;                             // _t402
    int _t417;                             // _t417
    char* _t436;                           // _t436
    int _t447;                             // _t447

    if(pu->scheme == 254) {
        return Strnew_charp(135065888);
    }
    if(pu->scheme == 255) {
        return Strnew_charp(pu->file);
    }
    if(pu->host != 0) {
L8:
        if(pu->scheme != 4) {
L15:
            tmp = Strnew_charp( *( &scheme_str + pu->scheme * 4));
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t270 = tmp->length;
             *((char*)(tmp->ptr + _t270)) = 58;
            tmp->length = _t270 + 1;
             *((char*)(tmp->ptr + tmp->length)) = 0;
            if(pu->scheme != 11) {
                if(pu->scheme != 9 && pu->scheme != 10) {
                    Strcat_charp(tmp, "//");
                }
                if(pu->user != 0) {
                    Strcat_charp(tmp, pu->user);
                    if(pass != 0 && pu->pass != 0) {
                        if(tmp->length + 1 >= tmp->area_size) {
                            Strgrow(tmp);
                        }
                        _t417 = tmp->length;
                         *((char*)(tmp->ptr + _t417)) = 58;
                        tmp->length = _t417 + 1;
                         *((char*)(tmp->ptr + tmp->length)) = 0;
                        Strcat_charp(tmp, pu->pass);
                    }
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t402 = tmp->length;
                     *((char*)(tmp->ptr + _t402)) = 64;
                    tmp->length = _t402 + 1;
                     *((char*)(tmp->ptr + tmp->length)) = 0;
                }
                if(pu->host != 0) {
                    Strcat_charp(tmp, pu->host);
                    if(pu->port !=  *((intOrPtr*)( &DefaultPort + pu->scheme * 4))) {
                        if(tmp->length + 1 >= tmp->area_size) {
                            Strgrow(tmp);
                        }
                        _t382 = tmp->length;
                         *((char*)(tmp->ptr + _t382)) = 58;
                        tmp->length = _t382 + 1;
                         *((char*)(tmp->ptr + tmp->length)) = 0;
                        _v40 = pu->port;
                        Strcat(tmp, Sprintf("%d"));
                    }
                }
                if(pu->scheme != 9 && pu->scheme != 10 && (pu->file == 0 || (pu & 255) != 47)) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t359 = tmp->length;
                     *((char*)(tmp->ptr + _t359)) = 47;
                    tmp->length = _t359 + 1;
                     *((char*)(tmp->ptr + tmp->length)) = 0;
                }
                Strcat_charp(tmp, pu->file);
                if(pu->scheme == 3 && (tmp->length <= 0 || ( *(tmp->ptr + tmp->length - 1) & 255) != 47)) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t336 = tmp->length;
                     *((char*)(tmp->ptr + _t336)) = 47;
                    tmp->length = _t336 + 1;
                     *((char*)(tmp->ptr + tmp->length)) = 0;
                }
                if(pu->query != 0) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t318 = tmp->length;
                     *((char*)(tmp->ptr + _t318)) = 63;
                    tmp->length = _t318 + 1;
                     *((char*)(tmp->ptr + tmp->length)) = 0;
                    Strcat_charp(tmp, pu->query);
                }
                if(pu->label != 0) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t302 = tmp->length;
                     *((char*)(tmp->ptr + _t302)) = 35;
                    tmp->length = _t302 + 1;
                     *((char*)(tmp->ptr + tmp->length)) = 0;
                    Strcat_charp(tmp, pu->label);
                }
                return tmp;
            } else {
                Strcat_charp(tmp, pu->file);
                return tmp;
            }
        }
        _t436 = pu->file;
        _v40 = 135065886;
         *__esp = _t436;
        strcmp();
        if(_t436 != 0) {
            goto L15;
        }
        tmp = Strnew_charp(135065886);
        if(pu->label == 0) {
L14:
            return tmp;
        }
        if(tmp->length + 1 >= tmp->area_size) {
            Strgrow(tmp);
        }
        _t447 = tmp->length;
         *((char*)(tmp->ptr + _t447)) = 35;
        tmp->length = _t447 + 1;
         *((char*)(tmp->ptr + tmp->length)) = 0;
        Strcat_charp(tmp, pu->label);
        goto L14;
    } else {
        if(pu->file != 0) {
            goto L8;
        } else {
            if(pu->label == 0) {
                goto L8;
            } else {
                _v40 = pu->label;
                return Sprintf(135065892);
            }
        }
    }
}

Str parsedURL2Str(ParsedURL* pu)
{// addr = 0x080A03FA  --  defined in 'url.c' at line 1251
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return _parsedURL2Str(pu, 0);
}

int getURLScheme(char** url)
{// addr = 0x080A0415  --  defined in 'url.c' at line 1257
    char* p;                               // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    int scheme;                            // _cfa_ffffffe4
    int len;                               // _cfa_ffffffe0
    int _v52;                              // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    int _t49;                              // _t49
    char* _t52;                            // _t52

    p =  *url;
    scheme = 254;
    while(( *p & 255) != 0) {
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 0xc) != 0 || ( *p & 255) == 46 || ( *p & 255) == 43 || ( *p & 255) == 45) {
            p =  &(p[1]);
            continue;
        } else {
            break;
        }
    }
    if(( *p & 255) != 58) {
L14:
        return scheme;
    } else {
        scheme = 255;
        i = 0;
        while(1) {
            q =  *( &schemetable + i * 8);
            if(q == 0) {
                goto L14;
            }
            _t49 = q;
             *__esp = _t49;
            strlen();
            len = _t49;
            _v52 = len;
            _v56 =  *url;
            _t52 = q;
             *__esp = _t52;
            strncasecmp();
            if(_t52 != 0 || (( *url)[len] & 255) != 58) {
                i = i + 1;
                continue;
            } else {
                scheme =  *(135102692 + i * 8);
                 *url =  &(p[1]);
                goto L14;
            }
        }
        goto L14;
    }
}

char* otherinfo(ParsedURL* target, ParsedURL* current, char* referer)
{// addr = 0x080A0505  --  defined in 'url.c' at line 1280
    Str s;                 // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc (outparam)
    int _v56;                              // _cfa_ffffffc8 (outparam)
    char* _t115;                           // _t115

    s = Strnew();
    Strcat_charp(s, "User-Agent: ");
    if(UserAgent == 0) {
L2:
        Strcat_charp(s, w3m_version);
L4:
        Strcat_charp(s, "\n");
        _v44 = 0;
        _v48 = "\n";
        _v52 = AcceptMedia;
        _v56 = "Accept: ";
        Strcat_m_charp(s);
        _v44 = 0;
        _v48 = "\n";
        _v52 = AcceptEncoding;
        _v56 = "Accept-Encoding: ";
        Strcat_m_charp(s);
        _v44 = 0;
        _v48 = "\n";
        _v52 = AcceptLang;
        _v56 = "Accept-Language: ";
        Strcat_m_charp(s);
        if(target->host != 0) {
            Strcat_charp(s, "Host: ");
            Strcat_charp(s, target->host);
            if(target->port !=  *((intOrPtr*)( &DefaultPort + target->scheme * 4))) {
                _v56 = target->port;
                Strcat(s, Sprintf(":%d"));
            }
            Strcat_charp(s, "\n");
        }
        if(target->is_nocache != 0 || (NoCache & 255) != 0) {
            Strcat_charp(s, "Pragma: no-cache\n");
            Strcat_charp(s, "Cache-control: no-cache\n");
        }
        if(NoSendReferer == 0) {
            if(referer != 0 || current == 0 || current->scheme == 4 || current->scheme == 2 && (current->user != 0 || current->pass != 0)) {
                if(referer != 0 && referer != -1) {
                    _v56 = 35;
                    _t115 = referer;
                     *__esp = _t115;
                    strchr();
                    p = _t115;
                    Strcat_charp(s, "Referer: ");
                    if(p == 0) {
                        Strcat_charp(s, referer);
                    } else {
                        Strcat_charp_n(s, referer, p - referer);
                    }
                    Strcat_charp(s, "\n");
                }
            } else {
                p = current->label;
                Strcat_charp(s, "Referer: ");
                current->label = 0;
                Strcat(s, parsedURL2Str(current));
                current->label = p;
                Strcat_charp(s, "\n");
            }
        }
        return s->ptr;
    }
    if(( *UserAgent & 255) != 0) {
        Strcat_charp(s, UserAgent);
        goto L4;
    }
    goto L2;
}

Str HTTPrequestMethod(HRequest* hr)
{// addr = 0x080A07EC  --  defined in 'url.c' at line 1331
    signed int _t4;                        // _t4

    _t4 = hr->command & 255;
    if(_t4 == 2) {
        return Strnew_charp("CONNECT");
    }
    if(_t4 == 3) {
        return Strnew_charp("HEAD");
    }
    if(_t4 == 1) {
        return Strnew_charp("POST");
    }
    return Strnew_charp("GET");
}

Str HTTPrequestURI(ParsedURL* pu, HRequest* hr)
{// addr = 0x080A0844  --  defined in 'url.c' at line 1350
    Str tmp;               // _cfa_fffffff0
    char* save_label;                      // _cfa_ffffffec
    int _v40;                              // _cfa_ffffffd8 (outparam)
    int _t80;                              // _t80

    tmp = Strnew();
    if((hr->command & 255) != 2) {
        if((hr->flag & 1) == 0) {
            save_label = pu->label;
            pu->label = 0;
            Strcat(tmp, _parsedURL2Str(pu, 1));
            pu->label = save_label;
        } else {
            Strcat_charp(tmp, pu->file);
            if(pu->query != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t80 = tmp->length;
                 *((char*)(tmp->ptr + _t80)) = 63;
                tmp->length = _t80 + 1;
                 *((char*)(tmp->ptr + tmp->length)) = 0;
                Strcat_charp(tmp, pu->query);
            }
        }
    } else {
        Strcat_charp(tmp, pu->host);
        _v40 = pu->port;
        Strcat(tmp, Sprintf(":%d"));
    }
    return tmp;
}

Str HTTPrequest(ParsedURL* pu, ParsedURL* current, HRequest* hr, TextList* extra)
{// addr = 0x080A0978  --  defined in 'url.c' at line 1374
    Str tmp;               // _cfa_fffffff0
    TextListItem* i;   // _cfa_ffffffec
    int seen_www_auth;                     // _cfa_ffffffe8
    int seen_proxy_auth;                   // _cfa_ffffffe4
    Str cookie;            // _cfa_ffffffe0
    intOrPtr _v52;                         // _cfa_ffffffcc (outparam)
    long unsigned int _v56;                // _cfa_ffffffc8 (outparam)
    _unknown_ _t184;                       // _t184
    char* _t186;                           // _t186

    seen_www_auth = 0;
    seen_proxy_auth = 0;
    tmp = HTTPrequestMethod(hr);
    Strcat_charp(tmp, 135066045);
    Strcat_charp(tmp,  *(HTTPrequestURI(pu, hr)));
    Strcat_charp(tmp, " HTTP/1.0\n");
    if(hr->referer != -1) {
        Strcat_charp(tmp, otherinfo(pu, current, hr->referer));
    } else {
        Strcat_charp(tmp, otherinfo(pu, 0, 0));
    }
    if(extra == 0) {
L11:
        if((hr->command & 255) != 2 && use_cookie != 0) {
            cookie = find_cookie(pu);
            if(cookie != 0) {
                Strcat_charp(tmp, "Cookie: ");
                Strcat(tmp, cookie);
                Strcat_charp(tmp, "\n");
                if((cookie & 255) != 36) {
                    Strcat_charp(tmp, "Cookie2: $Version="1"\n");
                }
            }
        }
        if((hr->command & 255) != 1) {
            if(header_string != 0) {
                Strcat(tmp, header_string);
            }
            Strcat_charp(tmp, "\n");
        } else {
            if(hr->request->enctype != 1) {
                if(override_content_type == 0) {
                    Strcat_charp(tmp, "Content-type: application/x-www-form-urlencoded\n");
                }
                _v56 = hr->request->length;
                Strcat(tmp, Sprintf("Content-length: %ld\n"));
                if(header_string != 0) {
                    Strcat(tmp, header_string);
                }
                Strcat_charp(tmp, "\n");
                Strcat_charp_n(tmp, hr->request->body, hr->request->length);
                Strcat_charp(tmp, "\n");
            } else {
                Strcat_charp(tmp, "Content-type: multipart/form-data; boundary=");
                Strcat_charp(tmp, hr->request->boundary);
                Strcat_charp(tmp, "\n");
                _v56 = hr->request->length;
                Strcat(tmp, Sprintf("Content-length: %ld\n"));
                Strcat_charp(tmp, "\n");
            }
        }
        return tmp;
    } else {
        i = extra->first;
        while(i != 0) {
            _t186 = i->ptr;
            _v52 = 20;
            _v56 = "Proxy-Authorization:";
             *__esp = _t186;
            strncasecmp();
            if(_t186 == 0) {
                seen_proxy_auth = 1;
            }
            Strcat_charp(tmp, i->ptr);
            i = i->next;
        }
        goto L11;
    }
}

void init_stream(URLFile* uf, int scheme, InputStream stream)
{// addr = 0x080A0CC5  --  defined in 'url.c' at line 1459
    intOrPtr _v20;                         // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8

    _v20 = 32;
    _v24 = 0;
     *__esp = uf;
    memset();
    uf->stream = stream;
    uf->scheme = scheme;
    uf->encoding = 0;
    uf->is_cgi = 0;
    uf->compression = 0;
    uf->content_encoding = 0;
    uf->guess_type = 0;
    uf->ext = 0;
    uf->modtime = -1;
}

URLFile openURL(char* url, ParsedURL* pu, ParsedURL* current, URLOption* option, FormList* request, TextList* extra_header, URLFile* ouf, HRequest* hr, unsigned char* status)
{// addr = 0x080A0D3B  --  defined in 'url.c' at line 1474
    Str tmp;               // _cfa_fffffff0
    int sock;                              // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe4
    char* q;                               // _cfa_ffffffe0
    FILE* ff;             // _cfa_ffffffd4
    int scheme;                            // _cfa_ffffffe8
    char* u;                               // _cfa_ffffffdc
    Str tmp2;              // _cfa_ffffffd8
    HRequest hr0;     // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    char* _v80;                            // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    URLFile uf;        // _cfa_ffffffa8
    _unknown_ _v100;                       // _cfa_ffffff9c (outparam)
    _unknown_ _v104;                       // _cfa_ffffff98 (outparam)
    struct  __ebx;            // r1
    _unknown_ __esi;                       // r5
    HRequest* _t175;   // _t175

    __ebx = url;
    if(status == 0) {
        status =  &hr0;
    }
    if(hr == 0) {
        init_stream( &uf, 254, 0);
    } else {
        _t175 = hr;
        uf.auto_detect =  *_t175;
        _v84 = _t175->referer;
        _v80 = _t175->request;
        _v76 =  *((intOrPtr*)(_t175 + 12));
        _v72 =  *((intOrPtr*)(_t175 + 16));
        _v68 =  *((intOrPtr*)(_t175 + 20));
        _v64 =  *((intOrPtr*)(_t175 + 24));
        _v60 =  *((intOrPtr*)(_t175 + 28));
    }
    u = pu;
    scheme = getURLScheme( &u);
    if(option != 0 || scheme != 254 || (ArgvIsURL & 255) != 0) {
        u = pu;
    } else {
        u = file_to_url(pu);
    }
    parseURL2(u, current, option);
    if(current->scheme != 4 || current->file != 0) {
L15:
        uf.auto_detect = current->scheme;
        _v64 =  *(parsedURL2Str(current));
        current->is_nocache = request->lastitem & 1;
        _v80 = filename_extension(current->file, 1);
         *status = 0;
        status[1] = 0;
        status[4] = request->item;
        status[8] = extra_header;
        if(current->scheme > 11) {
             *__ebx = uf.auto_detect;
             *(__ebx + 4) = _v84;
             *(__ebx + 8) = _v80;
             *((intOrPtr*)(__ebx + 12)) = _v76;
             *((intOrPtr*)(__ebx + 16)) = _v72;
             *((intOrPtr*)(__ebx + 20)) = _v68;
             *((intOrPtr*)(__ebx + 24)) = _v64;
             *((intOrPtr*)(__ebx + 28)) = _v60;
            goto L18;
        }
        goto __eax;
    } else {
        if(current->label == 0) {
             *__ebx = uf.auto_detect;
             *(__ebx + 4) = _v84;
             *(__ebx + 8) = _v80;
             *((intOrPtr*)(__ebx + 12)) = _v76;
             *((intOrPtr*)(__ebx + 16)) = _v72;
             *((intOrPtr*)(__ebx + 20)) = _v68;
             *((intOrPtr*)(__ebx + 24)) = _v64;
             *((intOrPtr*)(__ebx + 28)) = _v60;
L18:
            return __ebx;
        }
        tmp2 = Strnew_charp(135066246);
        Strcat_charp(tmp2, current->label);
        current->file = tmp2->ptr;
        current->real_file = cleanupName(file_unquote(current->file));
        current->label = 0;
        goto L15;
    }
}

void add_index_file(ParsedURL* pu, URLFile* uf)
{// addr = 0x080A1AD3  --  defined in 'url.c' at line 1807
    char* p;                               // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    union input_stream* _v32;   // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    char* _t29;                            // _t29

    if(index_file == 0 || ( *index_file & 255) == 0) {
        uf->stream = 0;
        return;
    }
    _t29 = file_quote(index_file);
    _v32 = 0;
    _v36 = _t29;
    _v40 = 135065749;
    p =  *(Strnew_m_charp(pu->file));
    p = cleanupName(p);
    q = cleanupName(file_unquote(p));
    examineFile(q, uf);
    if(uf->stream != 0) {
        pu->file = p;
        pu->real_file = q;
        return;
    }
}

char* guessContentTypeFromTable(struct table2* table, char* filename)
{// addr = 0x080A1B89  --  defined in 'url.c' at line 1827
    struct table2* t;   // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* _v40;                            // _cfa_ffffffd8
    char* _t34;                            // _t34
    char* _t44;                            // _t44
    char* _t52;                            // _t52

    if(table != 0) {
        _t34 = filename;
         *__esp = _t34;
        strlen();
        p =  &(filename[_t34 - 1]);
        while(filename < p && ( *p & 255) != 46) {
            p = p - 1;
        }
        if(p != filename) {
            p =  &(p[1]);
            t = table;
            while(t->item1 != 0) {
                _v40 = t->item1;
                _t44 = p;
                 *__esp = _t44;
                strcmp();
                if(_t44 != 0) {
                    t = t + 8;
                    continue;
                }
                return t->item2;
            }
            t = table;
            while(t->item1 != 0) {
                _v40 = t->item1;
                _t52 = p;
                 *__esp = _t52;
                strcasecmp();
                if(_t52 != 0) {
                    t = t + 8;
                    continue;
                }
                return t->item2;
            }
            return 0;
        }
        return 0;
    }
    return 0;
}

char* guessContentType(char* filename)
{// addr = 0x080A1C4F  --  defined in 'url.c' at line 1851
    char* ret;                             // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(filename != 0) {
        if(mimetypes_list == 0) {
L10:
            return guessContentTypeFromTable( &DefaultGuess, filename);
        }
        i = 0;
        while((mimetypes_list->nitem & 65535) > i) {
            ret = guessContentTypeFromTable(UserMimeTypes[i], filename);
            if(ret == 0) {
                i = i + 1;
                continue;
            }
            return ret;
        }
        goto L10;
    }
    return 0;
}

TextList* make_domain_list(char* domain_list)
{// addr = 0x080A1CCB  --  defined in 'url.c' at line 1872
    char* p;                               // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    TextList* domains;   // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    domains = 0;
    p = domain_list;
    tmp = Strnew_size(64);
    while(( *p & 255) != 0) {
        while(1) {
            p =  *p & 255;
            if(__al == 0) {
                break;
            }
            p =  *p & 255;
            __eax =  *( &MYCTYPE_MAP + __eax) & 255;
            __eax = __al & 255;
            if(__eax != 0) {
                p =  &(p[1]);
                continue;
            }
            break;
        }
        __eax = tmp;
        Strclear(tmp);
        while(1) {
            p =  *p & 255;
            if(__al == 0) {
                break;
            }
            p =  *p & 255;
            __eax =  *( &MYCTYPE_MAP + __eax) & 255;
            __eax = __al & 255;
            if(__eax != 0) {
                break;
            }
            p =  *p & 255;
            if(__al != 44) {
                __eax = tmp;
                __eax = tmp->length;
                __edx = tmp->length + 1;
                __eax = tmp;
                __eax = tmp->area_size;
                if(tmp->length + 1 >= tmp->area_size) {
                    __eax = tmp;
                    Strgrow(tmp);
                }
                __eax = tmp;
                __eax = tmp;
                __eax = tmp->length;
                __eax = p;
                 *((char*)(tmp->ptr + __eax)) = __dl;
                __edx = __eax + 1;
                __eax = tmp;
                tmp->length = __edx;
                p =  &(p[1]);
                __eax = tmp;
                __edx = tmp->ptr;
                __eax = tmp;
                __eax = tmp->length;
                __eax = tmp->ptr + tmp->length;
                 *(tmp->ptr + tmp->length) = 0;
                continue;
            }
            break;
        }
        __eax = tmp;
        __eax = tmp->length;
        if(tmp->length > 0) {
            if(domains == 0) {
                domains = newGeneralList();
            }
            tmp = tmp->ptr;
            __eax = allocStr(tmp->ptr, -1);
            __edx = domains;
            pushValue(domains, __eax);
        }
        while(1) {
            p =  *p & 255;
            if(__al == 0) {
                break;
            }
            p =  *p & 255;
            __eax =  *( &MYCTYPE_MAP + __eax) & 255;
            __eax = __al & 255;
            if(__eax != 0) {
                p =  &(p[1]);
                continue;
            }
            break;
        }
        p =  *p & 255;
        if(__al == 44) {
            p =  &(p[1]);
        }
    }
    return domains;
}

int domain_match(char* pat, char* domain)
{// addr = 0x080A1E39  --  defined in 'url.c' at line 1900
    char* _v24;                            // _cfa_ffffffe8
    char* _t17;                            // _t17
    char* _t18;                            // _t18

    if(domain != 0) {
        if(( *pat & 255) == 46) {
            pat =  &(pat[1]);
        }
        while(1) {
            _v24 = domain;
            _t17 = pat;
             *__esp = _t17;
            strcasecmp();
            if(_t17 == 0) {
                break;
            }
            _v24 = 46;
            _t18 = domain;
             *__esp = _t18;
            strchr();
            domain = _t18;
            if(domain != 0) {
                domain =  &(domain[1]);
                continue;
            }
            return 0;
        }
        return 1;
    }
    return 0;
}

int check_no_proxy(char* domain)
{// addr = 0x080A1EA2  --  defined in 'url.c' at line 1917
    signed int _v16;                       // _cfa_fffffff0
    char[63] addr;                         // _cfa_ffffffb0
    TextListItem* tl;   // _cfa_ffffffac
    _None ret;                             // _cfa_ffffffa8
    _None prevtrap;                        // _cfa_ffffffa4
    int error;                             // _cfa_ffffffa0
    struct addrinfo* res;   // _cfa_ffffff9c
    struct addrinfo* res0;   // _cfa_ffffff98
    int* af;                               // _cfa_ffffff94
    _unknown_ _v136;                       // _cfa_ffffff78
    struct addrinfo hints;   // _cfa_ffffff74
    char* _v144;                           // _cfa_ffffff70
    struct addrinfo** _v160;   // _cfa_ffffff60
    char[63]* _v164;                       // _cfa_ffffff5c
    char* _v168;                           // _cfa_ffffff58 (outparam)
    int _t83;                              // _t83
    int _t93;                              // _t93
    int _t104;                             // _t104
    int _t107;                             // _t107
    char* _t114;                           // _t114

    _v144 = domain;
    _v16 =  *gs:0x14];
    ret = 0;
    prevtrap = 0;
    if(NO_proxy_domains == 0 || (NO_proxy_domains->nitem & 65535) == 0 || _v144 == 0) {
        _t83 = 0;
L44:
        if((_v16 ^  *gs:0x14]) == 0) {
            return _t83;
        }
        __stack_chk_fail();
        return _t83;
    } else {
        tl = NO_proxy_domains->first;
        while(tl != 0) {
            if(domain_match(tl->ptr, _v144) == 0) {
                tl = tl->next;
                continue;
            } else {
                _t83 = 1;
                goto L44;
            }
        }
        _t93 = NOproxy_netaddr;
        if(_t93 != 0) {
            _v168 = 1;
             *__esp =  &AbortLoading;
            __sigsetjmp();
            if(_t93 == 0) {
                if((TrapSignal & 255) != 0) {
                    prevtrap = mySignal(2, KeyAbort);
                    if((fmInitialized & 255) != 0) {
                        term_cbreak();
                    }
                }
                af =  &ai_family_order_table + (DNS_order + DNS_order + _t141 << 2);
                while(1) {
                    _v164 = 32;
                    _v168 = 0;
                     *__esp =  &(hints.ai_flags);
                    memset();
                    hints.ai_family =  *af;
                    _t104 = _v144;
                    _v160 =  &res0;
                    _v164 =  &(hints.ai_flags);
                    _v168 = 0;
                     *__esp = _t104;
                    getaddrinfo();
                    error = _t104;
                    if(error == 0) {
                        goto L20;
                    }
                    if( *af != 0) {
L36:
                        af =  &(af[1]);
                        continue;
                    }
L38:
                    if((TrapSignal & 255) != 0) {
                        if((fmInitialized & 255) != 0) {
                            term_raw();
                        }
                        if(prevtrap != 0) {
                            mySignal(2, prevtrap);
                        }
                    }
                    _t83 = ret;
                    goto L44;
L20:
                    res = res0;
                    while(res != 0) {
                        _t107 = res->ai_family;
                        if(_t107 == 2) {
                            _v160 = 64;
                            _v164 =  &addr;
                            _v168 =  &(res->ai_addr->sa_data[2]);
                             *__esp = 2;
                            inet_ntop();
L26:
                            tl = NO_proxy_domains->first;
                            while(tl != 0) {
                                _t114 = tl->ptr;
                                 *__esp = _t114;
                                strlen();
                                _v164 = _t114;
                                _v168 =  &addr;
                                 *__esp = tl->ptr;
                                strncmp();
                                if( &addr != 0) {
                                    tl = tl->next;
                                    continue;
                                }
                                 *__esp = res0;
                                freeaddrinfo();
                                ret = 1;
                                goto L38;
                            }
L31:
                            res = res->ai_next;
                            continue;
                        }
                        if(_t107 == 10) {
                            _v160 = 64;
                            _v164 =  &addr;
                            _v168 =  &(res->ai_addr->sa_data[6]);
                             *__esp = 10;
                            inet_ntop();
                            goto L26;
                        }
                        goto L31;
                    }
                     *__esp = res0;
                    freeaddrinfo();
                    if( *af == 0) {
                        goto L38;
                    }
                    goto L36;
                }
            }
            ret = 0;
            goto L38;
        }
        _t83 = 0;
        goto L44;
    }
}

char* filename_extension(char* path, int is_url)
{// addr = 0x080A2170  --  defined in 'url.c' at line 2022
    char* last_dot;                        // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    last_dot = 135065832;
    p = path;
    if(path == 0) {
        return last_dot;
    }
    if(( *p & 255) == 46) {
        p =  &(p[1]);
    }
    while(( *p & 255) != 0) {
        if(( *p & 255) != 46) {
            if(is_url == 0 || ( *p & 255) != 63) {
L8:
                p =  &(p[1]);
                continue;
            } else {
L13:
                if(( *last_dot & 255) != 46) {
                    return last_dot;
                }
                i = 1;
                while((last_dot[i] & 255) != 0) {
                    if(i <= 7) {
                        if(is_url == 0 || ( *( &MYCTYPE_MAP + (last_dot[i] & 0xff)) & 0xc) != 0) {
                            i = i + 1;
                            continue;
                        } else {
                            break;
                        }
                    }
                    break;
                }
                return allocStr(last_dot, i);
            }
        }
        last_dot = p;
        goto L8;
    }
    goto L13;
}

struct table2* loadURIMethods(char* filename)
{// addr = 0x080A2240  --  defined in 'url.c' at line 2057
    FILE* f;              // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int n;                                 // _cfa_ffffffe8
    Str tmp;               // _cfa_ffffffe4
    struct table2* um;   // _cfa_ffffffe0
    char* up;                              // _cfa_ffffffdc
    char* p;                               // _cfa_ffffffd8
    struct table2* _v52;   // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    FILE* _t71;           // _t71
    struct table2* _t83;   // _t83

    _t71 = expandPath(filename);
    _v56 = 135065742;
     *__esp = _t71;
    fopen();
    f = _t71;
    if(f != 0) {
        i = 0;
        while(1) {
            tmp = Strfgets(f);
            if(tmp->length <= 0) {
                break;
            }
            if(( *(tmp->ptr) & 255) != 35) {
                i = i + 1;
            }
        }
        _v52 = 0;
        _v56 = 0;
         *__esp = f;
        fseek();
        n = i;
        _t83 = n + 1 << 3;
         *__esp = _t83;
        GC_malloc();
        um = _t83;
        i = 0;
        while(1) {
            tmp = Strfgets(f);
            if(tmp->length <= 0) {
                break;
            }
            if(( *(tmp->ptr) & 255) != 35) {
                while(1) {
                    tmp = tmp->length;
                    if(tmp->length <= 0) {
                        __eax = 0;
                    } else {
                        tmp = tmp;
                        tmp->length = tmp->length - 1;
                        tmp->ptr + tmp->length - 1 =  *(tmp->ptr + tmp->length - 1) & 255;
                        __eax = __al & 255;
                    }
                    __eax = __eax[ &MYCTYPE_MAP] & 255;
                    __eax = __al & 255;
                    if(__eax == 0) {
                        break;
                    }
                    _v56 = 1;
                    __eax = tmp;
                     *__esp = tmp;
                    Strshrink();
                }
                tmp = tmp->ptr;
                p = tmp->ptr;
                __eax = p;
                up = p;
                while(1) {
                    p =  *p & 255;
                    if(__al == 0) {
                        break;
                    }
                    p =  *p & 255;
                    if(__al != 58) {
                        p =  &(p[1]);
                        continue;
                    }
                    i = i << 3;
                    up = p - up;
                    _v56 = p - up;
                    __eax = up;
                     *__esp = up;
                    __eax = Strnew_charp_n();
                    um[i].item1 = __eax;
                    p =  &(p[1]);
                    break;
                }
                p =  *p & 255;
                if(__al != 0) {
                    while(1) {
                        p =  *p & 255;
                        if(__al == 0) {
                            break;
                        }
                        p =  *p & 255;
                        __eax = __eax[ &MYCTYPE_MAP] & 255;
                        __eax = __al & 255;
                        if(__eax != 0) {
                            p =  &(p[1]);
                            continue;
                        }
                        break;
                    }
                    i = i << 3;
                    __eax = p;
                    __eax = Strnew_charp(p);
                     &(um[i])->item2 = __eax;
                    i = i + 1;
                    continue;
                }
                continue;
            }
        }
        um[i].item1 = 0;
         &(um[i])->item2 = 0;
         *__esp = f;
        fclose();
        return um;
    }
    return 0;
}

void initURIMethods()
{// addr = 0x080A2445  --  defined in 'url.c' at line 2103
    TextList* methodmap_list;   // _cfa_fffffff0
    TextListItem* tl;   // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    struct table2** _t26;   // _t26

    methodmap_list = 0;
    if(non_null(urimethodmap_files) != 0) {
        methodmap_list = make_domain_list(urimethodmap_files);
    }
    if(methodmap_list != 0) {
        _t26 = (methodmap_list->nitem & 65535) + 1 << 2;
         *__esp = _t26;
        GC_malloc();
        urimethods = _t26;
        i = 0;
        tl = methodmap_list->first;
        while(tl != 0) {
            urimethods[i] = loadURIMethods(tl->ptr);
            if(urimethods[i] != 0) {
                i = i + 1;
            }
            tl = tl->next;
        }
        urimethods[i] = 0;
        return;
    }
}

Str searchURIMethods(ParsedURL* pu)
{// addr = 0x080A2509  --  defined in 'url.c' at line 2123
    struct table2* ump;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    Str scheme;            // _cfa_ffffffe8
    Str url;               // _cfa_ffffffe4
    char* p;                               // _cfa_ffffffe0
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    char* _t67;                            // _t67

    scheme = 0;
    if(pu->scheme == 255) {
        if(urimethods != 0) {
            url = parsedURL2Str(pu);
            p = url->ptr;
            while(( *p & 255) != 0) {
                if(( *p & 255) != 58) {
                    p =  &(p[1]);
                    continue;
                }
                scheme = Strnew_charp_n(url->ptr, p - url->ptr);
                break;
            }
            if(scheme != 0) {
                i = 0;
                while(1) {
                    ump = urimethods[i];
                    if(ump == 0) {
                        break;
                    }
                    while(1) {
                        ump = ump->item1;
                        if(ump->item1 == 0) {
                            break;
                        }
                        scheme = ump;
                        __eax = ump->item1;
                        _v56 = scheme->ptr;
                         *__esp = __eax;
                        strcasecmp();
                        if(__eax != 0) {
                            ump = ump + 8;
                            continue;
                        }
                        url = url->ptr;
                        _v56 = url_quote(url->ptr);
                        return Sprintf(ump->item2);
                    }
                    i = i + 1;
                }
                ump =  &default_urimethods;
                while(ump->item1 != 0) {
                    _t67 = ump->item1;
                    _v56 = scheme->ptr;
                     *__esp = _t67;
                    strcasecmp();
                    if(_t67 != 0) {
                        ump = ump + 8;
                        continue;
                    }
                    _v56 = url_quote(url->ptr);
                    return Sprintf(ump->item2);
                }
                return 0;
            }
            return 0;
        }
        return 0;
    }
    return 0;
}

void chkExternalURIBuffer(Buffer* buf)
{// addr = 0x080A266A  --  defined in 'url.c' at line 2180
    int i;                                 // _cfa_fffffff0
    struct table2* ump;   // _cfa_ffffffec
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8 (outparam)

    i = 0;
    while(1) {
        ump = urimethods[i];
        if(ump == 0) {
            break;
        }
        while(1) {
            ump = ump->item1;
            if(ump->item1 == 0) {
                break;
            }
            ump = ump->item1;
            _v36 = "([-;/?:&=+$,a-zA-Z0-9_.!~*'()]|%[0-9A-Fa-f][0-9A-Fa-f])*";
            _v40 = ump->item1;
            __eax = Sprintf(135065880);
            _v40 = __eax;
            __eax = buf;
             *__esp = buf;
            __eax = reAnchor();
            ump = ump + 8;
        }
        i = i + 1;
    }
    ump =  &default_urimethods;
    while(ump->item1 != 0) {
        _v36 = "([-;/?:&=+$,a-zA-Z0-9_.!~*'()]|%[0-9A-Fa-f][0-9A-Fa-f])*";
        _v40 = ump->item1;
        reAnchor(buf,  *(Sprintf(135065880)));
        ump = ump + 8;
    }
}

ParsedURL* schemeToProxy(int scheme)
{// addr = 0x080A2719  --  defined in 'url.c' at line 2197
    ParsedURL* pu;   // _cfa_fffffff8
    int _t7;                               // _t7

    pu = 0;
    _t7 = scheme;
    if(_t7 == 1) {
        pu =  &GOPHER_proxy_parsed;
    } else {
        if(_t7 == 2) {
            pu =  &FTP_proxy_parsed;
        } else {
            if(_t7 == 0) {
                pu =  &HTTP_proxy_parsed;
            }
        }
    }
    return pu;
}

void KeyAbort(int _dummy)
{// addr = 0x080A2758  --  defined in 'ftp.c' at line 45
    intOrPtr _v0;                          // _cfa_0
    struct _Str* _v20;    // _cfa_ffffffec
    int _v24;                              // _cfa_ffffffe8
    intOrPtr _v60;                         // _cfa_ffffffc4
    int _v64;                              // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    _unknown_ _t149;                       // _t149

    _v24 = 1;
     *__esp =  &AbortLoading;
    siglongjmp();
    _push(_t149);
    __esp = __esp - 40;
    if( *_v24 == 0) {
        return;
    }
    if(_dummy != 0) {
        if(_a8 == 0) {
            _v68 = _dummy;
            _v20 = Sprintf("%s\n");
        } else {
            _v64 = _a8;
            _v68 = _dummy;
            _v20 = Sprintf("%s %s\n");
        }
        _v60 =  *((intOrPtr*)(_v0 + 20));
        _v64 = _v20->length;
        _v68 = 1;
         *__esp =  *_v20;
        fwrite();
         *__esp =  *((intOrPtr*)(_v0 + 20));
        fflush();
    }
    if(_a12 != 0) {
         *_a12 = -1;
        _v20 = StrISgets( *(_v0 + 16));
        if(( *( &MYCTYPE_MAP + ( *( *_v20) & 0xff)) & 8) != 0 && ( *( &MYCTYPE_MAP + ( *( *_v20 + 1) & 0xff)) & 8) != 0 && ( *( &MYCTYPE_MAP + ( *( *_v20 + 2) & 0xff)) & 8) != 0 && ( *( *_v20 + 3) & 255) == 32) {
            _v64 = _a12;
            _v68 = "%d";
             *__esp =  *_v20;
            __isoc99_sscanf();
        }
        if(( *( *_v20 + 3) & 255) == 45) {
            while(1) {
L21:
                _v20 = StrISgets( *(_v0 + 16));
                if(( *( &MYCTYPE_MAP + ( *( *_v20) & 0xff)) & 8) == 0) {
                    break;
                }
                if(( *( &MYCTYPE_MAP + ( *( *_v20 + 1) & 0xff)) & 8) == 0) {
                    continue;
                }
                if(( *( &MYCTYPE_MAP + ( *( *_v20 + 2) & 0xff)) & 8) == 0) {
                    continue;
                }
                if(( *( *_v20 + 3) & 255) != 32) {
                    continue;
                }
                _v64 = _a12;
                _v68 = "%d";
                 *__esp =  *_v20;
                __isoc99_sscanf();
                return;
            }
            goto L21;
        }
        return;
    } else {
        return;
    }
}

Str ftp_command(FTP ftp, char* cmd, char* arg, int* status)
{// addr = 0x080A2772  --  defined in 'ftp.c' at line 52
    Str tmp;               // _cfa_fffffff0
    FILE* _v32;           // _cfa_ffffffe0
    int* _v36;                             // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8

    if(ftp->host == 0) {
        return 0;
    }
    if(cmd != 0) {
        if(arg == 0) {
            _v40 = cmd;
            tmp = Sprintf("%s\n");
        } else {
            _v36 = arg;
            _v40 = cmd;
            tmp = Sprintf("%s %s\n");
        }
        _v32 = ftp->wf;
        _v36 = tmp->length;
        _v40 = 1;
         *__esp = tmp->ptr;
        fwrite();
         *__esp = ftp->wf;
        fflush();
    }
    if(status != 0) {
         *status = -1;
        tmp = StrISgets(ftp->rf);
        if(( *( &MYCTYPE_MAP + (tmp & 0xff)) & 8) != 0 && ( *( &MYCTYPE_MAP + (tmp->ptr[1] & 0xff)) & 8) != 0 && ( *( &MYCTYPE_MAP + (tmp->ptr[2] & 0xff)) & 8) != 0 && (tmp->ptr[3] & 255) == 32) {
            _v36 = status;
            _v40 = "%d";
             *__esp = tmp->ptr;
            __isoc99_sscanf();
        }
        if((tmp->ptr[3] & 255) == 45) {
            while(1) {
L20:
                tmp = StrISgets(ftp->rf);
                if(( *( &MYCTYPE_MAP + (tmp & 0xff)) & 8) == 0) {
                    break;
                }
                if(( *( &MYCTYPE_MAP + (tmp->ptr[1] & 0xff)) & 8) == 0) {
                    continue;
                }
                if(( *( &MYCTYPE_MAP + (tmp->ptr[2] & 0xff)) & 8) == 0) {
                    continue;
                }
                if((tmp->ptr[3] & 255) != 32) {
                    continue;
                }
                _v36 = status;
                _v40 = "%d";
                 *__esp = tmp->ptr;
                __isoc99_sscanf();
                return tmp;
            }
            goto L20;
        } else {
            return tmp;
        }
    } else {
        return 0;
    }
}

void ftp_close(FTP ftp)
{// addr = 0x080A2972  --  defined in 'ftp.c' at line 97
    if(ftp->host != 0) {
        if(ftp->rf != 0) {
             *(ftp->rf + 20) =  *(ftp->rf + 20) & 0xef;
            ISclose(ftp->rf);
            ftp->rf = 0;
        }
        if(ftp->wf != 0) {
             *__esp = ftp->wf;
            fclose();
            ftp->wf = 0;
        }
        if(ftp->data != 0) {
             *__esp = ftp->data;
            fclose();
            ftp->data = 0;
        }
        ftp->host = 0;
        return;
    }
}

int ftp_login(FTP ftp)
{// addr = 0x080A2A10  --  defined in 'ftp.c' at line 119
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v28;                        // _cfa_ffffffe4
    struct sockaddr_in sockname;   // _cfa_ffffffe0
    int sock;                              // _cfa_ffffffdc
    int status;                            // _cfa_ffffffd8
    size_t n;           // _cfa_ffffffd4
    int socknamelen;                       // _cfa_ffffffd0
    struct hostent* sockent;   // _cfa_ffffffcc
    Str tmp;               // _cfa_ffffffc8
    struct _FTP* _v64;    // _cfa_ffffffc0
    int _v92;                              // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0 (outparam)
    signed int _v100;                      // _cfa_ffffff9c (outparam)
    char* _v104;                           // _cfa_ffffff98 (outparam)
    int _t102;                             // _t102
    FILE* _t106;          // _t106
    char* _t135;                           // _t135
    unsigned int _t137;                    // _t137
    int _t143;                             // _t143
    struct hostent* _t150;   // _t150
    signed int _t151;                      // _t151

    _v64 = ftp;
    _v16 =  *gs:0x14];
    sock = openSocket( *_v64, "ftp", 21);
    if(sock < 0) {
L27:
        ftp_close(_v64);
        _t102 = 0;
L28:
        if((_v16 ^  *gs:0x14]) == 0) {
            return _t102;
        }
        __stack_chk_fail();
        return _t102;
    }
    if(ftppass_hostnamegen != 0) {
        _t135 = _v64->user;
        _v104 = "anonymous";
         *__esp = _t135;
        strcmp();
        if(_t135 == 0) {
            _t137 = _v64->pass;
             *__esp = _t137;
            strlen();
            n = _t137;
            if(n != 0 && (_v64->pass[n - 1] & 255) == 64) {
                socknamelen = 16;
                _v100 =  &socknamelen;
                _v104 =  &(sockname.sin_family);
                _t143 = sock;
                 *__esp = _t143;
                getsockname();
                if(_t143 == 0) {
                    tmp = Strnew_charp(_v64->pass);
                    _v100 = sockname.sin_family.s_addr & 0xffff;
                    _v104 = 4;
                    _t150 =  &(sockname.sin_family) + 4;
                     *__esp = _t150;
                    gethostbyaddr();
                    sockent = _t150;
                    if(sockent == 0) {
                        _t151 = sockname.sin_addr;
                         *__esp = _t151;
                        inet_ntoa();
                        _v92 = 0;
                        _v96 = 135066462;
                        _v100 = _t151;
                        _v104 = 135066464;
                        Strcat_m_charp(tmp);
                    } else {
                        Strcat_charp(tmp, sockent->h_name);
                    }
                    _v64->pass = tmp->ptr;
                }
            }
        }
    }
    _v64->rf = newInputStream(sock);
    _t106 = sock;
     *__esp = _t106;
    dup();
    _v104 = 135066466;
     *__esp = _t106;
    fdopen();
    _v64->wf = _t106;
    if(_v64->rf == 0 || _v64->wf == 0) {
        goto L27;
    } else {
        _v64->rf[0x14] = _v64->rf[0x14] & 255 | 16;
        ftp_command(_v64, 0, 0,  &status);
        if(status != 220) {
            goto L27;
        }
        if((fmInitialized & 255) != 0) {
            _v104 = _v64->user;
            message( *(Sprintf("Sending FTP username (%s) to remote server.")), 0, 0);
            refresh();
        }
        ftp_command(_v64, "USER", _v64->user,  &status);
        if(status == 230) {
            goto L22;
        } else {
            if(status != 331) {
                goto L27;
            }
            if((fmInitialized & 255) != 0) {
                message("Sending FTP password to remote server.", 0, 0);
                refresh();
            }
            ftp_command(_v64, "PASS", _v64->pass,  &status);
            if(status != 230) {
                goto L27;
            } else {
L22:
                _t102 = 1;
                goto L28;
            }
        }
    }
}

int ftp_pasv(FTP ftp)
{// addr = 0x080A2D03  --  defined in 'ftp.c' at line 185
    signed int _v16;                       // _cfa_fffffff0
    char[45] abuf;                         // _cfa_ffffffc2
    struct sockaddr_storage sockaddr;   // _cfa_ffffff40
    unsigned char d1;                      // _cfa_ffffff3f
    unsigned char d2;                      // _cfa_ffffff3e
    unsigned char d3;                      // _cfa_ffffff3d
    unsigned char d4;                      // _cfa_ffffff3c
    int status;                            // _cfa_ffffff38
    int n1;                                // _cfa_ffffff34
    int n2;                                // _cfa_ffffff30
    int n3;                                // _cfa_ffffff2c
    int n4;                                // _cfa_ffffff28
    int p1;                                // _cfa_ffffff24
    int p2;                                // _cfa_ffffff20
    int data;                              // _cfa_ffffff1c
    char* p;                               // _cfa_ffffff18
    Str tmp;               // _cfa_ffffff14
    int family;                            // _cfa_ffffff10
    int sockaddrlen;                       // _cfa_ffffff0c
    int port;                              // _cfa_ffffff08
    struct _FTP* _v256;   // _cfa_ffffff00
    int* _v272;                            // _cfa_fffffef0
    unsigned char* _v276;                  // _cfa_fffffeec
    int* _v280;                            // _cfa_fffffee8
    unsigned char* _v284;                  // _cfa_fffffee4
    unsigned char* _v288;                  // _cfa_fffffee0 (outparam)
    char[45]* _v292;                       // _cfa_fffffedc (outparam)
    int _v296;                             // _cfa_fffffed8 (outparam)
    _unknown_ __ebx;                       // r1
    FILE* _t117;          // _t117
    int _t120;                             // _t120
    FILE* _t141;          // _t141
    int _t142;                             // _t142
    char* _t160;                           // _t160
    short unsigned int* _t165;             // _t165

    _v256 = ftp;
    _v16 =  *gs:0x14];
    sockaddrlen = 128;
    _t117 = _v256->wf;
     *__esp = _t117;
    fileno();
    _v292 =  &sockaddrlen;
    _v296 =  &(sockaddr.ss_family);
     *__esp = _t117;
    getpeername();
    if(_t117 >= 0) {
        family = sockaddr.ss_family & 0xffff;
        _t120 = family;
        if(_t120 == 2) {
            tmp = ftp_command(_v256, "PASV", 0,  &status);
            if(status == 227) {
                p =  &(tmp->ptr[4]);
                while(( *p & 255) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 8) == 0) {
                    p =  &(p[1]);
                }
                if(( *p & 255) != 0) {
                    _v272 =  &p2;
                    _v276 =  &p1;
                    _v280 =  &n4;
                    _v284 =  &n3;
                    _v288 =  &n2;
                    _v292 =  &n1;
                    _v296 = "%d,%d,%d,%d,%d,%d";
                     *__esp = p;
                    __isoc99_sscanf();
                    _v284 = n4;
                    _v288 = n3;
                    _v292 = n2;
                    _v296 = n1;
                    tmp = Sprintf("%d.%d.%d.%d");
                    data = openSocket(tmp->ptr, 135066584, (p1 << 8) + p2 & 65535);
L30:
                    if(data >= 0) {
                        _v296 = "rb";
                        _t141 = data;
                         *__esp = _t141;
                        fdopen();
                        _v256->data = _t141;
                        _t142 = 0;
                    } else {
                        _t142 = -1;
                    }
                    goto L33;
                }
                _t142 = -1;
                goto L33;
            }
            _t142 = -1;
            goto L33;
        }
        if(_t120 != 10) {
            _t142 = -1;
            goto L33;
        }
        tmp = ftp_command(_v256, "EPSV", 0,  &status);
        if(status == 229) {
            p =  &(tmp->ptr[4]);
            do {
            } while(( *p & 255) != 0 && ( *p & 255) != 40);
            if(( *p & 255) != 0) {
                p =  &(p[1]);
                _t160 = p;
                _v276 =  &d4;
                _v280 =  &port;
                _v284 =  &d3;
                _v288 =  &d2;
                _v292 =  &d1;
                _v296 = "%c%c%c%d%c";
                 *__esp = _t160;
                __isoc99_sscanf();
                if(_t160 != 5 || (d1 & 255) != (d2 & 255) || (d1 & 255) != (d3 & 255) || (d1 & 255) != (d4 & 255)) {
                    _t142 = -1;
                } else {
                    _t165 =  &(sockaddr.ss_family);
                    _v276 = 1;
                    _v280 = 0;
                    _v284 = 0;
                    _v288 = 46;
                    _v292 =  &abuf;
                    _v296 = sockaddrlen;
                     *__esp = _t165;
                    getnameinfo();
                    if(_t165 == 0) {
                        data = openSocket( &abuf, 135066584, port & 65535);
                        goto L30;
                    }
                    _t142 = -1;
                }
            } else {
                _t142 = -1;
            }
        } else {
            _t142 = -1;
        }
        goto L33;
    } else {
        _t142 = -1;
L33:
        if((_v16 ^  *gs:0x14]) == 0) {
            return _t142;
        }
        __stack_chk_fail();
        return _t142;
    }
}

time_t ftp_modtime(FTP ftp, char* path)
{// addr = 0x080A30EC  --  defined in 'ftp.c' at line 252
    int status;                            // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    time_t t;           // _cfa_ffffffe4
    time_t lt;          // _cfa_ffffffe0
    time_t gt;          // _cfa_ffffffdc
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    struct tm tm;           // _cfa_ffffffb0
    int* _v96;                             // _cfa_ffffffa0
    int* _v100;                            // _cfa_ffffff9c
    int* _v104;                            // _cfa_ffffff98
    int* _v108;                            // _cfa_ffffff94
    int* _v112;                            // _cfa_ffffff90 (outparam)
    int* _v116;                            // _cfa_ffffff8c (outparam)
    char* _v120;                           // _cfa_ffffff88 (outparam)
    char* _t57;                            // _t57
    long int _t62;                         // _t62

    tmp = ftp_command(ftp, "MDTM", path,  &status);
    if(status == 213) {
        p =  &(tmp->ptr[4]);
        while(( *p & 255) != 0 && ( *p & 255) == 32) {
            p =  &(p[1]);
        }
        _v116 = 44;
        _v120 = 0;
         *__esp =  &(tm.tm_sec);
        memset();
        _t57 = p;
        _v96 =  &(tm.tm_sec);
        _v100 =  &(( &(tm.tm_sec))[1]);
        _v104 =  &(( &(tm.tm_sec))[2]);
        _v108 =  &(( &(tm.tm_sec))[3]);
        _v112 =  &(( &(tm.tm_sec))[4]);
        _v116 =  &(( &(tm.tm_sec))[5]);
        _v120 = "%04d%02d%02d%02d%02d%02d";
         *__esp = _t57;
        __isoc99_sscanf();
        if(_t57 > 5) {
            tm.tm_year = tm.tm_year - 1900;
            tm.tm_mon = tm.tm_mon - 1;
            _t62 =  &(tm.tm_sec);
             *__esp = _t62;
            mktime();
            t = _t62;
             *__esp =  &t;
            localtime();
             *__esp =  &t;
            mktime();
            lt =  &t;
             *__esp =  &t;
            gmtime();
             *__esp =  &t;
            mktime();
            gt =  &t;
            return lt - gt + t;
        }
        return -1;
    }
    return -1;
}

int ftp_quit(FTP ftp)
{// addr = 0x080A3221  --  defined in 'ftp.c' at line 278
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    ftp_command(ftp, "QUIT", 0, 0);
    ftp_close(ftp);
    return 0;
}

void closeFTPdata(FILE* f)
{// addr = 0x080A325C  --  defined in 'ftp.c' at line 304
    int status;                            // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(f != 0) {
         *__esp = f;
        fclose();
        if(current_ftp.data == f) {
            current_ftp.data = 0;
        }
    }
    ftp_command( &current_ftp, 0, 0,  &status);
}

void closeFTP()
{// addr = 0x080A32AC  --  defined in 'ftp.c' at line 317
    ftp_close( &current_ftp);
}

InputStream openFTPStream(ParsedURL* pu, URLFile* uf)
{// addr = 0x080A32C0  --  defined in 'ftp.c' at line 323
    Str tmp;               // _cfa_fffffff0
    int status;                            // _cfa_ffffffec
    char* user;                            // _cfa_ffffffe8
    char* pass;                            // _cfa_ffffffe4
    Str uname;             // _cfa_ffffffe0
    Str pwd;               // _cfa_ffffffdc
    int add_auth_cookie_flag;              // _cfa_ffffffd8
    char* realpathname;                    // _cfa_ffffffd4
    struct passwd* mypw;   // _cfa_ffffffd0
    _unknown_ _v76;                        // _cfa_ffffffb4 (outparam)
    _unknown_ _v80;                        // _cfa_ffffffb0 (outparam)
    _unknown_ _v84;                        // _cfa_ffffffac (outparam)
    char* _v88;                            // _cfa_ffffffa8 (outparam)
    char* _t167;                           // _t167
    signed int _t207;                      // _t207
    char* _t208;                           // _t208
    int _t216;                             // _t216
    char* _t235;                           // _t235
    char* _t244;                           // _t244
    char* _t248;                           // _t248

    user = 0;
    pass = 0;
    uname = 0;
    pwd = 0;
    add_auth_cookie_flag = 0;
    realpathname = 0;
    if(pu->host == 0) {
        return 0;
    }
    if(pu->user == 0) {
        if(pu->pass == 0 && find_auth_user_passwd(pu, 0,  &uname,  &pwd, 0) != 0) {
            if(uname != 0) {
                user = uname->ptr;
            }
            if(pwd != 0) {
                pass = pwd->ptr;
            }
        }
    }
    if(user == 0) {
        if(pu->user == 0) {
            user = "anonymous";
        } else {
            user = pu->user;
        }
    }
    if(current_ftp.host == 0) {
L20:
        if(pass != 0) {
L39:
            if(current_ftp.host != 0) {
L42:
                if(add_auth_cookie_flag != 0) {
                    add_auth_user_passwd(pu, 0, uname, pwd, 0);
                }
                goto L45;
            }
            current_ftp.host = allocStr(pu->host, -1);
            current_ftp.port = pu->port;
            current_ftp.user = allocStr(user, -1);
            current_ftp.pass = allocStr(pass, -1);
            if(ftp_login( &current_ftp) != 0) {
                goto L42;
            }
            return 0;
        }
        if(pu->pass == 0) {
            if(pu->user == 0) {
                _t207 = ftppasswd;
                if(_t207 == 0) {
L33:
                    getuid();
                     *__esp = _t207;
                    getpwuid();
                    mypw = _t207;
                    if(mypw == 0) {
                        _t208 = "anonymous";
                    } else {
                        _t208 = mypw->pw_name;
                    }
                    tmp = Strnew_charp(_t208);
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t216 = tmp->length;
                     *((char*)(tmp->ptr + _t216)) = 64;
                    tmp->length = _t216 + 1;
                     *((char*)(tmp->ptr + tmp->length)) = 0;
                    pass = tmp->ptr;
                    goto L39;
                }
                _t207 =  *ftppasswd & 255;
                if(_t207 == 0) {
                    goto L33;
                }
                pass = ftppasswd;
                goto L39;
            }
            pwd = 0;
            find_auth_user_passwd(pu, 0,  &uname,  &pwd, 0);
            if(pwd == 0) {
                _t235 = fmInitialized & 255;
                if(_t235 == 0) {
                     *__esp = "Password: ";
                    getpass();
                    pwd = Strnew_charp(_t235);
                } else {
                    term_raw();
                    pwd = Strnew_charp(inputLineHistSearch("Password: ", 0, 64, 0, 0));
                    pwd = wc_Str_conv_strict(pwd, InnerCharset, SystemCharset);
                    term_cbreak();
                }
                add_auth_cookie_flag = 1;
            }
            pass = pwd->ptr;
            goto L39;
        }
        pass = pu->pass;
        goto L39;
    } else {
        _t244 = current_ftp.host;
        _v88 = pu->host;
         *__esp = _t244;
        strcmp();
        if(_t244 != 0 || current_ftp.port != pu->port) {
L19:
            ftp_quit( &current_ftp);
            goto L20;
        } else {
            _t248 = current_ftp.user;
            _v88 = user;
             *__esp = _t248;
            strcmp();
            if(_t248 != 0) {
                goto L19;
            }
            ftp_command( &current_ftp, "NOOP", 0,  &status);
            if(status == 200) {
L45:
                ftp_command( &current_ftp, 135066676, 135066674,  &status);
                if(ftp_pasv( &current_ftp) >= 0) {
                    if(pu->file == 0 || (pu & 255) == 0) {
L56:
                        pu->scheme = 3;
                        return 0;
                    } else {
                        _t167 = pu->file;
                         *__esp = _t167;
                        strlen();
                        if((pu->file[_t167 - 1] & 255) == 47) {
                            goto L56;
                        }
                        realpathname = file_unquote(pu->file);
                        if(( *realpathname & 255) == 47 && (realpathname[1] & 255) == 126) {
                            realpathname =  &(realpathname[1]);
                        }
                        uf->modtime = ftp_modtime( &current_ftp, realpathname);
                        ftp_command( &current_ftp, 135066681, realpathname,  &status);
                        if(status == 125 || status == 150) {
                            return newFileStream(current_ftp.data, closeFTPdata);
                        } else {
                            goto L56;
                        }
                    }
                }
                ftp_quit( &current_ftp);
                return 0;
            } else {
                ftp_close( &current_ftp);
                goto L20;
            }
        }
    }
}

Str loadFTPDir(ParsedURL* pu, wc_ces* charset)
{// addr = 0x080A37A6  --  defined in 'ftp.c' at line 443
    Str FTPDIRtmp;         // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    int status;                            // _cfa_ffffffe8
    _None sv_type;                         // _cfa_ffffffe4
    char* realpathname;                    // _cfa_ffffffe0
    char* fn;                              // _cfa_ffffffdc
    char* q;                               // _cfa_ffffffd8
    char** flist;                          // _cfa_ffffffd4
    int i;                                 // _cfa_ffffffd0
    int nfile;                             // _cfa_ffffffcc
    int nfile_max;                         // _cfa_ffffffc8
    _None prevtrap;                        // _cfa_ffffffc4
    wc_ces doc_charset;   // _cfa_ffffffc0
    char* name;                            // _cfa_ffffffbc
    char* link;                            // _cfa_ffffffb8
    char* date;                            // _cfa_ffffffb4
    char* size;                            // _cfa_ffffffb0
    char* type_str;                        // _cfa_ffffffac
    int ftype;                             // _cfa_ffffffa8
    int max_len;                           // _cfa_ffffffa4
    int len;                               // _cfa_ffffffa0
    int j;                                 // _cfa_ffffff9c
    struct _Str* _v112;   // _cfa_ffffff90
    struct _Str* _v116;   // _cfa_ffffff8c
    char* _v120;                           // _cfa_ffffff88
    char* _v124;                           // _cfa_ffffff84 (outparam)
    struct _Str* _v128;   // _cfa_ffffff80 (outparam)
    char* _v132;                           // _cfa_ffffff7c (outparam)
    char* _v136;                           // _cfa_ffffff78 (outparam)
    char* __ebx;                           // r1
    char* _t363;                           // _t363
    int _t381;                             // _t381
    struct _Str* _t401;   // _t401
    char** _t407;                          // _t407
    char* _t417;                           // _t417
    char* _t418;                           // _t418
    int _t419;                             // _t419
    char** _t429;                          // _t429
    char* _t438;                           // _t438
    char* _t454;                           // _t454
    char* _t457;                           // _t457
    int _t475;                             // _t475
    int _t488;                             // _t488
    char* _t500;                           // _t500
    int _t508;                             // _t508
    char* _t569;                           // _t569

    prevtrap = 0;
    doc_charset = DocumentCharset;
     *charset = 256;
    if(current_ftp.data == 0) {
        return 0;
    }
    tmp = ftp_command( &current_ftp, 135066686, 0,  &status);
    _t363 = tmp->ptr;
    _v136 = 135066691;
     *__esp = _t363;
    strstr();
    if(_t363 != 0) {
L4:
        sv_type = 1;
        goto L6;
    } else {
        _t569 =  &(4[tmp->ptr]);
        _v132 = 10;
        _v136 = "Windows_NT";
         *__esp = _t569;
        strncmp();
        if(_t569 != 0) {
            sv_type = 0;
L6:
            if(pu->file == 0 || (pu & 255) == 0) {
                if(sv_type != 1) {
                    ftp_command( &current_ftp, "NLST", 0,  &status);
                } else {
                    ftp_command( &current_ftp, "LIST", 0,  &status);
                }
                pu->file = 135066717;
            } else {
                realpathname = file_unquote(pu->file);
                if(( *realpathname & 255) == 47 && (realpathname[1] & 255) == 126) {
                    realpathname =  &(realpathname[1]);
                }
                if(sv_type != 1) {
                    ftp_command( &current_ftp, "NLST", realpathname,  &status);
                } else {
                    ftp_command( &current_ftp, 135066719, realpathname,  &status);
                    if(status == 250) {
                        ftp_command( &current_ftp, "LIST", 0,  &status);
                    }
                }
            }
            if(status == 125 || status == 150) {
                tmp = parsedURL2Str(pu);
                if(tmp->length <= 0 || ( *(tmp->ptr + tmp->length - 1) & 255) != 47) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t381 = tmp->length;
                     *((char*)(tmp->ptr + _t381)) = 47;
                    tmp->length = _t381 + 1;
                     *((char*)(tmp->ptr + tmp->length)) = 0;
                }
                fn = html_quote(tmp->ptr);
                tmp = convertLine(0, Strnew_charp(file_unquote(tmp->ptr)), 0, charset, doc_charset);
                q = html_quote(tmp->ptr);
                _v112 = 0;
                _v116 = "</h1>\n";
                _v120 = q;
                _v124 = "</title>\n</head>\n<body>\n<h1>Index of ";
                _v128 = q;
                _v132 = "">\n<title>";
                _v136 = fn;
                _t401 = Strnew_m_charp("<html>\n<head>\n<base href="");
                FTPDIRtmp = _t401;
                _v136 = 1;
                 *__esp =  &AbortLoading;
                __sigsetjmp();
                if(_t401 == 0) {
                    if((TrapSignal & 255) != 0) {
                        prevtrap = mySignal(2, KeyAbort);
                        if((fmInitialized & 255) != 0) {
                            term_cbreak();
                        }
                    }
                    if(sv_type != 1) {
                        Strcat_charp(FTPDIRtmp, "<ul>\n<li>");
                    } else {
                        Strcat_charp(FTPDIRtmp, "<pre>\n");
                    }
                    Strcat_charp(FTPDIRtmp, "<a href="..">[Upper Directory]</a>\n");
                    nfile_max = 100;
                    _t407 = nfile_max << 2;
                     *__esp = _t407;
                    GC_malloc();
                    flist = _t407;
                    nfile = 0;
                    if(sv_type != 1) {
                        while(1) {
                            __eax = current_ftp.data;
                            tmp = Strfgets(current_ftp.data);
                            tmp = tmp->length;
                            if(tmp->length <= 0) {
                                break;
                            }
                            __eax = tmp;
                            Strchop(tmp);
                            nfile = nfile << 2;
                            nfile << 2 =  &(flist[nfile]);
                            tmp = tmp->ptr;
                            flist[nfile] = mybasename(tmp->ptr);
                            nfile = nfile + 1;
                            __eax = nfile;
                            if(nfile == nfile_max) {
                                nfile_max = nfile_max << 1;
                                nfile_max = nfile_max << 2;
                                _v136 = nfile_max << 2;
                                __eax = flist;
                                 *__esp = __eax;
                                GC_realloc();
                                flist = __eax;
                            }
                        }
                        __eax = nfile;
                        _v128 = strCmp;
                        _v132 = 4;
                        _v136 = nfile;
                        __eax = flist;
                         *__esp = flist;
                        qsort();
                        i = 0;
                        while(1) {
                            __eax = i;
                            if(i >= nfile) {
                                break;
                            }
                            i = i << 2;
                             &(flist[i]) = flist[i];
                            fn = flist[i];
                            __eax = fn;
                            __eax = Strnew_charp(fn);
                            tmp = __eax;
                            tmp = tmp->ptr;
                            __ebx = html_quote(tmp->ptr);
                            __eax = fn;
                            __eax = file_quote(fn);
                            __eax = html_quote(__eax);
                            _v116 = 0;
                            _v120 = "</a>\n";
                            _v124 = __ebx;
                            _v128 = "">";
                            _v132 = __eax;
                            _v136 = "<li><a href="";
                            __eax = FTPDIRtmp;
                            Strcat_m_charp(FTPDIRtmp);
                            i = i + 1;
                        }
                        _v136 = "</ul>\n";
                        __eax = FTPDIRtmp;
                         *__esp = FTPDIRtmp;
                        Strcat_charp();
                    } else {
                        max_len = 20;
                        while(1) {
                            tmp = Strfgets(current_ftp.data);
                            if(tmp->length <= 0) {
                                break;
                            }
                            Strchop(tmp);
                            ftype = ex_ftpdir_name_size_date(tmp->ptr,  &name,  &link,  &date,  &size);
                            if(ftype != 0) {
                                _t417 = name;
                                _v136 = _t417;
                                 *__esp = 135066912;
                                strcmp();
                                if(_t417 != 0) {
                                    _t418 = name;
                                    _v136 = _t418;
                                     *__esp = 135066914;
                                    strcmp();
                                    if(_t418 != 0) {
                                        _t419 = name;
                                         *__esp = _t419;
                                        strlen();
                                        len = _t419;
                                        if(len != 0) {
                                            if(ftype != 1) {
                                                if(ftype != 2) {
                                                    type_str = 135066919;
                                                } else {
                                                    len = len + 1;
                                                    type_str = 135066917;
                                                }
                                            } else {
                                                len = len + 1;
                                                type_str = 135066717;
                                            }
                                            if(max_len < len) {
                                                max_len = len;
                                            }
                                            _v120 = link;
                                            _v124 = size;
                                            _v128 = date;
                                            _v132 = type_str;
                                            _v136 = name;
                                            flist[nfile] =  *(Sprintf("%s%s\n%s  %5s%s"));
                                            nfile = nfile + 1;
                                            if(nfile == nfile_max) {
                                                nfile_max = nfile_max << 1;
                                                _v136 = nfile_max << 2;
                                                _t429 = flist;
                                                 *__esp = _t429;
                                                GC_realloc();
                                                flist = _t429;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        _v128 = strCmp;
                        _v132 = 4;
                        _v136 = nfile;
                         *__esp = flist;
                        qsort();
                        j = 0;
                        while(j < nfile) {
                            fn = flist[j];
                            _v136 = 10;
                            _t438 = fn;
                             *__esp = _t438;
                            strchr();
                            date = _t438;
                            if(( *(date - 1) & 255) != 47) {
                                if(( *(date - 1) & 255) != 64) {
                                    ftype = 3;
                                     *(date - 1) = 0;
                                } else {
                                    ftype = 2;
                                     *(date - 1) = 0;
                                }
                            } else {
                                ftype = 1;
                                 *date = 0;
                            }
                            date =  &(date[1]);
                            tmp = convertLine(0, Strnew_charp(fn), 0, charset, doc_charset);
                            if(ftype == 2) {
                                if(tmp->length + 1 >= tmp->area_size) {
                                    Strgrow(tmp);
                                }
                                _t508 = tmp->length;
                                 *((char*)(tmp->ptr + _t508)) = 64;
                                tmp->length = _t508 + 1;
                                 *((char*)(tmp->ptr + tmp->length)) = 0;
                            }
                            _t454 = html_quote(tmp->ptr);
                            _t457 = html_quote(file_quote(fn));
                            _v116 = 0;
                            _v120 = "</a>";
                            _v124 = _t454;
                            _v128 = "">";
                            _v132 = _t457;
                            _v136 = "<a href="";
                            Strcat_m_charp(FTPDIRtmp);
                            i = wtf_strwidth(tmp->ptr);
                            while(i <= max_len) {
                                if(((max_len + (max_len >> 31 >> 31) & 1) - (max_len >> 31 >> 31) + i & 1) == 0) {
                                    if(FTPDIRtmp->length + 1 >= FTPDIRtmp->area_size) {
                                        Strgrow(FTPDIRtmp);
                                    }
                                    _t475 = FTPDIRtmp->length;
                                     *((char*)(FTPDIRtmp->ptr + _t475)) = 32;
                                    FTPDIRtmp->length = _t475 + 1;
                                     *((char*)(FTPDIRtmp->ptr + FTPDIRtmp->length)) = 0;
                                } else {
                                    if(FTPDIRtmp->length + 1 >= FTPDIRtmp->area_size) {
                                        Strgrow(FTPDIRtmp);
                                    }
                                    _t488 = FTPDIRtmp->length;
                                     *((char*)(FTPDIRtmp->ptr + _t488)) = 46;
                                    FTPDIRtmp->length = _t488 + 1;
                                     *((char*)(FTPDIRtmp->ptr + FTPDIRtmp->length)) = 0;
                                }
                                i = i + 1;
                            }
                            tmp = convertLine(0, Strnew_charp(date), 0, charset, doc_charset);
                            _t500 = html_quote(tmp->ptr);
                            _v128 = 0;
                            _v132 = 135066954;
                            _v136 = _t500;
                            Strcat_m_charp(FTPDIRtmp);
                            j = j + 1;
                        }
                        Strcat_charp(FTPDIRtmp, "</pre>\n");
                    }
                    goto L89;
                } else {
                    if(sv_type != 1) {
                        Strcat_charp(FTPDIRtmp, "</a></ul>\n");
                    } else {
                        Strcat_charp(FTPDIRtmp, "</a></pre>\n");
                    }
                    Strcat_charp(FTPDIRtmp, "<p>Transfer Interrupted!\n");
L89:
                    Strcat_charp(FTPDIRtmp, "</body>\n</html>\n");
                    if((TrapSignal & 255) != 0) {
                        if((fmInitialized & 255) != 0) {
                            term_raw();
                        }
                        if(prevtrap != 0) {
                            mySignal(2, prevtrap);
                        }
                    }
                    closeFTPdata(current_ftp.data);
                    return FTPDIRtmp;
                }
            } else {
                 *__esp = current_ftp.data;
                fclose();
                current_ftp.data = 0;
                return 0;
            }
        }
        goto L4;
    }
}

void disconnectFTP()
{// addr = 0x080A41AF  --  defined in 'ftp.c' at line 625
    ftp_quit( &current_ftp);
}

int ex_ftpdir_name_size_date(char* line, char** name, char** link, char** date, char** sizep)
{// addr = 0x080A41C3  --  defined in 'ftp.c' at line 651
    int ftype;                             // _cfa_fffffff0
    char* cp;                              // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    signed int _v32;                       // _cfa_ffffffe0
    clen_t size;        // _cfa_ffffffdc
    signed int _v56;                       // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    char* _t198;                           // _t198
    signed int _t331;                      // _t331
    char* _t339;                           // _t339

    ftype = 0;
    cp = line;
    _t198 = cp;
     *__esp = _t198;
    strlen();
    if(_t198 <= 10) {
L99:
        return ftype;
    }
    cp =  &(cp[0xa]);
    if(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) == 0) {
        goto L99;
    } else {
        cp =  &(cp[1]);
        while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) != 0) {
            if(( *cp & 255) != 0) {
                cp =  &(cp[1]);
                continue;
            }
            break;
        }
        if(( *cp & 255) == 0) {
            goto L99;
        } else {
            size = 0;
            _v32 = 0;
            while(( *cp & 255) != 0) {
                if(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 8) != 0) {
                    asm("adc edx, ebx");
                    asm("adc edx, 0xffffffff");
                    size = 10 * size + ( *cp & 255) + -48;
                    _v32 = _v32 * 10 + size * 0 + (10 * size >> 32);
                    cp =  &(cp[1]);
                    continue;
                }
                break;
            }
            if(( *cp & 255) == 0) {
                goto L99;
            } else {
                cp =  &(cp[1]);
                while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) != 0) {
                    if(( *cp & 255) != 0) {
                        cp =  &(cp[1]);
                        continue;
                    }
                    break;
                }
                if(( *cp & 255) == 0) {
                    goto L99;
                } else {
                    while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) == 0) {
                        if(( *cp & 255) != 0) {
                            cp =  &(cp[1]);
                            continue;
                        }
                        break;
                    }
                    if(( *cp & 255) == 0) {
                        goto L99;
                    } else {
                        cp =  &(cp[1]);
                        while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) != 0) {
                            if(( *cp & 255) != 0) {
                                cp =  &(cp[1]);
                                continue;
                            }
                            break;
                        }
                        if(( *cp & 255) == 0) {
                            goto L99;
                        } else {
                            do {
                            } while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) == 0 && ( *cp & 255) != 0);
                            if(( *cp & 255) == 0) {
                                goto L99;
                            } else {
                                cp =  &(cp[1]);
                                do {
                                } while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) != 0 && ( *cp & 255) != 0);
                                if(( *cp & 255) == 0) {
                                    goto L99;
                                } else {
                                    p = cp;
                                    size = 0;
                                    _v32 = 0;
                                    while(( *cp & 255) != 0 && ( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 8) != 0) {
                                        asm("adc edx, ebx");
                                        asm("adc edx, 0xffffffff");
                                        size = 10 * size + ( *cp & 255) + -48;
                                        _v32 = _v32 * 10 + size * 0 + (10 * size >> 32);
                                        cp =  &(cp[1]);
                                    }
                                    if(( *cp & 255) == 0) {
                                        goto L99;
                                    }
                                    if(( *cp & 255) != 44) {
                                         *__esp = size;
                                        _v56 = _v32;
                                         *sizep =  *(size_int2str());
L55:
                                        cp =  &(cp[1]);
                                        p = cp;
                                        while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) != 0 && ( *cp & 255) != 0) {
                                            cp =  &(cp[1]);
                                        }
                                        if(( *cp & 255) == 0) {
                                            goto L99;
                                        }
                                        while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) == 0 && ( *cp & 255) != 0) {
                                            cp =  &(cp[1]);
                                        }
                                        if(( *cp & 255) == 0) {
                                            goto L99;
                                        }
                                        while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) != 0 && ( *cp & 255) != 0) {
                                            cp =  &(cp[1]);
                                        }
                                        if(( *cp & 255) == 0) {
                                            goto L99;
                                        }
                                        while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) == 0 && ( *cp & 255) != 0) {
                                            cp =  &(cp[1]);
                                        }
                                        if(( *cp & 255) == 0) {
                                            goto L99;
                                        }
                                        while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) != 0 && ( *cp & 255) != 0) {
                                            cp =  &(cp[1]);
                                        }
                                        if(( *cp & 255) == 0) {
                                            goto L99;
                                        }
                                        while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) == 0 && ( *cp & 255) != 0) {
                                            cp =  &(cp[1]);
                                        }
                                        if(( *cp & 255) == 0) {
                                            goto L99;
                                        }
                                         *date = allocStr(p, cp - p);
                                        cp =  &(cp[1]);
                                        while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) != 0 && ( *cp & 255) != 0) {
                                            cp =  &(cp[1]);
                                        }
                                        if(( *cp & 255) != 0) {
                                            _t331 =  *line & 255;
                                            if(_t331 == 100) {
                                                ftype = 1;
                                                 *name = allocStr(cp, -1);
                                                 *link = 135066584;
                                                 *sizep = 135066584;
                                            } else {
                                                if(_t331 != 108) {
                                                    ftype = 3;
                                                     *name = allocStr(cp, -1);
                                                     *link = 135066584;
                                                } else {
                                                    ftype = 2;
                                                    _v56 = " -> ";
                                                    _t339 = cp;
                                                     *__esp = _t339;
                                                    strstr();
                                                    p = _t339;
                                                    if(p != 0) {
                                                         *name = allocStr(cp, p - cp);
                                                         *link = allocStr(p, -1);
                                                         *sizep = 135066584;
                                                    }
                                                }
                                            }
                                        }
                                        goto L99;
                                    }
                                    cp =  &(cp[1]);
                                    while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) != 0 && ( *cp & 255) != 0) {
                                        cp =  &(cp[1]);
                                    }
                                    if(( *cp & 255) == 0) {
                                        goto L99;
                                    }
                                    while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) == 0 && ( *cp & 255) != 0) {
                                        cp =  &(cp[1]);
                                    }
                                    if(( *cp & 255) == 0) {
                                        goto L99;
                                    }
                                     *sizep = allocStr(p, cp - p);
                                    goto L55;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

Str size_int2str(clen_t size)
{// addr = 0x080A47D6  --  defined in 'ftp.c' at line 737
    Str size_str;          // _cfa_fffffff0
    int unit;                              // _cfa_ffffffec
    char* size_format;                     // _cfa_ffffffe8
    char* unit_str;                        // _cfa_ffffffe4
    double dtmp;                           // _cfa_ffffffdc
    intOrPtr _v48;                         // _cfa_ffffffd0
    long long int _v52;                    // _cfa_ffffffcc
    char* _v64;                            // _cfa_ffffffc0
    double _v72;                           // _cfa_ffffffb8
    int _t34;                              // _t34
    int _t42;                              // _t42

    _v52 = size;
    _v48 = _a8;
    asm("fild qword [ebp-0x30]");
    dtmp = __fp0;
    unit = 0;
    while(unit <= 2) {
        asm("fucomip st0, st1");
        st0 =  *135067040;
        __eflags = __eflags > 0;
        if(__eflags != 0) {
L6:
            _t42 = unit;
            if(_t42 == 0) {
L8:
                size_format = "%.0f%s";
L12:
                _t34 = unit;
                if(_t34 == 2) {
                    unit_str = 135067036;
                } else {
                    if(_t34 == 3) {
                        unit_str = L"GMK";
                    } else {
                        if(_t34 == 1) {
                            unit_str = 135067038;
                        } else {
                            unit_str = 135066584;
                        }
                    }
                }
                _v64 = unit_str;
                _v72 = dtmp;
                size_str = Sprintf(size_format);
                return size_str;
            }
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            st0 =  *135067048;
            if(_t42 > 0) {
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                st0 =  *135067056;
                if(__eflags == 0) {
                    size_format = "%.2f%s";
                } else {
                    size_format = "%.1f%s";
                }
                goto L12;
            }
            goto L8;
        } else {
            asm("fdivp st1, st0");
            dtmp =  *135067040;
            unit = unit + 1;
            __eflags = unit;
            continue;
        }
    }
    goto L6;
}

unsigned char c2e(char x)
{// addr = 0x080A48C8  --  defined in 'mimehead.c' at line 23
    signed int _v8;                        // _cfa_fffffff8

    _v8 = x;
    if(_v8 > 64) {
        if(_v8 > 90) {
            goto L3;
        } else {
            return (_v8 & 255) - 65;
        }
    }
L3:
    if(_v8 <= 96 || _v8 > 122) {
        if(_v8 <= 47 || _v8 > 57) {
            if(_v8 != 43) {
                if(_v8 != 47) {
                    return -1;
                }
                return 63;
            }
            return 62;
        } else {
            return (_v8 & 255) + 4;
        }
    } else {
        return (_v8 & 255) - 71;
    }
}

int ha2d(char x, char y)
{// addr = 0x080A4934  --  defined in 'mimehead.c' at line 40
    int r;                                 // _cfa_fffffff8
    char _v24;                             // _cfa_ffffffe8
    char _v28;                             // _cfa_ffffffe4

    _v24 = x;
    _v28 = y;
    r = 0;
    if(_v24 <= 47) {
L3:
        if(_v24 <= 64) {
L6:
            if(_v24 > 96 && _v24 <= 102) {
                r = _v24 - 87;
            }
L9:
            r = r << 4;
            if(_v28 <= 47 || _v28 > 57) {
                if(_v28 <= 64 || _v28 > 70) {
                    if(_v28 > 96 && _v28 <= 102) {
                        r = r + _v28 - 87;
                    }
                } else {
                    r = r + _v28 - 55;
                }
            } else {
                r = r + _v28 - 48;
            }
            return r;
        }
        if(_v24 > 70) {
            goto L6;
        } else {
            r = _v24 - 55;
            goto L9;
        }
    }
    if(_v24 > 57) {
        goto L3;
    } else {
        r = _v24 - 48;
        goto L9;
    }
}

Str decodeB(char** ww)
{// addr = 0x080A49E2  --  defined in 'mimehead.c' at line 65
    char _v13;                             // _cfa_fffffff3
    char _v14;                             // _cfa_fffffff2
    char[2] d;                             // _cfa_fffffff1
    signed int _v16;                       // _cfa_fffffff0
    signed int _v17;                       // _cfa_ffffffef
    signed int _v18;                       // _cfa_ffffffee
    unsigned char[3] c;                    // _cfa_ffffffed
    char* wp;                              // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    int n_pad;                             // _cfa_ffffffe0
    Str ap;                // _cfa_ffffffdc
    int _t91;                              // _t91
    int _t129;                             // _t129

    wp =  *ww;
    _t91 = wp;
     *__esp = _t91;
    strlen();
    ap = Strnew_size(_t91);
    n_pad = 0;
    do {
        i = 0;
        while(i <= 3) {
             *(__ebp + i - 15) =  *wp & 255;
            wp =  &(wp[1]);
            if(( *wp & 255) == 0 || ( *wp & 255) == 63) {
                i = i + 1;
                do {
                } while(i <= 3);
                break;
            } else {
                i = i + 1;
                continue;
            }
        }
        if((_v16 & 255) == 61) {
            n_pad = n_pad + 1;
            _v16 = 65;
            if((_v17 & 255) == 61) {
                n_pad = n_pad + 1;
                _v17 = 65;
            }
        }
        i = 0;
        while(i <= 3) {
             *(__ebp + i - 15) = c2e( *(__ebp + i - 15) & 255);
            if(( *(__ebp + i - 15) & 255) != 255) {
                i = i + 1;
                continue;
            }
             *ww = wp;
            return ap;
        }
        d = (_v18 & 255) >> 4 | (c & 0xff) << 2;
        _v14 = (_v17 & 255) >> 2 | (_v18 & 0xff) << 4;
        _v13 = _v16 & 255 | (_v17 & 0xff) << 6;
        i = 0;
        while(3 - n_pad > i) {
            if(ap->length + 1 >= ap->area_size) {
                Strgrow(ap);
            }
            _t129 = ap->length;
             *((char*)(ap->ptr + _t129)) =  *(__ebp + i - 11) & 255;
            ap->length = _t129 + 1;
             *((char*)(ap->ptr + ap->length)) = 0;
            i = i + 1;
        }
    } while(n_pad == 0 && ( *wp & 255) != 0 && ( *wp & 255) != 63);
     *ww = wp;
    return ap;
}

Str decodeU(char** ww)
{// addr = 0x080A4BAB  --  defined in 'mimehead.c' at line 114
    unsigned char c1;                      // _cfa_ffffffe3
    unsigned char c2;                      // _cfa_ffffffe2
    char* w;                               // _cfa_ffffffdc
    int n;                                 // _cfa_ffffffd8
    int i;                                 // _cfa_ffffffd4
    Str a;                 // _cfa_ffffffd0
    signed int _v64;                       // _cfa_ffffffc0
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    int _t91;                              // _t91

    w =  *ww;
    if(( *w & 255) <= 32 || ( *w & 255) > 95) {
        return Strnew_size(0);
    }
    n = ( *w & 255) - 32;
    a = Strnew_size(n);
    w =  &(w[1]);
    i = 2;
    while(( *w & 255) != 0 && n != 0) {
        c1 = (( *w & 255) - 32 + (( *w & 255) - 32 >> 31 >> 26) & 63) - (( *w & 255) - 32 >> 31 >> 26);
        c2 = ((w[1] & 255) - 32 + ((w[1] & 255) - 32 >> 31 >> 26) & 63) - ((w[1] & 255) - 32 >> 31 >> 26);
        if(a->length + 1 >= a->area_size) {
            Strgrow(a);
        }
        _t91 = a->length;
        _v64 = c2 & 255;
         *((char*)(a->ptr + _t91)) = _v64 >> 6 - i | (c1 & 255) << i;
        a->length = _t91 + 1;
         *((char*)(a->ptr + a->length)) = 0;
        if(i != 6) {
            w =  &(w[1]);
            i = i + 2;
        } else {
            w =  &(w[2]);
            i = 2;
        }
        n = n - 1;
    }
    return a;
}

Str decodeQ(char** ww)
{// addr = 0x080A4D08  --  defined in 'mimehead.c' at line 143
    char* w;                               // _cfa_fffffff0
    Str a;                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int __ebx;                             // r1
    int _t74;                              // _t74
    int _t92;                              // _t92
    int _t105;                             // _t105

    w =  *ww;
    _t74 = w;
     *__esp = _t74;
    strlen();
    a = Strnew_size(_t74);
    while(( *w & 255) != 0 && ( *w & 255) != 63) {
        if(( *w & 255) != 61) {
            if(( *w & 255) != 95) {
                if(a->length + 1 >= a->area_size) {
                    Strgrow(a);
                }
                _t92 = a->length;
                 *((char*)(a->ptr + _t92)) =  *w & 255;
                a->length = _t92 + 1;
                 *((char*)(a->ptr + a->length)) = 0;
            } else {
                if(a->length + 1 >= a->area_size) {
                    Strgrow(a);
                }
                _t105 = a->length;
                 *((char*)(a->ptr + _t105)) = 32;
                a->length = _t105 + 1;
                 *((char*)(a->ptr + a->length)) = 0;
            }
L12:
            w =  &(w[1]);
            continue;
        }
        w =  &(w[1]);
        if(a->length + 1 >= a->area_size) {
            Strgrow(a);
        }
        __ebx = a->length;
         *((char*)(a->ptr + __ebx)) = ha2d( *w & 255, w[1] & 255);
        a->length = __ebx + 1;
         *((char*)(a->ptr + a->length)) = 0;
        w =  &(w[1]);
        goto L12;
    }
     *ww = w;
    return a;
}

Str decodeQP(char** ww)
{// addr = 0x080A4E89  --  defined in 'mimehead.c' at line 166
    char* w;                               // _cfa_fffffff0
    Str a;                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int __ebx;                             // r1
    int _t66;                              // _t66
    int _t78;                              // _t78

    w =  *ww;
    _t66 = w;
     *__esp = _t66;
    strlen();
    a = Strnew_size(_t66);
    while(( *w & 255) != 0) {
        if(( *w & 255) != 61) {
            if(a->length + 1 >= a->area_size) {
                Strgrow(a);
            }
            _t78 = a->length;
             *((char*)(a->ptr + _t78)) =  *w & 255;
            a->length = _t78 + 1;
             *((char*)(a->ptr + a->length)) = 0;
L24:
            w =  &(w[1]);
            continue;
        }
        w =  &(w[1]);
        if(( *w & 255) == 10) {
L11:
            while(( *w & 255) != 10 && ( *w & 255) != 0) {
                w =  &(w[1]);
            }
            if(( *w & 255) != 0) {
                goto L24;
            }
            break;
        }
        if(( *w & 255) == 13) {
            goto L11;
        }
        if(( *w & 255) == 32) {
            goto L11;
        }
        if(( *w & 255) != 9) {
            if(( *w & 255) == 0 || (w[1] & 255) == 0) {
                break;
            } else {
                if(a->length + 1 >= a->area_size) {
                    Strgrow(a);
                }
                __ebx = a->length;
                 *((char*)(a->ptr + __ebx)) = ha2d( *w & 255, w[1] & 255);
                a->length = __ebx + 1;
                 *((char*)(a->ptr + a->length)) = 0;
                w =  &(w[1]);
                goto L24;
            }
        } else {
            goto L11;
        }
    }
     *ww = w;
    return a;
}

Str decodeWord(char** ow, wc_ces* charset)
{// addr = 0x080A502A  --  defined in 'mimehead.c' at line 196
    char method;                           // _cfa_fffffff3
    wc_ces c;           // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    char* w;                               // _cfa_ffffffe4
    Str a;                 // _cfa_ffffffe0
    Str tmp;               // _cfa_ffffffdc
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    int _t87;                              // _t87
    char* _t101;                           // _t101
    signed int _t113;                      // _t113

    w =  *ow;
    a = Strnew();
    tmp = Strnew();
    if(( *w & 255) != 61 || (w[1] & 255) != 63) {
L27:
        return Strnew();
    } else {
        w =  &(w[2]);
        while(( *w & 255) != 63) {
            if(( *w & 255) == 0) {
                goto L27;
            }
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t87 = tmp->length;
             *((char*)(tmp->ptr + _t87)) =  *w & 255;
            tmp->length = _t87 + 1;
             *((char*)(tmp->ptr + tmp->length)) = 0;
            w =  &(w[1]);
        }
        c = wc_guess_charset(tmp->ptr, 0);
        if(c == 0) {
            goto L27;
        }
        w =  &(w[1]);
        _t101 = w;
        method =  *_t101 & 255;
        w =  &(_t101[1]);
        if(( *w & 255) != 63) {
            goto L27;
        }
        w =  &(w[1]);
        p = w;
        if(( *( &MYCTYPE_MAP + (method & 0xff)) & 4) == 0) {
            _t113 = method;
        } else {
            _t113 = method & 0xdf;
        }
        if(_t113 == 66) {
            a = decodeB( &w);
            goto L18;
        } else {
            if(_t113 == 81) {
                a = decodeQ( &w);
L18:
                if(p == w) {
                    goto L27;
                }
                if(( *w & 255) == 63) {
                    w =  &(w[1]);
                    if(( *w & 255) == 61) {
                        w =  &(w[1]);
                    }
                }
                 *ow = w;
                 *charset = c;
                return a;
            }
            goto L27;
        }
    }
}

Str decodeMIME(Str orgstr, wc_ces* charset)
{// addr = 0x080A51E0  --  defined in 'mimehead.c' at line 265
    char* org;                             // _cfa_fffffff0
    char* endp;                            // _cfa_ffffffec
    char* org0;                            // _cfa_ffffffe8
    char* p;                               // _cfa_ffffffe4
    Str cnv;               // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    int _t85;                              // _t85
    signed int _t104;                      // _t104

    org = orgstr->ptr;
    endp =  &(org[orgstr->length]);
    cnv = 0;
     *charset = 0;
L25:
    while(org < endp) {
        if(( *org & 255) != 61 || (org[1] & 255) != 63) {
            if(cnv != 0) {
                if(cnv->length + 1 >= cnv->area_size) {
                    Strgrow(cnv);
                }
                _t85 = cnv->length;
                 *((char*)(cnv->ptr + _t85)) =  *org & 255;
                cnv->length = _t85 + 1;
                 *((char*)(cnv->ptr + cnv->length)) = 0;
            }
            org =  &(org[1]);
            continue;
        } else {
            if(cnv == 0) {
                cnv = Strnew_size(orgstr->length);
                Strcat_charp_n(cnv, orgstr->ptr, org - orgstr->ptr);
            }
            while(1) {
L5:
                p = org;
                Strcat(cnv, decodeWord( &org, charset));
                if(org == p) {
                    break;
                }
                org0 = org;
                while(1) {
                    _t104 =  *org0 & 255;
                    if(_t104 == 13) {
                        goto L15;
                    }
L9:
                    if(_t104 > 13) {
                        if(_t104 == 32) {
                            goto L15;
                        }
                        if(_t104 == 61) {
                            if((org0[1] & 255) != 63) {
                                goto L25;
                            }
                            org = org0;
                            goto L5;
                        }
                        goto L25;
                    }
                    if(_t104 - 9 > 1) {
                        goto L25;
                    }
L15:
                    org0 =  &(org0[1]);
                    _t104 =  *org0 & 255;
                    if(_t104 == 13) {
                        goto L15;
                    }
                    goto L9;
                }
            }
            Strcat_charp(cnv, org);
            return cnv;
        }
    }
    if(cnv != 0) {
        return cnv;
    }
    return orgstr;
}

Str encodeB(char* a)
{// addr = 0x080A5389  --  defined in 'mimehead.c' at line 326
    unsigned char c1;                      // _cfa_fffffff3
    unsigned char c2;                      // _cfa_fffffff2
    unsigned char c3;                      // _cfa_fffffff1
    unsigned char c4;                      // _cfa_fffffff0
    signed int _v17;                       // _cfa_ffffffef
    signed int _v18;                       // _cfa_ffffffee
    unsigned char[2] d;                    // _cfa_ffffffed
    int i;                                 // _cfa_ffffffe8
    int n_pad;                             // _cfa_ffffffe4
    Str w;                 // _cfa_ffffffe0
    int _t147;                             // _t147
    int _t159;                             // _t159
    int _t171;                             // _t171
    int _t183;                             // _t183

    w = Strnew();
    while(( *a & 255) != 0) {
        n_pad = 0;
        _v17 = 0;
        _v18 = _v17 & 255;
        i = 0;
        while(i <= 2) {
             *((char*)(__ebp + i - 15)) = a[i] & 255;
            if((a[i] & 255) != 0) {
                i = i + 1;
                continue;
            }
            n_pad = 3 - i;
            break;
        }
        c1 = (d & 255) >> 2;
        c2 = ((_v18 & 255) >> 4 | (d & 0xff) << 4) & 63;
        if(n_pad != 2) {
            if(n_pad != 1) {
                c3 = ((_v17 & 255) >> 6 | (_v18 & 0xff) << 2) & 63;
                c4 = _v17 & 0x3f;
            } else {
                c3 = (_v18 & 0xff) << 2 & 63;
                c4 = 64;
            }
        } else {
            c4 = 64;
            c3 = c4 & 255;
        }
        if(w->length + 1 >= w->area_size) {
            Strgrow(w);
        }
        _t147 = w->length;
         *((char*)(w->ptr + _t147)) =  *((c1 & 255) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=") & 255;
        w->length = _t147 + 1;
         *((char*)(w->ptr + w->length)) = 0;
        if(w->length + 1 >= w->area_size) {
            Strgrow(w);
        }
        _t159 = w->length;
         *((char*)(w->ptr + _t159)) =  *((c2 & 255) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=") & 255;
        w->length = _t159 + 1;
         *((char*)(w->ptr + w->length)) = 0;
        if(w->length + 1 >= w->area_size) {
            Strgrow(w);
        }
        _t171 = w->length;
         *((char*)(w->ptr + _t171)) =  *((c3 & 255) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=") & 255;
        w->length = _t171 + 1;
         *((char*)(w->ptr + w->length)) = 0;
        if(w->length + 1 >= w->area_size) {
            Strgrow(w);
        }
        _t183 = w->length;
         *((char*)(w->ptr + _t183)) =  *((c4 & 255) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=") & 255;
        w->length = _t183 + 1;
         *((char*)(w->ptr + w->length)) = 0;
        if(n_pad != 0) {
L24:
            return w;
        } else {
            a =  &(a[3]);
            continue;
        }
    }
    goto L24;
}

longchar set_longchar(char* str)
{// addr = 0x080A55D8  --  defined in 'regex.c' at line 77
    _unknown_ _v8;                         // _cfa_fffffff8
    unsigned char* p;                      // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    longchar r;       // _cfa_ffffffe0
    signed int _v48;                       // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    unsigned char** _v72;                  // _cfa_ffffffb8
    struct  _t85;             // _t85

    _push(__ebx);
    __esp = __esp - 68;
    _t85 = str;
    p =  *(__ebp + 12);
    if(( *p & 255) >= 0) {
        _v20 =  *p & 255;
        r.auto_detect = 1;
         *_t85 = r.auto_detect;
         *(_t85 + 4) = _v28;
         *(_t85 + 8) = _v24;
         *((intOrPtr*)(_t85 + 12)) = _v20;
L13:
        return _t85;
    }
    _v72 =  &p;
    wtf_parse1( &_v52);
    __esp = __esp - 4;
    _v28 = _v52;
    _v24 = _v48;
    if(_v28 == 2048 || _v28 == 34816) {
        r.auto_detect = 4;
         *_t85 = r.auto_detect;
         *(_t85 + 4) = _v28;
         *(_t85 + 8) = _v24;
         *((intOrPtr*)(_t85 + 12)) = _v20;
        goto L13;
    } else {
        if((_v28 & 65535) == 4096 || (_v28 & 65535) == 8192 || (_v28 & 65535) == 8193) {
            if((_v28 & 65535) == 8193) {
                _v24 = _v24 & 2097151;
            }
            _v28 = 8192;
            goto L11;
        } else {
            _v28 = _v28 & 65535;
L11:
            r.auto_detect = 2;
             *_t85 = r.auto_detect;
             *(_t85 + 4) = _v28;
             *(_t85 + 8) = _v24;
             *((intOrPtr*)(_t85 + 12)) = _v20;
            goto L13;
        }
    }
}

char* regexCompile(char* ex, int igncase)
{// addr = 0x080A56F0  --  defined in 'regex.c' at line 121
    char* msg;                             // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    newRegex(ex, igncase,  &DefaultRegex,  &msg);
    return msg;
}

Regex* newRegex0(char** ex, int igncase, Regex* regex, char** msg, int level)
{// addr = 0x080A571C  --  defined in 'regex.c' at line 129
    longchar* r;      // _cfa_ffffffec
    int m;                                 // _cfa_ffffffe4
    _unknown_ _v8;                         // _cfa_fffffff8
    char* p;                               // _cfa_fffffff0
    regexchar* re;   // _cfa_ffffffe8
    longchar* st_ptr;   // _cfa_ffffffe0
    unsigned char _v48;                    // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    unsigned char _v56;                    // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    char* _v88;                            // _cfa_ffffffa8
    Regex* _t99;         // _t99
    longchar* _t116;   // _t116

    _push(__ebx);
    __esp = __esp - 84;
    if(regex == 0) {
         *__esp = 4620;
        GC_malloc();
        regex = __eax;
    }
    regex->alt_regex = 0;
    re = regex;
    st_ptr = regex + 512;
    p =  *ex;
    while(( *p & 255) != 0) {
        re->mode = 0;
        if(( *p & 255) - 36 > 88) {
            _t116 = st_ptr;
            _v88 = p;
            __eax = set_longchar( &_v60);
            __esp = __esp - 4;
            _t116->type = _v60;
            _t116->wch = _v56;
            _t116->wch.code = _v52;
            _t116->ch = _v48;
            p =  &(p[( *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff) - 1]);
            re->p = st_ptr;
            st_ptr = st_ptr + 16;
            re->mode = re->mode & 0xf8;
            if(igncase != 0) {
                re->mode = re->mode & 255 | 64;
            }
            re = re + 8;
            if( &(regex->position) <= st_ptr || regex + 512 <= re) {
                if(msg != 0) {
                     *msg = "Regular expression too long";
                }
                _t99 = 0;
L17:
                return _t99;
            } else {
                p =  &(p[1]);
                continue;
            }
        }
        goto __eax;
    }
    re->mode = re->mode & 255 | 7;
    if(msg != 0) {
         *msg = 0;
    }
     *ex = p;
    _t99 = regex;
    goto L17;
}

Regex* newRegex(char* ex, int igncase, Regex* regex, char** msg)
{// addr = 0x080A5D6B  --  defined in 'regex.c' at line 285
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    return newRegex0( &ex, igncase, regex, msg, 0);
}

int regexMatch(char* str, int len, int firstp)
{// addr = 0x080A5D9B  --  defined in 'regex.c' at line 294
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return RegexMatch( &DefaultRegex, str, len, firstp);
}

int RegexMatch(Regex* re, char* str, int len, int firstp)
{// addr = 0x080A5DC4  --  defined in 'regex.c' at line 300
    char* p;                               // _cfa_fffffff0
    char* ep;                              // _cfa_ffffffec
    char* lpos;                            // _cfa_ffffffe8
    Regex* r;            // _cfa_ffffffe4
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    int _t62;                              // _t62
    int _t65;                              // _t65
    int _t87;                              // _t87

    if(str == 0) {
        return 0;
    }
    if(len < 0) {
        _t87 = str;
         *__esp = _t87;
        strlen();
        len = _t87;
    }
    re->position = 0;
    ep =  &(str[len]);
    p = str;
    while(p <= ep) {
        lpos = 0;
        re->lposition = 0;
        r = re;
        while(r != 0) {
            if(firstp == 0 || p != str) {
                _t62 = 0;
            } else {
                _t62 = 1;
            }
            _t65 = regmatch(r, p, ep, _t62,  &lpos);
            if(_t65 == -1) {
                re->position = 0;
                return -1;
            } else {
                if(_t65 == 1) {
                    re->position = p;
                    if(re->lposition == 0 || re->lposition < lpos) {
                        re->lposition = lpos;
                    }
                }
                r = r->alt_regex;
                continue;
            }
        }
        if(re->lposition == 0) {
            p =  &(p[( *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff) - 1]);
            p =  &(p[1]);
            continue;
        }
        return 1;
    }
    return 0;
}

void MatchedPosition(Regex* re, char** first, char** last)
{// addr = 0x080A5F1C  --  defined in 'regex.c' at line 340
     *first = re->position;
     *last = re->lposition;
}

void matchedPosition(char** first, char** last)
{// addr = 0x080A5F3D  --  defined in 'regex.c' at line 347
     *first =  *135789440;
     *last =  *135789444;
}

int regmatch_sub_anytime(struct MatchingContext2* c, Regex* regex, regexchar* pat2, char* str, char* end_p, int iter_limit, int firstp)
{// addr = 0x080A5F58  --  defined in 'regex.c' at line 389
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    struct MatchingContext1* _t107;   // _t107
    struct MatchingContext2* _t108;   // _t108

    _t107 = c->label;
    if(_t107 == 2) {
L12:
        if(iter_limit == 1) {
L20:
            while(regmatch_iter(c->ctx, c->regex, c->str, end_p, c->firstp) != 0) {
                c->n_any = c->ctx->lastpos - c->str;
                if(c->n_any <= 0) {
                    continue;
                }
                c->firstp = 0;
                if((pat2->mode & 7) != 7) {
                    if(regmatch(pat2,  &(c->str[c->n_any]), end_p, c->firstp,  &(c->lastpos)) != 1) {
                        goto L12;
                    }
                    c->label = 2;
                    return 1;
                }
                c->lastpos =  &(c->str[c->n_any]);
                c->label = 1;
                return 1;
            }
            if(c->regex->alt_regex != 0) {
                c->regex = c->regex->alt_regex;
L5:
                c->ctx->label = 0;
                goto L20;
            }
            return 0;
        }
        c->ctx2->label = 0;
L16:
        if(regmatch_sub_anytime(c->ctx2, regex, pat2,  &(c->str[c->n_any]), end_p, iter_limit - 1, c->firstp) != 0) {
            c->lastpos = c->ctx2->lastpos;
            c->label = 3;
            return 1;
        }
        goto L20;
    }
    if(_t107 == 3) {
        goto L16;
    }
    if(_t107 != 1) {
         *__esp = 44;
        GC_malloc();
        _t108 = c;
        _t108->ctx = _t107;
         *__esp = 32;
        GC_malloc();
        c->ctx2 = _t108;
        c->ctx->label = 0;
        c->regex = regex;
        c->n_any = 0;
        c->str = str;
        c->firstp = firstp;
        goto L5;
    }
    goto L12;
}

int regmatch_iter(struct MatchingContext1* c, regexchar* re, char* str, char* end_p, int firstp)
{// addr = 0x080A61A6  --  defined in 'regex.c' at line 442
    longchar k;       // _cfa_ffffffd4
    char _v16;                             // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    longchar k;       // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    _unknown_ _v84;                        // _cfa_ffffffac (outparam)
    _unknown_ _v88;                        // _cfa_ffffffa8 (outparam)
    _unknown_ _v92;                        // _cfa_ffffffa4 (outparam)
    _unknown_ _v96;                        // _cfa_ffffffa0 (outparam)
    _unknown_ _v100;                       // _cfa_ffffff9c (outparam)
    char* _v104;                           // _cfa_ffffff98 (outparam)
    _unknown_ _v108;                       // _cfa_ffffff94 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    signed int _t312;                      // _t312
    int _t321;                             // _t321
    struct MatchingContext1* _t333;   // _t333
    struct MatchingContext2* _t439;   // _t439

    __esp = __esp - 92;
    if(c->label <= 7) {
        goto __eax;
    }
    if((re->mode & 7) != 7) {
        c->re = re;
        c->firstp = firstp;
        c->str = str;
        c->end_p = end_p;
        c->sub_ctx = 0;
        c->lastpos = 0;
        while((c->re->mode & 7) != 7) {
            if((c->re->mode & 0x18) == 0) {
                _t312 = c->re->mode & 7;
                if(_t312 == 5) {
                    if(c->firstp != 0) {
                        c->re = c->re + 8;
                        goto L55;
                    } else {
                        _t321 = 0;
                    }
                } else {
                    if(_t312 == 6) {
                        if(c->str < c->end_p) {
                            c->lastpos = 0;
                            _t321 = 0;
                        } else {
                            c->lastpos = c->str;
                            c->re = c->re + 8;
                            c->label = 4;
                            _t321 = 1;
                        }
                    } else {
                        if(_t312 == 4) {
                            _t333 = c->sub_ctx;
                            if(_t333 == 0) {
                                 *__esp = 44;
                                GC_malloc();
                                c->sub_ctx = _t333;
                            }
                            c->sub_regex = c->re->p;
                            while(1) {
                                c->sub_ctx->label = 0;
                                while(regmatch_iter(c->sub_ctx, c->sub_regex, c->str, c->end_p, c->firstp) != 0) {
                                    if(c->sub_ctx->lastpos != c->str) {
                                        c->firstp = 0;
                                    }
                                    if(( *(c->re + 0xc) & 7) != 7) {
                                        if(regmatch(c->re + 8, c->sub_ctx->lastpos, c->end_p, c->firstp,  &(c->lastpos)) != 1) {
                                            continue;
                                        } else {
                                            c->label = 6;
                                            _t321 = 1;
                                        }
                                    } else {
                                        c->lastpos = c->sub_ctx->lastpos;
                                        c->label = 5;
                                        _t321 = 1;
                                    }
                                    goto L59;
                                }
                                if(c->sub_regex->alt_regex != 0) {
                                    c->sub_regex = c->sub_regex->alt_regex;
                                    continue;
                                } else {
                                    _t321 = 0;
                                }
                                goto L59;
                            }
                        } else {
                            _v104 = c->str;
                            __eax = set_longchar( &_v60);
                            __esp = __esp - 4;
                            k.auto_detect = _v60;
                            _v40 = _v56;
                            _v36 = _v52;
                            _v32 = _v48;
                            c->str =  &(c->str[ *( &WTF_LEN_MAP + (c & 0xff)) & 0xff]);
                            if(regmatch1(c->re,  &k) != 0) {
                                c->re = c->re + 8;
                                c->firstp = 0;
L55:
                                if(c->str <= c->end_p) {
                                    continue;
                                } else {
                                    _t321 = 0;
                                }
                            } else {
                                _t321 = 0;
                            }
                        }
                    }
                }
            } else {
                if((c->re->mode & 0x10) == 0) {
                    c->iter_limit = 1;
                } else {
                    c->iter_limit = 65535;
                }
                c->n_any = -1;
                while(c->n_any < c->iter_limit) {
                    if( &(c->str[c->n_any]) < c->end_p) {
                        if(c->n_any < 0) {
                            c->n_any =  &(c->n_any->p);
                            goto L22;
                        } else {
                            _t439 = c->re->mode & 7;
                            if(_t439 != 4) {
                                _v104 =  &(c->str[c->n_any]);
                                __eax = set_longchar( &_v60);
                                __esp = __esp - 4;
                                k.auto_detect = _v60;
                                _v40 = _v56;
                                _v36 = _v52;
                                _v32 = _v48;
                                if(regmatch1(c->re,  &k) == 0) {
                                    _t321 = 0;
                                } else {
                                    c->n_any = c->n_any + ( *( &WTF_LEN_MAP + (c->str[c->n_any] & 0xff)) & 0xff);
                                    c->firstp = 0;
L22:
                                    if(( *(c->re + 0xc) & 7) != 7) {
                                        if(regmatch(c->re + 8,  &(c->str[c->n_any]), c->end_p, c->firstp,  &(c->lastpos)) != 1) {
                                            continue;
                                        } else {
                                            c->label = 3;
                                            _t321 = 1;
                                        }
                                    } else {
                                        c->lastpos =  &(c->str[c->n_any]);
                                        c->label = 2;
                                        _t321 = 1;
                                    }
                                }
                            } else {
                                 *__esp = 32;
                                GC_malloc();
                                c->ctx2 = _t439;
                                c->ctx2->label = 0;
                                _v64 =  &(c->str[c->n_any]);
                                if(regmatch_sub_anytime(c->ctx2, c->re->p, c->re + 8, _v64, c->end_p, c->iter_limit, c->firstp) != 0) {
                                    c->n_any = c->ctx2->lastpos - c->str;
                                    c->lastpos = c->ctx2->lastpos;
                                    c->label = 1;
                                    _t321 = 1;
                                } else {
                                    _t321 = 0;
                                }
                            }
                        }
                    } else {
                        _t321 = 0;
                    }
                    goto L59;
                }
                _t321 = 0;
            }
            goto L59;
        }
        c->lastpos = c->str;
        c->label = 7;
        _t321 = 1;
    } else {
        _t321 = 0;
    }
L59:
     &_v16 =  &_v16;
    return _t321;
}

int regmatch(regexchar* re, char* str, char* end_p, int firstp, char** lastpos)
{// addr = 0x080A67D2  --  defined in 'regex.c' at line 590
    _unknown_ _v48;                        // _cfa_ffffffd0
    struct MatchingContext1 contx;   // _cfa_ffffffc8
    _unknown_ _v76;                        // _cfa_ffffffb4 (outparam)
    _unknown_ _v80;                        // _cfa_ffffffb0 (outparam)
    _unknown_ _v84;                        // _cfa_ffffffac (outparam)
    _unknown_ _v88;                        // _cfa_ffffffa8 (outparam)

     *lastpos = 0;
    contx.label = 0;
    do {
    } while(regmatch_iter( &(contx.label), re, str, end_p, firstp) != 0);
    if( *lastpos != 0) {
        return 1;
    }
    return 0;
}

int regmatch1(regexchar* re, longchar* c)
{// addr = 0x080A6849  --  defined in 'regex.c' at line 617
    int ans;                               // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    signed int _t29;                       // _t29

    if((c->type & 255) != 4) {
        _t29 = re->mode & 7;
        if(_t29 == 1) {
            return 1;
        }
        if(_t29 > 1) {
            if(_t29 == 2) {
                return matchWhich(re->p, c, re->mode & 0x40);
            }
            if(_t29 == 3) {
                return matchWhich(re->p, c, re->mode & 0x40) == 0 & 255;
            }
L13:
            return 0;
        }
        if(_t29 == 0) {
            ans = match_longchar(re->p, c, re->mode & 0x40);
            return ans;
        }
        goto L13;
    }
    return 0;
}

int matchWhich(longchar* pattern, longchar* c, int igncase)
{// addr = 0x080A692C  --  defined in 'regex.c' at line 649
    longchar* p;      // _cfa_fffffff0
    int ans;                               // _cfa_ffffffec
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    p = pattern;
    ans = 0;
    while((p->type & 255) != 0) {
        if(( *(p + 16) & 255) != 3 || ( *(p + 32) & 255) == 0) {
            if(match_longchar(p, c, igncase) == 0) {
                p = p + 16;
                continue;
            }
            ans = 1;
        } else {
            if(match_range_longchar(p, p + 32, c, igncase) == 0) {
                p = p + 48;
                continue;
            }
            ans = 1;
        }
        break;
    }
    return ans;
}

int match_longchar(longchar* a, longchar* b, int ignore)
{// addr = 0x080A69CE  --  defined in 'regex.c' at line 682
    signed int _t64;                       // _t64
    int _t65;                              // _t65
    signed int _t76;                       // _t76
    int _t86;                              // _t86
    signed int _t93;                       // _t93
    signed int _t94;                       // _t94

    if((a->type & 255) != (b->type & 255)) {
        return 0;
    }
    if((a->type & 255) != 2) {
        if(ignore == 0 || ( *( &MYCTYPE_MAP + (b->ch.ccs & 0xff)) & 4) == 0) {
            return (a->ch.ccs & 255) == (b->ch.ccs & 255) & 255;
        } else {
            _t93 = a->ch.ccs & 0xff;
            if(( *( &MYCTYPE_MAP + (b->ch.ccs & 0xff)) & 4) == 0) {
                _t64 = b->ch.ccs & 0xff;
            } else {
                _t64 = (b->ch.ccs & 255 | 32) & 255;
            }
            if(_t93 == _t64) {
L18:
                _t65 = 1;
                goto L20;
            } else {
                _t94 = a->ch.ccs & 0xff;
                if(( *( &MYCTYPE_MAP + (b->ch.ccs & 0xff)) & 4) == 0) {
                    _t76 = b->ch.ccs & 0xff;
                } else {
                    _t76 = b->ch.ccs & 0xdf;
                }
                if(_t94 != _t76) {
                    _t65 = 0;
L20:
                    return _t65;
                }
                goto L18;
            }
        }
    } else {
        if(a->wch.ccs != b->wch.ccs || a->wch.code != b->wch.code) {
            _t86 = 0;
        } else {
            _t86 = 1;
        }
        return _t86;
    }
}

int match_range_longchar(longchar* a, longchar* b, longchar* c, int ignore)
{// addr = 0x080A6AF9  --  defined in 'regex.c' at line 697
    signed int _t103;                      // _t103
    signed int _t114;                      // _t114
    int _t115;                             // _t115
    signed int _t124;                      // _t124
    signed int _t139;                      // _t139
    int _t149;                             // _t149
    signed int _t163;                      // _t163
    signed int _t164;                      // _t164

    if((a->type & 255) != (b->type & 255) || (a->type & 255) != (c->type & 255)) {
        return 0;
    }
    if((a->type & 255) != 2) {
        if(ignore == 0 || ( *( &MYCTYPE_MAP + (c->ch.ccs & 0xff)) & 4) == 0) {
            if((a->ch.ccs & 255) > (c->ch.ccs & 255) || (c->ch.ccs & 255) > (b->ch.ccs & 255)) {
                return 0;
            } else {
                return 1;
            }
        } else {
            _t163 = a->ch.ccs & 0xff;
            if(( *( &MYCTYPE_MAP + (c->ch.ccs & 0xff)) & 4) == 0) {
                _t103 = c->ch.ccs & 0xff;
            } else {
                _t103 = (c->ch.ccs & 255 | 32) & 255;
            }
            if(_t163 > _t103) {
L21:
                _t164 = a->ch.ccs & 0xff;
                if(( *( &MYCTYPE_MAP + (c->ch.ccs & 0xff)) & 4) == 0) {
                    _t114 = c->ch.ccs & 0xff;
                } else {
                    _t114 = c->ch.ccs & 0xdf;
                }
                if(_t164 > _t114) {
L30:
                    _t115 = 0;
                    goto L31;
                } else {
                    if(( *( &MYCTYPE_MAP + (c->ch.ccs & 0xff)) & 4) == 0) {
                        _t124 = c->ch.ccs & 0xff;
                    } else {
                        _t124 = c->ch.ccs & 0xdf;
                    }
                    if(_t124 > (b->ch.ccs & 0xff)) {
                        goto L30;
                    }
L29:
                    _t115 = 1;
L31:
                    return _t115;
                }
            }
            if(( *( &MYCTYPE_MAP + (c->ch.ccs & 0xff)) & 4) == 0) {
                _t139 = c->ch.ccs & 0xff;
            } else {
                _t139 = (c->ch.ccs & 255 | 32) & 255;
            }
            if(_t139 <= (b->ch.ccs & 0xff)) {
                goto L29;
            } else {
                goto L21;
            }
        }
    } else {
        if(a->wch.ccs != c->wch.ccs || c->wch.ccs != b->wch.ccs || a->wch.code > c->wch.code) {
L9:
            _t149 = 0;
            goto L10;
        } else {
            if(c->wch.code > b->wch.code) {
                goto L9;
            } else {
                _t149 = 1;
L10:
                return _t149;
            }
        }
    }
}

void KeyAbort(int _dummy)
{// addr = 0x080A6CF8  --  defined in 'news.c' at line 29
    intOrPtr _v0;                          // _cfa_0
    struct _Str* _v20;    // _cfa_ffffffec
    int _v24;                              // _cfa_ffffffe8
    intOrPtr _v60;                         // _cfa_ffffffc4
    int _v64;                              // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    _unknown_ _t64;                        // _t64

    _v24 = 1;
     *__esp =  &AbortLoading;
    siglongjmp();
    _push(_t64);
    __esp = __esp - 40;
    if( *_v24 != 0) {
        if(_dummy != 0) {
            if(_a8 == 0) {
                _v68 = _dummy;
                _v20 = Sprintf("%s\n");
            } else {
                _v64 = _a8;
                _v68 = _dummy;
                _v20 = Sprintf("%s %s\n");
            }
            _v60 =  *((intOrPtr*)(_v0 + 16));
            _v64 = _v20->length;
            _v68 = 1;
             *__esp =  *_v20;
            fwrite();
             *__esp =  *((intOrPtr*)(_v0 + 16));
            fflush();
        }
        if(_a12 != 0) {
             *_a12 = -1;
            _v20 = StrISgets( *(_v0 + 12));
            if(_v20->length != 0) {
                _v64 = _a12;
                _v68 = "%d";
                 *__esp =  *_v20;
                sscanf();
            }
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}

Str news_command(News* news, char* cmd, char* arg, int* status)
{// addr = 0x080A6D12  --  defined in 'news.c' at line 36
    Str tmp;               // _cfa_fffffff0
    FILE* _v32;           // _cfa_ffffffe0
    int* _v36;                             // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8

    if(news->host != 0) {
        if(cmd != 0) {
            if(arg == 0) {
                _v40 = cmd;
                tmp = Sprintf("%s\n");
            } else {
                _v36 = arg;
                _v40 = cmd;
                tmp = Sprintf("%s %s\n");
            }
            _v32 = news->wf;
            _v36 = tmp->length;
            _v40 = 1;
             *__esp = tmp->ptr;
            fwrite();
             *__esp = news->wf;
            fflush();
        }
        if(status != 0) {
             *status = -1;
            tmp = StrISgets(news->rf);
            if(tmp->length != 0) {
                _v36 = status;
                _v40 = "%d";
                 *__esp = tmp->ptr;
                sscanf();
            }
            return tmp;
        } else {
            return 0;
        }
    }
    return 0;
}

void news_close(News* news)
{// addr = 0x080A6DF8  --  defined in 'news.c' at line 60
    if(news->host != 0) {
        if(news->rf != 0) {
             *(news->rf + 20) =  *(news->rf + 20) & 0xef;
            ISclose(news->rf);
            news->rf = 0;
        }
        if(news->wf != 0) {
             *__esp = news->wf;
            fclose();
            news->wf = 0;
        }
        news->host = 0;
        return;
    }
}

int news_open(News* news)
{// addr = 0x080A6E6F  --  defined in 'news.c' at line 77
    int sock;                              // _cfa_fffffff0
    int status;                            // _cfa_ffffffec
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    FILE* _t53;           // _t53

    sock = openSocket(news->host, "nntp", news->port & 65535);
    if(sock < 0) {
L12:
        news_close(news);
        return 0;
    }
    news->rf = newInputStream(sock);
    _t53 = sock;
     *__esp = _t53;
    dup();
    _v40 = "wb";
     *__esp = _t53;
    fdopen();
    news->wf = _t53;
    if(news->rf == 0 || news->wf == 0) {
        goto L12;
    } else {
         *(news->rf + 20) =  *(news->rf + 20) & 255 | 16;
        news_command(news, 0, 0,  &status);
        if(status == 200 || status == 201) {
            if(news->mode == 0) {
L8:
                return 1;
            }
            news_command(news, "MODE", news->mode,  &status);
            if(status == 200 || status == 201) {
                goto L8;
            } else {
                goto L12;
            }
        } else {
            goto L12;
        }
    }
}

void news_quit(News* news)
{// addr = 0x080A6FA0  --  defined in 'news.c' at line 104
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    news_command(news, "QUIT", 0, 0);
    news_close(news);
}

char* name_from_address(char* str, int n)
{// addr = 0x080A6FD6  --  defined in 'news.c' at line 111
    char* s;                               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    int l;                                 // _cfa_ffffffe8
    int space;                             // _cfa_ffffffe4
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    char* _t84;                            // _t84
    char* _t85;                            // _t85
    signed int _t105;                      // _t105
    char* _t119;                           // _t119
    char* _t122;                           // _t122
    char* _t126;                           // _t126

    space = 1;
    s = allocStr(str, -1);
    do {
    } while(( *s & 255) != 0 && ( *( &MYCTYPE_MAP + ( *s & 0xff)) & 2) != 0);
    if(( *s & 255) != 60) {
L13:
        _v40 = 60;
        _t84 = s;
         *__esp = _t84;
        strchr();
        p = _t84;
        if(p == 0) {
            _v40 = 40;
            _t85 = s;
             *__esp = _t85;
            strchr();
            p = _t85;
            if(p != 0) {
                s = p;
            }
        } else {
             *p = 0;
        }
L17:
        if(( *s & 255) != 34) {
L20:
            if(( *s & 255) == 40) {
                _t119 =  &(s[1]);
                _v40 = 41;
                 *__esp = _t119;
                strchr();
                p = _t119;
                if(p != 0) {
                     *p = 0;
                    s =  &(s[1]);
                }
            }
L23:
            p = s;
            l = 0;
            while(( *p & 255) != 0) {
                if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
                    space = 0;
L28:
                    if(( *135119023 & 255) == 0) {
                        _t105 = ( *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 255) != 0 & 255;
                    } else {
                        _t105 =  *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 0xff;
                    }
                    l = l + _t105;
                    if(l > n) {
L38:
                         *p = 0;
                        return s;
                    } else {
L34:
                        p =  &(p[ *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff]);
                        continue;
                    }
                }
                if(space != 0) {
                    goto L34;
                }
                space = 1;
                goto L28;
            }
            goto L38;
        }
        _t122 =  &(s[1]);
        _v40 = 34;
         *__esp = _t122;
        strchr();
        p = _t122;
        if(p == 0) {
            goto L20;
        } else {
             *p = 0;
            s =  &(s[1]);
            goto L23;
        }
    }
    _v40 = 62;
    _t126 = s;
     *__esp = _t126;
    strchr();
    p = _t126;
    if(p == 0) {
        goto L13;
    } else {
         *p = 0;
        p =  &(p[1]);
        goto L8;
        do {
        } while();
        goto L17;
L8:
        if(( *p & 255) == 0 || ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
            if(( *p & 255) != 0) {
                s = p;
            } else {
                s =  &(s[1]);
            }
        } else {
            p =  &(p[1]);
            goto L8;
        }
        goto L17;
    }
}

char* html_quote_s(char* str)
{// addr = 0x080A71FD  --  defined in 'news.c' at line 155
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    int space;                             // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t72;                              // _t72

    tmp = 0;
    space = 1;
    p = str;
    while(( *p & 255) != 0) {
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
            q =  *( &HTML_QUOTE_MAP + ( *( &QUOTE_MAP + ( *p & 0xff)) & 7) * 4);
            space = 0;
L5:
            if(q == 0) {
                if(tmp != 0) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t72 = tmp->length;
                     *((char*)(tmp->ptr + _t72)) =  *p & 255;
                    tmp->length = _t72 + 1;
                     *((char*)(tmp->ptr + tmp->length)) = 0;
                }
            } else {
                if(tmp == 0) {
                    tmp = Strnew_charp_n(str, p - str);
                }
                Strcat_charp(tmp, q);
            }
L14:
            p =  &(p[1]);
            continue;
        }
        if(space != 0) {
            goto L14;
        } else {
            q = "&nbsp;";
            space = 1;
            goto L5;
        }
    }
    if(tmp == 0) {
        return str;
    }
    return tmp->ptr;
}

void add_news_message(Str str, int index, char* date, char* name, char* subject, char* mid, char* scheme, char* group)
{// addr = 0x080A7331  --  defined in 'news.c' at line 188
    time_t t;           // _cfa_fffffff0
    struct tm* tm;          // _cfa_ffffffec
    char* _v44;                            // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    int _t50;                              // _t50
    char* _t53;                            // _t53

    name = name_from_address(name, 16);
    t = mymktime(date);
     *__esp =  &t;
    localtime();
    tm =  &t;
    _v44 = html_quote_s(name);
    _v48 = tm->tm_mday;
    _v52 = tm->tm_mon + 1;
    _v56 = index;
    Strcat(str, Sprintf("<tr valign=top><td>%d<td nowrap>(%02d/%02d)<td nowrap>%s"));
    if(group == 0) {
        _t50 = html_quote(subject);
        _t53 = html_quote(file_quote(mid));
        _v48 = _t50;
        _v52 = _t53;
        _v56 = scheme;
        Strcat(str, Sprintf("<td><a href="%s%s">%s</a>\n"));
        return;
    }
    _v44 = html_quote(subject);
    _v48 = index;
    _v52 = group;
    _v56 = scheme;
    Strcat(str, Sprintf("<td><a href="%s%s/%d">%s</a>\n"));
}

InputStream openNewsStream(ParsedURL* pu)
{// addr = 0x080A7449  --  defined in 'news.c' at line 233
    char* host;                            // _cfa_fffffff0
    char* mode;                            // _cfa_ffffffec
    char* group;                           // _cfa_ffffffe8
    char* p;                               // _cfa_ffffffe4
    Str tmp;               // _cfa_ffffffe0
    int port;                              // _cfa_ffffffdc
    int status;                            // _cfa_ffffffd8
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    char* _t113;                           // _t113
    char* _t119;                           // _t119
    char* _t131;                           // _t131
    union input_stream* _t140;   // _t140
    char* _t144;                           // _t144
    char* _t146;                           // _t146
    char* _t155;                           // _t155
    int _t161;                             // _t161

    if(pu->file == 0 || (pu & 255) == 0) {
        return 0;
    }
    if(pu->scheme == 7) {
L5:
        host = pu->host;
        goto L7;
    } else {
        if(pu->scheme != 8) {
            host = NNTP_server;
L7:
            if(host == 0 || ( *host & 255) == 0) {
                if(current_news.host != 0) {
                    news_quit( &current_news);
                }
                return 0;
            }
            if(pu->scheme == 7 || pu->scheme == 8) {
L16:
                port = pu->port;
                goto L17;
            } else {
                _v56 = 58;
                _t155 = host;
                 *__esp = _t155;
                strchr();
                p = _t155;
                if(p == 0) {
                    goto L16;
                } else {
                    host = allocStr(host, p - host);
                    _t161 =  &(p[1]);
                     *__esp = _t161;
                    atoi();
                    port = _t161;
L17:
                    if(NNTP_mode == 0 || ( *NNTP_mode & 255) == 0) {
                        mode = 0;
                    } else {
                        mode = NNTP_mode;
                    }
                    if(current_news.host == 0) {
L33:
                        if(current_news.host != 0) {
L39:
                            if(pu->scheme == 7 || pu->scheme == 9) {
                                group = file_unquote(allocStr(pu->file, -1));
                                _v56 = 47;
                                _t113 = group;
                                 *__esp = _t113;
                                strchr();
                                p = _t113;
                                if(p != 0) {
                                     *p = 0;
                                    p =  &(p[1]);
                                    news_command( &current_news, "GROUP", group,  &status);
                                    if(status == 211) {
L47:
                                        _v56 = 64;
                                        _t119 = p;
                                         *__esp = _t119;
                                        strchr();
                                        if(_t119 == 0) {
                                            news_command( &current_news, "ARTICLE", p,  &status);
                                        } else {
                                            _v56 = p;
                                            news_command( &current_news, "ARTICLE",  *(Sprintf("<%s>")),  &status);
                                        }
                                        if(status == 220) {
                                            return  *135789484;
                                        } else {
                                            return 0;
                                        }
                                    }
                                    return 0;
                                }
                                _v56 = 64;
                                _t131 = group;
                                 *__esp = _t131;
                                strchr();
                                if(_t131 != 0) {
                                    p = group;
                                    goto L47;
                                }
                                return 0;
                            } else {
                                return 0;
                            }
                        }
                        current_news.host = allocStr(host, -1);
                         *135789476 = port;
                        if(mode == 0) {
                            _t140 = 0;
                        } else {
                            _t140 = allocStr(mode, -1);
                        }
                         *135789480 = _t140;
                        if(news_open( &current_news) != 0) {
                            goto L39;
                        } else {
                            return 0;
                        }
                    } else {
                        _t144 = current_news.host;
                        _v56 = host;
                         *__esp = _t144;
                        strcmp();
                        if(_t144 != 0 ||  *135789476 != port) {
                            news_quit( &current_news);
                        } else {
                            if(mode == 0) {
                                _t146 = "READER";
                            } else {
                                _t146 = mode;
                            }
                            tmp = news_command( &current_news, "MODE", _t146,  &status);
                            if(status != 200) {
                                if(status != 201) {
                                    news_close( &current_news);
                                }
                            }
                        }
                        goto L33;
                    }
                }
            }
        }
        goto L5;
    }
}

Str loadNewsgroup(ParsedURL* pu, wc_ces* charset)
{// addr = 0x080A779F  --  defined in 'news.c' at line 308
    _None page;                            // _cfa_ffffffe0
    Str tmp;               // _cfa_ffffffdc
    Buffer* buf;        // _cfa_ffffffd8
    char* qgroup;                          // _cfa_ffffffd4
    char* p;                               // _cfa_ffffffd0
    char* q;                               // _cfa_ffffffcc
    char* s;                               // _cfa_ffffffc8
    char* t;                               // _cfa_ffffffc4
    char* n;                               // _cfa_ffffffc0
    _None scheme;                          // _cfa_ffffffbc
    _None group;                           // _cfa_ffffffb8
    _None list;                            // _cfa_ffffffb4
    int status;                            // _cfa_ffffffb0
    int i;                                 // _cfa_ffffffac
    int first;                             // _cfa_ffffffa8
    int last;                              // _cfa_ffffffa4
    _None flag;                            // _cfa_ffffffa0
    _None start;                           // _cfa_ffffff9c
    _None end;                             // _cfa_ffffff98
    _None prevtrap;                        // _cfa_ffffff94
    wc_ces doc_charset;   // _cfa_ffffff90
    wc_ces mime_charset;   // _cfa_ffffff8c
    URLFile f;         // _cfa_ffffff6c
    _None _v160;                           // _cfa_ffffff60
    char* _v176;                           // _cfa_ffffff50 (outparam)
    _unknown_ _v180;                       // _cfa_ffffff4c (outparam)
    int _v184;                             // _cfa_ffffff48 (outparam)
    _unknown_ _v188;                       // _cfa_ffffff44 (outparam)
    _unknown_ _v192;                       // _cfa_ffffff40 (outparam)
    _unknown_ _v196;                       // _cfa_ffffff3c (outparam)
    _unknown_ _v200;                       // _cfa_ffffff38 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    char* _t432;                           // _t432
    char** _t440;                          // _t440
    _None _t442;                           // _t442
    char* _t449;                           // _t449
    char* _t484;                           // _t484
    int _t486;                             // _t486
    int _t489;                             // _t489
    char* _t518;                           // _t518
    char** _t523;                          // _t523
    char* _t536;                           // _t536
    int _t537;                             // _t537
    char* _t566;                           // _t566
    char* _t575;                           // _t575
    char* _t580;                           // _t580
    char* _t597;                           // _t597
    char* _t599;                           // _t599
    char* _t600;                           // _t600
    char* _t602;                           // _t602
    char* _t604;                           // _t604
    char* _t608;                           // _t608
    wc_ces* _t615;      // _t615
    wc_ces* _t625;      // _t625
    char* _t632;                           // _t632
    char* _t637;                           // _t637
    char* _t668;                           // _t668
    char* _t669;                           // _t669
    char* _t678;                           // _t678
    signed int _t685;                      // _t685
    int _t729;                             // _t729
    unsigned int _t743;                    // _t743
    unsigned int _t745;                    // _t745

    flag = 0;
    start = 0;
    end = 0;
    prevtrap = 0;
    doc_charset = DocumentCharset;
     *charset = 256;
    if(current_news.host == 0 || pu->file == 0) {
L3:
        return 0;
    } else {
        if((pu & 255) != 0) {
            group = allocStr(pu->file, -1);
            if(pu->scheme != 8) {
                scheme = 135067718;
            } else {
                scheme = 135067716;
            }
            _t432 = group;
            _v200 = 47;
             *__esp = _t432;
            strchr();
            list = _t432;
            if(list != 0) {
                _t685 = list;
                 *_t685 = 0;
                list =  &(1[_t685]);
            }
            if((fmInitialized & 255) != 0) {
                _v200 = group;
                message( *(Sprintf("Reading newsgroup %s...")), 0, 0);
                refresh();
            }
            qgroup = html_quote(group);
            group = file_unquote(group);
            _t440 = parsedURL2Str(pu);
            _v176 = 0;
            _v180 = "</h1>\n<hr>\n";
            _v184 = qgroup;
            _v188 = "</title>\n</head>\n<body>\n<h1>Newsgroup: ";
            _v192 = qgroup;
            _v196 = "">\n<title>Newsgroup: ";
            _v200 =  *_t440;
            _t442 = Strnew_m_charp("<html>\n<head>\n<base href="");
            page = _t442;
            _v200 = 1;
             *__esp =  &AbortLoading;
            __sigsetjmp();
            if(_t442 == 0) {
                if((TrapSignal & 255) != 0) {
                    prevtrap = mySignal(2, KeyAbort);
                    if((fmInitialized & 255) != 0) {
                        term_cbreak();
                    }
                }
                tmp = news_command( &current_news, "GROUP", group,  &status);
                if(status != 211) {
L108:
                    _v200 = group;
                    tmp = Sprintf("ACTIVE %s");
                    _t449 = group;
                    _v200 = 42;
                     *__esp = _t449;
                    strchr();
                    if(_t449 == 0) {
                        Strcat_charp(tmp, ".*");
                    }
                    news_command( &current_news, "LIST", tmp->ptr,  &status);
                    if(status != 215) {
                    } else {
                        while(1) {
                            tmp = StrISgets( *135789484);
                            if((tmp & 255) == 46 && ((tmp->ptr[1] & 255) == 10 || (tmp->ptr[1] & 255) == 13 || (tmp->ptr[1] & 255) == 0)) {
                                break;
                            }
                            if((tmp & 255) == 10 || (tmp & 255) == 13 || (tmp & 255) == 0) {
                                break;
                            } else {
                                if(flag <= 1) {
                                    if(flag == 1) {
                                        Strcat_charp(page, "<hr>\n");
                                    }
                                    Strcat_charp(page, "<table>\n");
                                    flag = 2;
                                }
                                p = tmp->ptr;
                                q = p;
                                while(( *q & 255) != 0 && ( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) == 0) {
                                    q =  &(q[1]);
                                }
                                 *q = 0;
                                q =  &(q[1]);
                                _t484 = q;
                                _v192 =  &first;
                                _v196 =  &last;
                                _v200 = "%d %d";
                                 *__esp = _t484;
                                sscanf();
                                if(_t484 != 2 || last < first) {
                                    i = 0;
                                } else {
                                    i =  &(1[last - first]);
                                }
                                _t486 = html_quote(p);
                                _t489 = html_quote(file_quote(p));
                                _v188 = _t486;
                                _v192 = _t489;
                                _v196 = scheme;
                                _v200 = i;
                                Strcat(page, Sprintf("<tr><td align=right>%d<td><a href="%s%s">%s</a>\n"));
                                continue;
                            }
                        }
                        if(flag == 2) {
                            Strcat_charp(page, "</table>\n");
                        }
                    }
                    goto L134;
                }
                _t518 = tmp->ptr;
                _v184 =  &last;
                _v188 =  &first;
                _v192 =  &i;
                _v196 =  &status;
                _v200 = "%d %d %d %d";
                 *__esp = _t518;
                sscanf();
                if(_t518 != 4) {
                    goto L108;
                } else {
                    if(list != 0 && ( *list & 255) != 0) {
                        _t668 = list;
                        _v200 = 45;
                         *__esp = _t668;
                        strchr();
                        p = _t668;
                        if(p != 0) {
                             *p = 0;
                            p =  &(p[1]);
                            _t678 = p;
                             *__esp = _t678;
                            atoi();
                            end = _t678;
                        }
                        _t669 = list;
                         *__esp = _t669;
                        atoi();
                        start = _t669;
                        if(start > 0) {
                            if(start < first) {
                                start = first;
                            }
                            if(end <= 0) {
                                end = start + MaxNewsMessage - 1;
                            }
                        }
                    }
                    if(start <= 0) {
                        start = first;
                        end = last;
                        if(end - start > MaxNewsMessage - 1) {
                            start =  &(1[end - MaxNewsMessage]);
                        }
                    }
                    _v160 = end;
                    _t523 = parsedURL2Str(pu);
                    _v176 = _v160;
                    _v180 = start;
                    _v184 = qgroup;
                    _v188 = end;
                    _v192 = start;
                    _v196 = qgroup;
                    _v200 =  *_t523;
                    page = Sprintf("<html>\n<head>\n<base href="%s">\n<title>Newsgroup: %s %d-%d</title>\n</head>\n<body>\n<h1>Newsgroup: %s %d-%d</h1>\n<hr>\n");
                    if(start > first) {
                        i = start - MaxNewsMessage;
                        if(i < first) {
                            i = first;
                        }
                        _v180 = start - 1;
                        _v184 = i;
                        _v188 = start - 1;
                        _v192 = i;
                        _v196 = qgroup;
                        _v200 = scheme;
                        Strcat(page, Sprintf("<a href="%s%s/%d-%d">[%d-%d]</a>\n"));
                    }
                    Strcat_charp(page, "<table>\n");
                    _v196 = end;
                    _v200 = start;
                    news_command( &current_news, "XOVER",  *(Sprintf("%d-%d")),  &status);
                    if(status != 224) {
                        init_stream( &f, 9,  *135789484);
                        _t729 = COLS;
                        if(showLineNum == 0) {
                            _t536 = 1;
                        } else {
                            _t536 = 6;
                        }
                        _t537 = _t729 - _t536;
                        _t538 = _t537 < 0 ? 0 : _t537;
                        buf = newBuffer(_t537 < 0 ? 0 : _t537);
                        i = start;
                        while(i <= end && i <= last) {
                            _v200 = i;
                            news_command( &current_news, "HEAD",  *(Sprintf("%d")),  &status);
                            if(status == 221) {
                                readHeader( &f, buf, 0, 0);
                                p = checkHeader(buf, "Message-ID:");
                                if(p != 0) {
                                    if(( *p & 255) == 60) {
                                        p =  &(p[1]);
                                    }
                                    _v200 = 62;
                                    _t566 = p;
                                     *__esp = _t566;
                                    strchr();
                                    q = _t566;
                                    if(q == 0) {
                                        _v200 = 9;
                                        _t580 = p;
                                         *__esp = _t580;
                                        strchr();
                                        q = _t580;
                                        if(q == 0) {
                                             *q = 0;
                                        }
                                    }
                                    s = checkHeader(buf, "Subject:");
                                    if(s != 0) {
                                        n = checkHeader(buf, "From:");
                                        if(n != 0) {
                                            t = checkHeader(buf, "Date:");
                                            if(t != 0) {
                                                if(pu->scheme != 8) {
                                                    _t575 = 0;
                                                } else {
                                                    _t575 = qgroup;
                                                }
                                                add_news_message(page, i, t, n, s, p, scheme, _t575);
                                            }
                                        }
                                    }
                                }
                            }
                            i =  &(1[i]);
                        }
                        goto L101;
                    } else {
                        f.auto_detect = 9;
                        while(1) {
                            tmp = StrISgets( *135789484);
                            if((tmp & 255) == 46 && ((tmp->ptr[1] & 255) == 10 || (tmp->ptr[1] & 255) == 13 || (tmp->ptr[1] & 255) == 0)) {
                                break;
                            }
                            if((tmp & 255) == 10 || (tmp & 255) == 13 || (tmp & 255) == 0) {
                                break;
                            } else {
                                _t597 = tmp->ptr;
                                _v196 =  &i;
                                _v200 = "%d";
                                 *__esp = _t597;
                                sscanf();
                                if(_t597 == 1) {
                                    _t599 = tmp->ptr;
                                    _v200 = 9;
                                     *__esp = _t599;
                                    strchr();
                                    s = _t599;
                                    if(s != 0) {
                                        s =  &(s[1]);
                                        _v200 = 9;
                                        _t600 = s;
                                         *__esp = _t600;
                                        strchr();
                                        n = _t600;
                                        if(n != 0) {
                                             *n = 0;
                                            n =  &(n[1]);
                                            _v200 = 9;
                                            _t602 = n;
                                             *__esp = _t602;
                                            strchr();
                                            t = _t602;
                                            if(t != 0) {
                                                 *t = 0;
                                                t =  &(t[1]);
                                                _v200 = 9;
                                                _t604 = t;
                                                 *__esp = _t604;
                                                strchr();
                                                p = _t604;
                                                if(p != 0) {
                                                     *p = 0;
                                                    p =  &(p[1]);
                                                    if(( *p & 255) == 60) {
                                                        p =  &(p[1]);
                                                    }
                                                    _v200 = 62;
                                                    _t608 = p;
                                                     *__esp = _t608;
                                                    strchr();
                                                    q = _t608;
                                                    if(q != 0) {
L58:
                                                         *q = 0;
                                                        tmp = decodeMIME(Strnew_charp(s),  &mime_charset);
                                                        if(mime_charset == 0) {
                                                            _t743 = doc_charset;
                                                        } else {
                                                            _t743 = mime_charset;
                                                        }
                                                        if(mime_charset == 0) {
                                                            _t615 = charset;
                                                        } else {
                                                            _t615 =  &mime_charset;
                                                        }
                                                        s =  *(convertLine( &f, tmp, 3, _t615, _t743));
                                                        tmp = decodeMIME(Strnew_charp(n),  &mime_charset);
                                                        if(mime_charset == 0) {
                                                            _t745 = doc_charset;
                                                        } else {
                                                            _t745 = mime_charset;
                                                        }
                                                        if(mime_charset == 0) {
                                                            _t625 = charset;
                                                        } else {
                                                            _t625 =  &mime_charset;
                                                        }
                                                        n =  *(convertLine( &f, tmp, 3, _t625, _t745));
                                                        if(pu->scheme != 8) {
                                                            _t632 = 0;
                                                        } else {
                                                            _t632 = qgroup;
                                                        }
                                                        add_news_message(page, i, t, n, s, p, scheme, _t632);
                                                    } else {
                                                        _v200 = 9;
                                                        _t637 = p;
                                                         *__esp = _t637;
                                                        strchr();
                                                        q = _t637;
                                                        if(q != 0) {
                                                            goto L58;
                                                        }
L74:
                                                    }
                                                    continue;
                                                }
                                                goto L74;
                                            }
                                            goto L74;
                                        }
                                        goto L74;
                                    }
                                    goto L74;
                                }
                                goto L74;
                            }
                        }
L101:
                        Strcat_charp(page, "</table>\n");
                        if(end < last) {
                            i = end + MaxNewsMessage;
                            if(i > last) {
                                i = last;
                            }
                            _v180 = i;
                            _v184 =  &(1[end]);
                            _v188 = i;
                            _v192 =  &(1[end]);
                            _v196 = qgroup;
                            _v200 = scheme;
                            Strcat(page, Sprintf("<a href="%s%s/%d-%d">[%d-%d]</a>\n"));
                        }
                        flag = 1;
                        goto L108;
                    }
                }
            } else {
                news_close( &current_news);
                Strcat_charp(page, "</table>\n<p>Transfer Interrupted!\n");
L134:
                Strcat_charp(page, "</body>\n</html>\n");
                if((TrapSignal & 255) != 0) {
                    if((fmInitialized & 255) != 0) {
                        term_raw();
                    }
                    if(prevtrap != 0) {
                        mySignal(2, prevtrap);
                    }
                }
                return page;
            }
        }
        goto L3;
    }
}

void closeNews()
{// addr = 0x080A83BA  --  defined in 'news.c' at line 507
    news_close( &current_news);
}

void disconnectNews()
{// addr = 0x080A83CE  --  defined in 'news.c' at line 513
    news_quit( &current_news);
}

void setKeymap(char* p, int lineno, int verbose)
{// addr = 0x080A83E4  --  defined in 'func.c' at line 22
    unsigned char* map;                    // _cfa_fffffff0
    char* s;                               // _cfa_ffffffec
    char* emsg;                            // _cfa_ffffffe8
    int c;                                 // _cfa_ffffffe4
    int f;                                 // _cfa_ffffffe0
    unsigned char** mmap;                  // _cfa_ffffffdc
    int i;                                 // _cfa_ffffffd8
    int j;                                 // _cfa_ffffffd4
    int m;                                 // _cfa_ffffffd0
    _unknown_ _v76;                        // _cfa_ffffffb4 (outparam)
    _unknown_ _v80;                        // _cfa_ffffffb0 (outparam)
    char* _v84;                            // _cfa_ffffffac (outparam)
    int _v88;                              // _cfa_ffffffa8 (outparam)
    _unknown_ __ebx;                       // r1
    unsigned char** _t160;                 // _t160

    map = 0;
    s = getQWord( &p);
    c = getKey(s);
    if(c < 0) {
        if(lineno <= 0) {
            _v88 = s;
            emsg =  *(Sprintf("defkey: unknown key '%s'"));
        } else {
            _v84 = s;
            _v88 = lineno;
            emsg =  *(Sprintf("line %d: unknown key '%s'"));
        }
        record_err_message(emsg);
        if(verbose != 0) {
            disp_message_nsec(emsg, 0, 1, 1, 0);
            return;
        }
        return;
    }
    s = getWord( &p);
    f = getFuncList(s);
    if(f >= 0) {
        if((c & 268435456) == 0) {
            if((c & 1024) == 0) {
                if((c & 512) == 0) {
                    if((c & 256) == 0) {
                        map =  &GlobalKeymap;
                    } else {
                        map =  &EscKeymap;
                    }
                } else {
                    map =  &EscBKeymap;
                }
            } else {
                map =  &EscDKeymap;
            }
L47:
            map[c & 127] = f;
            s = getQWord( &p);
            if(( *s & 255) == 0) {
                if(getKeyData(c) == 0) {
                    goto L55;
                }
                putHash_iv(keyData, c, 0);
                return;
            }
            if(keyData == 0) {
                keyData = newHash_iv(16);
            }
            putHash_iv(keyData, c, s);
            return;
        }
        mmap = 0;
        m = c >> 16 & 1919;
        if((m & 1024) == 0) {
            if((m & 512) == 0) {
                if((m & 256) == 0) {
                    map =  &GlobalKeymap;
                } else {
                    map =  &EscKeymap;
                }
            } else {
                map =  &EscBKeymap;
            }
        } else {
            map =  &EscDKeymap;
        }
        if((map[m & 127] & 255) != 74) {
            _t160 =  &(map[m & 127]);
             *_t160 = 74;
        } else {
            _t160 = getKeyData(m);
            mmap = _t160;
        }
        if(mmap != 0) {
L31:
            if(keyData == 0) {
                keyData = newHash_iv(16);
            }
            putHash_iv(keyData, m, mmap);
            if((c & 1024) == 0) {
                if((c & 512) == 0) {
                    if((c & 256) == 0) {
                        map =  *mmap;
                    } else {
                        map = mmap[1];
                    }
                } else {
                    map = mmap[2];
                }
            } else {
                map = mmap[3];
            }
            goto L47;
        } else {
             *__esp = 16;
            GC_malloc();
            mmap = _t160;
            i = 0;
            while(i <= 3) {
                 *__esp = 128;
                GC_malloc();
                mmap[i] = i << 2;
                j = 0;
                while(j <= 127) {
                    mmap[i][j] = 0;
                    j = j + 1;
                }
                i = i + 1;
            }
            ( *mmap)[0x1b] = 28;
            mmap[1][0x5b] = 27;
            mmap[1][0x4f] = 27;
            goto L31;
        }
    } else {
        if(lineno <= 0) {
            _v88 = s;
            emsg =  *(Sprintf("defkey: invalid command '%s'"));
        } else {
            _v84 = s;
            _v88 = lineno;
            emsg =  *(Sprintf("line %d: invalid command '%s'"));
        }
        record_err_message(emsg);
        if(verbose == 0) {
L55:
            return;
        } else {
            disp_message_nsec(emsg, 0, 1, 1, 0);
            return;
        }
    }
}

void interpret_keymap(FILE* kf, struct stat* current, int force)
{// addr = 0x080A87D7  --  defined in 'func.c' at line 117
    int fd;                                // _cfa_ffffffe0
    Str line;              // _cfa_ffffffdc
    char* p;                               // _cfa_ffffffd8
    char* s;                               // _cfa_ffffffd4
    char* emsg;                            // _cfa_ffffffd0
    int lineno;                            // _cfa_ffffffcc
    wc_ces charset;     // _cfa_ffffffc8
    int verbose;                           // _cfa_ffffffc4
    _unknown_ _v84;                        // _cfa_ffffffac
    _unknown_ _v104;                       // _cfa_ffffff98
    _unknown_ _v136;                       // _cfa_ffffff78
    _unknown_ _v144;                       // _cfa_ffffff70
    struct stat kstat;    // _cfa_ffffff6c
    _unknown_ _v172;                       // _cfa_ffffff54 (outparam)
    _unknown_ _v176;                       // _cfa_ffffff50 (outparam)
    char* _v180;                           // _cfa_ffffff4c (outparam)
    int _v184;                             // _cfa_ffffff48 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    int _t86;                              // _t86
    FILE* _t92;           // _t92
    char* _t109;                           // _t109
    char* _t111;                           // _t111
    char* _t119;                           // _t119
    char* _t120;                           // _t120

    charset = SystemCharset;
    verbose = 1;
    _t86 = kf;
     *__esp = _t86;
    fileno();
    fd = _t86;
    if(fd < 0) {
        return;
    }
    if(__fstat(fd,  &(kstat.st_dev)) != 0) {
        return;
    }
    if(force != 0 || kstat.st_mtim != current->st_mtim || (current->st_dev ^ kstat.st_dev | kstat.st_dev ^ current->st_dev) != 0 || kstat.st_ino != current->st_ino || kstat.st_size != current->st_size) {
        _push(22 << 2);
        _push( &(kstat.st_dev));
        _push(current);
        memcpy();
        __esp =  &(__esp[3]);
        lineno = 0;
        while(1) {
            _t92 = kf;
             *__esp = _t92;
            feof();
            if(_t92 != 0) {
                break;
            }
            line = Strfgets(kf);
            lineno = lineno + 1;
            Strchop(line);
            Strremovefirstspaces(line);
            if(line->length == 0) {
                continue;
            }
            line = wc_Str_conv(line, charset, InnerCharset);
            p = line->ptr;
            s = getWord( &p);
            if(( *s & 255) == 35) {
                continue;
            }
            _v184 = "keymap";
            _t109 = s;
             *__esp = _t109;
            strcmp();
            if(_t109 == 0) {
                setKeymap(p, lineno, verbose);
                continue;
            }
            _v184 = "charset";
            _t111 = s;
             *__esp = _t111;
            strcmp();
            if(_t111 == 0) {
L13:
                s = getQWord( &p);
                if(( *s & 255) != 0) {
                    charset = wc_guess_charset(s, charset);
                }
                continue;
            }
            _v184 = "encoding";
            _t119 = s;
             *__esp = _t119;
            strcmp();
            if(_t119 != 0) {
                _v184 = "verbose";
                _t120 = s;
                 *__esp = _t120;
                strcmp();
                if(_t120 != 0) {
                    _v180 = s;
                    _v184 = lineno;
                    emsg =  *(Sprintf("line %d: syntax error '%s'"));
                    record_err_message(emsg);
                    if(verbose != 0) {
                        disp_message_nsec(emsg, 0, 1, 1, 0);
                    }
                } else {
                    s = getWord( &p);
                    if(( *s & 255) != 0) {
                        verbose = str_to_bool(s, verbose);
                    }
                }
                continue;
            }
            goto L13;
        }
        return;
    } else {
        return;
    }
}

void initKeymap(int force)
{// addr = 0x080A8A8F  --  defined in 'func.c' at line 180
    FILE* kf;             // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    FILE* _t17;           // _t17
    FILE* _t19;           // _t19
    int _t20;                              // _t20
    int _t24;                              // _t24

    _t17 = confFile("keymap");
    _v40 = "rt";
     *__esp = _t17;
    fopen();
    kf = _t17;
    if(kf == 0) {
L6:
        _t19 = rcFile(keymap_file);
        _v40 = "rt";
         *__esp = _t19;
        fopen();
        kf = _t19;
        if(kf != 0) {
            if(force != 0 || (keymap_initialized & 255) == 0) {
                _t20 = 1;
            } else {
                _t20 = 0;
            }
            interpret_keymap(kf,  &current_keymap_file, _t20);
             *__esp = kf;
            fclose();
        }
        keymap_initialized = 1;
        return;
    }
    if(force == 0 && (keymap_initialized & 255) != 0) {
        _t24 = 0;
    } else {
        _t24 = 1;
    }
    interpret_keymap(kf,  &sys_current_keymap_file, _t24);
     *__esp = kf;
    fclose();
    goto L6;
}

int getFuncList(char* id)
{// addr = 0x080A8B6E  --  defined in 'func.c' at line 198
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return getHash_si( &functable, id, -1);
}

char* getKeyData(int key)
{// addr = 0x080A8B91  --  defined in 'func.c' at line 204
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(keyData != 0) {
        return getHash_iv(keyData, key, 0);
    }
    return 0;
}

int getKey2(char** str)
{// addr = 0x080A8BC5  --  defined in 'func.c' at line 212
    char* s;                               // _cfa_fffffff0
    int c;                                 // _cfa_ffffffec
    int esc;                               // _cfa_ffffffe8
    int ctrl;                              // _cfa_ffffffe4
    intOrPtr _v36;                         // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _t162;                           // _t162
    char* _t163;                           // _t163
    char* _t164;                           // _t164
    char* _t165;                           // _t165
    char* _t166;                           // _t166
    char* _t167;                           // _t167
    char* _t170;                           // _t170
    char* _t171;                           // _t171
    char* _t172;                           // _t172
    char* _t270;                           // _t270
    char* _t283;                           // _t283
    char* _t284;                           // _t284
    char* _t285;                           // _t285

    s =  *str;
    esc = 0;
    ctrl = 0;
    if(s == 0 || ( *s & 255) == 0) {
        return -1;
    }
    _v40 = "UP";
    _t162 = s;
     *__esp = _t162;
    strcasecmp();
    if(_t162 == 0) {
         *str =  &(s[2]);
        return 577;
    }
    _v40 = "DOWN";
    _t163 = s;
     *__esp = _t163;
    strcasecmp();
    if(_t163 == 0) {
         *str =  &(s[4]);
        return 578;
    }
    _v40 = "RIGHT";
    _t164 = s;
     *__esp = _t164;
    strcasecmp();
    if(_t164 == 0) {
         *str =  &(s[5]);
        return 579;
    }
    _v40 = "LEFT";
    _t165 = s;
     *__esp = _t165;
    strcasecmp();
    if(_t165 == 0) {
         *str =  &(s[4]);
        return 580;
    }
    _v36 = 4;
    _v40 = "ESC-";
    _t166 = s;
     *__esp = _t166;
    strncasecmp();
    if(_t166 == 0) {
L13:
        s =  &(s[4]);
        esc = 256;
        goto L19;
    } else {
        _v36 = 4;
        _v40 = "ESC ";
        _t283 = s;
         *__esp = _t283;
        strncasecmp();
        if(_t283 != 0) {
            _v36 = 2;
            _v40 = "M-";
            _t284 = s;
             *__esp = _t284;
            strncasecmp();
            if(_t284 == 0) {
L16:
                s =  &(s[2]);
                esc = 256;
L19:
                _v36 = 2;
                _v40 = "C-";
                _t167 = s;
                 *__esp = _t167;
                strncasecmp();
                if(_t167 != 0) {
                    if(( *s & 255) == 94 && (s[1] & 255) != 0) {
                        s =  &(s[1]);
                        ctrl = 1;
                    }
                } else {
                    s =  &(s[2]);
                    ctrl = 1;
                }
                if(esc == 0 && ctrl != 0 && ( *s & 255) == 91) {
                    s =  &(s[1]);
                    ctrl = 0;
                    esc = 256;
                }
                if(esc != 0 && ctrl == 0) {
                    if(( *s & 255) == 91 || ( *s & 255) == 79) {
                        s =  &(s[1]);
                        esc = 512;
                    }
                    _v36 = 2;
                    _v40 = "C-";
                    _t270 = s;
                     *__esp = _t270;
                    strncasecmp();
                    if(_t270 != 0) {
                        if(( *s & 255) == 94 && (s[1] & 255) != 0) {
                            s =  &(s[1]);
                            ctrl = 1;
                        }
                    } else {
                        s =  &(s[2]);
                        ctrl = 1;
                    }
                }
                if(ctrl == 0) {
                    if(esc != 512 || ( *( &MYCTYPE_MAP + ( *s & 0xff)) & 8) == 0) {
                        _v36 = 3;
                        _v40 = "SPC";
                        _t170 = s;
                         *__esp = _t170;
                        strncasecmp();
                        if(_t170 != 0) {
                            _v36 = 3;
                            _v40 = "TAB";
                            _t171 = s;
                             *__esp = _t171;
                            strncasecmp();
                            if(_t171 != 0) {
                                _v36 = 3;
                                _v40 = "DEL";
                                _t172 = s;
                                 *__esp = _t172;
                                strncasecmp();
                                if(_t172 != 0) {
                                    if(( *s & 255) != 92 || (s[1] & 255) == 0) {
                                         *str =  &(s[1]);
                                        if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 0x11) == 0) {
                                            return -1;
                                        }
                                        return  *s & 255 | esc;
                                    } else {
                                        s =  &(s[1]);
                                         *str =  &(s[1]);
                                        if(( *s & 255) - 92 > 24) {
                                            return -1;
                                        }
                                        goto __eax;
                                    }
                                }
                                 *str =  &(s[3]);
                                return esc | 127;
                            }
                             *str =  &(s[3]);
                            return esc | 9;
                        }
                         *str =  &(s[3]);
                        return esc | 32;
                    } else {
                        c = ( *s & 255) - 48;
                        s =  &(s[1]);
                        if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 8) != 0) {
                            c = (c << 2) + c + (c << 2) + c + ( *s & 255) - 48;
                            s =  &(s[1]);
                        }
                         *str =  &(s[1]);
                        if(( *s & 255) != 126) {
                            return -1;
                        } else {
                            return c | 4;
                        }
                    }
                } else {
                     *str =  &(s[1]);
                    if(( *s & 255) <= 63 || ( *s & 255) > 95) {
                        if(( *s & 255) <= 96 || ( *s & 255) > 122) {
                            if(( *s & 255) != 63) {
                                return -1;
                            }
                            return esc | 127;
                        } else {
                            return ( *s & 255) - 96 | esc;
                        }
                    } else {
                        return ( *s & 255) - 64 | esc;
                    }
                }
            }
            _v36 = 2;
            _v40 = "\\E";
            _t285 = s;
             *__esp = _t285;
            strncasecmp();
            if(_t285 != 0) {
                if(( *s & 255) == 27) {
                    s =  &(s[1]);
                    esc = 256;
                }
                goto L19;
            }
            goto L16;
        }
        goto L13;
    }
}

int getKey(char* s)
{// addr = 0x080A90C7  --  defined in 'func.c' at line 348
    int c;                                 // _cfa_fffffff0
    int c2;                                // _cfa_ffffffec

    c = getKey2( &s);
    if(c >= 0) {
        if(( *s & 255) == 32 || ( *s & 255) == 45) {
            s =  &(s[1]);
        }
        if(( *s & 255) == 0) {
L9:
            return c;
        } else {
            c2 = getKey2( &s);
            if(c2 >= 0) {
                c = c << 16 | 268435456 | c2;
                goto L9;
            }
            return -1;
        }
    }
    return -1;
}

char* getWord(char** str)
{// addr = 0x080A9140  --  defined in 'func.c' at line 367
    char* p;                               // _cfa_fffffff0
    char* s;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    p =  *str;
    while(( *p & 255) != 0) {
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
            p =  &(p[1]);
            continue;
        }
        break;
    }
    s = p;
    while(( *p & 255) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0 && ( *p & 255) != 59) {
        p =  &(p[1]);
    }
     *str = p;
    return  *(Strnew_charp_n(s, p - s));
}

char* getQWord(char** str)
{// addr = 0x080A91D9  --  defined in 'func.c' at line 379
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    int in_q;                              // _cfa_ffffffe8
    int in_dq;                             // _cfa_ffffffe4
    int esc;                               // _cfa_ffffffe0
    int _t201;                             // _t201
    int _t216;                             // _t216
    int _t231;                             // _t231
    int _t246;                             // _t246
    int _t269;                             // _t269
    int _t286;                             // _t286
    int _t303;                             // _t303

    tmp = Strnew();
    in_q = 0;
    in_dq = 0;
    esc = 0;
    p =  *str;
    while(( *p & 255) != 0) {
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
            p =  &(p[1]);
            continue;
        } else {
L53:
            while(( *p & 255) != 0) {
                if(esc == 0) {
                    if(( *p & 255) != 92) {
                        if(in_q == 0) {
                            if(in_dq == 0) {
                                if(( *p & 255) != 39) {
                                    if(( *p & 255) != 34) {
                                        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0 || ( *p & 255) == 59) {
                                            break;
                                        } else {
                                            if(tmp->length + 1 >= tmp->area_size) {
                                                Strgrow(tmp);
                                            }
                                            _t201 = tmp->length;
                                             *((char*)(tmp->ptr + _t201)) =  *p & 255;
                                            tmp->length = _t201 + 1;
                                             *((char*)(tmp->ptr + tmp->length)) = 0;
L51:
                                            p =  &(p[1]);
                                            continue;
                                        }
                                    }
                                    in_dq = 1;
                                    goto L51;
                                }
                                in_q = 1;
                                goto L51;
                            }
                            if(( *p & 255) != 34) {
                                if(tmp->length + 1 >= tmp->area_size) {
                                    Strgrow(tmp);
                                }
                                _t216 = tmp->length;
                                 *((char*)(tmp->ptr + _t216)) =  *p & 255;
                                tmp->length = _t216 + 1;
                                 *((char*)(tmp->ptr + tmp->length)) = 0;
                            } else {
                                in_dq = 0;
                            }
                            goto L51;
                        }
                        if(( *p & 255) != 39) {
                            if(tmp->length + 1 >= tmp->area_size) {
                                Strgrow(tmp);
                            }
                            _t231 = tmp->length;
                             *((char*)(tmp->ptr + _t231)) =  *p & 255;
                            tmp->length = _t231 + 1;
                             *((char*)(tmp->ptr + tmp->length)) = 0;
                        } else {
                            in_q = 0;
                        }
                        goto L51;
                    }
                    esc = 1;
                    goto L51;
                }
                if(in_q == 0) {
                    if(in_dq == 0) {
                        if(( *p & 255) != 92 && ( *p & 255) != 39 && ( *p & 255) != 34 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
                            if(tmp->length + 1 >= tmp->area_size) {
                                Strgrow(tmp);
                            }
                            _t269 = tmp->length;
                             *((char*)(tmp->ptr + _t269)) = 92;
                            tmp->length = _t269 + 1;
                             *((char*)(tmp->ptr + tmp->length)) = 0;
                        }
                    } else {
                        if(( *p & 255) != 92 && ( *p & 255) != 34) {
                            if(tmp->length + 1 >= tmp->area_size) {
                                Strgrow(tmp);
                            }
                            _t286 = tmp->length;
                             *((char*)(tmp->ptr + _t286)) = 92;
                            tmp->length = _t286 + 1;
                             *((char*)(tmp->ptr + tmp->length)) = 0;
                        }
                    }
                } else {
                    if(( *p & 255) != 92) {
                        if(( *p & 255) != 39) {
                            if(tmp->length + 1 >= tmp->area_size) {
                                Strgrow(tmp);
                            }
                            _t303 = tmp->length;
                             *((char*)(tmp->ptr + _t303)) = 92;
                            tmp->length = _t303 + 1;
                             *((char*)(tmp->ptr + tmp->length)) = 0;
                        }
                    }
                }
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t246 = tmp->length;
                 *((char*)(tmp->ptr + _t246)) =  *p & 255;
                tmp->length = _t246 + 1;
                 *((char*)(tmp->ptr + tmp->length)) = 0;
                esc = 0;
                goto L51;
            }
             *str = p;
            return tmp->ptr;
        }
    }
    goto L53;
}

void setMouseAction0(char** str, int* width, MouseActionMap** map, char* p)
{// addr = 0x080A95B9  --  defined in 'func.c' at line 459
    char* s;                               // _cfa_fffffff0
    int b;                                 // _cfa_ffffffec
    int w;                                 // _cfa_ffffffe8
    int x;                                 // _cfa_ffffffe4
    signed int _v40;                       // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    MouseActionMap* _t72;   // _t72

    s = getQWord( &p);
    if(( *s & 255) == 0) {
         *str = 0;
        width = 0;
        b = 0;
        while(b <= 2) {
            map[b] = 0;
            b = b + 1;
        }
        return;
    }
    w =  *width;
     *str = s;
     *width = wtf_strwidth(s);
    if( *width > 99) {
         *width = 100;
    }
    if( *width > w) {
        b = 0;
        while(b <= 2) {
            if(map[b] == 0) {
L15:
                b = b + 1;
                continue;
            }
            _t72 = map[b];
            _v40 =  *width * 8;
             *__esp = _t72;
            GC_realloc();
            map[b] = _t72;
            x = w + 1;
            while( *width > x) {
                 *(map[b] + (x << 3)) = 0;
                (map[b] + (x << 3))[1] = 0;
                x = x + 1;
            }
            goto L15;
        }
        return;
    }
}

void setMouseAction1(MouseActionMap** map, int width, char* p)
{// addr = 0x080A9701  --  defined in 'func.c' at line 491
    char* s;                               // _cfa_fffffff0
    int x;                                 // _cfa_ffffffec
    int x2;                                // _cfa_ffffffe8
    int f;                                 // _cfa_ffffffe4
    int _t60;                              // _t60
    int _t70;                              // _t70
    char* _t89;                            // _t89
    MouseActionMap* _t95;   // _t95
    char** _t106;                          // _t106

    if( *map == 0) {
        _t95 = width << 3;
         *__esp = _t95;
        GC_malloc();
         *map = _t95;
        x = 0;
        while(x < width) {
             *( *map + (x << 3)) = 0;
            ( *map + (x << 3))[1] = 0;
            x = x + 1;
        }
    }
    s = getWord( &p);
    _t60 = s;
     *__esp = _t60;
    atoi();
    x = _t60;
    if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 8) == 0) {
        return;
    }
    if(x < 0) {
        return;
    }
    if(x >= width) {
        return;
    }
    s = getWord( &p);
    _t70 = s;
     *__esp = _t70;
    atoi();
    x2 = _t70;
    if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 8) == 0) {
        return;
    }
    if(x2 < 0) {
        return;
    }
    if(x2 < width) {
        s = getWord( &p);
        f = getFuncList(s);
        s = getQWord( &p);
        if(( *s & 255) == 0) {
            s = 0;
        }
        while(x <= x2) {
            _t106 =  *map + (x << 3);
            if(f < 0) {
                _t89 = 0;
            } else {
                _t89 =  *(135103140 + f * 8);
            }
             *_t106 = _t89;
            ( *map + (x << 3))[1] = s;
            x = x + 1;
        }
        return;
    }
}

void setMouseAction2(MouseActionMap* map, char* p)
{// addr = 0x080A9899  --  defined in 'func.c' at line 523
    char* s;                               // _cfa_fffffff0
    int f;                                 // _cfa_ffffffec
    _None* _t25;                           // _t25

    s = getWord( &p);
    f = getFuncList(s);
    s = getQWord( &p);
    if(( *s & 255) == 0) {
        s = 0;
    }
    if(f < 0) {
        _t25 = 0;
    } else {
        _t25 =  *(135103140 + f * 8);
    }
    map->func = _t25;
    map->data = s;
}

void interpret_mouse_action(FILE* mf)
{// addr = 0x080A9901  --  defined in 'func.c' at line 538
    Str line;              // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* s;                               // _cfa_ffffffe8
    int b;                                 // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    FILE* _t77;           // _t77
    char* _t93;                            // _t93
    char* _t94;                            // _t94
    char* _t95;                            // _t95
    char* _t98;                            // _t98
    char* _t110;                           // _t110
    char* _t111;                           // _t111
    char* _t112;                           // _t112
    char* _t113;                           // _t113
    char* _t114;                           // _t114
    char* _t115;                           // _t115

    while(1) {
        _t77 = mf;
         *__esp = _t77;
        feof();
        if(_t77 != 0) {
            break;
        }
        line = Strfgets(mf);
        Strchop(line);
        Strremovefirstspaces(line);
        if(line->length == 0) {
            continue;
        }
        p =  *(wc_Str_conv(Strnew_charp(line->ptr), SystemCharset, InnerCharset));
        s = getWord( &p);
        if(( *s & 255) == 35) {
            continue;
        }
        _v40 = 135069899;
        _t93 = s;
         *__esp = _t93;
        strcmp();
        if(_t93 != 0) {
            _v40 = "lastline";
            _t94 = s;
             *__esp = _t94;
            strcmp();
            if(_t94 != 0) {
                _v40 = "button";
                _t95 = s;
                 *__esp = _t95;
                strcmp();
                if(_t95 != 0) {
                    continue;
                }
                s = getWord( &p);
                _t98 = s;
                 *__esp = _t98;
                atoi();
                b = _t98 - 1;
                if(b < 0) {
                    continue;
                }
                if(b <= 2) {
                    goto L12;
                    do {
                    } while();
                    continue;
L12:
                    if(( *p & 255) == 0 || ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
                        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 8) == 0) {
                            s = getWord( &p);
                        } else {
                            s = 135069899;
                        }
                        _v40 = 135069899;
                        _t110 = s;
                         *__esp = _t110;
                        strcasecmp();
                        if(_t110 != 0) {
                            _v40 = "lastline";
                            _t111 = s;
                             *__esp = _t111;
                            strcasecmp();
                            if(_t111 != 0) {
                                _v40 = "default";
                                _t112 = s;
                                 *__esp = _t112;
                                strcasecmp();
                                if(_t112 != 0) {
                                    _v40 = "anchor";
                                    _t113 = s;
                                     *__esp = _t113;
                                    strcasecmp();
                                    if(_t113 != 0) {
                                        _v40 = "active";
                                        _t114 = s;
                                         *__esp = _t114;
                                        strcasecmp();
                                        if(_t114 != 0) {
                                            _v40 = "tab";
                                            _t115 = s;
                                             *__esp = _t115;
                                            strcasecmp();
                                            if(_t115 == 0) {
                                                setMouseAction2((b << 3) + 135792356, p);
                                            }
                                        } else {
                                            setMouseAction2((b << 3) + 135792332, p);
                                        }
                                    } else {
                                        setMouseAction2((b << 3) + 135792308, p);
                                    }
                                } else {
                                    setMouseAction2((b << 3) + 135792284, p);
                                }
                            } else {
                                if( *135792260 != 0) {
                                    setMouseAction1( &(135792392[b]),  *135792268, p);
                                }
                            }
                        } else {
                            if(mouse_action.menu_str != 0) {
                                setMouseAction1( &(135792380[b]),  *135792264, p);
                            }
                        }
                    } else {
                        p =  &(p[1]);
                        goto L12;
                    }
                } else {
                }
            } else {
                setMouseAction0(135792260, 135792268, 135792392, p);
            }
        } else {
            setMouseAction0( &mouse_action, 135792264, 135792380, p);
        }
    }
}

void initMouseAction()
{// addr = 0x080A9C4C  --  defined in 'func.c' at line 600
    FILE* mf;             // _cfa_fffffff0
    int w;                                 // _cfa_ffffffec
    char** symbol;                         // _cfa_ffffffe8
    FILE* _v36;           // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    FILE* _t29;           // _t29
    FILE* _t30;           // _t30

    _v36 = 148;
    _v40 =  &mouse_action;
     *__esp =  &default_mouse_action;
    bcopy();
     *__esp = 48;
    GC_malloc();
     *135792392 = __eax;
    _v36 = 48;
    _v40 =  *135792392;
     *__esp =  &default_lastline_action;
    bcopy();
    w = 0;
    symbol = get_symbol(DisplayCharset,  &w);
     *135792260 =  *(Strnew_charp(symbol[0x2d]));
    _t29 = confFile("mouse");
    _v40 = "rt";
     *__esp = _t29;
    fopen();
    mf = _t29;
    if(mf != 0) {
        interpret_mouse_action(mf);
         *__esp = mf;
        fclose();
    }
    _t30 = rcFile("mouse");
    _v40 = "rt";
     *__esp = _t30;
    fopen();
    mf = _t30;
    if(mf != 0) {
        interpret_mouse_action(mf);
         *__esp = mf;
        fclose();
        return;
    }
}

int total_dot_number(char* p, char* ep, int max_count)
{// addr = 0x080A9D54  --  defined in 'cookie.c' at line 26
    int count;                             // _cfa_fffffff0
    signed int _t21;                       // _t21

    count = 0;
    if(ep == 0) {
        _t21 = p;
         *__esp = _t21;
        strlen();
        ep =  &(p[_t21]);
    }
    do {
    } while(p < ep && count < max_count);
    return count;
}

char* domain_match(char* host, char* domain)
{// addr = 0x080A9DA1  --  defined in 'cookie.c' at line 41
    int m0;                                // _cfa_fffffff0
    int m1;                                // _cfa_ffffffec
    int offset;                            // _cfa_ffffffe8
    char* domain_p;                        // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    char* _t56;                            // _t56
    int _t57;                              // _t57
    char* _t67;                            // _t67
    int _t72;                              // _t72
    char* _t76;                            // _t76
    char* _t78;                            // _t78
    char* _t79;                            // _t79
    char* _t82;                            // _t82
    char* _t85;                            // _t85

    regexCompile("[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+", 0);
    m0 = regexMatch(host, -1, 1);
    m1 = regexMatch(domain, -1, 1);
    if(m0 == 0 || m1 == 0) {
        if(m0 != 0 || m1 != 0) {
            goto L22;
        } else {
            _v40 = 135069983;
            _t56 = domain;
             *__esp = _t56;
            strcasecmp();
            if(_t56 == 0) {
L8:
                _t57 = host;
                 *__esp = _t57;
                strlen();
                offset = _t57;
                domain_p =  &(host[offset]);
                if((domain[1] & 255) == 0 || total_dot_number(host, domain_p, 1) == 0) {
                    return domain_p;
                } else {
                    goto L22;
                }
            }
            _v40 = ".local";
            _t67 = domain;
             *__esp = _t67;
            strcasecmp();
            if(_t67 != 0) {
                if(( *domain & 255) != 46) {
L14:
                    if(( *domain & 255) != 46) {
                        _t72 = 0;
                    } else {
                        _t78 = host;
                         *__esp = _t78;
                        strlen();
                        _t79 = domain;
                         *__esp = _t79;
                        strlen();
                        _t72 = _t78 - _t79;
                    }
                    offset = _t72;
                    domain_p =  &(host[offset]);
                    if(offset < 0) {
                        goto L22;
                    } else {
                        _v40 = domain;
                        _t76 = domain_p;
                         *__esp = _t76;
                        strcasecmp();
                        if(_t76 != 0) {
                            goto L22;
                        }
                        return domain_p;
                    }
                }
                _v40 =  &(domain[1]);
                _t82 = host;
                 *__esp = _t82;
                strcasecmp();
                if(_t82 != 0) {
                    goto L14;
                }
                return host;
            }
            goto L8;
        }
    } else {
        _v40 = domain;
        _t85 = host;
         *__esp = _t85;
        strcasecmp();
        if(_t85 == 0) {
            return host;
        }
L22:
        return 0;
    }
}

struct portlist* make_portlist(Str port)
{// addr = 0x080A9F49  --  defined in 'cookie.c' at line 88
    struct portlist* first;   // _cfa_fffffff0
    struct portlist* pl;   // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    Str tmp;               // _cfa_ffffffe4

    first = 0;
    tmp = Strnew();
    p = port->ptr;
    while(( *p & 255) != 0) {
        while(1) {
            p =  *p & 255;
            if(__al == 0) {
                break;
            }
            p =  *p & 255;
            __eax =  *(__eax +  &MYCTYPE_MAP) & 255;
            __eax = __al & 255;
            if(__eax == 0) {
                p =  &(p[1]);
                continue;
            }
            break;
        }
        __eax = tmp;
        Strclear(tmp);
        while(1) {
            p =  *p & 255;
            if(__al == 0) {
                break;
            }
            p =  *p & 255;
            __eax =  *(__eax +  &MYCTYPE_MAP) & 255;
            __eax = __al & 255;
            if(__eax != 0) {
                __eax = tmp;
                __eax = tmp->length;
                __edx = tmp->length + 1;
                __eax = tmp;
                __eax = tmp->area_size;
                if(tmp->length + 1 >= tmp->area_size) {
                    __eax = tmp;
                    Strgrow(tmp);
                }
                __eax = tmp;
                __eax = tmp;
                __eax = tmp->length;
                __eax = p;
                 *((char*)(__eax + tmp->ptr)) = __dl;
                __edx =  &(__eax->port);
                __eax = tmp;
                tmp->length = __edx;
                p =  &(p[1]);
                __eax = tmp;
                __edx = tmp->ptr;
                __eax = tmp;
                __eax = tmp->length;
                __eax = tmp->ptr + tmp->length;
                 *(tmp->ptr + tmp->length) = 0;
                continue;
            }
            break;
        }
        __eax = tmp;
        __eax = tmp->length;
        if(__eax != 0) {
             *__esp = 8;
            GC_malloc();
            pl = __eax;
            __eax = tmp;
            __eax = tmp->ptr;
             *__esp = __eax;
            atoi();
            __edx = __eax;
            __eax = pl;
            pl->port = __dx;
            __eax = pl;
            __edx = first;
            pl->next = first;
            __eax = pl;
            first = pl;
            continue;
        }
L16:
        return first;
    }
    goto L16;
}

Str portlist2str(struct portlist* first)
{// addr = 0x080AA06D  --  defined in 'cookie.c' at line 112
    struct portlist* pl;   // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    signed int _v40;                       // _cfa_ffffffd8 (outparam)

    _v40 = first->port & 0xffff;
    tmp = Sprintf("%d");
    pl = first->next;
    while(pl != 0) {
        _v40 = pl->port & 0xffff;
        Strcat(tmp, Sprintf(", %d"));
        pl = pl->next;
    }
    return tmp;
}

int port_match(struct portlist* first, int port)
{// addr = 0x080AA0D6  --  defined in 'cookie.c' at line 124
    struct portlist* pl;   // _cfa_fffffff8

    pl = first;
    while(pl != 0) {
        if((pl->port & 0xffff) != port) {
            pl = pl->next;
            continue;
        }
        return 1;
    }
    return 0;
}

void check_expired_cookies()
{// addr = 0x080AA10F  --  defined in 'cookie.c' at line 136
    struct cookie* p;   // _cfa_fffffff0
    struct cookie* p1;   // _cfa_ffffffec
    time_t now;         // _cfa_ffffffe8

     *__esp = 0;
    time();
    now = __eax;
    if(First_cookie == 0) {
L17:
        return;
    }
    if(First_cookie->expires == -1 || First_cookie->expires >= now) {
L6:
        p = First_cookie;
        while(p != 0) {
            if(p->next != 0) {
                p1 = p->next;
                if(p1->expires != -1 && p1->expires < now) {
                    if((p1->flag & 0x10) == 0) {
                        is_saved = 0;
                    }
                    p->next = p1->next;
                    p1 = p;
                }
                p = p1;
                continue;
            }
            return;
        }
        goto L17;
    } else {
        if((First_cookie->flag & 0x10) == 0) {
            is_saved = 0;
        }
        First_cookie = First_cookie->next;
        goto L6;
    }
}

Str make_cookie(struct cookie* cookie)
{// addr = 0x080AA1E6  --  defined in 'cookie.c' at line 162
    Str tmp;               // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t35;                              // _t35

    tmp = Strdup(cookie->name);
    if(tmp->length + 1 >= tmp->area_size) {
        Strgrow(tmp);
    }
    _t35 = tmp->length;
     *((char*)(tmp->ptr + _t35)) = 61;
    tmp->length = _t35 + 1;
     *((char*)(tmp->ptr + tmp->length)) = 0;
    Strcat(tmp, cookie->value);
    return tmp;
}

int match_cookie(ParsedURL* pu, struct cookie* cookie, char* domainname)
{// addr = 0x080AA262  --  defined in 'cookie.c' at line 171
    int _v20;                              // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8 (outparam)
    char* _t35;                            // _t35

    if(domainname != 0) {
        if(domain_match(domainname,  *(cookie->domain)) != 0) {
            _t35 =  *(cookie->path);
            _v20 = cookie->path->length;
            _v24 = pu->file;
             *__esp = _t35;
            strncmp();
            if(_t35 == 0) {
                if((cookie->flag & 2) == 0) {
                    if(cookie->portl == 0 || port_match(cookie->portl, pu->port) != 0) {
                        return 1;
                    } else {
                        return 0;
                    }
                }
                return 0;
            }
            return 0;
        }
        return 0;
    }
    return 0;
}

struct cookie* get_cookie_info(Str domain, Str path, Str name)
{// addr = 0x080AA31A  --  defined in 'cookie.c' at line 194
    struct cookie* p;   // _cfa_fffffff0
    char* _v40;                            // _cfa_ffffffd8
    struct _Str* _t23;    // _t23
    struct _Str* _t30;    // _t30
    struct _Str* _t34;    // _t34

    p = First_cookie;
    while(p != 0) {
        _t23 =  *(p->domain);
        _v40 = domain->ptr;
         *__esp = _t23;
        strcasecmp();
        if(_t23 != 0) {
L5:
            p = p->next;
            continue;
        }
        _t30 =  *(p->path);
        _v40 = path->ptr;
         *__esp = _t30;
        strcmp();
        if(_t30 != 0) {
            goto L5;
        }
        _t34 =  *(p->name);
        _v40 = name->ptr;
         *__esp = _t34;
        strcasecmp();
        if(_t34 != 0) {
            goto L5;
        }
        return p;
    }
    return 0;
}

Str find_cookie(ParsedURL* pu)
{// addr = 0x080AA39C  --  defined in 'cookie.c' at line 207
    Str tmp;               // _cfa_fffffff0
    struct cookie* p;   // _cfa_ffffffec
    struct cookie* p1;   // _cfa_ffffffe8
    struct cookie* fco;   // _cfa_ffffffe4
    int version;                           // _cfa_ffffffe0
    char* fq_domainname;                   // _cfa_ffffffdc
    char* domainname;                      // _cfa_ffffffd8
    struct cookie* _v52;   // _cfa_ffffffcc (outparam)
    struct _Str* _v56;    // _cfa_ffffffc8 (outparam)
    char* _t103;                           // _t103
    struct cookie* _t156;   // _t156

    fco = 0;
    version = 0;
    fq_domainname = FQDN(pu->host);
    check_expired_cookies();
    p = First_cookie;
    while(p != 0) {
        if((p->version & 255) == 0) {
            _t103 = fq_domainname;
        } else {
            _t103 = pu->host;
        }
        domainname = _t103;
        if((p->flag & 1) == 0 || match_cookie(pu, p, domainname) == 0) {
L14:
            p = p->next;
            continue;
        } else {
            _t156 = fco;
            p1 = _t156;
            while(p1 != 0) {
                _t156 =  *(p1->name);
                _v56 =  *(p->name);
                 *__esp = _t156;
                strcasecmp();
                if(_t156 != 0) {
                    _t156 = p1->next;
                    p1 = _t156;
                    continue;
                }
                break;
            }
            if(p1 == 0) {
                 *__esp = 80;
                GC_malloc();
                p1 = _t156;
                _v52 = 80;
                _v56 = p1;
                 *__esp = p;
                bcopy();
                p1->next = fco;
                fco = p1;
                if((p1->version & 255) > version) {
                    version = p1->version & 255;
                }
            }
            goto L14;
        }
    }
    if(fco == 0) {
        return 0;
    }
    tmp = Strnew();
    if(version > 0) {
        _v56 = version;
        Strcat(tmp, Sprintf("$Version="%d"; "));
    }
    Strcat(tmp, make_cookie(fco));
    p1 = fco->next;
    while(p1 != 0) {
        Strcat_charp(tmp, "; ");
        Strcat(tmp, make_cookie(p1));
        if(version > 0) {
            if((p1->flag & 8) != 0) {
                _v56 =  *(p1->path);
                Strcat(tmp, Sprintf("; $Path="%s""));
            }
            if((p1->flag & 4) != 0) {
                _v56 =  *(p1->domain);
                Strcat(tmp, Sprintf("; $Domain="%s""));
            }
            if(p1->portl != 0) {
                _v56 = portlist2str(p1->portl);
                Strcat(tmp, Sprintf("; $Port="%s""));
            }
        }
        p1 = p1->next;
    }
    return tmp;
}

int add_cookie(ParsedURL* pu, Str name, Str value, time_t expires, Str domain, Str path, int flag, Str comment, int version, Str port, Str commentURL)
{// addr = 0x080AA627  --  defined in 'cookie.c' at line 261
    struct cookie* p;   // _cfa_fffffff0
    char* domainname;                      // _cfa_ffffffec
    Str odomain;           // _cfa_ffffffe8
    Str opath;             // _cfa_ffffffe4
    struct portlist* portlist;   // _cfa_ffffffe0
    int use_security;                      // _cfa_ffffffdc
    char* dp;                              // _cfa_ffffffd8
    int n;                                 // _cfa_ffffffd4
    char** sdomain;                        // _cfa_ffffffd0
    int ok;                                // _cfa_ffffffcc
    int offset;                            // _cfa_ffffffc8
    int _v68;                              // _cfa_ffffffbc (outparam)
    char* _v72;                            // _cfa_ffffffb8 (outparam)
    char* _t200;                           // _t200
    struct cookie* _t210;   // _t210
    char* _t296;                           // _t296
    char* _t302;                           // _t302
    char* _t332;                           // _t332
    char* _t337;                           // _t337
    char* _t344;                           // _t344

    if(version != 0) {
        _t200 = pu->host;
    } else {
        _t200 = FQDN(pu->host);
    }
    domainname = _t200;
    odomain = domain;
    opath = path;
    portlist = 0;
    use_security = (flag & 32) == 0 & 255;
    if(domainname == 0) {
        return 37;
    }
    if(domain == 0) {
L34:
        if(path == 0 || version <= 0) {
L38:
            if(port == 0) {
L42:
                if(domain == 0) {
                    domain = Strnew_charp(domainname);
                }
                if(path != 0) {
L53:
                    _t210 = get_cookie_info(domain, path, name);
                    p = _t210;
                    if(p == 0) {
                         *__esp = 80;
                        GC_malloc();
                        p = _t210;
                        p->flag = 0;
                        if(default_use_cookie != 0) {
                            p->flag = p->flag & 255 | 1;
                        }
                        p->next = First_cookie;
                        First_cookie = p;
                    }
                    copyParsedURL(p, pu);
                    p->name = name;
                    p->value = value;
                    p->expires = expires;
                    p->domain = domain;
                    p->path = path;
                    p->comment = comment;
                    p->version = version;
                    p->portl = portlist;
                    p->commentURL = commentURL;
                    if((flag & 2) == 0) {
                        p->flag = p->flag & 0xfd;
                    } else {
                        p->flag = p->flag & 255 | 2;
                    }
                    if(odomain == 0) {
                        p->flag = p->flag & 0xfb;
                    } else {
                        p->flag = p->flag & 255 | 4;
                    }
                    if(opath == 0) {
                        p->flag = p->flag & 0xf7;
                    } else {
                        p->flag = p->flag & 255 | 8;
                    }
                    if((flag & 16) != 0 || p->expires == -1) {
                        p->flag = p->flag & 255 | 16;
                    } else {
                        p->flag = p->flag & 0xef;
                        is_saved = 0;
                    }
                    check_expired_cookies();
                    return 0;
                } else {
                    path = Strnew_charp(pu->file);
                    while(path->length > 0 && (path->length <= 0 || ( *(path->ptr + path->length - 1) & 255) != 47)) {
                        Strshrink(path, 1);
                    }
                    if(path->length > 0 && ( *(path->ptr + path->length - 1) & 255) == 47) {
                        Strshrink(path, 1);
                    }
                    goto L53;
                }
            }
            portlist = make_portlist(port);
            if(portlist == 0 || port_match(portlist, pu->port) != 0) {
                goto L42;
            } else {
                return 9;
            }
        } else {
            _t296 = path->ptr;
            _v68 = path->length;
            _v72 = pu->file;
             *__esp = _t296;
            strncmp();
            if(_t296 == 0) {
                goto L38;
            }
            return 4;
        }
    } else {
        if(( *(domain->ptr) & 255) == 46) {
L10:
            if(version != 0) {
                _t302 = domain->ptr;
                _v72 = ".local";
                 *__esp = _t302;
                strcasecmp();
                if(_t302 == 0 || total_dot_number(domain->ptr + 1, domain->ptr + domain->length, 1) != 0 || use_security == 0) {
L27:
                    dp = domain_match(domainname, domain->ptr);
                    if(dp != 0 || use_security == 0) {
                        if(version <= 0 || total_dot_number(domainname, dp, 1) == 0 || use_security == 0) {
                            goto L34;
                        } else {
                            return 40;
                        }
                    } else {
                        return 39;
                    }
                } else {
                    return 37;
                }
            }
            n = total_dot_number(domain->ptr, domain->ptr + domain->length, 3);
            if(n <= 1) {
                return 3;
            }
            if(n != 2) {
                goto L27;
            } else {
                ok = 0;
                sdomain =  &special_domain;
                while(ok == 0) {
                    if( *sdomain != 0) {
                        _t332 =  *sdomain;
                         *__esp = _t332;
                        strlen();
                        offset = domain->length - _t332;
                        if(offset >= 0) {
                            _t337 =  *sdomain;
                            _v72 =  &(domain->ptr[offset]);
                             *__esp = _t337;
                            strcasecmp();
                            if(_t337 == 0) {
                                ok = 1;
                            }
                        }
                        sdomain =  &(sdomain[1]);
                        continue;
                    }
                    break;
                }
                if(ok != 0) {
                    goto L27;
                }
                return 3;
            }
        }
        if(version > 0) {
L9:
            _v72 = domain->ptr;
            domain = Sprintf(".%s");
            goto L10;
        }
        _v72 = domain->ptr;
        _t344 = domainname;
         *__esp = _t344;
        strcasecmp();
        if(_t344 == 0) {
            goto L10;
        }
        goto L9;
    }
}

struct cookie* nth_cookie(int n)
{// addr = 0x080AAB16  --  defined in 'cookie.c' at line 405
    struct cookie* p;   // _cfa_fffffff8
    int i;                                 // _cfa_fffffff4

    p = First_cookie;
    i = 0;
    while(p != 0) {
        if(i != n) {
            p = p->next;
            i = i + 1;
            continue;
        }
        return p;
    }
    return 0;
}

void save_cookies()
{// addr = 0x080AAB54  --  defined in 'cookie.c' at line 419
    struct cookie* p;   // _cfa_ffffffe0
    char* cookie_file;                     // _cfa_ffffffdc
    FILE* fp;             // _cfa_ffffffd8
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v92;                         // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    intOrPtr _v100;                        // _cfa_ffffff9c
    signed int _v104;                      // _cfa_ffffff98
    signed int _v108;                      // _cfa_ffffff94
    intOrPtr _v112;                        // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    intOrPtr _v124;                        // _cfa_ffffff84
    intOrPtr _v128;                        // _cfa_ffffff80
    intOrPtr _v132;                        // _cfa_ffffff7c
    char* _v136;                           // _cfa_ffffff78
    intOrPtr __ebx;                        // r1
    intOrPtr __edi;                        // r4
    FILE* _t77;           // _t77
    intOrPtr* _t117;                       // _t117

    check_expired_cookies();
    if(First_cookie == 0) {
        return;
    }
    if(is_saved != 0) {
        return;
    }
    if(no_rc_dir != 0) {
        return;
    }
    cookie_file = rcFile("cookie");
    _t77 = cookie_file;
    _v136 = "w";
     *__esp = _t77;
    fopen();
    fp = _t77;
    if(fp != 0) {
        p = First_cookie;
        while(p != 0) {
            if((p->flag & 1) != 0) {
                if((p->flag & 0x10) == 0) {
                    if(p->commentURL == 0) {
                        __ebx = 135070108;
                    } else {
                        __ebx =  *(p->commentURL);
                    }
                    if(p->portl == 0) {
                        __edi = 135070108;
                    } else {
                        __edi =  *(portlist2str(p->portl));
                    }
                    if(p->comment == 0) {
                        _v72 = 135070108;
                    } else {
                        _v72 =  *(p->comment);
                    }
                    _v68 = p->version & 255;
                    _v64 = p->flag & 255;
                    _v60 =  *(p->path);
                    _v56 =  *(p->domain);
                    _v52 = p->expires;
                    _v48 =  *(p->value);
                    _t117 = parsedURL2Str(p);
                    _v92 = __ebx;
                    _v96 = __edi;
                    _v100 = _v72;
                    _v104 = _v68;
                    _v108 = _v64;
                    _v112 = _v60;
                    _v116 = _v56;
                    _v120 = _v52;
                    _v124 = _v48;
                    _v128 =  *(p->name);
                    _v132 =  *_t117;
                    _v136 = "%s\t%s\t%s\t%ld\t%s\t%s\t%d\t%d\t%s\t%s\t%s\n";
                     *__esp = fp;
                    fprintf();
                }
            }
            p = p->next;
        }
         *__esp = fp;
        fclose();
        _v136 = 384;
         *__esp = cookie_file;
        chmod();
        return;
    }
}

Str readcol(char** p)
{// addr = 0x080AAD41  --  defined in 'cookie.c' at line 450
    Str tmp;               // _cfa_fffffff0
    char* _t59;                            // _t59
    int _t71;                              // _t71

    tmp = Strnew();
    while(( *( *p) & 255) != 0 && ( *( *p) & 255) != 10 && ( *( *p) & 255) != 13 && ( *( *p) & 255) != 9) {
        _t71 = tmp->length;
        _t59 =  *p;
         *((char*)(tmp->ptr + _t71)) =  *_t59 & 255;
        tmp->length = _t71 + 1;
         *p =  &(_t59[1]);
         *((char*)(tmp->ptr + tmp->length)) = 0;
    }
    if(( *( *p) & 255) == 9) {
         *p =  &(( *p)[1]);
    }
    return tmp;
}

void load_cookies()
{// addr = 0x080AAE02  --  defined in 'cookie.c' at line 461
    struct cookie* cookie;   // _cfa_fffffff0
    struct cookie* p;   // _cfa_ffffffec
    FILE* fp;             // _cfa_ffffffe8
    Str line;              // _cfa_ffffffe4
    char* str;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    FILE* _t94;           // _t94
    struct cookie* _t101;   // _t101
    long int _t124;                        // _t124
    FILE* _t137;          // _t137
    FILE* _t143;          // _t143

    _t94 = rcFile("cookie");
    _v56 = "r";
     *__esp = _t94;
    fopen();
    fp = _t94;
    if(fp == 0) {
        return;
    }
    if(First_cookie == 0) {
        p = 0;
    } else {
        p = First_cookie;
        while(p->next != 0) {
            p = p->next;
        }
        while(1) {
L7:
            line = Strfgets(fp);
            if(line->length == 0) {
                break;
            }
            _t101 = line->ptr;
            str = _t101;
             *__esp = 80;
            GC_malloc();
            cookie = _t101;
            cookie->next = 0;
            cookie->flag = 0;
            cookie->version = 0;
            cookie->expires = -1;
            cookie->comment = 0;
            cookie->portl = 0;
            cookie->commentURL = 0;
            parseURL( *(readcol( &str)), cookie, 0);
            if(( *str & 255) == 0) {
                return;
            }
            cookie->name = readcol( &str);
            if(( *str & 255) == 0) {
                return;
            }
            cookie->value = readcol( &str);
            if(( *str & 255) == 0) {
                return;
            }
            _t124 =  *(readcol( &str));
             *__esp = _t124;
            atol();
            cookie->expires = _t124;
            if(( *str & 255) == 0) {
                return;
            }
            cookie->domain = readcol( &str);
            if(( *str & 255) == 0) {
                return;
            }
            cookie->path = readcol( &str);
            if(( *str & 255) == 0) {
                return;
            }
            _t137 =  *(readcol( &str));
             *__esp = _t137;
            atoi();
            cookie->flag = _t137;
            if(( *str & 255) == 0) {
                return;
            }
            _t143 =  *(readcol( &str));
             *__esp = _t143;
            atoi();
            cookie->version = _t143;
            if(( *str & 255) == 0) {
                return;
            }
            cookie->comment = readcol( &str);
            if(cookie->comment->url.user == 0) {
                cookie->comment = 0;
            }
            if(( *str & 255) == 0) {
                return;
            }
            cookie->portl = make_portlist(readcol( &str));
            if(( *str & 255) != 0) {
                cookie->commentURL = readcol( &str);
                if(cookie->commentURL->url.user == 0) {
                    cookie->commentURL = 0;
                }
                if(p == 0) {
                    First_cookie = cookie;
                } else {
                    p->next = cookie;
                }
                p = cookie;
                continue;
            }
            return;
        }
         *__esp = fp;
        fclose();
        return;
    }
    goto L7;
}

void initCookie()
{// addr = 0x080AB0D8  --  defined in 'cookie.c' at line 538
    load_cookies();
    check_expired_cookies();
}

Buffer* cookie_list_panel()
{// addr = 0x080AB0EA  --  defined in 'cookie.c' at line 545
    signed int _v16;                       // _cfa_fffffff0
    char[79] tmp2;                         // _cfa_ffffffa0
    Str src;               // _cfa_ffffff9c
    struct cookie* p;   // _cfa_ffffff98
    int i;                                 // _cfa_ffffff94
    char* tmp;                             // _cfa_ffffff90
    char* _v140;                           // _cfa_ffffff74
    int _v144;                             // _cfa_ffffff70
    char* _v148;                           // _cfa_ffffff6c
    int _v152;                             // _cfa_ffffff68 (outparam)
    Buffer* _t159;      // _t159
    char* _t206;                           // _t206
    char* _t217;                           // _t217
    time_t* _t287;      // _t287
    char* _t292;                           // _t292

    _v16 =  *gs:0x14];
    src = Strnew_charp("<html><head><title>Cookies</title></head><body><center><b>Cookies</b></center><p><form method=internal action=cookie>");
    if(use_cookie == 0 || First_cookie == 0) {
        _t159 = 0;
        goto L35;
    } else {
        Strcat_charp(src, "<ol>");
        p = First_cookie;
        i = 0;
        while(p != 0) {
            tmp = html_quote( *(parsedURL2Str(p)));
            if(p->expires == -1) {
                tmp2 = 0;
            } else {
                _t287 =  &(p->expires);
                 *__esp = _t287;
                gmtime();
                _v144 = _t287;
                _v148 = "%a, %d %b %Y %H:%M:%S GMT";
                _v152 = 80;
                 *__esp =  &tmp2;
                strftime();
            }
            Strcat_charp(src, "<li>");
            Strcat_charp(src, "<h1><a href="");
            Strcat_charp(src, tmp);
            Strcat_charp(src, "">");
            Strcat_charp(src, tmp);
            Strcat_charp(src, "</a></h1>");
            Strcat_charp(src, "<table cellpadding=0>");
            if((p->flag & 2) == 0) {
                Strcat_charp(src, "<tr><td width="80"><b>Cookie:</b></td><td>");
                Strcat_charp(src, html_quote( *(make_cookie(p))));
                Strcat_charp(src, "</td></tr>");
            }
            if(p->comment != 0) {
                Strcat_charp(src, "<tr><td width="80"><b>Comment:</b></td><td>");
                Strcat_charp(src, html_quote( *(p->comment)));
                Strcat_charp(src, "</td></tr>");
            }
            if(p->commentURL != 0) {
                Strcat_charp(src, "<tr><td width="80"><b>CommentURL:</b></td><td>");
                Strcat_charp(src, "<a href="");
                Strcat_charp(src, html_quote( *(p->commentURL)));
                Strcat_charp(src, "">");
                Strcat_charp(src, html_quote( *(p->commentURL)));
                Strcat_charp(src, "</a>");
                Strcat_charp(src, "</td></tr>");
            }
            if((tmp2 & 255) != 0) {
                Strcat_charp(src, "<tr><td width="80"><b>Expires:</b></td><td>");
                Strcat_charp(src,  &tmp2);
                if((p->flag & 0x10) != 0) {
                    Strcat_charp(src, " (Discard)");
                }
                Strcat_charp(src, "</td></tr>");
            }
            Strcat_charp(src, "<tr><td width="80"><b>Version:</b></td><td>");
            _v152 = p->version & 255;
            Strcat_charp(src,  *(Sprintf("%d")));
            Strcat_charp(src, "</td></tr><tr><td>");
            if(p->domain != 0) {
                Strcat_charp(src, "<tr><td width="80"><b>Domain:</b></td><td>");
                Strcat_charp(src, html_quote( *(p->domain)));
                Strcat_charp(src, "</td></tr>");
            }
            if(p->path != 0) {
                Strcat_charp(src, "<tr><td width="80"><b>Path:</b></td><td>");
                Strcat_charp(src, html_quote( *(p->path)));
                Strcat_charp(src, "</td></tr>");
            }
            if(p->portl != 0) {
                Strcat_charp(src, "<tr><td width="80"><b>Port:</b></td><td>");
                Strcat_charp(src, html_quote( *(portlist2str(p->portl))));
                Strcat_charp(src, "</td></tr>");
            }
            Strcat_charp(src, "<tr><td width="80"><b>Secure:</b></td><td>");
            if((p->flag & 2) == 0) {
                _t206 = "No";
            } else {
                _t206 = "Yes";
            }
            Strcat_charp(src, _t206);
            Strcat_charp(src, "</td></tr><tr><td>");
            if((p->flag & 1) != 0) {
                _t292 = 135070108;
            } else {
                _t292 = " checked";
            }
            if((p->flag & 1) == 0) {
                _t217 = 135070108;
            } else {
                _t217 = " checked";
            }
            _v140 = _t292;
            _v144 = i;
            _v148 = _t217;
            _v152 = i;
            Strcat(src, Sprintf("<tr><td width="80"><b>Use:</b></td><td><input type=radio name="%d" value=1%s>Yes&nbsp;&nbsp;<input type=radio name="%d" value=0%s>No"));
            Strcat_charp(src, "</td></tr><tr><td><input type=submit value="OK"></table><p>");
            p = p->next;
            i = i + 1;
        }
        Strcat_charp(src, "</ol></form></body></html>");
        _t159 = loadHTMLString(src);
L35:
        if((_v16 ^  *gs:0x14]) == 0) {
            return _t159;
        }
        __stack_chk_fail();
        return _t159;
    }
}

void set_cookie_flag(struct parsed_tagarg* arg)
{// addr = 0x080AB643  --  defined in 'cookie.c' at line 660
    int n;                                 // _cfa_fffffff0
    int v;                                 // _cfa_ffffffec
    struct cookie* p;   // _cfa_ffffffe8
    _unknown_ _t48;                        // _t48
    _unknown_ _t50;                        // _t50

    while(arg != 0) {
        arg = arg->next;
    }
    backBf();
}

int check_cookie_accept_domain(char* domain)
{// addr = 0x080AB748  --  defined in 'cookie.c' at line 684
    TextListItem* tl;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(domain == 0) {
        return 0;
    }
    if(Cookie_accept_domains == 0 || (Cookie_accept_domains->nitem & 65535) <= 0) {
L9:
        if(Cookie_reject_domains == 0 || (Cookie_reject_domains->nitem & 65535) <= 0) {
L16:
            return 1;
        } else {
            tl = Cookie_reject_domains->first;
            while(tl != 0) {
                if(domain_match(domain, tl->ptr) == 0) {
                    tl = tl->next;
                    continue;
                }
                return 0;
            }
            goto L16;
        }
    } else {
        tl = Cookie_accept_domains->first;
        while(tl != 0) {
            if(domain_match(domain, tl->ptr) == 0) {
                tl = tl->next;
                continue;
            }
            return 1;
        }
        goto L9;
    }
}

Buffer* historyBuffer(Hist* hist)
{// addr = 0x080AB808  --  defined in 'history.c' at line 6
    Str src;               // _cfa_fffffff0
    HistItem* item;   // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    char* q;                               // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    src = Strnew();
    Strcat_charp(src, "<html>\n<head><title>History Page</title></head>\n");
    Strcat_charp(src, "<body>\n<h1>History Page</h1>\n<hr>\n");
    Strcat_charp(src, "<ol>\n");
    if(hist == 0 || hist->list == 0) {
L8:
        Strcat_charp(src, "</ol>\n</body>\n</html>");
        return loadHTMLString(src);
    } else {
        item = hist->list->last;
        while(item != 0) {
            q = html_quote(item->ptr);
            if(DecodeURL == 0) {
                p = q;
            } else {
                p = html_quote(url_unquote_conv(item->ptr, 0));
            }
            Strcat_charp(src, "<li><a href="");
            Strcat_charp(src, q);
            Strcat_charp(src, "">");
            Strcat_charp(src, p);
            Strcat_charp(src, "</a>\n");
            item = item->prev;
        }
        goto L8;
    }
}

void loadHistory(Hist* hist)
{// addr = 0x080AB947  --  defined in 'history.c' at line 35
    FILE* f;              // _cfa_fffffff0
    Str line;              // _cfa_ffffffec
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    FILE* _t17;           // _t17
    FILE* _t18;           // _t18

    if(hist != 0) {
        _t17 = rcFile("history");
        _v40 = "rt";
         *__esp = _t17;
        fopen();
        f = _t17;
        if(f != 0) {
            while(1) {
                _t18 = f;
                 *__esp = _t18;
                feof();
                if(_t18 != 0) {
                    break;
                }
                line = Strfgets(f);
                Strchop(line);
                Strremovefirstspaces(line);
                Strremovetrailingspaces(line);
                if(line->length != 0) {
                    pushHist(hist, url_quote(line->ptr));
                }
            }
             *__esp = f;
            fclose();
            return;
        }
        return;
    }
}

void saveHistory(Hist* hist, size_t size)
{// addr = 0x080AB9FE  --  defined in 'history.c' at line 58
    FILE* f;              // _cfa_fffffff0
    HistItem* item;   // _cfa_ffffffec
    char* tmpf;                            // _cfa_ffffffe8
    _Unknown_base* _v36;                   // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    FILE* _t37;           // _t37
    FILE* _t47;           // _t47

    if(hist == 0) {
        return;
    }
    if(hist->list != 0) {
        tmpf =  *(tmpfname(0, 0));
        _t37 = tmpf;
        _v40 = 135071205;
         *__esp = _t37;
        fopen();
        f = _t37;
        if(f != 0) {
            item = hist->list->first;
            while(item != 0) {
                if((hist->list->nitem & 65535) > size) {
                    size = size + 1;
                    item = item->next;
                    continue;
                }
L10:
                while(item != 0) {
                    _v36 = item->ptr;
                    _v40 = "%s\n";
                     *__esp = f;
                    fprintf();
                    item = item->next;
                }
                _t47 = f;
                 *__esp = _t47;
                fclose();
                if(_t47 != -1) {
                    _v40 = rcFile("history");
                     *__esp = tmpf;
                    rename();
                    return;
                }
                disp_err_message("Can't save history", 0);
                return;
            }
            goto L10;
        }
        disp_err_message("Can't open history", 0);
        return;
    }
}

Hist* newHist()
{// addr = 0x080ABB11  --  defined in 'history.c' at line 87
    Hist* hist;           // _cfa_fffffff0

     *__esp = 12;
    GC_malloc();
    hist = __eax;
    hist->list = newGeneralList();
    hist->current = 0;
    hist->hash = 0;
    return hist;
}

Hist* copyHist(Hist* hist)
{// addr = 0x080ABB49  --  defined in 'history.c' at line 99
    Hist* new;            // _cfa_fffffff0
    HistItem* item;   // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(hist != 0) {
        new = newHist();
        item = hist->list->first;
        while(item != 0) {
            pushHist(new, item->ptr);
            item = item->next;
        }
        return new;
    }
    return 0;
}

HistItem* unshiftHist(Hist* hist, char* ptr)
{// addr = 0x080ABB98  --  defined in 'history.c' at line 113
    HistItem* item;   // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(hist == 0 || hist->list == 0) {
        return 0;
    } else {
        item = newListItem(allocStr(ptr, -1), hist->list->first, 0);
        if(hist->list->first == 0) {
            hist->list->last = item;
        } else {
            hist->list->first->prev = item;
        }
        hist->list->first = item;
        hist->list->nitem = (hist->list->nitem & 65535) + 1;
        return item;
    }
}

HistItem* pushHist(Hist* hist, char* ptr)
{// addr = 0x080ABC2E  --  defined in 'history.c' at line 131
    HistItem* item;   // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(hist == 0 || hist->list == 0) {
        return 0;
    } else {
        item = newListItem(allocStr(ptr, -1), 0, hist->list->last);
        if(hist->list->last == 0) {
            hist->list->first = item;
        } else {
             *(hist->list->last + 4) = item;
        }
        hist->list->last = item;
        hist->list->nitem = (hist->list->nitem & 65535) + 1;
        return item;
    }
}

HistItem* pushHashHist(Hist* hist, char* ptr)
{// addr = 0x080ABCC7  --  defined in 'history.c' at line 151
    HistItem* item;   // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(hist == 0 || hist->list == 0) {
        return 0;
    } else {
        item = getHashHist(hist, ptr);
        if(item != 0) {
            if(item->next == 0) {
                hist->list->tab = item->prev;
            } else {
                item->next->prev = item->prev;
            }
            if(item->prev == 0) {
                hist->list->size = item->next;
            } else {
                item->prev->next = item->next;
            }
             *(hist->list + 8) = ( *(hist->list + 8) & 65535) - 1;
        }
        item = pushHist(hist, ptr);
        putHash_sv(hist->hash, ptr, item);
        return item;
    }
}

HistItem* getHashHist(Hist* hist, char* ptr)
{// addr = 0x080ABD98  --  defined in 'history.c' at line 175
    HistItem* item;   // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(hist == 0 || hist->list == 0) {
        return 0;
    } else {
        if(hist->hash != 0) {
L7:
            return getHash_sv(hist->hash, ptr, 0);
        }
        hist->hash = newHash_sv(127);
        item = hist->list->size;
        while(item != 0) {
            putHash_sv(hist->hash, item->ptr, item);
            item = item->next;
        }
        goto L7;
    }
}

char* lastHist(Hist* hist)
{// addr = 0x080ABE2A  --  defined in 'history.c' at line 190
    if(hist == 0 || hist->list == 0) {
        return 0;
    } else {
        if(hist->list->next == 0) {
            return 0;
        }
        hist->current = hist->list->next;
        return hist->current->ptr;
    }
}

char* nextHist(Hist* hist)
{// addr = 0x080ABE6E  --  defined in 'history.c' at line 202
    if(hist == 0 || hist->list == 0) {
        return 0;
    }
    if(hist->current == 0 || hist->current->next == 0) {
        return 0;
    } else {
        hist->current = hist->current->next;
        return hist->current->ptr;
    }
}

char* prevHist(Hist* hist)
{// addr = 0x080ABEBE  --  defined in 'history.c' at line 214
    if(hist == 0 || hist->list == 0) {
        return 0;
    }
    if(hist->current == 0 || hist->current->prev == 0) {
        return 0;
    } else {
        hist->current = hist->current->prev;
        return hist->current->ptr;
    }
}

void print_headers(Buffer* buf, int len)
{// addr = 0x080ABF10  --  defined in 'backend.c' at line 66
    TextListItem* tp;   // _cfa_fffffff0
    int _v40;                              // _cfa_ffffffd8

    if(buf->document_header != 0) {
        tp = buf->document_header->first;
        while(tp != 0) {
             *__esp = tp->ptr;
            puts();
            tp = tp->next;
        }
    }
    _v40 =  *(parsedURL2Str( &(buf->currentURL)));
     *__esp = "w3m-current-url: %s\n";
    printf();
    if(buf->baseURL != 0) {
        _v40 =  *(parsedURL2Str(buf->baseURL));
         *__esp = "w3m-base-url: %s\n";
        printf();
    }
    _v40 = buf->type;
     *__esp = "w3m-content-type: %s\n";
    printf();
    if(buf->document_charset != 0) {
        _v40 = wc_ces_to_charset(buf->document_charset);
         *__esp = "w3m-content-charset: %s\n";
        printf();
    }
    if(len > 0) {
        _v40 = len;
         *__esp = "w3m-content-length: %d\n";
        printf();
        return;
    }
}

void internal_get(char* url, int flag, FormList* request)
{// addr = 0x080AC005  --  defined in 'backend.c' at line 89
    Buffer* buf;        // _cfa_fffffff0
    TextLineListItem* p;   // _cfa_ffffffec
    Str first;             // _cfa_ffffffe8
    Str last;              // _cfa_ffffffe4
    int len;                               // _cfa_ffffffe0
    Line* lp;             // _cfa_ffffffdc
    int len;                               // _cfa_ffffffd8
    FormList* _v60;   // _cfa_ffffffc4
    int _v64;                              // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc (outparam)
    char* _v72;                            // _cfa_ffffffb8 (outparam)
    TextLine* __ebx;   // r1
    char* _t90;                            // _t90
    TextLine* _t115;   // _t115
    char* _t126;                           // _t126

    backend_halfdump_buf = 0;
    do_download = flag;
    _v60 = request;
    _v64 = 0;
    buf = loadGeneralFile(url, 0, -1);
    do_download = 0;
    if(buf == 0 || buf == 1) {
        return;
    } else {
        if(is_html_type(buf->type) == 0 || backend_halfdump_buf == 0) {
            _t90 = buf->type;
            _v72 = "text/plain";
             *__esp = _t90;
            strcasecmp();
            if(_t90 != 0) {
                print_headers(buf, 0);
                return;
            }
            len = 0;
            lp = buf->firstLine;
            while(lp != 0) {
                len = len + lp->len;
                if(( *(lp->lineBuf + lp->len - 1) & 255) != 10) {
                    len = len + 1;
                }
                lp = lp->next;
            }
            print_headers(buf, len);
             *__esp = 10;
            putchar();
            saveBuffer(buf, __imp__stdout, 1);
            return;
        } else {
            len = 0;
            p = backend_halfdump_buf->first;
            while(p != 0) {
                __ebx = p->ptr;
                if((ExtHalfdump & 255) == 0) {
                    _t115 = p->ptr->ptr;
                } else {
                    _t115 = wc_Str_conv(p->ptr->ptr, InnerCharset, DisplayCharset);
                }
                __ebx->line = _t115;
                len = len + p->ptr->ptr->pos + 1;
                p = p->next;
            }
            first = Strnew_charp("<pre>\n");
            _t126 = html_quote(buf->buffername);
            _v64 = 0;
            _v68 = "</title>\n";
            _v72 = _t126;
            last = Strnew_m_charp("</pre><title>");
            print_headers(buf, first->length + len + last->length);
             *__esp = 10;
            putchar();
            _v72 = first->ptr;
             *__esp = "%s";
            printf();
            p = backend_halfdump_buf->first;
            while(p != 0) {
                 *__esp = p->ptr->ptr->line;
                puts();
                p = p->next;
            }
            _v72 = last->ptr;
             *__esp = "%s";
            printf();
            return;
        }
    }
}

void get(TextList* argv)
{// addr = 0x080AC281  --  defined in 'backend.c' at line 139
    char* p;                               // _cfa_fffffff0
    char* url;                             // _cfa_ffffffec
    int flag;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    char* _t18;                            // _t18

    url = 0;
    flag = 0;
    while(1) {
        p = popValue(argv);
        if(p == 0) {
            break;
        }
        _v40 = "-download_only";
        _t18 = p;
         *__esp = _t18;
        strcasecmp();
        if(_t18 != 0) {
            url = p;
        } else {
            flag = 1;
        }
    }
    if(url == 0) {
        return;
    }
    internal_get(url, flag, 0);
}

void post(TextList* argv)
{// addr = 0x080AC2F3  --  defined in 'backend.c' at line 158
    FormList* request;   // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* target;                          // _cfa_ffffffe8
    char* charset;                         // _cfa_ffffffe4
    char* enctype;                         // _cfa_ffffffe0
    char* body;                            // _cfa_ffffffdc
    char* boundary;                        // _cfa_ffffffd8
    char* url;                             // _cfa_ffffffd4
    int flag;                              // _cfa_ffffffd0
    int length;                            // _cfa_ffffffcc
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ _v76;                        // _cfa_ffffffb4 (outparam)
    _unknown_ _v80;                        // _cfa_ffffffb0 (outparam)
    _unknown_ _v84;                        // _cfa_ffffffac (outparam)
    char* _v88;                            // _cfa_ffffffa8 (outparam)
    char* _t71;                            // _t71
    char* _t72;                            // _t72
    char* _t73;                            // _t73
    char* _t74;                            // _t74
    char* _t75;                            // _t75
    char* _t76;                            // _t76
    char* _t77;                            // _t77
    int _t80;                              // _t80
    long unsigned int _t97;                // _t97

    target = 0;
    charset = 0;
    enctype = 0;
    body = 0;
    boundary = 0;
    url = 0;
    flag = 0;
    length = 0;
    while(1) {
        p = popValue(argv);
        if(p == 0) {
            break;
        }
        _v88 = "-download_only";
        _t71 = p;
         *__esp = _t71;
        strcasecmp();
        if(_t71 != 0) {
            _v88 = "-target";
            _t72 = p;
             *__esp = _t72;
            strcasecmp();
            if(_t72 != 0) {
                _v88 = "-charset";
                _t73 = p;
                 *__esp = _t73;
                strcasecmp();
                if(_t73 != 0) {
                    _v88 = "-enctype";
                    _t74 = p;
                     *__esp = _t74;
                    strcasecmp();
                    if(_t74 != 0) {
                        _v88 = "-body";
                        _t75 = p;
                         *__esp = _t75;
                        strcasecmp();
                        if(_t75 != 0) {
                            _v88 = "-boundary";
                            _t76 = p;
                             *__esp = _t76;
                            strcasecmp();
                            if(_t76 != 0) {
                                _v88 = "-length";
                                _t77 = p;
                                 *__esp = _t77;
                                strcasecmp();
                                if(_t77 != 0) {
                                    url = p;
                                } else {
                                    _t80 = popValue(argv);
                                     *__esp = _t80;
                                    atol();
                                    length = _t80;
                                }
                            } else {
                                boundary = popValue(argv);
                            }
                        } else {
                            body = popValue(argv);
                        }
                    } else {
                        enctype = popValue(argv);
                    }
                } else {
                    charset = popValue(argv);
                }
            } else {
                target = popValue(argv);
            }
        } else {
            flag = 1;
        }
    }
    if(url == 0) {
        return;
    }
    request = newFormList(0, "post", charset, enctype, target, 0, 0);
    request->body = body;
    request->boundary = boundary;
    if(length <= 0) {
        if(body == 0) {
            _t97 = 0;
        } else {
            _t97 = body;
             *__esp = _t97;
            strlen();
        }
    } else {
        _t97 = length;
    }
    request->length = _t97;
    internal_get(url, flag, request);
}

void set(TextList* argv)
{// addr = 0x080AC50E  --  defined in 'backend.c' at line 196
    int i;                                 // _cfa_fffffff0
    char* _v40;                            // _cfa_ffffffd8
    TextList* _t31;   // _t31

    if((argv->nitem & 65535) > 1) {
        i = 0;
        while( *((intOrPtr*)( &variable_table + (i + i + _t44 << 2))) != 0) {
            _t31 =  *( &variable_table + (i + i + _t45 << 2));
            _v40 = argv->first->ptr;
             *__esp = _t31;
            strcasecmp();
            if(_t31 != 0) {
                i = i + 1;
                continue;
            }
            popValue(argv);
            if( *((intOrPtr*)((i + i + _t46 << 2) + 135106996)) != 0) {
                _t47 = i;
                 *__esp = argv;
                 *((intOrPtr*)( *((intOrPtr*)((i + _t47 + _t47 << 2) + 135106996))))();
                return;
            }
            goto L9;
        }
        return;
    }
L9:
}

void show(TextList* argv)
{// addr = 0x080AC5B3  --  defined in 'backend.c' at line 214
    int i;                                 // _cfa_fffffff0
    char* _v40;                            // _cfa_ffffffd8
    TextList* _t31;   // _t31

    if((argv->nitem & 65535) > 0) {
        i = 0;
        while( *((intOrPtr*)( &variable_table + (i + i + _t44 << 2))) != 0) {
            _t31 =  *( &variable_table + (i + i + _t45 << 2));
            _v40 = argv->first->ptr;
             *__esp = _t31;
            strcasecmp();
            if(_t31 != 0) {
                i = i + 1;
                continue;
            }
            popValue(argv);
            if( *((intOrPtr*)((i + i + _t46 << 2) + 135107000)) != 0) {
                _t47 = i;
                 *__esp = argv;
                 *((intOrPtr*)( *((intOrPtr*)((i + _t47 + _t47 << 2) + 135107000))))();
                return;
            }
            goto L9;
        }
        return;
    }
L9:
}

void quit(TextList* argv)
{// addr = 0x080AC657  --  defined in 'backend.c' at line 232
    save_cookies();
    w3m_exit(0);
}

void help(TextList* argv)
{// addr = 0x080AC670  --  defined in 'backend.c' at line 243
    int i;                                 // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8

    i = 0;
    while( *((intOrPtr*)( &command_table + (i << 4))) != 0) {
        _v32 =  *((intOrPtr*)((i << 4) + 135106888));
        _v36 =  *((intOrPtr*)((i << 4) + 135106884));
        _v40 =  *((intOrPtr*)( &command_table + (i << 4)));
         *__esp = "%s %s\n    %s\n";
        printf();
        i = i + 1;
    }
}

void set_column(TextList* argv)
{// addr = 0x080AC6D7  --  defined in 'backend.c' at line 255
    int _t8;                               // _t8

    if((argv->nitem & 65535) == 1) {
        _t8 = argv->first->ptr;
         *__esp = _t8;
        atol();
        COLS = _t8;
        return;
    }
}

void show_column(TextList* argv)
{// addr = 0x080AC700  --  defined in 'backend.c' at line 264
    int _v20;                              // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8

    _v20 = COLS;
    _v24 = "column=%d\n";
     *__esp = __imp__stdout;
    fprintf();
}

void call_command_function(char* str)
{// addr = 0x080AC728  --  defined in 'backend.c' at line 272
    int i;                                 // _cfa_fffffff0
    TextList* argv;   // _cfa_ffffffec
    char* _v40;                            // _cfa_ffffffd8
    TextList* _t31;   // _t31

    argv = split(str);
    if((argv->nitem & 65535) > 0) {
        i = 0;
        while( *( &command_table + (i << 4)) != 0) {
            _t31 =  *( &command_table + (i << 4));
            _v40 = argv->first->ptr;
             *__esp = _t31;
            strcasecmp();
            if(_t31 != 0) {
                i = i + 1;
                continue;
            }
            popValue(argv);
            if( *((intOrPtr*)((i << 4) + 135106892)) != 0) {
                 *__esp = argv;
                 *((intOrPtr*)( *((intOrPtr*)((i << 4) + 135106892))))();
                return;
            }
            goto L9;
        }
        return;
    }
L9:
}

int backend()
{// addr = 0x080AC7BE  --  defined in 'backend.c' at line 291
    char* str;                             // _cfa_fffffff0

    w3m_dump = 0;
    if(COLS == 0) {
        COLS = 80;
    }
    use_mouse = 0;
    if(backend_batch_commands == 0) {
        while(1) {
            str = readline("w3m> ");
            if(str == 0) {
                goto L10;
            }
            __eax = str;
            call_command_function(str);
        }
    } else {
        while(1) {
            str = popValue(backend_batch_commands);
            if(str == 0) {
                break;
            }
            call_command_function(str);
        }
    }
L10:
    quit(0);
    return 0;
}

char* readline(char* prompt)
{// addr = 0x080AC84F  --  defined in 'backend.c' at line 318
    Str s;                 // _cfa_fffffff0
    FILE* _v40;           // _cfa_ffffffd8
    FILE* _t11;           // _t11

    _v40 = __imp__stdout;
     *__esp = prompt;
    fputs();
     *__esp = __imp__stdout;
    fflush();
    s = Strfgets(__imp__stdin);
    _t11 = __imp__stdin;
     *__esp = _t11;
    feof();
    if(_t11 == 0 || (s & 255) != 0) {
        return s->ptr;
    } else {
        return 0;
    }
}

TextList* split(char* p)
{// addr = 0x080AC8B3  --  defined in 'backend.c' at line 334
    int in_double_quote;                   // _cfa_fffffff0
    int in_single_quote;                   // _cfa_ffffffec
    Str s;                 // _cfa_ffffffe8
    TextList* tp;     // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    signed int _t211;                      // _t211
    int _t220;                             // _t220
    int _t235;                             // _t235
    int _t248;                             // _t248
    signed int _t257;                      // _t257
    int _t264;                             // _t264
    int _t277;                             // _t277
    int _t290;                             // _t290
    int _t303;                             // _t303
    int _t316;                             // _t316
    int _t329;                             // _t329
    int _t342;                             // _t342

    in_double_quote = 0;
    in_single_quote = 0;
    s = Strnew();
    tp = newGeneralList();
    while(( *p & 255) != 0) {
        _t211 =  *p & 255;
        if(_t211 > 13) {
            if(_t211 == 34) {
                if(in_single_quote == 0) {
                    in_double_quote = in_double_quote == 0 & 255;
L60:
                    p =  &(p[1]);
                    continue;
                }
                if(s->length + 1 >= s->area_size) {
                    Strgrow(s);
                }
                _t220 = s->length;
                 *((char*)(s->ptr + _t220)) = 34;
                s->length = _t220 + 1;
                 *((char*)(s->ptr + s->length)) = 0;
                goto L60;
            }
            if(_t211 > 34) {
                if(_t211 == 39) {
                    if(in_double_quote == 0) {
                        in_single_quote = in_single_quote == 0 & 255;
                    } else {
                        if(s->length + 1 >= s->area_size) {
                            Strgrow(s);
                        }
                        _t235 = s->length;
                         *((char*)(s->ptr + _t235)) = 39;
                        s->length = _t235 + 1;
                         *((char*)(s->ptr + s->length)) = 0;
                    }
                    goto L60;
                }
                if(_t211 == 92) {
                    if(in_single_quote != 0) {
                        if(s->length + 1 >= s->area_size) {
                            Strgrow(s);
                        }
                        _t248 = s->length;
                         *((char*)(s->ptr + _t248)) =  *p & 255;
                        s->length = _t248 + 1;
                         *((char*)(s->ptr + s->length)) = 0;
                        goto L60;
                    }
                    p =  &(p[1]);
                    _t257 =  *p & 255;
                    if(_t257 == 110) {
                        if(s->length + 1 >= s->area_size) {
                            Strgrow(s);
                        }
                        _t264 = s->length;
                         *((char*)(s->ptr + _t264)) = 10;
                        s->length = _t264 + 1;
                         *((char*)(s->ptr + s->length)) = 0;
L45:
                        goto L60;
                    }
                    if(_t257 > 110) {
                        if(_t257 == 114) {
                            if(s->length + 1 >= s->area_size) {
                                Strgrow(s);
                            }
                            _t277 = s->length;
                             *((char*)(s->ptr + _t277)) = 13;
                            s->length = _t277 + 1;
                             *((char*)(s->ptr + s->length)) = 0;
                            goto L45;
                        }
                        if(_t257 != 116) {
L42:
                            if(s->length + 1 >= s->area_size) {
                                Strgrow(s);
                            }
                            _t290 = s->length;
                             *((char*)(s->ptr + _t290)) =  *p & 255;
                            s->length = _t290 + 1;
                             *((char*)(s->ptr + s->length)) = 0;
                            goto L60;
                        }
                        if(s->length + 1 >= s->area_size) {
                            Strgrow(s);
                        }
                        _t303 = s->length;
                         *((char*)(s->ptr + _t303)) = 9;
                        s->length = _t303 + 1;
                         *((char*)(s->ptr + s->length)) = 0;
                        goto L45;
                    }
                    if(_t257 == 0) {
L64:
                        if(s->length > 0) {
                            pushValue(tp, allocStr(s->ptr, -1));
                        }
                        return tp;
                    }
                    if(_t257 == 102) {
                        if(s->length + 1 >= s->area_size) {
                            Strgrow(s);
                        }
                        _t316 = s->length;
                         *((char*)(s->ptr + _t316)) = 12;
                        s->length = _t316 + 1;
                         *((char*)(s->ptr + s->length)) = 0;
                        goto L45;
                    }
                    goto L42;
                } else {
L56:
                    if(s->length + 1 >= s->area_size) {
                        Strgrow(s);
                    }
                    _t329 = s->length;
                     *((char*)(s->ptr + _t329)) =  *p & 255;
                    s->length = _t329 + 1;
                     *((char*)(s->ptr + s->length)) = 0;
                    goto L60;
                }
            }
            if(_t211 == 32) {
L49:
                if(in_double_quote != 0 || in_single_quote != 0) {
                    if(s->length + 1 >= s->area_size) {
                        Strgrow(s);
                    }
                    _t342 = s->length;
                     *((char*)(s->ptr + _t342)) =  *p & 255;
                    s->length = _t342 + 1;
                     *((char*)(s->ptr + s->length)) = 0;
                } else {
                    if(s->length > 0) {
                        pushValue(tp, allocStr(s->ptr, -1));
                        s = Strnew();
                    }
                }
                goto L60;
            } else {
                goto L56;
            }
        }
        if(_t211 >= 12 || _t211 - 9 <= 1) {
            goto L49;
        } else {
            goto L56;
        }
    }
    goto L64;
}

AnchorList* putAnchor(AnchorList* al, char* url, char* target, Anchor** anchor_return, char* referer, char* title, unsigned char key, int line, int pos)
{// addr = 0x080ACD68  --  defined in 'anchor.c' at line 9
    int n;                                 // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    Anchor* a;          // _cfa_ffffffe4
    int _v32;                              // _cfa_ffffffe0
    int _v36;                              // _cfa_ffffffdc
    BufferPoint bp;   // _cfa_ffffffd8
    signed char _v48;                      // _cfa_ffffffd0
    intOrPtr _v72;                         // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    AnchorList* _t161;   // _t161
    Anchor* _t163;      // _t163
    Anchor* _t183;      // _t183
    Anchor* _t184;      // _t184
    unsigned int _t220;                    // _t220
    intOrPtr* _t227;                       // _t227
    Anchor* _t251;      // _t251
    intOrPtr* _t338;                       // _t338

    _t161 = key;
    _v48 = _t161;
    if(al == 0) {
         *__esp = 16;
        GC_malloc();
        al = _t161;
        al->anchors = 0;
        al->anchormax = 0;
        al->nanchor = al->anchormax;
        al->acache = -1;
    }
    _t163 = al->anchormax;
    if(_t163 == 0) {
         *__esp = 1800;
        GC_malloc();
        al->anchors = _t163;
        al->anchormax = 30;
    }
    if(al->nanchor == al->anchormax) {
        al->anchormax = al->anchormax + al->anchormax;
        _t251 = al->anchors;
        _v72 = (al->anchormax << 2 << 4) - (al->anchormax << 2);
         *__esp = _t251;
        GC_realloc();
        al->anchors = _t251;
    }
    bp.auto_detect = line;
    _v36 = pos;
    n = al->nanchor;
    if(n == 0) {
L11:
        i = n;
    } else {
        if( *((intOrPtr*)(al->anchors + (n - 1 << 2 << 4) - (n - 1 << 2) + 20)) == bp.auto_detect) {
            if( *((intOrPtr*)(al->anchors + (n - 1 << 2 << 4) - (n - 1 << 2) + 24)) - _v36 >= 0) {
                goto L12;
            } else {
                goto L11;
            }
        } else {
            if( *((intOrPtr*)(al->anchors + (n - 1 << 2 << 4) - (n - 1 << 2) + 20)) - bp.auto_detect < 0) {
                goto L11;
            } else {
L12:
                i = 0;
                while(i < n) {
                    if(al->anchors + (i << 2 << 4) - (i << 2)->start.line == bp.auto_detect) {
                        _t220 =  !(al->anchors + (i << 2 << 4) - (i << 2)->start.pos - _v36) >> 31;
                    } else {
                        _t220 =  !(al->anchors + (i << 2 << 4) - (i << 2)->start.line - bp.auto_detect) >> 31;
                    }
                    if(_t220 == 0) {
                        i = i + 1;
                        continue;
                    } else {
                        j = n;
                        while(j > i) {
                            _t227 = al->anchors + (j << 2 << 4) - (j << 2);
                            _t338 = al->anchors + (j - 1 << 2 << 4) - (j - 1 << 2);
                             *_t227 =  *_t338;
                            _t227[1] = _t338[1];
                            _t227[2] = _t338[2];
                            _t227[3] = _t338[3];
                             *((intOrPtr*)(16 + _t227)) =  *((intOrPtr*)(16 + _t338));
                            _t227[5] = _t338[5];
                            _t227[6] = _t338[6];
                            _t227[7] = _t338[7];
                            _t227[8] = _t338[8];
                            _t227[9] = _t338[9];
                            _t227[0xa] = _t338[0xa];
                            _t227[0xb] = _t338[0xb];
                            _t227[0xc] = _t338[0xc];
                            _t227[0xd] = _t338[0xd];
                            _t227[0xe] = _t338[0xe];
                            j = j - 1;
                        }
                    }
                    goto L23;
                }
            }
        }
    }
L23:
    a = al->anchors + (i << 2 << 4) - (i << 2);
    a->url = url;
    a->target = target;
    a->referer = referer;
    a->title = title;
    a->accesskey = _v48 & 255;
    a->slave = 0;
    _t183 = a;
    _t183->start.line = bp.auto_detect;
    _t183->start.pos = _v36;
    _t183->start.invalid = _v32;
    _t184 = a;
    _t184->end.line = bp.auto_detect;
    _t184->end.pos = _v36;
    _t184->end.invalid = _v32;
    al->nanchor = al->nanchor + 1;
    if(anchor_return != 0) {
         *anchor_return = a;
    }
    return al;
}

Anchor* registerHref(Buffer* buf, char* url, char* target, char* referer, char* title, unsigned char key, int line, int pos)
{// addr = 0x080AD0B4  --  defined in 'anchor.c' at line 60
    Anchor* a;          // _cfa_fffffff0
    signed char _v32;                      // _cfa_ffffffe0
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ _v76;                        // _cfa_ffffffb4 (outparam)
    _unknown_ _v80;                        // _cfa_ffffffb0 (outparam)
    _unknown_ _v84;                        // _cfa_ffffffac (outparam)
    _unknown_ _v88;                        // _cfa_ffffffa8 (outparam)

    _v32 = key;
    buf->href = putAnchor(buf->href, url, target,  &a, referer, title, _v32 & 255, line, pos);
    return a;
}

Anchor* registerName(Buffer* buf, char* url, int line, int pos)
{// addr = 0x080AD112  --  defined in 'anchor.c' at line 70
    Anchor* a;          // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)

    buf->name = putAnchor(buf->name, url, 0,  &a, 0, 0, 0, line, pos);
    return a;
}

Anchor* registerImg(Buffer* buf, char* url, char* title, int line, int pos)
{// addr = 0x080AD16D  --  defined in 'anchor.c' at line 79
    Anchor* a;          // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)

    buf->img = putAnchor(buf->img, url, 0,  &a, 0, title, 0, line, pos);
    return a;
}

Anchor* registerForm(Buffer* buf, FormList* flist, struct parsed_tag* tag, int line, int pos)
{// addr = 0x080AD1C7  --  defined in 'anchor.c' at line 88
    Anchor* a;          // _cfa_fffffff0
    FormItemList* fi;   // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1

    fi = formList_addInput(flist, tag);
    if(fi != 0) {
        buf->formitem = putAnchor(buf->formitem, fi, flist->target,  &a, 0, 0, 0, line, pos);
        return a;
    }
    return 0;
}

int onAnchor(Anchor* a, int line, int pos)
{// addr = 0x080AD24B  --  defined in 'anchor.c' at line 103
    int _v12;                              // _cfa_fffffff4
    BufferPoint bp;   // _cfa_fffffff0
    unsigned int _t30;                     // _t30
    _unknown_ _t36;                        // _t36

    bp.auto_detect = line;
    _v12 = pos;
    if(bp.auto_detect == a->start.line) {
        _t30 = _v12 - a->start.pos >> 31;
    } else {
        _t30 = bp.auto_detect - a->start.line >> 31;
    }
    if(_t30 == 0) {
        if(a->end.line == bp.auto_detect) {
            _t36 = a->end.pos - _v12 <= 0;
        } else {
            _t36 = a->end.line - bp.auto_detect <= 0;
        }
        if(_t36 == 0) {
            return 0;
        } else {
            return 1;
        }
    } else {
        return -1;
    }
}

Anchor* retrieveAnchor(AnchorList* al, int line, int pos)
{// addr = 0x080AD2E4  --  defined in 'anchor.c' at line 117
    Anchor* a;          // _cfa_fffffff4
    size_t b;           // _cfa_fffffff0
    size_t e;           // _cfa_ffffffec
    int cmp;                               // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ __ebx;                       // r1

    if(al == 0 || al->nanchor == 0) {
        return 0;
    }
    if(al->acache < 0 || al->acache >= al->nanchor) {
        al->acache = 0;
    }
    b = 0;
    e = al->nanchor - 1;
    while(b <= e) {
        a = al->anchors + (al->acache << 2 << 4) - (al->acache << 2);
        cmp = onAnchor(a, line, pos);
        if(cmp != 0) {
            if(cmp <= 0) {
                if(al->acache != 0) {
                    e = al->acache - 1;
L14:
                    al->acache = b + e >> 1;
                    continue;
                }
                return 0;
            }
            b = al->acache + 1;
            goto L14;
        }
        return a;
    }
    return 0;
}

Anchor* retrieveCurrentAnchor(Buffer* buf)
{// addr = 0x080AD3E2  --  defined in 'anchor.c' at line 145
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)
    _unknown_ _v12;                        // _cfa_fffffff4 (outparam)

    if(buf->currentLine != 0) {
        return retrieveAnchor(buf->href, buf->currentLine->linenumber, buf->pos);
    }
    return 0;
}

Anchor* retrieveCurrentImg(Buffer* buf)
{// addr = 0x080AD420  --  defined in 'anchor.c' at line 153
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)
    _unknown_ _v12;                        // _cfa_fffffff4 (outparam)

    if(buf->currentLine != 0) {
        return retrieveAnchor(buf->img, buf->currentLine->linenumber, buf->pos);
    }
    return 0;
}

Anchor* retrieveCurrentForm(Buffer* buf)
{// addr = 0x080AD45E  --  defined in 'anchor.c' at line 161
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)
    _unknown_ _v12;                        // _cfa_fffffff4 (outparam)

    if(buf->currentLine != 0) {
        return retrieveAnchor(buf->formitem, buf->currentLine->linenumber, buf->pos);
    }
    return 0;
}

Anchor* searchAnchor(AnchorList* al, char* str)
{// addr = 0x080AD49C  --  defined in 'anchor.c' at line 170
    int i;                                 // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    char* _t28;                            // _t28

    if(al != 0) {
        i = 0;
        while(al->nanchor > i) {
            a = al->anchors + (i << 2 << 4) - (i << 2);
            if(a->hseq < 0) {
L7:
                i = i + 1;
                continue;
            }
            _t28 = a->url;
            _v40 = str;
             *__esp = _t28;
            strcmp();
            if(_t28 != 0) {
                goto L7;
            }
            return a;
        }
        return 0;
    }
    return 0;
}

Anchor* searchURLLabel(Buffer* buf, char* url)
{// addr = 0x080AD517  --  defined in 'anchor.c' at line 187
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return searchAnchor(buf->name, url);
}

Anchor* _put_anchor_news(Buffer* buf, char* p1, char* p2, int line, int pos)
{// addr = 0x080AD534  --  defined in 'anchor.c' at line 194
    Str tmp;               // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    char* _v56;                            // _cfa_ffffffc8 (outparam)

    if(( *p1 & 255) == 60) {
        p1 =  &(p1[1]);
        if(( *(p2 - 1) & 255) == 62) {
            p2 = p2 - 1;
        }
    }
    tmp = wc_Str_conv_strict(Strnew_charp_n(p1, p2 - p1), InnerCharset, buf->document_charset);
    _v56 = file_quote(tmp->ptr);
    tmp = Sprintf("news:%s");
    return registerHref(buf, tmp->ptr, 0, -1, 0, 0, line, pos);
}

Anchor* _put_anchor_all(Buffer* buf, char* p1, char* p2, int line, int pos)
{// addr = 0x080AD601  --  defined in 'anchor.c' at line 212
    Str tmp;               // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    tmp = wc_Str_conv_strict(Strnew_charp_n(p1, p2 - p1), InnerCharset, buf->document_charset);
    return registerHref(buf, url_quote(tmp->ptr), 0, -1, 0, 0, line, pos);
}

void reseq_anchor0(AnchorList* al, short int* seqmap)
{// addr = 0x080AD697  --  defined in 'anchor.c' at line 223
    int i;                                 // _cfa_fffffff4
    Anchor* a;          // _cfa_fffffff0
    _unknown_ __ebx;                       // r1

    if(al != 0) {
        i = 0;
        while(al->nanchor > i) {
            a = al->anchors + (i << 2 << 4) - (i << 2);
            if(a->hseq >= 0) {
                a->hseq =  *(seqmap + a->hseq + a->hseq) & 65535;
            }
            i = i + 1;
        }
        return;
    }
}

void reseq_anchor(Buffer* buf)
{// addr = 0x080AD702  --  defined in 'anchor.c' at line 241
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int n;                                 // _cfa_ffffffe8
    int nmark;                             // _cfa_ffffffe4
    short int* seqmap;                     // _cfa_ffffffe0
    Anchor* a;          // _cfa_ffffffdc
    Anchor* a1;         // _cfa_ffffffd8
    HmarkerList* ml;   // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t144;                             // _t144
    short int* _t161;                      // _t161

    if(buf->hmarklist == 0) {
        _t144 = 0;
    } else {
        _t144 = buf->hmarklist->nmark;
    }
    nmark = _t144;
    ml = 0;
    if(buf->href == 0) {
        return;
    }
    n = nmark;
    i = 0;
    while(buf->href->nanchor > i) {
        a = buf->href->anchors + (i << 2 << 4) - (i << 2);
        if(a->hseq.line == -2) {
            n = n + 1;
        }
        i = i + 1;
    }
    if(n != nmark) {
        _t161 = n + n;
         *__esp = _t161;
        GC_malloc_atomic();
        seqmap = _t161;
        i = 0;
        while(i < n) {
             *(seqmap + i + i) = i;
            i = i + 1;
        }
        n = nmark;
        i = 0;
        while(buf->href->nanchor > i) {
            a = buf->href->anchors + (i << 2 << 4) - (i << 2);
            if(a->hseq.line != -2) {
L21:
                i = i + 1;
                continue;
            }
            a->hseq.line = n;
            a1 = closest_next_anchor(buf->href, 0, a->start.pos, a->start.line);
            a1 = closest_next_anchor(buf->formitem, a1, a->start.pos, a->start.line);
            if(a1 == 0 || a1->hseq < 0) {
L20:
                ml = putHmarker(ml, a->start.line, a->start.pos,  *(seqmap + n + n) & 65535);
                n = n + 1;
                goto L21;
            } else {
                 *(seqmap + n + n) =  *(seqmap + a1->hseq + a1->hseq) & 65535;
                j = a1->hseq;
                while(j < nmark) {
                     *(seqmap + j + j) = ( *(seqmap + j + j) & 65535) + 1;
                    j = j + 1;
                }
                goto L20;
            }
        }
        i = 0;
        while(i < nmark) {
            _t255 = i;
            ml = putHmarker(ml,  *(buf->hmarklist->marks + (i + i + i << 2)),  *(buf->hmarklist->marks + (i + i + _t255 << 2) + 4),  *(seqmap + i + i) & 65535);
            i = i + 1;
        }
        buf->hmarklist = ml;
        reseq_anchor0(buf->href, seqmap);
        reseq_anchor0(buf->formitem, seqmap);
        return;
    }
}

char* reAnchorPos(Buffer* buf, Line* l, char* p1, char* p2, _None* anchorproc)
{// addr = 0x080AD9BB  --  defined in 'anchor.c' at line 296
    Anchor* a;          // _cfa_fffffff0
    int spos;                              // _cfa_ffffffec
    int epos;                              // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    int hseq;                              // _cfa_ffffffe0
    int _v60;                              // _cfa_ffffffc4
    long int _v64;                         // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    Anchor* _t129;      // _t129

    hseq = -2;
    spos = p1 - l->lineBuf;
    epos = p2 - l->lineBuf;
    i = spos;
    do {
    } while(i < epos);
    i = spos;
    while(i < epos) {
         *(l->propBuf + i + i) =  *(l->propBuf + i + i) & 65535 | 16;
        i = i + 1;
    }
    while(l->len < spos && l->next != 0 && l->next->bpos != 0) {
        spos = spos - l->len;
        epos = epos - l->len;
        l = l->next;
    }
    while(1) {
        _v60 = spos;
        _v64 = l->linenumber;
        _v68 = p2;
        _v72 = p1;
         *__esp = buf;
        _t129 = anchorproc;
        _t129->url();
        a = _t129;
        a->hseq.line = hseq;
        if(hseq == -2) {
            reseq_anchor(buf);
            hseq = a->hseq.line;
        }
        a->end.line = l->linenumber;
        if(l->len >= epos || l->next == 0 || l->next->bpos == 0) {
            break;
        }
        a->end.pos = l->len;
        spos = 0;
        epos = epos - l->len;
        l = l->next;
    }
    a->end.pos = epos;
    return p2;
}

void reAnchorWord(Buffer* buf, Line* l, int spos, int epos)
{// addr = 0x080ADB4D  --  defined in 'anchor.c' at line 339
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    reAnchorPos(buf, l,  &(l->lineBuf[spos]),  &(l->lineBuf[epos]), _put_anchor_all);
}

char* reAnchorAny(Buffer* buf, char* re, _None* anchorproc)
{// addr = 0x080ADB8C  --  defined in 'anchor.c' at line 347
    Line* l;              // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* p1;                              // _cfa_ffffffe8
    char* p2;                              // _cfa_ffffffe4
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    Line* _t66;           // _t66

    p = 0;
    if(re == 0) {
L2:
        return 0;
    }
    if(( *re & 255) != 0) {
        re = regexCompile(re, 1);
        if(re != 0) {
            return re;
        }
        if(MarkAllPages == 0) {
            _t66 = buf->topLine;
        } else {
            _t66 = buf->firstLine;
        }
        l = _t66;
        while(l != 0 && (MarkAllPages != 0 || l->linenumber < buf->topLine->linenumber + LINES - 1)) {
            if(p == 0 || l->bpos == 0) {
                p = l->lineBuf;
                while(regexMatch(p, l->lineBuf + l->size - p, l->lineBuf == p & 255) == 1) {
                    matchedPosition( &p1,  &p2);
                    p = reAnchorPos(buf, l, p1, p2, anchorproc);
                }
                goto L16;
            } else {
L16:
                if(MarkAllPages != 0 && l->next == 0 && buf->pagerSource != 0 && (buf->bufferprop & 0x40) == 0) {
                    getNextPage(buf, PagerMax);
                }
                l = l->next;
                continue;
            }
        }
        return 0;
    }
    goto L2;
}

char* reAnchor(Buffer* buf, char* re)
{// addr = 0x080ADD1D  --  defined in 'anchor.c' at line 382
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return reAnchorAny(buf, re, _put_anchor_all);
}

char* reAnchorNews(Buffer* buf, char* re)
{// addr = 0x080ADD3F  --  defined in 'anchor.c' at line 389
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return reAnchorAny(buf, re, _put_anchor_news);
}

char* reAnchorNewsheader(Buffer* buf)
{// addr = 0x080ADD61  --  defined in 'anchor.c' at line 395
    Line* l;              // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* p1;                              // _cfa_ffffffe8
    char* p2;                              // _cfa_ffffffe4
    char** header;                         // _cfa_ffffffe0
    char** q;                              // _cfa_ffffffdc
    int i;                                 // _cfa_ffffffd8
    int search;                            // _cfa_ffffffd4
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    char* _v68;                            // _cfa_ffffffbc (outparam)
    char* _v72;                            // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    char* _t107;                           // _t107
    char* _t110;                           // _t110
    char* _t111;                           // _t111

    search = 0;
    if(buf == 0 || buf->firstLine == 0) {
        return 0;
    }
    i = 0;
    while(i <= 1) {
        if(i != 0) {
            regexCompile("[a-zA-Z0-9\\.\\-_]+", 1);
            header =  &header_group;
        } else {
            regexCompile("<[!-;=?-~]+[a-zA-Z0-9\\.\\-_]+>", 1);
            header =  &header_mid;
        }
        l = buf->firstLine;
        while(l != 0 && l->real_linenumber == 0) {
            if(l->bpos != 0) {
L21:
                l = l->next;
                continue;
            }
            p = l->lineBuf;
            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
L15:
                if(search == 0) {
                    goto L21;
                }
                while(regexMatch(p, l->lineBuf + l->size - p, l->lineBuf == p & 255) == 1) {
                    matchedPosition( &p1,  &p2);
                    p = reAnchorPos(buf, l, p1, p2, _put_anchor_news);
                }
                goto L21;
            }
            search = 0;
            q = header;
            while( *q != 0) {
                _t107 =  *q;
                 *__esp = _t107;
                strlen();
                _v68 = _t107;
                _v72 =  *q;
                _t110 = p;
                 *__esp = _t110;
                strncasecmp();
                if(_t110 != 0) {
                    q =  &(q[1]);
                    continue;
                }
                search = 1;
                _v72 = 58;
                _t111 = p;
                 *__esp = _t111;
                strchr();
                p =  &(_t111[1]);
                goto L15;
            }
            goto L15;
        }
        i = i + 1;
    }
    reseq_anchor(buf);
    return 0;
}

HmarkerList* putHmarker(HmarkerList* ml, int line, int pos, int seq)
{// addr = 0x080ADF4A  --  defined in 'anchor.c' at line 454
    signed int _v24;                       // _cfa_ffffffe8
    BufferPoint* _t95;   // _t95
    BufferPoint* _t105;   // _t105

    if(ml == 0) {
         *__esp = 16;
        GC_malloc();
        ml = __eax;
        ml->marks = 0;
        ml->nmark = 0;
        ml->markmax = 0;
        ml->prevhseq = -1;
    }
    if(ml->markmax == 0) {
        ml->markmax = 30;
        _t105 = ml->markmax + ml->markmax + ml->markmax << 2;
         *__esp = _t105;
        GC_malloc_atomic();
        ml->marks = _t105;
        _v24 = ml->markmax + ml->markmax + ml->markmax << 2;
         *__esp = ml->marks;
        bzero();
    }
    if(seq + 1 > ml->nmark) {
        ml->nmark = seq + 1;
    }
    if(ml->nmark >= ml->markmax) {
        ml->markmax = ml->nmark + ml->nmark;
        _t130 = ml->markmax;
        _t95 = ml->marks;
        _v24 = ml->markmax + ml->markmax + _t130 << 2;
         *__esp = _t95;
        GC_realloc();
        ml->marks = _t95;
    }
     *(ml->marks + (seq + seq + seq << 2)) = line;
    (ml->marks + (seq + seq + seq << 2))[1] = pos;
    (ml->marks + (seq + seq + seq << 2))[2] = 0;
    return ml;
}

Anchor* closest_next_anchor(AnchorList* a, Anchor* an, int x, int y)
{// addr = 0x080AE09D  --  defined in 'anchor.c' at line 481
    int i;                                 // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5

    if(a == 0) {
L2:
        return an;
    }
    if(a->nanchor != 0) {
        i = 0;
        while(a->nanchor > i) {
            i = i + 1;
        }
        return an;
    }
    goto L2;
}

Anchor* closest_prev_anchor(AnchorList* a, Anchor* an, int x, int y)
{// addr = 0x080AE20C  --  defined in 'anchor.c' at line 502
    int i;                                 // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5

    if(a == 0) {
L2:
        return an;
    }
    if(a->nanchor != 0) {
        i = 0;
        while(a->nanchor > i) {
            i = i + 1;
        }
        return an;
    }
    goto L2;
}

void shiftAnchorPosition(AnchorList* al, HmarkerList* hl, int line, int pos, int shift)
{// addr = 0x080AE37B  --  defined in 'anchor.c' at line 523
    Anchor* a;          // _cfa_fffffff4
    size_t b;           // _cfa_fffffff0
    size_t e;           // _cfa_ffffffec
    size_t s;           // _cfa_ffffffe8
    int cmp;                               // _cfa_ffffffe4
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ __ebx;                       // r1

    s = 0;
    if(al == 0) {
        return;
    }
    if(al->nanchor == 0) {
        return;
    }
    s = (al->nanchor >> 31) + al->nanchor >> 1;
    b = 0;
    e = al->nanchor - 1;
    while(b <= e) {
        a = al->anchors + (s << 2 << 4) - (s << 2);
        cmp = onAnchor(a, line, pos);
        if(cmp != 0) {
            if(cmp <= 0) {
                if(s != 0) {
                    e = s - 1;
                    goto L10;
                } else {
                    goto L13;
                }
            } else {
                b = s + 1;
L10:
                s = b + e + 1 >> 1;
                continue;
            }
        } else {
L13:
L21:
            while(al->nanchor > s) {
                a = al->anchors + (s << 2 << 4) - (s << 2);
                if(a->start <= line) {
                    if(a->start.pos > pos) {
                        a->start.pos = a->start.pos + shift;
                        if( *((intOrPtr*)(hl->marks + (a->hseq + a->hseq + a->hseq << 2))) == line) {
                             *(hl->marks + (a->hseq + a->hseq + a->hseq << 2) + 4) = a->start.pos;
                        }
                    }
                    if(a->end.pos >= pos) {
                        a->end.pos = a->end.pos + shift;
                    }
                    s = s + 1;
                    continue;
                }
                return;
            }
            return;
        }
        goto L21;
    }
    goto L21;
}

void addMultirowsImg(Buffer* buf, AnchorList* al)
{// addr = 0x080AE515  --  defined in 'anchor.c' at line 562
    int i;                                 // _cfa_ffffffe0
    int j;                                 // _cfa_ffffffdc
    int k;                                 // _cfa_ffffffd8
    int col;                               // _cfa_ffffffd4
    int ecol;                              // _cfa_ffffffd0
    int pos;                               // _cfa_ffffffcc
    Image* img;          // _cfa_ffffffc8
    Anchor* a;          // _cfa_ffffffc4
    Line* l;              // _cfa_ffffffc0
    Line* ls;             // _cfa_ffffffbc
    Image* _v72;         // _cfa_ffffffb8
    char* _v76;                            // _cfa_ffffffb4
    signed int _v78;                       // _cfa_ffffffb2
    char* _v80;                            // _cfa_ffffffb0
    signed int _v84;                       // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    int _v92;                              // _cfa_ffffffa4
    char* _v96;                            // _cfa_ffffffa0
    char* _v100;                           // _cfa_ffffff9c
    int _v104;                             // _cfa_ffffff98
    int _v108;                             // _cfa_ffffff94
    char* _v112;                           // _cfa_ffffff90
    char* _v116;                           // _cfa_ffffff8c
    char* _v120;                           // _cfa_ffffff88
    char* _v124;                           // _cfa_ffffff84
    Anchor a_img;       // _cfa_ffffff80
    Image* _v132;        // _cfa_ffffff7c
    short int _v136;                       // _cfa_ffffff78
    char _v140;                            // _cfa_ffffff74
    char _v144;                            // _cfa_ffffff70
    int _v148;                             // _cfa_ffffff6c
    int _v152;                             // _cfa_ffffff68
    intOrPtr _v156;                        // _cfa_ffffff64
    int _v160;                             // _cfa_ffffff60
    int _v164;                             // _cfa_ffffff5c
    intOrPtr _v168;                        // _cfa_ffffff58
    signed char _v172;                     // _cfa_ffffff54
    char* _v176;                           // _cfa_ffffff50
    char* _v180;                           // _cfa_ffffff4c
    char* _v184;                           // _cfa_ffffff48
    Anchor a_href;      // _cfa_ffffff44
    Image* _v192;        // _cfa_ffffff40
    short int _v196;                       // _cfa_ffffff3c
    char _v200;                            // _cfa_ffffff38
    char _v204;                            // _cfa_ffffff34
    int _v208;                             // _cfa_ffffff30
    int _v212;                             // _cfa_ffffff2c
    intOrPtr _v216;                        // _cfa_ffffff28
    int _v220;                             // _cfa_ffffff24
    int _v224;                             // _cfa_ffffff20
    intOrPtr _v228;                        // _cfa_ffffff1c
    unsigned char _v232;                   // _cfa_ffffff18
    char* _v236;                           // _cfa_ffffff14
    char* _v240;                           // _cfa_ffffff10
    char* _v244;                           // _cfa_ffffff0c
    Anchor a_form;      // _cfa_ffffff08
    int _v256;                             // _cfa_ffffff00
    char* _v272;                           // _cfa_fffffef0
    _unknown_ _v300;                       // _cfa_fffffed4 (outparam)
    _unknown_ _v304;                       // _cfa_fffffed0 (outparam)
    _unknown_ _v308;                       // _cfa_fffffecc (outparam)
    _unknown_ _v312;                       // _cfa_fffffec8 (outparam)
    _unknown_ _v316;                       // _cfa_fffffec4 (outparam)
    _unknown_ _v320;                       // _cfa_fffffec0 (outparam)
    _unknown_ _v324;                       // _cfa_fffffebc (outparam)
    _unknown_ _v328;                       // _cfa_fffffeb8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    char** _t321;                          // _t321
    Line* _t343;          // _t343
    Anchor* _t419;      // _t419
    Anchor* _t421;      // _t421

    if(al == 0) {
        return;
    }
    if(al->nanchor == 0) {
        return;
    }
    i = 0;
    while(al->nanchor > i) {
        _t321 = al->anchors + (i << 2 << 4) - (i << 2);
        a_img.url =  *_t321;
        _v124 = _t321[1];
        _v120 = _t321[2];
        _v116 = _t321[3];
        _v112 = _t321[4];
        _v108 = _t321[5];
        _v104 = _t321[6];
        _v100 = _t321[7];
        _v96 = _t321[8];
        _v92 = _t321[9];
        _v88 = _t321[0xa];
        _v84 = _t321[0xb];
        _v80 = _t321[0xc];
        _v76 = _t321[0xd];
        _v72 = _t321[0xe];
        img = _v72;
        if(_v84 < 0) {
L52:
            i = i + 1;
            continue;
        }
        if(img == 0) {
            goto L52;
        }
        if((img->rows & 65535) <= 1) {
            goto L52;
        }
        l = buf->firstLine;
        while(l != 0) {
            if(l->linenumber == (img->y & 65535)) {
L12:
                if(l == 0) {
                    goto L52;
                }
                if((_v78 & 65535) != _v108) {
                    ls = l;
                    while(ls != 0) {
                        if(ls->linenumber == _v108) {
L24:
                            if(ls == 0) {
                                goto L52;
                            }
L25:
                            a = retrieveAnchor(buf->href, _v108, _v104);
                            if(a == 0) {
                                a_href.url = 0;
                            } else {
                                _t421 = a;
                                a_href.url =  *_t421;
                                _v184 = _t421->target;
                                _v180 = _t421->referer;
                                _v176 = _t421->title;
                                _v172 = _t421->accesskey;
                                _v168 = _t421->start;
                                _v164 = _t421->start.pos;
                                _v160 = _t421->start.invalid;
                                _v156 = _t421->end;
                                _v152 = _t421->end.pos;
                                _v148 = _t421->end.invalid;
                                _v144 = _t421->hseq;
                                _v140 = _t421->slave;
                                _v136 = _t421->rows;
                                _v132 = _t421->image;
                            }
                            a = retrieveAnchor(buf->formitem, _v108, _v104);
                            if(a == 0) {
                                a_form.url = 0;
                            } else {
                                _t419 = a;
                                a_form.url =  *_t419;
                                _v244 = _t419->target;
                                _v240 = _t419->referer;
                                _v236 = _t419->title;
                                _v232 = _t419->accesskey;
                                _v228 = _t419->start;
                                _v224 = _t419->start.pos;
                                _v220 = _t419->start.invalid;
                                _v216 = _t419->end;
                                _v212 = _t419->end.pos;
                                _v208 = _t419->end.invalid;
                                _v204 = _t419->hseq;
                                _v200 = _t419->slave;
                                _v196 = _t419->rows;
                                _v192 = _t419->image;
                            }
                            col = calcPosition(ls->lineBuf, ls->propBuf, ls->len, _v104, 0, 0);
                            ecol = calcPosition(ls->lineBuf, ls->propBuf, ls->len, _v92, 0, 0);
                            j = 0;
                            while(l != 0 && (img->rows & 65535) > j) {
                                if(_v108 == l->linenumber) {
L43:
                                    l = l->next;
                                    j = j + 1;
                                    continue;
                                }
                                pos = columnPos(l, col);
                                a = registerImg(buf, a_img.url, _v116, l->linenumber, pos);
                                a->hseq =  ~_v84;
                                a->slave = 1;
                                a->image = img;
                                a->end.pos = pos + ecol - col;
                                k = pos;
                                while(a->end.pos > k) {
                                     *(l->propBuf + k + k) =  *(l->propBuf + k + k) & 65535 | 32;
                                    k = k + 1;
                                }
                                if(a_href.url == 0) {
L40:
                                    if(a_form.url != 0) {
                                        buf->formitem = putAnchor(buf->formitem, a_form.url, _v244,  &a, 0, 0, 0, l->linenumber, pos);
                                        a->hseq = _v204;
                                        a->end.pos = pos + ecol - col;
                                    }
                                    goto L43;
                                }
                                _v272 = a_href.url;
                                _v256 = pos;
                                a = registerHref(buf, _v272, _v184, _v180, _v176, _v172 & 0xff, l->linenumber, _v256);
                                a->hseq = _v144;
                                a->slave = 1;
                                a->end.pos = pos + ecol - col;
                                k = pos;
                                while(a->end.pos > k) {
                                     *(l->propBuf + k + k) =  *(l->propBuf + k + k) & 65535 | 16;
                                    k = k + 1;
                                }
                                goto L40;
                            }
                            img->rows = 0;
                            goto L52;
                        }
                        if((_v78 & 65535) >= _v108) {
                            _t343 = ls->prev;
                        } else {
                            _t343 = ls->next;
                        }
                        ls = _t343;
                    }
                    goto L24;
                }
                ls = l;
                goto L25;
            }
            l = l->next;
        }
        goto L12;
    }
}

void addMultirowsForm(Buffer* buf, AnchorList* al)
{// addr = 0x080AEAEF  --  defined in 'anchor.c' at line 640
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int k;                                 // _cfa_ffffffe8
    int col;                               // _cfa_ffffffe4
    int ecol;                              // _cfa_ffffffe0
    int pos;                               // _cfa_ffffffdc
    Anchor* a;          // _cfa_ffffffd8
    FormItemList* fi;   // _cfa_ffffffd4
    Line* l;              // _cfa_ffffffd0
    Line* ls;             // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    signed int _v62;                       // _cfa_ffffffc2
    char* _v64;                            // _cfa_ffffffc0
    short int _v68;                        // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    int _v76;                              // _cfa_ffffffb4
    char* _v80;                            // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    int _v88;                              // _cfa_ffffffa8
    char* _v92;                            // _cfa_ffffffa4
    char* _v96;                            // _cfa_ffffffa0
    char* _v100;                           // _cfa_ffffff9c
    char* _v104;                           // _cfa_ffffff98
    char* _v108;                           // _cfa_ffffff94
    Anchor a_form;      // _cfa_ffffff90
    _unknown_ _v140;                       // _cfa_ffffff74 (outparam)
    _unknown_ _v144;                       // _cfa_ffffff70 (outparam)
    _unknown_ _v148;                       // _cfa_ffffff6c (outparam)
    _unknown_ _v152;                       // _cfa_ffffff68 (outparam)
    _unknown_ _v156;                       // _cfa_ffffff64 (outparam)
    _unknown_ _v160;                       // _cfa_ffffff60 (outparam)
    _unknown_ _v164;                       // _cfa_ffffff5c (outparam)
    _unknown_ _v168;                       // _cfa_ffffff58 (outparam)
    _unknown_ __ebx;                       // r1
    char** _t190;                          // _t190
    Line* _t214;          // _t214

    if(al == 0) {
        return;
    }
    if(al->nanchor != 0) {
        i = 0;
        while(al->nanchor > i) {
            _t190 = al->anchors + (i << 2 << 4) - (i << 2);
            a_form.url =  *_t190;
            _v108 = _t190[1];
            _v104 = _t190[2];
            _v100 = _t190[3];
            _v96 = _t190[4];
            _v92 = _t190[5];
            _v88 = _t190[6];
            _v84 = _t190[7];
            _v80 = _t190[8];
            _v76 = _t190[9];
            _v72 = _t190[0xa];
            _v68 = _t190[0xb];
            _v64 = _t190[0xc];
            _v60 = _t190[0xd];
            _v56 = _t190[0xe];
            (al->anchors + (i << 2 << 4) - (i << 2))[0xd] = 1;
            if(_v68 < 0) {
L41:
                i = i + 1;
                continue;
            }
            if((_v60 & 65535) <= 1) {
                goto L41;
            }
            l = buf->firstLine;
            while(l != 0) {
                if(l->linenumber == (_v62 & 65535)) {
L11:
                    if(l == 0) {
                        goto L41;
                    }
                    if((_v62 & 65535) != _v92) {
                        ls = l;
                        while(ls != 0) {
                            if(ls->linenumber == _v92) {
L23:
                                if(ls == 0) {
                                    goto L41;
                                }
L24:
                                fi = a_form.url;
                                col = calcPosition(ls->lineBuf, ls->propBuf, ls->len, _v88, 0, 0);
                                ecol = calcPosition(ls->lineBuf, ls->propBuf, ls->len, _v76, 0, 0);
                                j = 0;
                                while(l != 0) {
                                    if((_v60 & 65535) > j) {
                                        pos = columnPos(l, col);
                                        if(j == 0) {
                                             *(buf->hmarklist->marks + (_v68 + _v68 + _v68 << 2)) = l->linenumber;
                                            (buf->hmarklist->marks + (_v68 + _v68 + _v68 << 2))[1] = pos;
                                        }
                                        if(_v92 == l->linenumber) {
                                            goto L33;
                                        } else {
                                            buf->formitem = putAnchor(buf->formitem, a_form.url, _v108,  &a, 0, 0, 0, l->linenumber, pos);
                                            a->hseq = _v68;
                                            a->y = _v62 & 65535;
                                            a->end.pos = pos + ecol - col;
                                             *((char*)(l->lineBuf + pos - 1)) = 91;
                                             *((char*)(l->lineBuf + a->end.pos)) = 93;
                                            k = pos;
                                            while(a->end.pos > k) {
                                                 *(l->propBuf + k + k) =  *(l->propBuf + k + k) & 65535 | 64;
                                                k = k + 1;
                                            }
L33:
                                            l = l->next;
                                            j = j + 1;
                                            continue;
                                        }
                                    }
                                    goto L41;
                                }
                                goto L41;
                            }
                            if((_v62 & 65535) >= _v92) {
                                _t214 = ls->prev;
                            } else {
                                _t214 = ls->next;
                            }
                            ls = _t214;
                        }
                        goto L23;
                    }
                    ls = l;
                    goto L24;
                }
                l = l->next;
            }
            goto L11;
        }
        return;
    }
}

char* getAnchorText(Buffer* buf, AnchorList* al, Anchor* a)
{// addr = 0x080AEE76  --  defined in 'anchor.c' at line 697
    int hseq;                              // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    Line* l;              // _cfa_ffffffe8
    Str tmp;               // _cfa_ffffffe4
    char* p;                               // _cfa_ffffffe0
    char* ep;                              // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t117;                             // _t117

    tmp = 0;
    if(a == 0 || a->hseq.line < 0) {
        return 0;
    }
    hseq = a->hseq.line;
    l = buf->firstLine;
    i = 0;
L25:
    while(al->nanchor > i) {
        a = al->anchors + (i << 2 << 4) - (i << 2);
        if(a->hseq.line == hseq) {
            while(l != 0) {
                if(l->linenumber == a->start.line) {
L11:
                    if(l == 0) {
L28:
                        if(tmp == 0) {
                            return 0;
                        }
                        return tmp->ptr;
                    }
                    p = l->lineBuf + a->start.pos;
                    ep = l->lineBuf + a->end.pos;
                    while(p < ep && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                        p =  &(p[1]);
                    }
                    if(p == ep) {
L24:
                        i = i + 1;
                        goto L25;
                    }
                    if(tmp != 0) {
                        if(tmp->length + 1 >= tmp->area_size) {
                            Strgrow(tmp);
                        }
                        _t117 = tmp->length;
                         *((char*)(tmp->ptr + _t117)) = 32;
                        tmp->length = _t117 + 1;
                         *((char*)(tmp->ptr + tmp->length)) = 0;
L22:
                        Strcat_charp_n(tmp, p, ep - p);
                        goto L24;
                    }
                    tmp = Strnew_size(ep - p);
                    goto L22;
                }
                l = l->next;
            }
            goto L11;
        }
        goto L24;
    }
    goto L28;
}

Buffer* link_list_panel(Buffer* buf)
{// addr = 0x080AF027  --  defined in 'anchor.c' at line 733
    LinkList* l;      // _cfa_fffffff0
    AnchorList* al;   // _cfa_ffffffec
    Anchor* a;          // _cfa_ffffffe8
    FormItemList* fi;   // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    char* t;                               // _cfa_ffffffdc
    char* u;                               // _cfa_ffffffd8
    char* p;                               // _cfa_ffffffd4
    Str tmp;               // _cfa_ffffffd0
    MapList* ml;       // _cfa_ffffffcc
    ListItem* mi;     // _cfa_ffffffc8
    MapArea* m;        // _cfa_ffffffc4
    ParsedURL pu;    // _cfa_ffffff9c
    int _v124;                             // _cfa_ffffff84
    intOrPtr _v128;                        // _cfa_ffffff80
    char* _v132;                           // _cfa_ffffff7c
    char* _v136;                           // _cfa_ffffff78
    char* _v140;                           // _cfa_ffffff74
    char* _v144;                           // _cfa_ffffff70
    char* _v148;                           // _cfa_ffffff6c (outparam)
    char* _v152;                           // _cfa_ffffff68 (outparam)
    _unknown_ __ebx;                       // r1
    intOrPtr _t346;                        // _t346
    char* _t444;                           // _t444
    char* _t468;                           // _t468

    tmp = Strnew_charp("<title>Link List</title><h1 align=center>Link List</h1>\n");
    if((buf->bufferprop & 8) != 0 || buf->linklist == 0 && buf->href == 0 && buf->img == 0) {
        return 0;
    }
    if(buf->linklist == 0) {
L23:
        if(buf->href == 0) {
L39:
            if(buf->img == 0) {
L78:
                return loadHTMLString(tmp);
            }
            Strcat_charp(tmp, "<hr><h2>Images</h2>\n<ol>\n");
            al = buf->img;
            i = 0;
            while(al->nanchor > i) {
                a = al->anchors + (i << 2 << 4) - (i << 2);
                if((a->slave & 255) != 0) {
L75:
                    i = i + 1;
                    continue;
                }
                parseURL2(a->url,  &pu, baseURL(buf));
                p =  *(parsedURL2Str( &pu));
                u = html_quote(p);
                if(DecodeURL == 0) {
                    p = u;
                } else {
                    p = html_quote(url_unquote_conv(p, buf->document_charset));
                }
                if(a->title == 0 || ( *(a->title) & 255) == 0) {
                    if(DecodeURL == 0) {
                        t = html_quote(a->url);
                    } else {
                        t = html_quote(url_unquote_conv(a->url, buf->document_charset));
                    }
                } else {
                    t = html_quote(a->title);
                }
                _v124 = 0;
                _v128 = 135071971;
                _v132 = p;
                _v136 = "</a><br>";
                _v140 = t;
                _v144 = "">";
                _v148 = u;
                _v152 = "<li><a href="";
                Strcat_m_charp(tmp);
                a = retrieveAnchor(buf->formitem, a->start, a->start.pos);
                if(a == 0) {
                } else {
                    fi = a->url;
                    fi = fi->parent->item;
                    if(fi->parent->method != 2) {
                        goto L75;
                    }
                    _t346 =  *(fi->parent->action);
                    _v152 = "map";
                     *__esp = _t346;
                    strcmp();
                    if(_t346 == 0 && fi->value != 0) {
                        ml = searchMapList(buf,  *(fi->value));
                        if(ml == 0) {
                            goto L75;
                        }
                        Strcat_charp(tmp, "<br>\n<b>Image map</b>\n<ol>\n");
                        mi = ml->area->first;
                        while(mi != 0) {
                            m = mi->ptr;
                            if(m != 0) {
                                parseURL2(m->url,  &pu, baseURL(buf));
                                p =  *(parsedURL2Str( &pu));
                                u = html_quote(p);
                                if(DecodeURL == 0) {
                                    p = u;
                                } else {
                                    p = html_quote(url_unquote_conv(p, buf->document_charset));
                                }
                                if(m->alt == 0 || (m & 255) == 0) {
                                    if(DecodeURL == 0) {
                                        t = html_quote(m->url);
                                    } else {
                                        t = html_quote(url_unquote_conv(m->url, buf->document_charset));
                                    }
                                } else {
                                    t = html_quote(m->alt);
                                }
                                _v124 = 0;
                                _v128 = 135071971;
                                _v132 = p;
                                _v136 = "</a><br>";
                                _v140 = t;
                                _v144 = "">";
                                _v148 = u;
                                _v152 = "<li><a href="";
                                Strcat_m_charp(tmp);
                            }
                            mi = mi->next;
                        }
                        Strcat_charp(tmp, "</ol>\n");
                    }
                }
                goto L75;
            }
            Strcat_charp(tmp, "</ol>\n");
            goto L78;
        }
        Strcat_charp(tmp, "<hr><h2>Anchors</h2>\n<ol>\n");
        al = buf->href;
        i = 0;
        while(al->nanchor > i) {
            a = al->anchors + (i << 2 << 4) - (i << 2);
            if(a->hseq >= 0) {
                if((a->slave & 255) == 0) {
                    parseURL2(a->url,  &pu, baseURL(buf));
                    p =  *(parsedURL2Str( &pu));
                    u = html_quote(p);
                    if(DecodeURL == 0) {
                        p = u;
                    } else {
                        p = html_quote(url_unquote_conv(p, buf->document_charset));
                    }
                    t = getAnchorText(buf, al, a);
                    if(t == 0) {
                        _t444 = 135071950;
                    } else {
                        _t444 = html_quote(t);
                    }
                    t = _t444;
                    _v124 = 0;
                    _v128 = 135071971;
                    _v132 = p;
                    _v136 = "</a><br>";
                    _v140 = t;
                    _v144 = "">";
                    _v148 = u;
                    _v152 = "<li><a href="";
                    Strcat_m_charp(tmp);
                }
            }
            i = i + 1;
        }
        Strcat_charp(tmp, "</ol>\n");
        goto L39;
    } else {
        Strcat_charp(tmp, "<hr><h2>Links</h2>\n<ol>\n");
        l = buf->linklist;
        while(l != 0) {
            if(l->url == 0) {
                p = 135071950;
                u = p;
            } else {
                parseURL2(l->url,  &pu, baseURL(buf));
                p =  *(parsedURL2Str( &pu));
                u = html_quote(p);
                if(DecodeURL == 0) {
                    p = u;
                } else {
                    p = html_quote(url_unquote_conv(p, buf->document_charset));
                }
            }
            if((l->type & 255) != 1) {
                if((l->type & 255) != 2) {
                    t = 135071950;
                } else {
                    t = " [Rev]";
                }
            } else {
                t = " [Rel]";
            }
            if(l->title == 0) {
                _t468 = 135071950;
            } else {
                _t468 = l->title;
            }
            _v148 = t;
            _v152 = _t468;
            t =  *(Sprintf("%s%s\n"));
            t = html_quote(t);
            _v124 = 0;
            _v128 = 135071971;
            _v132 = p;
            _v136 = "</a><br>";
            _v140 = t;
            _v144 = "">";
            _v148 = u;
            _v152 = "<li><a href="";
            Strcat_m_charp(tmp);
            l = l->next;
        }
        Strcat_charp(tmp, "</ol>\n");
        goto L23;
    }
}

int noConv(char* oval, char** str)
{// addr = 0x080AF79C  --  defined in 'parsetagx.c' at line 36
     *str = oval;
    return 1;
}

int toNumber(char* oval, int* num)
{// addr = 0x080AF7AE  --  defined in 'parsetagx.c' at line 43
    char* ep;                              // _cfa_fffffff0
    int x;                                 // _cfa_ffffffec
    intOrPtr _v36;                         // _cfa_ffffffdc
    char** _v40;                           // _cfa_ffffffd8
    int _t10;                              // _t10

    _t10 = oval;
    _v36 = 10;
    _v40 =  &ep;
     *__esp = _t10;
    strtol();
    x = _t10;
    if(ep <= oval) {
        return 0;
    }
     *num = x;
    return 1;
}

int toLength(char* oval, int* len)
{// addr = 0x080AF7EF  --  defined in 'parsetagx.c' at line 59
    int w;                                 // _cfa_fffffff0
    int _t20;                              // _t20
    char* _t21;                            // _t21

    if(( *( &MYCTYPE_MAP + ( *oval & 0xff)) & 8) != 0) {
        _t20 = oval;
         *__esp = _t20;
        atoi();
        w = _t20;
        if(w >= 0) {
            if(w == 0) {
                w = 1;
            }
            _t21 = oval;
             *__esp = _t21;
            strlen();
            if((oval[_t21 - 1] & 255) != 37) {
                 *len = w;
            } else {
                 *len =  ~w;
            }
            return 1;
        }
        return 0;
    }
    return 0;
}

int toAlign(char* oval, int* align)
{// addr = 0x080AF873  --  defined in 'parsetagx.c' at line 77
    char* _v24;                            // _cfa_ffffffe8
    char* _t19;                            // _t19
    char* _t20;                            // _t20
    char* _t21;                            // _t21
    char* _t22;                            // _t22
    char* _t23;                            // _t23
    char* _t24;                            // _t24

    _v24 = "left";
    _t19 = oval;
     *__esp = _t19;
    strcasecmp();
    if(_t19 != 0) {
        _v24 = "right";
        _t20 = oval;
         *__esp = _t20;
        strcasecmp();
        if(_t20 != 0) {
            _v24 = "center";
            _t21 = oval;
             *__esp = _t21;
            strcasecmp();
            if(_t21 != 0) {
                _v24 = "top";
                _t22 = oval;
                 *__esp = _t22;
                strcasecmp();
                if(_t22 != 0) {
                    _v24 = "bottom";
                    _t23 = oval;
                     *__esp = _t23;
                    strcasecmp();
                    if(_t23 != 0) {
                        _v24 = "middle";
                        _t24 = oval;
                         *__esp = _t24;
                        strcasecmp();
                        if(_t24 != 0) {
                            return 0;
                        }
                         *align = 4;
L13:
                        return 1;
                    }
                     *align = 6;
                    goto L13;
                }
                 *align = 5;
                goto L13;
            }
             *align = 0;
            goto L13;
        }
         *align = 2;
        goto L13;
    }
     *align = 1;
    goto L13;
}

int toVAlign(char* oval, int* valign)
{// addr = 0x080AF959  --  defined in 'parsetagx.c' at line 97
    char* _v24;                            // _cfa_ffffffe8
    char* _t12;                            // _t12
    char* _t15;                            // _t15
    char* _t16;                            // _t16
    char* _t17;                            // _t17

    _v24 = "top";
    _t12 = oval;
     *__esp = _t12;
    strcasecmp();
    if(_t12 == 0) {
L2:
         *valign = 1;
L8:
        return 1;
    }
    _v24 = "baseline";
    _t15 = oval;
     *__esp = _t15;
    strcasecmp();
    if(_t15 != 0) {
        _v24 = "bottom";
        _t16 = oval;
         *__esp = _t16;
        strcasecmp();
        if(_t16 != 0) {
            _v24 = "middle";
            _t17 = oval;
             *__esp = _t17;
            strcasecmp();
            if(_t17 != 0) {
                return 0;
            }
             *valign = 0;
            goto L8;
        }
         *valign = 2;
        goto L8;
    }
    goto L2;
}

struct parsed_tag* parse_tag(char** s, int internal)
{// addr = 0x080AF9EA  --  defined in 'parsetagx.c' at line 114
    signed int _v16;                       // _cfa_fffffff0
    char[63] tagname;                      // _cfa_ffffffb0
    char[63] attrname;                     // _cfa_ffffff70
    struct parsed_tag* tag;   // _cfa_ffffff6c
    int tag_id;                            // _cfa_ffffff68
    char* p;                               // _cfa_ffffff64
    char* q;                               // _cfa_ffffff60
    int i;                                 // _cfa_ffffff5c
    int attr_id;                           // _cfa_ffffff58
    int nattr;                             // _cfa_ffffff54
    Str value;             // _cfa_ffffff50
    Str value_tmp;         // _cfa_ffffff4c
    int j;                                 // _cfa_ffffff48
    int hidden;                            // _cfa_ffffff44
    char* x;                               // _cfa_ffffff40
    char** _v208;                          // _cfa_ffffff30
    int _v228;                             // _cfa_ffffff1c (outparam)
    char[63]* _v232;                       // _cfa_ffffff18 (outparam)
    signed int _t363;                      // _t363
    struct parsed_tag* _t369;   // _t369
    struct parsed_tag* _t410;   // _t410
    char* _t440;                           // _t440
    char[63]* _t449;                       // _t449
    int _t463;                             // _t463
    int _t496;                             // _t496
    int _t524;                             // _t524
    int _t552;                             // _t552
    char _t609;                            // _t609
    char _t618;                            // _t618
    signed int _t621;                      // _t621
    char _t622;                            // _t622
    char _t674;                            // _t674

    _v208 = s;
    _v16 =  *gs:0x14];
    tag = 0;
    attr_id = 0;
    q =  &(( *_v208)[1]);
    p =  &tagname;
    if(( *q & 255) != 47) {
    } else {
         *p =  *q & 255;
        p =  &(p[1]);
        q =  &(q[1]);
        while(( *q & 255) != 0) {
            if(( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) != 0) {
                q =  &(q[1]);
                continue;
            } else {
L12:
                while(( *q & 255) != 0 && ( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) == 0 && ((tagname & 255) == 47 || ( *q & 255) != 47) && ( *q & 255) != 62) {
                    if(p -  &tagname <= 62) {
                        if(( *( &MYCTYPE_MAP + ( *q & 0xff)) & 4) == 0) {
                            _t674 =  *q & 255;
                        } else {
                            _t674 =  *q & 255 | 32;
                        }
                         *p = _t674;
                        p =  &(p[1]);
                        q =  &(q[1]);
                        continue;
                    }
                    break;
                }
                 *p = 0;
                while(( *q & 255) != 0 && ( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) == 0 && ((tagname & 255) == 47 || ( *q & 255) != 47)) {
                    if(( *q & 255) != 62) {
                        q =  &(q[1]);
                        continue;
                    }
                    break;
                }
                _t363 = getHash_si( &tagtable,  &tagname, 0);
                tag_id = _t363;
                if(tag_id == 0) {
L137:
                    while(( *q & 255) != 62 && ( *q & 255) != 0) {
                        q =  &(q[1]);
                    }
L139:
                    if(( *q & 255) == 62) {
                        q =  &(q[1]);
                    }
                     *_v208 = q;
                    _t369 = tag;
                    if((_v16 ^  *gs:0x14]) == 0) {
                        return _t369;
                    } else {
                        __stack_chk_fail();
                        return _t369;
                    }
                }
                if(internal != 0) {
L28:
                     *__esp = 20;
                    GC_malloc();
                    tag = _t363;
                    _v232 = 20;
                     *__esp = tag;
                    bzero();
                    tag->tagid = tag_id;
                    nattr =  *((tag_id + tag_id + _t706 << 2) + 135107784) & 0xff;
                    if(nattr <= 0) {
                        goto L34;
                    } else {
                        _t618 = nattr;
                         *__esp = _t618;
                        GC_malloc_atomic();
                        tag->attrid = _t618;
                        _t621 = nattr << 2;
                         *__esp = _t621;
                        GC_malloc();
                        _t622 = tag;
                         *(_t622 + 8) = _t621;
                         *__esp = 75;
                        GC_malloc_atomic();
                        tag->map = _t622;
                        _v228 = 75;
                        _v232 = 75;
                         *__esp = tag->map;
                        memset();
                        _v228 = nattr;
                        _v232 = 0;
                         *__esp = tag->attrid;
                        memset();
                        i = 0;
                        do {
                        } while(i < nattr);
L34:
                        while(( *q & 255) != 0) {
                            if(( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) != 0) {
                                q =  &(q[1]);
                                continue;
                            } else {
                                goto L36;
                            }
                            while(1) {
L36:
                                value = 0;
                                value_tmp = 0;
                                if(( *q & 255) == 62) {
                                    goto L139;
                                }
                                if(( *q & 255) == 0) {
                                    goto L139;
                                } else {
                                    p =  &attrname;
                                    goto L43;
                                    do {
                                    } while();
L50:
                                    while(( *q & 255) != 0 && ( *q & 255) != 61 && ( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) == 0) {
                                        if(( *q & 255) != 62) {
                                            q =  &(q[1]);
                                            continue;
                                        } else {
                                            do {
                                                goto L56;
                                            } while(( *q & 255) != 0 && ( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) != 0);
                                            if(( *q & 255) != 61) {
L98:
                                                i = 0;
                                                while(i < nattr) {
                                                    if(( *(tag->attrid + i) & 255) != 0) {
L102:
                                                        i = i + 1;
                                                        continue;
                                                    }
                                                    _t410 =  *( &AttrMAP + ( *( *((intOrPtr*)((tag_id + tag_id + _t743 << 2) + 135107780)) + i) & 0xff) * 8);
                                                    _v232 =  &attrname;
                                                     *__esp = _t410;
                                                    strcmp();
                                                    if(_t410 != 0) {
                                                        goto L102;
                                                    }
                                                    attr_id =  *( *((intOrPtr*)((tag_id + tag_id + _t746 << 2) + 135107780)) + i) & 0xff;
                                                    break;
                                                }
                                                if(value_tmp == 0) {
L123:
                                                    if(i == nattr) {
                                                        tag->need_reconstruct = 1;
                                                        goto L36;
                                                    }
                                                    if(internal != 0) {
L130:
                                                         *(tag->attrid + i) = attr_id;
                                                        if(value == 0) {
                                                             *(tag->value + (i << 2)) = 0;
                                                        } else {
                                                             *(tag->value + (i << 2)) = html_unquote(value->ptr);
                                                        }
                                                        goto L36;
                                                    }
                                                    if(( *(135109541 + attr_id * 8) & 1) != 0) {
L129:
                                                        tag->need_reconstruct = 1;
                                                        goto L36;
                                                    }
                                                    if(value == 0 || ( *(135109540 + attr_id * 8) & 255) != 8) {
                                                        goto L130;
                                                    } else {
                                                        _t440 = value->ptr;
                                                        _v232 = "internal";
                                                         *__esp = _t440;
                                                        strcasecmp();
                                                        if(_t440 != 0) {
                                                            goto L130;
                                                        }
                                                        goto L129;
                                                    }
                                                }
                                                hidden = 0;
                                                j = 0;
                                                while(j < i) {
                                                    if(( *(tag->attrid + j) & 255) != 33) {
L109:
                                                        j = j + 1;
                                                        continue;
                                                    }
                                                    _t449 =  *(tag->value + (j << 2));
                                                    _v232 = _t449;
                                                     *__esp = "hidden";
                                                    strcmp();
                                                    if(_t449 != 0) {
                                                        goto L109;
                                                    }
                                                    hidden = 1;
                                                    break;
                                                }
                                                if(tag_id == 44 || tag_id == 134) {
                                                    if(attr_id != 36 || hidden == 0) {
                                                        goto L116;
                                                    } else {
                                                        value = value_tmp;
                                                        goto L123;
                                                    }
                                                } else {
L116:
                                                    value = Strnew();
                                                    x = value_tmp->ptr;
                                                    while(( *x & 255) != 0) {
                                                        if(( *x & 255) != 10) {
                                                            if(value->length + 1 >= value->area_size) {
                                                                Strgrow(value);
                                                            }
                                                            _t463 = value->length;
                                                             *((char*)(value->ptr + _t463)) =  *x & 255;
                                                            value->length = _t463 + 1;
                                                             *((char*)(value->ptr + value->length)) = 0;
                                                        }
                                                        x =  &(x[1]);
                                                    }
                                                    goto L123;
                                                }
                                            } else {
                                                value_tmp = Strnew();
                                                q =  &(q[1]);
                                                do {
                                                } while(( *q & 255) != 0 && ( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) != 0);
                                                if(( *q & 255) != 34) {
                                                    if(( *q & 255) != 39) {
                                                        if(( *q & 255) == 0) {
                                                            goto L98;
                                                        }
                                                        while(( *q & 255) != 0 && ( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) == 0 && ( *q & 255) != 62) {
                                                            if(value_tmp->length + 1 >= value_tmp->area_size) {
                                                                Strgrow(value_tmp);
                                                            }
                                                            _t496 = value_tmp->length;
                                                             *((char*)(value_tmp->ptr + _t496)) =  *q & 255;
                                                            value_tmp->length = _t496 + 1;
                                                             *((char*)(value_tmp->ptr + value_tmp->length)) = 0;
                                                            if((tag->need_reconstruct & 255) == 0 && ( *( &QUOTE_MAP + ( *q & 0xff)) & 7) != 0) {
                                                                tag->need_reconstruct = 1;
                                                            }
                                                            q =  &(q[1]);
                                                        }
                                                        goto L98;
                                                    }
                                                    q =  &(q[1]);
                                                    while(( *q & 255) != 0 && ( *q & 255) != 39) {
                                                        if(value_tmp->length + 1 >= value_tmp->area_size) {
                                                            Strgrow(value_tmp);
                                                        }
                                                        _t524 = value_tmp->length;
                                                         *((char*)(value_tmp->ptr + _t524)) =  *q & 255;
                                                        value_tmp->length = _t524 + 1;
                                                         *((char*)(value_tmp->ptr + value_tmp->length)) = 0;
                                                        if((tag->need_reconstruct & 255) == 0 && ( *( &QUOTE_MAP + ( *q & 0xff)) & 7) != 0) {
                                                            tag->need_reconstruct = 1;
                                                        }
                                                        q =  &(q[1]);
                                                    }
                                                    if(( *q & 255) == 39) {
                                                        q =  &(q[1]);
                                                    }
                                                } else {
                                                    q =  &(q[1]);
                                                    while(( *q & 255) != 0 && ( *q & 255) != 34) {
                                                        _t552 = value_tmp->length;
                                                         *((char*)(value_tmp->ptr + _t552)) =  *q & 255;
                                                        value_tmp->length = _t552 + 1;
                                                         *((char*)(value_tmp->ptr + value_tmp->length)) = 0;
                                                        if((tag->need_reconstruct & 255) == 0 && ( *( &QUOTE_MAP + ( *q & 0xff)) & 7) != 0) {
                                                            tag->need_reconstruct = 1;
                                                        }
                                                        q =  &(q[1]);
                                                    }
                                                    if(( *q & 255) == 34) {
                                                        q =  &(q[1]);
                                                    }
                                                }
                                                goto L98;
                                            }
                                        }
                                    }
L56:
L43:
                                    if(( *q & 255) == 0 || ( *q & 255) == 61 || ( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) != 0 || ( *q & 255) == 62 || p -  &attrname > 62) {
                                         *p = 0;
                                    } else {
                                        if(( *( &MYCTYPE_MAP + ( *q & 0xff)) & 4) == 0) {
                                            _t609 =  *q & 255;
                                        } else {
                                            _t609 =  *q & 255 | 32;
                                        }
                                         *p = _t609;
                                        p =  &(p[1]);
                                        q =  &(q[1]);
                                        goto L43;
                                    }
                                    goto L50;
                                }
                            }
                            goto L139;
                        }
                        goto L36;
                    }
                }
                _t363 =  *((tag_id + tag_id + _t755 << 2) + 135107785) & 2;
                if(_t363 != 0) {
                    goto L137;
                }
                goto L28;
            }
        }
    }
}

int parsedtag_set_value(struct parsed_tag* tag, int id, char* value)
{// addr = 0x080B05B7  --  defined in 'parsetagx.c' at line 272
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(tag->map == 0 || ( *(tag->map + id) & 255) == 75) {
        return 0;
    } else {
        i =  *(tag->map + id) & 0xff;
         *((char*)(tag->attrid + i)) = id;
        if(value == 0) {
             *(tag->value + (i << 2)) = 0;
        } else {
             *(tag->value + (i << 2)) = allocStr(value, -1);
        }
        tag->need_reconstruct = 1;
        return 1;
    }
}

int parsedtag_get_value(struct parsed_tag* tag, int id, _Unknown_base* value)
{// addr = 0x080B0659  --  defined in 'parsetagx.c' at line 290
    int i;                                 // _cfa_fffffff0
    _Unknown_base* _v40;                   // _cfa_ffffffd8
    int _t64;                              // _t64

    if(tag->map != 0 && (tag->map[id] & 255) != 75 && (tag->attrid[tag->map[id] & 0xff] & 255) != 0) {
        i = tag->map[id] & 0xff;
        if(tag->value[i] != 0) {
            _t64 = tag->value[i];
            _v40 = value;
             *__esp = _t64;
             *((intOrPtr*)( *((intOrPtr*)( &toValFunc + ( *(135109540 + id * 8) & 0xff) * 4))))();
            return _t64;
        } else {
            goto L4;
        }
    }
L4:
    return 0;
}

Str parsedtag2str(struct parsed_tag* tag)
{// addr = 0x080B0702  --  defined in 'parsetagx.c' at line 299
    int i;                                 // _cfa_fffffff0
    int tag_id;                            // _cfa_ffffffec
    int nattr;                             // _cfa_ffffffe8
    Str tagstr;            // _cfa_ffffffe4
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    int _t105;                             // _t105
    int _t128;                             // _t128
    int _t159;                             // _t159

    tag_id = tag->tagid & 0xff;
    nattr =  *((tag_id + tag_id + _t171 << 2) + 135107784) & 0xff;
    tagstr = Strnew();
    if(tagstr->length + 1 >= tagstr->area_size) {
        Strgrow(tagstr);
    }
    _t105 = tagstr->length;
     *((char*)(tagstr->ptr + _t105)) = 60;
    tagstr->length = _t105 + 1;
     *((char*)(tagstr->ptr + tagstr->length)) = 0;
    Strcat_charp(tagstr,  *( &TagMAP + (tag_id + tag_id + _t177 << 2)));
    i = 0;
    while(i < nattr) {
        if((tag->attrid[i] & 255) != 0) {
            if(tagstr->length + 1 >= tagstr->area_size) {
                Strgrow(tagstr);
            }
            _t128 = tagstr->length;
             *((char*)(tagstr->ptr + _t128)) = 32;
            tagstr->length = _t128 + 1;
             *((char*)(tagstr->ptr + tagstr->length)) = 0;
            Strcat_charp(tagstr,  *( &AttrMAP + (tag->attrid[i] & 0xff) * 8));
            if(tag->value[i] != 0) {
                _v40 = html_quote(tag->value[i]);
                Strcat(tagstr, Sprintf("="%s""));
            }
        }
        i = i + 1;
    }
    if(tagstr->length + 1 >= tagstr->area_size) {
        Strgrow(tagstr);
    }
    _t159 = tagstr->length;
     *((char*)(tagstr->ptr + _t159)) = 62;
    tagstr->length = _t159 + 1;
     *((char*)(tagstr->ptr + tagstr->length)) = 0;
    return tagstr;
}

void do_update(BaseStream base)
{// addr = 0x080B08E4  --  defined in 'istream.c' at line 39
    int len;                               // _cfa_fffffff0
    int _v36;                              // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    int _t32;                              // _t32
    int _t40;                              // _t40

    base->stream.next = 0;
    base->stream.cur = base->stream.next;
    _t32 = base->handle;
    _v36 = base->stream.size;
    _v40 = base->stream;
     *__esp = _t32;
     *(base->read)();
    len = _t32;
    __eflags = len;
    if(__eflags > 0) {
        _t40 = base->stream.next + len;
        __eflags = _t40;
        base->stream.next = _t40;
        return;
    }
    base->iseos = 1;
}

int buffer_read(StreamBuffer sb, char* obuf, int count)
{// addr = 0x080B094E  --  defined in 'istream.c' at line 51
    int len;                               // _cfa_fffffff0
    int _v36;                              // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8

    len = sb->next - sb->cur;
    if(len > 0) {
        if(len > count) {
            len = count;
        }
        _v36 = len;
        _v40 = obuf;
         *__esp = sb->buf + sb->cur;
        bcopy();
        sb->cur = sb->cur + len;
    }
    return len;
}

void init_buffer(BaseStream base, char* buf, int bufsize)
{// addr = 0x080B09B7  --  defined in 'istream.c' at line 64
    StreamBuffer sb;   // _cfa_fffffff0
    unsigned char* _t23;                   // _t23

    sb = base;
    sb->size = bufsize;
    sb->cur = 0;
    if(buf == 0) {
        _t23 = bufsize;
         *__esp = _t23;
        GC_malloc_atomic();
        sb->buf = _t23;
        sb->next = 0;
    } else {
        sb->buf = buf;
        sb->next = bufsize;
    }
    base->iseos = 0;
}

void init_base_stream(BaseStream base, int bufsize)
{// addr = 0x080B0A14  --  defined in 'istream.c' at line 81
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    init_buffer(base, 0, bufsize);
}

void init_str_stream(BaseStream base, Str s)
{// addr = 0x080B0A36  --  defined in 'istream.c' at line 87
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    init_buffer(base, s->ptr, s->length);
}

InputStream newInputStream(int des)
{// addr = 0x080B0A5C  --  defined in 'istream.c' at line 93
    InputStream stream;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    union input_stream* _t17;   // _t17
    int _t19;                              // _t19

    if(des >= 0) {
         *__esp = 32;
        GC_malloc();
        stream = _t17;
        init_base_stream(stream, 8192);
        _t19 = stream;
         *((char*)(_t19 + 20)) = 0;
         *__esp = 4;
        GC_malloc();
        stream->base.stream.size = _t19;
         *(stream->base.stream.size) = des;
        stream->base.stream.next = basic_read;
        stream->base.handle = basic_close;
        return stream;
    }
    return 0;
}

InputStream newFileStream(FILE* f, _None* closep)
{// addr = 0x080B0AD0  --  defined in 'istream.c' at line 109
    InputStream stream;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    union input_stream* _t25;   // _t25
    int _t27;                              // _t27

    if(f != 0) {
         *__esp = 32;
        GC_malloc();
        stream = _t25;
        init_base_stream(stream, 8192);
        _t27 = stream;
         *((char*)(_t27 + 20)) = 1;
         *__esp = 8;
        GC_malloc();
        stream->base.stream.size = _t27;
         *(stream->base.stream.size) = f;
        if(closep == 0) {
             *(stream->base.stream.size + 4) = fclose;
        } else {
             *(stream->base.stream.size + 4) = closep;
        }
        stream->base.stream.next = file_read;
        stream->base.handle = file_close;
        return stream;
    }
    return 0;
}

InputStream newStrStream(Str s)
{// addr = 0x080B0B6B  --  defined in 'istream.c' at line 129
    InputStream stream;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    union input_stream* _t16;   // _t16

    if(s != 0) {
         *__esp = 32;
        GC_malloc();
        stream = _t16;
        init_str_stream(stream, s);
        stream->base.stream.cur = 2;
        stream->base.stream.size = s;
        stream->base.stream.next = str_read;
        stream->base.handle = 0;
        return stream;
    }
    return 0;
}

InputStream newEncodedStream(InputStream is, char encoding)
{// addr = 0x080B0BC9  --  defined in 'istream.c' at line 163
    InputStream stream;   // _cfa_fffffff0
    signed char _v32;                      // _cfa_ffffffe0
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    union input_stream* _t33;   // _t33
    int _t36;                              // _t36

    _t33 = encoding;
    _v32 = _t33;
    if(is != 0) {
        if(_v32 == 2 || _v32 == 1 || _v32 == 3) {
             *__esp = 32;
            GC_malloc();
            stream = _t33;
            init_base_stream(stream, 8192);
            _t36 = stream;
             *((char*)(_t36 + 20)) = 4;
             *__esp = 16;
            GC_malloc();
            stream->base.stream.size = _t36;
             *(stream->base.stream.size) = is;
             *((intOrPtr*)(stream->base.stream.size + 8)) = 0;
             *((char*)(stream->base.stream.size + 12)) = _v32 & 255;
             *((intOrPtr*)(stream->base.stream.size + 4)) = 0;
            stream->base.stream.next = ens_read;
            stream->base.handle = ens_close;
            return stream;
        } else {
            goto L4;
        }
    }
L4:
    return is;
}

int ISclose(InputStream stream)
{// addr = 0x080B0C7F  --  defined in 'istream.c' at line 183
    _None* prevtrap;                       // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(stream == 0 || stream->base.handle == 0 || (stream->base.stream.cur & 0x10) != 0) {
        return -1;
    }
    prevtrap = mySignal(2, 1);
     *__esp = stream->base.stream.size;
     *(stream->base.handle)();
    __eax = mySignal(2, prevtrap);
    return 0;
}

int ISgetc(InputStream stream)
{// addr = 0x080B0CEF  --  defined in 'istream.c' at line 196
    BaseStream base;   // _cfa_fffffff0
    int _t39;                              // _t39

    if(stream != 0) {
        base = stream;
        if((base->iseos & 255) == 0 && base->stream.cur == base->stream.next) {
            do_update(base);
        }
        if((base->iseos & 255) != 0) {
            return 0;
        } else {
            _t39 = base->stream.cur;
            base->stream.cur = _t39 + 1;
            return  *(base->stream + _t39) & 0xff;
        }
    }
    return 0;
}

int ISundogetc(InputStream stream)
{// addr = 0x080B0D61  --  defined in 'istream.c' at line 208
    StreamBuffer sb;   // _cfa_fffffff8

    if(stream != 0) {
        sb = stream;
        if(sb->cur <= 0) {
            return -1;
        }
        sb->cur = sb->cur - 1;
        return 0;
    }
    return -1;
}

Str StrISgets(InputStream stream)
{// addr = 0x080B0DA1  --  defined in 'istream.c' at line 223
    BaseStream base;   // _cfa_fffffff0
    StreamBuffer sb;   // _cfa_ffffffec
    Str s;                 // _cfa_ffffffe8
    unsigned char* p;                      // _cfa_ffffffe4
    int len;                               // _cfa_ffffffe0
    unsigned char* _v52;                   // _cfa_ffffffcc (outparam)
    intOrPtr _v56;                         // _cfa_ffffffc8 (outparam)
    unsigned char* _t81;                   // _t81

    s = 0;
    if(stream != 0) {
        base = stream;
        sb = base;
        while((base->iseos & 255) == 0) {
            if(base->stream.cur != base->stream.next) {
                _t81 = sb->next - sb->cur;
                _v52 = _t81;
                _v56 = 10;
                 *__esp = sb->buf + sb->cur;
                memchr();
                p = _t81;
                if(p == 0) {
                    if(s == 0) {
                        s = Strnew_size(sb->next - sb->cur + 10);
                    }
                    Strcat_charp_n(s, sb->buf + sb->cur, sb->next - sb->cur);
                    sb->cur = sb->next;
                    continue;
                }
                len = p - sb->buf + sb->cur + 1;
                if(s == 0) {
                    s = Strnew_size(len);
                }
                Strcat_charp_n(s, sb->buf + sb->cur, len);
                sb->cur = sb->cur + len;
                return s;
            }
            do_update(base);
        }
        if(s != 0) {
            return s;
        }
        return Strnew();
    }
    return 0;
}

Str StrmyISgets(InputStream stream)
{// addr = 0x080B0F1F  --  defined in 'istream.c' at line 265
    BaseStream base;   // _cfa_fffffff0
    StreamBuffer sb;   // _cfa_ffffffec
    Str s;                 // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    int len;                               // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    int _t193;                             // _t193
    int _t229;                             // _t229

    s = 0;
    if(stream == 0) {
        return 0;
    }
    base = stream;
    sb = base;
    while((base->iseos & 255) == 0) {
        if(base->stream.cur != base->stream.next) {
            if(s == 0 || s->length <= 0 || ( *(s->ptr + s->length - 1) & 255) != 13) {
                i = sb->cur;
                while(sb->next > i && ( *(sb->buf + i) & 255) != 10 && ( *(sb->buf + i) & 255) != 13) {
                    i = i + 1;
                }
                if(sb->next <= i) {
                    if(s == 0) {
                        s = Strnew_size(sb->next - sb->cur + 10);
                    }
                    Strcat_charp_n(s, sb->buf + sb->cur, sb->next - sb->cur);
                    sb->cur = sb->next;
                    continue;
                }
                len = i - sb->cur + 1;
                if(s == 0) {
                    s = Strnew_size(len + 10);
                }
                Strcat_charp_n(s, sb->buf + sb->cur, len);
                sb->cur = i + 1;
                if(( *(sb->buf + i) & 255) != 10) {
                    continue;
                } else {
                    return s;
                }
            } else {
                if(( *(sb->buf + sb->cur) & 255) == 10) {
                    if(s->length + 1 >= s->area_size) {
                        Strgrow(s);
                    }
                    _t229 = s->length;
                    _t193 = sb->cur;
                     *((char*)(s->ptr + _t229)) =  *(sb->buf + _t193) & 255;
                    s->length = _t229 + 1;
                    sb->cur = _t193 + 1;
                     *((char*)(s->ptr + s->length)) = 0;
                }
                return s;
            }
        } else {
            do_update(base);
            continue;
        }
    }
    if(s != 0) {
        return s;
    }
    return Strnew();
}

int ISread(InputStream stream, Str buf, int count)
{// addr = 0x080B116F  --  defined in 'istream.c' at line 315
    int rest;                              // _cfa_fffffff0
    int len;                               // _cfa_ffffffec
    BaseStream base;   // _cfa_ffffffe8
    int _v36;                              // _cfa_ffffffdc (outparam)
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    int _t66;                              // _t66

    if(stream == 0) {
L2:
        return 0;
    }
    base = stream;
    if((base->iseos & 255) == 0) {
        len = buffer_read(base, buf->ptr, count);
        rest = count - len;
        if(base->stream.cur == base->stream.next) {
            _t66 = base->handle;
            _v36 = rest;
            _v40 = buf->ptr + len;
             *__esp = _t66;
             *(base->read)();
            len = _t66;
            if(len <= 0) {
                base->iseos = 1;
                len = 0;
            }
            rest = rest - len;
        }
        Strtruncate(buf, count - rest);
        if(buf->length <= 0) {
            return 0;
        } else {
            return 1;
        }
    }
    goto L2;
}

int ISfileno(InputStream stream)
{// addr = 0x080B124F  --  defined in 'istream.c' at line 340
    signed int _t13;                       // _t13
    int _t16;                              // _t16

    if(stream != 0) {
        _t13 = stream->base.stream.cur & 0xef;
        if(_t13 == 1) {
            _t16 =  *(stream->base.stream.size);
             *__esp = _t16;
            fileno();
            return _t16;
        }
        if(_t13 == 4) {
            return ISfileno( *(stream->base.stream.size));
        }
        if(_t13 != 0) {
            return -1;
        }
        return  *(stream->base.stream.size);
    }
    return -1;
}

int ISeos(InputStream stream)
{// addr = 0x080B12B2  --  defined in 'istream.c' at line 361
    BaseStream base;   // _cfa_fffffff0

    base = stream;
    if((base->iseos & 255) == 0 && base->stream.cur == base->stream.next) {
        do_update(base);
    }
    return base->iseos & 255;
}

void basic_close(int* handle)
{// addr = 0x080B12F0  --  defined in 'istream.c' at line 641
     *__esp =  *handle;
    close();
}

int basic_read(int* handle, char* buf, int len)
{// addr = 0x080B1305  --  defined in 'istream.c' at line 651
    int _v20;                              // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    int _t7;                               // _t7

    _t7 =  *handle;
    _v20 = len;
    _v24 = buf;
     *__esp = _t7;
    read();
    return _t7;
}

void file_close(struct file_handle* handle)
{// addr = 0x080B1328  --  defined in 'istream.c' at line 661
     *__esp = handle->f;
    handle();
}

int file_read(struct file_handle* handle, char* buf, int len)
{// addr = 0x080B1340  --  defined in 'istream.c' at line 667
    FILE* _v16;           // _cfa_fffffff0
    int _v20;                              // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    int _t9;                               // _t9

    _v16 = handle->f;
    _v20 = len;
    _v24 = 1;
    _t9 = buf;
     *__esp = _t9;
    fread();
    return _t9;
}

int str_read(Str handle, char* buf, int len)
{// addr = 0x080B136B  --  defined in 'istream.c' at line 673
    return 0;
}

void ens_close(struct ens_handle* handle)
{// addr = 0x080B1375  --  defined in 'istream.c' at line 717
    ISclose(handle->is);
}

int ens_read(struct ens_handle* handle, char* buf, int len)
{// addr = 0x080B138A  --  defined in 'istream.c' at line 723
    char* p;                               // _cfa_fffffff0
    int _v36;                              // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    char* _t127;                           // _t127

    if(handle->s == 0 || handle->pos ==  *(handle->s + 4)) {
        handle->s = StrmyISgets(handle->is);
        if( *(handle->s + 4) == 0) {
            return 0;
        }
        cleanup_line(handle->s, 1);
        if((handle->encoding & 255) != 1) {
            if((handle->encoding & 255) == 3) {
                _t127 =  *(handle->s);
                _v36 = 5;
                _v40 = 135074528;
                 *__esp = _t127;
                strncmp();
                if(_t127 == 0) {
                    handle->s = StrmyISgets(handle->is);
                }
                Strchop(handle->s);
            }
        } else {
            Strchop(handle->s);
        }
        p =  *(handle->s);
        if((handle->encoding & 255) != 2) {
            if((handle->encoding & 255) != 1) {
                if((handle->encoding & 255) == 3) {
                    handle->s = decodeU( &p);
                }
            } else {
                handle->s = decodeB( &p);
            }
        } else {
            handle->s = decodeQP( &p);
        }
        handle->pos = 0;
    }
    if( *(handle->s + 4) - handle->pos < len) {
        len =  *(handle->s + 4) - handle->pos;
    }
    _v36 = len;
    _v40 = buf;
     *__esp =  &(( *(handle->s))[handle->pos]);
    bcopy();
    handle->pos = handle->pos + len;
    return len;
}

Str Strnew()
{// addr = 0x080B1538  --  defined in 'Str.c' at line 37
    Str x;                 // _cfa_fffffff0

     *__esp = 12;
    GC_malloc();
    x = __eax;
     *__esp = 32;
    GC_malloc_atomic();
    x->ptr = __eax;
     *(x->ptr) = 0;
    x->area_size = 32;
    x->length = 0;
    return x;
}

Str Strnew_size(int n)
{// addr = 0x080B1581  --  defined in 'Str.c' at line 48
    Str x;                 // _cfa_fffffff0
    char* _t14;                            // _t14

     *__esp = 12;
    GC_malloc();
    x = __eax;
    _t14 = n + 1;
     *__esp = _t14;
    GC_malloc_atomic();
    x->ptr = _t14;
     *(x->ptr) = 0;
    x->area_size = n + 1;
    x->length = 0;
    return x;
}

Str Strnew_charp(char* p)
{// addr = 0x080B15CE  --  defined in 'Str.c' at line 59
    Str x;                 // _cfa_fffffff0
    int n;                                 // _cfa_ffffffec
    int _v36;                              // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    struct _Str* _t20;    // _t20
    char* _t21;                            // _t21
    char* _t23;                            // _t23

    if(p != 0) {
         *__esp = 12;
        GC_malloc();
        x = _t20;
        _t21 = p;
         *__esp = _t21;
        strlen();
        n =  &(_t21[1]);
        _t23 = n;
         *__esp = _t23;
        GC_malloc_atomic();
        x->ptr = _t23;
        x->area_size = n;
        x->length = n - 1;
        _v36 = n;
        _v40 = x->ptr;
         *__esp = p;
        bcopy();
        return x;
    }
    return Strnew();
}

Str Strnew_m_charp(char* p)
{// addr = 0x080B1648  --  defined in 'Str.c' at line 76
    va_list ap;        // _cfa_fffffff0
    Str r;                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    char** _t17;                           // _t17

    r = Strnew();
    ap =  &_a8;
    while(p != 0) {
        Strcat_charp(r, p);
        _t17 = ap;
        ap =  &(_t17[1]);
        p =  *_t17;
    }
    return r;
}

Str Strnew_charp_n(char* p, int n)
{// addr = 0x080B1689  --  defined in 'Str.c' at line 90
    Str x;                 // _cfa_fffffff0
    int _v36;                              // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    struct _Str* _t22;    // _t22
    char* _t24;                            // _t24

    if(p != 0) {
         *__esp = 12;
        GC_malloc();
        x = _t22;
        _t24 = n + 1;
         *__esp = _t24;
        GC_malloc_atomic();
        x->ptr = _t24;
        x->area_size = n + 1;
        x->length = n;
        _v36 = n;
        _v40 = x->ptr;
         *__esp = p;
        bcopy();
        x->ptr[n] = 0;
        return x;
    }
    return Strnew_size(n);
}

Str Strdup(Str s)
{// addr = 0x080B1709  --  defined in 'Str.c' at line 106
    Str n;                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    n = Strnew_size(s->length);
    Strcopy(n, s);
    return n;
}

void Strclear(Str s)
{// addr = 0x080B1737  --  defined in 'Str.c' at line 115
    s->length = 0;
    s = 0;
}

void Strfree(Str x)
{// addr = 0x080B174E  --  defined in 'Str.c' at line 122
     *__esp = x->ptr;
    GC_free();
     *__esp = x;
    GC_free();
}

void Strcopy(Str x, Str y)
{// addr = 0x080B176E  --  defined in 'Str.c' at line 129
    intOrPtr _v20;                         // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    char* _t40;                            // _t40

    if(x->area_size < y->length + 1) {
         *__esp = x->ptr;
        GC_free();
        _t40 = y->length + 1;
         *__esp = _t40;
        GC_malloc_atomic();
        x->ptr = _t40;
        x->area_size = y->length + 1;
    }
    _v20 = y->length + 1;
    _v24 = x->ptr;
     *__esp = y->ptr;
    bcopy();
    x->length = y->length;
}

void Strcopy_charp(Str x, char* y)
{// addr = 0x080B17EE  --  defined in 'Str.c' at line 143
    int len;                               // _cfa_fffffff0
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    int _t24;                              // _t24
    struct _Str* _t25;    // _t25
    char* _t28;                            // _t28
    char* _t36;                            // _t36

    __eflags = y;
    if(__eflags != 0) {
        _t24 = y;
         *__esp = _t24;
        strlen();
        len = _t24;
        _t25 = x;
        __eflags = _t25->area_size - len + 1;
        if(_t25->area_size < len + 1) {
             *__esp = x->ptr;
            GC_free();
            _t36 = len + 1;
            __eflags = _t36;
             *__esp = _t36;
            GC_malloc_atomic();
            x->ptr = _t36;
            x->area_size = len + 1;
        }
        _t28 = len + 1;
        __eflags = _t28;
        _v36 = _t28;
        _v40 = x->ptr;
         *__esp = y;
        bcopy();
        x->length = len;
        return;
    }
    x->length = 0;
}

void Strcopy_charp_n(Str x, char* y, int n)
{// addr = 0x080B187D  --  defined in 'Str.c' at line 163
    int len;                               // _cfa_fffffff0
    int _v36;                              // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _t40;                            // _t40

    len = n;
    __eflags = y;
    if(__eflags != 0) {
        __eflags = x->area_size - len + 1;
        if(__eflags < 0) {
             *__esp = x->ptr;
            GC_free();
            _t40 = len + 1;
            __eflags = _t40;
             *__esp = _t40;
            GC_malloc_atomic();
            x->ptr = _t40;
            x->area_size = len + 1;
        }
        _v36 = n;
        _v40 = x->ptr;
         *__esp = y;
        bcopy();
         *((char*)(x->ptr + n)) = 0;
        x->length = n;
        return;
    }
    x->length = 0;
}

void Strcat_charp_n(Str x, char* y, int n)
{// addr = 0x080B190D  --  defined in 'Str.c' at line 183
    int newlen;                            // _cfa_fffffff0
    char* old;                             // _cfa_ffffffec
    int _v36;                              // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _t65;                            // _t65

    if(y != 0) {
        newlen = x->length + n + 1;
        if(x->area_size < newlen) {
            old = x->ptr;
            newlen = (newlen + newlen + _t81 >> 31) + newlen + newlen + _t81 >> 1;
            _t65 = newlen;
             *__esp = _t65;
            GC_malloc_atomic();
            x->ptr = _t65;
            x->area_size = newlen;
            _v36 = x->length;
            _v40 = x->ptr;
             *__esp = old;
            bcopy();
             *__esp = old;
            GC_free();
        }
        _v36 = n;
        _v40 = x->ptr + x->length;
         *__esp = y;
        bcopy();
        x->length = x->length + n;
         *(x->ptr + x->length) = 0;
        return;
    }
}

void Strcat(Str x, Str y)
{// addr = 0x080B19E6  --  defined in 'Str.c' at line 205
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    Strcat_charp_n(x, y->ptr, y->length);
}

void Strcat_charp(Str x, char* y)
{// addr = 0x080B1A0C  --  defined in 'Str.c' at line 212
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    int _t7;                               // _t7

    if(y != 0) {
        _t7 = y;
         *__esp = _t7;
        strlen();
        Strcat_charp_n(x, y, _t7);
        return;
    }
}

void Strcat_m_charp(Str x)
{// addr = 0x080B1A3E  --  defined in 'Str.c' at line 220
    va_list ap;        // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    char** _t14;                           // _t14
    int _t16;                              // _t16

    ap =  &_a8;
    while(1) {
        _t14 = ap;
        ap =  &(_t14[1]);
        p =  *_t14;
        if(p == 0) {
            break;
        }
        _t16 = p;
         *__esp = _t16;
        strlen();
        Strcat_charp_n(x, p, _t16);
    }
}

void Strgrow(Str x)
{// addr = 0x080B1A83  --  defined in 'Str.c' at line 231
    char* old;                             // _cfa_fffffff0
    int newlen;                            // _cfa_ffffffec
    int _v36;                              // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _t41;                            // _t41

    old = x->ptr;
    newlen = ((x->length + x->length + _t53 + x->length + x->length + _t53) * 1717986919 >> 32 >> 1) - (x->length + x->length + _t53 + x->length + x->length + _t53 >> 31);
    if(x->length == newlen) {
        newlen = newlen + 2;
    }
    _t41 = newlen;
     *__esp = _t41;
    GC_malloc_atomic();
    x->ptr = _t41;
    x->area_size = newlen;
    _v36 = x->length;
    _v40 = x->ptr;
     *__esp = old;
    bcopy();
     *__esp = old;
    GC_free();
}

Str Strsubstr(Str s, int beg, int len)
{// addr = 0x080B1B11  --  defined in 'Str.c' at line 245
    Str new_s;             // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int _t51;                              // _t51

    new_s = Strnew();
    if(s->length > beg) {
        i = 0;
        while(i < len && beg + i < s->length) {
            if(new_s->length + 1 >= new_s->area_size) {
                Strgrow(new_s);
            }
            _t51 = new_s->length;
             *((char*)(new_s->ptr + _t51)) = s->ptr[beg + i] & 255;
            new_s->length = _t51 + 1;
             *((char*)(new_s->ptr + new_s->length)) = 0;
            i = i + 1;
        }
        return new_s;
    }
    return new_s;
}

void Strlower(Str s)
{// addr = 0x080B1BC2  --  defined in 'Str.c' at line 260
    int i;                                 // _cfa_fffffff8
    signed int _t34;                       // _t34
    char* _t43;                            // _t43

    i = 0;
    while(s->length > i) {
        _t43 =  &(s->ptr[i]);
        if(( *( &MYCTYPE_MAP + (s->ptr[i] & 0xff)) & 4) == 0) {
            _t34 = s->ptr[i] & 255;
        } else {
            _t34 = s->ptr[i] & 255 | 32;
        }
         *_t43 = _t34;
        i = i + 1;
    }
}

void Strupper(Str s)
{// addr = 0x080B1C31  --  defined in 'Str.c' at line 269
    int i;                                 // _cfa_fffffff8
    signed int _t34;                       // _t34
    char* _t43;                            // _t43

    i = 0;
    while(s->length > i) {
        _t43 =  &(s->ptr[i]);
        if(( *( &MYCTYPE_MAP + (s->ptr[i] & 0xff)) & 4) == 0) {
            _t34 = s->ptr[i] & 255;
        } else {
            _t34 = s->ptr[i] & 0xdf;
        }
         *_t43 = _t34;
        i = i + 1;
    }
}

void Strchop(Str s)
{// addr = 0x080B1CA0  --  defined in 'Str.c' at line 278
    while(( *(s->ptr + s->length - 1) & 255) == 10 || ( *(s->ptr + s->length - 1) & 255) == 13) {
        if(s->length > 0) {
            s->length = s->length - 1;
            continue;
        }
        break;
    }
     *((char*)(s->ptr + s->length)) = 0;
}

void Strinsert_char(Str s, int pos, char c)
{// addr = 0x080B1D01  --  defined in 'Str.c' at line 289
    int i;                                 // _cfa_fffffff0
    signed char _v32;                      // _cfa_ffffffe0

    _v32 = c;
    if(pos < 0) {
        return;
    }
    if(s->length >= pos) {
        if(s->length + 2 > s->area_size) {
            Strgrow(s);
        }
        i = s->length;
        while(i > pos) {
             *((char*)(s->ptr + i)) =  *(s->ptr + i - 1) & 255;
            i = i - 1;
        }
        s->length = s->length + 1;
         *((char*)(s->ptr + s->length)) = 0;
        s->ptr[pos] = _v32 & 255;
        return;
    }
}

void Strinsert_charp(Str s, int pos, char* p)
{// addr = 0x080B1DAF  --  defined in 'Str.c' at line 304
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    while(( *p & 255) != 0) {
        p =  &(p[1]);
        pos = pos + 1;
        Strinsert_char(s, pos,  *p & 255);
    }
}

void Strdelete(Str s, int pos, int n)
{// addr = 0x080B1DEA  --  defined in 'Str.c' at line 312
    int i;                                 // _cfa_fffffff4

    if(s->length > pos + n) {
        i = pos;
        while(s->length - n > i) {
             *((char*)(s->ptr + i)) =  *(s->ptr + i + n) & 255;
            i = i + 1;
        }
         *((char*)(s->ptr + i)) = 0;
        s->length = i;
        return;
    }
     *((char*)(s->ptr + pos)) = 0;
    s->length = pos;
}

void Strtruncate(Str s, int pos)
{// addr = 0x080B1E74  --  defined in 'Str.c' at line 328
     *((char*)(s->ptr + pos)) = 0;
    s->length = pos;
}

void Strshrink(Str s, int n)
{// addr = 0x080B1E90  --  defined in 'Str.c' at line 336
    int _t29;                              // _t29

    __eflags = s->length - n;
    if(__eflags > 0) {
        _t29 = s->length - n;
        __eflags = _t29;
        s->length = _t29;
         *((char*)(s->ptr + s->length)) = 0;
        return;
    }
    s->length = 0;
    s = 0;
}

void Strremovefirstspaces(Str s)
{// addr = 0x080B1ED6  --  defined in 'Str.c' at line 350
    int i;                                 // _cfa_fffffff8
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)

    i = 0;
    while(s->length > i && ( *( &MYCTYPE_MAP + (s->ptr[i] & 0xff)) & 2) != 0) {
        i = i + 1;
    }
    if(i != 0) {
        Strdelete(s, 0, i);
        return;
    }
}

void Strremovetrailingspaces(Str s)
{// addr = 0x080B1F3B  --  defined in 'Str.c' at line 362
    int i;                                 // _cfa_fffffff8

    i = s->length - 1;
    while(i >= 0 && ( *( &MYCTYPE_MAP + ( *(s->ptr + i) & 0xff)) & 2) != 0) {
        i = i - 1;
    }
    s->length = i + 1;
    s->ptr[i + 1] = 0;
}

Str Stralign_left(Str s, int width)
{// addr = 0x080B1F99  --  defined in 'Str.c' at line 373
    Str n;                 // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t50;                              // _t50

    if(s->length < width) {
        n = Strnew_size(width);
        Strcopy(n, s);
        i = s->length;
        while(i < width) {
            if(n->length + 1 >= n->area_size) {
                Strgrow(n);
            }
            _t50 = n->length;
             *((char*)(n->ptr + _t50)) = 32;
            n->length = _t50 + 1;
             *((char*)(n->ptr + n->length)) = 0;
            i = i + 1;
        }
        return n;
    }
    return Strdup(s);
}

Str Stralign_right(Str s, int width)
{// addr = 0x080B2041  --  defined in 'Str.c' at line 389
    Str n;                 // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t48;                              // _t48

    if(s->length < width) {
        n = Strnew_size(width);
        i = s->length;
        while(i < width) {
            if(n->length + 1 >= n->area_size) {
                Strgrow(n);
            }
            _t48 = n->length;
             *((char*)(n->ptr + _t48)) = 32;
            n->length = _t48 + 1;
             *((char*)(n->ptr + n->length)) = 0;
            i = i + 1;
        }
        Strcat(n, s);
        return n;
    }
    return Strdup(s);
}

Str Stralign_center(Str s, int width)
{// addr = 0x080B20E9  --  defined in 'Str.c' at line 405
    Str n;                 // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int w;                                 // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t79;                              // _t79
    int _t98;                              // _t98

    if(s->length < width) {
        n = Strnew_size(width);
        w = (width - s->length >> 31) + width - s->length >> 1;
        i = 0;
        while(i < w) {
            if(n->length + 1 >= n->area_size) {
                Strgrow(n);
            }
            _t79 = n->length;
             *((char*)(n->ptr + _t79)) = 32;
            n->length = _t79 + 1;
             *((char*)(n->ptr + n->length)) = 0;
            i = i + 1;
        }
        Strcat(n, s);
        i = s->length + w;
        while(i < width) {
            if(n->length + 1 >= n->area_size) {
                Strgrow(n);
            }
            _t98 = n->length;
             *((char*)(n->ptr + _t98)) = 32;
            n->length = _t98 + 1;
             *((char*)(n->ptr + n->length)) = 0;
            i = i + 1;
        }
        return n;
    }
    return Strdup(s);
}

Str Sprintf(char* fmt)
{// addr = 0x080B2210  --  defined in 'Str.c' at line 428
    double vd;                             // _cfa_ffffffc4
    int vi;                                // _cfa_ffffffd8
    char* vs;                              // _cfa_ffffffd4
    _Unknown_base* vp;                     // _cfa_ffffffd0
    int len;                               // _cfa_fffffff0
    int status;                            // _cfa_ffffffec
    int p;                                 // _cfa_ffffffe8
    char* f;                               // _cfa_ffffffe4
    Str s;                 // _cfa_ffffffe0
    va_list ap;        // _cfa_ffffffdc
    int _v64;                              // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    int _t61;                              // _t61
    int _t107;                             // _t107

    len = 0;
    status = 0;
    p = 0;
    ap =  &_a8;
    f = fmt;
L21:
    while(( *f & 255) != 0) {
        while(1) {
            _t61 = status;
            if(_t61 == 1) {
                break;
            }
            if(_t61 == 2) {
                if(( *( &MYCTYPE_MAP + ( *f & 0xff)) & 4) == 0) {
                    goto L20;
                }
                status = 1;
                continue;
            } else {
                if(_t61 == 0) {
                    if(( *f & 255) != 37) {
                        len = len + 1;
                    } else {
                        status = 1;
                        p = 0;
                    }
                }
L20:
                f =  &(f[1]);
                goto L21;
            }
        }
        if(( *( &MYCTYPE_MAP + ( *f & 0xff)) & 4) == 0) {
            if(( *( &MYCTYPE_MAP + ( *f & 0xff)) & 8) == 0) {
                if(( *f & 255) != 46) {
                    if(( *f & 255) == 37) {
                        status = 0;
                        len = len + 1;
                    }
                } else {
                    status = 2;
                }
            } else {
                p = (p << 2) + p + (p << 2) + p + ( *f & 255) - 48;
            }
            goto L20;
        }
        if(( *f & 255) - 69 > 51) {
            status = 0;
            goto L20;
        }
        goto __eax;
    }
    s = Strnew_size(len + len);
    ap =  &_a8;
    _v68 = ap;
    _v72 = fmt;
     *__esp = s->ptr;
    vsprintf();
    _t107 = s->ptr;
     *__esp = _t107;
    strlen();
    s->length = _t107;
    if(s->length > len + len) {
        _v64 = __imp__stderr;
        _v68 = 25;
        _v72 = 1;
         *__esp = "Sprintf: string too long\n";
        fwrite();
         *__esp = 1;
        exit();
    }
    return s;
}

Str Strfgets(FILE* f)
{// addr = 0x080B249D  --  defined in 'Str.c' at line 530
    char c;                                // _cfa_fffffff3
    Str s;                 // _cfa_ffffffec
    char _t26;                             // _t26
    FILE* _t27;           // _t27
    FILE* _t29;           // _t29
    int _t36;                              // _t36

    s = Strnew();
    while(1) {
        _t26 = f;
         *__esp = _t26;
        fgetc();
        c = _t26;
        _t27 = f;
         *__esp = _t27;
        feof();
        if(_t27 != 0) {
            break;
        }
        _t29 = f;
         *__esp = _t29;
        ferror();
        if(_t29 == 0) {
            if(s->length + 1 >= s->area_size) {
                Strgrow(s);
            }
            _t36 = s->length;
             *((char*)(s->ptr + _t36)) = c & 255;
            s->length = _t36 + 1;
             *((char*)(s->ptr + s->length)) = 0;
            if(c != 10) {
                continue;
            } else {
            }
        }
        break;
    }
    return s;
}

Str Strfgetall(FILE* f)
{// addr = 0x080B2533  --  defined in 'Str.c' at line 546
    char c;                                // _cfa_fffffff3
    Str s;                 // _cfa_ffffffec
    char _t25;                             // _t25
    FILE* _t26;           // _t26
    FILE* _t28;           // _t28
    int _t35;                              // _t35

    s = Strnew();
    while(1) {
        _t25 = f;
         *__esp = _t25;
        fgetc();
        c = _t25;
        _t26 = f;
         *__esp = _t26;
        feof();
        if(_t26 != 0) {
            break;
        }
        _t28 = f;
         *__esp = _t28;
        ferror();
        if(_t28 == 0) {
            if(s->length + 1 >= s->area_size) {
                Strgrow(s);
            }
            _t35 = s->length;
             *((char*)(s->ptr + _t35)) = c & 255;
            s->length = _t35 + 1;
             *((char*)(s->ptr + s->length)) = 0;
            continue;
        }
        break;
    }
    return s;
}

clen_t strtoclen(const char* s)
{// addr = 0x080B25C4  --  defined in 'indep.c' at line 56
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8

    _v20 = 10;
    _v24 = 0;
    __eax = s;
     *__esp = __eax;
    strtoll();
    return __eax;
}

char* allocStr(const char* s, int len)
{// addr = 0x080B25E7  --  defined in 'indep.c' at line 99
    char* ptr;                             // _cfa_fffffff0
    int _v32;                              // _cfa_ffffffe0
    int _v36;                              // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _t20;                            // _t20
    int _t29;                              // _t29

    if(s != 0) {
        if(len < 0) {
            _t29 = s;
             *__esp = _t29;
            strlen();
            len = _t29;
        }
        _t20 =  &(1[len]);
         *__esp = _t20;
        GC_malloc_atomic();
        ptr = _t20;
        if(ptr == 0) {
            _v32 = __imp__stderr;
            _v36 = 48;
            _v40 = 1;
             *__esp = "fm: Can't allocate string. Give me more memory!\n";
            fwrite();
             *__esp = -1;
            exit();
        }
        _v36 = len;
        _v40 = ptr;
         *__esp = s;
        bcopy();
        ptr[len] = 0;
        return ptr;
    }
    return 0;
}

int strCmp(* s1, * s2)
{// addr = 0x080B2683  --  defined in 'indep.c' at line 118
    intOrPtr _v24;                         // _cfa_ffffffe8
    int _t6;                               // _t6

    _t6 =  *s1;
    _v24 =  *s2;
     *__esp = _t6;
    strcmp();
    return _t6;
}

char* currentdir()
{// addr = 0x080B26A1  --  defined in 'indep.c' at line 124
    char* path;                            // _cfa_fffffff0
    char* _v40;                            // _cfa_ffffffd8

     *__esp = 4096;
    GC_malloc_atomic();
    path = __eax;
    _v40 = 4096;
     *__esp = path;
    getcwd();
    return path;
}

char* cleanupName(char* name)
{// addr = 0x080B26CE  --  defined in 'indep.c' at line 156
    char* buf;                             // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    intOrPtr _v36;                         // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    char* _t95;                            // _t95
    char* _t96;                            // _t96
    char* _t97;                            // _t97
    char* _t98;                            // _t98
    char* _t99;                            // _t99
    char* _t117;                           // _t117
    char* _t119;                           // _t119
    char* _t131;                           // _t131
    char* _t133;                           // _t133

    buf = allocStr(name, -1);
    p = buf;
    q = name;
    while(( *q & 255) != 0) {
        _v36 = 4;
        _v40 = "/../";
        _t95 = p;
         *__esp = _t95;
        strncmp();
        if(_t95 != 0) {
            _v40 = "/..";
            _t96 = p;
             *__esp = _t96;
            strcmp();
            if(_t96 != 0) {
                _v36 = 3;
                _v40 = "/./";
                _t97 = p;
                 *__esp = _t97;
                strncmp();
                if(_t97 != 0) {
                    _v40 = "/.";
                    _t98 = p;
                     *__esp = _t98;
                    strcmp();
                    if(_t98 != 0) {
                        _v36 = 2;
                        _v40 = "//";
                        _t99 = p;
                         *__esp = _t99;
                        strncmp();
                        if(_t99 != 0) {
                            p =  &(p[1]);
                            q =  &(q[1]);
                        } else {
                             *p = 0;
                            q =  &(q[1]);
                            _v40 = q;
                             *__esp = buf;
                            strcat();
                        }
                        continue;
                    }
                    p =  &(p[1]);
                     *p = 0;
                    break;
                }
                 *p = 0;
                q =  &(q[2]);
                _v40 = q;
                 *__esp = buf;
                strcat();
                continue;
            }
            if(p - 2 != buf) {
L15:
                if(p - 3 < buf) {
L18:
                    while(p != buf) {
                        p = p - 1;
                        if(( *p & 255) != 47) {
                            continue;
                        }
                        break;
                    }
                    p =  &(p[1]);
                     *p = 0;
                    break;
                }
                _t117 = p - 3;
                _v36 = 3;
                _v40 = "/..";
                 *__esp = _t117;
                strncmp();
                if(_t117 != 0) {
                    goto L18;
                }
L21:
                break;
            }
            _t119 = p - 2;
            _v36 = 2;
            _v40 = "..";
             *__esp = _t119;
            strncmp();
            if(_t119 != 0) {
                goto L15;
            }
            goto L21;
        }
        if(p - 2 != buf) {
L5:
            if(p - 3 < buf) {
L8:
                while(p != buf) {
                    p = p - 1;
                    if(( *p & 255) != 47) {
                        continue;
                    }
                    break;
                }
                 *p = 0;
                q =  &(q[3]);
                _v40 = q;
                 *__esp = buf;
                strcat();
                continue;
            }
            _t131 = p - 3;
            _v36 = 3;
            _v40 = "/..";
             *__esp = _t131;
            strncmp();
            if(_t131 != 0) {
                goto L8;
            }
            p =  &(p[3]);
            q =  &(q[3]);
            continue;
        }
        _t133 = p - 2;
        _v36 = 2;
        _v40 = "..";
         *__esp = _t133;
        strncmp();
        if(_t133 != 0) {
            goto L5;
        }
        p =  &(p[3]);
        q =  &(q[3]);
    }
    return buf;
}

char* expandPath(char* name)
{// addr = 0x080B2925  --  defined in 'indep.c' at line 219
    char* p;                               // _cfa_fffffff0
    struct passwd* passent;   // _cfa_ffffffec
    Str extpath;           // _cfa_ffffffe8
    char* q;                               // _cfa_ffffffe4
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    signed int _t52;                       // _t52
    char* _t55;                            // _t55
    char* _t63;                            // _t63
    struct passwd* _t64;   // _t64
    struct passwd* _t71;   // _t71

    extpath = 0;
    if(name != 0) {
        p = name;
        if(( *p & 255) != 126) {
L17:
            return name;
        }
        p =  &(p[1]);
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 4) == 0) {
            _t52 =  *p & 255;
            if(_t52 == 47) {
L11:
                 *__esp = "HOME";
                getenv();
                extpath = Strnew_charp(_t52);
L12:
                _t55 = extpath->ptr;
                _v40 = 135076317;
                 *__esp = _t55;
                strcmp();
                if(_t55 == 0 && ( *p & 255) == 47) {
                    p =  &(p[1]);
                }
                Strcat_charp(extpath, p);
                return extpath->ptr;
            }
            _t52 =  *p & 255;
            if(_t52 != 0) {
                goto L17;
            }
            goto L11;
        }
        _v40 = 47;
        _t63 = p;
         *__esp = _t63;
        strchr();
        q = _t63;
        if(q == 0) {
            _t64 = p;
             *__esp = _t64;
            getpwnam();
            passent = _t64;
            p = 135076311;
        } else {
            _t71 = allocStr(p, q - p);
             *__esp = _t71;
            getpwnam();
            passent = _t71;
            p = q;
        }
        if(passent == 0) {
            goto L17;
        } else {
            extpath = Strnew_charp(passent->pw_dir);
            goto L12;
        }
    }
    return 0;
}

int strcasematch(char* s1, char* s2)
{// addr = 0x080B2A5D  --  defined in 'indep.c' at line 327
    int x;                                 // _cfa_fffffff8
    signed int _t38;                       // _t38

    while(( *s1 & 255) != 0) {
        if(( *s2 & 255) != 0) {
            if(( *( &MYCTYPE_MAP + ( *s1 & 0xff)) & 4) == 0) {
                __edx =  *s1 & 255;
            } else {
                __edx =  *s1 & 255 | 32;
            }
            if(( *( &MYCTYPE_MAP + ( *s2 & 0xff)) & 4) == 0) {
                _t38 =  *s2 & 255;
            } else {
                _t38 =  *s2 & 255 | 32;
            }
            x = __edx - _t38;
            if(x != 0) {
L14:
                return ( *s2 & 255) == 0 & 255;
            } else {
                s1 =  &(s1[1]);
                s2 =  &(s2[1]);
                continue;
            }
        }
        return 1;
    }
    goto L14;
}

int strcasemstr(char* str, char** srch, char** ret_ptr)
{// addr = 0x080B2B16  --  defined in 'indep.c' at line 344
    int i;                                 // _cfa_fffffff8
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    while(( *str & 255) != 0) {
        i = 0;
        while(srch[i] != 0) {
            if(strcasematch(str, srch[i]) == 0) {
                i = i + 1;
                continue;
            }
            if(ret_ptr != 0) {
                 *ret_ptr = str;
            }
            return i;
        }
        str =  &(str[1]);
    }
    return -1;
}

char* remove_space(char* str)
{// addr = 0x080B2B80  --  defined in 'indep.c' at line 361
    char* p;                               // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    p = str;
    do {
    } while(( *p & 255) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0);
    q = p;
    while(( *q & 255) != 0) {
        q =  &(q[1]);
    }
    while(q > p && ( *( &MYCTYPE_MAP + ( *(q - 1) & 0xff)) & 2) != 0) {
        q = q - 1;
    }
    if(( *q & 255) == 0) {
        return p;
    }
    return  *(Strnew_charp_n(p, q - p));
}

int non_null(char* s)
{// addr = 0x080B2C25  --  defined in 'indep.c' at line 374
    if(s != 0) {
        while(1) {
            s =  *s & 255;
            if(__al == 0) {
                break;
            }
            s =  *s & 255;
            __eax =  *( &MYCTYPE_MAP + __eax) & 255;
            __eax = __al & 255;
            if(__eax != 0) {
                s =  &(s[1]);
                continue;
            }
            __eax = 1;
            return 1;
        }
        __eax = 0;
        return 0;
    }
    __eax = 0;
    return 0;
}

void cleanup_line(Str s, int mode)
{// addr = 0x080B2C6E  --  defined in 'indep.c' at line 387
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t88;                              // _t88
    int _t140;                             // _t140

    if(s->length <= 1) {
L6:
        if(s->length <= 0 || ( *(s->ptr + s->length - 1) & 255) != 13) {
            if(s->length <= 0 || ( *(s->ptr + s->length - 1) & 255) != 10) {
                if(s->length + 1 >= s->area_size) {
                    Strgrow(s);
                }
                _t88 = s->length;
                 *((char*)(s->ptr + _t88)) = 10;
                s->length = _t88 + 1;
                 *((char*)(s->ptr + s->length)) = 0;
            }
        } else {
             *(s->ptr + s->length - 1) = 10;
        }
L14:
        if(mode == 1) {
L20:
            return;
        } else {
            i = 0;
            while(s->length > i) {
                if(( *(s->ptr + i) & 255) == 0) {
                     *(s->ptr + i) = 32;
                }
                i = i + 1;
            }
            goto L20;
        }
    }
    if(( *(s->ptr + s->length - 2) & 255) != 13 || ( *(s->ptr + s->length - 1) & 255) != 10) {
        goto L6;
    } else {
        Strshrink(s, 2);
        if(s->length + 1 >= s->area_size) {
            Strgrow(s);
        }
        _t140 = s->length;
         *((char*)(s->ptr + _t140)) = 10;
        s->length = _t140 + 1;
         *((char*)(s->ptr + s->length)) = 0;
        goto L14;
    }
}

int getescapechar(char** str)
{// addr = 0x080B2DFB  --  defined in 'indep.c' at line 408
    int dummy;                             // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    int strict_entity;                     // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    char* _t118;                           // _t118

    dummy = -1;
    p =  *str;
    strict_entity = 1;
    if(( *p & 255) == 38) {
        p =  &(p[1]);
    }
    if(( *p & 255) != 35) {
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 4) != 0) {
            q = p;
            p =  &(p[1]);
            while(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 0xc) != 0) {
                p =  &(p[1]);
            }
            q = allocStr(q, p - q);
            _t118 = q;
            _v40 = _t118;
             *__esp = "lt gt amp quot nbsp";
            strcasestr();
            if(_t118 != 0 && ( *p & 255) != 61) {
                strict_entity = 0;
            }
            if(( *p & 255) != 59) {
                if(strict_entity == 0) {
                    goto L33;
                }
                 *str = p;
                return -1;
            } else {
                p =  &(p[1]);
L33:
                 *str = p;
                return getHash_si( &entity, q, -1);
            }
        }
         *str = p;
        return -1;
    }
    p =  &(p[1]);
    if(( *p & 255) == 120 || ( *p & 255) == 88) {
        p =  &(p[1]);
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 0x28) != 0) {
            dummy =  *( &MYCTYPE_DIGITMAP + ( *p & 0xff)) & 0xff;
            p =  &(p[1]);
            while(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 0x28) != 0) {
                dummy = (dummy << 4) + ( *( &MYCTYPE_DIGITMAP + ( *p & 0xff)) & 0xff);
                p =  &(p[1]);
            }
            if(( *p & 255) == 59) {
                p =  &(p[1]);
            }
             *str = p;
            return dummy;
        }
         *str = p;
        return -1;
    } else {
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 8) != 0) {
            dummy =  *( &MYCTYPE_DIGITMAP + ( *p & 0xff)) & 0xff;
            p =  &(p[1]);
            while(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 8) != 0) {
                dummy = (dummy << 2) + dummy + (dummy << 2) + dummy + ( *( &MYCTYPE_DIGITMAP + ( *p & 0xff)) & 0xff);
                p =  &(p[1]);
            }
            if(( *p & 255) == 59) {
                p =  &(p[1]);
            }
             *str = p;
            return dummy;
        }
         *str = p;
        return -1;
    }
}

char* getescapecmd(char** s)
{// addr = 0x080B3089  --  defined in 'indep.c' at line 473
    char* save;                            // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    int ch;                                // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    save =  *s;
    ch = getescapechar(s);
    if(ch < 0) {
        if(( *save & 255) == 38) {
            tmp = Strnew();
        } else {
            tmp = Strnew_charp(135076339);
        }
        Strcat_charp_n(tmp, save,  *s - save);
        return tmp->ptr;
    }
    return conv_entity(ch);
}

char* html_quote(char* str)
{// addr = 0x080B3108  --  defined in 'indep.c' at line 491
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t59;                              // _t59

    tmp = 0;
    p = str;
    while(( *p & 255) != 0) {
        q =  *( &HTML_QUOTE_MAP + ( *( &QUOTE_MAP + ( *p & 0xff)) & 7) * 4);
        if(q == 0) {
            if(tmp != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t59 = tmp->length;
                 *((char*)(tmp->ptr + _t59)) =  *p & 255;
                tmp->length = _t59 + 1;
                 *((char*)(tmp->ptr + tmp->length)) = 0;
            }
        } else {
            if(tmp == 0) {
                tmp = Strnew_charp_n(str, p - str);
            }
            Strcat_charp(tmp, q);
        }
        p =  &(p[1]);
    }
    if(tmp == 0) {
        return str;
    }
    return tmp->ptr;
}

char* html_unquote(char* str)
{// addr = 0x080B31F7  --  defined in 'indep.c' at line 514
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t53;                              // _t53

    tmp = 0;
    p = str;
    while(( *p & 255) != 0) {
        if(( *p & 255) != 38) {
            if(tmp != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t53 = tmp->length;
                 *((char*)(tmp->ptr + _t53)) =  *p & 255;
                tmp->length = _t53 + 1;
                 *((char*)(tmp->ptr + tmp->length)) = 0;
            }
            p =  &(p[1]);
        } else {
            if(tmp == 0) {
                tmp = Strnew_charp_n(str, p - str);
            }
            q = getescapecmd( &p);
            Strcat_charp(tmp, q);
        }
    }
    if(tmp == 0) {
        return str;
    }
    return tmp->ptr;
}

char* url_quote(char* str)
{// addr = 0x080B32DF  --  defined in 'indep.c' at line 546
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t104;                             // _t104
    int _t117;                             // _t117
    int _t129;                             // _t129
    int _t141;                             // _t141

    tmp = 0;
    p = str;
    while(( *p & 255) != 0) {
        if(( *( &QUOTE_MAP + ( *p & 0xff)) & 0x10) == 0) {
            if(tmp != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t104 = tmp->length;
                 *((char*)(tmp->ptr + _t104)) =  *p & 255;
                tmp->length = _t104 + 1;
                 *((char*)(tmp->ptr + tmp->length)) = 0;
            }
        } else {
            if(tmp == 0) {
                tmp = Strnew_charp_n(str, p - str);
            }
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t117 = tmp->length;
             *((char*)(tmp->ptr + _t117)) = 37;
            tmp->length = _t117 + 1;
             *((char*)(tmp->ptr + tmp->length)) = 0;
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t129 = tmp->length;
             *((char*)(tmp->ptr + _t129)) =  *((( *p & 255) >> 4 & 255) + "0123456789ABCDEF") & 255;
            tmp->length = _t129 + 1;
             *((char*)(tmp->ptr + tmp->length)) = 0;
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t141 = tmp->length;
             *((char*)(tmp->ptr + _t141)) =  *(( *p & 0xf) + "0123456789ABCDEF") & 255;
            tmp->length = _t141 + 1;
             *((char*)(tmp->ptr + tmp->length)) = 0;
        }
        p =  &(p[1]);
    }
    if(tmp == 0) {
        return str;
    }
    return tmp->ptr;
}

char* file_quote(char* str)
{// addr = 0x080B34B7  --  defined in 'indep.c' at line 570
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char[3] buf;                           // _cfa_ffffffe8
    signed int _v36;                       // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    int _t58;                              // _t58

    tmp = 0;
    p = str;
    while(( *p & 255) != 0) {
        if(( *( &QUOTE_MAP + ( *p & 0xff)) & 0x30) == 0) {
            if(tmp != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t58 = tmp->length;
                 *((char*)(tmp->ptr + _t58)) =  *p & 255;
                tmp->length = _t58 + 1;
                 *((char*)(tmp->ptr + tmp->length)) = 0;
            }
        } else {
            if(tmp == 0) {
                tmp = Strnew_charp_n(str, p - str);
            }
            _v36 =  *p & 0xff;
            _v40 = "%%%02X";
             *__esp =  &buf;
            sprintf();
            Strcat_charp(tmp,  &buf);
        }
        p =  &(p[1]);
    }
    if(tmp == 0) {
        return str;
    }
    return tmp->ptr;
}

char* file_unquote(char* str)
{// addr = 0x080B35BB  --  defined in 'indep.c' at line 594
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    int c;                                 // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t82;                              // _t82
    signed int _t97;                       // _t97
    int _t105;                             // _t105

    tmp = 0;
    p = str;
    while(( *p & 255) != 0) {
        if(( *p & 255) != 37) {
L16:
            if(tmp != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t82 = tmp->length;
                 *((char*)(tmp->ptr + _t82)) =  *p & 255;
                tmp->length = _t82 + 1;
                 *((char*)(tmp->ptr + tmp->length)) = 0;
            }
            p =  &(p[1]);
            continue;
        }
        q = p;
        if(( *( &MYCTYPE_MAP + (q[1] & 0xff)) & 0x28) == 0) {
L5:
            _t97 = -1;
L6:
            c = _t97;
            if(c < 0) {
                goto L16;
            }
            if(tmp == 0) {
                tmp = Strnew_charp_n(str, p - str);
            }
            if(c != 0 && c != 10 && c != 13) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t105 = tmp->length;
                 *((char*)(tmp->ptr + _t105)) = c;
                tmp->length = _t105 + 1;
                 *((char*)(tmp->ptr + tmp->length)) = 0;
            }
            p = q;
            continue;
        }
        if(( *( &MYCTYPE_MAP + (q[2] & 0xff)) & 0x28) == 0) {
            goto L5;
        } else {
            q =  &(q[3]);
            _t97 =  *( &MYCTYPE_DIGITMAP + ( *(q - 1) & 0xff)) & 0xff | ( *( &MYCTYPE_DIGITMAP + ( *(q - 2) & 0xff)) & 0xff) << 4;
            goto L6;
        }
    }
    if(tmp == 0) {
        return str;
    }
    return tmp->ptr;
}

Str Str_form_quote(Str x)
{// addr = 0x080B3774  --  defined in 'indep.c' at line 623
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* ep;                              // _cfa_ffffffe8
    char[3] buf;                           // _cfa_ffffffe4
    signed int _v36;                       // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    int _t94;                              // _t94
    int _t118;                             // _t118

    tmp = 0;
    p = x->ptr;
    ep = x->ptr + x->length;
    while(p < ep) {
        if(( *p & 255) != 32) {
            if(( *( &QUOTE_MAP + ( *p & 0xff)) & 0x70) == 0) {
                if(tmp != 0) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t94 = tmp->length;
                     *((char*)(tmp->ptr + _t94)) =  *p & 255;
                    tmp->length = _t94 + 1;
                     *((char*)(tmp->ptr + tmp->length)) = 0;
                }
            } else {
                if(tmp == 0) {
                    tmp = Strnew_charp_n(x->ptr, p - x->ptr);
                }
                _v36 =  *p & 0xff;
                _v40 = "%%%02X";
                 *__esp =  &buf;
                sprintf();
                Strcat_charp(tmp,  &buf);
            }
L15:
            p =  &(p[1]);
            continue;
        }
        if(tmp == 0) {
            tmp = Strnew_charp_n(x->ptr, p - x->ptr);
        }
        if(tmp->length + 1 >= tmp->area_size) {
            Strgrow(tmp);
        }
        _t118 = tmp->length;
         *((char*)(tmp->ptr + _t118)) = 43;
        tmp->length = _t118 + 1;
         *((char*)(tmp->ptr + tmp->length)) = 0;
        goto L15;
    }
    if(tmp == 0) {
        return x;
    }
    return tmp;
}

Str Str_url_unquote(Str x, int is_form, int safe)
{// addr = 0x080B3905  --  defined in 'indep.c' at line 653
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* ep;                              // _cfa_ffffffe8
    char* q;                               // _cfa_ffffffe4
    int c;                                 // _cfa_ffffffe0
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    int _t121;                             // _t121
    int _t136;                             // _t136
    int _t143;                             // _t143
    int _t195;                             // _t195

    tmp = 0;
    p = x->ptr;
    ep = x->ptr + x->length;
    while(p < ep) {
        if(is_form == 0) {
L8:
            if(( *p & 255) != 37) {
L22:
                if(tmp != 0) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t121 = tmp->length;
                     *((char*)(tmp->ptr + _t121)) =  *p & 255;
                    tmp->length = _t121 + 1;
                     *((char*)(tmp->ptr + tmp->length)) = 0;
                }
                p =  &(p[1]);
                continue;
            }
            q = p;
            if(( *( &MYCTYPE_MAP + (q[1] & 0xff)) & 0x28) == 0 || ( *( &MYCTYPE_MAP + (q[2] & 0xff)) & 0x28) == 0) {
                _t136 = -1;
            } else {
                q =  &(q[3]);
                _t136 =  *( &MYCTYPE_DIGITMAP + ( *(q - 1) & 0xff)) & 0xff | ( *( &MYCTYPE_DIGITMAP + ( *(q - 2) & 0xff)) & 0xff) << 4;
            }
            c = _t136;
            if(c < 0 || safe != 0 && ( *( &MYCTYPE_MAP + (c & 255)) & 0x11) != 0 && ( *( &QUOTE_MAP + (c & 255)) & 0x30) != 0) {
                goto L22;
            } else {
                if(tmp == 0) {
                    tmp = Strnew_charp_n(x->ptr, p - x->ptr);
                }
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t143 = tmp->length;
                 *((char*)(tmp->ptr + _t143)) = c;
                tmp->length = _t143 + 1;
                 *((char*)(tmp->ptr + tmp->length)) = 0;
                p = q;
                continue;
            }
        }
        if(( *p & 255) != 43) {
            goto L8;
        } else {
            if(tmp == 0) {
                tmp = Strnew_charp_n(x->ptr, p - x->ptr);
            }
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t195 = tmp->length;
             *((char*)(tmp->ptr + _t195)) = 32;
            tmp->length = _t195 + 1;
             *((char*)(tmp->ptr + tmp->length)) = 0;
            p =  &(p[1]);
            continue;
        }
    }
    if(tmp == 0) {
        return x;
    }
    return tmp;
}

char* shell_quote(char* str)
{// addr = 0x080B3B7B  --  defined in 'indep.c' at line 688
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t85;                              // _t85
    int _t98;                              // _t98
    int _t110;                             // _t110

    tmp = 0;
    p = str;
    while(( *p & 255) != 0) {
        if(( *( &QUOTE_MAP + ( *p & 0xff)) & 8) == 0) {
            if(tmp != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t85 = tmp->length;
                 *((char*)(tmp->ptr + _t85)) =  *p & 255;
                tmp->length = _t85 + 1;
                 *((char*)(tmp->ptr + tmp->length)) = 0;
            }
        } else {
            if(tmp == 0) {
                tmp = Strnew_charp_n(str, p - str);
            }
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t98 = tmp->length;
             *((char*)(tmp->ptr + _t98)) = 92;
            tmp->length = _t98 + 1;
             *((char*)(tmp->ptr + tmp->length)) = 0;
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t110 = tmp->length;
             *((char*)(tmp->ptr + _t110)) =  *p & 255;
            tmp->length = _t110 + 1;
             *((char*)(tmp->ptr + tmp->length)) = 0;
        }
        p =  &(p[1]);
    }
    if(tmp == 0) {
        return str;
    }
    return tmp->ptr;
}

char* w3m_dir(const char* name, char* dft)
{// addr = 0x080B3CEA  --  defined in 'indep.c' at line 711
    return dft;
}

char* w3m_auxbin_dir()
{// addr = 0x080B3CF2  --  defined in 'indep.c' at line 722
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)

    return w3m_dir("W3M_AUXBIN_DIR", "/usr/lib/w3m");
}

char* w3m_lib_dir()
{// addr = 0x080B3D0E  --  defined in 'indep.c' at line 728
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)

    return w3m_dir("W3M_LIB_DIR", "/usr/lib/w3m/cgi-bin");
}

char* w3m_etc_dir()
{// addr = 0x080B3D2A  --  defined in 'indep.c' at line 735
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)

    return w3m_dir("W3M_ETC_DIR", "/etc");
}

char* w3m_conf_dir()
{// addr = 0x080B3D46  --  defined in 'indep.c' at line 741
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)

    return w3m_dir("W3M_CONF_DIR", "/etc/w3m");
}

char* w3m_help_dir()
{// addr = 0x080B3D62  --  defined in 'indep.c' at line 747
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)

    return w3m_dir("W3M_HELP_DIR", "/usr/share/w3m");
}

ListItem* newListItem(_Unknown_base* s, ListItem* n, ListItem* p)
{// addr = 0x080B3D80  --  defined in 'textlist.c' at line 10
    ListItem* it;     // _cfa_fffffff0

     *__esp = 12;
    GC_malloc();
    it = __eax;
    it->ptr = s;
    it->next = n;
    it->prev = p;
    return it;
}

GeneralList* newGeneralList()
{// addr = 0x080B3DB4  --  defined in 'textlist.c' at line 21
    GeneralList* tl;   // _cfa_fffffff0

     *__esp = 12;
    GC_malloc();
    tl = __eax;
    tl->last = 0;
    tl->first = tl->last;
    tl->nitem = 0;
    return tl;
}

void pushValue(GeneralList* tl, _Unknown_base* s)
{// addr = 0x080B3DEC  --  defined in 'textlist.c' at line 30
    ListItem* it;     // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(s != 0) {
        it = newListItem(s, 0, tl->last);
        if(tl->first != 0) {
             *(tl->last + 4) = it;
            tl->last = it;
            tl->nitem = (tl->nitem & 65535) + 1;
            return;
        }
        tl->first = it;
        tl->last = it;
        tl->nitem = 1;
        return;
    }
}

_Unknown_base* popValue(GeneralList* tl)
{// addr = 0x080B3E68  --  defined in 'textlist.c' at line 49
    ListItem* f;      // _cfa_fffffff8

    if(tl == 0 || tl->first == 0) {
        return 0;
    } else {
        f = tl->first;
        tl->first = f->next;
        if(tl->first == 0) {
            tl->last = 0;
        } else {
            tl->first->prev = 0;
        }
        tl->nitem = (tl->nitem & 65535) - 1;
        return f->ptr;
    }
}

_Unknown_base* rpopValue(GeneralList* tl)
{// addr = 0x080B3ED0  --  defined in 'textlist.c' at line 66
    ListItem* f;      // _cfa_fffffff8

    if(tl == 0 || tl->last == 0) {
        return 0;
    } else {
        f = tl->last;
        tl->last = f->prev;
        if(tl->last == 0) {
            tl->first = 0;
        } else {
             *(tl->last + 4) = 0;
        }
        tl->nitem = (tl->nitem & 65535) - 1;
        return f->ptr;
    }
}

void delValue(GeneralList* tl, ListItem* it)
{// addr = 0x080B3F3C  --  defined in 'textlist.c' at line 83
    if(it->prev == 0) {
        tl->first = it->next;
    } else {
        it->prev->next = it->next;
    }
    if(it->next == 0) {
        tl->last = it->prev;
    } else {
        it->next->prev = it->prev;
    }
    tl->nitem = (tl->nitem & 65535) - 1;
}

GeneralList* appendGeneralList(GeneralList* tl, GeneralList* tl2)
{// addr = 0x080B3F9F  --  defined in 'textlist.c' at line 97
    if(tl == 0 || tl2 == 0) {
L7:
        return tl;
    } else {
        if(tl2->first != 0) {
            if(tl->last == 0) {
                tl->first = tl2->first;
                tl->last = tl2->last;
                tl->nitem = tl2->nitem & 65535;
            } else {
                 *(tl->last + 4) = tl2->first;
                tl2->first->prev = tl->last;
                tl->last = tl2->last;
                tl->nitem = (tl->nitem & 65535) + (tl2->nitem & 65535);
            }
        }
        tl2->last = 0;
        tl2->first = tl2->last;
        tl2->nitem = 0;
        goto L7;
    }
}

TextLine* newTextLine(Str line, int pos)
{// addr = 0x080B4056  --  defined in 'textlist.c' at line 124
    TextLine* lbuf;   // _cfa_fffffff0

     *__esp = 8;
    GC_malloc();
    lbuf = __eax;
    if(line == 0) {
        lbuf->line = Strnew();
    } else {
        lbuf->line = line;
    }
    lbuf->pos = pos;
    return lbuf;
}

void appendTextLine(TextLineList* tl, Str line, int pos)
{// addr = 0x080B4096  --  defined in 'textlist.c' at line 136
    TextLine* lbuf;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(tl->last != 0) {
        lbuf = tl->last->ptr;
        if(lbuf->line == 0) {
            lbuf->line = line;
        } else {
            Strcat(lbuf->line, line);
        }
        lbuf->pos = (lbuf->pos & 65535) + pos;
        return;
    }
    pushValue(tl, newTextLine(Strdup(line), pos));
}

char* tag_get_value(struct parsed_tagarg* t, char* arg)
{// addr = 0x080B4120  --  defined in 'parsetag.c' at line 8
    char* _v24;                            // _cfa_ffffffe8
    char* _t11;                            // _t11

    while(t != 0) {
        _t11 = t->arg;
        _v24 = arg;
         *__esp = _t11;
        strcasecmp();
        if(_t11 != 0) {
            t = t->next;
            continue;
        }
        return t->value;
    }
    return 0;
}

int tag_exists(struct parsed_tagarg* t, char* arg)
{// addr = 0x080B415E  --  defined in 'parsetag.c' at line 18
    char* _v24;                            // _cfa_ffffffe8
    char* _t9;                             // _t9

    while(t != 0) {
        _t9 = t->arg;
        _v24 = arg;
         *__esp = _t9;
        strcasecmp();
        if(_t9 != 0) {
            t = t->next;
            continue;
        }
        return 1;
    }
    return 0;
}

struct parsed_tagarg* cgistr2tagarg(char* cgistr)
{// addr = 0x080B419B  --  defined in 'parsetag.c' at line 28
    Str tag;               // _cfa_fffffff0
    Str value;             // _cfa_ffffffec
    struct parsed_tagarg* t0;   // _cfa_ffffffe8
    struct parsed_tagarg* t;   // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    signed int _t76;                       // _t76
    int _t108;                             // _t108
    _unknown_ _t126;                       // _t126

    t0 = 0;
    _t76 = t0;
    t = _t76;
    do {
         *__esp = 12;
        GC_malloc();
        t = _t76;
        t->next = t0;
        t0 = t;
        tag = Strnew();
        do {
        } while(( *cgistr & 255) != 0 && ( *cgistr & 255) != 61 && ( *cgistr & 255) != 38);
        t->arg =  *(Str_url_unquote(tag, 1, 0));
        t->value = 0;
        if(( *cgistr & 255) != 0) {
            if(( *cgistr & 255) != 61) {
                if(( *cgistr & 255) == 38) {
                    cgistr =  &(cgistr[1]);
                }
                goto L20;
            }
            cgistr =  &(cgistr[1]);
            value = Strnew();
            while(( *cgistr & 255) != 0 && ( *cgistr & 255) != 38) {
                if(value->length + 1 >= value->area_size) {
                    Strgrow(value);
                }
                _t108 = value->length;
                 *((char*)(value->ptr + _t108)) =  *cgistr & 255;
                value->length = _t108 + 1;
                cgistr =  &(cgistr[1]);
                 *((char*)(value->ptr + value->length)) = 0;
            }
            t->value =  *(Str_url_unquote(value, 1, 0));
            goto L20;
        }
        return t;
L20:
        _t76 =  *cgistr & 255;
    } while(_t76 != 0);
    return t;
}

unsigned int hashfunc(char* s)
{// addr = 0x080B4350  --  defined in 'hash.c' at line 7
    unsigned int h;                        // _cfa_fffffff8

    h = 0;
    while(( *s & 255) != 0) {
        if(h >= 0) {
            h = h << 1;
        } else {
            h = h << 1;
            h = h | 1;
        }
        h = h + ( *s & 255);
        s =  &(s[1]);
    }
    return h;
}

Hash_si* newHash_si(int size)
{// addr = 0x080B4391  --  defined in 'hash.c' at line 26
    struct Hash_si* hash;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    struct HashItem_si** _t19;   // _t19

     *__esp = 8;
    GC_malloc();
    hash = __eax;
    hash->size = size;
    _t19 = size << 2;
     *__esp = _t19;
    GC_malloc();
    hash->tab = _t19;
    i = 0;
    while(i < size) {
        hash->tab[i] = 0;
        i = i + 1;
    }
    return hash;
}

HashItem_si* lookupHash_si(Hash_si* t, char* key, int* hashval_return)
{// addr = 0x080B43F2  --  defined in 'hash.c' at line 26
    HashItem_si* hi;   // _cfa_fffffff0
    char* _v40;                            // _cfa_ffffffd8
    char* _t33;                            // _t33

     *hashval_return = hashfunc(key) % t->size;
    hi = t->tab[ *hashval_return];
    while(hi != 0) {
        _t33 = hi->key;
        _v40 = key;
         *__esp = _t33;
        strcmp();
        if(_t33 != 0) {
            hi = hi->next;
            continue;
        }
        return hi;
    }
    return 0;
}

void putHash_si(Hash_si* t, char* key, int value)
{// addr = 0x080B4465  --  defined in 'hash.c' at line 26
    int h;                                 // _cfa_fffffff0
    HashItem_si* hi;   // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    HashItem_si* _t30;   // _t30
    signed int _t47;                       // _t47

    _t30 = lookupHash_si(t, key,  &h);
    hi = _t30;
    __eflags = hi;
    if(__eflags == 0) {
         *__esp = 12;
        GC_malloc();
        hi = _t30;
        hi->key = key;
        hi->value = value;
        hi->next = t->tab[h];
        _t47 = h << 2;
        __eflags = _t47;
         *(t->tab + _t47) = hi;
        return;
    }
    hi->value = value;
}

int getHash_si(Hash_si* t, char* key, int failval)
{// addr = 0x080B44E4  --  defined in 'hash.c' at line 26
    int h;                                 // _cfa_fffffff0
    HashItem_si* hi;   // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    hi = lookupHash_si(t, key,  &h);
    if(hi != 0) {
        return hi->value;
    }
    return failval;
}

Hash_ss* newHash_ss(int size)
{// addr = 0x080B4519  --  defined in 'hash.c' at line 27
    struct Hash_ss* hash;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    struct HashItem_ss** _t19;   // _t19

     *__esp = 8;
    GC_malloc();
    hash = __eax;
    hash->size = size;
    _t19 = size << 2;
     *__esp = _t19;
    GC_malloc();
    hash->tab = _t19;
    i = 0;
    while(i < size) {
        hash->tab[i] = 0;
        i = i + 1;
    }
    return hash;
}

HashItem_ss* lookupHash_ss(Hash_ss* t, char* key, int* hashval_return)
{// addr = 0x080B457A  --  defined in 'hash.c' at line 27
    HashItem_ss* hi;   // _cfa_fffffff0
    char* _v40;                            // _cfa_ffffffd8
    char* _t33;                            // _t33

     *hashval_return = hashfunc(key) % t->size;
    hi = t->tab[ *hashval_return];
    while(hi != 0) {
        _t33 = hi->key;
        _v40 = key;
         *__esp = _t33;
        strcmp();
        if(_t33 != 0) {
            hi = hi->next;
            continue;
        }
        return hi;
    }
    return 0;
}

void putHash_ss(Hash_ss* t, char* key, char* value)
{// addr = 0x080B45ED  --  defined in 'hash.c' at line 27
    int h;                                 // _cfa_fffffff0
    HashItem_ss* hi;   // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    HashItem_ss* _t30;   // _t30
    signed int _t47;                       // _t47

    _t30 = lookupHash_ss(t, key,  &h);
    hi = _t30;
    __eflags = hi;
    if(__eflags == 0) {
         *__esp = 12;
        GC_malloc();
        hi = _t30;
        hi->key = key;
        hi->value = value;
        hi->next = t->tab[h];
        _t47 = h << 2;
        __eflags = _t47;
         *(t->tab + _t47) = hi;
        return;
    }
    hi->value = value;
}

char* getHash_ss(Hash_ss* t, char* key, char* failval)
{// addr = 0x080B466C  --  defined in 'hash.c' at line 27
    int h;                                 // _cfa_fffffff0
    HashItem_ss* hi;   // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    hi = lookupHash_ss(t, key,  &h);
    if(hi != 0) {
        return hi->value;
    }
    return failval;
}

Hash_sv* newHash_sv(int size)
{// addr = 0x080B46A1  --  defined in 'hash.c' at line 28
    struct Hash_sv* hash;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    struct HashItem_sv** _t19;   // _t19

     *__esp = 8;
    GC_malloc();
    hash = __eax;
    hash->size = size;
    _t19 = size << 2;
     *__esp = _t19;
    GC_malloc();
    hash->tab = _t19;
    i = 0;
    while(i < size) {
        hash->tab[i] = 0;
        i = i + 1;
    }
    return hash;
}

HashItem_sv* lookupHash_sv(Hash_sv* t, char* key, int* hashval_return)
{// addr = 0x080B4702  --  defined in 'hash.c' at line 28
    HashItem_sv* hi;   // _cfa_fffffff0
    char* _v40;                            // _cfa_ffffffd8
    char* _t33;                            // _t33

     *hashval_return = hashfunc(key) % t->size;
    hi = t->tab[ *hashval_return];
    while(hi != 0) {
        _t33 = hi->key;
        _v40 = key;
         *__esp = _t33;
        strcmp();
        if(_t33 != 0) {
            hi = hi->next;
            continue;
        }
        return hi;
    }
    return 0;
}

void putHash_sv(Hash_sv* t, char* key, _Unknown_base* value)
{// addr = 0x080B4775  --  defined in 'hash.c' at line 28
    int h;                                 // _cfa_fffffff0
    HashItem_sv* hi;   // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    HashItem_sv* _t30;   // _t30
    signed int _t47;                       // _t47

    _t30 = lookupHash_sv(t, key,  &h);
    hi = _t30;
    __eflags = hi;
    if(__eflags == 0) {
         *__esp = 12;
        GC_malloc();
        hi = _t30;
        hi->key = key;
        hi->value = value;
        hi->next = t->tab[h];
        _t47 = h << 2;
        __eflags = _t47;
         *(t->tab + _t47) = hi;
        return;
    }
    hi->value = value;
}

_Unknown_base* getHash_sv(Hash_sv* t, char* key, _Unknown_base* failval)
{// addr = 0x080B47F4  --  defined in 'hash.c' at line 28
    int h;                                 // _cfa_fffffff0
    HashItem_sv* hi;   // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    hi = lookupHash_sv(t, key,  &h);
    if(hi != 0) {
        return hi->value;
    }
    return failval;
}

Hash_iv* newHash_iv(int size)
{// addr = 0x080B4829  --  defined in 'hash.c' at line 29
    struct Hash_iv* hash;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    struct HashItem_iv** _t19;   // _t19

     *__esp = 8;
    GC_malloc();
    hash = __eax;
    hash->size = size;
    _t19 = size << 2;
     *__esp = _t19;
    GC_malloc();
    hash->tab = _t19;
    i = 0;
    while(i < size) {
        hash->tab[i] = 0;
        i = i + 1;
    }
    return hash;
}

HashItem_iv* lookupHash_iv(Hash_iv* t, int key, int* hashval_return)
{// addr = 0x080B488A  --  defined in 'hash.c' at line 29
    HashItem_iv* hi;   // _cfa_fffffff8

     *hashval_return = key % t->size;
    hi = t->tab[ *hashval_return];
    while(hi != 0) {
        if(hi->key != key) {
            hi = hi->next;
            continue;
        }
        return hi;
    }
    return 0;
}

void putHash_iv(Hash_iv* t, int key, _Unknown_base* value)
{// addr = 0x080B48E1  --  defined in 'hash.c' at line 29
    int h;                                 // _cfa_fffffff0
    HashItem_iv* hi;   // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    HashItem_iv* _t30;   // _t30
    signed int _t47;                       // _t47

    _t30 = lookupHash_iv(t, key,  &h);
    hi = _t30;
    __eflags = hi;
    if(__eflags == 0) {
         *__esp = 12;
        GC_malloc();
        hi = _t30;
        hi->key = key;
        hi->value = value;
        hi->next = t->tab[h];
        _t47 = h << 2;
        __eflags = _t47;
         *(t->tab + _t47) = hi;
        return;
    }
    hi->value = value;
}

_Unknown_base* getHash_iv(Hash_iv* t, int key, _Unknown_base* failval)
{// addr = 0x080B4960  --  defined in 'hash.c' at line 29
    int h;                                 // _cfa_fffffff8
    HashItem_iv* hi;   // _cfa_fffffff4
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)

    hi = lookupHash_iv(t, key,  &h);
    if(hi != 0) {
        return hi->value;
    }
    return failval;
}

void wc_char_conv_init(wc_ces f_ces, wc_ces t_ces)
{// addr = 0x080B4998  --  defined in 'char_conv.c' at line 8
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    wc_input_init(f_ces,  &char_conv_st);
     *135789960 = -1;
    char_conv_f_ces = f_ces;
    char_conv_t_ces = t_ces;
}

Str wc_char_conv(char c)
{// addr = 0x080B49CD  --  defined in 'char_conv.c' at line 17
    signed char _v16;                      // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    struct * _v40;            // _cfa_ffffffd8 (outparam)
    struct _Str* _t11;    // _t11

    _v16 = c;
    _t11 = _v16 & 0xff;
    _v40 =  &char_conv_st;
     *__esp = _t11;
     *((intOrPtr*)( *((intOrPtr*)(char_conv_st.auto_detect + 28))))();
    wc_Str_conv(_t11, 3211264, char_conv_t_ces);
    return _t11;
}

wc_ces wc_guess_charset(char* charset, wc_ces orig)
{// addr = 0x080B4A18  --  defined in 'charset.c' at line 36
    wc_ces guess;       // _cfa_fffffff0

    if(charset == 0 || ( *charset & 255) == 0) {
        return orig;
    } else {
        guess = wc_charset_to_ces(charset);
        if(guess == 0) {
            return orig;
        }
        return guess;
    }
}

wc_ces wc_guess_charset_short(char* charset, wc_ces orig)
{// addr = 0x080B4A51  --  defined in 'charset.c' at line 47
    wc_ces guess;       // _cfa_fffffff0

    if(charset == 0 || ( *charset & 255) == 0) {
        return orig;
    } else {
        guess = wc_charset_short_to_ces(charset);
        if(guess == 0) {
            return orig;
        }
        return guess;
    }
}

wc_ces wc_guess_locale_charset(char* locale, wc_ces orig)
{// addr = 0x080B4A8A  --  defined in 'charset.c' at line 58
    wc_ces guess;       // _cfa_fffffff0

    if(locale == 0 || ( *locale & 255) == 0) {
        return orig;
    } else {
        guess = wc_locale_to_ces(locale);
        if(guess == 0) {
            return orig;
        }
        return guess;
    }
}

wc_ces wc_charset_to_ces(char* charset)
{// addr = 0x080B4AC3  --  defined in 'charset.c' at line 69
    signed int _v16;                       // _cfa_fffffff0
    char[15] buf;                          // _cfa_ffffffe0
    char* p;                               // _cfa_ffffffdc
    int n;                                 // _cfa_ffffffd8
    char* _v48;                            // _cfa_ffffffd0
    signed int _t39;                       // _t39
    signed int _t58;                       // _t58

    _v48 = charset;
    _v16 =  *gs:0x14];
    p = _v48;
    _t39 =  *p & 255;
     *__esp = _t39;
    tolower();
    if(_t39 == 120) {
        if((p[1] & 255) == 45) {
            p =  &(p[2]);
        }
    }
    n = 0;
    while(( *p & 255) != 0 && n <= 14) {
        if(( *p & 255) > 32 && ( *p & 255) != 95 && ( *p & 255) != 45) {
            _t58 =  *p & 255;
             *__esp = _t58;
            tolower();
             *((char*)(__ebp + n - 28)) = _t58;
            n = n + 1;
        }
        p =  &(p[1]);
    }
     *((char*)(__ebp + n - 28)) = 0;
    p =  &buf;
    if(( *p & 255) - 97 > 22) {
        if((_v16 ^  *gs:0x14]) == 0) {
            return 0;
        }
        __stack_chk_fail();
        return 0;
    }
    goto __eax;
}

wc_ces wc_charset_short_to_ces(char* charset)
{// addr = 0x080B568A  --  defined in 'charset.c' at line 271
    signed int _v16;                       // _cfa_fffffff0
    char[15] buf;                          // _cfa_ffffffe0
    char* p;                               // _cfa_ffffffdc
    wc_ces ces;         // _cfa_ffffffd8
    int n;                                 // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    unsigned int _t47;                     // _t47
    signed int _t57;                       // _t57

    _v48 = charset;
    _v16 =  *gs:0x14];
    p = _v48;
    ces = wc_charset_to_ces(_v48);
    if(ces == 0) {
        n = 0;
        while(( *p & 255) != 0 && n <= 14) {
            if(( *p & 255) > 32 && ( *p & 255) != 95 && ( *p & 255) != 45) {
                _t57 =  *p & 255;
                 *__esp = _t57;
                tolower();
                 *((char*)(__ebp + n - 28)) = _t57;
                n = n + 1;
            }
            p =  &(p[1]);
        }
         *((char*)(__ebp + n - 28)) = 0;
        p =  &buf;
        if(( *p & 255) - 97 > 22) {
            _t47 = 0;
            goto L13;
        }
        goto __eax;
    } else {
        _t47 = ces;
L13:
        if((_v16 ^  *gs:0x14]) == 0) {
            return _t47;
        }
        __stack_chk_fail();
        return _t47;
    }
}

wc_ces wc_locale_to_ces(char* locale)
{// addr = 0x080B5999  --  defined in 'charset.c' at line 368
    char* p;                               // _cfa_fffffff0
    int n;                                 // _cfa_ffffffec
    char* cs;                              // _cfa_ffffffe8
    char[5] buf;                           // _cfa_ffffffe2
    intOrPtr _v52;                         // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    signed int _t60;                       // _t60
    char* _t79;                            // _t79
    signed int _t83;                       // _t83
    _unknown_ _t92;                        // _t92
    char* _t93;                            // _t93

    p = locale;
    _t60 =  *p & 255;
    if(_t60 != 67) {
L3:
         *__esp = 14;
        nl_langinfo();
        cs = _t60;
        if(cs != 0) {
            _v56 = "US-ASCII";
            _t93 = cs;
             *__esp = _t93;
            strcmp();
            if(_t93 == 0) {
                goto L6;
            } else {
                return wc_charset_to_ces(cs);
            }
        }
L6:
        n = 0;
        do {
        } while(( *p & 255) != 0 && ( *p & 255) != 46 && n <= 4);
         *((char*)(__ebp + n - 26)) = 0;
        if(( *p & 255) != 46) {
            _v56 = "japanese";
             *__esp =  &buf;
            strcmp();
            if( &buf != 0) {
                _v56 = "zh_tw";
                 *__esp =  &buf;
                strcmp();
                if( &buf == 0) {
L31:
                    return 3153981;
                }
                _v56 = "zh_hk";
                 *__esp =  &buf;
                strcmp();
                if( &buf != 0) {
                    n = 0;
                    while( *((intOrPtr*)( &lang_ces_table + n * 8)) != 0) {
                        _v52 = 2;
                        _v56 =  *((intOrPtr*)( &lang_ces_table + n * 8));
                         *__esp =  &buf;
                        strncmp();
                        if( &buf != 0) {
                            n = n + 1;
                            continue;
                        }
                        return  *(135117092 + n * 8);
                    }
                    return 1049089;
                }
                goto L31;
            }
            return 3153976;
        }
        p =  &(p[1]);
        _v56 = "euc";
        _t79 = p;
         *__esp = _t79;
        strcasecmp();
        if(_t79 == 0) {
            _t83 = buf & 255;
            if(_t83 == 107) {
                WcLocale = 5;
            } else {
                if(_t83 == 122) {
                    _v56 = "zh_tw";
                     *__esp =  &buf;
                    strcmp();
                    if( &buf != 0) {
                        _v56 = "zh_hk";
                         *__esp =  &buf;
                        strcmp();
                        if( &buf != 0) {
                            WcLocale = 2;
                        } else {
                            WcLocale = 4;
                        }
                    } else {
                        WcLocale = 3;
                    }
                } else {
                    if(_t83 != 106) {
                        WcLocale = 0;
                    } else {
                        WcLocale = 1;
                    }
                }
            }
        }
        return wc_charset_to_ces(p);
    } else {
        _t60 = p[1] & 255;
        if(_t60 != 0) {
            goto L3;
        } else {
            return 256;
        }
    }
}

char* wc_ces_to_charset(wc_ces ces)
{// addr = 0x080B5BCC  --  defined in 'charset.c' at line 427
    if(ces != 3211264) {
        return  *(((ces & 255) << 5) + 135767972);
    }
    return "WTF";
}

char* wc_ces_to_charset_desc(wc_ces ces)
{// addr = 0x080B5BF2  --  defined in 'charset.c' at line 435
    if(ces != 3211264) {
        return  *(((ces & 255) << 5) + 135767976);
    }
    return "W3M Transfer Format";
}

wc_ces wc_guess_8bit_charset(wc_ces orig)
{// addr = 0x080B5C18  --  defined in 'charset.c' at line 443
    unsigned int _t3;                      // _t3

    _t3 = orig;
    if(_t3 > 2099219) {
        if(_t3 == 2099221) {
            return 3149849;
        }
        if(_t3 < 2099221 || _t3 == 2105404) {
            return 3149847;
        } else {
L12:
            return orig;
        }
    }
    if(_t3 >= 2099217) {
        return 3149846;
    }
    if(_t3 == 256) {
        return 1049089;
    }
    goto L12;
}

wc_bool wc_check_ces(wc_ces ces)
{// addr = 0x080B5C6D  --  defined in 'charset.c' at line 462
    size_t i;           // _cfa_fffffff8

    i = ces & 255;
    if(i > 70 ||  *((intOrPtr*)( &WcCesInfo + (i << 5))) != ces) {
        return 0;
    } else {
        return 1;
    }
}

int wc_ces_list_cmp(* a, * b)
{// addr = 0x080B5CA3  --  defined in 'charset.c' at line 470
    intOrPtr _v24;                         // _cfa_ffffffe8
    int _t8;                               // _t8

    _t8 =  *(a + 8);
    _v24 =  *((intOrPtr*)(b + 8));
     *__esp = _t8;
    strcasecmp();
    return _t8;
}

wc_ces_list* wc_get_ces_list()
{// addr = 0x080B5CC3  --  defined in 'charset.c' at line 478
    wc_ces_info* info;   // _cfa_fffffff0
    size_t n;           // _cfa_ffffffec
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    signed int _t55;                       // _t55

    if(list == 0) {
        info =  &WcCesInfo;
        n = 0;
        while(info->id != 0) {
            if(info->name != 0) {
                n = n + 1;
            }
            info = info + 32;
        }
        _t55 = n + 1 + n + 1 + _t102 << 2;
         *__esp = _t55;
        GC_malloc();
        list = _t55;
        info =  &WcCesInfo;
        n = 0;
        while(info->id != 0) {
            if(info->name != 0) {
                 *(list + (n + n + _t107 << 2)) = info->id;
                 *(list + (n + n + _t109 << 2) + 4) = info->name;
                 *(list + (n + n + _t111 << 2) + 8) = info->desc;
                n = n + 1;
            }
            info = info + 32;
        }
         *(list + (n + n + _t103 << 2)) = 0;
         *(list + (n + n + _t104 << 2) + 4) = 0;
         *(list + (n + n + _t105 << 2) + 8) = 0;
        _v32 = wc_ces_list_cmp;
        _v36 = 12;
        _v40 = n;
         *__esp = list;
        qsort();
        return list;
    }
    return list;
}

Str wc_Str_conv(Str is, wc_ces f_ces, wc_ces t_ces)
{// addr = 0x080B5E24  --  defined in 'conv.c' at line 18
    unsigned int _v24;                     // _cfa_ffffffe8
    struct _Str* _t15;    // _t15
    struct _Str* _t22;    // _t22

    if(f_ces != 3211264) {
        _v24 = f_ces;
        _t22 = is;
         *__esp = _t22;
         *((intOrPtr*)( *((intOrPtr*)(((f_ces & 255) + (f_ces & 255) + 1 << 4) + 135767972))))();
        is = _t22;
    }
    if(t_ces == 3211264) {
        return is;
    } else {
        _v24 = t_ces;
        _t15 = is;
         *__esp = _t15;
        wc_conv_to_ces();
        return _t15;
    }
}

Str wc_Str_conv_strict(Str is, wc_ces f_ces, wc_ces t_ces)
{// addr = 0x080B5E7D  --  defined in 'conv.c' at line 29
    Str os;                // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    wc_option opt;   // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    opt.auto_detect = WcOption.auto_detect;
    _v28 =  *135119012;
    _v24 =  *135119016;
    _v20 =  *135119020;
     *135119020 = 1;
     *135119022 = 1;
     *135119013 = 0;
    os = wc_Str_conv(is, f_ces, t_ces);
    WcOption.auto_detect = opt.auto_detect;
     *135119012 = _v28;
     *135119016 = _v24;
     *135119020 = _v20;
    return os;
}

Str wc_conv_to_ces(Str is, wc_ces ces)
{// addr = 0x080B5EF9  --  defined in 'conv.c' at line 43
    _unknown_ _v8;                         // _cfa_fffffff8
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    wc_uchar** _v32;   // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    wc_uchar** _v40;   // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    wc_status st;    // _cfa_ffffff98
    struct * _v116;           // _cfa_ffffff8c (outparam)
    wc_uchar** _v120;   // _cfa_ffffff88 (outparam)
    wc_uchar* _v124;   // _cfa_ffffff84 (outparam)
    unsigned int _t113;                    // _t113
    unsigned int _t124;                    // _t124
    struct _Str* _t133;   // _t133
    int _t153;                             // _t153

    _push(__ebx);
    __esp = __esp - 116;
    sp = is->ptr;
    ep = sp + is->length;
    _t113 = ces;
    if(_t113 < 1066050) {
L15:
        p = sp;
        while(p < ep) {
            if(( *p & 255) >= 0) {
                p =  &(p[1]);
                continue;
            }
            break;
        }
L24:
        if(p != ep) {
            os = Strnew_size(is->length);
            if(p > sp) {
                p = p - 1;
            }
            if(p > sp) {
                Strcat_charp_n(os, is->ptr, p - sp);
            }
            wc_output_init(ces,  &st);
            _t124 = ces;
            if(_t124 > 2099221) {
                if(_t124 == 2129990) {
                    goto L43;
                }
                if(_t124 == 3178565) {
                    goto L43;
                }
                if(_t124 == 2105404) {
                    goto L43;
                }
                goto L52;
            } else {
                if(_t124 >= 2099217) {
L43:
                    while(p < ep) {
                        _v120 =  &p;
                        wtf_parse( &_v36);
                        __esp = __esp - 4;
                        _v116 =  &st;
                        _v124 = _v36;
                        _v120 = _v32;
                         *__esp = os;
                         *((intOrPtr*)( *((intOrPtr*)(st.auto_detect + 24))))();
                    }
L53:
                    wc_push_end(os,  &st);
                    _t133 = os;
L54:
                    return _t133;
                }
                if(_t124 - 1066050 > 2) {
L52:
                    while(p < ep) {
                        if(( *p & 255) < 0 || ( *( &WTF_WIDTH_MAP + (p[1] & 0xff)) & 255) == 0) {
                            _v120 =  &p;
                            wtf_parse( &_v44);
                            __esp = __esp - 4;
                            _v116 =  &st;
                            _v124 = _v44;
                            _v120 = _v40;
                             *__esp = os;
                             *((intOrPtr*)( *((intOrPtr*)(st.auto_detect + 24))))();
                        } else {
                            if(os->length + 1 >= os->area_size) {
                                Strgrow(os);
                            }
                            _t153 = os->length;
                             *((char*)(os->ptr + _t153)) =  *p & 255;
                            os->length = _t153 + 1;
                             *((char*)(os->ptr + os->length)) = 0;
                            p =  &(p[1]);
                        }
                    }
                    goto L53;
                }
                goto L43;
            }
        }
        _t133 = is;
        goto L54;
    }
    if(_t113 <= 1066052) {
        p = sp;
        while(p < ep) {
            if(( *p & 255) <= 31) {
                goto L24;
            }
            if(( *p & 255) >= 0) {
                p =  &(p[1]);
                continue;
            }
            goto L24;
        }
        goto L24;
    }
    if(_t113 != 2105404) {
        goto L15;
    } else {
        p = sp;
        while(p < ep) {
            if(( *p & 255) == 126) {
                goto L24;
            }
            if(( *p & 255) >= 0) {
                p =  &(p[1]);
                continue;
            }
            goto L24;
        }
        goto L24;
    }
}

Str wc_Str_conv_with_detect(Str is, wc_ces* f_ces, wc_ces hint, wc_ces t_ces)
{// addr = 0x080B618F  --  defined in 'conv.c' at line 112
    wc_ces detect;      // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if( *f_ces != 3211264 && hint != 3211264) {
        if((WcOption.auto_detect & 255) != 0) {
            if(( *f_ces & 1048576) != 0) {
                hint =  *f_ces;
            }
            detect = wc_auto_detect(is->ptr, is->length, hint);
            if((WcOption.auto_detect & 255) != 2) {
                if((detect & 2048) != 0 && ( *f_ces & 1048576) == 0) {
                     *f_ces = detect;
                }
            } else {
                if((detect & 1048576) != 0 || (detect & 130560) != 0 && ( *f_ces & 1048576) == 0) {
                     *f_ces = detect;
                }
            }
        } else {
             *f_ces = hint;
            detect = hint;
        }
    } else {
         *f_ces = 3211264;
        detect = 3211264;
    }
    return wc_Str_conv(is, detect, t_ces);
}

void wc_push_end(Str os, wc_status* st)
{// addr = 0x080B628E  --  defined in 'conv.c' at line 139
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if((st->ces_info->id & 2048) != 0) {
        wc_push_to_iso2022_end(os, st);
        return;
    }
    if(st->ces_info->id == 2105404) {
        wc_push_to_hz_end(os, st);
        return;
    }
    if(st->ces_info->id == 3178565) {
        wc_push_to_utf8_end(os, st);
        return;
    }
    if(st->ces_info->id == 2129990) {
        wc_push_to_utf7_end(os, st);
        return;
    }
}

void wc_create_detect_map(wc_ces ces, wc_bool esc)
{// addr = 0x080B6320  --  defined in 'detect.c' at line 41
    int i;                                 // _cfa_fffffff8
    wc_uint8* map;    // _cfa_fffffff4
    char _v24;                             // _cfa_ffffffe8
    int _t31;                              // _t31
    unsigned int _t40;                     // _t40

    _v24 = esc;
    if(ces == detect_ces) {
L17:
        if(_v24 != 0 || (ces & 2048) != 0) {
            _t31 = 1;
        } else {
            _t31 = 0;
        }
         *135117243 = _t31;
        return;
    }
    if((ces & 16384) == 0) {
        i = 0;
        while(i <= 31) {
             *((char*)( &WC_DETECT_MAP + i)) = 0;
            i = i + 1;
        }
         *135117342 = ces == 2105404;
         *135117259 = ces == 2129990;
L16:
        detect_ces = ces;
        goto L17;
    }
    map = 0;
    _t40 = ces;
    if(_t40 == 1066051) {
        map =  &wc_c0_viscii112_map;
    } else {
        if(_t40 == 1066052) {
            map =  &wc_c0_vps2_map;
        } else {
            if(_t40 == 1066050) {
                map =  &wc_c0_tcvn57122_map;
            }
        }
    }
    i = 0;
    while(i <= 31) {
         *((char*)( &WC_DETECT_MAP + i)) = ( *(map + i) & 255) != 0;
        i = i + 1;
    }
    goto L16;
}

wc_ces wc_auto_detect(char* is, size_t len, wc_ces hint)
{// addr = 0x080B6412  --  defined in 'detect.c' at line 77
    wc_bool iso2022jp2;   // _cfa_fffffff3
    wc_bool iso2022jp3;   // _cfa_fffffff2
    wc_bool iso2022cn;   // _cfa_fffffff1
    wc_bool iso2022kr;   // _cfa_fffffff0
    wc_bool ok;        // _cfa_ffffffef
    wc_uchar* p;      // _cfa_ffffffe8
    wc_uchar* ep;     // _cfa_ffffffe4
    wc_uchar* q;      // _cfa_ffffffe0
    wc_ces euc;         // _cfa_ffffffdc
    wc_ces priv;        // _cfa_ffffffd8
    int euc_state;                         // _cfa_ffffffd4
    int sjis_state;                        // _cfa_ffffffd0
    int big5_state;                        // _cfa_ffffffcc
    int hz_state;                          // _cfa_ffffffc8
    int iso_detect;                        // _cfa_ffffffc4
    int euc_detect;                        // _cfa_ffffffc0
    int sjis_detect;                       // _cfa_ffffffbc
    int big5_detect;                       // _cfa_ffffffb8
    int hz_detect;                         // _cfa_ffffffb4
    int latin_detect;                      // _cfa_ffffffb0
    int priv_detect;                       // _cfa_ffffffac
    int possible;                          // _cfa_ffffffa8
    int utf8_state;                        // _cfa_ffffffa4
    int utf8_detect;                       // _cfa_ffffffa0
    int utf8_next;                         // _cfa_ffffff9c
    signed int _v132;                      // _cfa_ffffff7c
    signed int _v136;                      // _cfa_ffffff78
    intOrPtr _v140;                        // _cfa_ffffff74
    signed int _v144;                      // _cfa_ffffff70
    wc_status st;    // _cfa_ffffff60
    _unknown_ _v184;                       // _cfa_ffffff48 (outparam)
    wc_ces _t328;       // _t328
    wc_ces _t333;       // _t333
    wc_ces _t359;       // _t359
    int _t370;                             // _t370
    int _t376;                             // _t376
    signed int _t392;                      // _t392
    int _t398;                             // _t398
    signed int _t403;                      // _t403
    int _t412;                             // _t412
    int _t414;                             // _t414
    int _t423;                             // _t423
    int _t438;                             // _t438
    int _t445;                             // _t445
    signed int _t465;                      // _t465

    p = is;
    ep = p + len;
    euc = 0;
    priv = 0;
    euc_state = 0;
    sjis_state = 0;
    big5_state = 0;
    hz_state = 0;
    iso_detect = 8;
    euc_detect = 8;
    sjis_detect = 8;
    big5_detect = 8;
    hz_detect = 8;
    latin_detect = 8;
    priv_detect = 8;
    possible = 0;
    iso2022jp2 = 0;
    iso2022jp3 = 0;
    iso2022cn = 0;
    iso2022kr = 0;
    ok = 0;
    utf8_state = 0;
    utf8_detect = 8;
    utf8_next = 0;
    wc_create_detect_map(hint, 1);
    while(p < ep) {
        if(( *( &WC_DETECT_MAP + ( *p & 0xff)) & 255) == 0) {
            p =  &(p[1]);
            continue;
        }
        break;
    }
    if(p == ep) {
        return hint;
    }
    _t328 = hint;
    if(_t328 == 3149846) {
L25:
        euc = 3149846;
        euc_state = 0;
        sjis_state = 0;
        sjis_detect = 0;
        euc_detect = sjis_detect;
        iso_detect = euc_detect;
        possible = 3;
        goto L35;
    } else {
        if(_t328 > 3149846) {
            if(_t328 > 3153977) {
                if(_t328 == 3153981) {
L27:
                    euc = 3149848;
                    euc_state = 0;
                    big5_state = 0;
                    big5_detect = 0;
                    euc_detect = big5_detect;
                    iso_detect = euc_detect;
                    possible = 3;
L35:
                    if(priv_detect == 8) {
                        utf8_detect = 0;
                        possible = possible + 1;
                    }
                    wc_input_init(256,  &st);
                    while(p < ep) {
                        if(possible == 0 || possible == 1 && ok != 0) {
                            break;
                        } else {
                            if(iso_detect == 8) {
L77:
                                if(euc_detect == 8) {
L98:
                                    if(sjis_detect == 8) {
L118:
                                        if(big5_detect != 8) {
                                            _t398 = big5_state;
                                            if(_t398 == 0) {
                                                _t403 =  *( &WC_BIG5_MAP + ( *p & 0xff)) & 0xff;
                                                if(_t403 == 2) {
                                                    big5_detect = 8;
                                                } else {
                                                    if(_t403 == 7) {
                                                        big5_state = 1;
                                                    }
                                                }
                                            } else {
                                                if(_t398 == 1) {
                                                    if(( *( &WC_BIG5_MAP + ( *p & 0xff)) & 4) == 0) {
                                                        if((big5_detect & 4) != 0) {
                                                            _t412 = 8;
                                                        } else {
                                                            _t412 = big5_detect | 4;
                                                        }
                                                        big5_detect = _t412;
                                                    } else {
                                                        big5_detect = big5_detect | 2;
                                                        ok = 1;
                                                    }
                                                    big5_state = 0;
                                                }
                                            }
                                            if(big5_detect == 8) {
                                                possible = possible - 1;
                                            }
                                        }
                                        if(hz_detect == 8) {
L141:
                                            if(latin_detect != 8) {
                                                _t392 =  *( &WC_ISO_MAP + ( *p & 0xff)) & 0xf0;
                                                if(_t392 == 80) {
                                                    latin_detect = 8;
                                                } else {
                                                    if(_t392 == 96 || _t392 == 64) {
                                                        latin_detect = latin_detect | 2;
                                                        ok = 1;
                                                    }
                                                }
                                                if(latin_detect == 8) {
                                                    possible = possible - 1;
                                                }
                                            }
                                            if(priv_detect != 8 && ( *p & 255) != 27 && ( *( &WC_DETECT_MAP + ( *p & 0xff)) & 255) != 0) {
                                                priv_detect = priv_detect | 2;
                                                ok = 1;
                                            }
                                            if(utf8_detect == 8) {
L173:
                                                p =  &(p[1]);
                                                continue;
                                            } else {
                                                _t370 = utf8_state;
                                                if(_t370 == 0) {
                                                    utf8_next =  *( &WC_UTF8_MAP + ( *p & 0xff)) & 0xff;
                                                    _t376 = utf8_next;
                                                    if(_t376 == 1) {
L163:
L166:
L171:
                                                        if(utf8_detect == 8) {
                                                            possible = possible - 1;
                                                        }
                                                        goto L173;
                                                    }
                                                    if(_t376 > 1) {
                                                        if(_t376 == 7) {
L164:
                                                            utf8_detect = 8;
                                                            goto L166;
                                                        }
                                                        if(_t376 != 8) {
L165:
                                                            utf8_next = utf8_next - 1;
                                                            utf8_state = 1;
                                                            goto L171;
                                                        }
                                                        goto L163;
                                                    }
                                                    if(_t376 == 0) {
                                                        goto L164;
                                                    }
                                                    goto L165;
                                                }
                                                if(_t370 == 1) {
                                                    if(( *( &WC_UTF8_MAP + ( *p & 0xff)) & 255) == 0) {
                                                        utf8_next = utf8_next - 1;
                                                        if(utf8_next == 0) {
                                                            utf8_detect = utf8_detect | 2;
                                                            ok = 1;
                                                            utf8_state = 0;
                                                        }
                                                    } else {
                                                        utf8_detect = 8;
                                                        utf8_state = 0;
                                                    }
                                                }
                                                goto L171;
                                            }
                                        } else {
                                            if(( *p & 255) >= 0) {
                                                if(hz_state > 4) {
                                                    goto L141;
                                                }
                                                goto __eax;
                                            }
                                            hz_detect = 8;
                                            possible = possible - 1;
                                            goto L141;
                                        }
                                    }
                                    _t414 = sjis_state;
                                    if(_t414 == 1) {
                                        if(( *( &WC_SJIS_MAP + ( *p & 0xff)) & 0x10) == 0) {
                                            if((sjis_detect & 4) != 0) {
                                                _t423 = 8;
                                            } else {
                                                _t423 = sjis_detect | 4;
                                            }
                                            sjis_detect = _t423;
                                        } else {
                                            sjis_detect = sjis_detect | 2;
                                            ok = 1;
                                        }
                                        sjis_state = 0;
L116:
                                        if(sjis_detect == 8) {
                                            possible = possible - 1;
                                        }
                                        goto L118;
                                    }
                                    if(_t414 == 3) {
                                        if(( *( &WC_SJIS_MAP + ( *p & 0xff)) & 0x10) == 0) {
                                            sjis_detect = 8;
                                        } else {
                                            sjis_detect = sjis_detect | 1;
                                        }
                                        sjis_state = 0;
                                        goto L116;
                                    }
                                    if(_t414 != 0) {
                                        goto L116;
                                    }
                                    if(( *( &WC_SJIS_MAP + ( *p & 0xff)) & 0xff) - 18 > 46) {
                                        goto L116;
                                    }
                                    goto __eax;
                                }
                                _t438 = euc_state;
                                if(_t438 == 2) {
                                    if(( *( &WC_ISO_MAP + ( *p & 0xff)) & 255) != 64) {
                                        if((euc_detect & 4) != 0) {
                                            _t445 = 8;
                                        } else {
                                            _t445 = euc_detect | 4;
                                        }
                                        euc_detect = _t445;
                                    } else {
                                        euc_detect = euc_detect | 2;
                                        ok = 1;
                                    }
                                    euc_state = 0;
L96:
                                    if(euc_detect == 8) {
                                        possible = possible - 1;
                                    }
                                    goto L98;
                                }
                                if(_t438 == 3) {
                                    if(( *p & 255) <= 159 || ( *p & 255) > 176 || ( *( &WC_ISO_MAP + (p[1] & 0xff)) & 255) != 64) {
                                        euc_detect = 8;
                                    }
                                    euc_state = 0;
                                    goto L96;
                                }
                                if(_t438 != 0) {
                                    goto L96;
                                }
                                if(( *( &WC_ISO_MAP + ( *p & 0xff)) & 0xff) - 64 > 32) {
                                    goto L96;
                                }
                                goto __eax;
                            }
                            _t465 =  *p & 0xff;
                            if(_t465 < 14) {
L72:
                                if(( *p & 255) < 0) {
                                    iso_detect = 8;
                                    possible = possible - 1;
                                }
                                goto L77;
                            }
                            if(_t465 <= 15) {
                                iso_detect = 2;
                                ok = 1;
                                iso2022cn = 1;
                                iso2022kr = 1;
                                goto L77;
                            }
                            if(_t465 != 27) {
                                goto L72;
                            }
                            if((p[1] & 255) != 36) {
                                if((p[1] & 255) != 46) {
                                    if((p[1] & 255) != 37) {
L70:
                                        iso_detect = 2;
                                        ok = 1;
                                        goto L77;
                                    }
                                    q = p;
                                    if(wc_parse_iso2022_esc( &q,  &st) == 0) {
                                        goto L77;
                                    }
                                    possible = 0;
                                    iso_detect = 4;
                                    goto L173;
                                }
                                q = p;
                                if(wc_parse_iso2022_esc( &q,  &st) == 0) {
                                    goto L77;
                                } else {
                                    if((_v136 & 65280) == 512) {
                                        iso2022jp2 = 1;
                                    }
                                    goto L70;
                                }
                            }
                            q = p;
                            if(wc_parse_iso2022_esc( &q,  &st) == 0) {
                                goto L77;
                            } else {
                                if(_v144 != 33088 && _v144 != 33090) {
                                    if(_v144 == 33103 || _v144 == 33104) {
                                        iso2022jp3 = 1;
                                    } else {
                                        if((_v144 & 65280) == 33024) {
                                            iso2022jp2 = 1;
                                        }
                                    }
                                }
                                if(_v140 != 33091) {
                                    if(_v140 == 33089 || _v140 == 33093 || _v140 == 33095) {
                                        iso2022cn = 1;
                                    }
                                } else {
                                    iso2022kr = 1;
                                }
                                if((_v136 & 65280) == 33024 || (_v132 & 65280) == 33024) {
                                    iso2022cn = 1;
                                }
                                goto L70;
                            }
                        }
                    }
                    if(iso_detect == 8) {
                        _t333 = hint;
                        if(_t333 > 3149849) {
                            if(_t333 == 3153981) {
                                if(big5_detect == 8) {
L234:
                                    if(euc_detect != 2) {
                                        if(sjis_detect != 2) {
                                            if(big5_detect != 2) {
                                                if(utf8_detect != 2) {
                                                    if((sjis_detect & 1) == 0) {
                                                        if(euc_detect == 8) {
                                                            if(sjis_detect == 8) {
                                                                if(big5_detect == 8) {
                                                                    if(utf8_detect == 8) {
                                                                        return hint;
                                                                    }
                                                                    return 3178565;
                                                                }
                                                                return 3153981;
                                                            }
                                                            return 3153976;
                                                        }
                                                        return euc;
                                                    }
                                                    return 3153976;
                                                }
                                                return 3178565;
                                            }
                                            return 3153981;
                                        }
                                        return 3153976;
                                    }
                                    return euc;
                                }
                                return hint;
                            }
                            if(_t333 > 3153981) {
L210:
                                if(_t333 == 3178565) {
                                    return hint;
                                }
L224:
                                if(latin_detect == 8) {
                                    if(priv_detect == 8) {
                                        if(utf8_detect == 8) {
                                            return hint;
                                        }
                                        return 3178565;
                                    }
                                    return hint;
                                }
                                return hint;
                            }
                            if(_t333 - 3153976 > 1) {
                                goto L224;
                            }
                            if(sjis_detect == 8) {
                                goto L234;
                            } else {
                                return hint;
                            }
                            goto L210;
                        }
                        if(_t333 >= 3149846) {
                            if(euc_detect == 8) {
                                goto L234;
                            }
                            return hint;
                        }
                        if(_t333 == 256) {
                            if(utf8_detect == 8) {
                                if(latin_detect == 8) {
                                    return hint;
                                }
                                return 1049089;
                            }
                            return hint;
                        }
                        if(_t333 < 256 || _t333 - 2099217 > 4) {
                            goto L224;
                        } else {
                            goto L234;
                        }
                    }
                    if(iso_detect != 0) {
                        _t359 = euc;
                        if(_t359 < 3149847) {
L191:
                            if(iso2022jp3 == 0) {
                                if(iso2022jp2 == 0) {
                                    if(iso2022cn == 0) {
                                        if(iso2022kr == 0) {
                                            return 2099217;
                                        }
                                        return 2099221;
                                    }
                                    return 2099220;
                                }
                                return 2099218;
                            }
                            return 2099219;
                        }
                        if(_t359 <= 3149848) {
                            if(iso2022cn == 0) {
                                goto L191;
                            }
                            return 2099220;
                        }
                        if(_t359 == 3149849) {
                            if(iso2022kr == 0) {
                                goto L191;
                            }
                            return 2099221;
                        }
                        goto L191;
                    }
                    if(hz_detect != 2) {
                        if(priv_detect != 2) {
                            return 256;
                        }
                        return priv;
                    }
                    return 2105404;
                }
                if(_t328 == 3178565) {
                    iso_detect = 0;
                    possible = 1;
                } else {
L32:
                    if((hint & 512) == 0) {
                        priv_detect = 0;
                        iso_detect = priv_detect;
                        priv = hint;
                        possible = 2;
                    } else {
                        latin_detect = 0;
                        iso_detect = latin_detect;
                        possible = 2;
                    }
                }
                goto L35;
            }
            if(_t328 >= 3153976) {
                goto L25;
            }
            if(_t328 == 3149848) {
                goto L27;
            }
            if(_t328 < 3149848) {
L26:
                euc = 3149847;
                euc_state = 0;
                big5_state = 0;
                big5_detect = 0;
                euc_detect = big5_detect;
                iso_detect = euc_detect;
                possible = 3;
                goto L35;
            }
            if(_t328 == 3149849) {
L29:
                euc = 3149849;
                euc_state = 0;
                euc_detect = 0;
                iso_detect = euc_detect;
                possible = 3;
                goto L35;
            } else {
                goto L32;
            }
        }
        if(_t328 > 2099219) {
            if(_t328 == 2099221) {
                goto L29;
            }
            if(_t328 < 2099221) {
                goto L26;
            }
            if(_t328 == 2105404) {
                euc = 3149847;
                euc_state = 0;
                hz_state = 0;
                hz_detect = 0;
                big5_detect = hz_detect;
                euc_detect = big5_detect;
                iso_detect = euc_detect;
                possible = 4;
                goto L35;
            } else {
                goto L32;
            }
        }
        if(_t328 >= 2099217) {
            goto L25;
        }
        if(_t328 == 256) {
            latin_detect = 0;
            iso_detect = latin_detect;
            possible = 2;
            goto L35;
        } else {
            goto L32;
        }
    }
}

Str wc_conv_from_hz(Str is, wc_ces ces)
{// addr = 0x080B7018  --  defined in 'hz.c' at line 11
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    int state;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    p = sp;
    while(p < ep) {
        if(( *p & 255) < 0 || ( *p & 255) == 126) {
            break;
        } else {
            p =  &(p[1]);
            continue;
        }
    }
    if(p == ep) {
        return is;
    }
    os = Strnew_size(is->length);
    if(p > sp) {
        Strcat_charp_n(os, is->ptr, p - sp);
    }
    while(p < ep) {
        if(state > 5) {
            p =  &(p[1]);
            continue;
        }
        goto __eax;
    }
    if(state <= 5 && (1 << state & 54) != 0) {
        wtf_push_unknown(os, p - 1, 1);
    }
    return os;
}

void wc_push_to_hz(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080B7449  --  defined in 'hz.c' at line 98
    intOrPtr _v16;                         // _cfa_fffffff0
    wc_status* _v20;   // _cfa_ffffffec
    unsigned char _v24;                    // _cfa_ffffffe8 (outparam)
    unsigned char _t238;                   // _t238
    int _t250;                             // _t250
    int _t262;                             // _t262
    int _t279;                             // _t279
    int _t291;                             // _t291
    int _t305;                             // _t305
    int _t317;                             // _t317
    int _t337;                             // _t337
    int _t349;                             // _t349
    unsigned char _t361;                   // _t361
    int _t373;                             // _t373
    int _t386;                             // _t386
    int _t399;                             // _t399
    int _t411;                             // _t411

    while(1) {
        _t238 = cc.auto_detect;
        if(_t238 == 16384) {
            break;
        }
        if(_t238 > 16384) {
            if(_t238 == 33089) {
                if(( *( *((intOrPtr*)(__ebp + 20)) + 5) & 255) == 0) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t305 = os->length;
                     *((char*)(os->ptr + _t305)) = 126;
                    os->length = _t305 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t317 = os->length;
                     *((char*)(os->ptr + _t317)) = 123;
                    os->length = _t317 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                     *( *((intOrPtr*)(__ebp + 20)) + 5) = 1;
                }
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t279 = os->length;
                 *((char*)(os->ptr + _t279)) = st >> 8 & 127;
                os->length = _t279 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t291 = os->length;
                 *((char*)(os->ptr + _t291)) = st & 127;
                os->length = _t291 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            if(_t238 == 49152) {
                if(( *135119022 & 255) != 0) {
                    return;
                }
                if(( *( *((intOrPtr*)(__ebp + 20)) + 5) & 255) != 0) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t337 = os->length;
                     *((char*)(os->ptr + _t337)) = 126;
                    os->length = _t337 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t349 = os->length;
                     *((char*)(os->ptr + _t349)) = 125;
                    os->length = _t349 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                     *( *((intOrPtr*)(__ebp + 20)) + 5) = 0;
                }
                Strcat_charp(os, WcReplaceW);
                return;
            }
        } else {
            if(_t238 == 322) {
                if(( *( *((intOrPtr*)(__ebp + 20)) + 5) & 255) != 0) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t399 = os->length;
                     *((char*)(os->ptr + _t399)) = 126;
                    os->length = _t399 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t411 = os->length;
                     *((char*)(os->ptr + _t411)) = 125;
                    os->length = _t411 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                     *( *((intOrPtr*)(__ebp + 20)) + 5) = 0;
                }
                if(st == 126) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t386 = os->length;
                     *((char*)(os->ptr + _t386)) = 126;
                    os->length = _t386 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                }
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t373 = os->length;
                 *((char*)(os->ptr + _t373)) = st;
                os->length = _t373 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
        }
        if(( *135119011 & 255) == 0) {
            if((cc.auto_detect & 98304) == 0) {
                _t361 = 16384;
            } else {
                _t361 = 49152;
            }
            cc.auto_detect = _t361;
        } else {
            _v16 =  *((intOrPtr*)(__ebp + 20));
            _v24 = cc.auto_detect;
            _v20 = st;
             *__esp =  &cc;
            wc_any_to_any_ces();
            __esp = __esp - 4;
        }
    }
    if(( *135119022 & 255) == 0) {
        if(( *( *((intOrPtr*)(__ebp + 20)) + 5) & 255) != 0) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t250 = os->length;
             *((char*)(os->ptr + _t250)) = 126;
            os->length = _t250 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t262 = os->length;
             *((char*)(os->ptr + _t262)) = 125;
            os->length = _t262 + 1;
             *((char*)(os->ptr + os->length)) = 0;
             *( *((intOrPtr*)(__ebp + 20)) + 5) = 0;
        }
        Strcat_charp(os, WcReplace);
        return;
    }
}

void wc_push_to_hz_end(Str os, wc_status* st)
{// addr = 0x080B792D  --  defined in 'hz.c' at line 154
    int _t47;                              // _t47
    int _t59;                              // _t59

    if((st->gl & 255) != 0) {
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t47 = os->length;
         *((char*)(os->ptr + _t47)) = 126;
        os->length = _t47 + 1;
         *((char*)(os->ptr + os->length)) = 0;
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t59 = os->length;
         *((char*)(os->ptr + _t59)) = 125;
        os->length = _t59 + 1;
         *((char*)(os->ptr + os->length)) = 0;
        st->gl = 0;
        return;
    }
}

void wtf_push_iso2022(Str os, wc_ccs ccs, wc_uint32 code)
{// addr = 0x080B79E4  --  defined in 'iso2022.c' at line 51
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    unsigned int _t12;                     // _t12

    _t12 = ccs;
    if(_t12 == 33090) {
L10:
        ccs = wc_jisx0208_or_jisx02131(code & 65535);
L13:
        wtf_push(os, ccs, code);
        return;
    }
    if(_t12 > 33090) {
        if(_t12 == 33103) {
            goto L10;
        }
        if(_t12 == 33104 || _t12 == 33092) {
            ccs = wc_jisx0212_or_jisx02132(code & 65535);
        }
        goto L13;
    }
    if(_t12 == 340) {
L12:
        ccs = 322;
        goto L13;
    }
    if(_t12 == 33088) {
        goto L10;
    }
    if(_t12 == 330) {
        goto L12;
    } else {
        goto L13;
    }
}

Str wc_conv_from_iso2022(Str is, wc_ces ces)
{// addr = 0x080B7A71  --  defined in 'iso2022.c' at line 72
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    wc_uchar* q;      // _cfa_ffffffe0
    int state;                             // _cfa_ffffffdc
    wc_ccs gl_ccs;      // _cfa_ffffffd8
    wc_ccs gr_ccs;      // _cfa_ffffffd4
    char _v98;                             // _cfa_ffffff9e
    signed char _v99;                      // _cfa_ffffff9d
    signed char _v100;                     // _cfa_ffffff9c
    wc_status st;    // _cfa_ffffff98
    _unknown_ _v116;                       // _cfa_ffffff8c (outparam)
    _unknown_ _v120;                       // _cfa_ffffff88 (outparam)
    int _t91;                              // _t91

    sp = is->ptr;
    ep = sp + is->length;
    q = 0;
    state = 0;
    p = sp;
    do {
    } while(p < ep && ( *( &WC_ISO_MAP + ( *p & 0xff)) & 0x4f) == 0);
    if(p == ep) {
        return is;
    }
    os = Strnew_size(is->length);
    if(p > sp) {
        Strcat_charp_n(os, is->ptr, p - sp);
    }
    wc_input_init(ces,  &st);
    gl_ccs =  *(__ebp + ((_v99 & 0xff) + 4) * 4 - 100);
    gr_ccs =  *(__ebp + ((_v100 & 0xff) + 4) * 4 - 100);
    while(p < ep) {
        if(state > 32) {
            _v98 = 0;
            state = 0;
            p =  &(p[1]);
            continue;
        }
        goto __eax;
    }
    _t91 = state;
    if(_t91 >= 1) {
        if(_t91 <= 2) {
            wtf_push_unknown(os, p - 1, 1);
        } else {
            if(_t91 == 4) {
                wtf_push_unknown(os, p - 2, 2);
            }
        }
    }
    return os;
}

int wc_parse_iso2022_esc(wc_uchar** ptr, wc_status* st)
{// addr = 0x080B82F1  --  defined in 'iso2022.c' at line 255
    wc_uchar state;   // _cfa_fffffff7
    wc_uchar f;       // _cfa_fffffff6
    wc_uchar g;       // _cfa_fffffff5
    wc_uchar cs;      // _cfa_fffffff4
    wc_uchar* p;      // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    signed int _t98;                       // _t98
    signed int _t120;                      // _t120
    signed int _t133;                      // _t133
    signed int _t135;                      // _t135

    p =  *ptr;
    f = 0;
    g = 0;
    cs = 0;
    if(( *p & 255) != 27) {
        return 0;
    }
    state =  *p & 255;
    p =  &(p[1]);
    while(( *p & 255) != 0 && state != 0) {
        _t120 = state & 255;
        if(_t120 == 40) {
            if(( *p & 255) != 33) {
L34:
                state = 0;
                f =  *p & 255;
L39:
                p =  &(p[1]);
                continue;
            }
            cs = 161;
            state = cs & 255;
            g =  *p & 3;
            goto L39;
        }
        if(_t120 > 40) {
            if(_t120 == 165) {
                goto L34;
            }
            if(_t120 > 165) {
                if(_t120 == 168 || _t120 == 172) {
                    goto L34;
                } else {
L38:
                    return 0;
                }
            }
            if(_t120 == 44 || _t120 == 161) {
                goto L34;
            } else {
                goto L38;
            }
        }
        if(_t120 == 33) {
            goto L34;
        }
        if(_t120 > 33) {
            if(_t120 == 36) {
                _t133 = ( *p & 0xff) - 40;
                if(_t133 > 26) {
L31:
                    return 0;
                }
                _t135 = 1 << _t133;
                if((_t135 & 117440512) != 0) {
                    state = 0;
                    cs = 168;
                    g = 0;
                    f =  *p & 255;
                    goto L39;
                }
                if((_t135 & 240) != 0) {
                    cs = 172;
                    state = cs & 255;
                    g =  *p & 3;
                    goto L39;
                }
                if((_t135 & 15) != 0) {
                    cs = 168;
                    state = cs & 255;
                    g =  *p & 3;
                    goto L39;
                } else {
                    goto L31;
                }
            }
            if(_t120 == 37) {
                if(( *p & 255) != 47) {
                    state = 0;
                    f =  *p & 255;
                } else {
                    cs = 165;
                    state = cs & 255;
                }
                goto L39;
            } else {
                goto L38;
            }
        } else {
            if(_t120 == 27) {
                if(( *p & 0xff) - 33 <= 93) {
                    goto __eax;
                }
                return 0;
            } else {
                goto L38;
            }
        }
    }
    if(f <= 63 || f > 126) {
        return 0;
    } else {
        _t98 = cs & 255;
        if(_t98 == 47) {
            st->state = 32;
        } else {
            if(_t98 > 47) {
                if(_t98 == 168) {
                     *((intOrPtr*)(st + ((g & 255) + 4) * 4)) = f & 255 | 129;
                } else {
                    if(_t98 == 172) {
                         *((intOrPtr*)(st + ((g & 255) + 4) * 4)) = f & 255 | 130;
                    } else {
                        if(_t98 == 161) {
                             *((intOrPtr*)(st + ((g & 255) + 4) * 4)) = f & 255 | 4;
                        }
                    }
                }
            } else {
                if(_t98 == 40) {
                     *((intOrPtr*)(st + ((g & 255) + 4) * 4)) = f & 255 | 1;
                } else {
                    if(_t98 == 44) {
                         *((intOrPtr*)(st + ((g & 255) + 4) * 4)) = f & 255 | 2;
                    } else {
                        if(_t98 == 37) {
                            if(f != 64) {
                                st->state = 16;
                            } else {
                                st->state = 0;
                            }
                        }
                    }
                }
            }
        }
         *ptr = p - 1;
        return 1;
    }
}

void wc_push_to_iso2022(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080B871B  --  defined in 'iso2022.c' at line 397
    wc_uchar g;       // _cfa_fffffff3
    wc_bool is_wide;   // _cfa_fffffff2
    wc_bool retry;     // _cfa_fffffff1
    wc_status* _v20;   // _cfa_ffffffec
    wc_wchar_t cc2;   // _cfa_ffffffe8
    wc_status* _v28;   // _cfa_ffffffe4
    wc_wchar_t cc2;   // _cfa_ffffffe0
    wc_status* _v48;   // _cfa_ffffffd0
    unsigned char _v52;                    // _cfa_ffffffcc
    _unknown_ _v76;                        // _cfa_ffffffb4 (outparam)
    wc_status* _v80;   // _cfa_ffffffb0 (outparam)
    wc_status* _v84;   // _cfa_ffffffac (outparam)
    unsigned char _v88;                    // _cfa_ffffffa8 (outparam)
    signed int _t144;                      // _t144
    int _t161;                             // _t161
    int _t174;                             // _t174
    unsigned char _t184;                   // _t184
    unsigned char _t205;                   // _t205
    unsigned char _t229;                   // _t229

    g = 0;
    is_wide = 0;
    retry = 0;
    while(1) {
        _t144 = cc.auto_detect & 65280;
        if(_t144 == 16384) {
            goto L39;
        }
        if(_t144 > 16384) {
            if(_t144 == 33280) {
                is_wide = 1;
                g =  *( &cs96w_gmap + (cc.auto_detect & 255) - 64) & 255;
L51:
                if(g != 0) {
                    wc_push_iso2022_esc(os, cc.auto_detect, g & 255, 1,  *(__ebp + 20));
                    if(is_wide != 0) {
                        if(os->length + 1 >= os->area_size) {
                            Strgrow(os);
                        }
                        _t174 = os->length;
                         *((char*)(os->ptr + _t174)) = st >> 8 & 127;
                        os->length = _t174 + 1;
                         *((char*)(os->ptr + os->length)) = 0;
                    }
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t161 = os->length;
                     *((char*)(os->ptr + _t161)) = st & 127;
                    os->length = _t161 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    return;
                }
                if(( *135119011 & 255) == 0 || retry != 0) {
                    if((cc.auto_detect & 98304) == 0) {
                        _t184 = 16384;
                    } else {
                        _t184 = 49152;
                    }
                    cc.auto_detect = _t184;
                } else {
                    _v80 =  *(__ebp + 20);
                    _v88 = cc.auto_detect;
                    _v84 = st;
                     *__esp =  &_v52;
                    wc_any_to_any_ces();
                    __esp = __esp - 4;
                    cc.auto_detect = _v52;
                    st = _v48;
                }
                retry = 1;
L67:
                continue;
            }
            if(_t144 == 49152) {
                if(( *135119022 & 255) != 0) {
                    return;
                }
                is_wide = 1;
                cc.auto_detect = 322;
                g =  *( &cs94_gmap + (cc.auto_detect & 255) - 64) & 255;
                st = WcReplaceW[1] & 255 | ( *WcReplaceW & 255) << 8;
                goto L51;
            }
            if(_t144 == 33024) {
                is_wide = 1;
                _t205 = cc.auto_detect;
                if(_t205 == 33092) {
                    if(( *135119018 & 255) != 0) {
L33:
                        g =  *( &cs94w_gmap + (cc.auto_detect & 255) - 64) & 255;
                        goto L51;
                    }
                    if(( *135119019 & 255) == 0) {
                        goto L33;
                    }
                    if(( *135119011 & 255) == 0) {
                        goto L33;
                    }
                    _v88 = cc.auto_detect;
                    _v84 = st;
                     *__esp =  &cc2;
                    wc_jisx0212_to_jisx0213();
                    __esp = __esp - 4;
                    if(cc2.auto_detect == 33103 || cc2.auto_detect == 33104) {
                        cc.auto_detect = cc2.auto_detect;
                        st = _v20;
                        goto L67;
                    } else {
                        goto L33;
                    }
                }
                if(_t205 < 33092 || _t205 - 33103 > 1 || ( *135119019 & 255) != 0 || ( *135119018 & 255) == 0 || ( *135119011 & 255) == 0) {
                    goto L33;
                } else {
                    _v88 = cc.auto_detect;
                    _v84 = st;
                     *__esp =  &_v52;
                    wc_jisx0213_to_jisx0212();
                    __esp = __esp - 4;
                    cc2.auto_detect = _v52;
                    _v20 = _v48;
                    if(cc2.auto_detect != 33092) {
                        goto L33;
                    }
                    cc.auto_detect = cc2.auto_detect;
                    st = _v20;
                    goto L67;
                }
            } else {
L41:
                if(( *135790083 & 255) == 0) {
L44:
                    if(( *135119011 & 255) == 0) {
                        if((cc.auto_detect & 98304) == 0) {
                            _t229 = 16384;
                        } else {
                            _t229 = 49152;
                        }
                        cc.auto_detect = _t229;
                    } else {
                        _v80 =  *(__ebp + 20);
                        _v88 = cc.auto_detect;
                        _v84 = st;
                         *__esp =  &cc;
                        wc_any_to_iso2022();
                        __esp = __esp - 4;
                    }
                    goto L67;
                }
                _v88 = cc.auto_detect;
                _v84 = st;
                 *__esp =  &cc2;
                wc_johab_to_ksx1001();
                __esp = __esp - 4;
                if(cc2.auto_detect != 33091) {
                    goto L44;
                }
                cc.auto_detect = cc2.auto_detect;
                st = _v28;
                goto L67;
            }
        }
        if(_t144 == 512) {
            g =  *( &cs96_gmap + (cc.auto_detect & 255) - 64) & 255;
            goto L51;
        }
        if(_t144 == 1024) {
            g =  *( &cs942_gmap + (cc.auto_detect & 255) - 64) & 255;
            goto L51;
        }
        if(_t144 == 256) {
            if(cc.auto_detect == 322) {
                cc.auto_detect =  *(__ebp + 20)->g0_ccs;
            }
            g =  *( &cs94_gmap + (cc.auto_detect & 255) - 64) & 255;
            goto L51;
        } else {
            goto L41;
        }
L39:
        if(( *135119022 & 255) != 0) {
            return;
        }
        cc.auto_detect = 322;
        g =  *( &cs94_gmap + (cc.auto_detect & 255) - 64) & 255;
        st =  *WcReplace & 255;
        goto L51;
    }
}

void wc_push_to_iso2022_end(Str os, wc_status* st)
{// addr = 0x080B8B9C  --  defined in 'iso2022.c' at line 503
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if( *((intOrPtr*)(st + 20)) != 0 &&  *((intOrPtr*)(st + 20)) != st->g1_ccs) {
        wc_push_iso2022_esc(os, st->g1_ccs, 41, 0, st);
    }
    wc_push_iso2022_esc(os, st->g0_ccs, 40, 1, st);
}

void wc_push_iso2022_esc(Str os, wc_ccs ccs, wc_uchar g, wc_uint8 invoke, wc_status* st)
{// addr = 0x080B8C16  --  defined in 'iso2022.c' at line 511
    wc_uint8 g_invoke;   // _cfa_fffffff3
    signed int _v32;                       // _cfa_ffffffe0
    char _v36;                             // _cfa_ffffffdc
    signed int _t243;                      // _t243
    int _t252;                             // _t252
    int _t266;                             // _t266
    int _t278;                             // _t278
    int _t292;                             // _t292
    int _t304;                             // _t304
    int _t320;                             // _t320
    int _t334;                             // _t334
    int _t348;                             // _t348
    int _t362;                             // _t362
    int _t376;                             // _t376
    int _t390;                             // _t390
    int _t402;                             // _t402

    _v32 = g;
    _v36 = invoke;
    g_invoke = _v32 & 3;
    if( *((intOrPtr*)(st + ((g_invoke & 255) + 4) * 4)) == ccs) {
L22:
        if(_v36 == 0) {
            return;
        }
        _t243 = g_invoke & 255;
        if(_t243 == 1) {
            if((st->gl & 255) == 1) {
                return;
            }
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t252 = os->length;
             *((char*)(os->ptr + _t252)) = 14;
            os->length = _t252 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            st->gl = 1;
            return;
        }
        if(_t243 > 1) {
            if(_t243 == 2) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t266 = os->length;
                 *((char*)(os->ptr + _t266)) = 27;
                os->length = _t266 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t278 = os->length;
                 *((char*)(os->ptr + _t278)) = 78;
                os->length = _t278 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            if(_t243 == 3) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t292 = os->length;
                 *((char*)(os->ptr + _t292)) = 27;
                os->length = _t292 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t304 = os->length;
                 *((char*)(os->ptr + _t304)) = 79;
                os->length = _t304 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            return;
        }
        if(_t243 == 0) {
            if((st->gl & 255) == 0) {
                return;
            }
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t320 = os->length;
             *((char*)(os->ptr + _t320)) = 15;
            os->length = _t320 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            st->gl = 0;
            return;
        }
        return;
    } else {
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t334 = os->length;
         *((char*)(os->ptr + _t334)) = 27;
        os->length = _t334 + 1;
         *((char*)(os->ptr + os->length)) = 0;
        if((ccs & 98304) == 0) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t348 = os->length;
             *((char*)(os->ptr + _t348)) = _v32 & 255;
            os->length = _t348 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            if((ccs & 1792) == 1024) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t376 = os->length;
                 *((char*)(os->ptr + _t376)) = 33;
                os->length = _t376 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
            }
L19:
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t362 = os->length;
             *((char*)(os->ptr + _t362)) = ccs;
            os->length = _t362 + 1;
             *((char*)(os->ptr + os->length)) = 0;
             *((intOrPtr*)(st + ((g_invoke & 255) + 4) * 4)) = ccs;
            goto L22;
        }
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t390 = os->length;
         *((char*)(os->ptr + _t390)) = 36;
        os->length = _t390 + 1;
         *((char*)(os->ptr + os->length)) = 0;
        if(g_invoke != 0 || ccs != 33088 && ccs != 33090 && ccs != 33089) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t402 = os->length;
             *((char*)(os->ptr + _t402)) = _v32 & 255;
            os->length = _t402 + 1;
             *((char*)(os->ptr + os->length)) = 0;
        }
        goto L19;
    }
}

void wc_push_to_euc(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080B90B4  --  defined in 'iso2022.c' at line 560
    wc_ccs g1_ccs;      // _cfa_fffffff0
    wc_status* _v32;   // _cfa_ffffffe0
    unsigned char _v36;                    // _cfa_ffffffdc
    intOrPtr _v48;                         // _cfa_ffffffd0
    wc_status* _v52;   // _cfa_ffffffcc
    unsigned char _v56;                    // _cfa_ffffffc8 (outparam)
    unsigned char _t104;                   // _t104
    int _t111;                             // _t111
    unsigned char _t121;                   // _t121
    int _t138;                             // _t138
    int _t154;                             // _t154
    int _t166;                             // _t166

    g1_ccs =  *( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__ebp + 20)))) + 12)) + 8);
    while(cc.auto_detect != g1_ccs) {
        _t104 = cc.auto_detect;
        if(_t104 == 16385) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t111 = os->length;
             *((char*)(os->ptr + _t111)) = st | -128;
            os->length = _t111 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(_t104 > 16385) {
            if(_t104 < 34831) {
L28:
                if(( *135119011 & 255) == 0) {
                    if((cc.auto_detect & 98304) == 0) {
                        _t121 = 16384;
                    } else {
                        _t121 = 49152;
                    }
                    cc.auto_detect = _t121;
                } else {
                    _v48 =  *((intOrPtr*)(__ebp + 20));
                    _v56 = cc.auto_detect;
                    _v52 = st;
                     *__esp =  &_v36;
                    wc_any_to_any_ces();
                    __esp = __esp - 4;
                    cc.auto_detect = _v36;
                    st = _v32;
                }
                continue;
            } else {
                if(_t104 <= 34834) {
                    if( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__ebp + 20)))))) != 3149849) {
                        goto L28;
                    } else {
                        _v56 = cc.auto_detect;
                        _v52 = st;
                         *__esp =  &cc;
                        wc_johab_to_ksx1001();
                        __esp = __esp - 4;
                        continue;
                    }
                } else {
                    if(_t104 == 49152) {
                        if(( *135119022 & 255) != 0) {
                            return;
                        }
                        Strcat_charp(os, WcReplaceW);
                        return;
                    }
                    goto L28;
                }
            }
L35:
            return;
        }
        if(_t104 == 322) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t138 = os->length;
             *((char*)(os->ptr + _t138)) = st;
            os->length = _t138 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(_t104 != 16384) {
            goto L28;
        }
        if(( *135119022 & 255) == 0) {
            Strcat_charp(os, WcReplace);
            return;
        }
        goto L35;
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t154 = os->length;
     *((char*)(os->ptr + _t154)) = st >> 8 | -128;
    os->length = _t154 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t166 = os->length;
     *((char*)(os->ptr + _t166)) = st | -128;
    os->length = _t166 + 1;
     *((char*)(os->ptr + os->length)) = 0;
}

void wc_push_to_eucjp(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080B9358  --  defined in 'iso2022.c' at line 606
    wc_status* _v16;   // _cfa_fffffff0
    unsigned char _v20;                    // _cfa_ffffffec
    intOrPtr _v32;                         // _cfa_ffffffe0
    wc_status* _v36;   // _cfa_ffffffdc
    unsigned char _v40;                    // _cfa_ffffffd8 (outparam)
    unsigned char _t191;                   // _t191
    int _t198;                             // _t198
    int _t210;                             // _t210
    int _t234;                             // _t234
    unsigned char _t247;                   // _t247
    int _t262;                             // _t262
    int _t278;                             // _t278
    int _t290;                             // _t290
    int _t307;                             // _t307
    int _t320;                             // _t320

    while(1) {
        _t191 = cc.auto_detect;
        if(_t191 == 33090) {
            break;
        }
        if(_t191 > 33090) {
            if(_t191 == 33103) {
                if(( *135119019 & 255) != 0) {
L70:
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t198 = os->length;
                     *((char*)(os->ptr + _t198)) = st >> 8 | -128;
                    os->length = _t198 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t210 = os->length;
                     *((char*)(os->ptr + _t210)) = st | -128;
                    os->length = _t210 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    return;
                }
                if(( *135119011 & 255) == 0 || ( *135119018 & 255) == 0) {
                    cc.auto_detect = 49152;
                } else {
                    _v40 = cc.auto_detect;
                    _v36 = st;
                     *__esp =  &_v20;
                    wc_jisx0213_to_jisx0212();
                    __esp = __esp - 4;
                    cc.auto_detect = _v20;
                    st = _v16;
                }
L75:
                continue;
            }
            if(_t191 > 33103) {
                if(_t191 == 33104) {
                    if(( *135119019 & 255) == 0) {
                        if(( *135119011 & 255) == 0 || ( *135119018 & 255) == 0) {
                            cc.auto_detect = 49152;
                        } else {
                            _v40 = cc.auto_detect;
                            _v36 = st;
                             *__esp =  &_v20;
                            wc_jisx0213_to_jisx0212();
                            __esp = __esp - 4;
                            cc.auto_detect = _v20;
                            st = _v16;
                        }
                        goto L75;
                    }
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t234 = os->length;
                     *((char*)(os->ptr + _t234)) = 143;
                    os->length = _t234 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    goto L70;
                }
                if(_t191 == 49152) {
                    if(( *135119022 & 255) != 0) {
                        return;
                    }
                    Strcat_charp(os, WcReplaceW);
                    return;
                }
L61:
                if(( *135119011 & 255) == 0) {
                    if((cc.auto_detect & 98304) == 0) {
                        _t247 = 16384;
                    } else {
                        _t247 = 49152;
                    }
                    cc.auto_detect = _t247;
                } else {
                    _v32 =  *((intOrPtr*)(__ebp + 20));
                    _v40 = cc.auto_detect;
                    _v36 = st;
                     *__esp =  &_v20;
                    wc_any_to_any_ces();
                    __esp = __esp - 4;
                    cc.auto_detect = _v20;
                    st = _v16;
                }
                goto L75;
            }
            if(_t191 == 33092) {
                if(( *135119018 & 255) == 0) {
                    if(( *135119011 & 255) == 0 || ( *135119019 & 255) == 0) {
                        cc.auto_detect = 49152;
                    } else {
                        _v40 = cc.auto_detect;
                        _v36 = st;
                         *__esp =  &_v20;
                        wc_jisx0212_to_jisx0213();
                        __esp = __esp - 4;
                        cc.auto_detect = _v20;
                        st = _v16;
                    }
                    goto L75;
                }
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t262 = os->length;
                 *((char*)(os->ptr + _t262)) = 143;
                os->length = _t262 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                goto L70;
            }
            goto L61;
        }
        if(_t191 == 329) {
            if(( *135119017 & 255) == 0) {
                if(( *135119013 & 255) == 0) {
                    _v40 = cc.auto_detect;
                    _v36 = st;
                     *__esp =  &cc;
                    wc_jisx0201k_to_jisx0208();
                    __esp = __esp - 4;
                } else {
                    cc.auto_detect = 16384;
                }
                goto L75;
            }
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t278 = os->length;
             *((char*)(os->ptr + _t278)) = 142;
            os->length = _t278 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t290 = os->length;
             *((char*)(os->ptr + _t290)) = st | -128;
            os->length = _t290 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(_t191 > 329) {
            if(_t191 == 16384) {
                if(( *135119022 & 255) != 0) {
                    return;
                }
                Strcat_charp(os, WcReplace);
                return;
            }
            if(_t191 == 16385) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t307 = os->length;
                 *((char*)(os->ptr + _t307)) = st | -128;
                os->length = _t307 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            goto L61;
        }
        if(_t191 == 322) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t320 = os->length;
             *((char*)(os->ptr + _t320)) = st;
            os->length = _t320 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        } else {
            goto L61;
        }
    }
    goto L70;
}

void wc_push_to_euctw(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080B9879  --  defined in 'iso2022.c' at line 686
    intOrPtr _v16;                         // _cfa_fffffff0
    wc_status* _v20;   // _cfa_ffffffec
    unsigned char _v24;                    // _cfa_ffffffe8 (outparam)
    unsigned char _t151;                   // _t151
    unsigned char _t155;                   // _t155
    int _t164;                             // _t164
    int _t176;                             // _t176
    int _t188;                             // _t188
    int _t200;                             // _t200
    int _t219;                             // _t219
    int _t231;                             // _t231
    int _t248;                             // _t248
    int _t261;                             // _t261

    while(1) {
        _t151 = cc.auto_detect;
        if(_t151 > 33101) {
            goto L10;
        }
        if(_t151 >= 33096) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t219 = os->length;
             *((char*)(os->ptr + _t219)) = 142;
            os->length = _t219 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t231 = os->length;
             *((char*)(os->ptr + _t231)) = cc.auto_detect + 90;
            os->length = _t231 + 1;
             *((char*)(os->ptr + os->length)) = 0;
L41:
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t188 = os->length;
             *((char*)(os->ptr + _t188)) = st >> 8 | -128;
            os->length = _t188 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t200 = os->length;
             *((char*)(os->ptr + _t200)) = st | -128;
            os->length = _t200 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(_t151 != 16384) {
            if(_t151 > 16384) {
                if(_t151 == 16385) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t248 = os->length;
                     *((char*)(os->ptr + _t248)) = st | -128;
                    os->length = _t248 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    return;
                }
                if(_t151 == 33095) {
                    goto L41;
                }
            } else {
                if(_t151 == 322) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t261 = os->length;
                     *((char*)(os->ptr + _t261)) = st;
                    os->length = _t261 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    return;
                }
            }
L34:
            if(( *135119011 & 255) == 0) {
                if((cc.auto_detect & 98304) == 0) {
                    _t155 = 16384;
                } else {
                    _t155 = 49152;
                }
                cc.auto_detect = _t155;
            } else {
                _v16 =  *((intOrPtr*)(__ebp + 20));
                _v24 = cc.auto_detect;
                _v20 = st;
                 *__esp =  &cc;
                wc_any_to_any_ces();
                __esp = __esp - 4;
            }
            continue;
        }
        if(( *135119022 & 255) == 0) {
            Strcat_charp(os, WcReplace);
            return;
        }
        return;
L10:
        if(_t151 >= 34820) {
            if(_t151 <= 34828) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t164 = os->length;
                 *((char*)(os->ptr + _t164)) = 142;
                os->length = _t164 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t176 = os->length;
                 *((char*)(os->ptr + _t176)) = cc.auto_detect - 92;
                os->length = _t176 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                goto L41;
            }
            if(_t151 == 49152) {
                if(( *135119022 & 255) != 0) {
                    return;
                }
                Strcat_charp(os, WcReplaceW);
                return;
            }
        }
        goto L34;
    }
}

void wc_push_to_iso8859(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080B9C24  --  defined in 'iso2022.c' at line 743
    wc_ccs g1_ccs;      // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    wc_status* _v36;   // _cfa_ffffffdc
    unsigned char _v40;                    // _cfa_ffffffd8 (outparam)
    unsigned char _t77;                    // _t77
    int _t87;                              // _t87
    unsigned char _t100;                   // _t100
    int _t109;                             // _t109
    int _t122;                             // _t122

    g1_ccs =  *( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__ebp + 20)))) + 12)) + 8);
    while(cc.auto_detect != g1_ccs) {
        _t77 = cc.auto_detect;
        if(_t77 != 16384) {
            if(_t77 > 16384) {
                if(_t77 == 16385) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t87 = os->length;
                     *((char*)(os->ptr + _t87)) = st | -128;
                    os->length = _t87 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    return;
                }
                if(_t77 == 49152) {
                    if(( *135119022 & 255) != 0) {
                        return;
                    }
                    Strcat_charp(os, WcReplaceW);
                    return;
                }
            } else {
                if(_t77 == 322) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t109 = os->length;
                     *((char*)(os->ptr + _t109)) = st;
                    os->length = _t109 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    return;
                }
            }
            if(( *135119011 & 255) == 0) {
                if((cc.auto_detect & 98304) == 0) {
                    _t100 = 16384;
                } else {
                    _t100 = 49152;
                }
                cc.auto_detect = _t100;
            } else {
                _v32 =  *((intOrPtr*)(__ebp + 20));
                _v40 = cc.auto_detect;
                _v36 = st;
                 *__esp =  &cc;
                wc_any_to_any_ces();
                __esp = __esp - 4;
            }
            continue;
        }
        if(( *135119022 & 255) == 0) {
            Strcat_charp(os, WcReplace);
            return;
        }
        return;
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t122 = os->length;
     *((char*)(os->ptr + _t122)) = st | -128;
    os->length = _t122 + 1;
     *((char*)(os->ptr + os->length)) = 0;
}

void wc_create_gmap(wc_status* st)
{// addr = 0x080B9E12  --  defined in 'iso2022.c' at line 780
    wc_gset* gset;     // _cfa_fffffff8
    wc_uchar* gset_ext;   // _cfa_fffffff4
    int i;                                 // _cfa_fffffff0
    int f;                                 // _cfa_ffffffec
    signed int _t105;                      // _t105
    signed int _t110;                      // _t110

    gset = st->ces_info->gset;
    gset_ext = st->ces_info->gset_ext;
    if(( *135119020 & 255) == 0) {
        i = 0;
        while(i <= 63) {
             *((char*)( &cs94_gmap + i)) =  *gset_ext & 255;
             *((char*)( &cs96_gmap + i)) = gset_ext[1] & 255;
             *((char*)( &cs94w_gmap + i)) = gset_ext[2] & 255;
             *((char*)( &cs96w_gmap + i)) = gset_ext[3] & 255;
             *((char*)( &cs942_gmap + i)) =  *gset_ext & 255;
            i = i + 1;
        }
        goto L8;
    } else {
        i = 0;
        do {
        } while(i <= 63);
L8:
        i = 0;
        while( *(gset + (i << 3)) != 0) {
            f = ( *(gset + (i << 3)) & 255) - 64;
            _t105 =  *(gset + (i << 3)) & 65280;
            if(_t105 == 1024) {
                 *((char*)( &cs942_gmap + f)) = (gset + (i << 3))[1] & 255;
L35:
                i = i + 1;
                continue;
            }
            if(_t105 > 1024) {
                if(_t105 == 33024) {
                    _t110 =  *(gset + (i << 3));
                    if(_t110 == 33092) {
L24:
                        if(( *135119018 & 255) != 0) {
L29:
                             *((char*)( &cs94w_gmap + f)) = (gset + (i << 3))[1] & 255;
                            goto L35;
                        }
                        goto L35;
                    }
                    if(_t110 < 33092 || _t110 - 33103 > 1) {
                        goto L29;
                    } else {
                        if(( *135119019 & 255) == 0) {
                            goto L35;
                        } else {
                            goto L29;
                        }
                        goto L24;
                    }
                }
                if(_t105 == 33280) {
                     *((char*)( &cs96w_gmap + f)) = (gset + (i << 3))[1] & 255;
                }
                goto L35;
            }
            if(_t105 == 256) {
                if( *(gset + (i << 3)) != 329 || ( *135119017 & 255) != 0) {
                     *((char*)( &cs94_gmap + f)) = (gset + (i << 3))[1] & 255;
                }
            } else {
                if(_t105 == 512) {
                     *((char*)( &cs96_gmap + f)) = (gset + (i << 3))[1] & 255;
                }
            }
            goto L35;
        }
        return;
    }
}

Str wc_char_conv_from_iso2022(wc_uchar c, wc_status* st)
{// addr = 0x080BA052  --  defined in 'iso2022.c' at line 843
    wc_uchar* p;      // _cfa_fffffff0
    wc_ccs gl_ccs;      // _cfa_ffffffec
    wc_ccs gr_ccs;      // _cfa_ffffffe8
    char _v32;                             // _cfa_ffffffe0
    _unknown_ __ebx;                       // r1
    unsigned int _t49;                     // _t49
    unsigned int _t55;                     // _t55

    _v32 = c;
    if(st->state == -1) {
        st->state = 0;
        os.4122 = Strnew_size(8);
        nbuf = 0;
    }
    if((st->ss & 255) == 0) {
        _t49 =  *(st + ((st->gl & 0xff) + 4) * 4);
    } else {
        _t49 =  *(st + ((st->ss & 0xff) + 4) * 4);
    }
    gl_ccs = _t49;
    if((st->ss & 255) == 0) {
        _t55 =  *(st + ((st->gr & 0xff) + 4) * 4);
    } else {
        _t55 =  *(st + ((st->ss & 0xff) + 4) * 4);
    }
    gr_ccs = _t55;
    if(st->state <= 44) {
        goto __eax;
    }
    st->ss = 0;
    st->state = -1;
    return os.4122;
}

wc_wchar_t wc_jisx0201k_to_jisx0208(wc_wchar_t cc)
{// addr = 0x080BA840  --  defined in 'jis.c' at line 13
    intOrPtr _t16;                         // _t16

    __ecx = cc.auto_detect;
    _a12 =  *((_a12 & 127) +  &jisx0201k_jisx0208_map + (_a12 & 127)) & 0xffff;
    if(_a12 == 0) {
        _t16 = 49152;
    } else {
        _t16 = 33090;
    }
     *((intOrPtr*)(__ebp + 12)) = _t16;
     *__ecx =  *((intOrPtr*)(__ebp + 12));
     *(__ecx + 4) = _a12;
    return __ecx;
}

wc_wchar_t wc_jisx0212_to_jisx0213(wc_wchar_t cc)
{// addr = 0x080BA881  --  defined in 'jis.c' at line 21
    _unknown_ _v8;                         // _cfa_fffffff8
    intOrPtr _v16;                         // _cfa_fffffff0
    wc_wchar_t cc2;   // _cfa_ffffffec
    wc_table* _v32;   // _cfa_ffffffe0
    wc_table* _v36;   // _cfa_ffffffdc
    wc_table* _v40;   // _cfa_ffffffd8
    wc_table* _v44;   // _cfa_ffffffd4 (outparam)
    struct  _t29;             // _t29

    _push(__ebx);
    __esp = __esp - 36;
    _t29 = cc.auto_detect;
    if(t1.2377 == 0) {
        t1.2377 = wc_get_ucs_table(33103);
        t2.2378 = wc_get_ucs_table(33104);
    }
    _v32 = t2.2378;
    _v40 =  *(__ebp + 12);
    _v36 = _a12;
     *__esp =  &cc2;
    wc_any_to_any();
    __esp = __esp - 4;
    if(cc2.auto_detect != 33092) {
        _v36 = t1.2377;
        _v44 =  *(__ebp + 12);
        _v40 = _a12;
         *__esp = _t29;
        wc_any_to_any();
        __esp = __esp - 4;
    } else {
         *_t29 = cc2.auto_detect;
         *((intOrPtr*)(_t29 + 4)) = _v16;
    }
    return _t29;
}

wc_wchar_t wc_jisx0213_to_jisx0212(wc_wchar_t cc)
{// addr = 0x080BA91D  --  defined in 'jis.c' at line 43
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_table* _v16;   // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    struct  _t14;             // _t14

    _push(__ebx);
    __esp = __esp - 20;
    _t14 = cc.auto_detect;
    if(t.2393 == 0) {
        t.2393 = wc_get_ucs_table(33092);
    }
    _v16 = t.2393;
    _v24 =  *((intOrPtr*)(__ebp + 12));
    _v20 = _a12;
     *__esp = _t14;
    wc_any_to_any();
    __esp = __esp - 4;
    return _t14;
}

wc_ccs wc_jisx0208_or_jisx02131(wc_uint16 code)
{// addr = 0x080BA96C  --  defined in 'jis.c' at line 58
    signed short _v16;                     // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v16 = code;
    if(wc_map_range_search(_v16 & 0x7f7f, "/"9"B"I"Q"["k"q"z"}"!#/#:##[#`#{#~#t$~$w%~%9&@&Y&~&B'P'r'~'A(~/TO~O%t~~", 18) == 0) {
        return 33090;
    }
    return 33103;
}

wc_ccs wc_jisx0212_or_jisx02132(wc_uint16 code)
{// addr = 0x080BA9AC  --  defined in 'jis.c' at line 66
    signed short _v8;                      // _cfa_fffffff8

    _v8 = code;
    if(( *(wc_jisx0212_jisx02132_map + ((_v8 & 65535) >> 8 & 0x7f)) & 255) == 0) {
        return 33092;
    }
    return 33104;
}

wc_wchar_t wc_johab_to_ksx1001(wc_wchar_t cc)
{// addr = 0x080BA9E4  --  defined in 'johab.c' at line 74
    _unknown_ _v8;                         // _cfa_fffffff8
    unsigned int _v16;                     // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    wc_table* _v32;   // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4 (outparam)
    unsigned int _t26;                     // _t26
    struct  _t39;             // _t39

    _push(__ebx);
    __esp = __esp - 36;
    _t39 = cc.auto_detect;
    _t26 =  *(__ebp + 12);
    if(_t26 > 34833) {
        if(_t26 == 34834) {
            if(_a12 <= 8480) {
                 *(__ebp + 12) = 49152;
            } else {
                 *(__ebp + 12) = 33091;
            }
        }
L15:
         *_t39 =  *(__ebp + 12);
         *((intOrPtr*)(_t39 + 4)) = _a12;
L16:
        return _t39;
    }
    if(_t26 >= 34832) {
        if(( *135119011 & 255) == 0) {
             *(__ebp + 12) = 49152;
        } else {
            if(t.2389 == 0) {
                t.2389 = wc_get_ucs_table(33091);
            }
            _v32 = t.2389;
            _v40 =  *(__ebp + 12);
            _v36 = _a12;
             *__esp = __ebp + 12;
            wc_any_to_any();
            __esp = __esp - 4;
        }
        goto L15;
    }
    if(_t26 == 34831) {
        _v40 =  *(__ebp + 12);
        _v36 = _a12;
         *__esp =  &_v20;
        wc_johab_to_cs128w();
        __esp = __esp - 4;
        _v44 = _v20;
        _v40 = _v16;
         *__esp = _t39;
        wc_johab_to_ksx1001();
        __esp = __esp - 4;
        goto L16;
    } else {
        goto L15;
    }
}

wc_wchar_t wc_ksx1001_to_johab(wc_wchar_t cc)
{// addr = 0x080BAAD5  --  defined in 'johab.c' at line 105
    _unknown_ _v8;                         // _cfa_fffffff8
    unsigned int _v24;                     // _cfa_ffffffe8
    struct  _t39;             // _t39

    _push(__ebx);
    __esp = __esp - 20;
    _t39 = cc.auto_detect;
    _a12 = _a12 & 32639;
    if(_a12 <= 8480 || _a12 > 9248) {
        if(_a12 <= 9299 || _a12 > 11390) {
            if(_a12 <= 18976 || _a12 > 32126) {
                if(( *135119011 & 255) == 0) {
                     *(__ebp + 12) = 49152;
                } else {
                     *__esp =  *(__ebp + 12);
                    _v24 = _a12;
                    _v24 = wc_any_to_ucs();
                    wc_ucs_to_johab(__ebp + 12);
                    __esp = __esp - 4;
                }
                 *_t39 =  *(__ebp + 12);
                 *(_t39 + 4) = _a12;
                goto L11;
            } else {
                goto L6;
            }
        } else {
            goto L6;
        }
    } else {
L6:
         *(__ebp + 12) = 34834;
         *_t39 =  *(__ebp + 12);
         *(_t39 + 4) = _a12;
L11:
        return _t39;
    }
}

wc_wchar_t wc_ucs_to_johab(wc_uint32 ucs)
{// addr = 0x080BAB86  --  defined in 'johab.c' at line 125
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_table* t;      // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    wc_wchar_t cc;   // _cfa_ffffffe8
    unsigned int _v32;                     // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    wc_table* _v52;   // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    struct  _t41;             // _t41

    _push(__ebx);
    __esp = __esp - 52;
    _t41 = ucs;
    if( *(__ebp + 12) <= 44031 ||  *(__ebp + 12) > 55203) {
        if( *(__ebp + 12) <= 12592 ||  *(__ebp + 12) > 12643) {
            t = wc_get_ucs_table(34834);
            _v52 = t;
            wc_ucs_to_any( &_v36,  *(__ebp + 12));
            __esp = __esp - 4;
            cc.auto_detect = _v36;
            _v20 = _v32;
        } else {
            t = wc_get_ucs_table(34833);
            _v52 = t;
            wc_ucs_to_any( &cc,  *(__ebp + 12));
            __esp = __esp - 4;
        }
    } else {
         *(__ebp + 12) =  *(__ebp + 12) - 44032;
        _v20 = wc_N_to_johab1( *(__ebp + 12));
        cc.auto_detect = 34831;
    }
     *_t41 = cc.auto_detect;
     *(_t41 + 4) = _v20;
    return _t41;
}

wc_uint32 wc_johab1_to_N(wc_uint32 code)
{// addr = 0x080BAC4A  --  defined in 'johab.c' at line 146
    wc_uint32 a;     // _cfa_fffffff8
    wc_uint32 b;     // _cfa_fffffff4
    wc_uint32 c;     // _cfa_fffffff0

    a =  *( &johab1_N_map + (code >> 10 & 31)) & 0xff;
    b =  *((code >> 5 & 31) + 135118400) & 0xff;
    c =  *((code & 31) + 135118432) & 0xff;
    if(a != 0 && b != 0 && c != 0) {
        return (((a << 2) + a << 2) + a + b << 2) * 8 - (((a << 2) + a << 2) + a + b << 2) + c - 617;
    }
    return -1;
}

wc_uint32 wc_N_to_johab1(wc_uint32 code)
{// addr = 0x080BACD4  --  defined in 'johab.c' at line 159
    wc_uint32 a;     // _cfa_fffffff8
    wc_uint32 b;     // _cfa_fffffff4
    wc_uint32 c;     // _cfa_fffffff0
    signed int _v24;                       // _cfa_ffffffe8
    unsigned int _t75;                     // _t75

    _v24 = code;
    a =  *( &N_johab1_map + (_v24 * -555131827 >> 32 >> 9)) & 0xff;
    _v24 = code >> 2;
    b =  *((_v24 * 613566757 >> 32) - ((((_v24 * 613566757 >> 32) * -2045222521 >> 32) + (_t74 - -2045222521 >> 1) >> 4 << 2) + (((_v24 * 613566757 >> 32) * -2045222521 >> 32) + (_t74 - -2045222521 >> 1) >> 4) << 2) + (((_v24 * 613566757 >> 32) * -2045222521 >> 32) + (_t74 - -2045222521 >> 1) >> 4) + 135118496) & 0xff;
    _t75 = code;
    _v24 = _t75 >> 2;
    c =  *(_t75 - (_v24 * 613566757 >> 32 << 2) * 8 - (_v24 * 613566757 >> 32 << 2) + 135118528) & 0xff;
    return b << 5 | a << 10 | c | 128;
}

wc_wchar_t wc_johab_to_cs128w(wc_wchar_t cc)
{// addr = 0x080BAD93  --  defined in 'johab.c' at line 200
    wc_uchar ub;      // _cfa_fffffff7
    wc_uchar lb;      // _cfa_fffffff6
    wc_uint32 n;     // _cfa_fffffff0
    struct  __ebx;            // r1
    _unknown_ _t58;                        // _t58
    _unknown_ _t71;                        // _t71
    _unknown_ _t92;                        // _t92

    __ebx = cc.auto_detect;
    if(_a12 > 55295) {
        ub = _a12 >> 8;
        lb = _a12;
        if(ub > 223) {
            ub = (ub & 255) + 32 + (ub & 255) + 32 + 74;
        } else {
            ub = (ub & 255) + 40 + (ub & 255) + 40 + 31;
        }
        if(lb > 160) {
            ub = ub + 1;
            lb = lb + 128;
        } else {
            if(lb > 144) {
                _t58 = 34;
            } else {
                _t58 = 16;
            }
            lb = lb - _t58;
        }
        _a12 = lb & 255 | (ub & 255) << 8;
         *((intOrPtr*)(__ebp + 12)) = 34834;
    } else {
        n = wc_johab1_to_N(_a12);
        if(n == -1) {
            _t92 = (_a12 >> 8 & 255) * 188 + (_a12 & 255);
            if((_a12 & 255) > 128) {
                _t71 = 67;
            } else {
                _t71 = 65;
            }
            n = _t92 - _t71 - 24816;
            _a12 = (n >> 7 << 8) + (n & 127);
             *((intOrPtr*)(__ebp + 12)) = 34833;
        } else {
            _a12 = ((n >> 7) + 33 << 8) + (n & 127);
             *((intOrPtr*)(__ebp + 12)) = 34832;
        }
    }
     *__ebx =  *((intOrPtr*)(__ebp + 12));
     *(__ebx + 4) = _a12;
    return __ebx;
}

wc_wchar_t wc_cs128w_to_johab(wc_wchar_t cc)
{// addr = 0x080BAED3  --  defined in 'johab.c' at line 226
    wc_uchar ub;      // _cfa_ffffffef
    wc_uchar lb;      // _cfa_ffffffee
    wc_uint32 n;     // _cfa_ffffffe8
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    struct  __esi;            // r5
    intOrPtr _t61;                         // _t61
    _unknown_ _t83;                        // _t83
    _unknown_ _t95;                        // _t95
    _unknown_ _t104;                       // _t104
    _unknown_ _t122;                       // _t122
    signed int _t139;                      // _t139

    __esi = cc.auto_detect;
    _t61 =  *((intOrPtr*)(__ebp + 12));
    if(_t61 == 34833) {
        n = ((_a12 >> 8 & 127) << 7) + (_a12 & 127);
        _v36 = n;
        _t139 = (_v36 * -1370734243 >> 32 >> 7) + 132 << 8;
        _t122 = n - (n * -1370734243 >> 32 >> 7) * 188;
        if(n - (n * -1370734243 >> 32 >> 7) * 188 > 61) {
            _t83 = 67;
        } else {
            _t83 = 65;
        }
        _a12 = _t139 + _t122 + _t83;
    } else {
        if(_t61 == 34834) {
            ub = _a12 >> 8 & 127;
            lb = _a12 & 127;
            if(ub > 73) {
                ub = ub - 74;
                if((ub & 1) == 0) {
                    if(lb > 110) {
                        _t95 = 34;
                    } else {
                        _t95 = 16;
                    }
                } else {
                    _t95 = -128;
                }
                lb = lb + _t95;
                ub = ((ub & 255) >> 1) - 32;
            } else {
                ub = ub - 31;
                if((ub & 1) == 0) {
                    if(lb > 110) {
                        _t104 = 34;
                    } else {
                        _t104 = 16;
                    }
                } else {
                    _t104 = -128;
                }
                lb = lb + _t104;
                ub = ((ub & 255) >> 1) - 40;
            }
            _a12 = lb & 255 | (ub & 255) << 8;
        } else {
            if(_t61 == 34832) {
                n = ((_a12 >> 8 & 127) + 33554399 << 7) + (_a12 & 127);
                _a12 = wc_N_to_johab1(n);
            }
        }
    }
     *((intOrPtr*)(__ebp + 12)) = 34831;
     *__esi =  *((intOrPtr*)(__ebp + 12));
     *(__esi + 4) = _a12;
    return __esi;
}

Str wc_conv_from_johab(Str is, wc_ces ces)
{// addr = 0x080BB07C  --  defined in 'johab.c' at line 251
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    int state;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    int _t102;                             // _t102
    signed int _t144;                      // _t144
    int _t153;                             // _t153

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    p = sp;
    do {
    } while(p < ep && ( *p & 255) >= 0);
    if(p != ep) {
        os = Strnew_size(is->length);
        if(p > sp) {
            Strcat_charp_n(os, is->ptr, p - sp);
        }
        while(p < ep) {
            _t102 = state;
            if(_t102 == 1) {
                if(( *( &WC_JOHAB_MAP + ( *p & 0xff)) & 0x10) == 0) {
                    wtf_push_unknown(os, p - 1, 2);
                } else {
                    wtf_push(os, 34831,  *p & 0xff | ( *(p - 1) & 0xff) << 8);
                }
                state = 0;
L29:
                p =  &(p[1]);
                continue;
            }
            if(_t102 == 2) {
                if(( *( &WC_JOHAB_MAP + ( *p & 0xff)) & 0x20) == 0) {
                    wtf_push_unknown(os, p - 1, 2);
                } else {
                    wtf_push(os, 34831,  *p & 0xff | ( *(p - 1) & 0xff) << 8);
                }
                state = 0;
                goto L29;
            }
            if(_t102 != 0) {
                goto L29;
            }
            _t144 =  *( &WC_JOHAB_MAP + ( *p & 0xff)) & 0xf;
            if(_t144 == 4) {
                state = 2;
L20:
                goto L29;
            }
            if(_t144 == 8) {
                wtf_push_unknown(os, p, 1);
                goto L20;
            }
            if(_t144 != 2) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t153 = os->length;
                 *((char*)(os->ptr + _t153)) =  *p & 255;
                os->length = _t153 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                goto L29;
            }
            state = 1;
            goto L20;
        }
        if(state - 1 <= 1) {
            wtf_push_unknown(os, p - 1, 1);
        }
        return os;
    }
    return is;
}

void wc_push_to_johab(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080BB2FB  --  defined in 'johab.c' at line 311
    wc_status* _v16;   // _cfa_fffffff0
    unsigned char _v20;                    // _cfa_ffffffec
    intOrPtr _v32;                         // _cfa_ffffffe0
    wc_status* _v36;   // _cfa_ffffffdc
    unsigned char _v40;                    // _cfa_ffffffd8 (outparam)
    unsigned char _t84;                    // _t84
    int _t91;                              // _t91
    int _t103;                             // _t103
    unsigned char _t118;                   // _t118
    int _t133;                             // _t133

    while(1) {
        _t84 = cc.auto_detect;
        if(_t84 == 34831) {
            break;
        }
        if(_t84 > 34831) {
            if(_t84 <= 34834) {
                _v40 = cc.auto_detect;
                _v36 = st;
                 *__esp =  &cc;
                wc_cs128w_to_johab();
                __esp = __esp - 4;
                break;
            }
            if(_t84 == 49152) {
                if(( *135119022 & 255) != 0) {
                    return;
                }
                Strcat_charp(os, WcReplaceW);
                return;
            }
L24:
            if(( *135119011 & 255) == 0) {
                if((cc.auto_detect & 98304) == 0) {
                    _t118 = 16384;
                } else {
                    _t118 = 49152;
                }
                cc.auto_detect = _t118;
            } else {
                _v32 =  *((intOrPtr*)(__ebp + 20));
                _v40 = cc.auto_detect;
                _v36 = st;
                 *__esp =  &_v20;
                wc_any_to_any_ces();
                __esp = __esp - 4;
                cc.auto_detect = _v20;
                st = _v16;
            }
            continue;
        }
        if(_t84 != 16384) {
            if(_t84 == 33091) {
                _v40 = cc.auto_detect;
                _v36 = st;
                 *__esp =  &_v20;
                wc_ksx1001_to_johab();
                __esp = __esp - 4;
                cc.auto_detect = _v20;
                st = _v16;
                continue;
            } else {
                if(_t84 == 322) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t133 = os->length;
                     *((char*)(os->ptr + _t133)) = st;
                    os->length = _t133 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    return;
                }
                goto L24;
            }
L31:
            return;
        }
        if(( *135119022 & 255) == 0) {
            Strcat_charp(os, WcReplace);
            return;
        }
        goto L31;
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t91 = os->length;
     *((char*)(os->ptr + _t91)) = st >> 8;
    os->length = _t91 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t103 = os->length;
     *((char*)(os->ptr + _t103)) = st;
    os->length = _t103 + 1;
     *((char*)(os->ptr + os->length)) = 0;
}

Str wc_char_conv_from_johab(wc_uchar c, wc_status* st)
{// addr = 0x080BB538  --  defined in 'johab.c' at line 350
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t41;                              // _t41
    signed int _t63;                       // _t63
    struct _Str* _t72;    // _t72
    int _t94;                              // _t94

    _v16 = c;
    if(st->state == -1) {
        st->state = 0;
        os.2826 = Strnew_size(8);
    }
    _t41 = st->state;
    if(_t41 == 1) {
        if(( *( &WC_JOHAB_MAP + (_v16 & 255)) & 0x10) != 0) {
            wtf_push(os.2826, 34831, (johabu & 0xff) << 8 | _v16 & 255);
        }
L19:
        st->state = -1;
        return os.2826;
    }
    if(_t41 == 2) {
        if(( *( &WC_JOHAB_MAP + (_v16 & 255)) & 0x20) != 0) {
            wtf_push(os.2826, 34831, (johabu & 0xff) << 8 | _v16 & 255);
        }
        goto L19;
    }
    if(_t41 != 0) {
        goto L19;
    }
    _t63 =  *( &WC_JOHAB_MAP + (_v16 & 255)) & 0xf;
    if(_t63 == 4) {
        johabu = _v16 & 255;
        st->state = 2;
        return 0;
    }
    if(_t63 == 8) {
        goto L19;
    }
    if(_t63 != 2) {
        if(os.2826->length + 1 >= os.2826->area_size) {
            Strgrow(os.2826);
        }
        _t72 = os.2826;
        _t94 = _t72->length;
         *((char*)( *os.2826 + _t94)) = _v16 & 255;
        _t72->length = _t94 + 1;
         *((char*)( *os.2826 + os.2826->length)) = 0;
        goto L19;
    }
    johabu = _v16 & 255;
    st->state = 1;
    return 0;
}

void wc_putc_init(wc_ces f_ces, wc_ces t_ces)
{// addr = 0x080BB6E8  --  defined in 'putc.c' at line 10
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    wc_output_init(t_ces,  &putc_st);
    putc_str = Strnew_size(8);
    putc_f_ces = f_ces;
    putc_t_ces = t_ces;
}

void wc_putc(char* c, FILE* f)
{// addr = 0x080BB724  --  defined in 'putc.c' at line 19
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_uchar* p;      // _cfa_fffffff0
    wc_uchar** _v20;   // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    FILE* _v32;           // _cfa_ffffffe0
    int _v36;                              // _cfa_ffffffdc (outparam)
    wc_uchar** _v40;   // _cfa_ffffffd8 (outparam)
    wc_uchar* _v44;   // _cfa_ffffffd4 (outparam)

    _push(__ebx);
    __esp = __esp - 36;
    if(putc_f_ces == 3211264) {
        p = c;
    } else {
        p =  *(wc_Str_conv(Strnew_charp(c), putc_f_ces, 3211264));
    }
    Strclear(putc_str);
    while(( *p & 255) != 0) {
        _v40 =  &p;
        wtf_parse( &_v24);
        __esp = __esp - 4;
        _v36 =  &putc_st;
        _v44 = _v24;
        _v40 = _v20;
         *__esp = putc_str;
         *((intOrPtr*)( *((intOrPtr*)(putc_st.auto_detect + 24))))();
    }
    _v32 = f;
    _v36 = putc_str->length;
    _v40 = 1;
     *__esp = putc_str->ptr;
    fwrite();
}

void wc_putc_end(FILE* f)
{// addr = 0x080BB7F1  --  defined in 'putc.c' at line 35
    FILE* _v16;           // _cfa_fffffff0
    int _v20;                              // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8 (outparam)

    Strclear(putc_str);
    wc_push_end(putc_str,  &putc_st);
    if(putc_str->length != 0) {
        _v16 = f;
        _v20 = putc_str->length;
        _v24 = 1;
         *__esp = putc_str->ptr;
        fwrite();
        return;
    }
}

void wc_putc_clear_status()
{// addr = 0x080BB853  --  defined in 'putc.c' at line 44
    if(( *(putc_st.auto_detect) & 2048) != 0) {
         *135790405 = 0;
         *135790404 = 0;
         *135790406 = 0;
         *135790416 = 0;
         *135790420 = 0;
         *135790424 = 0;
         *135790428 = 0;
        return;
    }
}

int map_cmp(* a, * b)
{// addr = 0x080BB8A8  --  defined in 'search.c' at line 6
    return ( *a & 0xffff) - ( *b & 0xffff);
}

int map3_cmp(* a, * b)
{// addr = 0x080BB8C5  --  defined in 'search.c' at line 12
    return  *a - ( *(b + 2) & 0xffff | ( *b & 0xffff) << 16);
}

int map_range_cmp(* a, * b)
{// addr = 0x080BB8EF  --  defined in 'search.c' at line 18
    if(( *a & 65535) < ( *b & 65535)) {
        return -1;
    }
    return ( *a & 65535) - ( *(b + 2) & 65535) > 0 & 255;
}

int map2_range_cmp(* a, * b)
{// addr = 0x080BB922  --  defined in 'search.c' at line 25
    if(( *a & 65535) < ( *b & 65535)) {
        return -1;
    }
    return ( *a & 65535) - ( *(b + 4) & 65535) >= 0 & 255;
}

int map3_range_cmp(* a, * b)
{// addr = 0x080BB957  --  defined in 'search.c' at line 32
    if(( *a & 65535) < ( *b & 65535)) {
        return -1;
    }
    return ( *a & 65535) - ( *(b + 2) & 65535) > 0 & 255;
}

wc_map* wc_map_search(wc_uint16 code, wc_map* map, size_t n)
{// addr = 0x080BB98A  --  defined in 'search.c' at line 39
    struct  _v16;             // _cfa_fffffff0
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    wc_map* _v56;       // _cfa_ffffffc8

    _v16 = code;
    _v44 = map_cmp;
    _v48 = 4;
    _v52 = n;
    _v56 = map;
     *__esp =  &_v16;
    bsearch();
    return  &_v16;
}

wc_map3* wc_map3_search(wc_uint16 c1, wc_uint16 c2, wc_map3* map, size_t n)
{// addr = 0x080BB9C2  --  defined in 'search.c' at line 46
    wc_uint32 code;   // _cfa_fffffff0
    signed short _v32;                     // _cfa_ffffffe0
    signed short _v36;                     // _cfa_ffffffdc
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    unsigned int _v68;                     // _cfa_ffffffbc
    wc_map3* _v72;     // _cfa_ffffffb8

    _v32 = c1;
    _v36 = c2;
    code = _v36 & 65535 | (_v32 & 65535) << 16;
    _v60 = map3_cmp;
    _v64 = 6;
    _v68 = n;
    _v72 = map;
     *__esp =  &code;
    bsearch();
    return  &code;
}

wc_map* wc_map_range_search(wc_uint16 code, wc_map* map, int n)
{// addr = 0x080BBA13  --  defined in 'search.c' at line 54
    struct  _v16;             // _cfa_fffffff0
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    int _v52;                              // _cfa_ffffffcc
    wc_map* _v56;       // _cfa_ffffffc8

    _v16 = code;
    _v44 = map_range_cmp;
    _v48 = 4;
    _v52 = n;
    _v56 = map;
     *__esp =  &_v16;
    bsearch();
    return  &_v16;
}

wc_map* wc_map2_range_search(wc_uint16 code, wc_map* map, size_t n)
{// addr = 0x080BBA4B  --  defined in 'search.c' at line 61
    struct  _v16;             // _cfa_fffffff0
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    wc_map* _v56;       // _cfa_ffffffc8

    _v16 = code;
    _v44 = map2_range_cmp;
    _v48 = 4;
    _v52 = n;
    _v56 = map;
     *__esp =  &_v16;
    bsearch();
    return  &_v16;
}

wc_map3* wc_map3_range_search(wc_uint16 code, wc_map3* map, size_t n)
{// addr = 0x080BBA83  --  defined in 'search.c' at line 68
    struct  _v16;             // _cfa_fffffff0
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    wc_map3* _v56;     // _cfa_ffffffc8

    _v16 = code;
    _v44 = map3_range_cmp;
    _v48 = 6;
    _v52 = n;
    _v56 = map;
     *__esp =  &_v16;
    bsearch();
    return  &_v16;
}

wc_wchar_t wc_sjis_to_jis(wc_wchar_t cc)
{// addr = 0x080BBABC  --  defined in 'sjis.c' at line 80
    wc_uchar ub;      // _cfa_fffffffb
    wc_uchar lb;      // _cfa_fffffffa
    _unknown_ _t54;                        // _t54
    _unknown_ _t55;                        // _t55
    _unknown_ _t59;                        // _t59

    __ecx = cc.auto_detect;
    ub = _a12 >> 8;
    lb = _a12;
    if(ub > 239) {
        if(lb > 158) {
            ub =  *((ub & 255) - 240 + "($,.nprtvxz|~") & 255;
            lb = lb - 126;
        } else {
            ub =  *((ub & 255) - 240 + "!#%-/oqsuwy{}") & 255;
            if(lb <= 126) {
                _t54 = 31;
            } else {
                _t54 = 32;
            }
            lb = lb - _t54;
        }
         *((intOrPtr*)(__ebp + 12)) = 33104;
    } else {
        if(ub > 159) {
            _t55 = -63;
        } else {
            _t55 = -127;
        }
        ub = ub - _t55;
        ub = (ub & 255) + (ub & 255) + 33;
        if(lb > 158) {
            ub = ub + 1;
            lb = lb - 126;
        } else {
            if(lb <= 126) {
                _t59 = 31;
            } else {
                _t59 = 32;
            }
            lb = lb - _t59;
        }
         *((intOrPtr*)(__ebp + 12)) = 33090;
    }
    _a12 = lb & 255 | (ub & 255) << 8;
     *__ecx =  *((intOrPtr*)(__ebp + 12));
     *(__ecx + 4) = _a12;
    return __ecx;
}

wc_wchar_t wc_jis_to_sjis(wc_wchar_t cc)
{// addr = 0x080BBB9A  --  defined in 'sjis.c' at line 98
    wc_uchar ub;      // _cfa_fffffffb
    wc_uchar lb;      // _cfa_fffffffa
    _unknown_ _t46;                        // _t46
    _unknown_ _t50;                        // _t50
    _unknown_ _t58;                        // _t58

    __ecx = cc.auto_detect;
    ub = _a12 >> 8 & 127;
    lb = _a12 & 127;
    if( *((intOrPtr*)(__ebp + 12)) != 33104) {
        if((ub & 1) == 0) {
            _t46 = 125;
        } else {
            _t46 = 31;
        }
        lb = lb + _t46;
        if(lb > 126) {
            lb = lb + 1;
        }
        ub = (ub & 255) - 33 >> 1;
        if(ub > 30) {
            _t50 = -63;
        } else {
            _t50 = -127;
        }
        ub = ub + _t50;
        goto L17;
    } else {
        if((ub & 1) == 0) {
            _t58 = 125;
        } else {
            _t58 = 31;
        }
        lb = lb + _t58;
        if(lb > 126) {
            lb = lb + 1;
        }
        ub =  *( &jisx02132_sjis_map + (ub & 255)) & 255;
        if(ub != 0) {
L17:
            _a12 = lb & 255 | (ub & 255) << 8;
             *__ecx =  *((intOrPtr*)(__ebp + 12));
             *(__ecx + 4) = _a12;
        } else {
             *((intOrPtr*)(__ebp + 12)) = 49152;
             *__ecx =  *((intOrPtr*)(__ebp + 12));
             *(__ecx + 4) = _a12;
        }
    }
    return __ecx;
}

wc_wchar_t wc_sjis_ext_to_cs94w(wc_wchar_t cc)
{// addr = 0x080BBC76  --  defined in 'sjis.c' at line 118
    wc_uchar ub;      // _cfa_fffffffb
    wc_uchar lb;      // _cfa_fffffffa
    _unknown_ _t33;                        // _t33
    _unknown_ _t42;                        // _t42

    __ecx = cc.auto_detect;
    ub = _a12 >> 8;
    lb = _a12;
    if(ub > 159) {
        _t33 = -63;
    } else {
        _t33 = -127;
    }
    ub = ub - _t33;
    ub = (ub & 255) + (ub & 255) + 33;
    if(lb > 158) {
        ub = ub + 1;
        lb = lb - 126;
    } else {
        if(lb <= 126) {
            _t42 = 31;
        } else {
            _t42 = 32;
        }
        lb = lb - _t42;
    }
    if(ub > 126) {
        ub = ub - 94;
         *((intOrPtr*)(__ebp + 12)) = 34837;
    } else {
         *((intOrPtr*)(__ebp + 12)) = 34836;
    }
    _a12 = lb & 255 | (ub & 255) << 8;
     *__ecx =  *((intOrPtr*)(__ebp + 12));
     *(__ecx + 4) = _a12;
    return __ecx;
}

wc_wchar_t wc_cs94w_to_sjis_ext(wc_wchar_t cc)
{// addr = 0x080BBD11  --  defined in 'sjis.c' at line 136
    wc_uchar ub;      // _cfa_fffffffb
    wc_uchar lb;      // _cfa_fffffffa
    _unknown_ _t35;                        // _t35
    _unknown_ _t39;                        // _t39

    __ecx = cc.auto_detect;
    ub = _a12 >> 8 & 127;
    lb = _a12 & 127;
    if( *((intOrPtr*)(__ebp + 12)) == 34837) {
        ub = ub + 94;
    }
    if((ub & 1) == 0) {
        _t35 = 125;
    } else {
        _t35 = 31;
    }
    lb = lb + _t35;
    if(lb > 126) {
        lb = lb + 1;
    }
    ub = (ub & 255) - 33 >> 1;
    if(ub > 30) {
        _t39 = -63;
    } else {
        _t39 = -127;
    }
    ub = ub + _t39;
     *((intOrPtr*)(__ebp + 12)) = 34835;
    _a12 = lb & 255 | (ub & 255) << 8;
     *__ecx =  *((intOrPtr*)(__ebp + 12));
     *(__ecx + 4) = _a12;
    return __ecx;
}

wc_uint32 wc_sjis_ext1_to_N(wc_uint32 c)
{// addr = 0x080BBDAC  --  defined in 'sjis.c' at line 151
    wc_uchar ub;      // _cfa_fffffffb
    signed int _t12;                       // _t12

    ub = c >> 8 & 127;
    _t12 = ub & 255;
    if(_t12 == 45) {
        ub = 0;
L7:
        return (ub & 255) * 94 + (c & 127) - 33;
    }
    if(_t12 < 45 || _t12 - 121 > 3) {
        return -1;
    } else {
        ub = ub - 120;
        goto L7;
    }
}

wc_uint32 wc_sjis_ext2_to_N(wc_uint32 c)
{// addr = 0x080BBDFD  --  defined in 'sjis.c' at line 173
    wc_uchar ub;      // _cfa_fffffffb

    ub = c >> 8 & 127;
    if((ub & 255) - 53 > 4) {
        return -1;
    }
    ub = ub - 48;
    return (ub & 255) * 94 + (c & 127) - 33;
}

Str wc_conv_from_sjis(Str is, wc_ces ces)
{// addr = 0x080BBE3A  --  defined in 'sjis.c' at line 193
    signed int _v13;                       // _cfa_fffffff3
    wc_uchar[1] jis;   // _cfa_fffffff2
    Str os;                // _cfa_ffffffec
    wc_uchar* sp;     // _cfa_ffffffe8
    wc_uchar* ep;     // _cfa_ffffffe4
    wc_uchar* p;      // _cfa_ffffffe0
    int state;                             // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    wc_wchar_t cc;   // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    int _t126;                             // _t126
    _unknown_ _t160;                       // _t160
    _unknown_ _t191;                       // _t191
    int _t205;                             // _t205
    signed int _t234;                      // _t234
    signed int _t246;                      // _t246

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    p = sp;
    do {
    } while(p < ep && ( *p & 255) >= 0);
    if(p == ep) {
        return is;
    }
    os = Strnew_size(is->length);
    if(p > sp) {
        Strcat_charp_n(os, is->ptr, p - sp);
    }
    while(p < ep) {
        _t126 = state;
        if(_t126 > 2) {
            if(_t126 == 3) {
                if(( *( &WC_SJIS_MAP + ( *p & 0xff)) & 0x10) == 0) {
                    wtf_push_unknown(os, p - 1, 2);
                } else {
                    wtf_push(os, 34835,  *p & 0xff | ( *(p - 1) & 0xff) << 8);
                }
                state = 0;
            }
L38:
            p =  &(p[1]);
            continue;
        }
        if(_t126 >= 1) {
            if(( *( &WC_SJIS_MAP + ( *p & 0xff)) & 0x10) == 0) {
                wtf_push_unknown(os, p - 1, 2);
            } else {
                jis =  *(p - 1) & 255;
                _v13 =  *p & 255;
                _t234 = jis & 255;
                if((jis & 255) > 159) {
                    _t160 = -63;
                } else {
                    _t160 = -127;
                }
                jis = _t234 - _t160;
                jis = (jis & 255) + (jis & 255) + 33;
                if((_v13 & 255) > 158) {
                    jis = (jis & 255) + 1;
                    _v13 = (_v13 & 255) - 126;
                } else {
                    _t246 = _v13 & 255;
                    if((_v13 & 255) <= 126) {
                        _t191 = 31;
                    } else {
                        _t191 = 32;
                    }
                    _v13 = _t246 - _t191;
                }
                _v40 = _v13 & 0xff | (jis & 0xff) << 8;
                cc.auto_detect = wc_jisx0208_or_jisx02131(_v40 & 65535);
                if(cc.auto_detect != 33090) {
                    wtf_push(os, 34835,  *p & 0xff | ( *(p - 1) & 0xff) << 8);
                } else {
                    wtf_push(os, cc.auto_detect, _v40);
                }
            }
            state = 0;
            goto L38;
        }
        if(_t126 == 0) {
            if(( *( &WC_SJIS_MAP + ( *p & 0xff)) & 0xff) - 18 > 46) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t205 = os->length;
                 *((char*)(os->ptr + _t205)) =  *p & 255;
                os->length = _t205 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                goto L38;
            }
            goto __eax;
        }
        goto L38;
    }
    if(state - 1 <= 2) {
        wtf_push_unknown(os, p - 1, 1);
    }
    return os;
}

Str wc_conv_from_sjisx0213(Str is, wc_ces ces)
{// addr = 0x080BC1CA  --  defined in 'sjis.c' at line 273
    signed int _v13;                       // _cfa_fffffff3
    wc_uchar[1] jis;   // _cfa_fffffff2
    Str os;                // _cfa_ffffffec
    wc_uchar* sp;     // _cfa_ffffffe8
    wc_uchar* ep;     // _cfa_ffffffe4
    wc_uchar* p;      // _cfa_ffffffe0
    int state;                             // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    wc_wchar_t cc;   // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    int _t136;                             // _t136
    _unknown_ _t169;                       // _t169
    _unknown_ _t186;                       // _t186
    _unknown_ _t207;                       // _t207
    int _t221;                             // _t221
    signed int _t252;                      // _t252
    signed int _t253;                      // _t253
    signed int _t263;                      // _t263

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    p = sp;
    do {
    } while(p < ep && ( *p & 255) >= 0);
    if(p == ep) {
        return is;
    }
    os = Strnew_size(is->length);
    if(p > sp) {
        Strcat_charp_n(os, is->ptr, p - sp);
    }
    while(p < ep) {
        _t136 = state;
        if(_t136 > 2) {
            if(_t136 == 3) {
                if(( *( &WC_SJIS_MAP + ( *p & 0xff)) & 0x10) == 0) {
                    wtf_push_unknown(os, p - 1, 2);
                } else {
                    jis =  *(p - 1) & 255;
                    _v13 =  *p & 255;
                    if((_v13 & 255) > 158) {
                        jis =  *((jis & 0xff) - 240 + "($,.nprtvxz|~") & 255;
                        _v13 = (_v13 & 255) - 126;
                    } else {
                        jis =  *((jis & 0xff) - 240 + "!#%-/oqsuwy{}") & 255;
                        _t252 = _v13 & 255;
                        if((_v13 & 255) <= 126) {
                            _t169 = 31;
                        } else {
                            _t169 = 32;
                        }
                        _v13 = _t252 - _t169;
                    }
                    wtf_push(os, 33104, _v13 & 0xff | (jis & 0xff) << 8);
                }
                state = 0;
            }
L42:
            p =  &(p[1]);
            continue;
        }
        if(_t136 >= 1) {
            if(( *( &WC_SJIS_MAP + ( *p & 0xff)) & 0x10) == 0) {
                wtf_push_unknown(os, p - 1, 2);
            } else {
                jis =  *(p - 1) & 255;
                _v13 =  *p & 255;
                _t253 = jis & 255;
                if((jis & 255) > 159) {
                    _t186 = -63;
                } else {
                    _t186 = -127;
                }
                jis = _t253 - _t186;
                jis = (jis & 255) + (jis & 255) + 33;
                if((_v13 & 255) > 158) {
                    jis = (jis & 255) + 1;
                    _v13 = (_v13 & 255) - 126;
                } else {
                    _t263 = _v13 & 255;
                    if((_v13 & 255) <= 126) {
                        _t207 = 31;
                    } else {
                        _t207 = 32;
                    }
                    _v13 = _t263 - _t207;
                }
                _v40 = _v13 & 0xff | (jis & 0xff) << 8;
                cc.auto_detect = wc_jisx0208_or_jisx02131(_v40 & 65535);
                wtf_push(os, cc.auto_detect, _v40);
            }
            state = 0;
            goto L42;
        }
        if(_t136 == 0) {
            if(( *( &WC_SJIS_MAP + ( *p & 0xff)) & 0xff) - 18 > 46) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t221 = os->length;
                 *((char*)(os->ptr + _t221)) =  *p & 255;
                os->length = _t221 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                goto L42;
            }
            goto __eax;
        }
        goto L42;
    }
    if(state - 1 <= 2) {
        wtf_push_unknown(os, p - 1, 1);
    }
    return os;
}

void wc_push_to_sjis(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080BC591  --  defined in 'sjis.c' at line 353
    wc_uchar ub;      // _cfa_fffffff3
    wc_uchar lb;      // _cfa_fffffff2
    wc_status* _v32;   // _cfa_ffffffe0
    unsigned char _v36;                    // _cfa_ffffffdc
    intOrPtr _v48;                         // _cfa_ffffffd0
    wc_status* _v52;   // _cfa_ffffffcc
    unsigned char _v56;                    // _cfa_ffffffc8 (outparam)
    unsigned char _t151;                   // _t151
    _unknown_ _t159;                       // _t159
    _unknown_ _t163;                       // _t163
    int _t170;                             // _t170
    int _t182;                             // _t182
    unsigned char _t196;                   // _t196
    int _t208;                             // _t208
    int _t220;                             // _t220
    int _t237;                             // _t237
    int _t253;                             // _t253

    while(1) {
        _t151 = cc.auto_detect;
        if(_t151 == 33090) {
            break;
        }
        if(_t151 > 33090) {
            if(_t151 > 34837) {
                if(_t151 == 49152) {
                    if(( *135119022 & 255) != 0) {
                        return;
                    }
                    Strcat_charp(os, WcReplaceW);
                    return;
                }
            } else {
                if(_t151 >= 34836) {
                    _v56 = cc.auto_detect;
                    _v52 = st;
                     *__esp =  &_v36;
                    wc_cs94w_to_sjis_ext();
                    __esp = __esp - 4;
                    cc.auto_detect = _v36;
                    st = _v32;
L38:
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t208 = os->length;
                     *((char*)(os->ptr + _t208)) = st >> 8;
                    os->length = _t208 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t220 = os->length;
                     *((char*)(os->ptr + _t220)) = st;
                    os->length = _t220 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    return;
                }
                if(_t151 == 34835) {
                    goto L38;
                }
            }
L47:
            if(( *135119011 & 255) == 0) {
                if((cc.auto_detect & 98304) == 0) {
                    _t196 = 16384;
                } else {
                    _t196 = 49152;
                }
                cc.auto_detect = _t196;
            } else {
                _v48 =  *((intOrPtr*)(__ebp + 20));
                _v56 = cc.auto_detect;
                _v52 = st;
                 *__esp =  &_v36;
                wc_any_to_any_ces();
                __esp = __esp - 4;
                cc.auto_detect = _v36;
                st = _v32;
            }
            continue;
        }
        if(_t151 == 329) {
            if(( *135119017 & 255) != 0) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t237 = os->length;
                 *((char*)(os->ptr + _t237)) = st | -128;
                os->length = _t237 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            if(( *135119013 & 255) == 0) {
                _v56 = cc.auto_detect;
                _v52 = st;
                 *__esp =  &cc;
                wc_jisx0201k_to_jisx0208();
                __esp = __esp - 4;
            } else {
                cc.auto_detect = 16384;
            }
            continue;
        }
        if(_t151 != 16384) {
            if(_t151 == 322) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t253 = os->length;
                 *((char*)(os->ptr + _t253)) = st;
                os->length = _t253 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            goto L47;
        }
        if(( *135119022 & 255) == 0) {
            Strcat_charp(os, WcReplace);
            return;
        }
        return;
    }
    ub = st >> 8 & 127;
    lb = st & 127;
    if((ub & 1) == 0) {
        _t159 = 125;
    } else {
        _t159 = 31;
    }
    lb = lb + _t159;
    if(lb > 126) {
        lb = lb + 1;
    }
    ub = (ub & 255) - 33 >> 1;
    if(ub > 30) {
        _t163 = -63;
    } else {
        _t163 = -127;
    }
    ub = ub + _t163;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t170 = os->length;
     *((char*)(os->ptr + _t170)) = ub & 255;
    os->length = _t170 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t182 = os->length;
     *((char*)(os->ptr + _t182)) = lb & 255;
    os->length = _t182 + 1;
     *((char*)(os->ptr + os->length)) = 0;
}

void wc_push_to_sjisx0213(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080BC955  --  defined in 'sjis.c' at line 406
    wc_uchar ub;      // _cfa_fffffff3
    wc_uchar lb;      // _cfa_fffffff2
    wc_status* _v32;   // _cfa_ffffffe0
    unsigned char _v36;                    // _cfa_ffffffdc
    intOrPtr _v48;                         // _cfa_ffffffd0
    wc_status* _v52;   // _cfa_ffffffcc
    unsigned char _v56;                    // _cfa_ffffffc8 (outparam)
    unsigned char _t158;                   // _t158
    _unknown_ _t166;                       // _t166
    _unknown_ _t170;                       // _t170
    int _t177;                             // _t177
    int _t189;                             // _t189
    _unknown_ _t205;                       // _t205
    int _t217;                             // _t217
    int _t229;                             // _t229
    unsigned char _t241;                   // _t241
    int _t254;                             // _t254
    int _t270;                             // _t270

    while(1) {
        _t158 = cc.auto_detect;
        if(_t158 == 33090) {
            break;
        }
        if(_t158 > 33090) {
            if(_t158 == 33104) {
                if(( *135119019 & 255) != 0) {
                    ub = st >> 8 & 127;
                    lb = st & 127;
                    if((ub & 1) == 0) {
                        _t205 = 125;
                    } else {
                        _t205 = 31;
                    }
                    lb = lb + _t205;
                    if(lb > 126) {
                        lb = lb + 1;
                    }
                    ub =  *( &jisx02132_sjis_map + (ub & 255)) & 255;
                    if(ub == 0) {
                        goto L50;
                    } else {
                        if(os->length + 1 >= os->area_size) {
                            Strgrow(os);
                        }
                        _t217 = os->length;
                         *((char*)(os->ptr + _t217)) = ub & 255;
                        os->length = _t217 + 1;
                         *((char*)(os->ptr + os->length)) = 0;
                        if(os->length + 1 >= os->area_size) {
                            Strgrow(os);
                        }
                        _t229 = os->length;
                         *((char*)(os->ptr + _t229)) = lb & 255;
                        os->length = _t229 + 1;
                         *((char*)(os->ptr + os->length)) = 0;
                        return;
                    }
                }
                cc.auto_detect = 49152;
                goto L60;
            } else {
                if(_t158 == 49152) {
L50:
                    if(( *135119022 & 255) != 0) {
                        return;
                    }
                    Strcat_charp(os, WcReplaceW);
                    return;
                }
                if(_t158 == 33103) {
                    if(( *135119019 & 255) != 0) {
                        break;
                    }
                    cc.auto_detect = 49152;
L60:
                } else {
L54:
                    if(( *135119011 & 255) == 0) {
                        if((cc.auto_detect & 98304) == 0) {
                            _t241 = 16384;
                        } else {
                            _t241 = 49152;
                        }
                        cc.auto_detect = _t241;
                    } else {
                        _v48 =  *((intOrPtr*)(__ebp + 20));
                        _v56 = cc.auto_detect;
                        _v52 = st;
                         *__esp =  &_v36;
                        wc_any_to_any_ces();
                        __esp = __esp - 4;
                        cc.auto_detect = _v36;
                        st = _v32;
                    }
                }
                continue;
            }
L52:
            if(( *135119022 & 255) == 0) {
                Strcat_charp(os, WcReplace);
                return;
            }
            return;
        }
        if(_t158 == 329) {
            if(( *135119017 & 255) != 0) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t254 = os->length;
                 *((char*)(os->ptr + _t254)) = st | -128;
                os->length = _t254 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            if(( *135119013 & 255) == 0) {
                _v56 = cc.auto_detect;
                _v52 = st;
                 *__esp =  &cc;
                wc_jisx0201k_to_jisx0208();
                __esp = __esp - 4;
            } else {
                cc.auto_detect = 16384;
            }
            goto L60;
        }
        if(_t158 != 16384) {
            if(_t158 == 322) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t270 = os->length;
                 *((char*)(os->ptr + _t270)) = st;
                os->length = _t270 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            goto L54;
        }
        goto L52;
    }
    ub = st >> 8 & 127;
    lb = st & 127;
    if((ub & 1) == 0) {
        _t166 = 125;
    } else {
        _t166 = 31;
    }
    lb = lb + _t166;
    if(lb > 126) {
        lb = lb + 1;
    }
    ub = (ub & 255) - 33 >> 1;
    if(ub > 30) {
        _t170 = -63;
    } else {
        _t170 = -127;
    }
    ub = ub + _t170;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t177 = os->length;
     *((char*)(os->ptr + _t177)) = ub & 255;
    os->length = _t177 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t189 = os->length;
     *((char*)(os->ptr + _t189)) = lb & 255;
    os->length = _t189 + 1;
     *((char*)(os->ptr + os->length)) = 0;
}

Str wc_char_conv_from_sjis(wc_uchar c, wc_status* st)
{// addr = 0x080BCD67  --  defined in 'sjis.c' at line 470
    signed int _v16;                       // _cfa_fffffff0
    wc_wchar_t cc;   // _cfa_ffffffec
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t49;                              // _t49
    _unknown_ _t70;                        // _t70
    _unknown_ _t96;                        // _t96
    struct _Str* _t107;   // _t107
    signed int _t128;                      // _t128
    signed int _t135;                      // _t135
    int _t137;                             // _t137

    _v32 = c;
    if(st->state == -1) {
        st->state = 0;
        os.3288 = Strnew_size(8);
    }
    _t49 = st->state;
    if(_t49 > 2) {
        if(_t49 == 3) {
            if(( *( &WC_SJIS_MAP + (_v32 & 255)) & 0x10) != 0) {
                 *135790485 = _v32 & 255;
                wtf_push(os.3288, 34835, (jis.3289 & 0xff) << 8 |  *135790485 & 0xff);
            }
            st->state = 0;
        }
        goto L30;
    } else {
        if(_t49 >= 1) {
            if(( *( &WC_SJIS_MAP + (_v32 & 255)) & 0x10) != 0) {
                 *135790485 = _v32 & 255;
                _t128 = jis.3289 & 255;
                if((jis.3289 & 255) > 159) {
                    _t70 = -63;
                } else {
                    _t70 = -127;
                }
                jis.3289 = _t128 - _t70;
                jis.3289 = (jis.3289 & 255) + (jis.3289 & 255) + 33;
                if(( *135790485 & 255) > 158) {
                    jis.3289 = (jis.3289 & 255) + 1;
                     *135790485 = ( *135790485 & 255) - 126;
                } else {
                    _t135 =  *135790485 & 255;
                    if(( *135790485 & 255) <= 126) {
                        _t96 = 31;
                    } else {
                        _t96 = 32;
                    }
                     *135790485 = _t135 - _t96;
                }
                _v16 =  *135790485 & 0xff | (jis.3289 & 0xff) << 8;
                cc.auto_detect = wc_jisx0208_or_jisx02131(_v16 & 65535);
                if(cc.auto_detect != 33090) {
                    wtf_push(os.3288, 34835, (jis.3289 & 0xff) << 8 |  *135790485 & 0xff);
                } else {
                    wtf_push(os.3288, cc.auto_detect, _v16);
                }
            }
            st->state = 0;
L30:
            st->state = -1;
            return os.3288;
        }
        if(_t49 == 0) {
            if(( *( &WC_SJIS_MAP + (_v32 & 255)) & 0xff) - 18 > 46) {
                if(os.3288->length + 1 >= os.3288->area_size) {
                    Strgrow(os.3288);
                }
                _t107 = os.3288;
                _t137 = _t107->length;
                 *((char*)( *os.3288 + _t137)) = _v32 & 255;
                _t107->length = _t137 + 1;
                 *((char*)( *os.3288 + os.3288->length)) = 0;
                goto L30;
            }
            goto __eax;
        } else {
            goto L30;
        }
    }
}

Str wc_char_conv_from_sjisx0213(wc_uchar c, wc_status* st)
{// addr = 0x080BD079  --  defined in 'sjis.c' at line 535
    signed int _v16;                       // _cfa_fffffff0
    wc_wchar_t cc;   // _cfa_ffffffec
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t48;                              // _t48
    _unknown_ _t74;                        // _t74
    _unknown_ _t83;                        // _t83
    _unknown_ _t103;                       // _t103
    struct _Str* _t114;   // _t114
    signed int _t137;                      // _t137
    signed int _t138;                      // _t138
    signed int _t142;                      // _t142
    int _t144;                             // _t144

    _v32 = c;
    if(st->state == -1) {
        st->state = 0;
        os.3413 = Strnew_size(8);
    }
    _t48 = st->state;
    if(_t48 > 2) {
        if(_t48 == 3) {
            if(( *( &WC_SJIS_MAP + (_v32 & 255)) & 0x10) != 0) {
                 *135790477 = _v32 & 255;
                if(( *135790477 & 255) > 158) {
                    jis.3414 =  *((jis.3414 & 0xff) - 240 + "($,.nprtvxz|~") & 255;
                     *135790477 = ( *135790477 & 255) - 126;
                } else {
                    jis.3414 =  *((jis.3414 & 0xff) - 240 + "!#%-/oqsuwy{}") & 255;
                    _t137 =  *135790477 & 255;
                    if(( *135790477 & 255) <= 126) {
                        _t74 = 31;
                    } else {
                        _t74 = 32;
                    }
                     *135790477 = _t137 - _t74;
                }
                wtf_push(os.3413, 33104, (jis.3414 & 0xff) << 8 |  *135790477 & 0xff);
            }
            st->state = 0;
        }
    } else {
        if(_t48 >= 1) {
            if(( *( &WC_SJIS_MAP + (_v32 & 255)) & 0x10) != 0) {
                 *135790477 = _v32 & 255;
                _t138 = jis.3414 & 255;
                if((jis.3414 & 255) > 159) {
                    _t83 = -63;
                } else {
                    _t83 = -127;
                }
                jis.3414 = _t138 - _t83;
                jis.3414 = (jis.3414 & 255) + (jis.3414 & 255) + 33;
                if(( *135790477 & 255) > 158) {
                    jis.3414 = (jis.3414 & 255) + 1;
                     *135790477 = ( *135790477 & 255) - 126;
                } else {
                    _t142 =  *135790477 & 255;
                    if(( *135790477 & 255) <= 126) {
                        _t103 = 31;
                    } else {
                        _t103 = 32;
                    }
                     *135790477 = _t142 - _t103;
                }
                _v16 =  *135790477 & 0xff | (jis.3414 & 0xff) << 8;
                cc.auto_detect = wc_jisx0208_or_jisx02131(_v16 & 65535);
                wtf_push(os.3413, cc.auto_detect, _v16);
            }
            st->state = 0;
L34:
            st->state = -1;
            return os.3413;
        }
        if(_t48 == 0) {
            if(( *( &WC_SJIS_MAP + (_v32 & 255)) & 0xff) - 18 > 46) {
                if(os.3413->length + 1 >= os.3413->area_size) {
                    Strgrow(os.3413);
                }
                _t114 = os.3413;
                _t144 = _t114->length;
                 *((char*)( *os.3413 + _t144)) = _v32 & 255;
                _t114->length = _t144 + 1;
                 *((char*)( *os.3413 + os.3413->length)) = 0;
                goto L34;
            }
            goto __eax;
        }
    }
}

void wc_input_init(wc_ces ces, wc_status* st)
{// addr = 0x080BD3D0  --  defined in 'status.c' at line 38
    wc_gset* gset;     // _cfa_fffffff8
    int i;                                 // _cfa_fffffff4
    int g;                                 // _cfa_fffffff0

    st->ces_info =  &WcCesInfo + ((ces & 255) << 5);
    gset =  *(st->ces_info + 12);
    st->state = 0;
    st->g0_ccs = 0;
    st->g1_ccs = 0;
     *(st + 16) = gset->ccs;
     *((intOrPtr*)(st + 20)) =  *((intOrPtr*)(gset + 8));
     *(st + 24) = 0;
     *(st + 28) = 0;
    st->gl = 0;
    st->gr = 1;
    st->ss = 0;
    i = 0;
    while( *((intOrPtr*)(gset + (i << 3))) != 0) {
        if(( *(gset + (i << 3) + 5) & 255) != 0) {
            g =  *(gset + (i << 3) + 4) & 3;
            if( *((intOrPtr*)(st + (g + 4) * 4)) == 0) {
                 *((intOrPtr*)(st + (g + 4) * 4)) =  *((intOrPtr*)(gset + (i << 3)));
            }
        }
        i = i + 1;
    }
    st->tag = 0;
    st->ntag = 0;
}

void wc_output_init(wc_ces ces, wc_status* st)
{// addr = 0x080BD4D7  --  defined in 'status.c' at line 72
    wc_gset* gset;     // _cfa_fffffff0
    size_t i;           // _cfa_ffffffec
    size_t n;           // _cfa_ffffffe8
    size_t nw;          // _cfa_ffffffe4
    intOrPtr _v36;                         // _cfa_ffffffdc
    struct * _v40;            // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    unsigned int _t156;                    // _t156
    unsigned int _t158;                    // _t158
    wc_table** _t185;   // _t185
    wc_table** _t189;   // _t189
    unsigned int _t217;                    // _t217
    wc_table** _t237;   // _t237
    wc_status* _t238;   // _t238
    _unknown_ _t251;                       // _t251
    wc_status* _t252;   // _t252

    if((output_set & 255) == 0) {
L4:
        st->state = 0;
        st->ces_info =  &WcCesInfo + ((ces & 255) << 5);
        gset =  *(st->ces_info + 12);
        __eflags = ces - 2099217;
        if(ces == 2099217) {
L7:
            __eflags =  *135119015 & 255;
            if(( *135119015 & 255) != 0) {
                _t156 = 330;
L10:
                st->g0_ccs = _t156;
                __eflags = ces - 2099217;
                if(ces == 2099217) {
L13:
                    __eflags =  *135119016 & 255;
                    if(( *135119016 & 255) != 0) {
                        _t158 = 33088;
L16:
                        st->g1_ccs = _t158;
                         *((intOrPtr*)(st + 16)) = st->g0_ccs;
                         *(st + 20) = 0;
                         *(st + 24) = 0;
                         *(st + 28) = 0;
                        st->gl = 0;
                        st->gr = 0;
                        st->ss = 0;
                        __eflags = ces & 2048;
                        if((ces & 2048) != 0) {
                            wc_create_gmap(st);
                        }
                        st->tag = 0;
                        st->ntag = 0;
                        __eflags =  *135119011 & 255;
                        if(__eflags != 0) {
                            nw = 0;
                            n = nw;
                            i = n;
                            while(1) {
                                __eflags =  *(gset + (i << 3));
                                if( *(gset + (i << 3)) == 0) {
                                    break;
                                }
                                __eflags =  *(gset + (i << 3)) & 98304;
                                if(( *(gset + (i << 3)) & 98304) == 0) {
                                    n = n + 1;
                                    __eflags = n;
                                } else {
                                    nw = nw + 1;
                                }
                                i = i + 1;
                                __eflags = i;
                            }
                            _t185 = n + 1 << 2;
                             *__esp = _t185;
                            GC_malloc();
                            st->tlist = _t185;
                            _t189 = nw + 1 << 2;
                             *__esp = _t189;
                            GC_malloc();
                            st->tlistw = _t189;
                            nw = 0;
                            n = nw;
                            i = n;
                            while(1) {
                                __eflags =  *(gset + (i << 3));
                                if( *(gset + (i << 3)) == 0) {
                                    break;
                                }
                                __eflags =  *(gset + (i << 3)) & 98304;
                                if(( *(gset + (i << 3)) & 98304) == 0) {
                                    __eflags =  *(gset + (i << 3)) - 329;
                                    if( *(gset + (i << 3)) != 329) {
L47:
                                        st->tlist[n] = wc_get_ucs_table( *(gset + (i << 3)));
                                        n = n + 1;
L49:
                                        i = i + 1;
                                        __eflags = i;
                                        continue;
                                    }
                                    __eflags =  *135119017 & 255;
                                    if(( *135119017 & 255) == 0) {
                                        goto L49;
                                    }
                                    goto L47;
                                }
                                _t217 =  *(gset + (i << 3));
                                __eflags = _t217 - 33092;
                                if(_t217 == 33092) {
                                    __eflags =  *135119018 & 255;
                                    if(( *135119018 & 255) != 0) {
L44:
                                        st->tlistw[nw] = wc_get_ucs_table( *(gset + (i << 3)));
                                        nw = nw + 1;
                                        goto L49;
                                    }
                                    goto L49;
                                }
                                __eflags = _t217 - 33092;
                                if(_t217 > 33092) {
                                    __eflags = _t217 - 33103 - 1;
                                    if(_t217 - 33103 > 1) {
                                        goto L44;
                                    }
                                    __eflags =  *135119019 & 255;
                                    if(( *135119019 & 255) != 0) {
                                        goto L44;
                                    }
                                    goto L49;
                                }
                                __eflags = _t217 - 33089;
                                if(_t217 == 33089) {
                                    __eflags =  *135119014 & 255;
                                    if(( *135119014 & 255) == 0) {
                                        goto L44;
                                    }
                                    __eflags = ces - 3153978;
                                    if(ces == 3153978) {
                                        goto L44;
                                    }
                                    __eflags = ces - 3153979;
                                    if(ces == 3153979) {
                                        goto L44;
                                    }
                                    st->tlistw[nw] = wc_get_ucs_table(34830);
                                    nw = nw + 1;
                                    goto L49;
                                }
                                goto L44;
                            }
                            st->tlist[n] = 0;
                            _t237 =  &(st->tlistw[nw]);
                            __eflags = _t237;
                             *_t237 = 0;
                            goto L52;
                        } else {
                            st->tlist = 0;
                            st->tlistw = 0;
L52:
                            _t238 = st;
                            output_st.auto_detect =  *_t238;
                             *135790500 = _t238->gr;
                             *135790504 = _t238->g0_ccs;
                             *135790508 = _t238->g1_ccs;
                             *135790512 =  *((intOrPtr*)(_t238 + 16));
                             *135790516 =  *((intOrPtr*)(_t238 + 20));
                             *135790520 =  *((intOrPtr*)(_t238 + 24));
                             *135790524 =  *((intOrPtr*)(_t238 + 28));
                             *135790528 = _t238->tlist;
                             *135790532 = _t238->tlistw;
                             *135790536 = _t238->state;
                             *135790540 = _t238->tag;
                             *135790544 = _t238->ntag;
                             *135790548 = _t238->base;
                             *135790552 = _t238->shift;
                            output_set = 1;
                            output_option.auto_detect = WcOption.auto_detect;
                             *135790560 =  *135119012;
                             *135790564 =  *135119016;
                             *135790568 =  *135119020;
                            return;
                        }
                    }
L14:
                    _t158 =  *(gset + 8);
                    goto L16;
                }
                __eflags = ces - 2099218;
                if(ces == 2099218) {
                    goto L13;
                }
                __eflags = ces - 2099219;
                if(ces != 2099219) {
                    goto L14;
                }
                goto L13;
            }
L8:
            _t156 = gset->ccs;
            goto L10;
        }
        __eflags = ces - 2099218;
        if(ces == 2099218) {
            goto L7;
        }
        __eflags = ces - 2099219;
        if(ces != 2099219) {
            goto L8;
        }
        goto L7;
    }
    _t251 =  *(output_st.auto_detect);
    if(_t251 != ces) {
        goto L4;
    }
    _v36 = 16;
    _v40 =  &output_option;
     *__esp =  &WcOption;
    memcmp();
    if(_t251 != 0) {
        goto L4;
    }
    _t252 = st;
    _t252->ces_info = output_st.auto_detect;
    _t252->gr =  *135790500;
    _t252->g0_ccs =  *135790504;
    _t252->g1_ccs =  *135790508;
     *((intOrPtr*)(_t252 + 16)) =  *135790512;
     *((intOrPtr*)(_t252 + 20)) =  *135790516;
     *((intOrPtr*)(_t252 + 24)) =  *135790520;
     *((intOrPtr*)(_t252 + 28)) =  *135790524;
    _t252->tlist =  *135790528;
    _t252->tlistw =  *135790532;
    _t252->state =  *135790536;
    _t252->tag =  *135790540;
    _t252->ntag =  *135790544;
    _t252->base =  *135790548;
    _t252->shift =  *135790552;
}

wc_bool wc_ces_has_ccs(wc_ccs ccs, wc_status* st)
{// addr = 0x080BD983  --  defined in 'status.c' at line 165
    wc_gset* gset;     // _cfa_fffffff8
    int i;                                 // _cfa_fffffff4

    gset = st->ces_info->gset;
    i = 0;
    while( *((intOrPtr*)(gset + (i << 3))) != 0) {
        if( *((intOrPtr*)(gset + (i << 3))) != ccs) {
            i = i + 1;
            continue;
        }
        return 1;
    }
    return 0;
}

wc_wchar_t ucs_cs94_conv(wc_ccs ccs, wc_uint16 c)
{// addr = 0x080BD9D0  --  defined in 'ucs.map' at line 237
    signed int _v8;                        // _cfa_fffffff8
    wc_wchar_t cc;   // _cfa_fffffff4
    signed short _v24;                     // _cfa_ffffffe8

    __ecx = ccs;
    _v24 = _a12;
    cc.auto_detect = c;
    _v8 = _v24 & 65535;
     *__ecx = cc.auto_detect;
     *(__ecx + 4) = _v8;
    return __ecx;
}

wc_wchar_t ucs_viet_conv(wc_ccs ccs, wc_uint16 c)
{// addr = 0x080BD9FE  --  defined in 'ucs.map' at line 252
    signed int _v8;                        // _cfa_fffffff8
    wc_wchar_t cc;   // _cfa_fffffff4
    signed int _v24;                       // _cfa_ffffffe8
    short unsigned int _t26;               // _t26
    short unsigned int _t32;               // _t32

    __ecx = ccs;
    _v24 = _a12;
    if((_v24 & 0x80) == 0) {
        cc.auto_detect = c;
        _t26 = c;
        if(_t26 == 2080) {
            cc.auto_detect = 2081;
        } else {
            if(_t26 == 2082) {
                cc.auto_detect = 2083;
            } else {
                if(_t26 == 2077) {
                    cc.auto_detect = 2078;
                }
            }
        }
    } else {
        cc.auto_detect = c;
        _t32 = c;
        if(_t32 == 2081) {
            cc.auto_detect = 2080;
        } else {
            if(_t32 == 2083) {
                cc.auto_detect = 2082;
            } else {
                if(_t32 == 2078) {
                    cc.auto_detect = 2077;
                }
            }
        }
    }
    _v8 = _v24 & 0xff;
     *__ecx = cc.auto_detect;
     *(__ecx + 4) = _v8;
    return __ecx;
}

wc_wchar_t ucs_cp1258_conv(wc_ccs ccs, wc_uint16 c)
{// addr = 0x080BDAAC  --  defined in 'ucs.map' at line 288
    signed int _v8;                        // _cfa_fffffff8
    wc_wchar_t cc;   // _cfa_fffffff4
    signed short _v24;                     // _cfa_ffffffe8
    unsigned char _t12;                    // _t12

    __ecx = ccs;
    _v24 = _a12;
    if(_v24 > 255) {
        _t12 = 2076;
    } else {
        _t12 = 2075;
    }
    cc.auto_detect = _t12;
    _v8 = _v24 & 65535;
     *__ecx = cc.auto_detect;
     *(__ecx + 4) = _v8;
    return __ecx;
}

wc_wchar_t ucs_cns11643_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDAEB  --  defined in 'ucs.map' at line 298
    signed int _v8;                        // _cfa_fffffff8
    wc_wchar_t cc;   // _cfa_fffffff4
    signed int _v24;                       // _cfa_ffffffe8
    unsigned char _t13;                    // _t13

    __ecx = cs;
    _v24 = _a12;
    if((_v24 & 65535) >= 0) {
        _t13 = 33095;
    } else {
        _t13 = 33096;
    }
    cc.auto_detect = _t13;
    _v8 = _v24 & 0x7f7f;
     *__ecx = cc.auto_detect;
     *(__ecx + 4) = _v8;
    return __ecx;
}

wc_wchar_t ucs_big5_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDB30  --  defined in 'ucs.map' at line 308
    _unknown_ _v8;                         // _cfa_fffffff8
    signed int _v16;                       // _cfa_fffffff0
    wc_wchar_t cc;   // _cfa_ffffffec
    signed short _v32;                     // _cfa_ffffffe0
    signed int _v52;                       // _cfa_ffffffcc
    unsigned char _v56;                    // _cfa_ffffffc8
    struct  _t19;             // _t19

    _push(__ebx);
    __esp = __esp - 52;
    _t19 = cs;
    _v32 = _a12;
    cc.auto_detect = c;
    _v16 = _v32 & 65535;
    _v56 = cc.auto_detect;
    _v52 = _v16;
     *__esp = _t19;
    wc_big5_to_cs94w();
    __esp = __esp - 4;
    return _t19;
}

wc_wchar_t ucs_johab2_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDB70  --  defined in 'ucs.map' at line 318
    _unknown_ _v8;                         // _cfa_fffffff8
    signed int _v16;                       // _cfa_fffffff0
    wc_wchar_t cc;   // _cfa_ffffffec
    signed short _v32;                     // _cfa_ffffffe0
    signed int _v52;                       // _cfa_ffffffcc
    unsigned char _v56;                    // _cfa_ffffffc8
    struct  _t19;             // _t19

    _push(__ebx);
    __esp = __esp - 52;
    _t19 = cs;
    _v32 = _a12;
    cc.auto_detect = c;
    _v16 = _v32 & 65535;
    _v56 = cc.auto_detect;
    _v52 = _v16;
     *__esp = _t19;
    wc_johab_to_cs128w();
    __esp = __esp - 4;
    return _t19;
}

wc_wchar_t ucs_johab3_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDBB0  --  defined in 'ucs.map' at line 328
    signed int _v8;                        // _cfa_fffffff8
    wc_wchar_t cc;   // _cfa_fffffff4
    signed short _v24;                     // _cfa_ffffffe8

    __ecx = cs;
    _v24 = _a12;
    if(_v24 <= 8480 || _v24 > 9248) {
        if(_v24 <= 9299 || _v24 > 11390) {
            if(_v24 <= 18976 || _v24 > 32126) {
                cc.auto_detect = 49152;
                goto L8;
            } else {
                goto L6;
            }
        } else {
            goto L6;
        }
    } else {
L6:
        cc.auto_detect = c;
L8:
        _v8 = _v24 & 65535;
         *__ecx = cc.auto_detect;
         *(__ecx + 4) = _v8;
        return __ecx;
    }
}

wc_wchar_t ucs_sjis_ext_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDC17  --  defined in 'ucs.map' at line 343
    _unknown_ _v8;                         // _cfa_fffffff8
    signed int _v16;                       // _cfa_fffffff0
    wc_wchar_t cc;   // _cfa_ffffffec
    signed short _v32;                     // _cfa_ffffffe0
    signed int _v52;                       // _cfa_ffffffcc
    unsigned char _v56;                    // _cfa_ffffffc8
    struct  _t19;             // _t19

    _push(__ebx);
    __esp = __esp - 52;
    _t19 = cs;
    _v32 = _a12;
    cc.auto_detect = c;
    _v16 = _v32 & 65535;
    _v56 = cc.auto_detect;
    _v52 = _v16;
     *__esp = _t19;
    wc_sjis_ext_to_cs94w();
    __esp = __esp - 4;
    return _t19;
}

wc_wchar_t ucs_gbk_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDC57  --  defined in 'ucs.map' at line 353
    _unknown_ _v8;                         // _cfa_fffffff8
    signed int _v16;                       // _cfa_fffffff0
    wc_wchar_t cc;   // _cfa_ffffffec
    signed short _v32;                     // _cfa_ffffffe0
    signed int _v52;                       // _cfa_ffffffcc
    unsigned char _v56;                    // _cfa_ffffffc8
    struct  _t19;             // _t19

    _push(__ebx);
    __esp = __esp - 52;
    _t19 = cs;
    _v32 = _a12;
    cc.auto_detect = c;
    _v16 = _v32 & 65535;
    _v56 = cc.auto_detect;
    _v52 = _v16;
     *__esp = _t19;
    wc_gbk_to_cs128w();
    __esp = __esp - 4;
    return _t19;
}

wc_wchar_t ucs_uhc_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDC97  --  defined in 'ucs.map' at line 363
    _unknown_ _v8;                         // _cfa_fffffff8
    signed int _v16;                       // _cfa_fffffff0
    wc_wchar_t cc;   // _cfa_ffffffec
    signed short _v32;                     // _cfa_ffffffe0
    signed int _v52;                       // _cfa_ffffffcc
    unsigned char _v56;                    // _cfa_ffffffc8
    struct  _t19;             // _t19

    _push(__ebx);
    __esp = __esp - 52;
    _t19 = cs;
    _v32 = _a12;
    cc.auto_detect = c;
    _v16 = _v32 & 65535;
    _v56 = cc.auto_detect;
    _v52 = _v16;
     *__esp = _t19;
    wc_uhc_to_cs128w();
    __esp = __esp - 4;
    return _t19;
}

wc_wchar_t ucs_hkscs_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDCD7  --  defined in 'ucs.map' at line 373
    _unknown_ _v8;                         // _cfa_fffffff8
    signed int _v16;                       // _cfa_fffffff0
    wc_wchar_t cc;   // _cfa_ffffffec
    signed short _v32;                     // _cfa_ffffffe0
    signed int _v52;                       // _cfa_ffffffcc
    unsigned char _v56;                    // _cfa_ffffffc8
    struct  _t19;             // _t19

    _push(__ebx);
    __esp = __esp - 52;
    _t19 = cs;
    _v32 = _a12;
    cc.auto_detect = c;
    _v16 = _v32 & 65535;
    _v56 = cc.auto_detect;
    _v52 = _v16;
     *__esp = _t19;
    wc_hkscs_to_cs128w();
    __esp = __esp - 4;
    return _t19;
}

wc_table* wc_get_ucs_table(wc_ccs ccs)
{// addr = 0x080BDD17  --  defined in 'ucs.c' at line 31
    int f;                                 // _cfa_fffffff8
    signed int _t28;                       // _t28

    f = ccs & 255;
    _t28 = ccs & 65280;
    if(_t28 == 2048) {
        if(f <= 0 || f > 40) {
            return 0;
        } else {
            return  &ucs_pcs_table + (f - 1 << 4);
        }
    }
    if(_t28 > 2048) {
        if(_t28 == 33280) {
            if(f <= 63 || f > 0) {
                return 0;
            } else {
                return ucs_cs96w_table + (f - 64 << 4);
            }
        }
        if(_t28 == 34816) {
            if(f <= 0 || f > 33) {
                return 0;
            } else {
                return  &ucs_pcsw_table + (f - 1 << 4);
            }
        }
        if(_t28 == 33024) {
            if(f <= 63 || f > 80) {
                return 0;
            }
            return  &ucs_cs94w_table + (f - 64 << 4);
        } else {
L38:
            return 0;
        }
    }
    if(_t28 == 512) {
        if(f <= 63 || f > 102) {
            return 0;
        } else {
            return  &ucs_cs96_table + (f - 64 << 4);
        }
    }
    if(_t28 == 1024) {
        if(f <= 63 || f > 0) {
            return 0;
        } else {
            return ucs_cs942_table + (f - 64 << 4);
        }
    }
    if(_t28 == 256) {
        if(f <= 63) {
L12:
            return 0;
        } else {
            if(f <= 84) {
                return  &ucs_cs94_table + (f - 64 << 4);
            } else {
                goto L12;
            }
        }
    } else {
        goto L38;
    }
}

wc_wchar_t wc_ucs_to_any(wc_uint32 ucs, wc_table* t)
{// addr = 0x080BDE9B  --  defined in 'ucs.c' at line 70
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_map* map;        // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    wc_wchar_t cc;   // _cfa_ffffffe8
    signed int _v36;                       // _cfa_ffffffdc (outparam)
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    wc_map* _t67;       // _t67
    wc_map* _t78;       // _t78
    wc_map* _t80;       // _t80
    struct  _t94;             // _t94

    _push(__ebx);
    __esp = __esp - 36;
    _t94 = ucs;
    if( *((intOrPtr*)(__ebp + 16)) == 0 ||  *( *((intOrPtr*)(__ebp + 16)) + 8) == 0 || t == 0 || t > 65535) {
L6:
        if( *((intOrPtr*)(__ebp + 16)) == 0 || 0 != 131072) {
L19:
            cc.auto_detect = 16384;
             *_t94 = cc.auto_detect;
             *((intOrPtr*)(_t94 + 4)) = _v20;
        } else {
            if( *((intOrPtr*)( *((intOrPtr*)(__ebp + 16)))) != 33103) {
                if( *((intOrPtr*)( *((intOrPtr*)(__ebp + 16)))) != 33104) {
                    if( *((intOrPtr*)( *((intOrPtr*)(__ebp + 16)))) == 34847 ||  *((intOrPtr*)( *((intOrPtr*)(__ebp + 16)))) == 34848 ||  *((intOrPtr*)( *((intOrPtr*)(__ebp + 16)))) == 34849) {
                        _t67 = t & 65535;
                        wc_map_search(_t67,  &ucs_p2_hkscs_map, 1081);
                        map = _t67;
                    } else {
                        map = 0;
                    }
                } else {
                    _t78 = 0;
                    wc_map_search(_t78,  &ucs_p2_jisx02132_map, 277);
                    map = _t78;
                }
            } else {
                _t80 = 0;
                wc_map_search(_t80,  &ucs_p2_jisx02131_map, 25);
                map = _t80;
            }
            if(map == 0) {
                goto L19;
            }
            _v36 = map->code2 & 0xffff;
            _v40 =  *((intOrPtr*)( *((intOrPtr*)(__ebp + 16))));
             *__esp = _t94;
             *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__ebp + 16)) + 12))))();
            __esp = __esp - 4;
        }
        goto L20;
    } else {
        map = wc_map_search(t & 65535,  *( *((intOrPtr*)(__ebp + 16)) + 8),  *( *((intOrPtr*)(__ebp + 16)) + 4));
        if(map == 0) {
            goto L6;
        } else {
            _v36 = map->code2 & 0xffff;
            _v40 =  *((intOrPtr*)( *((intOrPtr*)(__ebp + 16))));
             *__esp = _t94;
             *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__ebp + 16)) + 12))))();
            __esp = __esp - 4;
L20:
            return _t94;
        }
    }
}

wc_uint32 wc_any_to_ucs(wc_wchar_t cc)
{// addr = 0x080BE029  --  defined in 'ucs.c' at line 101
    char _v12;                             // _cfa_fffffff4
    int f;                                 // _cfa_fffffff0
    wc_uint16* map;   // _cfa_ffffffec
    wc_map* map2;       // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    char _v32;                             // _cfa_ffffffe0
    signed int _v100;                      // _cfa_ffffff9c (outparam)
    signed int _v104;                      // _cfa_ffffff98 (outparam)
    intOrPtr _v108;                        // _cfa_ffffff94 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    signed int _t120;                      // _t120
    signed int _t123;                      // _t123
    signed int _t182;                      // _t182
    unsigned char _t197;                   // _t197

    __esp = __esp - 96;
    map = 0;
    f = cc.auto_detect & 255;
    _t120 = cc.auto_detect & 65280;
    if(_t120 == 4096) {
        if((cc.auto_detect & 65535) != 4096) {
            _t123 = -1;
        } else {
            _t123 = _a8;
        }
L82:
         &_v12 =  &_v12;
        return _t123;
    }
    if(_t120 > 4096) {
        if(_t120 == 33024) {
            if(cc.auto_detect != 33089 || ( *135119014 & 255) == 0) {
                if(cc.auto_detect != 33103) {
                    if(cc.auto_detect != 33104) {
L30:
                        if(f <= 63 || f > 80) {
                            _t123 = 0;
                        } else {
                            map =  *( &cs94w_ucs_map + (f - 64) * 4);
                            _a8 = (_a8 >> 8 & 127) * 94 + (_a8 & 127) - 3135;
L77:
                            if(map != 0) {
                                _a8 =  *(map + _a8 + _a8) & 0xffff;
                                if(_a8 == 0) {
                                    _t123 = -1;
                                } else {
                                    _t123 = _a8;
                                }
                            } else {
                                _t123 = -1;
                            }
                        }
                        goto L82;
                    }
                    map2 = wc_map_search(_a8 & 0x7f7f,  &jisx02132_ucs_p2_map, 277);
                    if(map2 == 0) {
                        goto L30;
                    } else {
                        _t123 = map2->code2 & 0xffff | 131072;
                        goto L82;
                    }
                }
                map2 = wc_map_search(_a8 & 0x7f7f,  &jisx02131_ucs_p2_map, 25);
                if(map2 == 0) {
                    goto L30;
                } else {
                    _t123 = map2->code2 & 0xffff | 131072;
                    goto L82;
                }
            } else {
                cc.auto_detect = 34830;
                 *__esp = cc.auto_detect;
                _v104 = _a8;
                _t123 = wc_any_to_ucs();
                goto L82;
            }
        }
        if(_t120 > 33024) {
            if(_t120 == 33280) {
                if(f <= 63 || f > 0) {
                    _t123 = -1;
                    goto L82;
                } else {
                    map = cs96w_ucs_map[f - 64];
                    _a8 = ((_a8 >> 8 & 127) + (_a8 >> 8 & 127) + _t222 << 5) + (_a8 & 127) - 3104;
                    goto L77;
                }
            }
            if(_t120 == 34816) {
                if(f <= 0 || f > 33) {
                    _t123 = -1;
                    goto L82;
                } else {
                    map =  *( &pcsw_ucs_map + (f - 1) * 4);
                    if(cc.auto_detect - 34817 > 32) {
                        _a8 = (_a8 >> 8 & 127) * 94 + (_a8 & 127) - 3135;
                        goto L77;
                    }
                    goto __eax;
                }
            } else {
L76:
                _t123 = -1;
                goto L82;
            }
        }
        if(_t120 == 8192) {
            _t182 = cc.auto_detect & 65535;
            if(_t182 == 8193) {
                _t123 = _a8 & 2097151;
            } else {
                if(_t182 == 8194) {
                     *__esp = cc.auto_detect;
                    _v104 = _a8;
                    _t123 = wc_gb18030_to_ucs();
                } else {
                    if(_t182 != 8192) {
                        _t123 = -1;
                    } else {
                        _t123 = _a8;
                    }
                }
            }
            goto L82;
        }
        if(_t120 == 16384) {
            if(cc.auto_detect != 16385) {
                goto L76;
            }
            _t123 = _a8 | 128;
            goto L82;
        } else {
            goto L76;
        }
    }
    if(_t120 == 512) {
        if(f <= 63 || f > 102) {
            _t123 = -1;
            goto L82;
        } else {
            map =  *( &cs96_ucs_map + (f - 64) * 4);
            _a8 = _a8 & 127;
            goto L77;
        }
    }
    if(_t120 > 512) {
        if(_t120 == 1024) {
            if(f <= 63 || f > 0) {
                _t123 = -1;
                goto L82;
            } else {
                map = cs942_ucs_map[f - 64];
                _a8 = _a8 & 127;
                goto L77;
            }
        }
        if(_t120 == 2048) {
            if(f <= 0 || f > 40) {
                _t123 = -1;
            } else {
                _t197 = cc.auto_detect;
                if(_t197 == 2079) {
                    _v104 = cc.auto_detect;
                    _v100 = _a8;
                     *__esp =  &_v32;
                    wc_tcvn57123_to_tcvn5712();
                     *__esp = _v32;
                    _v108 = _v28;
                    _t123 = wc_any_to_ucs();
                    goto L82;
                }
                if(_t197 == 2087) {
                    _t123 = 8364;
                    goto L82;
                }
                if(_t197 != 2076) {
                    map =  *( &pcs_ucs_map + (f - 1) * 4);
                    _a8 = _a8 & 127;
                    goto L77;
                }
                map2 = wc_map_search(_a8 & 65535,  &cp12582_ucs_map, 120);
                if(map2 == 0) {
                    _t123 = -1;
                } else {
                    _t123 = map2->code2 & 0xffff;
                }
            }
            goto L82;
        } else {
            goto L76;
        }
    }
    if(_t120 == 256) {
        if(f <= 63) {
L19:
            _t123 = -1;
            goto L82;
        }
        if(f <= 84) {
            map =  *( &cs94_ucs_map + (f - 64) * 4);
            _a8 = _a8 & 127;
            goto L77;
        }
        goto L19;
    } else {
        goto L76;
    }
}

wc_wchar_t wc_any_to_any(wc_wchar_t cc, wc_table* t)
{// addr = 0x080BE7F3  --  defined in 'ucs.c' at line 271
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_ccs is_wide;     // _cfa_fffffff0
    wc_uint32 ucs;   // _cfa_ffffffec
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    wc_table* _t44;   // _t44
    struct  _t59;             // _t59

    _push(__ebx);
    __esp = __esp - 52;
    _t59 = cc.auto_detect;
    is_wide = t & 98304;
     *__esp = t;
    _v56 = _a12;
    ucs = wc_any_to_ucs();
    if(ucs == -1) {
L6:
        if(is_wide == 0) {
            _t44 = 16384;
        } else {
            _t44 = 49152;
        }
        t = _t44;
         *_t59 = t;
         *((intOrPtr*)(_t59 + 4)) = _a12;
    } else {
        _v52 =  *((intOrPtr*)(__ebp + 20));
        wc_ucs_to_any( &t, ucs);
        __esp = __esp - 4;
        if((t & 16384) != 0) {
            ucs = wc_ucs_to_fullwidth(ucs);
            if(ucs == -1) {
                goto L6;
            } else {
                _v56 =  *((intOrPtr*)(__ebp + 20));
                wc_ucs_to_any( &_v36, ucs);
                __esp = __esp - 4;
                t = _v36;
                _a12 = _v32;
                if((t & 16384) != 0) {
                    goto L6;
                } else {
                     *_t59 = t;
                     *((intOrPtr*)(_t59 + 4)) = _a12;
                }
            }
        } else {
             *_t59 = t;
             *((intOrPtr*)(_t59 + 4)) = _a12;
        }
    }
    return _t59;
}

wc_wchar_t wc_ucs_to_any_list(wc_uint32 ucs, wc_table** tlist)
{// addr = 0x080BE8DA  --  defined in 'ucs.c' at line 293
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_table** t;     // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    wc_wchar_t cc;   // _cfa_ffffffe8
    wc_table* _v36;   // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    struct  _t38;             // _t38

    _push(__ebx);
    __esp = __esp - 36;
    _t38 = ucs;
    if( *(__ebp + 16) == 0) {
L8:
        cc.auto_detect = 16384;
         *_t38 = cc.auto_detect;
         *((intOrPtr*)(_t38 + 4)) = _v20;
    } else {
        t =  *(__ebp + 16);
        while( *t != 0) {
            if( *t->map == 0) {
                goto L6;
            } else {
                _v36 =  *t;
                wc_ucs_to_any( &cc, tlist);
                __esp = __esp - 4;
                if((cc.auto_detect & 16384) != 0) {
L6:
                    t =  &(t[1]);
                    continue;
                } else {
                     *_t38 = cc.auto_detect;
                     *((intOrPtr*)(_t38 + 4)) = _v20;
                }
            }
            goto L9;
        }
        goto L8;
    }
L9:
    return _t38;
}

wc_wchar_t wc_any_to_any_ces(wc_wchar_t cc, wc_status* st)
{// addr = 0x080BE95E  --  defined in 'ucs.c' at line 312
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_uint32 ucs;   // _cfa_fffffff0
    wc_ccs is_wide;     // _cfa_ffffffec
    unsigned int _v32;                     // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    unsigned int _v52;                     // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    unsigned int _v60;                     // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    wc_status* _t144;   // _t144
    unsigned int _t155;                    // _t155
    unsigned int _t171;                    // _t171
    unsigned int _t178;                    // _t178
    wc_status* _t195;   // _t195
    unsigned int _t197;                    // _t197
    wc_status* _t210;   // _t210
    struct  _t218;            // _t218

    _push(__ebx);
    __esp = __esp - 52;
    _t218 = cc.auto_detect;
     *__esp = st;
    _v56 = _a12;
    ucs = wc_any_to_ucs();
    is_wide = st & 98304;
    if(ucs > 127) {
        if(ucs == -1) {
L48:
            if(is_wide == 0) {
                _t144 = 16384;
            } else {
                _t144 = 49152;
            }
            st = _t144;
             *_t218 = st;
             *(_t218 + 4) = _a12;
            goto L52;
        }
        if(( *( *( *(__ebp + 20))) & 32768) == 0) {
            if( *( *( *(__ebp + 20))) != 3153984) {
                if(is_wide == 0) {
                    _t155 = ( *(__ebp + 20))[8];
                } else {
                    _t155 = ( *(__ebp + 20))[9];
                }
                _v52 = _t155;
                wc_ucs_to_any_list( &_v36, ucs);
                __esp = __esp - 4;
                st = _v36;
                _a12 = _v32;
                if((st & 16384) != 0) {
                    if(( *135119013 & 255) != 0) {
L23:
                        if( *( *( *(__ebp + 20))) != 3153979) {
                            if(ucs != 160) {
                                if(( *( *( *(__ebp + 20))) & 4608) == 0 || ucs <= 127 || ucs > 159) {
                                    ucs = wc_ucs_to_fullwidth(ucs);
                                    if(ucs == -1) {
                                        goto L48;
                                    }
                                    if(is_wide == 0) {
                                        _t171 = ( *(__ebp + 20))[8];
                                    } else {
                                        _t171 = ( *(__ebp + 20))[9];
                                    }
                                    _v56 = _t171;
                                    wc_ucs_to_any_list( &_v36, ucs);
                                    __esp = __esp - 4;
                                    st = _v36;
                                    _a12 = _v32;
                                    if((st & 16384) != 0) {
                                        if(( *135119013 & 255) != 0) {
                                            goto L48;
                                        }
                                        if(is_wide == 0) {
                                            _t178 = ( *(__ebp + 20))[9];
                                        } else {
                                            _t178 = ( *(__ebp + 20))[8];
                                        }
                                        _v60 = _t178;
                                        wc_ucs_to_any_list( &_v36, ucs);
                                        __esp = __esp - 4;
                                        st = _v36;
                                        _a12 = _v32;
                                        if((st & 16384) != 0) {
                                            goto L48;
                                        } else {
                                             *_t218 = st;
                                             *(_t218 + 4) = _a12;
                                            goto L52;
                                        }
                                    } else {
                                         *_t218 = st;
                                         *(_t218 + 4) = _a12;
                                        goto L52;
                                    }
                                } else {
                                    st = 16385;
                                    _a12 = ucs;
                                     *_t218 = st;
                                     *(_t218 + 4) = _a12;
                                    goto L52;
                                }
                            }
                            st = 322;
                            _a12 = 32;
                             *_t218 = st;
                             *(_t218 + 4) = _a12;
                            goto L52;
                        }
                        _v60 = ucs;
                        wc_ucs_to_gb18030( &_v36);
                        __esp = __esp - 4;
                        st = _v36;
                        _a12 = _v32;
                        if((st & 16384) != 0) {
                            if(is_wide == 0) {
                                _t195 = 16384;
                            } else {
                                _t195 = 49152;
                            }
                            st = _t195;
                        }
                         *_t218 = st;
                         *(_t218 + 4) = _a12;
                        goto L52;
                    }
                    if(is_wide == 0) {
                        _t197 = ( *(__ebp + 20))[9];
                    } else {
                        _t197 = ( *(__ebp + 20))[8];
                    }
                    _v56 = _t197;
                    wc_ucs_to_any_list( &_v36, ucs);
                    __esp = __esp - 4;
                    st = _v36;
                    _a12 = _v32;
                    if((st & 16384) != 0) {
                        goto L23;
                    } else {
                         *_t218 = st;
                         *(_t218 + 4) = _a12;
                        goto L52;
                    }
                } else {
                     *_t218 = st;
                     *(_t218 + 4) = _a12;
                    goto L52;
                }
            }
            _v56 = ucs;
            wc_ucs_to_johab( &st);
            __esp = __esp - 4;
            if((st & 16384) != 0) {
                if(is_wide == 0) {
                    _t210 = 16384;
                } else {
                    _t210 = 49152;
                }
                st = _t210;
            }
             *_t218 = st;
             *(_t218 + 4) = _a12;
            goto L52;
        }
        st = wc_ucs_to_ccs(ucs);
        _a12 = ucs;
         *_t218 = st;
         *(_t218 + 4) = _a12;
        goto L52;
    } else {
        st = 322;
        _a12 = ucs;
         *_t218 = st;
         *(_t218 + 4) = _a12;
L52:
        return _t218;
    }
}

wc_wchar_t wc_any_to_iso2022(wc_wchar_t cc, wc_status* st)
{// addr = 0x080BECA5  --  defined in 'ucs.c' at line 376
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_uint32 ucs;   // _cfa_fffffff0
    wc_ccs is_wide;     // _cfa_ffffffec
    unsigned int _v32;                     // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    unsigned int _v52;                     // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    unsigned int _v60;                     // _cfa_ffffffc4 (outparam)
    intOrPtr _v64;                         // _cfa_ffffffc0 (outparam)
    intOrPtr _v68;                         // _cfa_ffffffbc
    wc_status* _t181;   // _t181
    unsigned int _t185;                    // _t185
    unsigned int _t195;                    // _t195
    unsigned int _t203;                    // _t203
    unsigned int _t229;                    // _t229
    struct  _t256;            // _t256

    _push(__ebx);
    __esp = __esp - 52;
    _t256 = cc.auto_detect;
     *__esp = st;
    _v56 = _a12;
    ucs = wc_any_to_ucs();
    is_wide = st & 98304;
    if(ucs > 127) {
        if(ucs == -1) {
L54:
            if(is_wide == 0) {
                _t181 = 16384;
            } else {
                _t181 = 49152;
            }
            st = _t181;
             *_t256 = st;
             *(_t256 + 4) = _a12;
        } else {
            if(is_wide == 0) {
                _t185 =  *( *((intOrPtr*)(__ebp + 20)) + 32);
            } else {
                _t185 =  *( *((intOrPtr*)(__ebp + 20)) + 36);
            }
            _v52 = _t185;
            wc_ucs_to_any_list( &st, ucs);
            __esp = __esp - 4;
            if((st & 16384) != 0) {
                if(( *135119020 & 255) != 0) {
L14:
                    if(( *135119013 & 255) != 0) {
L26:
                        if(ucs != 160) {
                            ucs = wc_ucs_to_fullwidth(ucs);
                            if(ucs == -1) {
L52:
                                if(ucs != 160) {
                                    goto L54;
                                } else {
                                    st = 322;
                                    _a12 = 32;
                                     *_t256 = st;
                                     *(_t256 + 4) = _a12;
                                }
                            } else {
                                if(is_wide == 0) {
                                    _t195 =  *( *((intOrPtr*)(__ebp + 20)) + 32);
                                } else {
                                    _t195 =  *( *((intOrPtr*)(__ebp + 20)) + 36);
                                }
                                _v56 = _t195;
                                wc_ucs_to_any_list( &_v36, ucs);
                                __esp = __esp - 4;
                                st = _v36;
                                _a12 = _v32;
                                if((st & 16384) != 0) {
                                    if(( *135119020 & 255) != 0) {
L40:
                                        if(( *135119013 & 255) != 0) {
                                            goto L52;
                                        } else {
                                            if(is_wide == 0) {
                                                _t203 =  *( *((intOrPtr*)(__ebp + 20)) + 36);
                                            } else {
                                                _t203 =  *( *((intOrPtr*)(__ebp + 20)) + 32);
                                            }
                                            _v60 = _t203;
                                            wc_ucs_to_any_list( &_v36, ucs);
                                            __esp = __esp - 4;
                                            st = _v36;
                                            _a12 = _v32;
                                            if((st & 16384) != 0) {
                                                if(( *135119020 & 255) != 0) {
                                                    goto L52;
                                                } else {
                                                    if(is_wide == 0) {
                                                        _v68 = ucs;
                                                        wc_ucs_to_iso2022w( &_v36);
                                                        __esp = __esp - 4;
                                                        st = _v36;
                                                        _a12 = _v32;
                                                    } else {
                                                        _v68 = ucs;
                                                        wc_ucs_to_iso2022( &_v36);
                                                        __esp = __esp - 4;
                                                        st = _v36;
                                                        _a12 = _v32;
                                                    }
                                                    if((st & 16384) != 0) {
                                                        goto L52;
                                                    } else {
                                                         *_t256 = st;
                                                         *(_t256 + 4) = _a12;
                                                    }
                                                }
                                            } else {
                                                 *_t256 = st;
                                                 *(_t256 + 4) = _a12;
                                            }
                                        }
                                    } else {
                                        if(is_wide == 0) {
                                            _v64 = ucs;
                                            wc_ucs_to_iso2022( &_v36);
                                            __esp = __esp - 4;
                                            st = _v36;
                                            _a12 = _v32;
                                        } else {
                                            _v64 = ucs;
                                            wc_ucs_to_iso2022w( &_v36);
                                            __esp = __esp - 4;
                                            st = _v36;
                                            _a12 = _v32;
                                        }
                                        if((st & 16384) != 0) {
                                            goto L40;
                                        } else {
                                             *_t256 = st;
                                             *(_t256 + 4) = _a12;
                                        }
                                    }
                                } else {
                                     *_t256 = st;
                                     *(_t256 + 4) = _a12;
                                }
                            }
                        } else {
                            st = 322;
                            _a12 = 32;
                             *_t256 = st;
                             *(_t256 + 4) = _a12;
                        }
                    } else {
                        if(is_wide == 0) {
                            _t229 =  *( *((intOrPtr*)(__ebp + 20)) + 36);
                        } else {
                            _t229 =  *( *((intOrPtr*)(__ebp + 20)) + 32);
                        }
                        _v56 = _t229;
                        wc_ucs_to_any_list( &_v36, ucs);
                        __esp = __esp - 4;
                        st = _v36;
                        _a12 = _v32;
                        if((st & 16384) != 0) {
                            if(( *135119020 & 255) != 0) {
                                goto L26;
                            } else {
                                if(is_wide == 0) {
                                    _v64 = ucs;
                                    wc_ucs_to_iso2022w( &_v36);
                                    __esp = __esp - 4;
                                    st = _v36;
                                    _a12 = _v32;
                                } else {
                                    _v64 = ucs;
                                    wc_ucs_to_iso2022( &_v36);
                                    __esp = __esp - 4;
                                    st = _v36;
                                    _a12 = _v32;
                                }
                                if((st & 16384) != 0) {
                                    goto L26;
                                } else {
                                     *_t256 = st;
                                     *(_t256 + 4) = _a12;
                                }
                            }
                        } else {
                             *_t256 = st;
                             *(_t256 + 4) = _a12;
                        }
                    }
                } else {
                    if(is_wide == 0) {
                        _v60 = ucs;
                        wc_ucs_to_iso2022( &_v36);
                        __esp = __esp - 4;
                        st = _v36;
                        _a12 = _v32;
                    } else {
                        _v60 = ucs;
                        wc_ucs_to_iso2022w( &_v36);
                        __esp = __esp - 4;
                        st = _v36;
                        _a12 = _v32;
                    }
                    if((st & 16384) != 0) {
                        goto L14;
                    } else {
                         *_t256 = st;
                         *(_t256 + 4) = _a12;
                    }
                }
            } else {
                 *_t256 = st;
                 *(_t256 + 4) = _a12;
            }
        }
    } else {
        st = 322;
        _a12 = ucs;
         *_t256 = st;
         *(_t256 + 4) = _a12;
    }
    return _t256;
}

wc_wchar_t wc_ucs_to_iso2022(wc_uint32 ucs)
{// addr = 0x080BF0AF  --  defined in 'ucs.c' at line 443
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_table* t;      // _cfa_fffffff0
    int f;                                 // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    wc_wchar_t cc;   // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    wc_table* _v52;   // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    struct  _t101;            // _t101

    _push(__ebx);
    __esp = __esp - 52;
    _t101 = ucs;
    if( *(__ebp + 12) > 65535) {
L22:
        cc.auto_detect = 16384;
         *_t101 = cc.auto_detect;
         *((intOrPtr*)(_t101 + 4)) = _v24;
    } else {
        f = 0;
        while(f <= 38) {
            t =  &ucs_cs96_table + (f << 4);
            if(t->map == 0) {
                goto L6;
            } else {
                _v52 = t;
                wc_ucs_to_any( &cc,  *(__ebp + 12) & 65535);
                __esp = __esp - 4;
                if((cc.auto_detect & 16384) != 0) {
L6:
                    f = f + 1;
                    continue;
                } else {
                     *_t101 = cc.auto_detect;
                     *((intOrPtr*)(_t101 + 4)) = _v24;
                }
            }
            goto L23;
        }
        f = 0;
        while(f <= 20) {
            t =  &ucs_cs94_table + (f << 4);
            if(t->map == 0) {
                goto L13;
            } else {
                _v52 = t;
                wc_ucs_to_any( &_v36,  *(__ebp + 12) & 65535);
                __esp = __esp - 4;
                cc.auto_detect = _v36;
                _v24 = _v32;
                if((cc.auto_detect & 16384) != 0) {
L13:
                    f = f + 1;
                    continue;
                } else {
                     *_t101 = cc.auto_detect;
                     *((intOrPtr*)(_t101 + 4)) = _v24;
                }
            }
            goto L23;
        }
        f = 0;
        while(f < -63) {
            t = ucs_cs942_table + (f << 4);
            if(t->map == 0) {
                goto L20;
            } else {
                _v52 = t;
                wc_ucs_to_any( &_v36,  *(__ebp + 12) & 65535);
                __esp = __esp - 4;
                cc.auto_detect = _v36;
                _v24 = _v32;
                if((cc.auto_detect & 16384) != 0) {
L20:
                    f = f + 1;
                    continue;
                } else {
                     *_t101 = cc.auto_detect;
                     *((intOrPtr*)(_t101 + 4)) = _v24;
                }
            }
            goto L23;
        }
        goto L22;
    }
L23:
    return _t101;
}

wc_wchar_t wc_ucs_to_iso2022w(wc_uint32 ucs)
{// addr = 0x080BF22D  --  defined in 'ucs.c' at line 480
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_table* t;      // _cfa_fffffff0
    int f;                                 // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    wc_wchar_t cc;   // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    wc_table* _v52;   // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    struct  _t69;             // _t69

    _push(__ebx);
    __esp = __esp - 52;
    _t69 = ucs;
    if( *(__ebp + 12) > 65535) {
L15:
        cc.auto_detect = 49152;
         *_t69 = cc.auto_detect;
         *((intOrPtr*)(_t69 + 4)) = _v24;
    } else {
        f = 0;
        while(f <= 16) {
            t =  &ucs_cs94w_table + (f << 4);
            if(t->map == 0) {
                goto L6;
            } else {
                _v52 = t;
                wc_ucs_to_any( &cc,  *(__ebp + 12) & 65535);
                __esp = __esp - 4;
                if((cc.auto_detect & 16384) != 0) {
L6:
                    f = f + 1;
                    continue;
                } else {
                     *_t69 = cc.auto_detect;
                     *((intOrPtr*)(_t69 + 4)) = _v24;
                }
            }
            goto L16;
        }
        f = 0;
        while(f < -63) {
            t = ucs_cs96w_table + (f << 4);
            if(t->map == 0) {
                goto L13;
            } else {
                _v52 = t;
                wc_ucs_to_any( &_v36,  *(__ebp + 12) & 65535);
                __esp = __esp - 4;
                cc.auto_detect = _v36;
                _v24 = _v32;
                if((cc.auto_detect & 16384) != 0) {
L13:
                    f = f + 1;
                    continue;
                } else {
                     *_t69 = cc.auto_detect;
                     *((intOrPtr*)(_t69 + 4)) = _v24;
                }
            }
            goto L16;
        }
        goto L15;
    }
L16:
    return _t69;
}

wc_ccs wc_ucs_to_ccs(wc_uint32 ucs)
{// addr = 0x080BF338  --  defined in 'ucs.c' at line 509
    _unknown_ __ebx;                       // r1
    signed int _t8;                        // _t8
    signed int _t11;                       // _t11
    signed int _t14;                       // _t14
    signed int _t15;                       // _t15

    if(ucs <= 127 || ucs > 159) {
        if(ucs > 65535) {
            _t14 = 8192;
        } else {
            _t14 = 4096;
        }
        if(wc_is_ucs_wide(ucs) == 0) {
            _t8 = 0;
        } else {
            _t8 = 65536;
        }
        _t15 = _t14 | _t8;
        if(wc_is_ucs_combining(ucs) == 0) {
            _t11 = 0;
        } else {
            _t11 = 131072;
        }
        return _t11 | _t15;
    } else {
        return 16385;
    }
}

wc_bool wc_is_ucs_wide(wc_uint32 ucs)
{// addr = 0x080BF3AA  --  defined in 'ucs.c' at line 519
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(ucs > 65535) {
        if(0 == 131072 || 0 == 196608) {
            return 1;
        } else {
            return 0;
        }
    }
    return wc_map_range_search(ucs & 65535,  &ucs_wide_map, 11) != 0;
}

wc_bool wc_is_ucs_combining(wc_uint32 ucs)
{// addr = 0x080BF408  --  defined in 'ucs.c' at line 530
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(( *135119009 & 255) != 0 && ucs <= 65535 && wc_map_range_search(ucs & 65535,  &ucs_combining_map, 99) != 0) {
        return 1;
    }
    return 0;
}

wc_bool wc_is_ucs_hangul(wc_uint32 ucs)
{// addr = 0x080BF452  --  defined in 'ucs.c' at line 538
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(ucs > 65535 || wc_map_range_search(ucs & 65535,  &ucs_hangul_map, 6) == 0) {
        return 0;
    } else {
        return 1;
    }
}

wc_uint32 wc_ucs_precompose(wc_uint32 ucs1, wc_uint32 ucs2)
{// addr = 0x080BF491  --  defined in 'ucs.c' at line 546
    wc_map3* map;      // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(( *135119009 & 255) != 0 && ucs1 <= 65535 && ucs2 <= 65535) {
        map = wc_map3_search(ucs1 & 65535, ucs2 & 65535,  &ucs_precompose_map, 988);
        if(map == 0) {
            goto L5;
        } else {
            return map->code3 & 0xffff;
        }
    }
L5:
    return -1;
}

wc_uint32 wc_ucs_to_fullwidth(wc_uint32 ucs)
{// addr = 0x080BF4F8  --  defined in 'ucs.c' at line 559
    wc_map* map;        // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(ucs > 65535) {
L3:
        return -1;
    }
    map = wc_map_search(ucs & 65535,  &ucs_fullwidth_map, 14);
    if(map == 0) {
        goto L3;
    }
    return map->code2 & 0xffff;
}

int wc_ucs_put_tag(char* p)
{// addr = 0x080BF541  --  defined in 'ucs.c' at line 571
    int i;                                 // _cfa_fffffff0
    intOrPtr _v40;                         // _cfa_ffffffd8
    char* _t22;                            // _t22

    if(p == 0 || ( *p & 255) == 0) {
        return 0;
    } else {
        i = 1;
        while(i <= n_tag_map) {
            _v40 =  *((intOrPtr*)( &tag_map + i * 4));
            _t22 = p;
             *__esp = _t22;
            strcasecmp();
            if(_t22 != 0) {
                i = i + 1;
                continue;
            }
            return i;
        }
        n_tag_map = n_tag_map + 1;
        if(n_tag_map != 256) {
             *( &tag_map + n_tag_map * 4) = p;
            return n_tag_map;
        }
        return 0;
    }
}

char* wc_ucs_get_tag(int ntag)
{// addr = 0x080BF5CD  --  defined in 'ucs.c' at line 589
    if(ntag == 0 || ntag > n_tag_map) {
        return 0;
    } else {
        return  *( &tag_map + ntag * 4);
    }
}

void wtf_push_ucs(Str os, wc_uint32 ucs, wc_status* st)
{// addr = 0x080BF5F3  --  defined in 'ucs.c' at line 597
    wc_ccs ccs;         // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    wc_status* _t87;   // _t87
    int _t110;                             // _t110
    Str _t139;             // _t139
    signed int _t165;                      // _t165

    if(ucs <= 917503 || ucs > 917631) {
        _t87 = st;
        __eflags = _t87->tag;
        if(_t87->tag != 0) {
            st->ntag = wc_ucs_put_tag( *(st->tag));
            st->tag = 0;
        }
        __eflags = ucs - 127;
        if(ucs > 127) {
            ccs = wc_ucs_to_ccs(ucs);
            __eflags = st->ntag;
            if(__eflags != 0) {
                __eflags = ucs - 1114111;
                if(__eflags <= 0) {
                    ccs = 0x2001;
                    ucs = ucs | st->ntag << 24;
                    __eflags = ucs;
                }
            }
            wtf_push(os, ccs, ucs);
            return;
        } else {
            __eflags = st->ntag;
            if(__eflags == 0) {
                __eflags = os->length + 1 - os->area_size;
                if(__eflags >= 0) {
                    Strgrow(os);
                }
                _t110 = os->length;
                 *((char*)(os->ptr + _t110)) = ucs;
                os->length = _t110 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            wtf_push(os, 8193, st->ntag << 24 | ucs);
            return;
        }
    } else {
        if(( *135119010 & 255) == 0) {
            return;
        }
        if(ucs != 917505) {
            __eflags = ucs - 917631;
            if(__eflags != 0) {
                __eflags = st->tag;
                if(__eflags == 0) {
                    return;
                }
                __eflags = ucs - 917535;
                if(__eflags <= 0) {
                    return;
                }
                __eflags =  *(st->tag + 4) + 1 - st->tag->area_size;
                if(__eflags >= 0) {
                    Strgrow(st->tag);
                }
                _t139 = st->tag;
                _t165 =  *(_t139 + 4);
                ( *(st->tag))[_t165] = ucs & 127;
                 *(_t139 + 4) = _t165 + 1;
                ( *(st->tag))[ *(st->tag + 4)] = 0;
                return;
            }
            st->tag = 0;
            st->ntag = 0;
            return;
        }
        st->tag = Strnew_size(4);
        return;
    }
}

wc_wchar_t wc_uhc_to_cs128w(wc_wchar_t cc)
{// addr = 0x080BF800  --  defined in 'uhc.c' at line 36
    _unknown_ __ebx;                       // r1
    _unknown_ _t26;                        // _t26
    _unknown_ _t45;                        // _t45

    __ecx = cc.auto_detect;
    _t45 = (_a12 >> 8 & 255) * 178 + (_a12 & 255);
    if((_a12 & 255) <= 96) {
        _t26 = 65;
    } else {
        if((_a12 & 255) > 128) {
            _t26 = 77;
        } else {
            _t26 = 71;
        }
    }
    _a12 = _t45 - _t26 - 22962;
    if(_a12 > 16383) {
         *((intOrPtr*)(__ebp + 12)) = 34846;
        _a12 = _a12 - 16384;
    } else {
         *((intOrPtr*)(__ebp + 12)) = 34845;
    }
    _a12 = (_a12 >> 7 << 8) + (_a12 & 127);
     *__ecx =  *((intOrPtr*)(__ebp + 12));
     *(__ecx + 4) = _a12;
    return __ecx;
}

wc_wchar_t wc_cs128w_to_uhc(wc_wchar_t cc)
{// addr = 0x080BF8AF  --  defined in 'uhc.c' at line 50
    signed int _v20;                       // _cfa_ffffffec
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    struct  __esi;            // r5
    _unknown_ _t60;                        // _t60
    _unknown_ _t79;                        // _t79
    signed int _t96;                       // _t96

    __esi = cc.auto_detect;
    _a12 = ((_a12 >> 8 & 127) << 7) + (_a12 & 127);
    if( *((intOrPtr*)(__ebp + 12)) == 34846) {
        _a12 = _a12 + 16384;
    }
     *((intOrPtr*)(__ebp + 12)) = 34844;
    _v20 = _a12;
    _t96 = (_v20 * -1206451487 >> 32 >> 7) + 129 << 8;
    _t79 = _a12 - (_a12 * -1206451487 >> 32 >> 7) * 178;
    if(_a12 - (_a12 * -1206451487 >> 32 >> 7) * 178 <= 25) {
        _t60 = 65;
    } else {
        if(_a12 - (_a12 * -1206451487 >> 32 >> 7) * 178 > 51) {
            _t60 = 77;
        } else {
            _t60 = 71;
        }
    }
    _a12 = _t96 + _t79 + _t60;
     *__esi =  *((intOrPtr*)(__ebp + 12));
     *(__esi + 4) = _a12;
    return __esi;
}

wc_uint32 wc_uhc_to_N(wc_uint32 c)
{// addr = 0x080BF9A2  --  defined in 'uhc.c' at line 61
    _unknown_ _t27;                        // _t27
    _unknown_ _t43;                        // _t43
    _unknown_ _t54;                        // _t54
    _unknown_ _t67;                        // _t67
    _unknown_ _t71;                        // _t71
    _unknown_ _t74;                        // _t74

    if(c > 41376) {
        if(c > 41632) {
            if(c > 41703) {
                _t67 = (c >> 8 & 255) * 178 + (c & 255);
                if((c & 255) <= 96) {
                    _t27 = 65;
                } else {
                    if((c & 255) > 128) {
                        _t27 = 77;
                    } else {
                        _t27 = 71;
                    }
                }
                return _t67 - _t27 - (c >> 8) * 94 - 7826;
            }
            return c - 35838;
        }
        _t71 = (c >> 8 & 255) * 178 + (c & 255);
        if((c & 255) <= 96) {
            _t43 = 65;
        } else {
            if((c & 255) > 128) {
                _t43 = 77;
            } else {
                _t43 = 71;
            }
        }
        return _t71 - _t43 - 23056;
    }
    _t74 = (c >> 8 & 255) * 178 + (c & 255);
    if((c & 255) <= 96) {
        _t54 = 65;
    } else {
        if((c & 255) > 128) {
            _t54 = 77;
        } else {
            _t54 = 71;
        }
    }
    return _t74 - _t54 - 22962;
}

Str wc_conv_from_uhc(Str is, wc_ces ces)
{// addr = 0x080BFAE3  --  defined in 'uhc.c' at line 74
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    int state;                             // _cfa_ffffffe0
    wc_uint32 uhc;   // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    int _t99;                              // _t99
    signed int _t104;                      // _t104
    int _t113;                             // _t113

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    p = sp;
    while(p < ep) {
        if(( *p & 255) >= 0) {
            p =  &(p[1]);
            continue;
        }
        break;
    }
    if(p == ep) {
        return is;
    }
    os = Strnew_size(is->length);
    if(p > sp) {
        Strcat_charp_n(os, is->ptr, p - sp);
    }
    while(p < ep) {
        _t99 = state;
        if(_t99 == 0) {
            _t104 =  *( &WC_UHC_MAP + ( *p & 0xff)) & 0xff;
            if(_t104 == 2) {
                wtf_push_unknown(os, p, 1);
L18:
L28:
                p =  &(p[1]);
                continue;
            }
            if(_t104 != 12) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t113 = os->length;
                 *((char*)(os->ptr + _t113)) =  *p & 255;
                os->length = _t113 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                goto L28;
            }
            state = 1;
            goto L18;
        }
        if(_t99 == 1) {
            if(( *( &WC_UHC_MAP + ( *p & 0xff)) & 4) == 0) {
                wtf_push_unknown(os, p - 1, 2);
            } else {
                uhc =  *p & 0xff | ( *(p - 1) & 0xff) << 8;
                if(( *(p - 1) & 255) <= 160 || ( *p & 255) <= 160 || uhc == 41702 || uhc == 41703) {
                    wtf_push(os, 34844, uhc);
                } else {
                    wtf_push(os, 33091, uhc);
                }
            }
            state = 0;
        }
        goto L28;
    }
    if(state == 1) {
        wtf_push_unknown(os, p - 1, 1);
    }
    return os;
}

void wc_push_to_uhc(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080BFD21  --  defined in 'uhc.c' at line 129
    wc_status* _v16;   // _cfa_fffffff0
    unsigned char _v20;                    // _cfa_ffffffec
    intOrPtr _v32;                         // _cfa_ffffffe0
    wc_status* _v36;   // _cfa_ffffffdc
    unsigned char _v40;                    // _cfa_ffffffd8 (outparam)
    unsigned char _t109;                   // _t109
    int _t116;                             // _t116
    int _t128;                             // _t128
    unsigned char _t143;                   // _t143
    int _t156;                             // _t156
    int _t168;                             // _t168
    int _t182;                             // _t182

    while(1) {
        _t109 = cc.auto_detect;
        if(_t109 == 34844) {
            break;
        }
        if(_t109 > 34844) {
            if(_t109 <= 34846) {
                _v40 = cc.auto_detect;
                _v36 = st;
                 *__esp =  &cc;
                wc_cs128w_to_uhc();
                __esp = __esp - 4;
                break;
            }
            if(_t109 == 49152) {
                if(( *135119022 & 255) != 0) {
                    return;
                }
                Strcat_charp(os, WcReplaceW);
                return;
            }
L28:
            if(( *135119011 & 255) == 0) {
                if((cc.auto_detect & 98304) == 0) {
                    _t143 = 16384;
                } else {
                    _t143 = 49152;
                }
                cc.auto_detect = _t143;
            } else {
                _v32 =  *((intOrPtr*)(__ebp + 20));
                _v40 = cc.auto_detect;
                _v36 = st;
                 *__esp =  &_v20;
                wc_any_to_any_ces();
                __esp = __esp - 4;
                cc.auto_detect = _v20;
                st = _v16;
            }
            continue;
        }
        if(_t109 != 16384) {
            if(_t109 == 33091) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t156 = os->length;
                 *((char*)(os->ptr + _t156)) = st >> 8 | -128;
                os->length = _t156 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t168 = os->length;
                 *((char*)(os->ptr + _t168)) = st | -128;
                os->length = _t168 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            if(_t109 == 322) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t182 = os->length;
                 *((char*)(os->ptr + _t182)) = st;
                os->length = _t182 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            goto L28;
        }
        if(( *135119022 & 255) == 0) {
            Strcat_charp(os, WcReplace);
            return;
        }
        return;
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t116 = os->length;
     *((char*)(os->ptr + _t116)) = st >> 8;
    os->length = _t116 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t128 = os->length;
     *((char*)(os->ptr + _t128)) = st;
    os->length = _t128 + 1;
     *((char*)(os->ptr + os->length)) = 0;
}

Str wc_char_conv_from_uhc(wc_uchar c, wc_status* st)
{// addr = 0x080BFFD6  --  defined in 'uhc.c' at line 168
    wc_uint32 uhc;   // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t41;                              // _t41
    signed int _t44;                       // _t44
    struct _Str* _t52;    // _t52
    int _t79;                              // _t79

    _v32 = c;
    if(st->state == -1) {
        st->state = 0;
        os.2735 = Strnew_size(8);
    }
    _t41 = st->state;
    if(_t41 == 0) {
        _t44 =  *( &WC_UHC_MAP + (_v32 & 255)) & 0xff;
        if(_t44 != 2) {
            if(_t44 == 12) {
                uhcu = _v32 & 255;
                st->state = 1;
                return 0;
            }
            if(os.2735->length + 1 >= os.2735->area_size) {
                Strgrow(os.2735);
            }
            _t52 = os.2735;
            _t79 = _t52->length;
             *((char*)( *os.2735 + _t79)) = _v32 & 255;
            _t52->length = _t79 + 1;
             *((char*)( *os.2735 + os.2735->length)) = 0;
        }
    } else {
        if(_t41 == 1) {
            if(( *( &WC_UHC_MAP + (_v32 & 255)) & 4) != 0) {
                uhc = _v32 & 255 | (uhcu & 0xff) << 8;
                if((uhcu & 255) <= 160 || _v32 <= 160 || uhc == 41702 || uhc == 41703) {
                    wtf_push(os.2735, 34844, uhc);
                } else {
                    wtf_push(os.2735, 33091, uhc);
                }
            }
        }
    }
    st->state = -1;
    return os.2735;
}

Str wc_conv_from_utf7(Str is, wc_ces ces)
{// addr = 0x080C0158  --  defined in 'utf7.c' at line 62
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    int state;                             // _cfa_ffffffe0
    wc_uint32 b;     // _cfa_ffffffdc
    wc_uint32 high;   // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    wc_status st;    // _cfa_ffffff9c
    _unknown_ _v116;                       // _cfa_ffffff8c (outparam)
    _unknown_ _v120;                       // _cfa_ffffff88 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    int _t144;                             // _t144
    signed int _t151;                      // _t151
    signed int _t188;                      // _t188
    int _t195;                             // _t195

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    high = 0;
    p = sp;
    while(p < ep && ( *p & 255) >= 0) {
        if(( *p & 255) != 43) {
            p =  &(p[1]);
            continue;
        }
        break;
    }
    if(p == ep) {
        return is;
    }
    os = Strnew_size((is->length * 4 * 1431655766 >> 32) - (is->length * 4 >> 31));
    if(p > sp) {
        Strcat_charp_n(os, is->ptr, p - sp);
    }
    _v56 = 0;
    _v52 = 0;
    while(p < ep) {
        _t144 = state;
        if(_t144 == 1) {
            if(( *p & 255) == 45) {
                wtf_push_ucs(os, 43,  &st);
            }
L17:
            _t151 =  *( &WC_UTF7_MAP + ( *p & 0xff)) & 0xff;
            if(_t151 == 32) {
L20:
                b =  *( &c_base64_map + ( *p & 0xff) - 32) & 255;
                _v44 = _v44 - 6;
                if(_v44 <= 0) {
                    _v48 = _v48 | b >>  ~_v44;
                    if(_v48 <= 55295 || _v48 > 56319) {
                        if(_v48 <= 56319 || _v48 > 57343) {
                            if(_v48 != 65279) {
                                wtf_push_ucs(os, _v48,  &st);
                            }
                        } else {
                            if(high != 0) {
                                wtf_push_ucs(os, (_v48 & 1023 | (high & 1023) << 10) + 65536,  &st);
                            }
                            high = 0;
                        }
                    } else {
                        if(high != 0) {
                            high = 0;
                        } else {
                            high = _v48;
                        }
                    }
                    _v44 = _v44 + 16;
                    _v48 = 0;
                }
                _v48 = b << _v44 & 65535 | _v48;
                state = 2;
L45:
                p =  &(p[1]);
                continue;
            }
            if(_t151 == 64) {
                state = 0;
                goto L45;
            }
            if(_t151 != 16) {
L37:
                _t188 =  *( &WC_UTF7_MAP + ( *p & 0xff)) & 0xff;
                if(_t188 == 6) {
L40:
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t195 = os->length;
                     *((char*)(os->ptr + _t195)) =  *p & 255;
                    os->length = _t195 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    goto L45;
                }
                if(_t188 == 8) {
                    wtf_push_unknown(os, p, 1);
                    goto L45;
                }
                if(_t188 != 4) {
                    wtf_push_ucs(os,  *p & 0xff,  &st);
                    goto L45;
                }
                goto L40;
            }
            goto L20;
        }
        if(_t144 == 2) {
            goto L17;
        }
        if(_t144 != 0) {
            goto L37;
        }
        if(( *p & 255) != 43) {
            goto L37;
        } else {
            state = 1;
            _v44 = 16;
            _v48 = 0;
            high = 0;
            goto L45;
        }
    }
    return os;
}

void wc_push_ucs_to_utf7(Str os, wc_uint32 ucs, wc_status* st)
{// addr = 0x080C04AB  --  defined in 'utf7.c' at line 146
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    int _t289;                             // _t289
    int _t304;                             // _t304
    int _t328;                             // _t328
    int _t352;                             // _t352
    signed int _t361;                      // _t361
    int _t370;                             // _t370
    int _t383;                             // _t383
    int _t395;                             // _t395
    int _t412;                             // _t412
    int _t424;                             // _t424
    int _t438;                             // _t438
    int _t450;                             // _t450

    if(ucs > 1114111) {
        return;
    }
    if(ucs <= 65535) {
        if(ucs > 127) {
L31:
            if(st->state != 2 || st->shift == 0) {
                if(st->state != 2) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t328 = os->length;
                     *((char*)(os->ptr + _t328)) = 43;
                    os->length = _t328 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    st->state = 2;
                }
                st->shift = 16;
                st->base = 0;
            } else {
                st->shift = st->shift + 16;
                st->base = st->base | ucs >> st->shift;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t352 = os->length;
                 *((char*)(os->ptr + _t352)) =  *(st->base + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") & 255;
                os->length = _t352 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
            }
            st->shift = st->shift - 6;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t289 = os->length;
             *((char*)(os->ptr + _t289)) =  *((ucs >> st->shift & 63) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") & 255;
            os->length = _t289 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            st->shift = st->shift - 6;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t304 = os->length;
             *((char*)(os->ptr + _t304)) =  *((ucs >> st->shift & 63) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") & 255;
            os->length = _t304 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            if(st->shift == 0) {
                return;
            } else {
                st->shift = st->shift - 6;
                st->base = ucs <<  ~(st->shift) & 63;
                return;
            }
        }
        _t361 =  *( &WC_UTF7_MAP + ucs) & 0xff;
        if(_t361 == 16) {
L11:
            if(st->state == 2) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t383 = os->length;
                 *((char*)(os->ptr + _t383)) =  *(st->base + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") & 255;
                os->length = _t383 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t395 = os->length;
                 *((char*)(os->ptr + _t395)) = 45;
                os->length = _t395 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                st->state = 0;
            }
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t370 = os->length;
             *((char*)(os->ptr + _t370)) = ucs;
            os->length = _t370 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(_t361 > 16) {
            if(_t361 == 32) {
                if(st->state == 2) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t438 = os->length;
                     *((char*)(os->ptr + _t438)) =  *(st->base + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") & 255;
                    os->length = _t438 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t450 = os->length;
                     *((char*)(os->ptr + _t450)) = 45;
                    os->length = _t450 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    st->state = 0;
                }
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t412 = os->length;
                 *((char*)(os->ptr + _t412)) = 43;
                os->length = _t412 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t424 = os->length;
                 *((char*)(os->ptr + _t424)) = 45;
                os->length = _t424 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            if(_t361 != 64) {
                goto L31;
            }
            goto L11;
        }
        if(_t361 == 0 || _t361 == 4) {
            goto L11;
        } else {
            goto L31;
        }
    }
    ucs = ucs - 65536 & 1023 | (ucs - 65536 >> 10 | 216) << 16 | 220;
    wc_push_ucs_to_utf7(os, ucs >> 16, st);
    wc_push_ucs_to_utf7(os, ucs & 65535, st);
}

int wc_push_tag_to_utf7(Str os, int ntag, wc_status* st)
{// addr = 0x080C0A16  --  defined in 'utf7.c' at line 204
    char* p;                               // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(ntag != 0) {
        p = wc_ucs_get_tag(ntag);
        if(p == 0) {
            ntag = 0;
        }
    }
    if(ntag == 0) {
        wc_push_ucs_to_utf7(os, 917631, st);
        goto L9;
    } else {
        wc_push_ucs_to_utf7(os, 917505, st);
        while(( *p & 255) != 0) {
            wc_push_ucs_to_utf7(os,  *p & 255 | 917504, st);
            p =  &(p[1]);
        }
L9:
        return ntag;
    }
}

void wc_push_to_utf7(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C0AB2  --  defined in 'utf7.c' at line 223
    char* p;                               // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    wc_status* _v40;   // _cfa_ffffffd8 (outparam)
    signed int _t89;                       // _t89
    unsigned char _t100;                   // _t100
    unsigned char _t141;                   // _t141

    while(1) {
L1:
        _t89 = cc.auto_detect & 65535;
        if(_t89 == 8192) {
            break;
        }
        if(_t89 > 8192) {
            if(_t89 == 16384) {
                if(( *135119022 & 255) != 0) {
                    return;
                }
                if( *(__ebp + 20)->ntag != 0) {
                     *(__ebp + 20)->ntag = wc_push_tag_to_utf7(os, 0,  *(__ebp + 20));
                }
                p = WcReplace;
                while(( *p & 255) != 0) {
                    wc_push_ucs_to_utf7(os,  *p & 255,  *(__ebp + 20));
                    p =  &(p[1]);
                }
                return;
            }
            if(_t89 == 49152) {
                if(( *135119022 & 255) != 0) {
                    return;
                }
                if( *(__ebp + 20)->ntag != 0) {
                     *(__ebp + 20)->ntag = wc_push_tag_to_utf7(os, 0,  *(__ebp + 20));
                }
                p = WcReplaceW;
                while(( *p & 255) != 0) {
                    wc_push_ucs_to_utf7(os,  *p & 255,  *(__ebp + 20));
                    p =  &(p[1]);
                }
                return;
            }
            if(_t89 == 8193) {
                if(( *135119010 & 255) != 0 && st >> 24 !=  *(__ebp + 20)->ntag) {
                     *(__ebp + 20)->ntag = wc_push_tag_to_utf7(os, st >> 24,  *(__ebp + 20));
                }
                wc_push_ucs_to_utf7(os, st & 2097151,  *(__ebp + 20));
                return;
            }
L40:
            if(( *135119011 & 255) == 0) {
L43:
                if((cc.auto_detect & 98304) == 0) {
                    _t141 = 16384;
                } else {
                    _t141 = 49152;
                }
                cc.auto_detect = _t141;
                continue;
            }
             *__esp = cc.auto_detect;
            _v40 = st;
            st = wc_any_to_ucs();
            if(st == -1) {
                goto L43;
            }
            cc.auto_detect = 4096;
            continue;
        }
        if(_t89 == 577) {
            if( *(__ebp + 20)->ntag != 0) {
                 *(__ebp + 20)->ntag = wc_push_tag_to_utf7(os, 0,  *(__ebp + 20));
            }
            wc_push_ucs_to_utf7(os, st | 128,  *(__ebp + 20));
            return;
        }
        if(_t89 == 4096 || _t89 == 322) {
L16:
            if( *(__ebp + 20)->ntag != 0) {
                 *(__ebp + 20)->ntag = wc_push_tag_to_utf7(os, 0,  *(__ebp + 20));
            }
            wc_push_ucs_to_utf7(os, st,  *(__ebp + 20));
            return;
        } else {
            goto L40;
        }
    }
    if(st <= 1114111) {
        goto L16;
    }
    if((cc.auto_detect & 98304) == 0) {
        _t100 = 16384;
    } else {
        _t100 = 49152;
    }
    cc.auto_detect = _t100;
    goto L1;
}

void wc_push_to_utf7_end(Str os, wc_status* st)
{// addr = 0x080C0D72  --  defined in 'utf7.c' at line 278
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    int _t61;                              // _t61
    int _t74;                              // _t74

    if(st->ntag != 0) {
        st->ntag = wc_push_tag_to_utf7(os, 0, st);
    }
    if(st->state == 2) {
        if(st->shift != 0) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t74 = os->length;
             *((char*)(os->ptr + _t74)) =  *(st->base + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") & 255;
            os->length = _t74 + 1;
             *((char*)(os->ptr + os->length)) = 0;
        }
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t61 = os->length;
         *((char*)(os->ptr + _t61)) = 45;
        os->length = _t61 + 1;
         *((char*)(os->ptr + os->length)) = 0;
        return;
    }
}

Str wc_char_conv_from_utf7(wc_uchar c, wc_status* st)
{// addr = 0x080C0E5E  --  defined in 'utf7.c' at line 291
    wc_uint32 b;     // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    int _t102;                             // _t102
    signed int _t105;                      // _t105
    signed int _t160;                      // _t160
    struct _Str* _t166;   // _t166
    int _t206;                             // _t206

    _v32 = c;
    if(st->state == -1) {
        st->state = 0;
        os.2932 = Strnew_size(8);
    }
    _t102 = st->state;
    if(_t102 == 1) {
        if(_v32 != 45) {
L9:
            _t105 =  *( &WC_UTF7_MAP + (_v32 & 255)) & 0xff;
            if(_t105 == 32) {
L12:
                b =  *( &c_base64_map + (_v32 & 255) - 32) & 255;
                st->shift = st->shift - 6;
                if(st->shift <= 0) {
                    st->base = st->base | b >>  ~(st->shift);
                    if(st->base <= 55295 || st->base > 56319) {
                        if(st->base <= 56319 || st->base > 57343) {
                            if(st->base != 65279) {
                                wtf_push_ucs(os.2932, st->base, st);
                            }
                        } else {
                            if(high.2933 != 0) {
                                wtf_push_ucs(os.2932, (st->base & 1023 | (high.2933 & 1023) << 10) + 65536, st);
                            }
                            high.2933 = 0;
                        }
                    } else {
                        if(high.2933 != 0) {
                            high.2933 = 0;
                        } else {
                            high.2933 = st->base;
                        }
                    }
                    st->shift = st->shift + 16;
                    st->base = 0;
                }
                st->base = st->base | b << st->shift & 65535;
                st->state = 2;
                return os.2932;
            }
            if(_t105 == 64) {
                st->state = -1;
                return 0;
            }
            if(_t105 != 16) {
L29:
                _t160 =  *( &WC_UTF7_MAP + (_v32 & 255)) & 0xff;
                if(_t160 == 6) {
L32:
                    if(os.2932->length + 1 >= os.2932->area_size) {
                        Strgrow(os.2932);
                    }
                    _t166 = os.2932;
                    _t206 = _t166->length;
                     *((char*)( *os.2932 + _t206)) = _v32 & 255;
                    _t166->length = _t206 + 1;
                     *((char*)( *os.2932 + os.2932->length)) = 0;
L37:
                    st->state = -1;
                    return os.2932;
                }
                if(_t160 == 8) {
                    goto L37;
                }
                if(_t160 != 4) {
                    wtf_push_ucs(os.2932, _v32 & 255, st);
                    goto L37;
                }
                goto L32;
            }
            goto L12;
        }
        wtf_push_ucs(os.2932, 43, st);
        st->state = -1;
        return os.2932;
    }
    if(_t102 == 2) {
        goto L9;
    }
    if(_t102 == 0) {
        if(_v32 == 43) {
            st->state = 1;
            st->shift = 16;
            st->base = 0;
            high.2933 = 0;
            return 0;
        }
    }
    goto L29;
}

size_t wc_ucs_to_utf8(wc_uint32 ucs, wc_uchar* utf8)
{// addr = 0x080C117C  --  defined in 'utf8.c' at line 32
    if(ucs > 127) {
        if(ucs > 2047) {
            if(ucs > 65535) {
                if(ucs > 2097151) {
                    if(ucs > 67108863) {
                        if(ucs < 0) {
                             *utf8 = 0;
                            return 0;
                        }
                         *utf8 = ucs >> 30 | -4;
                        utf8[1] = ucs >> 24 & 63 | -128;
                        utf8[2] = ucs >> 18 & 63 | -128;
                        utf8[3] = ucs >> 12 & 63 | -128;
                        utf8[4] = ucs >> 6 & 63 | -128;
                        utf8[5] = ucs & 63 | -128;
                        utf8[6] = 0;
                        return 6;
                    }
                     *utf8 = ucs >> 24 | -8;
                    utf8[1] = ucs >> 18 & 63 | -128;
                    utf8[2] = ucs >> 12 & 63 | -128;
                    utf8[3] = ucs >> 6 & 63 | -128;
                    utf8[4] = ucs & 63 | -128;
                    utf8[5] = 0;
                    return 5;
                }
                 *utf8 = ucs >> 18 | -16;
                utf8[1] = ucs >> 12 & 63 | -128;
                utf8[2] = ucs >> 6 & 63 | -128;
                utf8[3] = ucs & 63 | -128;
                utf8[4] = 0;
                return 4;
            }
             *utf8 = ucs >> 12 | -32;
            utf8[1] = ucs >> 6 & 63 | -128;
            utf8[2] = ucs & 63 | -128;
            utf8[3] = 0;
            return 3;
        }
         *utf8 = ucs >> 6 | -64;
        utf8[1] = ucs & 63 | -128;
        utf8[2] = 0;
        return 2;
    }
     *utf8 = ucs;
    utf8[1] = 0;
    return 1;
}

wc_uint32 wc_utf8_to_ucs(wc_uchar* utf8)
{// addr = 0x080C13A7  --  defined in 'utf8.c' at line 80
    wc_uint32 ucs;   // _cfa_fffffff8
    if(( *( &WC_UTF8_MAP + ( *utf8 & 0xff)) & 0xff) <= 6) {
        goto __eax;
    }
    return -1;
}

Str wc_conv_from_utf8(Str is, wc_ces ces)
{// addr = 0x080C15E5  --  defined in 'utf8.c' at line 137
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    wc_uchar* q;      // _cfa_ffffffe0
    int state;                             // _cfa_ffffffdc
    size_t next;        // _cfa_ffffffd8
    wc_uint32 ucs;   // _cfa_ffffffd4
    int _v56;                              // _cfa_ffffffc8
    int _v60;                              // _cfa_ffffffc4
    wc_status st;    // _cfa_ffffff98
    _unknown_ _v116;                       // _cfa_ffffff8c (outparam)
    _unknown_ _v120;                       // _cfa_ffffff88 (outparam)
    int _t134;                             // _t134
    size_t _t140;       // _t140
    int _t153;                             // _t153

    sp = is->ptr;
    ep = sp + is->length;
    q = 0;
    state = 0;
    next = 0;
    p = sp;
    while(p < ep) {
        if(( *p & 255) >= 0) {
            p =  &(p[1]);
            continue;
        }
        break;
    }
    if(p == ep) {
        return is;
    }
    os = Strnew_size((is->length * 4 * 1431655766 >> 32) - (is->length * 4 >> 31));
    if(p > sp) {
        Strcat_charp_n(os, is->ptr, p - sp);
    }
    _v60 = 0;
    _v56 = 0;
    while(p < ep) {
        _t134 = state;
        if(_t134 == 0) {
            next =  *( &WC_UTF8_MAP + ( *p & 0xff)) & 0xff;
            _t140 = next;
            if(_t140 == 1) {
                wtf_push_ucs(os,  *p & 0xff,  &st);
L23:
                goto L34;
            }
            if(_t140 < 1 || _t140 == 7) {
                wtf_push_unknown(os, p, 1);
                goto L23;
            } else {
                if(_t140 == 8) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t153 = os->length;
                     *((char*)(os->ptr + _t153)) =  *p & 255;
                    os->length = _t153 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    goto L23;
                }
                q = p;
                next = next - 1;
                state = 1;
                goto L34;
            }
        } else {
            if(_t134 == 1) {
                if(( *( &WC_UTF8_MAP + ( *p & 0xff)) & 255) == 0) {
                    next = next - 1;
                    if(next == 0) {
                        state = 0;
                        ucs = wc_utf8_to_ucs(q);
                        if(ucs == -1 || ucs > 55295 && ucs <= 57343) {
                            wtf_push_unknown(os, q, p - q + 1);
                        } else {
                            if(ucs != 65279) {
                                wtf_push_ucs(os, ucs,  &st);
                            }
                        }
                    }
                } else {
                    wtf_push_unknown(os, q, p - q + 1);
                    state = 0;
                }
            }
L34:
            p =  &(p[1]);
            continue;
        }
    }
    if(state == 1) {
        wtf_push_unknown(os, q, p - q);
    }
    return os;
}

int wc_push_tag_to_utf8(Str os, int ntag)
{// addr = 0x080C18A7  --  defined in 'utf8.c' at line 208
    char* p;                               // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    if(ntag != 0) {
        p = wc_ucs_get_tag(ntag);
        if(p == 0) {
            ntag = 0;
        }
    }
    if(ntag == 0) {
        wc_ucs_to_utf8(917631,  &utf8_buf);
        Strcat_charp(os,  &utf8_buf);
        goto L9;
    } else {
        wc_ucs_to_utf8(917505,  &utf8_buf);
        Strcat_charp(os,  &utf8_buf);
        while(( *p & 255) != 0) {
            wc_ucs_to_utf8( *p & 255 | 917504,  &utf8_buf);
            Strcat_charp(os,  &utf8_buf);
            p =  &(p[1]);
        }
L9:
        return ntag;
    }
}

void wc_push_to_utf8(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C196D  --  defined in 'utf8.c' at line 232
    wc_status* _v24;   // _cfa_ffffffe8 (outparam)
    signed int _t83;                       // _t83
    unsigned char _t122;                   // _t122
    int _t143;                             // _t143

    while(1) {
        _t83 = cc.auto_detect & 65535;
        if(_t83 == 8192) {
            break;
        }
        if(_t83 <= 8192) {
            if(_t83 == 577) {
                if( *( *((intOrPtr*)(__ebp + 20)) + 48) != 0) {
                     *( *((intOrPtr*)(__ebp + 20)) + 48) = wc_push_tag_to_utf8(os, 0);
                }
                wc_ucs_to_utf8(st | 128,  &utf8_buf);
                Strcat_charp(os,  &utf8_buf);
                return;
            }
            if(_t83 == 4096) {
                break;
            }
            if(_t83 == 322) {
                if( *( *((intOrPtr*)(__ebp + 20)) + 48) != 0) {
                     *( *((intOrPtr*)(__ebp + 20)) + 48) = wc_push_tag_to_utf8(os, 0);
                }
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t143 = os->length;
                 *((char*)(os->ptr + _t143)) = st & 127;
                os->length = _t143 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
L34:
            if(( *135119011 & 255) == 0) {
L37:
                if((cc.auto_detect & 98304) == 0) {
                    _t122 = 16384;
                } else {
                    _t122 = 49152;
                }
                cc.auto_detect = _t122;
                continue;
            } else {
                 *__esp = cc.auto_detect;
                _v24 = st;
                st = wc_any_to_ucs();
                if(st == -1) {
                    goto L37;
                } else {
                    cc.auto_detect = 4096;
                    continue;
                }
            }
L42:
            return;
        }
        if(_t83 != 16384) {
            if(_t83 == 49152) {
                if(( *135119022 & 255) != 0) {
                    return;
                }
                if( *( *((intOrPtr*)(__ebp + 20)) + 48) != 0) {
                     *( *((intOrPtr*)(__ebp + 20)) + 48) = wc_push_tag_to_utf8(os, 0);
                }
                Strcat_charp(os, WcReplaceW);
                return;
            }
            if(_t83 == 8193) {
                if(( *135119010 & 255) != 0 && st >> 24 !=  *( *((intOrPtr*)(__ebp + 20)) + 48)) {
                     *( *((intOrPtr*)(__ebp + 20)) + 48) = wc_push_tag_to_utf8(os, st >> 24);
                }
                wc_ucs_to_utf8(st & 2097151,  &utf8_buf);
                Strcat_charp(os,  &utf8_buf);
                return;
            }
            goto L34;
        }
        if(( *135119022 & 255) == 0) {
            if( *( *((intOrPtr*)(__ebp + 20)) + 48) != 0) {
                 *( *((intOrPtr*)(__ebp + 20)) + 48) = wc_push_tag_to_utf8(os, 0);
            }
            Strcat_charp(os, WcReplace);
            return;
        }
        goto L42;
    }
    if( *( *((intOrPtr*)(__ebp + 20)) + 48) != 0) {
         *( *((intOrPtr*)(__ebp + 20)) + 48) = wc_push_tag_to_utf8(os, 0);
    }
    wc_ucs_to_utf8(st,  &utf8_buf);
    Strcat_charp(os,  &utf8_buf);
}

void wc_push_to_utf8_end(Str os, wc_status* st)
{// addr = 0x080C1C44  --  defined in 'utf8.c' at line 286
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(st->ntag != 0) {
        st->ntag = wc_push_tag_to_utf8(os, 0);
        return;
    }
}

Str wc_char_conv_from_utf8(wc_uchar c, wc_status* st)
{// addr = 0x080C1C6F  --  defined in 'utf8.c' at line 294
    wc_uint32 ucs;   // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t50;                              // _t50
    signed int _t54;                       // _t54
    struct _Str* _t63;    // _t63
    struct _Str* _t69;    // _t69
    struct _Str* _t77;    // _t77
    int _t96;                              // _t96

    _v32 = c;
    if(st->state == -1) {
        st->state = 0;
        os.2857 = Strnew_size(8);
        st->tag = 0;
        st->ntag = 0;
        nbuf.2859 = 0;
    }
    _t50 = st->state;
    if(_t50 == 0) {
        next.2860 =  *( &WC_UTF8_MAP + (_v32 & 255)) & 0xff;
        _t54 = next.2860;
        if(_t54 == 1) {
            wtf_push_ucs(os.2857, _v32 & 255, st);
L16:
L26:
            st->state = -1;
            return os.2857;
        }
        if(_t54 < 1 || _t54 == 7) {
        } else {
            if(_t54 != 8) {
                _t69 = nbuf.2859;
                 *((char*)( &buf.2858 + _t69)) = _v32 & 255;
                nbuf.2859 =  &(_t69->ptr);
                next.2860 = next.2860 - 1;
                st->state = 1;
                return 0;
            }
            if(os.2857->length + 1 >= os.2857->area_size) {
                Strgrow(os.2857);
            }
            _t63 = os.2857;
            _t96 = _t63->length;
             *((char*)( *os.2857 + _t96)) = _v32 & 255;
            _t63->length = _t96 + 1;
             *((char*)( *os.2857 + os.2857->length)) = 0;
        }
        goto L16;
    }
    if(_t50 == 1) {
        if(( *( &WC_UTF8_MAP + (_v32 & 255)) & 255) != 0) {
            goto L26;
        }
        _t77 = nbuf.2859;
         *((char*)( &buf.2858 + _t77)) = _v32 & 255;
        nbuf.2859 =  &(_t77->ptr);
        next.2860 = next.2860 - 1;
        if(next.2860 == 0) {
            ucs = wc_utf8_to_ucs( &buf.2858);
            if(ucs != -1 && (ucs <= 55295 || ucs > 57343)) {
                if(ucs != 65279) {
                    wtf_push_ucs(os.2857, ucs, st);
                }
            }
            goto L26;
        }
        return 0;
    } else {
        goto L26;
    }
}

wc_uint32 wc_tcvn5712_precompose(wc_uchar c1, wc_uchar c2)
{// addr = 0x080C1E74  --  defined in 'viet.c' at line 77
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4

    _v8 = c1;
    _v12 = c2;
    if(( *( &tcvn5712_precompose_map + (_v8 & 255)) & 255) != 1 || ( *( &tcvn5712_precompose_map + (_v12 & 255)) & 255) != 2) {
        return 0;
    } else {
        return _v12 & 255 | (_v8 & 255) << 8;
    }
}

wc_wchar_t wc_tcvn57123_to_tcvn5712(wc_wchar_t cc)
{// addr = 0x080C1EBC  --  defined in 'viet.c' at line 86
    wc_map* map;        // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    struct  __ebx;            // r1
    intOrPtr _t25;                         // _t25

    __ebx = cc.auto_detect;
    map = wc_map_search(_a12 & 0x7f7f,  &tcvn57123_tcvn5712_map, 120);
    if(map == 0) {
         *((intOrPtr*)(__ebp + 12)) = 16384;
    } else {
        if((map->code2 & 65535) > 31) {
            _t25 = 2077;
        } else {
            _t25 = 2078;
        }
         *((intOrPtr*)(__ebp + 12)) = _t25;
        _a12 = (map->code2 & 65535 | 128) & 65535;
    }
     *__ebx =  *((intOrPtr*)(__ebp + 12));
     *(__ebx + 4) = _a12;
    return __ebx;
}

wc_uint32 wc_cp1258_precompose(wc_uchar c1, wc_uchar c2)
{// addr = 0x080C1F3B  --  defined in 'viet.c' at line 102
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4

    _v8 = c1;
    _v12 = c2;
    if(( *( &cp1258_precompose_map + (_v8 & 255)) & 255) != 1 || ( *( &cp1258_precompose_map + (_v12 & 255)) & 255) != 2) {
        return 0;
    } else {
        return _v12 & 255 | (_v8 & 255) << 8;
    }
}

Str wc_conv_from_viet(Str is, wc_ces ces)
{// addr = 0x080C1F83  --  defined in 'viet.c' at line 111
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    wc_ccs ccs1;        // _cfa_ffffffe0
    wc_ccs ccs2;        // _cfa_ffffffdc
    wc_uint8* map;    // _cfa_ffffffd8
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    wc_ces _t95;        // _t95
    int _t115;                             // _t115

    sp = is->ptr;
    ep = sp + is->length;
    ccs1 =  *( *((intOrPtr*)(((ces & 255) << 5) + 135767980)) + 8);
    ccs2 =  *( *((intOrPtr*)(((ces & 255) << 5) + 135767980)) + 16);
    map = 0;
    _t95 = ces;
    if(_t95 == 1066051) {
        map =  &wc_c0_viscii112_map;
    } else {
        if(_t95 == 1066052) {
            map =  &wc_c0_vps2_map;
        } else {
            if(_t95 == 1066050) {
                map =  &wc_c0_tcvn57122_map;
            }
        }
    }
    wc_create_detect_map(ces, 0);
    p = sp;
    do {
    } while(p < ep && ( *( &WC_DETECT_MAP + ( *p & 0xff)) & 255) == 0);
    if(p != ep) {
        os = Strnew_size(is->length);
        if(p > sp) {
            Strcat_charp_n(os, is->ptr, p - sp);
        }
        while(p < ep) {
            if(( *p & 255) >= 0) {
                if(( *p & 255) > 31 || ( *(map + ( *p & 0xff)) & 255) == 0) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t115 = os->length;
                     *((char*)(os->ptr + _t115)) =  *p & 255;
                    os->length = _t115 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                } else {
                    wtf_push(os, ccs2,  *p & 0xff);
                }
            } else {
                wtf_push(os, ccs1,  *p & 0xff);
            }
            p =  &(p[1]);
        }
        return os;
    }
    return is;
}

void wc_push_to_viet(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C2164  --  defined in 'viet.c' at line 154
    wc_ccs ccs1;        // _cfa_fffffff0
    wc_ccs ccs2;        // _cfa_ffffffec
    wc_ccs ccs3;        // _cfa_ffffffe8
    wc_uint8* map;    // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    wc_status* _v36;   // _cfa_ffffffdc
    unsigned char _v40;                    // _cfa_ffffffd8 (outparam)
    intOrPtr _t160;                        // _t160
    unsigned char _t174;                   // _t174
    unsigned char _t184;                   // _t184
    int _t194;                             // _t194
    int _t210;                             // _t210
    int _t223;                             // _t223
    int _t235;                             // _t235
    int _t249;                             // _t249
    int _t262;                             // _t262

    ccs1 =  *( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__ebp + 20)))) + 12)) + 8);
    ccs2 = 0;
    ccs3 = 0;
    map = 0;
    _t160 =  *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__ebp + 20))))));
    if(_t160 == 1066050) {
        map =  &wc_c0_tcvn57122_map;
        ccs2 =  *( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__ebp + 20)))) + 12)) + 16);
        ccs3 =  *( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__ebp + 20)))) + 12)) + 24);
    } else {
        if(_t160 > 1066050) {
            if(_t160 == 1066051) {
                map =  &wc_c0_viscii112_map;
                ccs2 =  *( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__ebp + 20)))) + 12)) + 16);
            } else {
                if(_t160 == 1066052) {
                    map =  &wc_c0_vps2_map;
                    ccs2 =  *( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__ebp + 20)))) + 12)) + 16);
                }
            }
        } else {
            if(_t160 == 1049665) {
                ccs3 =  *( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__ebp + 20)))) + 12)) + 16);
            }
        }
    }
L11:
    while(1) {
        if(cc.auto_detect == ccs1) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t262 = os->length;
             *((char*)(os->ptr + _t262)) = st | -128;
            os->length = _t262 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(cc.auto_detect != ccs2) {
            if(cc.auto_detect != ccs3) {
                _t174 = cc.auto_detect;
                if(_t174 == 16384) {
                    if(( *135119022 & 255) != 0) {
                        return;
                    }
                    Strcat_charp(os, WcReplace);
                    return;
                }
                if(_t174 == 49152) {
                    if(( *135119022 & 255) != 0) {
                        return;
                    }
                    Strcat_charp(os, WcReplaceW);
                    return;
                }
                if(_t174 != 322) {
                    if(( *135119011 & 255) == 0) {
                        if((cc.auto_detect & 98304) == 0) {
                            _t184 = 16384;
                        } else {
                            _t184 = 49152;
                        }
                        cc.auto_detect = _t184;
                    } else {
                        _v32 =  *((intOrPtr*)(__ebp + 20));
                        _v40 = cc.auto_detect;
                        _v36 = st;
                         *__esp =  &cc;
                        wc_any_to_any_ces();
                        __esp = __esp - 4;
                    }
                    continue;
                }
                if(st > 31 || map == 0 || ( *(st + map) & 255) == 0) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t194 = os->length;
                     *((char*)(os->ptr + _t194)) = st;
                    os->length = _t194 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    return;
                } else {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t210 = os->length;
                     *((char*)(os->ptr + _t210)) = 32;
                    os->length = _t210 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    return;
                }
            }
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t223 = os->length;
             *((char*)(os->ptr + _t223)) = st >> 8;
            os->length = _t223 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t235 = os->length;
             *((char*)(os->ptr + _t235)) = st;
            os->length = _t235 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t249 = os->length;
         *((char*)(os->ptr + _t249)) = st & 127;
        os->length = _t249 + 1;
         *((char*)(os->ptr + os->length)) = 0;
        return;
    }
}

Str wc_char_conv_from_viet(wc_uchar c, wc_status* st)
{// addr = 0x080C250D  --  defined in 'viet.c' at line 219
    Str os;                // _cfa_fffffff0
    wc_uint8* map;    // _cfa_ffffffec
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    unsigned int _t47;                     // _t47
    int _t55;                              // _t55

    _v32 = c;
    os = Strnew_size(1);
    map = 0;
    _t47 = st->ces_info->id;
    if(_t47 == 1066051) {
        map =  &wc_c0_viscii112_map;
    } else {
        if(_t47 == 1066052) {
            map =  &wc_c0_vps2_map;
        } else {
            if(_t47 == 1066050) {
                map =  &wc_c0_tcvn57122_map;
            }
        }
    }
    if((_v32 & 255) >= 0) {
        if(_v32 > 31 || ( *(map + (_v32 & 255)) & 255) == 0) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t55 = os->length;
             *((char*)(os->ptr + _t55)) = _v32 & 255;
            os->length = _t55 + 1;
             *((char*)(os->ptr + os->length)) = 0;
        } else {
            wtf_push(os,  *(st->ces_info->gset + 16), _v32 & 255);
        }
    } else {
        wtf_push(os,  *(st->ces_info->gset + 8), _v32 & 255);
    }
    return os;
}

void wtf_init(wc_ces ces1, wc_ces ces2)
{// addr = 0x080C2624  --  defined in 'wtf.c' at line 80
    int i;                                 // _cfa_fffffff0
    wc_gset* gset;     // _cfa_ffffffec

    if(wc_check_ces(ces2) != 0) {
        wtf_major_ces = ces2;
    }
    if(wc_check_ces(ces1) == 0) {
        return;
    }
    gset =  *(((ces1 & 255) << 5) + 135767980);
    if(gset == 0) {
        return;
    }
    if( *(gset + 8) == 0) {
        return;
    }
    if(( *(gset + 8) & 12288) == 0) {
        wtf_gr_ccs =  *(gset + 8);
        if((wtf_gr_ccs & 98304) == 0) {
            i = 161;
            while(i <= 255) {
                 *((char*)( &WTF_WIDTH_MAP + i)) = 1;
                 *((char*)( &WTF_LEN_MAP + i)) = 1;
                 *((char*)( &WTF_TYPE_MAP + i)) = 2;
                i = i + 1;
            }
            return;
        }
        i = 161;
        while(i <= 255) {
             *((char*)( &WTF_WIDTH_MAP + i)) = 2;
             *((char*)( &WTF_LEN_MAP + i)) = 2;
             *((char*)( &WTF_TYPE_MAP + i)) = 10;
            i = i + 1;
        }
        return;
    }
}

int wtf_strwidth(wc_uchar* p)
{// addr = 0x080C272A  --  defined in 'wtf.c' at line 120
    int w;                                 // _cfa_fffffff8
    signed int _t22;                       // _t22

    w = 0;
    while(( *p & 255) != 0) {
        if(( *135119023 & 255) == 0) {
            _t22 = ( *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 255) != 0 & 255;
        } else {
            _t22 =  *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 0xff;
        }
        w = w + _t22;
        p = p + ( *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff);
    }
    return w;
}

size_t wtf_len(wc_uchar* p)
{// addr = 0x080C2799  --  defined in 'wtf.c' at line 140
    wc_uchar* q;      // _cfa_fffffff8

    q = p;
    q = q + ( *( &WTF_LEN_MAP + ( *q & 0xff)) & 0xff);
    while(( *q & 255) != 0 && ( *( &WTF_WIDTH_MAP + ( *q & 0xff)) & 255) == 0) {
        q = q + ( *( &WTF_LEN_MAP + ( *q & 0xff)) & 0xff);
    }
    return q - p;
}

void wtf_push(Str os, wc_ccs ccs, wc_uint32 code)
{// addr = 0x080C27FF  --  defined in 'wtf.c' at line 180
    signed int _v16;                       // _cfa_fffffff0
    char _v21;                             // _cfa_ffffffeb
    char _v22;                             // _cfa_ffffffea
    signed int _v23;                       // _cfa_ffffffe9
    wc_uchar[7] s;    // _cfa_ffffffe8
    wc_bool fix_width_conv;   // _cfa_ffffffe7
    size_t n;           // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    wc_wchar_t cc;   // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    wc_wchar_t cc2;   // _cfa_ffffffd0
    struct _Str* _v64;    // _cfa_ffffffc0
    signed int _v72;                       // _cfa_ffffffb8
    unsigned char _v76;                    // _cfa_ffffffb4
    struct * _v80;            // _cfa_ffffffb0
    signed int _v84;                       // _cfa_ffffffac
    signed int _v88;                       // _cfa_ffffffa8 (outparam)
    _unknown_ _v92;                        // _cfa_ffffffa4 (outparam)
    signed int _t269;                      // _t269
    signed int _t274;                      // _t274
    signed int _t350;                      // _t350
    int _t449;                             // _t449
    int _t468;                             // _t468
    signed int _t485;                      // _t485
    signed int _t495;                      // _t495

    _v64 = os;
    _v16 =  *gs:0x14];
    if(ccs != 322) {
        cc.auto_detect = ccs;
        _v36 = code;
        if(( *135119012 & 255) == 0 || (cc.auto_detect & 16384) != 0) {
L31:
            _t269 = cc.auto_detect & 65280;
            if(_t269 == 4096) {
                if((cc.auto_detect & 98304) == 0) {
                    _t485 = -120;
                } else {
                    _t485 = -119;
                }
                if((cc.auto_detect & 131072) == 0) {
                    _t274 = 0;
                } else {
                    _t274 = 16;
                }
                s = _t274 | _t485;
                 *((char*)( &s + 1)) = _v36 >> 14 & 3 | -128;
                 *((char*)( &s + 2)) = _v36 >> 7 | -128;
                 *((char*)( &s + 3)) = _v36 | -128;
                _v23 = _v23 & 255 | cc.auto_detect << 2;
                n = 4;
L101:
                Strcat_charp_n(_v64,  &s, n);
                goto L102;
            }
            if(_t269 > 4096) {
                if(_t269 == 33024) {
                    if(cc.auto_detect != wtf_gr_ccs) {
                        s = 129;
                        _v23 = cc.auto_detect | -128;
                        _v22 = _v36 >> 8 | -128;
                        _v21 = _v36 | -128;
                        n = 4;
                    } else {
                        s = _v36 >> 8 | -128;
                        _v23 = _v36 | -128;
                        n = 2;
                    }
                    goto L101;
                }
                if(_t269 > 33024) {
                    if(_t269 == 33280) {
                        if(cc.auto_detect != wtf_gr_ccs || (_v36 >> 8 & 127) <= 32) {
                            s = 131;
                            _v23 = cc.auto_detect | -128;
                            _v22 = _v36 >> 8 | -128;
                            _v21 = _v36 | -128;
                            n = 4;
                        } else {
                            s = _v36 >> 8 | -128;
                            _v23 = _v36 | -128;
                            n = 2;
                        }
                        goto L101;
                    }
                    if(_t269 == 34816) {
                        if(cc.auto_detect - 34817 > 30) {
                            if(cc.auto_detect != wtf_gr_ccs || (_v36 >> 8 & 127) <= 32) {
                                s = 135;
                                _v23 = cc.auto_detect | -128;
                                _v22 = _v36 >> 8 | -128;
                                _v21 = _v36 | -128;
                                n = 4;
                            } else {
                                s = _v36 >> 8 | -128;
                                _v23 = _v36 | -128;
                                n = 2;
                            }
                            goto L101;
                        }
                        goto __eax;
                    } else {
L100:
                        s = 133;
                        _v23 = cc.auto_detect | -128;
                        _v22 = _v36 | -128;
                        n = 3;
                        goto L101;
                    }
                }
                if(_t269 == 8192) {
                    if((cc.auto_detect & 98304) == 0) {
                        _t495 = -118;
                    } else {
                        _t495 = -117;
                    }
                    if((cc.auto_detect & 131072) == 0) {
                        _t350 = 0;
                    } else {
                        _t350 = 16;
                    }
                    s = _t350 | _t495;
                     *((char*)( &s + 1)) = _v36 >> 28 | -128;
                     *((char*)( &s + 2)) = _v36 >> 21 | -128;
                     *((char*)( &s + 3)) = _v36 >> 14 | -128;
                     *((char*)( &s + 4)) = _v36 >> 7 | -128;
                     *((char*)( &s + 5)) = _v36 | -128;
                    _v23 = _v23 & 255 | cc.auto_detect << 4;
                    n = 6;
                    goto L101;
                } else {
                    goto L100;
                }
            }
            if(_t269 == 512) {
                if(( *135119009 & 255) == 0) {
L60:
                    if(cc.auto_detect != wtf_gr_ccs || (_v36 & 127) <= 32) {
                        s = 130;
L64:
                        _v23 = cc.auto_detect | -128;
                        _v22 = _v36 | -128;
                        n = 3;
                    } else {
                        s = _v36 | -128;
                        n = 1;
                    }
                    goto L101;
                }
                 *__esp = cc.auto_detect;
                _v88 = _v36;
                if(wc_is_combining() == 0) {
                    goto L60;
                }
                s = 146;
                goto L64;
            }
            if(_t269 > 512) {
                if(_t269 == 1024) {
                    if(cc.auto_detect != wtf_gr_ccs) {
                        s = 132;
                        _v23 = cc.auto_detect | -128;
                        _v22 = _v36 | -128;
                        n = 3;
                    } else {
                        s = _v36 | -128;
                        n = 1;
                    }
                    goto L101;
                }
                if(_t269 == 2048) {
                    if(( *135119009 & 255) == 0) {
L75:
                        if(cc.auto_detect != wtf_gr_ccs || (_v36 & 127) <= 32) {
                            s = 134;
L79:
                            _v23 = cc.auto_detect | -128;
                            _v22 = _v36 | -128;
                            n = 3;
                        } else {
                            s = _v36 | -128;
                            n = 1;
                        }
                        goto L101;
                    }
                     *__esp = cc.auto_detect;
                    _v88 = _v36;
                    if(wc_is_combining() == 0) {
                        goto L75;
                    }
                    s = 150;
                    goto L79;
                } else {
                    goto L100;
                }
            }
            if(_t269 == 256) {
                if(cc.auto_detect != wtf_gr_ccs) {
                    if(cc.auto_detect != 329 || ( *135119017 & 255) != 0) {
L53:
                        s = 128;
                        _v23 = cc.auto_detect | -128;
                        _v22 = _v36 | -128;
                        n = 3;
                        goto L101;
                    } else {
                        _v88 = cc.auto_detect;
                        _v84 = _v36;
                         *__esp =  &_v76;
                        wc_jisx0201k_to_jisx0208();
                        __esp = __esp - 4;
                        cc2.auto_detect = _v76;
                        _v44 = _v72;
                        if((cc2.auto_detect & 16384) != 0) {
                            goto L53;
                        }
                        wtf_push(_v64, cc2.auto_detect, _v44);
                        goto L102;
                    }
                }
                s = _v36 | -128;
                n = 1;
                goto L101;
            } else {
                goto L100;
            }
        } else {
            if(ccs == 34831 || ccs == 34832 || ccs == 34833 || ccs == 34834) {
                if(wtf_major_ces == 3149849 || wtf_major_ces == 2099221) {
                    _v88 = cc.auto_detect;
                    _v84 = _v36;
                     *__esp =  &cc2;
                    wc_johab_to_ksx1001();
                    __esp = __esp - 4;
                    if((cc2.auto_detect & 16384) == 0) {
                        cc.auto_detect = cc2.auto_detect;
                        _v36 = _v44;
                    }
                    goto L31;
                } else {
                    goto L14;
                }
            } else {
L14:
                if(ccs != 33091 || wtf_major_ces != 3153984) {
                    if(( *135119011 & 255) == 0) {
                        goto L31;
                    }
                    fix_width_conv =  *135119013 & 255;
                     *135119013 = 0;
                    wc_output_init(wtf_major_ces,  &wtf_major_st);
                    if(wc_ces_has_ccs(ccs & 65535,  &wtf_major_st) != 0) {
L28:
                         *135119013 = fix_width_conv & 255;
                        goto L31;
                    }
                    _v80 =  &wtf_major_st;
                    _v88 = cc.auto_detect;
                    _v84 = _v36;
                     *__esp =  &_v76;
                    wc_any_to_any_ces();
                    __esp = __esp - 4;
                    cc2.auto_detect = _v76;
                    _v44 = _v72;
                    if(cc2.auto_detect != 322) {
                        if((cc2.auto_detect & 16384) == 0 && cc2.auto_detect != 2076 && cc2.auto_detect != 2079) {
                            cc.auto_detect = cc2.auto_detect;
                            _v36 = _v44;
                        }
                        goto L28;
                    } else {
                        if(_v64->length + 1 >= _v64->area_size) {
                            Strgrow(_v64);
                        }
                        _t449 = _v64->length;
                         *((char*)( *_v64 + _t449)) = _v44 & 127;
                        _v64->length = _t449 + 1;
                         *((char*)( *_v64 + _v64->length)) = 0;
                        goto L102;
                    }
                } else {
                    _v88 = cc.auto_detect;
                    _v84 = _v36;
                     *__esp =  &_v76;
                    wc_ksx1001_to_johab();
                    __esp = __esp - 4;
                    cc2.auto_detect = _v76;
                    _v44 = _v72;
                    if((cc2.auto_detect & 16384) == 0) {
                        cc.auto_detect = cc2.auto_detect;
                        _v36 = _v44;
                    }
                    goto L31;
                }
            }
        }
    } else {
        if(_v64->length + 1 >= _v64->area_size) {
            Strgrow(_v64);
        }
        _t468 = _v64->length;
         *((char*)( *_v64 + _t468)) = code & 127;
        _v64->length = _t468 + 1;
         *((char*)( *_v64 + _v64->length)) = 0;
L102:
        if((_v16 ^  *gs:0x14]) == 0) {
            return;
        }
        __stack_chk_fail();
        return;
    }
}

void wtf_push_unknown(Str os, wc_uchar* p, size_t len)
{// addr = 0x080C30CF  --  defined in 'wtf.c' at line 370
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    int _t38;                              // _t38

    while(1) {
        len = len - 1;
        if(len == 0) {
            break;
        }
        if(( *p & 255) >= 0) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t38 = os->length;
             *((char*)(os->ptr + _t38)) =  *p & 255;
            os->length = _t38 + 1;
             *((char*)(os->ptr + os->length)) = 0;
        } else {
            wtf_push(os, 16384,  *p & 0xff);
        }
        p =  &(p[1]);
    }
}

wc_wchar_t wtf_parse1(wc_uchar** p)
{// addr = 0x080C316B  --  defined in 'wtf.c' at line 381
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_uchar* q;      // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    wc_wchar_t cc;   // _cfa_ffffffe8
    signed int _t93;                       // _t93
    struct  _t194;            // _t194

    _push(__ebx);
    __esp = __esp - 36;
    _t194 = p;
    q =  *( *(__ebp + 12));
    if(( *q & 255) < 0) {
        if(( *q & 255) <= 160) {
            cc.auto_detect = ( *(( *q & 0xff) + -128 +  &CCS_MAP + ( *q & 0xff) + -128) & 0xffff) << 8;
            q =  &(q[1]);
            _t93 = cc.auto_detect & 65280;
            if(_t93 == 8192) {
L28:
                cc.auto_detect = ( *q & 0x70) >> 4 | cc.auto_detect;
                _v20 = q[4] & 0x7f | ( *q & 0xff) << 28 | (q[1] & 0x7f) << 21 | (q[2] & 0x7f) << 14 | (q[3] & 0x7f) << 7;
                q =  &(q[5]);
                goto L30;
            }
            if(_t93 > 8192) {
                if(_t93 == 33280) {
L26:
                    cc.auto_detect =  *q & 0x7f | cc.auto_detect;
                    q =  &(q[1]);
                    _v20 = q[1] & 0xff | ( *q & 0xff) << 8;
                    q =  &(q[2]);
                    goto L30;
                }
                if(_t93 > 33280) {
                    if(_t93 == 69632) {
L27:
                        cc.auto_detect = ( *q & 0x7c) >> 2 | cc.auto_detect;
                        _v20 = q[2] & 0x7f | ( *q & 0xff) << 14 & 65535 | (q[1] & 0x7f) << 7;
                        q =  &(q[3]);
                        goto L30;
                    }
                    if(_t93 == 73728) {
                        goto L28;
                    }
                    if(_t93 == 34816) {
                        goto L26;
                    }
L29:
                    cc.auto_detect = 322;
                    _v20 = 32;
                    goto L30;
                }
                if(_t93 == 16384) {
L25:
                    cc.auto_detect =  *q & 0x7f | cc.auto_detect;
                    q =  &(q[1]);
                    _v20 =  *q & 0xff;
                    q =  &(q[1]);
                    goto L30;
                }
                if(_t93 == 33024) {
                    goto L26;
                }
                goto L29;
            }
            if(_t93 == 1024) {
                goto L25;
            }
            if(_t93 > 1024) {
                if(_t93 == 2048) {
                    goto L25;
                }
                if(_t93 == 4096) {
                    goto L27;
                }
                goto L29;
            }
            if(_t93 == 256 || _t93 == 512) {
                goto L25;
            } else {
                goto L29;
            }
        }
        cc.auto_detect = wtf_gr_ccs;
        if((cc.auto_detect & 98304) == 0) {
            _v20 =  *q & 0xff;
            q =  &(q[1]);
        } else {
            _v20 = q[1] & 0xff | ( *q & 0xff) << 8;
            q =  &(q[2]);
        }
        goto L30;
    } else {
        cc.auto_detect = 322;
        _v20 =  *q & 0xff;
        q =  &(q[1]);
L30:
         *( *(__ebp + 12)) = q;
        if(cc.auto_detect - 34818 > 31) {
             *_t194 = cc.auto_detect;
             *(_t194 + 4) = _v20;
            return _t194;
        }
        goto __eax;
    }
}

wc_wchar_t wtf_parse(wc_uchar** p)
{// addr = 0x080C34FA  --  defined in 'wtf.c' at line 463
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_uchar* q;      // _cfa_fffffff0
    wc_uint32 ucs;   // _cfa_ffffffec
    wc_uint32 ucs2;   // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    wc_wchar_t cc;   // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    wc_wchar_t cc2;   // _cfa_ffffffd8
    signed int _v48;                       // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    wc_uchar** _v72;   // _cfa_ffffffb8
    wc_uchar** _v76;   // _cfa_ffffffb4
    wc_uchar** _v80;   // _cfa_ffffffb0 (outparam)
    unsigned int _t122;                    // _t122
    unsigned int _t125;                    // _t125
    wc_uchar* _t181;   // _t181
    struct  _t184;            // _t184

    _push(__ebx);
    __esp = __esp - 68;
    _t184 = p;
    if(( *( *( *(__ebp + 12))) & 255) < 0) {
        _v72 =  *(__ebp + 12);
        wtf_parse1( &cc);
        __esp = __esp - 4;
    } else {
        cc.auto_detect = 322;
        _t181 =  *( *(__ebp + 12));
        _v28 =  *_t181 & 0xff;
         *( *(__ebp + 12)) =  &(_t181[1]);
    }
    if(( *135119009 & 255) == 0 || ( *( &WTF_WIDTH_MAP + ( *( *( *(__ebp + 12))) & 0xff)) & 255) != 0) {
         *_t184 = cc.auto_detect;
         *(_t184 + 4) = _v28;
L48:
        return _t184;
    } else {
        q =  *( *(__ebp + 12));
        _v76 =  &q;
        wtf_parse1( &cc2);
        __esp = __esp - 4;
        if(cc.auto_detect == 322 || cc.auto_detect == 2075) {
            if((cc2.auto_detect & 65535) != 2075) {
                goto L11;
            }
            _v36 = wc_cp1258_precompose(_v28 & 255, _v36 & 255);
            if(_v36 == 0) {
                goto L47;
            } else {
                cc2.auto_detect = 2076;
                 *( *(__ebp + 12)) = q;
                 *_t184 = cc2.auto_detect;
                 *(_t184 + 4) = _v36;
                goto L48;
            }
        } else {
L11:
            if(cc.auto_detect == 322 || cc.auto_detect == 2077) {
                if((cc2.auto_detect & 65535) != 2077) {
                    goto L16;
                }
                _v36 = wc_tcvn5712_precompose(_v28 & 255, _v36 & 255);
                if(_v36 == 0) {
                    goto L47;
                } else {
                    cc2.auto_detect = 2079;
                     *( *(__ebp + 12)) = q;
                     *_t184 = cc2.auto_detect;
                     *(_t184 + 4) = _v36;
                    goto L48;
                }
            } else {
L16:
                if(cc.auto_detect == 322 || cc.auto_detect == 577 || (cc.auto_detect & 65535) == 4096 || (cc.auto_detect & 65535) == 8192 || (cc.auto_detect & 65535) == 8193) {
                    if((cc2.auto_detect & 65535) == 4096 || (cc2.auto_detect & 65535) == 8192 || (cc2.auto_detect & 65535) == 8193) {
L28:
L28:
                        if((cc.auto_detect & 65535) != 8193) {
                            _t122 = _v28;
                        } else {
                            _t122 = _v28 & 2097151;
                        }
                        ucs = _t122;
                        if((cc2.auto_detect & 65535) != 8193) {
                            _t125 = _v36;
                        } else {
                            _t125 = _v36 & 2097151;
                        }
                        ucs2 = _t125;
                        ucs = wc_ucs_precompose(ucs, ucs2);
                        if(ucs == -1) {
                            goto L45;
                        }
                        if((cc.auto_detect & 65535) != 8193) {
                            cc.auto_detect = wc_ucs_to_ccs(ucs);
                            _v28 = ucs;
                        } else {
                            _v28 = _v28 & -16777216 | ucs;
                        }
                         *( *(__ebp + 12)) = q;
                        if(( *( &WTF_WIDTH_MAP + ( *q & 0xff)) & 255) == 0) {
                        } else {
                            _v80 =  &q;
                            wtf_parse1( &_v52);
                            __esp = __esp - 4;
                            cc2.auto_detect = _v52;
                            _v36 = _v48;
                            if((cc2.auto_detect & 65535) == 4096) {
                                goto L28;
                            }
                            if((cc2.auto_detect & 65535) == 8192) {
                                goto L28;
                            }
                            if((cc2.auto_detect & 65535) == 8193) {
                                goto L28;
                            }
                        }
                        goto L47;
L45:
                    }
                    goto L47;
                } else {
L47:
                     *_t184 = cc.auto_detect;
                     *(_t184 + 4) = _v28;
                    goto L48;
                }
            }
        }
    }
}

wc_ccs wtf_get_ccs(wc_uchar* p)
{// addr = 0x080C3807  --  defined in 'wtf.c' at line 526
    intOrPtr _v20;                         // _cfa_ffffffec
    wc_uchar** _v40;   // _cfa_ffffffd8

    _v40 =  &p;
    wtf_parse1( &_v20);
    __esp = __esp - 4;
    return _v20;
}

wc_uint32 wtf_get_code(wc_uchar* p)
{// addr = 0x080C3827  --  defined in 'wtf.c' at line 532
    unsigned int _v16;                     // _cfa_fffffff0
    wc_uchar* _v20;   // _cfa_ffffffec
    wc_uchar** _v40;   // _cfa_ffffffd8

    _v40 =  &p;
    wtf_parse1( &_v20);
    __esp = __esp - 4;
    return _v16;
}

wc_bool wtf_is_hangul(wc_uchar* p)
{// addr = 0x080C3847  --  defined in 'wtf.c' at line 538
    wc_uchar f;       // _cfa_fffffff3
    wc_uchar f;       // _cfa_fffffff2
    wc_uchar f;       // _cfa_fffffff1
    unsigned char _t103;                   // _t103
    unsigned char _t111;                   // _t111

    if(( *p & 255) <= 160) {
        if(( *p & 255) == 129) {
            return (p[1] & 0x7f) == 67;
        }
        if(( *p & 255) != 135) {
            if(( *p & 255) != 137) {
                if(( *p & 255) != 139) {
L23:
                    return 0;
                }
                p =  &(p[1]);
                f = ( *p & 0x7f) >> 4;
                if(f != 1) {
                    goto L23;
                }
                return wc_is_ucs_hangul((p[4] & 0x7f | ( *p & 0xff) << 28 | (p[1] & 0x7f) << 21 | (p[2] & 0x7f) << 14 | (p[3] & 0x7f) << 7) & 2097151);
            }
            p =  &(p[1]);
            f = ( *p & 0x7f) >> 2;
            if(f != 0) {
                goto L23;
            }
            return wc_is_ucs_hangul(p[2] & 0x7f | ( *p & 0xff) << 14 & 65535 | (p[1] & 0x7f) << 7);
        } else {
            f = p[1] & 0x7f;
            if(f == 16 || f == 17 || f == 18 || f == 29 || f == 30) {
                _t103 = 1;
            } else {
                _t103 = 0;
            }
            return _t103;
        }
    }
    if(wtf_gr_ccs == 33091) {
L3:
        _t111 = 1;
L5:
        return _t111;
    }
    if(wtf_gr_ccs != 34832) {
        _t111 = 0;
        goto L5;
    }
    goto L3;
}

char* wtf_conv_fit(char* s, wc_ces ces)
{// addr = 0x080C39F2  --  defined in 'wtf.c' at line 564
    wc_bool pre_conv;   // _cfa_fffffff3
    wc_bool ucs_conv;   // _cfa_fffffff2
    wc_uchar* p;      // _cfa_ffffffec
    Str os;                // _cfa_ffffffe8
    wc_ces major_ces;   // _cfa_ffffffe4
    unsigned int _v32;                     // _cfa_ffffffe0
    wc_wchar_t cc;   // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc
    wc_uchar** _v56;   // _cfa_ffffffc8 (outparam)
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    int _t45;                              // _t45

    if(ces == 3211264 || ces == 256) {
        return s;
    }
    p = s;
    while(( *p & 255) != 0 && ( *p & 255) >= 0) {
        p =  &(p[1]);
    }
    if(( *p & 255) != 0) {
        _t45 = s;
         *__esp = _t45;
        strlen();
        os = Strnew_size(_t45);
        if(p > s) {
            Strcopy_charp_n(os, s, p - s);
        }
        major_ces = wtf_major_ces;
        pre_conv =  *135119012 & 255;
        ucs_conv =  *135119011 & 255;
        wtf_major_ces = ces;
         *135119012 = 1;
         *135119011 = 1;
        while(( *p & 255) != 0) {
            _v56 =  &p;
            __eax = wtf_parse1( &cc);
            __esp = __esp - 4;
            wtf_push(os, cc.auto_detect, _v32);
        }
        wtf_major_ces = major_ces;
         *135119012 = pre_conv & 255;
         *135119011 = ucs_conv & 255;
        return os->ptr;
    }
    return s;
}

wc_wchar_t wc_big5_to_cs94w(wc_wchar_t cc)
{// addr = 0x080C3B1C  --  defined in 'big5.c' at line 37
    signed int _v16;                       // _cfa_fffffff0
    struct  __ebx;            // r1
    _unknown_ __esi;                       // r5
    _unknown_ _t35;                        // _t35
    _unknown_ _t62;                        // _t62

    __ebx = cc.auto_detect;
    _t62 = (_a12 >> 8 & 255) * 157 + (_a12 & 255);
    if((_a12 & 255) > 160) {
        _t35 = 98;
    } else {
        _t35 = 64;
    }
    _a12 = _t62 - _t35 - 25277;
    if(_a12 > 6279) {
         *((intOrPtr*)(__ebp + 12)) = 34819;
        _a12 = _a12 - 6280;
    } else {
         *((intOrPtr*)(__ebp + 12)) = 34818;
    }
    _v16 = _a12;
    _a12 = ((_v16 * -1370734243 >> 32 >> 6) + 33 << 8) + _a12 - (_a12 * -1370734243 >> 32 >> 6) * 94 + 33;
     *__ebx =  *((intOrPtr*)(__ebp + 12));
     *(__ebx + 4) = _a12;
    return __ebx;
}

wc_wchar_t wc_cs94w_to_big5(wc_wchar_t cc)
{// addr = 0x080C3BE8  --  defined in 'big5.c' at line 51
    signed int _v20;                       // _cfa_ffffffec
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    struct  __esi;            // r5
    _unknown_ _t54;                        // _t54
    _unknown_ _t66;                        // _t66
    signed int _t79;                       // _t79

    __esi = cc.auto_detect;
    _a12 = (_a12 >> 8 & 127) * 94 + (_a12 & 127) - 3135;
    if( *((intOrPtr*)(__ebp + 12)) == 34819) {
        _a12 = _a12 + 6280;
    }
    _v20 = _a12;
    _t79 = (_v20 * 875407347 >> 32 >> 5) + 161 << 8;
    _t66 = _a12 - (_a12 * 875407347 >> 32 >> 5) * 157;
    if(_a12 - (_a12 * 875407347 >> 32 >> 5) * 157 > 62) {
        _t54 = 98;
    } else {
        _t54 = 64;
    }
    _a12 = _t79 + _t66 + _t54;
     *((intOrPtr*)(__ebp + 12)) = 34817;
     *__esi =  *((intOrPtr*)(__ebp + 12));
     *(__esi + 4) = _a12;
    return __esi;
}

Str wc_conv_from_big5(Str is, wc_ces ces)
{// addr = 0x080C3CB4  --  defined in 'big5.c' at line 62
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    int state;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    int _t89;                              // _t89
    signed int _t94;                       // _t94
    int _t103;                             // _t103

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    p = sp;
    do {
    } while(p < ep && ( *p & 255) >= 0);
    if(p == ep) {
        return is;
    }
    os = Strnew_size(is->length);
    if(p > sp) {
        Strcat_charp_n(os, is->ptr, p - sp);
    }
    while(p < ep) {
        _t89 = state;
        if(_t89 == 0) {
            _t94 =  *( &WC_BIG5_MAP + ( *p & 0xff)) & 0xff;
            if(_t94 == 2) {
                wtf_push_unknown(os, p, 1);
L18:
L23:
                p =  &(p[1]);
                continue;
            }
            if(_t94 != 7) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t103 = os->length;
                 *((char*)(os->ptr + _t103)) =  *p & 255;
                os->length = _t103 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                goto L23;
            }
            state = 1;
            goto L18;
        }
        if(_t89 == 1) {
            if(( *( &WC_BIG5_MAP + ( *p & 0xff)) & 4) == 0) {
                wtf_push_unknown(os, p - 1, 2);
            } else {
                wtf_push(os, 34817,  *p & 0xff | ( *(p - 1) & 0xff) << 8);
            }
            state = 0;
        }
        goto L23;
    }
    if(state == 1) {
        wtf_push_unknown(os, p - 1, 1);
    }
    return os;
}

void wc_push_to_big5(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C3E9C  --  defined in 'big5.c' at line 111
    wc_status* _v16;   // _cfa_fffffff0
    unsigned char _v20;                    // _cfa_ffffffec
    intOrPtr _v32;                         // _cfa_ffffffe0
    wc_status* _v36;   // _cfa_ffffffdc
    unsigned char _v40;                    // _cfa_ffffffd8 (outparam)
    unsigned char _t75;                    // _t75
    int _t82;                              // _t82
    int _t94;                              // _t94
    unsigned char _t109;                   // _t109
    int _t119;                             // _t119

    while(1) {
        _t75 = cc.auto_detect;
        if(_t75 == 34817) {
            break;
        }
        if(_t75 > 34817) {
            if(_t75 <= 34819) {
                _v40 = cc.auto_detect;
                _v36 = st;
                 *__esp =  &cc;
                wc_cs94w_to_big5();
                __esp = __esp - 4;
                break;
            }
            if(_t75 == 49152) {
                if(( *135119022 & 255) != 0) {
                    return;
                }
                Strcat_charp(os, WcReplaceW);
                return;
            }
L22:
            if(( *135119011 & 255) == 0) {
                if((cc.auto_detect & 98304) == 0) {
                    _t109 = 16384;
                } else {
                    _t109 = 49152;
                }
                cc.auto_detect = _t109;
            } else {
                _v32 =  *((intOrPtr*)(__ebp + 20));
                _v40 = cc.auto_detect;
                _v36 = st;
                 *__esp =  &_v20;
                wc_any_to_any_ces();
                __esp = __esp - 4;
                cc.auto_detect = _v20;
                st = _v16;
            }
            continue;
        }
        if(_t75 == 322) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t119 = os->length;
             *((char*)(os->ptr + _t119)) = st;
            os->length = _t119 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(_t75 != 16384) {
            goto L22;
        }
        if(( *135119022 & 255) == 0) {
            Strcat_charp(os, WcReplace);
            return;
        }
        return;
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t82 = os->length;
     *((char*)(os->ptr + _t82)) = st >> 8;
    os->length = _t82 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t94 = os->length;
     *((char*)(os->ptr + _t94)) = st;
    os->length = _t94 + 1;
     *((char*)(os->ptr + os->length)) = 0;
}

Str wc_char_conv_from_big5(wc_uchar c, wc_status* st)
{// addr = 0x080C40A0  --  defined in 'big5.c' at line 146
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t33;                              // _t33
    signed int _t36;                       // _t36
    struct _Str* _t44;    // _t44
    int _t68;                              // _t68

    _v16 = c;
    if(st->state == -1) {
        st->state = 0;
        os.2633 = Strnew_size(8);
    }
    _t33 = st->state;
    if(_t33 == 0) {
        _t36 =  *( &WC_BIG5_MAP + (_v16 & 255)) & 0xff;
        if(_t36 == 2) {
L14:
            st->state = -1;
            return os.2633;
        }
        if(_t36 != 7) {
            if(os.2633->length + 1 >= os.2633->area_size) {
                Strgrow(os.2633);
            }
            _t44 = os.2633;
            _t68 = _t44->length;
             *((char*)( *os.2633 + _t68)) = _v16 & 255;
            _t44->length = _t68 + 1;
             *((char*)( *os.2633 + os.2633->length)) = 0;
            goto L14;
        }
        big5u = _v16 & 255;
        st->state = 1;
        return 0;
    }
    if(_t33 == 1) {
        if(( *( &WC_BIG5_MAP + (_v16 & 255)) & 4) != 0) {
            wtf_push(os.2633, 34817, (big5u & 0xff) << 8 | _v16 & 255);
        }
    }
    goto L14;
}

wc_bool wc_is_combining(wc_wchar_t cc)
{// addr = 0x080C41D8  --  defined in 'combining.c' at line 16
    signed int _t20;                       // _t20

    _t20 = cc.auto_detect & 65535;
    if(_t20 == 2073) {
        return  *( &cp1256_combining_map + (_a8 & 127)) & 255;
    }
    if(_t20 > 2073) {
        if(_t20 == 4096) {
L25:
            return wc_is_ucs_combining(_a8);
        }
        if(_t20 > 4096) {
            if(_t20 - 8192 > 1) {
L26:
                return 0;
            }
            goto L25;
        }
        if(_t20 == 2075) {
            return  *( &cp1258_combining_map + (_a8 & 127)) & 255;
        }
        if(_t20 == 2077) {
            return  *( &tcvn5712_combining_map + (_a8 & 127)) & 255;
        }
        goto L26;
    }
    if(_t20 == 2061) {
        return  *( &cp864_combining_map + (_a8 & 127)) & 255;
    }
    if(_t20 > 2061) {
        if(_t20 == 2065) {
            return  *( &cp874_combining_map + (_a8 & 127)) & 255;
        }
        if(_t20 == 2072) {
            return  *( &cp1255_combining_map + (_a8 & 127)) & 255;
        }
        goto L26;
    }
    if(_t20 == 583) {
        return  *( &iso88596_combining_map + (_a8 & 127)) & 255;
    }
    if(_t20 == 596) {
        return  *( &iso885911_combining_map + (_a8 & 127)) & 255;
    }
    goto L26;
}

wc_wchar_t wc_gbk_ext_to_cs128w(wc_wchar_t cc)
{// addr = 0x080C42F4  --  defined in 'gb18030.c' at line 39
    _unknown_ __ebx;                       // r1
    _unknown_ _t25;                        // _t25
    _unknown_ _t42;                        // _t42

    __ecx = cc.auto_detect;
    _t42 = (_a12 >> 8 & 255) * 190 + (_a12 & 255);
    if((_a12 & 255) > 127) {
        _t25 = 65;
    } else {
        _t25 = 64;
    }
    _a12 = _t42 - _t25 - 24510;
    if(_a12 > 16383) {
         *((intOrPtr*)(__ebp + 12)) = 34843;
        _a12 = _a12 - 16384;
    } else {
         *((intOrPtr*)(__ebp + 12)) = 34842;
    }
    _a12 = (_a12 >> 7 << 8) + (_a12 & 127);
     *__ecx =  *((intOrPtr*)(__ebp + 12));
     *(__ecx + 4) = _a12;
    return __ecx;
}

wc_wchar_t wc_cs128w_to_gbk_ext(wc_wchar_t cc)
{// addr = 0x080C438D  --  defined in 'gb18030.c' at line 53
    signed int _v20;                       // _cfa_ffffffec
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    struct  __esi;            // r5
    _unknown_ _t59;                        // _t59
    unsigned int _t66;                     // _t66
    unsigned int _t67;                     // _t67
    _unknown_ _t71;                        // _t71
    signed int _t90;                       // _t90

    __esi = cc.auto_detect;
    _a12 = ((_a12 >> 8 & 127) << 7) + (_a12 & 127);
    if( *((intOrPtr*)(__ebp + 12)) == 34843) {
        _a12 = _a12 + 16384;
    }
     *((intOrPtr*)(__ebp + 12)) = 34841;
    _v20 = _a12 >> 1;
    _t90 = (_v20 * -1401515643 >> 32 >> 6) + 129 << 8;
    _t66 = _a12;
    _v20 = _t66 >> 1;
    _t71 = _t66 - (_v20 * -1401515643 >> 32 >> 6) * 190;
    _t67 = _a12;
    _v20 = _t67 >> 1;
    if(_t67 - (_v20 * -1401515643 >> 32 >> 6) * 190 > 62) {
        _t59 = 65;
    } else {
        _t59 = 64;
    }
    _a12 = _t90 + _t71 + _t59;
     *__esi =  *((intOrPtr*)(__ebp + 12));
     *(__esi + 4) = _a12;
    return __esi;
}

wc_ccs wc_gbk_or_gbk_ext(wc_uint16 code)
{// addr = 0x080C446B  --  defined in 'gb18030.c' at line 64
    signed short _v16;                     // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v16 = code;
    if(wc_map3_range_search(_v16 & 65535,  &gbk_ext_ucs_map, 110) == 0) {
        return 34838;
    }
    return 34841;
}

wc_uint32 wc_gb18030_to_ucs(wc_wchar_t cc)
{// addr = 0x080C44A6  --  defined in 'gb18030.c' at line 72
    char _v12;                             // _cfa_fffffff4
    wc_map3* map;      // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int min;                               // _cfa_ffffffe8
    int max;                               // _cfa_ffffffe4
    signed int _v36;                       // _cfa_ffffffdc (outparam)
    signed int _v40;                       // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    signed int _t76;                       // _t76
    unsigned int _t80;                     // _t80
    _unknown_ _t89;                        // _t89
    _unknown_ _t95;                        // _t95
    _unknown_ _t182;                       // _t182
    _unknown_ _t183;                       // _t183
    signed int _t188;                      // _t188

    __esp = __esp - 32;
    _t76 = cc.auto_detect & 65535;
    if(_t76 == 34841) {
L6:
        map = wc_map3_range_search(_a8 & 65535,  &gbk_ext_ucs_map, 110);
        if(map == 0) {
            _t80 = -1;
        } else {
            _t188 = map->code3 & 0xffff;
            _t182 = (_a8 >> 8 & 255) * 190 + (_a8 & 255);
            if((_a8 & 255) > 127) {
                _t89 = 65;
            } else {
                _t89 = 64;
            }
            _t183 = _t188 + _t182 - _t89;
            if((map->code2 & 0xff) > 127) {
                _t95 = 65;
            } else {
                _t95 = 64;
            }
            _t80 = _t183 + _t95 + 24510 + ((map->code2 & 65535) >> 8 & 65535) * -190 - (map->code2 & 0xff) - 24510;
        }
L33:
         &_v12 =  &_v12;
        return _t80;
    }
    if(_t76 > 34841) {
        if(_t76 > 34843) {
L17:
             *__esp = cc.auto_detect;
            _v40 = _a8;
            _t80 = wc_any_to_ucs();
            goto L33;
        } else {
            _v40 = cc.auto_detect;
            _v36 = _a8;
             *__esp =  &cc;
            wc_cs128w_to_gbk_ext();
            __esp = __esp - 4;
            goto L6;
        }
    }
    if(_t76 == 8194) {
        if(_a8 > -2127527633) {
            if(_a8 > -2077121479) {
L29:
                if(_a8 <= -1875869393 || _a8 > -483222987) {
                    _t80 = -1;
                } else {
                    _t80 = (((_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) << 6) - (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 8 & 255) << 2) + ((_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) << 6) - (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 8 & 255) + (((_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) << 6) - (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 8 & 255) << 2) + ((_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) << 6) - (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 8 & 255) + (_a8 & 255) - 1810682;
                }
                goto L33;
            }
            min = 0;
            max = 205;
            _a8 = (((_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) << 6) - (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 8 & 255) << 2) + ((_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) << 6) - (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 8 & 255) + (((_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) << 6) - (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 8 & 255) << 2) + ((_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) << 6) - (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 24 << 2) + (_a8 >> 24) + (_a8 >> 16 & 255) + (_a8 >> 8 & 255) + (_a8 & 255) - 1687218;
            if(_a8 < ( *(max + max + max + max + max + max + 135772644) & 0xffff)) {
                while(1) {
                    i = (min + max >> 31) + min + max >> 1;
                    if(min == max) {
                        break;
                    }
                    if(_a8 >= ( *(i + i + i + i + i + i + 135772644) & 0xffff)) {
                        if(_a8 < ( *(i + 1 + i + 1 + i + 1 + i + 1 + i + 1 + i + 1 + 135772644) & 0xffff)) {
L28:
                            _t80 = ( *( &ucs_gb18030_map + i + i + i + i + i + i) & 0xffff) + _a8 - ( *(i + i + i + i + i + i + 135772644) & 0xffff);
                            goto L33;
                        }
                        min = i + 1;
                        continue;
                    }
                    max = i - 1;
                }
                goto L28;
            }
            i = max;
            goto L28;
        }
        goto L29;
    } else {
        goto L17;
    }
}

wc_wchar_t wc_ucs_to_gb18030(wc_uint32 ucs)
{// addr = 0x080C47AD  --  defined in 'gb18030.c' at line 119
    wc_map3* map;      // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    wc_wchar_t cc;   // _cfa_ffffffd8
    signed int _v48;                       // _cfa_ffffffd0
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    struct  __ebx;            // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ _t267;                       // _t267
    _unknown_ _t288;                       // _t288
    unsigned int _t295;                    // _t295
    unsigned int _t302;                    // _t302
    _unknown_ _t311;                       // _t311
    _unknown_ _t374;                       // _t374
    signed int _t393;                      // _t393
    unsigned int _t402;                    // _t402
    unsigned int _t403;                    // _t403

    __ebx = ucs;
    if( *(__ebp + 12) > 65535) {
        if( *(__ebp + 12) > 1114111) {
            goto L19;
        } else {
            _v36 =  *(__ebp + 12) + 123464;
            _v48 = _v36 >> 3;
            _v48 = _v36 >> 2;
            _v48 = _v36;
            _t295 = _v48 * -858993459 >> 32 >> 3;
            _v48 = _t295 >> 1;
            _v36 = ((_v48 * 349051311 >> 32 >> 7) + 129 << 24) + ((_v48 * 1745256553 >> 32 >> 7) - (-858993459 << 2) + ((_v48 * 1745256553 >> 32 >> 7) * -858993459 >> 32 >> 3) + (-858993459 << 2) + ((_v48 * 1745256553 >> 32 >> 7) * -858993459 >> 32 >> 3) + 48 << 16) + (_t295 - ((_v48 * -2113396605 >> 32 >> 5) + (_v48 * -2113396605 >> 32 >> 5) << 6) - (_v48 * -2113396605 >> 32 >> 5) + (_v48 * -2113396605 >> 32 >> 5) + 129 << 8) + _v36 - (-858993459 << 2) + (_v36 * -858993459 >> 32 >> 3) + (-858993459 << 2) + (_v36 * -858993459 >> 32 >> 3) + 48;
            if(( *135119021 & 255) == 0) {
                cc.auto_detect = 73730;
            } else {
                wc_ucs_to_ccs( *(__ebp + 12));
                cc.auto_detect = 0x2002;
            }
             *__ebx = cc.auto_detect;
             *(__ebx + 4) = _v36;
        }
    } else {
        map = wc_map3_range_search( *(__ebp + 12) & 65535,  &ucs_gbk_ext_map, 110);
        if(map == 0) {
            map = wc_map3_range_search( *(__ebp + 12) & 65535,  &ucs_gb18030_map, 206);
            if(map == 0) {
L19:
                cc.auto_detect = 16384;
                 *__ebx = cc.auto_detect;
                 *(__ebx + 4) = _v36;
            } else {
                _v36 = (map->code3 & 0xffff) +  *(__ebp + 12) - (map->code & 0xffff);
                _v48 = _v36 >> 3;
                _v48 = _v36 >> 2;
                _v48 = _v36;
                _t302 = _v48 * -858993459 >> 32 >> 3;
                _v48 = _t302 >> 1;
                _v36 = ((_v48 * 349051311 >> 32 >> 7) + 129 << 24) + ((_v48 * 1745256553 >> 32 >> 7) - (-858993459 << 2) + ((_v48 * 1745256553 >> 32 >> 7) * -858993459 >> 32 >> 3) + (-858993459 << 2) + ((_v48 * 1745256553 >> 32 >> 7) * -858993459 >> 32 >> 3) + 48 << 16) + (_t302 - ((_v48 * -2113396605 >> 32 >> 5) + (_v48 * -2113396605 >> 32 >> 5) << 6) - (_v48 * -2113396605 >> 32 >> 5) + (_v48 * -2113396605 >> 32 >> 5) + 129 << 8) + _v36 - (-858993459 << 2) + (_v36 * -858993459 >> 32 >> 3) + (-858993459 << 2) + (_v36 * -858993459 >> 32 >> 3) + 48;
                if(( *135119021 & 255) == 0) {
                    cc.auto_detect = 73730;
                } else {
                    wc_ucs_to_ccs( *(__ebp + 12));
                    cc.auto_detect = 0x2002;
                }
                 *__ebx = cc.auto_detect;
                 *(__ebx + 4) = _v36;
            }
        } else {
            _t374 = ((map->code3 & 65535) >> 8 & 65535) * 190 - 24510 + (map->code3 & 0xff);
            if((map->code3 & 0xff) > 127) {
                _t267 = 65;
            } else {
                _t267 = 64;
            }
            _v36 = _t374 - _t267 +  *(__ebp + 12) - (map->code & 0xffff);
            _v48 = _v36 >> 1;
            _t393 = (_v48 * -1401515643 >> 32 >> 6) + 129 << 8;
            _t402 = _v36;
            _v48 = _t402 >> 1;
            _t311 = _t402 - (_v48 * -1401515643 >> 32 >> 6) * 190;
            _t403 = _v36;
            _v48 = _t403 >> 1;
            if(_t403 - (_v48 * -1401515643 >> 32 >> 6) * 190 > 62) {
                _t288 = 65;
            } else {
                _t288 = 64;
            }
            _v36 = _t393 + _t311 + _t288;
            cc.auto_detect = 34841;
             *__ebx = cc.auto_detect;
             *(__ebx + 4) = _v36;
        }
    }
    return __ebx;
}

Str wc_conv_from_gb18030(Str is, wc_ces ces)
{// addr = 0x080C4B76  --  defined in 'gb18030.c' at line 159
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    int state;                             // _cfa_ffffffe0
    wc_uint32 gbk;   // _cfa_ffffffdc
    wc_uint32 ucs;   // _cfa_ffffffd8
    unsigned int _v44;                     // _cfa_ffffffd4
    wc_wchar_t cc;   // _cfa_ffffffd0
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    unsigned int _v72;                     // _cfa_ffffffb8 (outparam)
    int _t150;                             // _t150
    signed int _t234;                      // _t234
    int _t243;                             // _t243
    int _t250;                             // _t250

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    p = sp;
    goto L2;
    do {
    } while();
L45:
    while(p < ep) {
        _t150 = state;
        if(_t150 == 1) {
            if(( *( &WC_GB18030_MAP + ( *p & 0xff)) & 4) == 0) {
                if(( *( &WC_GB18030_MAP + ( *p & 0xff)) & 255) != 16) {
                    wtf_push_unknown(os, p - 1, 2);
L33:
                    state = 0;
L44:
                    p =  &(p[1]);
                    continue;
                }
                state = 2;
                goto L44;
            }
            gbk =  *p & 0xff | ( *(p - 1) & 0xff) << 8;
            if(wc_gbk_or_gbk_ext(gbk & 65535) != 34841) {
                if(( *(p - 1) & 255) <= 160 || ( *p & 255) <= 160) {
                    wtf_push(os, 34838, gbk);
                } else {
                    wtf_push(os, wc_gb2312_or_gbk(gbk & 65535), gbk);
                }
            } else {
                wtf_push(os, 34841, gbk);
            }
            goto L33;
        }
        if(_t150 > 1) {
            if(_t150 == 2) {
                if(( *( &WC_GB18030_MAP + ( *p & 0xff)) & 255) != 12) {
                    wtf_push_unknown(os, p - 2, 3);
                    state = 0;
                } else {
                    state = 3;
                }
                goto L44;
            }
            if(_t150 == 3) {
                if(( *( &WC_GB18030_MAP + ( *p & 0xff)) & 255) != 16) {
                    wtf_push_unknown(os, p - 3, 4);
L43:
                    state = 0;
                    goto L44;
                }
                cc.auto_detect = 73730;
                _v44 =  *p & 0xff | ( *(p - 3) & 0xff) << 24 | ( *(p - 2) & 0xff) << 16 | ( *(p - 1) & 0xff) << 8;
                if(( *135119021 & 255) == 0) {
L41:
                    wtf_push(os, cc.auto_detect, _v44);
                    goto L43;
                }
                 *__esp = cc.auto_detect;
                _v72 = _v44;
                ucs = wc_gb18030_to_ucs();
                if(ucs == -1) {
                    goto L41;
                }
                wc_ucs_to_ccs(ucs);
                wtf_push(os, 0x2002, _v44);
                goto L43;
            }
            goto L44;
        }
        if(_t150 == 0) {
            _t234 =  *( &WC_GB18030_MAP + ( *p & 0xff)) & 0xff;
            if(_t234 == 2) {
                wtf_push_unknown(os, p, 1);
L22:
                goto L44;
            }
            if(_t234 != 12) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t243 = os->length;
                 *((char*)(os->ptr + _t243)) =  *p & 255;
                os->length = _t243 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                goto L44;
            }
            state = 1;
            goto L22;
        } else {
            goto L44;
        }
    }
    _t250 = state;
    if(_t250 == 2) {
        wtf_push_unknown(os, p - 2, 2);
    } else {
        if(_t250 == 3) {
            wtf_push_unknown(os, p - 3, 3);
        } else {
            if(_t250 == 1) {
                wtf_push_unknown(os, p - 1, 1);
            }
        }
    }
    return os;
L2:
    if(p >= ep || ( *p & 255) < 0) {
        if(p == ep) {
            return is;
        }
        os = Strnew_size(is->length);
        if(p > sp) {
            Strcat_charp_n(os, is->ptr, p - sp);
        }
    } else {
        p =  &(p[1]);
        goto L2;
    }
    goto L45;
}

void wc_push_to_gb18030(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C4FA9  --  defined in 'gb18030.c' at line 254
    wc_status* _v16;   // _cfa_fffffff0
    unsigned char _v20;                    // _cfa_ffffffec
    intOrPtr _v32;                         // _cfa_ffffffe0
    wc_status* _v36;   // _cfa_ffffffdc
    unsigned char _v40;                    // _cfa_ffffffd8 (outparam)
    signed int _t221;                      // _t221
    unsigned char _t228;                   // _t228
    int _t240;                             // _t240
    int _t252;                             // _t252
    int _t267;                             // _t267
    int _t279;                             // _t279
    int _t296;                             // _t296
    int _t308;                             // _t308
    int _t322;                             // _t322
    int _t335;                             // _t335
    int _t347;                             // _t347
    int _t359;                             // _t359
    int _t371;                             // _t371

    while(1) {
        _t221 = cc.auto_detect & 65535;
        if(_t221 > 34840) {
            goto L11;
        }
        if(_t221 >= 34839) {
            _v40 = cc.auto_detect;
            _v36 = st;
             *__esp =  &cc;
            wc_cs128w_to_gbk();
            __esp = __esp - 4;
L25:
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t267 = os->length;
             *((char*)(os->ptr + _t267)) = st >> 8;
            os->length = _t267 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t279 = os->length;
             *((char*)(os->ptr + _t279)) = st;
            os->length = _t279 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(_t221 != 16384) {
            if(_t221 > 16384) {
                if(_t221 == 33089) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t296 = os->length;
                     *((char*)(os->ptr + _t296)) = st >> 8 | -128;
                    os->length = _t296 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t308 = os->length;
                     *((char*)(os->ptr + _t308)) = st | -128;
                    os->length = _t308 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    return;
                }
                if(_t221 == 34838) {
                    goto L25;
                }
            } else {
                if(_t221 == 322) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t322 = os->length;
                     *((char*)(os->ptr + _t322)) = st;
                    os->length = _t322 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    return;
                }
                if(_t221 == 8194) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t335 = os->length;
                     *((char*)(os->ptr + _t335)) = st >> 24;
                    os->length = _t335 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t347 = os->length;
                     *((char*)(os->ptr + _t347)) = st >> 16;
                    os->length = _t347 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t359 = os->length;
                     *((char*)(os->ptr + _t359)) = st >> 8;
                    os->length = _t359 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t371 = os->length;
                     *((char*)(os->ptr + _t371)) = st;
                    os->length = _t371 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    return;
                }
            }
L49:
            if(( *135119011 & 255) == 0) {
                if((cc.auto_detect & 98304) == 0) {
                    _t228 = 16384;
                } else {
                    _t228 = 49152;
                }
                cc.auto_detect = _t228;
            } else {
                _v32 =  *((intOrPtr*)(__ebp + 20));
                _v40 = cc.auto_detect;
                _v36 = st;
                 *__esp =  &_v20;
                wc_any_to_any_ces();
                __esp = __esp - 4;
                cc.auto_detect = _v20;
                st = _v16;
            }
            continue;
        }
        if(( *135119022 & 255) == 0) {
            Strcat_charp(os, WcReplace);
            return;
        }
        return;
L11:
        if(_t221 <= 34843) {
            if(_t221 >= 34842) {
                _v40 = cc.auto_detect;
                _v36 = st;
                 *__esp =  &_v20;
                wc_cs128w_to_gbk();
                __esp = __esp - 4;
                cc.auto_detect = _v20;
                st = _v16;
            }
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t240 = os->length;
             *((char*)(os->ptr + _t240)) = st >> 8;
            os->length = _t240 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t252 = os->length;
             *((char*)(os->ptr + _t252)) = st;
            os->length = _t252 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(_t221 == 49152) {
            if(( *135119022 & 255) != 0) {
                return;
            }
            Strcat_charp(os, WcReplaceW);
            return;
        }
        goto L49;
    }
}

Str wc_char_conv_from_gb18030(wc_uchar c, wc_status* st)
{// addr = 0x080C549B  --  defined in 'gb18030.c' at line 306
    wc_uint32 gbk;   // _cfa_fffffff0
    wc_uint32 ucs;   // _cfa_ffffffec
    unsigned int _v24;                     // _cfa_ffffffe8
    wc_wchar_t cc;   // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    unsigned int _v56;                     // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t72;                              // _t72
    signed int _t124;                      // _t124
    struct _Str* _t130;   // _t130
    int _t162;                             // _t162

    _v32 = c;
    if(st->state == -1) {
        st->state = 0;
        os.3152 = Strnew_size(8);
    }
    _t72 = st->state;
    if(_t72 == 1) {
        if(( *( &WC_GB18030_MAP + (_v32 & 255)) & 4) == 0) {
            if(( *( &WC_GB18030_MAP + (_v32 & 255)) & 255) != 16) {
L34:
                st->state = -1;
                return os.3152;
            }
             *135791817 = _v32 & 255;
            st->state = 2;
            return 0;
        }
        gbk = _v32 & 255 | (gb & 0xff) << 8;
        if(wc_gbk_or_gbk_ext(gbk & 65535) != 34841) {
            if((gb & 255) <= 160 || _v32 <= 160) {
                wtf_push(os.3152, 34838, gbk);
            } else {
                wtf_push(os.3152, wc_gb2312_or_gbk(gbk & 65535), gbk);
            }
        } else {
            wtf_push(os.3152, 34841, gbk);
        }
        goto L34;
    }
    if(_t72 > 1) {
        if(_t72 == 2) {
            if(( *( &WC_GB18030_MAP + (_v32 & 255)) & 255) != 12) {
                goto L34;
            }
             *135791818 = _v32 & 255;
            st->state = 3;
            return 0;
        }
        if(_t72 == 3) {
            if(( *( &WC_GB18030_MAP + (_v32 & 255)) & 255) != 16) {
                goto L34;
            }
            cc.auto_detect = 73730;
            _v24 = _v32 & 255 | (gb & 0xff) << 24 | ( *135791817 & 0xff) << 16 | ( *135791818 & 0xff) << 8;
            if(( *135119021 & 255) == 0) {
L31:
                wtf_push(os.3152, cc.auto_detect, _v24);
                goto L34;
            }
             *__esp = cc.auto_detect;
            _v56 = _v24;
            ucs = wc_gb18030_to_ucs();
            if(ucs == -1) {
                goto L31;
            }
            wc_ucs_to_ccs(ucs);
            wtf_push(os.3152, 0x2002, _v24);
            goto L34;
        }
        goto L34;
    }
    if(_t72 == 0) {
        _t124 =  *( &WC_GB18030_MAP + (_v32 & 255)) & 0xff;
        if(_t124 == 2) {
            goto L34;
        }
        if(_t124 != 12) {
            if(os.3152->length + 1 >= os.3152->area_size) {
                Strgrow(os.3152);
            }
            _t130 = os.3152;
            _t162 = _t130->length;
             *((char*)( *os.3152 + _t162)) = _v32 & 255;
            _t130->length = _t162 + 1;
             *((char*)( *os.3152 + os.3152->length)) = 0;
            goto L34;
        }
        gb = _v32 & 255;
        st->state = 1;
        return 0;
    } else {
        goto L34;
    }
}

wc_ccs wc_gb2312_or_gbk(wc_uint16 code)
{// addr = 0x080C57A0  --  defined in 'gbk.c' at line 40
    signed short _v16;                     // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v16 = code;
    if(wc_map_range_search(_v16 & 65535,  &gb2312_gbk_map, 7) == 0) {
        return 33089;
    }
    return 34838;
}

wc_wchar_t wc_gbk_to_cs128w(wc_wchar_t cc)
{// addr = 0x080C57DB  --  defined in 'gbk.c' at line 47
    _unknown_ __ebx;                       // r1
    _unknown_ _t25;                        // _t25
    _unknown_ _t42;                        // _t42

    __ecx = cc.auto_detect;
    _t42 = (_a12 >> 8 & 255) * 190 + (_a12 & 255);
    if((_a12 & 255) > 127) {
        _t25 = 65;
    } else {
        _t25 = 64;
    }
    _a12 = _t42 - _t25 - 24510;
    if(_a12 > 16383) {
         *((intOrPtr*)(__ebp + 12)) = 34840;
        _a12 = _a12 - 16384;
    } else {
         *((intOrPtr*)(__ebp + 12)) = 34839;
    }
    _a12 = (_a12 >> 7 << 8) + (_a12 & 127);
     *__ecx =  *((intOrPtr*)(__ebp + 12));
     *(__ecx + 4) = _a12;
    return __ecx;
}

wc_wchar_t wc_cs128w_to_gbk(wc_wchar_t cc)
{// addr = 0x080C5874  --  defined in 'gbk.c' at line 61
    signed int _v20;                       // _cfa_ffffffec
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    struct  __esi;            // r5
    _unknown_ _t59;                        // _t59
    unsigned int _t66;                     // _t66
    unsigned int _t67;                     // _t67
    _unknown_ _t71;                        // _t71
    signed int _t90;                       // _t90

    __esi = cc.auto_detect;
    _a12 = ((_a12 >> 8 & 127) << 7) + (_a12 & 127);
    if( *((intOrPtr*)(__ebp + 12)) == 34840) {
        _a12 = _a12 + 16384;
    }
     *((intOrPtr*)(__ebp + 12)) = 34838;
    _v20 = _a12 >> 1;
    _t90 = (_v20 * -1401515643 >> 32 >> 6) + 129 << 8;
    _t66 = _a12;
    _v20 = _t66 >> 1;
    _t71 = _t66 - (_v20 * -1401515643 >> 32 >> 6) * 190;
    _t67 = _a12;
    _v20 = _t67 >> 1;
    if(_t67 - (_v20 * -1401515643 >> 32 >> 6) * 190 > 62) {
        _t59 = 65;
    } else {
        _t59 = 64;
    }
    _a12 = _t90 + _t71 + _t59;
     *__esi =  *((intOrPtr*)(__ebp + 12));
     *(__esi + 4) = _a12;
    return __esi;
}

wc_uint32 wc_gbk_to_N(wc_uint32 c)
{// addr = 0x080C5952  --  defined in 'gbk.c' at line 72
    _unknown_ _t47;                        // _t47
    _unknown_ _t59;                        // _t59
    _unknown_ _t71;                        // _t71
    _unknown_ _t83;                        // _t83
    _unknown_ _t95;                        // _t95
    _unknown_ _t107;                       // _t107
    _unknown_ _t119;                       // _t119
    _unknown_ _t138;                       // _t138
    _unknown_ _t142;                       // _t142
    _unknown_ _t146;                       // _t146
    _unknown_ _t150;                       // _t150
    _unknown_ _t154;                       // _t154
    _unknown_ _t158;                       // _t158
    _unknown_ _t162;                       // _t162

    if(c > 41376) {
        if(c > 41642) {
            if(c > 42656) {
                if(c > 42741) {
                    if(c > 43168) {
                        if(c > 43200) {
                            _t138 = (c >> 8 & 255) * 190 + (c & 255);
                            if((c & 255) > 127) {
                                _t47 = 65;
                            } else {
                                _t47 = 64;
                            }
                            return _t138 - _t47 - (c >> 8) * 94 - 9338;
                        }
                        _t142 = (c >> 8 & 255) * 190 + (c & 255);
                        if((c & 255) > 127) {
                            _t59 = 65;
                        } else {
                            _t59 = 64;
                        }
                        return _t142 - _t59 - (c >> 8) * 94 - 9370;
                    }
                    _t146 = (c >> 8 & 255) * 190 + (c & 255);
                    if((c & 255) > 127) {
                        _t71 = 65;
                    } else {
                        _t71 = 64;
                    }
                    return _t146 - _t71 - (c >> 8) * 94 - 9344;
                }
                _t150 = (c >> 8 & 255) * 190 + (c & 255);
                if((c & 255) > 127) {
                    _t83 = 65;
                } else {
                    _t83 = 64;
                }
                return _t150 - _t83 - (c >> 8) * 94 - 9429;
            }
            _t154 = (c >> 8 & 255) * 190 + (c & 255);
            if((c & 255) > 127) {
                _t95 = 65;
            } else {
                _t95 = 64;
            }
            return _t154 - _t95 - (c >> 8) * 94 - 9366;
        }
        _t158 = (c >> 8 & 255) * 190 + (c & 255);
        if((c & 255) > 127) {
            _t107 = 65;
        } else {
            _t107 = 64;
        }
        return _t158 - _t107 - (c >> 8) * 94 - 9376;
    }
    _t162 = (c >> 8 & 255) * 190 + (c & 255);
    if((c & 255) > 127) {
        _t119 = 65;
    } else {
        _t119 = 64;
    }
    return _t162 - _t119 - 24510;
}

Str wc_conv_from_gbk(Str is, wc_ces ces)
{// addr = 0x080C5BB1  --  defined in 'gbk.c' at line 91
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    int state;                             // _cfa_ffffffe0
    wc_uint32 gbk;   // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    int _t102;                             // _t102
    signed int _t107;                      // _t107
    int _t120;                             // _t120

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    p = sp;
    do {
    } while(p < ep && ( *p & 255) >= 0);
    if(p == ep) {
        return is;
    }
    os = Strnew_size(is->length);
    if(p > sp) {
        Strcat_charp_n(os, is->ptr, p - sp);
    }
    while(p < ep) {
        _t102 = state;
        if(_t102 == 0) {
            _t107 =  *( &WC_GBK_MAP + ( *p & 0xff)) & 0xff;
            if(_t107 == 12) {
                state = 1;
L21:
L29:
                p =  &(p[1]);
                continue;
            }
            if(_t107 == 20) {
                wtf_push(os, 2087,  *p & 0xff);
                goto L21;
            }
            if(_t107 == 2) {
                wtf_push_unknown(os, p, 1);
                goto L21;
            }
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t120 = os->length;
             *((char*)(os->ptr + _t120)) =  *p & 255;
            os->length = _t120 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            goto L29;
        }
        if(_t102 == 1) {
            if(( *( &WC_GBK_MAP + ( *p & 0xff)) & 4) == 0) {
                wtf_push_unknown(os, p - 1, 2);
            } else {
                gbk =  *p & 0xff | ( *(p - 1) & 0xff) << 8;
                if(( *(p - 1) & 255) <= 160 || ( *p & 255) <= 160) {
                    wtf_push(os, 34838, gbk);
                } else {
                    wtf_push(os, wc_gb2312_or_gbk(gbk & 65535), gbk);
                }
            }
            state = 0;
        }
        goto L29;
    }
    if(state == 1) {
        wtf_push_unknown(os, p - 1, 1);
    }
    return os;
}

void wc_push_to_gbk(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C5E0F  --  defined in 'gbk.c' at line 148
    wc_status* _v16;   // _cfa_fffffff0
    unsigned char _v20;                    // _cfa_ffffffec
    intOrPtr _v32;                         // _cfa_ffffffe0
    wc_status* _v36;   // _cfa_ffffffdc
    unsigned char _v40;                    // _cfa_ffffffd8 (outparam)
    unsigned char _t126;                   // _t126
    int _t133;                             // _t133
    int _t145;                             // _t145
    unsigned char _t159;                   // _t159
    int _t170;                             // _t170
    int _t182;                             // _t182
    int _t196;                             // _t196
    int _t212;                             // _t212

    while(1) {
        _t126 = cc.auto_detect;
        if(_t126 == 33089) {
            break;
        }
        if(_t126 > 33089) {
            if(_t126 > 34840) {
                if(_t126 == 49152) {
                    if(( *135119022 & 255) != 0) {
                        return;
                    }
                    Strcat_charp(os, WcReplaceW);
                    return;
                }
            } else {
                if(_t126 >= 34839) {
                    _v40 = cc.auto_detect;
                    _v36 = st;
                     *__esp =  &cc;
                    wc_cs128w_to_gbk();
                    __esp = __esp - 4;
L25:
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t170 = os->length;
                     *((char*)(os->ptr + _t170)) = st >> 8;
                    os->length = _t170 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t182 = os->length;
                     *((char*)(os->ptr + _t182)) = st;
                    os->length = _t182 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    return;
                }
                if(_t126 == 34838) {
                    goto L25;
                }
            }
L34:
            if(( *135119011 & 255) == 0) {
                if((cc.auto_detect & 98304) == 0) {
                    _t159 = 16384;
                } else {
                    _t159 = 49152;
                }
                cc.auto_detect = _t159;
            } else {
                _v32 =  *((intOrPtr*)(__ebp + 20));
                _v40 = cc.auto_detect;
                _v36 = st;
                 *__esp =  &_v20;
                wc_any_to_any_ces();
                __esp = __esp - 4;
                cc.auto_detect = _v20;
                st = _v16;
            }
            continue;
        }
        if(_t126 == 2087) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t196 = os->length;
             *((char*)(os->ptr + _t196)) = st | -128;
            os->length = _t196 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(_t126 != 16384) {
            if(_t126 == 322) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t212 = os->length;
                 *((char*)(os->ptr + _t212)) = st;
                os->length = _t212 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            goto L34;
        }
        if(( *135119022 & 255) == 0) {
            Strcat_charp(os, WcReplace);
            return;
        }
        return;
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t133 = os->length;
     *((char*)(os->ptr + _t133)) = st >> 8 | -128;
    os->length = _t133 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t145 = os->length;
     *((char*)(os->ptr + _t145)) = st | -128;
    os->length = _t145 + 1;
     *((char*)(os->ptr + os->length)) = 0;
}

Str wc_char_conv_from_gbk(wc_uchar c, wc_status* st)
{// addr = 0x080C6133  --  defined in 'gbk.c' at line 190
    wc_uint32 gbk;   // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t43;                              // _t43
    signed int _t46;                       // _t46
    struct _Str* _t58;    // _t58
    int _t86;                              // _t86

    _v32 = c;
    if(st->state == -1) {
        st->state = 0;
        os.2832 = Strnew_size(8);
    }
    _t43 = st->state;
    if(_t43 == 0) {
        _t46 =  *( &WC_GBK_MAP + (_v32 & 255)) & 0xff;
        if(_t46 == 12) {
            gbku = _v32 & 255;
            st->state = 1;
            return 0;
        }
        if(_t46 == 20) {
            wtf_push(os.2832, 2087, _v32 & 255);
L15:
            goto L21;
        }
        if(_t46 == 2) {
            goto L15;
        }
        if(os.2832->length + 1 >= os.2832->area_size) {
            Strgrow(os.2832);
        }
        _t58 = os.2832;
        _t86 = _t58->length;
         *((char*)( *os.2832 + _t86)) = _v32 & 255;
        _t58->length = _t86 + 1;
         *((char*)( *os.2832 + os.2832->length)) = 0;
        goto L21;
    } else {
        if(_t43 == 1) {
            if(( *( &WC_GBK_MAP + (_v32 & 255)) & 4) != 0) {
                gbk = _v32 & 255 | (gbku & 0xff) << 8;
                if((gbku & 255) <= 160 || _v32 <= 160) {
                    wtf_push(os.2832, 34838, gbk);
                } else {
                    wtf_push(os.2832, wc_gb2312_or_gbk(gbk & 65535), gbk);
                }
            }
        }
L21:
        st->state = -1;
        return os.2832;
    }
}

wc_wchar_t wc_hkscs_to_cs128w(wc_wchar_t cc)
{// addr = 0x080C62D8  --  defined in 'hkscs.c' at line 39
    _unknown_ __ebx;                       // r1
    _unknown_ _t25;                        // _t25
    _unknown_ _t42;                        // _t42

    __ecx = cc.auto_detect;
    _t42 = (_a12 >> 8 & 255) * 157 + (_a12 & 255);
    if((_a12 & 255) > 160) {
        _t25 = 98;
    } else {
        _t25 = 64;
    }
    _a12 = _t42 - _t25 - 21352;
    if(_a12 > 16383) {
         *((intOrPtr*)(__ebp + 12)) = 34849;
        _a12 = _a12 - 16384;
    } else {
         *((intOrPtr*)(__ebp + 12)) = 34848;
    }
    _a12 = (_a12 >> 7 << 8) + (_a12 & 127);
     *__ecx =  *((intOrPtr*)(__ebp + 12));
     *(__ecx + 4) = _a12;
    return __ecx;
}

wc_wchar_t wc_cs128w_to_hkscs(wc_wchar_t cc)
{// addr = 0x080C6373  --  defined in 'hkscs.c' at line 53
    signed int _v20;                       // _cfa_ffffffec
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    struct  __esi;            // r5
    _unknown_ _t55;                        // _t55
    _unknown_ _t67;                        // _t67
    signed int _t80;                       // _t80

    __esi = cc.auto_detect;
    _a12 = ((_a12 >> 8 & 127) << 7) + (_a12 & 127);
    if( *((intOrPtr*)(__ebp + 12)) == 34849) {
        _a12 = _a12 + 16384;
    }
     *((intOrPtr*)(__ebp + 12)) = 34847;
    _v20 = _a12;
    _t80 = (_v20 * 875407347 >> 32 >> 5) + 136 << 8;
    _t67 = _a12 - (_a12 * 875407347 >> 32 >> 5) * 157;
    if(_a12 - (_a12 * 875407347 >> 32 >> 5) * 157 > 62) {
        _t55 = 98;
    } else {
        _t55 = 64;
    }
    _a12 = _t80 + _t67 + _t55;
     *__esi =  *((intOrPtr*)(__ebp + 12));
     *(__esi + 4) = _a12;
    return __esi;
}

wc_uint32 wc_hkscs_to_N(wc_uint32 c)
{// addr = 0x080C643D  --  defined in 'hkscs.c' at line 64
    _unknown_ _t16;                        // _t16
    _unknown_ _t25;                        // _t25
    _unknown_ _t34;                        // _t34
    _unknown_ _t37;                        // _t37

    if(c > 41279) {
        _t34 = (c >> 8 & 255) * 157 + (c & 255);
        if((c & 255) > 160) {
            _t16 = 98;
        } else {
            _t16 = 64;
        }
        return _t34 - _t16 - 35325;
    }
    _t37 = (c >> 8 & 255) * 157 + (c & 255);
    if((c & 255) > 160) {
        _t25 = 98;
    } else {
        _t25 = 64;
    }
    return _t37 - _t25 - 21352;
}

Str wc_conv_from_hkscs(Str is, wc_ces ces)
{// addr = 0x080C64D3  --  defined in 'hkscs.c' at line 73
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    int state;                             // _cfa_ffffffe0
    wc_uint32 hkscs;   // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    int _t97;                              // _t97
    signed int _t102;                      // _t102
    int _t111;                             // _t111

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    p = sp;
    goto L2;
    do {
    } while();
L29:
    while(p < ep) {
        _t97 = state;
        if(_t97 == 0) {
            _t102 =  *( &WC_HKSCS_MAP + ( *p & 0xff)) & 0xff;
            if(_t102 == 12 || _t102 == 16) {
                state = 1;
                goto L20;
            } else {
                if(_t102 == 2) {
                    wtf_push_unknown(os, p, 1);
L20:
L28:
                    p =  &(p[1]);
                    continue;
                }
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t111 = os->length;
                 *((char*)(os->ptr + _t111)) =  *p & 255;
                os->length = _t111 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                goto L28;
            }
        }
        if(_t97 == 1) {
            if(( *( &WC_HKSCS_MAP + ( *p & 0xff)) & 4) == 0) {
                wtf_push_unknown(os, p - 1, 2);
            } else {
                hkscs =  *p & 0xff | ( *(p - 1) & 0xff) << 8;
                if(( *(p - 1) & 255) <= 160 || ( *(p - 1) & 255) > 249) {
                    wtf_push(os, 34847, hkscs);
                } else {
                    wtf_push(os, 34817, hkscs);
                }
            }
            state = 0;
        }
        goto L28;
    }
    if(state == 1) {
        wtf_push_unknown(os, p - 1, 1);
    }
    return os;
L2:
    if(p >= ep || ( *p & 255) < 0) {
        if(p == ep) {
            return is;
        }
        os = Strnew_size(is->length);
        if(p > sp) {
            Strcat_charp_n(os, is->ptr, p - sp);
        }
    } else {
        p =  &(p[1]);
        goto L2;
    }
    goto L29;
}

void wc_push_to_hkscs(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C6705  --  defined in 'hkscs.c' at line 128
    wc_status* _v16;   // _cfa_fffffff0
    unsigned char _v20;                    // _cfa_ffffffec
    intOrPtr _v32;                         // _cfa_ffffffe0
    wc_status* _v36;   // _cfa_ffffffdc
    unsigned char _v40;                    // _cfa_ffffffd8 (outparam)
    unsigned char _t118;                   // _t118
    unsigned char _t125;                   // _t125
    int _t137;                             // _t137
    int _t149;                             // _t149
    int _t164;                             // _t164
    int _t176;                             // _t176
    int _t193;                             // _t193

    while(1) {
        _t118 = cc.auto_detect;
        if(_t118 > 34819) {
            goto L7;
        }
        if(_t118 >= 34818) {
            _v40 = cc.auto_detect;
            _v36 = st;
             *__esp =  &cc;
            wc_cs94w_to_big5();
            __esp = __esp - 4;
L17:
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t164 = os->length;
             *((char*)(os->ptr + _t164)) = st >> 8;
            os->length = _t164 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t176 = os->length;
             *((char*)(os->ptr + _t176)) = st;
            os->length = _t176 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(_t118 != 16384) {
            if(_t118 == 34817) {
                goto L17;
            }
            if(_t118 == 322) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t193 = os->length;
                 *((char*)(os->ptr + _t193)) = st;
                os->length = _t193 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
L32:
            if(( *135119011 & 255) == 0) {
                if((cc.auto_detect & 98304) == 0) {
                    _t125 = 16384;
                } else {
                    _t125 = 49152;
                }
                cc.auto_detect = _t125;
            } else {
                _v32 =  *((intOrPtr*)(__ebp + 20));
                _v40 = cc.auto_detect;
                _v36 = st;
                 *__esp =  &_v20;
                wc_any_to_any_ces();
                __esp = __esp - 4;
                cc.auto_detect = _v20;
                st = _v16;
            }
            continue;
        }
        if(( *135119022 & 255) == 0) {
            Strcat_charp(os, WcReplace);
            return;
        }
        return;
L7:
        if(_t118 > 34849) {
            if(_t118 == 49152) {
                if(( *135119022 & 255) != 0) {
                    return;
                }
                Strcat_charp(os, WcReplaceW);
                return;
            }
        } else {
            if(_t118 >= 34848) {
                _v40 = cc.auto_detect;
                _v36 = st;
                 *__esp =  &_v20;
                wc_cs128w_to_hkscs();
                __esp = __esp - 4;
                cc.auto_detect = _v20;
                st = _v16;
L23:
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t137 = os->length;
                 *((char*)(os->ptr + _t137)) = st >> 8;
                os->length = _t137 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t149 = os->length;
                 *((char*)(os->ptr + _t149)) = st;
                os->length = _t149 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            if(_t118 == 34847) {
                goto L23;
            }
        }
        goto L32;
    }
}

Str wc_char_conv_from_hkscs(wc_uchar c, wc_status* st)
{// addr = 0x080C69F7  --  defined in 'hkscs.c' at line 170
    wc_uint32 hkscs;   // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    int _t39;                              // _t39
    signed int _t42;                       // _t42
    struct _Str* _t53;    // _t53
    int _t78;                              // _t78

    _v32 = c;
    if(st->state == -1) {
        st->state = 0;
        os.2724 = Strnew_size(8);
    }
    _t39 = st->state;
    if(_t39 == 0) {
        _t42 =  *( &WC_HKSCS_MAP + (_v32 & 255)) & 0xff;
        if(_t42 == 12 || _t42 == 16) {
            hkscsu = _v32 & 255;
            st->state = 1;
            return 0;
        }
        if(_t42 != 2) {
            if(os.2724->length + 1 >= os.2724->area_size) {
                Strgrow(os.2724);
            }
            _t53 = os.2724;
            _t78 = _t53->length;
             *((char*)( *os.2724 + _t78)) = _v32 & 255;
            _t53->length = _t78 + 1;
             *((char*)( *os.2724 + os.2724->length)) = 0;
        }
    } else {
        if(_t39 == 1) {
            if(( *( &WC_HKSCS_MAP + (_v32 & 255)) & 4) != 0) {
                hkscs = _v32 & 255 | (hkscsu & 0xff) << 8;
                if((hkscsu & 255) <= 160 || (hkscsu & 255) > 249 || _v32 <= 160) {
                    wtf_push(os.2724, 34847, hkscs);
                } else {
                    wtf_push(os.2724, 34817, hkscs);
                }
            }
        }
    }
    st->state = -1;
    return os.2724;
}

Str wc_conv_from_priv1(Str is, wc_ces ces)
{// addr = 0x080C6B7C  --  defined in 'priv.c' at line 6
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    wc_ccs ccs;         // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    int _t86;                              // _t86

    sp = is->ptr;
    ep = sp + is->length;
    ccs =  *( *((intOrPtr*)(((ces & 255) << 5) + 135767980)) + 8);
    p = sp;
    do {
    } while(p < ep && ( *p & 255) >= 0);
    if(p != ep) {
        os = Strnew_size(is->length);
        if(p > sp) {
            Strcat_charp_n(os, is->ptr, p - sp);
        }
        while(p < ep) {
            if(( *p & 255) >= 0) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t86 = os->length;
                 *((char*)(os->ptr + _t86)) =  *p & 255;
                os->length = _t86 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
            } else {
                wtf_push(os, ccs,  *p & 0xff);
            }
            p =  &(p[1]);
        }
        return os;
    }
    return is;
}

Str wc_char_conv_from_priv1(wc_uchar c, wc_status* st)
{// addr = 0x080C6CAB  --  defined in 'priv.c' at line 32
    Str os;                // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    int _t38;                              // _t38

    _v32 = c;
    os = Strnew_size(1);
    if((_v32 & 255) >= 0) {
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t38 = os->length;
         *((char*)(os->ptr + _t38)) = _v32 & 255;
        os->length = _t38 + 1;
         *((char*)(os->ptr + os->length)) = 0;
    } else {
        wtf_push(os,  *(st->ces_info->gset + 8), _v32 & 255);
    }
    return os;
}

Str wc_conv_from_ascii(Str is, wc_ces ces)
{// addr = 0x080C6D46  --  defined in 'priv.c' at line 44
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int _t76;                              // _t76

    sp = is->ptr;
    ep = sp + is->length;
    p = sp;
    do {
    } while(p < ep && ( *p & 255) >= 0);
    if(p != ep) {
        os = Strnew_size(is->length);
        if(p > sp) {
            Strcat_charp_n(os, is->ptr, p - sp);
        }
        while(p < ep) {
            if(( *p & 255) >= 0) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t76 = os->length;
                 *((char*)(os->ptr + _t76)) =  *p & 255;
                os->length = _t76 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
            } else {
                wtf_push_unknown(os, p, 1);
            }
            p =  &(p[1]);
        }
        return os;
    }
    return is;
}

void wc_push_to_raw(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C6E57  --  defined in 'priv.c' at line 69
    unsigned char _t19;                    // _t19
    int _t26;                              // _t26

    _t19 = cc.auto_detect;
    if(_t19 == 322 || _t19 == 2088) {
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t26 = os->length;
         *((char*)(os->ptr + _t26)) = st;
        os->length = _t26 + 1;
         *((char*)(os->ptr + os->length)) = 0;
        return;
    } else {
        return;
    }
}

signed int __divdi3(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x080C6EC0
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t66;                       // _t66
    signed int _t70;                       // _t70
    signed int _t71;                       // _t71
    signed int _t72;                       // _t72
    signed int _t73;                       // _t73
    signed int _t83;                       // _t83
    signed int _t90;                       // _t90
    signed int _t95;                       // _t95
    signed int _t96;                       // _t96
    signed int _t104;                      // _t104
    signed int _t117;                      // _t117
    signed int _t120;                      // _t120
    signed int _t124;                      // _t124
    signed int _t128;                      // _t128

    _t83 = _a8;
    _t95 = _a4;
    _v20 = _a12;
    _v16 = _a16;
    _v24 = 0;
    if(_t83 < 0) {
        _t95 =  ~_t95;
        asm("adc ecx, 0x0");
        _t83 =  ~_t83;
        _v24 = -1;
        if(_v16 >= 0) {
L2:
            _t66 = _v16;
            _t117 = _t83;
            _t124 = _v20;
            _v20 = _t95;
            if(_t66 != 0) {
                if(_t66 <= _t83) {
                    asm("bsr edx, eax");
                    _t96 = _t95 ^ 31;
                    _v28 = _t96;
                    if(_t96 != 0) {
                        _v32 = _t66 << (_v28 & 255);
                        _v36 = _t124 << (_v28 & 255);
                        _v32 = _t124 >> 32 | _v32;
                        _t70 = _t117 << (_v28 & 255) | _v20 >> 32 - _v28;
                        _t71 = _t70 / _v32;
                        _t128 = _t70 % _v32;
                        _t120 = _t71;
                        _t104 = _t71 * _v36 >> 32;
                        _t72 = _t71 * _v36;
                        _v32 = _t104;
                        if(_t128 < _t104 || _v20 << (_v28 & 255) < _t72 && _t128 == _v32) {
                            _t90 = _t120 - 1;
                        } else {
                            _t90 = _t120;
                        }
                        goto L7;
                    }
                    if(_t124 <= _v20 || _t66 < _t83) {
                        _t90 = 1;
                        goto L7;
                    } else {
                        goto L6;
                    }
                }
L6:
                _t90 = 0;
                goto L7;
            } else {
                if(_t124 <= _t83) {
                    if(_t124 == 0) {
                        _t124 = 1 / _t124;
                    }
                    _t90 = _v20 / _t124;
                } else {
                    _t90 = _t95 / _t124;
                }
L7:
                _t73 = _t90;
                if(_v24 != 0) {
                    asm("adc edx, 0x0");
                    return  ~_t73;
                }
                return _t73;
            }
        }
L18:
        _v20 =  ~_v20;
        asm("adc dword [ebp-0xc], 0x0");
        _v24 =  !_v24;
        _v16 =  ~_v16;
        goto L2;
    }
    if(_v16 < 0) {
        goto L18;
    }
    goto L2;
}

signed int __moddi3(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed char _a12,                      // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x080C7040
    _unknown_ _v16;                        // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    unsigned int _v48;                     // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t99;                       // _t99
    signed int _t109;                      // _t109
    signed int _t110;                      // _t110
    signed int _t111;                      // _t111
    signed int _t128;                      // _t128
    signed int _t143;                      // _t143
    signed int _t144;                      // _t144
    signed int _t150;                      // _t150
    signed int _t161;                      // _t161
    signed int _t167;                      // _t167
    unsigned int _t171;                    // _t171

    _t128 = _a8;
    _t143 = _a4;
    _v36 = _a12;
    _v32 = _a16;
    _v48 = 0;
    if(_t128 < 0) {
        _t143 =  ~_t143;
        asm("adc ecx, 0x0");
        _t128 =  ~_t128;
        _v48 = -1;
    }
    if(_v32 < 0) {
        _v36 =  ~_v36;
        asm("adc dword [ebp-0x1c], 0x0");
        _v32 =  ~_v32;
    }
    _t99 = _v32;
    _v52 = _t143;
    _v44 = _t143;
    _v40 = _v36;
    _t167 = _t128;
    if(_t99 != 0) {
        if(_t99 <= _t128) {
            asm("bsr edx, eax");
            _t144 = _t143 ^ 31;
            _v36 = _t144;
            if(_t144 != 0) {
                _v44 = 32 - _v36;
                _v60 = _v40 >> (_v44 & 255) | _t99 << (_v36 & 255);
                _v56 = _v40 << (_v36 & 255);
                _t109 = _v52 >> (_v44 & 255) | _t167 << (_v36 & 255);
                _t110 = _t109 / _v60;
                _v40 = _v52 << (_v36 & 255);
                _t171 = _t109 % _v60;
                _t150 = _t110 * _v56 >> 32;
                _t111 = _t110 * _v56;
                if(_t171 < _t150) {
L25:
                    _t111 = _t111 - _v56;
                    asm("sbb edx, [ebp-0x38]");
                } else {
                    if(_v40 < _t111) {
                        if(_t171 == _t150) {
                            goto L25;
                        }
                    }
                }
                asm("sbb edi, edx");
                _v20 = _t171 << (_v44 & 255) | _v40 - _t111 >> (_v36 & 255);
                ((char*)( &_v20))[1] = _t171 >> (_v36 & 255);
            } else {
                if(_v40 <= _v44 || _t99 < _t167) {
                    asm("sbb edi, eax");
                    _v44 = _v44 - _v40;
                }
                ((char*)( &_v20))[1] = _t167;
                _v20 = _v44;
            }
        } else {
            _v20 = _t143;
            ((char*)( &_v20))[1] = _t128;
        }
        if(_v48 == 0) {
            goto L6;
        } else {
            goto L10;
        }
    } else {
        if(_v40 <= _t128) {
            if(_v40 == 0) {
                _v40 = 1 / _v40;
            }
            _t161 = _v44 % _v40;
        } else {
            _t161 = _t143 % _v40;
        }
        _v20 = _t161;
        ((char*)( &_v20))[1] = 0;
        if(_v48 != 0) {
L10:
            asm("adc edx, 0x0");
            return  ~_v20;
        } else {
L6:
            return _v20;
        }
    }
}

__libc_csu_fini(
    _unknown_ __eax                        // r0
)
{// addr = 0x080C7210
    __eax = __eax;
    return __eax;
}

__libc_csu_init(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x080C7220
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    signed int __esi;                      // r5
    _unknown_ _t11;                        // _t11
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    signed int _t21;                       // _t21

    __i686.get_pc_thunk.bx(_t11);
    _t18 = _t17 + 56777;
    __esp = __esp - 28;
    _init();
    _t21 = _t18 - 272 - _t18 - 272 >> 2;
    if(_t21 != 0) {
        __esi = 0;
        do {
            _v36 = _a12;
            _v40 = _a8;
             *__esp = _a4;
             *((intOrPtr*)(_t18 + __esi * 4 - 272))();
            __esi = __esi + 1;
        } while(__esi < _t21);
    }
    __esp = __esp + 28;
}

__i686.get_pc_thunk.bx(
    _unknown_ __eax                        // r0
)
{// addr = 0x080C727A
    __eax = __eax;
    return __eax;
}

__stat(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080C7280
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    intOrPtr _t6;                          // _t6
    intOrPtr _t7;                          // _t7
    _unknown_ _t8;                         // _t8

    _t6 = __i686.get_pc_thunk.bx(_a8);
     *__esp = 3;
    _v12 = _t6;
    _t7 = _a4;
    _v16 = _t7;
    __xstat();
    return _t7;
}

__fstat(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080C72C0
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    intOrPtr _t6;                          // _t6
    intOrPtr _t7;                          // _t7
    _unknown_ _t8;                         // _t8

    _t6 = __i686.get_pc_thunk.bx(_a8);
     *__esp = 3;
    _v12 = _t6;
    _t7 = _a4;
    _v16 = _t7;
    __fxstat();
    return _t7;
}

__lstat(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080C7300
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    intOrPtr _t6;                          // _t6
    intOrPtr _t7;                          // _t7
    _unknown_ _t8;                         // _t8

    _t6 = __i686.get_pc_thunk.bx(_a8);
     *__esp = 3;
    _v12 = _t6;
    _t7 = _a4;
    _v16 = _t7;
    __lxstat();
    return _t7;
}

__do_global_ctors_aux()
{// addr = 0x080C7340
    intOrPtr* __ebx;                       // r1

    __eax = __CTOR_LIST__;
    if(__eax != -1) {
        __ebx =  &__CTOR_LIST__;
        do {
            __ebx = __ebx - 4;
             *__eax();
            __eax =  *__ebx;
        } while(__eax != -1);
    }
}

_fini()
{// addr = 0x080C736C
    _unknown_ __ebx;                       // r1
    _unknown_ _t1;                         // _t1

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    __eax = __do_global_dtors_aux();
    _pop(__ecx);
    return __eax;
}

L080C7378()
{
    _unknown_ _t1;                         // _t1

    _pop(__ebx);
    __eax = __do_global_dtors_aux();
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return __eax;
}

L080C7378()
{
    _unknown_ _t1;                         // _t1

    _pop(__ebx);
    __eax = @rec __do_global_dtors_aux@__do_global_dtors_aux@();
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return __eax;
}

// Statistics:
//    4829 Register nodes
//    8881 Temporaries nodes
//    1172 Casts
//    8413 Statements
//    2670 Labels
//    2114 Gotos
//    1491 Blocks
//  206198 Nodes
//     812 Assembly nodes
//    1772 Unknown Types


Total time: 22 seconds.
