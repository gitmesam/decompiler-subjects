typedef unsigned char   undefined;

typedef unsigned char    byte;
typedef unsigned char    dwfenc;
typedef unsigned int    dword;
typedef long long    longlong;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned long long    ulonglong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined3;
typedef unsigned int    undefined4;
typedef unsigned long long    undefined5;
typedef unsigned long long    undefined7;
typedef unsigned long long    undefined8;
typedef unsigned short    ushort;
typedef unsigned short    word;
typedef struct eh_frame_hdr eh_frame_hdr, *Peh_frame_hdr;

struct eh_frame_hdr {
    byte eh_frame_hdr_version; // Exception Handler Frame Header Version
    dwfenc eh_frame_pointer_encoding; // Exception Handler Frame Pointer Encoding
    dwfenc eh_frame_desc_entry_count_encoding; // Encoding of # of Exception Handler FDEs
    dwfenc eh_frame_table_encoding; // Exception Handler Table Encoding
};

typedef struct fde_table_entry fde_table_entry, *Pfde_table_entry;

struct fde_table_entry {
    dword initial_loc; // Initial Location
    dword data_loc; // Data location
};

typedef ushort sa_family_t;

typedef struct termios termios, *Ptermios;

typedef uint tcflag_t;

typedef uchar cc_t;

typedef uint speed_t;

struct termios {
    tcflag_t c_iflag;
    tcflag_t c_oflag;
    tcflag_t c_cflag;
    tcflag_t c_lflag;
    cc_t c_line;
    cc_t c_cc[32];
    speed_t c_ispeed;
    speed_t c_ospeed;
};

typedef void _IO_lock_t;

typedef struct _IO_marker _IO_marker, *P_IO_marker;

typedef struct _IO_FILE _IO_FILE, *P_IO_FILE;

typedef long __off_t;

typedef longlong __quad_t;

typedef __quad_t __off64_t;

typedef ulong size_t;

struct _IO_FILE {
    int _flags;
    char * _IO_read_ptr;
    char * _IO_read_end;
    char * _IO_read_base;
    char * _IO_write_base;
    char * _IO_write_ptr;
    char * _IO_write_end;
    char * _IO_buf_base;
    char * _IO_buf_end;
    char * _IO_save_base;
    char * _IO_backup_base;
    char * _IO_save_end;
    struct _IO_marker * _markers;
    struct _IO_FILE * _chain;
    int _fileno;
    int _flags2;
    __off_t _old_offset;
    ushort _cur_column;
    char _vtable_offset;
    char _shortbuf[1];
    _IO_lock_t * _lock;
    __off64_t _offset;
    void * __pad1;
    void * __pad2;
    void * __pad3;
    void * __pad4;
    size_t __pad5;
    int _mode;
    char _unused2[15];
};

struct _IO_marker {
    struct _IO_marker * _next;
    struct _IO_FILE * _sbuf;
    int _pos;
};

typedef struct rlimit64 rlimit64, *Prlimit64;

typedef ulonglong __u_quad_t;

typedef __u_quad_t __rlim64_t;

typedef __rlim64_t rlim64_t;

struct rlimit64 {
    rlim64_t rlim_cur;
    rlim64_t rlim_max;
};

typedef enum __rlimit_resource {
    RLIMIT_AS=9,
    RLIMIT_CORE=4,
    RLIMIT_CPU=0,
    RLIMIT_DATA=2,
    RLIMIT_FSIZE=1,
    RLIMIT_NOFILE=7,
    RLIMIT_STACK=3,
    __RLIMIT_LOCKS=10,
    __RLIMIT_MEMLOCK=8,
    __RLIMIT_MSGQUEUE=12,
    __RLIMIT_NICE=13,
    __RLIMIT_NLIMITS=15,
    __RLIMIT_NPROC=6,
    __RLIMIT_OFILE=8,
    __RLIMIT_RSS=5,
    __RLIMIT_RTPRIO=14,
    __RLIMIT_SIGPENDING=11,
    __RLIM_NLIMITS=16
} __rlimit_resource;

typedef enum __rlimit_resource __rlimit_resource_t;

typedef struct stat64 stat64, *Pstat64;

typedef __u_quad_t __dev_t;

typedef ulong __ino_t;

typedef uint __mode_t;

typedef uint __nlink_t;

typedef uint __uid_t;

typedef uint __gid_t;

typedef long __blksize_t;

typedef __quad_t __blkcnt64_t;

typedef struct timespec timespec, *Ptimespec;

typedef __u_quad_t __ino64_t;

typedef long __time_t;

struct timespec {
    __time_t tv_sec;
    long tv_nsec;
};

struct stat64 {
    __dev_t st_dev;
    uint __pad1;
    __ino_t __st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    uint __pad2;
    __off64_t st_size;
    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    __ino64_t st_ino;
};

typedef struct utsname utsname, *Putsname;

struct utsname {
    char sysname[65];
    char nodename[65];
    char release[65];
    char version[65];
    char machine[65];
    char domainname[65];
};

typedef struct addrinfo addrinfo, *Paddrinfo;

typedef uint __socklen_t;

typedef __socklen_t socklen_t;

typedef struct sockaddr sockaddr, *Psockaddr;

struct addrinfo {
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    socklen_t ai_addrlen;
    struct sockaddr * ai_addr;
    char * ai_canonname;
    struct addrinfo * ai_next;
};

struct sockaddr {
    sa_family_t sa_family;
    char sa_data[14];
};

typedef struct _IO_FILE FILE;

typedef int __ssize_t;

typedef __ssize_t ssize_t;

typedef int __pid_t;

typedef int __int32_t;

typedef long __suseconds_t;

typedef long __clock_t;

typedef struct passwd passwd, *Ppasswd;

struct passwd {
    char * pw_name;
    char * pw_passwd;
    __uid_t pw_uid;
    __gid_t pw_gid;
    char * pw_gecos;
    char * pw_dir;
    char * pw_shell;
};

typedef struct evp_pkey_ctx_st evp_pkey_ctx_st, *Pevp_pkey_ctx_st;

struct evp_pkey_ctx_st {
};

typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;

typedef int nl_item;

typedef struct dirent64 dirent64, *Pdirent64;

struct dirent64 {
    __ino64_t d_ino;
    __off64_t d_off;
    ushort d_reclen;
    uchar d_type;
    char d_name[256];
};

typedef struct __dirstream __dirstream, *P__dirstream;

struct __dirstream {
};

typedef struct __dirstream DIR;

typedef struct utimbuf utimbuf, *Putimbuf;

struct utimbuf {
    __time_t actime;
    __time_t modtime;
};

typedef union sigval sigval, *Psigval;

typedef union sigval sigval_t;

union sigval {
    int sival_int;
    void * sival_ptr;
};

typedef struct siginfo siginfo, *Psiginfo;

typedef union _union_1028 _union_1028, *P_union_1028;

typedef struct _struct_1029 _struct_1029, *P_struct_1029;

typedef struct _struct_1030 _struct_1030, *P_struct_1030;

typedef struct _struct_1031 _struct_1031, *P_struct_1031;

typedef struct _struct_1032 _struct_1032, *P_struct_1032;

typedef struct _struct_1033 _struct_1033, *P_struct_1033;

typedef struct _struct_1034 _struct_1034, *P_struct_1034;

struct _struct_1034 {
    long si_band;
    int si_fd;
};

struct _struct_1033 {
    void * si_addr;
};

struct _struct_1032 {
    __pid_t si_pid;
    __uid_t si_uid;
    int si_status;
    __clock_t si_utime;
    __clock_t si_stime;
};

struct _struct_1031 {
    __pid_t si_pid;
    __uid_t si_uid;
    sigval_t si_sigval;
};

struct _struct_1029 {
    __pid_t si_pid;
    __uid_t si_uid;
};

struct _struct_1030 {
    int si_tid;
    int si_overrun;
    sigval_t si_sigval;
};

union _union_1028 {
    int _pad[125];
    struct _struct_1029 _kill;
    struct _struct_1030 _timer;
    struct _struct_1031 _rt;
    struct _struct_1032 _sigchld;
    struct _struct_1033 _sigfault;
    struct _struct_1034 _sigpoll;
};

struct siginfo {
    int si_signo;
    int si_errno;
    int si_code;
    union _union_1028 _sifields;
};

typedef struct siginfo siginfo_t;

typedef struct color_spec color_spec, *Pcolor_spec;

typedef uint uint32_t;

typedef uint32_t color_T;

struct color_spec {
    char * name;
    color_T rgb;
};

typedef struct color_mode_info color_mode_info, *Pcolor_mode_info;

typedef struct rgb rgb, *Prgb;

typedef struct anon_struct.conflict13 anon_struct.conflict13, *Panon_struct.conflict13;

struct anon_struct.conflict13 {
    int bg;
    int fg;
};

struct color_mode_info {
    struct rgb * palette;
    struct anon_struct.conflict13 palette_range[2];
};

struct rgb {
    uchar r;
    uchar g;
    uchar b;
    uchar pad;
};

typedef struct rgb_cache_entry rgb_cache_entry, *Prgb_cache_entry;

struct rgb_cache_entry {
    int color;
    int level;
    color_T rgb;
};

typedef enum palette_range {
    PALETTE_FULL=0,
    PALETTE_HALF=1,
    PALETTE_RANGES=2
} palette_range;

typedef enum color_mode {
    COLOR_MODES=5,
    COLOR_MODE_16=1,
    COLOR_MODE_256=3,
    COLOR_MODE_88=2,
    COLOR_MODE_DUMP=-1,
    COLOR_MODE_MONO=0
} color_mode;

typedef enum color_flags {
    COLOR_DECREASE_LIGHTNESS=1,
    COLOR_ENHANCE_UNDERLINE=2,
    COLOR_ENSURE_CONTRAST=8,
    COLOR_ENSURE_INVERTED_CONTRAST=16,
    COLOR_INCREASE_CONTRAST=4
} color_flags;

typedef struct language language, *Planguage;

struct language {
    uchar * name;
    uchar * iso639;
};

typedef enum listbox_match {
    LISTBOX_MATCH_IMPOSSIBLE=2,
    LISTBOX_MATCH_NO=1,
    LISTBOX_MATCH_OK=0
} listbox_match;

typedef enum listbox_item_type {
    BI_FOLDER=1,
    BI_LEAF=0,
    BI_SEPARATOR=2
} listbox_item_type;

typedef struct listbox_data listbox_data, *Plistbox_data;

typedef struct listbox_ops listbox_ops, *Plistbox_ops;

typedef struct listbox_item listbox_item, *Plistbox_item;

typedef struct terminal terminal, *Pterminal;

typedef struct uri uri, *Puri;

typedef struct listbox_context listbox_context, *Plistbox_context;

typedef struct list_head_elinks list_head_elinks, *Plist_head_elinks;

typedef struct option_elinks option_elinks, *Poption_elinks;

typedef struct session session, *Psession;

typedef struct terminal_screen terminal_screen, *Pterminal_screen;

typedef struct menu menu, *Pmenu;

typedef enum term_redrawing_state {
    TREDRAW_BUSY=1,
    TREDRAW_DELAYED=2,
    TREDRAW_READY=0
} term_redrawing_state;

typedef enum term_env_type {
    ENV_ANY=-1,
    ENV_BE=16,
    ENV_CONSOLE=1,
    ENV_OS2VIO=8,
    ENV_SCREEN=4,
    ENV_TWIN=32,
    ENV_WIN32=64,
    ENV_XWIN=2
} term_env_type;

typedef struct terminal_interlink terminal_interlink, *Pterminal_interlink;

typedef struct term_event_mouse term_event_mouse, *Pterm_event_mouse;

typedef struct object object, *Pobject;

typedef struct dialog_data dialog_data, *Pdialog_data;

typedef struct widget_data widget_data, *Pwidget_data;

typedef struct listbox_ops_messages listbox_ops_messages, *Plistbox_ops_messages;

typedef enum option_flags {
    OPT_ALIAS_NEGATE=256,
    OPT_ALLOC=32,
    OPT_AUTOCREATE=2,
    OPT_DELETED=128,
    OPT_HIDDEN=1,
    OPT_LISTBOX=16,
    OPT_MUST_SAVE=4,
    OPT_SORT=64,
    OPT_TOUCHED=8
} option_flags;

typedef enum option_type {
    OPT_ALIAS=8,
    OPT_BOOL=0,
    OPT_CODEPAGE=4,
    OPT_COLOR=6,
    OPT_COMMAND=7,
    OPT_INT=1,
    OPT_LANGUAGE=5,
    OPT_LONG=2,
    OPT_STRING=3,
    OPT_TREE=9
} option_type;

typedef union option_value option_value, *Poption_value;

typedef struct window window, *Pwindow;

typedef struct term_event term_event, *Pterm_event;

typedef struct ses_history ses_history, *Pses_history;

typedef struct download download, *Pdownload;

typedef enum cache_mode {
    CACHE_MODE_ALWAYS=0,
    CACHE_MODE_CHECK_IF_MODIFIED=2,
    CACHE_MODE_FORCE_RELOAD=3,
    CACHE_MODE_INCREMENT=-1,
    CACHE_MODE_NEVER=4,
    CACHE_MODE_NORMAL=1
} cache_mode;

typedef struct document_view document_view, *Pdocument_view;

typedef struct session_task session_task, *Psession_task;

typedef struct kbdprefix kbdprefix, *Pkbdprefix;

typedef struct timer timer, *Ptimer;

typedef struct timer * timer_id_T;

typedef enum insert_mode {
    INSERT_MODE_LESS=0,
    INSERT_MODE_OFF=2,
    INSERT_MODE_ON=1
} insert_mode;

typedef enum navigate_mode {
    NAVIGATE_CURSOR_ROUTING=1,
    NAVIGATE_LINKWISE=0
} navigate_mode;

typedef struct session_status session_status, *Psession_status;

typedef struct screen_char screen_char, *Pscreen_char;

typedef struct menu_item menu_item, *Pmenu_item;

typedef struct box box, *Pbox;

typedef struct anon_struct_for_utf8 anon_struct_for_utf8, *Panon_struct_for_utf8;

typedef struct dialog dialog, *Pdialog;

typedef enum widget_handler_status_T {
    EVENT_NOT_PROCESSED=1,
    EVENT_PROCESSED=0
} widget_handler_status_T;

typedef struct memory_list memory_list, *Pmemory_list;

typedef struct widget widget, *Pwidget;

typedef union anon_union_for_info anon_union_for_info, *Panon_union_for_info;

typedef enum window_type {
    WINDOW_NORMAL=0,
    WINDOW_TAB=1
} window_type;

typedef enum term_event_type {
    EVENT_ABORT=5,
    EVENT_INIT=0,
    EVENT_KBD=1,
    EVENT_MOUSE=2,
    EVENT_REDRAW=3,
    EVENT_RESIZE=4
} term_event_type;


// WARNING! conflicting data type names: /DWARF/event.h/term_event/anon_union_for_info - /DWARF/common.h/widget_data/anon_union_for_info

typedef struct location location, *Plocation;

typedef struct connection connection, *Pconnection;

typedef struct cache_entry cache_entry, *Pcache_entry;

typedef struct progress progress, *Pprogress;

typedef struct connection_state connection_state, *Pconnection_state;

typedef enum connection_priority {
    PRIORITIES=7,
    PRI_CANCEL=6,
    PRI_CSS=2,
    PRI_DOWNLOAD=0,
    PRI_FRAME=1,
    PRI_IMG=4,
    PRI_MAIN=0,
    PRI_NEED_IMG=3,
    PRI_PRELOAD=5
} connection_priority;

typedef struct document document, *Pdocument;

typedef struct view_state view_state, *Pview_state;

typedef enum task_type {
    TASK_FORWARD=1,
    TASK_HISTORY=4,
    TASK_IMGMAP=2,
    TASK_NONE=0,
    TASK_RELOAD=3
} task_type;

typedef struct anon_struct_for_target anon_struct_for_target, *Panon_struct_for_target;

typedef enum anon_enum_32_for_mark {
    KP_MARK_GOTO=2,
    KP_MARK_NOTHING=0,
    KP_MARK_SET=1
} anon_enum_32_for_mark;

typedef struct timeval_T timeval_T, *Ptimeval_T;

typedef struct led_panel led_panel, *Pled_panel;

typedef struct led led, *Pled;

typedef uint32_t unicode_val_T;

typedef enum main_action {
    ACT_MAIN_ABORT_CONNECTION=2,
    ACT_MAIN_ADD_BOOKMARK=3,
    ACT_MAIN_ADD_BOOKMARK_LINK=4,
    ACT_MAIN_ADD_BOOKMARK_TABS=5,
    ACT_MAIN_AUTH_MANAGER=6,
    ACT_MAIN_BACKSPACE_PREFIX=7,
    ACT_MAIN_BOOKMARK_MANAGER=8,
    ACT_MAIN_CACHE_MANAGER=9,
    ACT_MAIN_CACHE_MINIMIZE=10,
    ACT_MAIN_COOKIES_LOAD=12,
    ACT_MAIN_COOKIE_MANAGER=11,
    ACT_MAIN_COPY_CLIPBOARD=13,
    ACT_MAIN_DOCUMENT_INFO=14,
    ACT_MAIN_DOWNLOAD_MANAGER=15,
    ACT_MAIN_EXMODE=16,
    ACT_MAIN_FILE_MENU=17,
    ACT_MAIN_FIND_NEXT=18,
    ACT_MAIN_FIND_NEXT_BACK=19,
    ACT_MAIN_FORGET_CREDENTIALS=20,
    ACT_MAIN_FORMHIST_MANAGER=21,
    ACT_MAIN_FRAME_EXTERNAL_COMMAND=22,
    ACT_MAIN_FRAME_MAXIMIZE=23,
    ACT_MAIN_FRAME_NEXT=24,
    ACT_MAIN_FRAME_PREV=25,
    ACT_MAIN_GOTO_URL=26,
    ACT_MAIN_GOTO_URL_CURRENT=27,
    ACT_MAIN_GOTO_URL_CURRENT_LINK=28,
    ACT_MAIN_GOTO_URL_HOME=29,
    ACT_MAIN_HEADER_INFO=30,
    ACT_MAIN_HISTORY_MANAGER=31,
    ACT_MAIN_HISTORY_MOVE_BACK=32,
    ACT_MAIN_HISTORY_MOVE_FORWARD=33,
    ACT_MAIN_JUMP_TO_LINK=34,
    ACT_MAIN_KEYBINDING_MANAGER=35,
    ACT_MAIN_KILL_BACKGROUNDED_CONNECTIONS=36,
    ACT_MAIN_LINK_DOWNLOAD=37,
    ACT_MAIN_LINK_DOWNLOAD_IMAGE=38,
    ACT_MAIN_LINK_DOWNLOAD_RESUME=39,
    ACT_MAIN_LINK_EXTERNAL_COMMAND=40,
    ACT_MAIN_LINK_FOLLOW=41,
    ACT_MAIN_LINK_FOLLOW_RELOAD=42,
    ACT_MAIN_LINK_FORM_MENU=44,
    ACT_MAIN_LINK_MENU=43,
    ACT_MAIN_LUA_CONSOLE=45,
    ACT_MAIN_MARK_GOTO=46,
    ACT_MAIN_MARK_SET=47,
    ACT_MAIN_MENU=48,
    ACT_MAIN_MOVE_CURSOR_DOWN=49,
    ACT_MAIN_MOVE_CURSOR_LEFT=50,
    ACT_MAIN_MOVE_CURSOR_LINE_START=51,
    ACT_MAIN_MOVE_CURSOR_RIGHT=52,
    ACT_MAIN_MOVE_CURSOR_UP=53,
    ACT_MAIN_MOVE_DOCUMENT_END=54,
    ACT_MAIN_MOVE_DOCUMENT_START=55,
    ACT_MAIN_MOVE_LINK_DOWN=56,
    ACT_MAIN_MOVE_LINK_DOWN_LINE=57,
    ACT_MAIN_MOVE_LINK_LEFT=58,
    ACT_MAIN_MOVE_LINK_LEFT_LINE=59,
    ACT_MAIN_MOVE_LINK_NEXT=60,
    ACT_MAIN_MOVE_LINK_PREV=61,
    ACT_MAIN_MOVE_LINK_RIGHT=62,
    ACT_MAIN_MOVE_LINK_RIGHT_LINE=63,
    ACT_MAIN_MOVE_LINK_UP=64,
    ACT_MAIN_MOVE_LINK_UP_LINE=65,
    ACT_MAIN_MOVE_PAGE_DOWN=66,
    ACT_MAIN_MOVE_PAGE_UP=67,
    ACT_MAIN_NONE=0,
    ACT_MAIN_OPEN_LINK_IN_NEW_TAB=68,
    ACT_MAIN_OPEN_LINK_IN_NEW_TAB_IN_BACKGROUND=69,
    ACT_MAIN_OPEN_LINK_IN_NEW_WINDOW=70,
    ACT_MAIN_OPEN_NEW_TAB=71,
    ACT_MAIN_OPEN_NEW_TAB_IN_BACKGROUND=72,
    ACT_MAIN_OPEN_NEW_WINDOW=73,
    ACT_MAIN_OPEN_OS_SHELL=74,
    ACT_MAIN_OPTIONS_MANAGER=75,
    ACT_MAIN_QUIT=76,
    ACT_MAIN_REALLY_QUIT=77,
    ACT_MAIN_REDRAW=78,
    ACT_MAIN_RELOAD=79,
    ACT_MAIN_RERENDER=80,
    ACT_MAIN_RESET_FORM=81,
    ACT_MAIN_RESOURCE_INFO=82,
    ACT_MAIN_SAVE_AS=83,
    ACT_MAIN_SAVE_FORMATTED=84,
    ACT_MAIN_SAVE_OPTIONS=85,
    ACT_MAIN_SAVE_URL_AS=86,
    ACT_MAIN_SCRIPTING_FUNCTION=1,
    ACT_MAIN_SCROLL_DOWN=87,
    ACT_MAIN_SCROLL_LEFT=88,
    ACT_MAIN_SCROLL_RIGHT=89,
    ACT_MAIN_SCROLL_UP=90,
    ACT_MAIN_SEARCH=91,
    ACT_MAIN_SEARCH_BACK=92,
    ACT_MAIN_SEARCH_TYPEAHEAD=93,
    ACT_MAIN_SEARCH_TYPEAHEAD_LINK=94,
    ACT_MAIN_SEARCH_TYPEAHEAD_TEXT=95,
    ACT_MAIN_SEARCH_TYPEAHEAD_TEXT_BACK=96,
    ACT_MAIN_SHOW_TERM_OPTIONS=97,
    ACT_MAIN_SUBMIT_FORM=98,
    ACT_MAIN_SUBMIT_FORM_RELOAD=99,
    ACT_MAIN_TAB_CLOSE=100,
    ACT_MAIN_TAB_CLOSE_ALL_BUT_CURRENT=101,
    ACT_MAIN_TAB_EXTERNAL_COMMAND=102,
    ACT_MAIN_TAB_MENU=103,
    ACT_MAIN_TAB_MOVE_LEFT=104,
    ACT_MAIN_TAB_MOVE_RIGHT=105,
    ACT_MAIN_TAB_NEXT=106,
    ACT_MAIN_TAB_PREV=107,
    ACT_MAIN_TERMINAL_RESIZE=108,
    ACT_MAIN_TOGGLE_CSS=109,
    ACT_MAIN_TOGGLE_DISPLAY_IMAGES=110,
    ACT_MAIN_TOGGLE_DISPLAY_TABLES=111,
    ACT_MAIN_TOGGLE_DOCUMENT_COLORS=112,
    ACT_MAIN_TOGGLE_HTML_PLAIN=113,
    ACT_MAIN_TOGGLE_MOUSE=114,
    ACT_MAIN_TOGGLE_NUMBERED_LINKS=115,
    ACT_MAIN_TOGGLE_PLAIN_COMPRESS_EMPTY_LINES=116,
    ACT_MAIN_TOGGLE_WRAP_TEXT=117,
    ACT_MAIN_VIEW_IMAGE=118
} main_action;

typedef enum menu_item_flags {
    FREE_DATA=8,
    FREE_LIST=1,
    FREE_RTEXT=4,
    FREE_TEXT=2,
    MENU_FULLNAME=16,
    NO_FLAG=0,
    NO_INTL=64,
    NO_SELECT=128,
    RIGHT_INTL=256,
    SUBMENU=32
} menu_item_flags;

typedef enum hotkey_state {
    HKS_CACHED=2,
    HKS_IGNORE=1,
    HKS_SHOW=0
} hotkey_state;

typedef enum term_event_modifier_T {
    KBD_MOD_ALT=4,
    KBD_MOD_CTRL=2,
    KBD_MOD_NONE=0,
    KBD_MOD_SHIFT=1
} term_event_modifier_T;

typedef struct dialog_refresh dialog_refresh, *Pdialog_refresh;

typedef enum dlg_refresh_code {
    REFRESH_CANCEL=1,
    REFRESH_DIALOG=0,
    REFRESH_NONE=2,
    REFRESH_STOP=3
} dlg_refresh_code;

typedef struct dialog_layout dialog_layout, *Pdialog_layout;

typedef struct widget_ops widget_ops, *Pwidget_ops;


// WARNING! conflicting data type names: /DWARF/widget.h/widget/anon_union_for_info - /DWARF/common.h/widget_data/anon_union_for_info

typedef enum widget_type {
    WIDGET_BUTTON=3,
    WIDGET_CHECKBOX=0,
    WIDGET_FIELD=1,
    WIDGET_FIELD_PASS=2,
    WIDGET_LISTBOX=4,
    WIDGET_TEXT=5
} widget_type;

typedef struct widget_data_info_field widget_data_info_field, *Pwidget_data_info_field;

typedef struct widget_data_info_checkbox widget_data_info_checkbox, *Pwidget_data_info_checkbox;

typedef struct widget_data_info_text widget_data_info_text, *Pwidget_data_info_text;

typedef __off64_t off_t;

typedef enum stream_encoding {
    ENCODINGS_KNOWN=5,
    ENCODING_BZIP2=2,
    ENCODING_DEFLATE=4,
    ENCODING_GZIP=1,
    ENCODING_LZMA=3,
    ENCODING_NONE=0
} stream_encoding;

typedef struct stream_encoded stream_encoded, *Pstream_encoded;

typedef struct socket socket, *Psocket;

typedef struct read_buffer read_buffer, *Pread_buffer;

typedef __time_t time_t;

typedef enum connection_basic_state {
    S_BAD_URL=-100009,
    S_BITTORRENT_BAD_URL=-100803,
    S_BITTORRENT_ERROR=-100800,
    S_BITTORRENT_METAINFO=-100801,
    S_BITTORRENT_PEER_URL=-100804,
    S_BITTORRENT_TRACKER=-100802,
    S_CANT_READ=-100007,
    S_CANT_WRITE=-100006,
    S_CONN=2,
    S_CONN_PEERS=10,
    S_CONN_TRACKER=11,
    S_DNS=1,
    S_ENCODE_ERROR=-100017,
    S_ERRNO=-1,
    S_EXCEPT=-100002,
    S_EXTERNAL_PROTOCOL=-100016,
    S_FILE_ANONYMOUS=-100203,
    S_FILE_CGI_BAD_PATH=-100202,
    S_FILE_ERROR=-100201,
    S_FILE_TYPE=-100200,
    S_FSP_OPEN_SESSION_UNKN=-100900,
    S_FTP_ERROR=-100300,
    S_FTP_FILE_ERROR=-100305,
    S_FTP_LOGIN=-100302,
    S_FTP_NO_FILE=-100304,
    S_FTP_PORT=-100303,
    S_FTP_UNAVAIL=-100301,
    S_GETH=6,
    S_GOPHER_CSO_ERROR=-100500,
    S_HTTP_204=-100101,
    S_HTTP_ERROR=-100100,
    S_INTERNAL=-100003,
    S_INTERRUPTED=-100001,
    S_LOCAL_ONLY=-100014,
    S_LOGIN=5,
    S_MODIFIED=-100008,
    S_NNTP_ACCESS_DENIED=-100407,
    S_NNTP_ARTICLE_UNKNOWN=-100404,
    S_NNTP_AUTH_REQUIRED=-100406,
    S_NNTP_ERROR=-100400,
    S_NNTP_GROUP_UNKNOWN=-100403,
    S_NNTP_NEWS_SERVER=-100401,
    S_NNTP_SERVER_ERROR=-100408,
    S_NNTP_SERVER_HANG_UP=-100402,
    S_NNTP_TRANSFER_ERROR=-100405,
    S_NO_DNS=-100005,
    S_NO_FORCED_DNS=-100019,
    S_NO_JAVASCRIPT=-100600,
    S_OK=-100000,
    S_OUT_OF_MEM=-100004,
    S_PROC=7,
    S_PROXY_ERROR=-100700,
    S_QUESTIONS=9,
    S_RESTART=-100011,
    S_RESUME=12,
    S_SENT=4,
    S_SSL_ERROR=-100018,
    S_SSL_NEG=3,
    S_STATE=-100012,
    S_TIMEOUT=-100010,
    S_TRANS=8,
    S_UNKNOWN_PROTOCOL=-100015,
    S_WAIT=0,
    S_WAIT_REDIR=-100013
} connection_basic_state;

typedef struct document_options document_options, *Pdocument_options;

typedef struct uri_list uri_list, *Puri_list;

typedef struct frame_desc frame_desc, *Pframe_desc;

typedef struct frameset_desc frameset_desc, *Pframeset_desc;

typedef struct document_refresh document_refresh, *Pdocument_refresh;

typedef struct line line, *Pline;

typedef struct link link, *Plink;

typedef struct search search, *Psearch;

typedef enum cp_status {
    CP_STATUS_ASSUMED=2,
    CP_STATUS_IGNORED=3,
    CP_STATUS_NONE=0,
    CP_STATUS_SERVER=1
} cp_status;

typedef struct form_state form_state, *Pform_state;

typedef struct input_history_entry input_history_entry, *Pinput_history_entry;

typedef enum socket_state {
    SOCKET_CLOSED=2,
    SOCKET_END_ONCLOSE=1,
    SOCKET_RETRY_ONCLOSE=0
} socket_state;

typedef struct connect_info connect_info, *Pconnect_info;

typedef struct socket_operations socket_operations, *Psocket_operations;

typedef struct text_style text_style, *Ptext_style;

typedef struct active_link_options active_link_options, *Pactive_link_options;

typedef struct anon_struct_for_image_link anon_struct_for_image_link, *Panon_struct_for_image_link;

typedef enum link_type {
    LINK_AREA=6,
    LINK_BUTTON=2,
    LINK_CHECKBOX=3,
    LINK_FIELD=5,
    LINK_HYPERTEXT=0,
    LINK_MAP=1,
    LINK_SELECT=4
} link_type;

typedef struct point point, *Ppoint;

typedef struct color_pair color_pair, *Pcolor_pair;

typedef union anon_union_for_data anon_union_for_data, *Panon_union_for_data;

typedef struct form_view form_view, *Pform_view;

typedef enum form_type {
    FC_BUTTON=10,
    FC_CHECKBOX=4,
    FC_FILE=2,
    FC_HIDDEN=11,
    FC_IMAGE=8,
    FC_PASSWORD=1,
    FC_RADIO=5,
    FC_RESET=9,
    FC_SELECT=6,
    FC_SUBMIT=7,
    FC_TEXT=0,
    FC_TEXTAREA=3
} form_type;

typedef struct sockaddr_storage sockaddr_storage, *Psockaddr_storage;

typedef void (* socket_connect_T)(struct socket *);

typedef enum text_style_format {
    AT_BOLD=1,
    AT_FIXED=8,
    AT_GRAPHICS=16,
    AT_ITALIC=2,
    AT_PREFORMATTED=32,
    AT_UNDERLINE=4
} text_style_format;

typedef struct form_control form_control, *Pform_control;

typedef struct form form, *Pform;

typedef enum form_mode {
    FORM_MODE_DISABLED=2,
    FORM_MODE_NORMAL=0,
    FORM_MODE_READONLY=1
} form_mode;

typedef enum form_wrap {
    FORM_WRAP_HARD=2,
    FORM_WRAP_NONE=0,
    FORM_WRAP_SOFT=1
} form_wrap;

typedef enum form_method {
    FORM_METHOD_GET=0,
    FORM_METHOD_POST=1,
    FORM_METHOD_POST_MP=2,
    FORM_METHOD_POST_TEXT_PLAIN=3
} form_method;

struct widget_ops {
    widget_handler_status_T (* display)(struct dialog_data *, struct widget_data *);
    widget_handler_status_T (* init)(struct dialog_data *, struct widget_data *);
    widget_handler_status_T (* mouse)(struct dialog_data *, struct widget_data *);
    widget_handler_status_T (* kbd)(struct dialog_data *, struct widget_data *);
    widget_handler_status_T (* select)(struct dialog_data *, struct widget_data *);
    widget_handler_status_T (* clear)(struct dialog_data *, struct widget_data *);
};

union anon_union_for_data {
    uchar * name;
    struct form_control * form_control;
};

struct list_head_elinks {
    void * next;
    void * prev;
};

struct widget_data_info_field {
    int vpos;
    int cpos;
    struct list_head_elinks history;
    struct input_history_entry * cur_hist;
};

struct widget_data_info_checkbox {
    int checked;
};

struct widget_data_info_text {
    int current;
    int lines;
    int max_width;
    int scroller_height;
    int scroller_y;
    int scroller_last_dir;
};

union anon_union_for_info {
    struct widget_data_info_field field;
    struct widget_data_info_checkbox checkbox;
    struct widget_data_info_text text;
};

struct terminal_screen {
    struct screen_char * image;
    struct screen_char * last_image;
    int cx;
    int cy;
    int lcx;
    int lcy;
    int dirty_from;
    int dirty_to;
};

struct menu_item {
    uchar * text;
    uchar * rtext;
    enum main_action action_id;
    void (* func)(struct terminal *, void *, void *);
    void * data;
    enum menu_item_flags flags;
    enum hotkey_state hotkey_state;
    int hotkey_pos;
};

struct read_buffer {
    void (* done)(struct socket *, struct read_buffer *);
    int length;
    int freespace;
    uchar data[1];
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
};

struct led {
    uint used__:1;
    uint value_changed__:1;
    uint value__:8;
    undefined field_0x2;
    undefined field_0x3;
};

struct memory_list {
    int n;
    void * p[1];
};

struct connection_state {
    enum connection_basic_state basic;
    int syserr;
};

struct download {
    struct download * next;
    struct download * prev;
    struct connection * conn;
    struct cache_entry * cached;
    void (* callback)(struct download *, void *);
    void * data;
    struct progress * progress;
    struct connection_state state;
    struct connection_state prev_error;
    enum connection_priority pri;
};

struct anon_struct_for_target {
    uchar * frame;
    struct location * location;
};

struct session_task {
    enum task_type type;
    struct anon_struct_for_target target;
};

struct view_state {
    struct document_view * doc_view;
    struct uri * uri;
    struct list_head_elinks forms;
    struct form_state * form_info;
    int form_info_len;
    int x;
    int y;
    int current_link;
    int old_current_link;
    int plain;
    uint wrap:1;
    uint did_fragment:1;
    undefined field_0x2d;
    undefined field_0x2e;
    undefined field_0x2f;
};

struct connection {
    struct connection * next;
    struct connection * prev;
    struct list_head_elinks downloads;
    struct progress * progress;
    struct uri * uri;
    struct uri * proxied_uri;
    struct uri * referrer;
    enum cache_mode cache_mode;
    struct cache_entry * cached;
    off_t from;
    off_t received;
    off_t est_length;
    enum stream_encoding content_encoding;
    struct stream_encoded * stream;
    void (* done)(struct connection *);
    uint id;
    struct connection_state state;
    struct connection_state prev_error;
    struct socket * socket;
    struct socket * data_socket;
    int tries;
    timer_id_T timer;
    int stream_pipes[2];
    uint running:1;
    uint unrestartable:1;
    uint detached:1;
    uint cgi:1;
    undefined field_0x79;
    undefined field_0x7a;
    undefined field_0x7b;
    int pri[7];
    void * info;
};

struct anon_struct_for_utf8 {
    unicode_val_T ucs;
    int len;
    unicode_val_T min;
    enum term_event_modifier_T modifier;
};

struct terminal_interlink {
    int qlen;
    int qfreespace;
    struct anon_struct_for_utf8 utf8;
    uchar input_queue[1];
    undefined field_0x19;
    undefined field_0x1a;
    undefined field_0x1b;
};

struct uri_list {
    int size;
    struct uri * * uris;
};

struct led_panel {
    struct led leds[6];
};

struct session_status {
    uint show_tabs_bar:1;
    uint show_status_bar:1;
    uint show_title_bar:1;
    int force_show_status_bar:2;
    int force_show_title_bar:2;
    uint set_window_title:1;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    uchar * last_title;
    uint show_leds:1;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    struct led_panel leds;
    struct led * ssl_led;
    struct led * insert_mode_led;
    struct led * ecmascript_led;
    struct led * popup_led;
    uint visited:1;
    uint processing_file_requests:1;
    uint show_tabs_bar_at_top:1;
    undefined field_0x35;
    undefined field_0x36;
    undefined field_0x37;
};

struct timeval_T {
    long sec;
    long usec;
};

struct object {
    int refcount;
};

struct cache_entry {
    struct cache_entry * next;
    struct cache_entry * prev;
    struct object object;
    struct list_head_elinks frag;
    struct uri * uri;
    struct uri * proxy_uri;
    struct uri * redirect;
    uchar * head;
    uchar * content_type;
    uchar * last_modified;
    uchar * etag;
    uchar * ssl_info;
    uchar * encoding_info;
    uint cache_id;
    time_t seconds;
    off_t length;
    off_t data_size;
    struct listbox_item * box_item;
    struct timeval_T max_age;
    uint expire:1;
    uint preformatted:1;
    uint redirect_get:1;
    uint incomplete:1;
    uint valid:1;
    uint gc_target:1;
    uint cgi:1;
    undefined field_0x5d;
    undefined field_0x5e;
    undefined field_0x5f;
    enum cache_mode cache_mode;
};

struct form_view {
    struct form_view * next;
    struct form_view * prev;
    int form_num;
};

struct anon_struct_for_image_link {
    uchar * prefix;
    uchar * suffix;
    int filename_maxlen;
    int label_maxlen;
    int display_style;
    int tagging;
    uint show_any_as_links:1;
    undefined field_0x19;
    undefined field_0x1a;
    undefined field_0x1b;
};

struct box {
    int x;
    int y;
    int width;
    int height;
};

struct widget_data {
    struct widget * widget;
    uchar * cdata;
    struct box box;
    union anon_union_for_info info;
};

struct dialog_data {
    struct window * win;
    struct dialog * dlg;
    struct memory_list * ml;
    struct box box;
    int number_of_widgets;
    int selected_widget_id;
    struct term_event * term_event;
    struct widget_data widgets_data[1];
};

struct dialog_refresh {
    dlg_refresh_code (* handler)(struct dialog_data *, void *);
    void * data;
    timer_id_T timer;
};

struct frame_desc {
    struct frameset_desc * subframe;
    uchar * name;
    struct uri * uri;
    int width;
    int height;
};

struct frameset_desc {
    int n;
    struct box box;
    struct frame_desc frame_desc[1];
};

struct screen_char {
    unicode_val_T data;
    uchar attr;
    uchar color[2];
    undefined field_0x7;
};

struct sockaddr_storage {
    sa_family_t ss_family;
    undefined field_0x2;
    undefined field_0x3;
    ulong __ss_align;
    char __ss_padding[120];
};

struct active_link_options {
    uint color:1;
    uint underline:1;
    uint bold:1;
    uint invert:1;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    color_T fg;
    color_T bg;
};

struct text_style {
    enum text_style_format attr;
    color_T fg;
    color_T bg;
};

struct document_options {
    enum color_mode color_mode;
    int cp;
    int assume_cp;
    int hard_assume;
    int margin;
    int num_links_key;
    int use_document_colors;
    int meta_link_display;
    int default_form_input_size;
    struct text_style default_style;
    color_T default_link;
    color_T default_vlink;
    color_T default_bookmark_link;
    color_T default_image_link;
    enum color_flags color_flags;
    uint css_enable:1;
    uint css_import:1;
    uint tables:1;
    uint table_order:1;
    uint frames:1;
    uint images:1;
    uint display_subs:1;
    uint display_sups:1;
    uint underline_links:1;
    uint wrap_nbsp:1;
    uint plain_display_links:1;
    uint plain_compress_empty_lines:1;
    uint links_numbering:1;
    uint use_tabindex:1;
    uint plain:1;
    uint wrap:1;
    undefined field_0x46;
    undefined field_0x47;
    uchar * framename;
    struct box box;
    uint needs_height:1;
    uint needs_width:1;
    uint no_cache:1;
    uint gradual_rerendering:1;
    uint utf8:1;
    undefined field_0x5d;
    undefined field_0x5e;
    undefined field_0x5f;
    struct active_link_options active_link;
    struct anon_struct_for_image_link image_link;
};

struct form_state {
    struct form_view * form_view;
    int g_ctrl_num;
    int position;
    enum form_type type;
    uchar * value;
    int state;
    int state_cell;
    int vpos;
    int vypos;
};

struct dialog_layout {
    uint maximize_width:1;
    uint padding_top:1;
    uint fit_datalen:1;
    uint float_groups:1;
    uint only_widgets:1;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
};

struct stream_encoded {
    enum stream_encoding encoding;
    void * data;
};

struct document_refresh {
    timer_id_T timer;
    ulong seconds;
    struct uri * uri;
    uint restart:1;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
};

struct widget {
    struct widget_ops * ops;
    uchar * text;
    widget_handler_status_T (* handler)(struct dialog_data *, struct widget_data *);
    void * data;
    int datalen;
    union anon_union_for_info info;
    enum widget_type type;
};

struct kbdprefix {
    int repeat_count;
    enum anon_enum_32_for_mark mark;
};

struct ses_history {
    struct list_head_elinks history;
    struct location * current;
};

struct session {
    struct session * next;
    struct session * prev;
    struct window * tab;
    struct ses_history history;
    struct list_head_elinks more_files;
    struct download loading;
    struct uri * loading_uri;
    enum cache_mode reloadlevel;
    int redirect_cnt;
    struct document_view * doc_view;
    struct list_head_elinks scrn_frames;
    struct uri * download_uri;
    struct uri * referrer;
    struct session_task task;
    int search_direction;
    struct kbdprefix kbdprefix;
    int exit_query;
    timer_id_T display_timer;
    enum insert_mode insert_mode;
    enum navigate_mode navigate_mode;
    uchar * search_word;
    uchar * last_search_word;
    struct list_head_elinks type_queries;
    struct session_status status;
};

struct line {
    struct screen_char * chars;
    int length;
};

struct document {
    struct document * next;
    struct document * prev;
    struct object object;
    struct document_options options;
    struct list_head_elinks forms;
    struct list_head_elinks tags;
    struct list_head_elinks nodes;
    struct uri_list css_imports;
    ulong css_magic;
    struct uri * uri;
    uchar * title;
    struct cache_entry * cached;
    struct frame_desc * frame;
    struct frameset_desc * frame_desc;
    struct document_refresh * refresh;
    struct line * data;
    struct link * links;
    struct link * * lines1;
    struct link * * lines2;
    struct search * search;
    struct search * * slines1;
    struct search * * slines2;
    uchar buf[7];
    uchar buf_length;
    uint cache_id;
    int cp;
    int width;
    int height;
    int nlinks;
    int nsearch;
    color_T bgcolor;
    enum cp_status cp_status;
    uint links_sorted:1;
    undefined field_0x115;
    undefined field_0x116;
    undefined field_0x117;
};

struct color_pair {
    color_T background;
    color_T foreground;
};

struct link {
    unicode_val_T accesskey;
    enum link_type type;
    uchar * where;
    uchar * target;
    uchar * where_img;
    uchar * title;
    struct point * points;
    int npoints;
    int number;
    struct color_pair color;
    struct list_head_elinks * event_hooks;
    union anon_union_for_data data;
};

struct listbox_data {
    struct listbox_data * next;
    struct listbox_data * prev;
    struct listbox_ops * ops;
    struct listbox_item * sel;
    struct listbox_item * top;
    int sel_offset;
    struct list_head_elinks * items;
};

struct document_view {
    struct document_view * next;
    struct document_view * prev;
    uchar * name;
    uchar * * search_word;
    struct session * session;
    struct document * document;
    struct view_state * vs;
    struct box box;
    int last_x;
    int last_y;
    int depth;
    int used;
};

struct point {
    int x;
    int y;
};

struct timer {
    struct timer * next;
    struct timer * prev;
    struct timeval_T interval;
    void (* func)(void *);
    void * data;
};

struct dialog {
    uchar * title;
    void * udata;
    void * udata2;
    struct dialog_refresh * refresh;
    void (* layouter)(struct dialog_data *);
    widget_handler_status_T (* handle_event)(struct dialog_data *);
    void (* abort)(struct dialog_data *);
    struct dialog_layout layout;
    int number_of_widgets;
    struct widget widgets[1];
};

struct socket_operations {
    void (* set_state)(struct socket *, struct connection_state);
    void (* set_timeout)(struct socket *, struct connection_state);
    void (* retry)(struct socket *, struct connection_state);
    void (* done)(struct socket *, struct connection_state);
};

struct listbox_item {
    struct listbox_item * next;
    struct listbox_item * prev;
    struct list_head_elinks child;
    enum listbox_item_type type;
    int depth;
    uint expanded:1;
    uint visible:1;
    uint marked:1;
    undefined field_0x19;
    undefined field_0x1a;
    undefined field_0x1b;
    void * udata;
};

struct search {
    int x;
    int y;
    int n;
    unicode_val_T c;
};

struct listbox_ops {
    void (* lock)(struct listbox_item *);
    void (* unlock)(struct listbox_item *);
    int (* is_used)(struct listbox_item *);
    uchar * (* get_text)(struct listbox_item *, struct terminal *);
    uchar * (* get_info)(struct listbox_item *, struct terminal *);
    uri * (* get_uri)(struct listbox_item *);
    listbox_item * (* get_root)(struct listbox_item *);
    listbox_match (* match)(struct listbox_item *, struct terminal *, uchar *);
    int (* can_delete)(struct listbox_item *);
    void (* delete)(struct listbox_item *, int);
    void (* draw)(struct listbox_item *, struct listbox_context *, int, int, int);
    struct listbox_ops_messages * messages;
};

struct input_history_entry {
    struct input_history_entry * next;
    struct input_history_entry * prev;
    uchar data[1];
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
};

union option_value {
    struct list_head_elinks * tree;
    int number;
    long big_number;
    color_T color;
    uchar * (* command)(struct option_elinks *, uchar * * *, int *);
    uchar * string;
};

struct option_elinks {
    struct option_elinks * next;
    struct option_elinks * prev;
    struct object object;
    uchar * name;
    enum option_flags flags;
    enum option_type type;
    long min;
    long max;
    union option_value value;
    uchar * desc;
    uchar * capt;
    struct option_elinks * root;
    int (* change_hook)(struct session *, struct option_elinks *, struct option_elinks *);
    struct listbox_item * box_item;
};

struct term_event_mouse {
    int x;
    int y;
    uint button;
};

struct terminal {
    struct terminal * next;
    struct terminal * prev;
    struct list_head_elinks windows;
    struct option_elinks * spec;
    uchar * title;
    struct terminal_screen * screen;
    struct menu * main_menu;
    int fdin;
    int fdout;
    int blocked;
    int width;
    int height;
    enum term_redrawing_state redrawing;
    uint master:1;
    uint utf8_cp:1;
    uint utf8_io:1;
    undefined field_0x39;
    undefined field_0x3a;
    undefined field_0x3b;
    int current_tab;
    int leds_length;
    enum term_env_type environment;
    uchar cwd[256];
    struct terminal_interlink * interlink;
    struct term_event_mouse prev_mouse_event;
};

struct menu {
    struct window * win;
    struct menu_item * items;
    int size;
    int selected;
    int first;
    int last;
    struct box box;
    int parent_x;
    int parent_y;
    int hotkeys;
    int lang;
    void * data;
};

struct uri {
    uchar * string;
    int protocol;
    int ip_family;
    uchar * user;
    uchar * password;
    uchar * host;
    uchar * port;
    uchar * data;
    uchar * fragment;
    uchar * post;
    uint protocollen:16;
    uint userlen:16;
    uint passwordlen:16;
    uint hostlen:16;
    uint portlen:8;
    uint datalen:16;
    undefined field_0x33;
    uint fragmentlen:16;
    uint ipv6:1;
    uint form:1;
    undefined field_0x37;
    struct object object;
};

struct listbox_ops_messages {
    uchar * cant_delete_item;
    uchar * cant_delete_used_item;
    uchar * cant_delete_folder;
    uchar * cant_delete_used_folder;
    uchar * delete_marked_items_title;
    uchar * delete_marked_items;
    uchar * delete_folder_title;
    uchar * delete_folder;
    uchar * delete_item_title;
    uchar * delete_item;
    uchar * clear_all_items_title;
    uchar * clear_all_items;
};

struct term_event {
    enum term_event_type ev;
    union anon_union_for_info info;
};

struct form_control {
    struct form_control * next;
    struct form_control * prev;
    struct form * form;
    int g_ctrl_num;
    int position;
    enum form_type type;
    enum form_mode mode;
    uchar * id;
    uchar * name;
    uchar * alt;
    uchar * default_value;
    int default_state;
    int size;
    int cols;
    int rows;
    enum form_wrap wrap;
    int maxlength;
    int nvalues;
    uchar * * values;
    uchar * * labels;
    struct menu_item * menu;
};

struct connect_info {
    struct sockaddr_storage * addr;
    int addrno;
    int triedno;
    socket_connect_T done;
    void * dnsquery;
    int port;
    int ip_family;
    struct uri * uri;
};

struct form {
    struct form * next;
    struct form * prev;
    int form_num;
    int form_end;
    uchar * action;
    uchar * name;
    uchar * onsubmit;
    uchar * target;
    enum form_method method;
    struct list_head_elinks items;
};

struct progress {
    struct timeval_T elapsed;
    struct timeval_T last_time;
    struct timeval_T dis_b;
    struct timeval_T estimated_time;
    int average_speed;
    int current_speed;
    uint valid:1;
    undefined field_0x29;
    undefined field_0x2a;
    undefined field_0x2b;
    off_t size;
    off_t loaded;
    off_t last_loaded;
    off_t cur_loaded;
    off_t start;
    off_t pos;
    off_t seek;
    timer_id_T timer;
    void (* timer_func)(void *);
    void * timer_func_data;
    int data_in_secs[50];
};

struct location {
    struct location * next;
    struct location * prev;
    struct list_head_elinks frames;
    struct download download;
    struct view_state vs;
};

struct window {
    struct window * next;
    struct window * prev;
    enum window_type type;
    void (* handler)(struct window *, struct term_event *);
    void * data;
    struct terminal * term;
    int xpos;
    int width;
    int x;
    int y;
    uint resize:1;
    undefined field_0x29;
    undefined field_0x2a;
    undefined field_0x2b;
};

struct socket {
    int fd;
    enum socket_state state;
    void * conn;
    struct connect_info * connect_info;
    struct read_buffer * read_buffer;
    void * write_buffer;
    struct socket_operations * ops;
    void (* read_done)(struct socket *, struct read_buffer *);
    void * ssl;
    uint protocol_family:1;
    uint need_ssl:1;
    uint no_tls:1;
    uint set_no_tls:1;
    uint duplex:1;
    undefined field_0x25;
    undefined field_0x26;
    undefined field_0x27;
};

struct listbox_context {
    struct terminal * term;
    struct listbox_item * item;
    struct listbox_data * box;
    struct dialog_data * dlg_data;
    struct widget_data * widget_data;
    int dist;
    int offset;
};

typedef struct screen_state screen_state, *Pscreen_state;

struct screen_state {
    uchar border;
    uchar underline;
    uchar bold;
    uchar attr;
    uchar color[2];
};

typedef struct screen_driver_opt screen_driver_opt, *Pscreen_driver_opt;


// WARNING! conflicting data type names: /DWARF/string.h/string - /string

struct screen_driver_opt {
    int charsets[2];
    uchar * frame;
    struct string * frame_seqs;
    struct string * underline;
    enum color_mode color_mode;
    uint transparent:1;
    uint utf8_cp:1;
    undefined field_0x19;
    undefined field_0x1a;
    undefined field_0x1b;
};

typedef struct screen_driver screen_driver, *Pscreen_driver;

typedef enum term_mode_type {
    TERM_DUMB=0,
    TERM_FREEBSD=4,
    TERM_KOI8=3,
    TERM_LINUX=2,
    TERM_VT100=1
} term_mode_type;

struct screen_driver {
    struct screen_driver * next;
    struct screen_driver * prev;
    enum term_mode_type type;
    struct screen_driver_opt opt;
    uchar name[1];
    undefined field_0x29;
    undefined field_0x2a;
    undefined field_0x2b;
};

typedef uint uint_least32_t;

typedef uint_least32_t globus_uint_t;

typedef globus_uint_t OM_uint32;

typedef struct gss_ctx_id_desc_struct gss_ctx_id_desc_struct, *Pgss_ctx_id_desc_struct;

typedef struct gss_ctx_id_desc_struct * gss_ctx_id_t;

struct gss_ctx_id_desc_struct {
};

typedef struct gss_OID_desc_struct gss_OID_desc_struct, *Pgss_OID_desc_struct;

typedef struct gss_OID_desc_struct * gss_OID;

struct gss_OID_desc_struct {
    OM_uint32 length;
    void * elements;
};

typedef struct gss_name_desc_struct gss_name_desc_struct, *Pgss_name_desc_struct;

typedef struct gss_name_desc_struct * gss_name_t;

struct gss_name_desc_struct {
};

typedef struct gss_buffer_desc_struct gss_buffer_desc_struct, *Pgss_buffer_desc_struct;


// WARNING! conflicting data type names: /DWARF/stddef.h/size_t - /stddef.h/size_t

struct gss_buffer_desc_struct {
    size_t length;
    void * value;
};

typedef struct gss_buffer_desc_struct gss_buffer_desc;

typedef struct gss_channel_bindings_struct gss_channel_bindings_struct, *Pgss_channel_bindings_struct;

struct gss_channel_bindings_struct {
    OM_uint32 initiator_addrtype;
    gss_buffer_desc initiator_address;
    OM_uint32 acceptor_addrtype;
    gss_buffer_desc acceptor_address;
    gss_buffer_desc application_data;
};

typedef char * __gnuc_va_list;

typedef enum docbook_attribute_type {
    DOCBOOK_ATTRIBUTES=145,
    DOCBOOK_ATTRIBUTE_ABBR=1,
    DOCBOOK_ATTRIBUTE_ACTION=2,
    DOCBOOK_ATTRIBUTE_ALIGN=3,
    DOCBOOK_ATTRIBUTE_APPLICATION=4,
    DOCBOOK_ATTRIBUTE_ARCH=5,
    DOCBOOK_ATTRIBUTE_AREAREFS=6,
    DOCBOOK_ATTRIBUTE_AUDIENCE=7,
    DOCBOOK_ATTRIBUTE_AXIS=8,
    DOCBOOK_ATTRIBUTE_BASEFORM=9,
    DOCBOOK_ATTRIBUTE_BGCOLOR=10,
    DOCBOOK_ATTRIBUTE_BORDER=11,
    DOCBOOK_ATTRIBUTE_CELLSPACING=12,
    DOCBOOK_ATTRIBUTE_CHAR=13,
    DOCBOOK_ATTRIBUTE_CHAROFF=14,
    DOCBOOK_ATTRIBUTE_CHOICE=15,
    DOCBOOK_ATTRIBUTE_CLASS=16,
    DOCBOOK_ATTRIBUTE_CMDLENGTH=17,
    DOCBOOK_ATTRIBUTE_COLNAME=18,
    DOCBOOK_ATTRIBUTE_COLNUM=19,
    DOCBOOK_ATTRIBUTE_COLNUMS=20,
    DOCBOOK_ATTRIBUTE_COLS=21,
    DOCBOOK_ATTRIBUTE_COLSEP=22,
    DOCBOOK_ATTRIBUTE_COLSPAN=23,
    DOCBOOK_ATTRIBUTE_COLWIDTH=24,
    DOCBOOK_ATTRIBUTE_CONDITION=25,
    DOCBOOK_ATTRIBUTE_CONFORMANCE=26,
    DOCBOOK_ATTRIBUTE_CONTENTDEPTH=27,
    DOCBOOK_ATTRIBUTE_CONTENTS=28,
    DOCBOOK_ATTRIBUTE_CONTENTWIDTH=29,
    DOCBOOK_ATTRIBUTE_CONTINUATION=30,
    DOCBOOK_ATTRIBUTE_COORDS=31,
    DOCBOOK_ATTRIBUTE_DEF=32,
    DOCBOOK_ATTRIBUTE_DEFAULTLABEL=33,
    DOCBOOK_ATTRIBUTE_DEPTH=34,
    DOCBOOK_ATTRIBUTE_ENCODING=35,
    DOCBOOK_ATTRIBUTE_ENDTERM=36,
    DOCBOOK_ATTRIBUTE_ENTITYREF=37,
    DOCBOOK_ATTRIBUTE_FILEREF=38,
    DOCBOOK_ATTRIBUTE_FLOAT=39,
    DOCBOOK_ATTRIBUTE_FLOATSTYLE=40,
    DOCBOOK_ATTRIBUTE_FORMAT=41,
    DOCBOOK_ATTRIBUTE_FPI=42,
    DOCBOOK_ATTRIBUTE_FRAME=43,
    DOCBOOK_ATTRIBUTE_FUNCTION=44,
    DOCBOOK_ATTRIBUTE_HEADERS=45,
    DOCBOOK_ATTRIBUTE_HEIGHT=46,
    DOCBOOK_ATTRIBUTE_ID=47,
    DOCBOOK_ATTRIBUTE_INHERITNUM=48,
    DOCBOOK_ATTRIBUTE_LABEL=49,
    DOCBOOK_ATTRIBUTE_LANG=50,
    DOCBOOK_ATTRIBUTE_LANGUAGE=51,
    DOCBOOK_ATTRIBUTE_LEVEL=52,
    DOCBOOK_ATTRIBUTE_LINENUMBERING=53,
    DOCBOOK_ATTRIBUTE_LINKEND=54,
    DOCBOOK_ATTRIBUTE_LINKENDS=55,
    DOCBOOK_ATTRIBUTE_LINKMODE=56,
    DOCBOOK_ATTRIBUTE_LOCALINFO=57,
    DOCBOOK_ATTRIBUTE_MARK=58,
    DOCBOOK_ATTRIBUTE_MOREINFO=59,
    DOCBOOK_ATTRIBUTE_MOREROWS=60,
    DOCBOOK_ATTRIBUTE_NAMEEND=61,
    DOCBOOK_ATTRIBUTE_NAMESPACE=62,
    DOCBOOK_ATTRIBUTE_NAMEST=63,
    DOCBOOK_ATTRIBUTE_NOWRAP=64,
    DOCBOOK_ATTRIBUTE_NUMERATION=65,
    DOCBOOK_ATTRIBUTE_ONCLICK=66,
    DOCBOOK_ATTRIBUTE_ONDBLCLICK=67,
    DOCBOOK_ATTRIBUTE_ONKEYDOWN=68,
    DOCBOOK_ATTRIBUTE_ONKEYPRESS=69,
    DOCBOOK_ATTRIBUTE_ONKEYUP=70,
    DOCBOOK_ATTRIBUTE_ONMOUSEDOWN=71,
    DOCBOOK_ATTRIBUTE_ONMOUSEMOVE=72,
    DOCBOOK_ATTRIBUTE_ONMOUSEOUT=73,
    DOCBOOK_ATTRIBUTE_ONMOUSEOVER=74,
    DOCBOOK_ATTRIBUTE_ONMOUSEUP=75,
    DOCBOOK_ATTRIBUTE_ORIENT=76,
    DOCBOOK_ATTRIBUTE_ORIGIN=77,
    DOCBOOK_ATTRIBUTE_OS=78,
    DOCBOOK_ATTRIBUTE_OTHERACTION=79,
    DOCBOOK_ATTRIBUTE_OTHERCLASS=80,
    DOCBOOK_ATTRIBUTE_OTHERFUNCTION=81,
    DOCBOOK_ATTRIBUTE_OTHERSPATIAL=82,
    DOCBOOK_ATTRIBUTE_OTHERTEMPORAL=83,
    DOCBOOK_ATTRIBUTE_OTHERTERM=84,
    DOCBOOK_ATTRIBUTE_OTHERTYPE=85,
    DOCBOOK_ATTRIBUTE_OTHERUNITS=86,
    DOCBOOK_ATTRIBUTE_OVERRIDE=87,
    DOCBOOK_ATTRIBUTE_PAGENUM=88,
    DOCBOOK_ATTRIBUTE_PARENTBOOK=89,
    DOCBOOK_ATTRIBUTE_PATH=90,
    DOCBOOK_ATTRIBUTE_PERFORMANCE=91,
    DOCBOOK_ATTRIBUTE_PGWIDE=92,
    DOCBOOK_ATTRIBUTE_PUBWORK=93,
    DOCBOOK_ATTRIBUTE_RELATION=94,
    DOCBOOK_ATTRIBUTE_REMAP=95,
    DOCBOOK_ATTRIBUTE_RENDERAS=96,
    DOCBOOK_ATTRIBUTE_REP=97,
    DOCBOOK_ATTRIBUTE_REVISION=98,
    DOCBOOK_ATTRIBUTE_REVISIONFLAG=99,
    DOCBOOK_ATTRIBUTE_ROLE=100,
    DOCBOOK_ATTRIBUTE_ROTATE=101,
    DOCBOOK_ATTRIBUTE_ROWSEP=102,
    DOCBOOK_ATTRIBUTE_ROWSPAN=103,
    DOCBOOK_ATTRIBUTE_RULES=104,
    DOCBOOK_ATTRIBUTE_SCALE=105,
    DOCBOOK_ATTRIBUTE_SCALEFIT=106,
    DOCBOOK_ATTRIBUTE_SCHEME=107,
    DOCBOOK_ATTRIBUTE_SCOPE=108,
    DOCBOOK_ATTRIBUTE_SECURITY=109,
    DOCBOOK_ATTRIBUTE_SEPCHAR=110,
    DOCBOOK_ATTRIBUTE_SHORTENTRY=111,
    DOCBOOK_ATTRIBUTE_SIGNIFICANCE=112,
    DOCBOOK_ATTRIBUTE_SORTAS=113,
    DOCBOOK_ATTRIBUTE_SPACING=114,
    DOCBOOK_ATTRIBUTE_SPAN=115,
    DOCBOOK_ATTRIBUTE_SPANNAME=116,
    DOCBOOK_ATTRIBUTE_SPATIAL=117,
    DOCBOOK_ATTRIBUTE_SRCCREDIT=118,
    DOCBOOK_ATTRIBUTE_STARTINGLINENUMBER=119,
    DOCBOOK_ATTRIBUTE_STARTREF=120,
    DOCBOOK_ATTRIBUTE_STATUS=121,
    DOCBOOK_ATTRIBUTE_STYLE=122,
    DOCBOOK_ATTRIBUTE_SUBJECT=123,
    DOCBOOK_ATTRIBUTE_SUMMARY=124,
    DOCBOOK_ATTRIBUTE_TABSTYLE=125,
    DOCBOOK_ATTRIBUTE_TARGETDOC=126,
    DOCBOOK_ATTRIBUTE_TARGETDOCENT=127,
    DOCBOOK_ATTRIBUTE_TARGETPTR=128,
    DOCBOOK_ATTRIBUTE_TEMPORAL=129,
    DOCBOOK_ATTRIBUTE_TERMLENGTH=130,
    DOCBOOK_ATTRIBUTE_TGROUPSTYLE=131,
    DOCBOOK_ATTRIBUTE_TITLE=132,
    DOCBOOK_ATTRIBUTE_TOCENTRY=133,
    DOCBOOK_ATTRIBUTE_TYPE=134,
    DOCBOOK_ATTRIBUTE_UNITS=135,
    DOCBOOK_ATTRIBUTE_UNKNOWN=0,
    DOCBOOK_ATTRIBUTE_URL=136,
    DOCBOOK_ATTRIBUTE_USERLEVEL=137,
    DOCBOOK_ATTRIBUTE_VALIGN=138,
    DOCBOOK_ATTRIBUTE_VENDOR=139,
    DOCBOOK_ATTRIBUTE_WEIGTH=140,
    DOCBOOK_ATTRIBUTE_WIDTH=141,
    DOCBOOK_ATTRIBUTE_XREFLABEL=142,
    DOCBOOK_ATTRIBUTE_XREFSTYLE=143,
    DOCBOOK_ATTRIBUTE_ZONE=144
} docbook_attribute_type;

typedef enum docbook_element_type {
    DOCBOOK_ELEMENTS=410,
    DOCBOOK_ELEMENT_ABBREV=1,
    DOCBOOK_ELEMENT_ABSTRACT=2,
    DOCBOOK_ELEMENT_ACCEL=3,
    DOCBOOK_ELEMENT_ACKNO=4,
    DOCBOOK_ELEMENT_ACRONYM=5,
    DOCBOOK_ELEMENT_ACTION=6,
    DOCBOOK_ELEMENT_ADDRESS=7,
    DOCBOOK_ELEMENT_AFFILIATION=8,
    DOCBOOK_ELEMENT_ALT=9,
    DOCBOOK_ELEMENT_ANCHOR=10,
    DOCBOOK_ELEMENT_ANSWER=11,
    DOCBOOK_ELEMENT_APPENDIX=12,
    DOCBOOK_ELEMENT_APPENDIXINFO=13,
    DOCBOOK_ELEMENT_APPLICATION=14,
    DOCBOOK_ELEMENT_AREA=15,
    DOCBOOK_ELEMENT_AREASET=16,
    DOCBOOK_ELEMENT_AREASPEC=17,
    DOCBOOK_ELEMENT_ARG=18,
    DOCBOOK_ELEMENT_ARTICLE=19,
    DOCBOOK_ELEMENT_ARTICLEINFO=20,
    DOCBOOK_ELEMENT_ARTPAGENUMS=21,
    DOCBOOK_ELEMENT_ATTRIBUTION=22,
    DOCBOOK_ELEMENT_AUDIODATA=23,
    DOCBOOK_ELEMENT_AUDIOOBJECT=24,
    DOCBOOK_ELEMENT_AUTHOR=25,
    DOCBOOK_ELEMENT_AUTHORBLURB=26,
    DOCBOOK_ELEMENT_AUTHORGROUP=27,
    DOCBOOK_ELEMENT_AUTHORINITIALS=28,
    DOCBOOK_ELEMENT_BEGINPAGE=29,
    DOCBOOK_ELEMENT_BIBLIOCOVERAGE=30,
    DOCBOOK_ELEMENT_BIBLIODIV=31,
    DOCBOOK_ELEMENT_BIBLIOENTRY=32,
    DOCBOOK_ELEMENT_BIBLIOGRAPHY=33,
    DOCBOOK_ELEMENT_BIBLIOGRAPHYINFO=34,
    DOCBOOK_ELEMENT_BIBLIOID=35,
    DOCBOOK_ELEMENT_BIBLIOMISC=36,
    DOCBOOK_ELEMENT_BIBLIOMIXED=37,
    DOCBOOK_ELEMENT_BIBLIOMSET=38,
    DOCBOOK_ELEMENT_BIBLIORELATION=39,
    DOCBOOK_ELEMENT_BIBLIOSET=40,
    DOCBOOK_ELEMENT_BIBLIOSOURCE=41,
    DOCBOOK_ELEMENT_BLOCKINFO=42,
    DOCBOOK_ELEMENT_BLOCKQUOTE=43,
    DOCBOOK_ELEMENT_BOOK=44,
    DOCBOOK_ELEMENT_BOOKINFO=45,
    DOCBOOK_ELEMENT_BRIDGEHEAD=46,
    DOCBOOK_ELEMENT_CALLOUT=47,
    DOCBOOK_ELEMENT_CALLOUTLIST=48,
    DOCBOOK_ELEMENT_CAPTION=49,
    DOCBOOK_ELEMENT_CAUTION=50,
    DOCBOOK_ELEMENT_CHAPTER=51,
    DOCBOOK_ELEMENT_CHAPTERINFO=52,
    DOCBOOK_ELEMENT_CITATION=53,
    DOCBOOK_ELEMENT_CITEBIBLIOID=54,
    DOCBOOK_ELEMENT_CITEREFENTRY=55,
    DOCBOOK_ELEMENT_CITETITLE=56,
    DOCBOOK_ELEMENT_CITY=57,
    DOCBOOK_ELEMENT_CLASSNAME=58,
    DOCBOOK_ELEMENT_CLASSSYNOPSIS=59,
    DOCBOOK_ELEMENT_CLASSSYNOPSISINFO=60,
    DOCBOOK_ELEMENT_CMDSYNOPSIS=61,
    DOCBOOK_ELEMENT_CO=62,
    DOCBOOK_ELEMENT_CODE=63,
    DOCBOOK_ELEMENT_COL=64,
    DOCBOOK_ELEMENT_COLGROUP=65,
    DOCBOOK_ELEMENT_COLLAB=66,
    DOCBOOK_ELEMENT_COLLABNAME=67,
    DOCBOOK_ELEMENT_COLOPHON=68,
    DOCBOOK_ELEMENT_COLSPEC=69,
    DOCBOOK_ELEMENT_COMMAND=70,
    DOCBOOK_ELEMENT_COMPUTEROUTPUT=71,
    DOCBOOK_ELEMENT_CONFDATES=72,
    DOCBOOK_ELEMENT_CONFGROUP=73,
    DOCBOOK_ELEMENT_CONFNUM=74,
    DOCBOOK_ELEMENT_CONFSPONSOR=75,
    DOCBOOK_ELEMENT_CONFTITLE=76,
    DOCBOOK_ELEMENT_CONSTANT=77,
    DOCBOOK_ELEMENT_CONSTRAINT=78,
    DOCBOOK_ELEMENT_CONSTRAINTDEF=79,
    DOCBOOK_ELEMENT_CONSTRUCTORSYNOPSIS=80,
    DOCBOOK_ELEMENT_CONTRACTNUM=81,
    DOCBOOK_ELEMENT_CONTRACTSPONSOR=82,
    DOCBOOK_ELEMENT_CONTRIB=83,
    DOCBOOK_ELEMENT_COPYRIGHT=84,
    DOCBOOK_ELEMENT_COREF=85,
    DOCBOOK_ELEMENT_CORPAUTHOR=86,
    DOCBOOK_ELEMENT_CORPCREDIT=87,
    DOCBOOK_ELEMENT_CORPNAME=88,
    DOCBOOK_ELEMENT_COUNTRY=89,
    DOCBOOK_ELEMENT_DATABASE=90,
    DOCBOOK_ELEMENT_DATE=91,
    DOCBOOK_ELEMENT_DEDICATION=92,
    DOCBOOK_ELEMENT_DESTRUCTORSYNOPSIS=93,
    DOCBOOK_ELEMENT_EDITION=94,
    DOCBOOK_ELEMENT_EDITOR=95,
    DOCBOOK_ELEMENT_EMAIL=96,
    DOCBOOK_ELEMENT_EMPHASIS=97,
    DOCBOOK_ELEMENT_ENTRY=98,
    DOCBOOK_ELEMENT_ENTRYTBL=99,
    DOCBOOK_ELEMENT_ENVAR=100,
    DOCBOOK_ELEMENT_EPIGRAPH=101,
    DOCBOOK_ELEMENT_EQUATION=102,
    DOCBOOK_ELEMENT_ERRORCODE=103,
    DOCBOOK_ELEMENT_ERRORNAME=104,
    DOCBOOK_ELEMENT_ERRORTEXT=105,
    DOCBOOK_ELEMENT_ERRORTYPE=106,
    DOCBOOK_ELEMENT_EXAMPLE=107,
    DOCBOOK_ELEMENT_EXCEPTIONNAME=108,
    DOCBOOK_ELEMENT_FAX=109,
    DOCBOOK_ELEMENT_FIELDSYNOPSIS=110,
    DOCBOOK_ELEMENT_FIGURE=111,
    DOCBOOK_ELEMENT_FILENAME=112,
    DOCBOOK_ELEMENT_FIRSTNAME=113,
    DOCBOOK_ELEMENT_FIRSTTERM=114,
    DOCBOOK_ELEMENT_FOOTNOTE=115,
    DOCBOOK_ELEMENT_FOOTNOTEREF=116,
    DOCBOOK_ELEMENT_FOREIGNPHRASE=117,
    DOCBOOK_ELEMENT_FORMALPARA=118,
    DOCBOOK_ELEMENT_FUNCDEF=119,
    DOCBOOK_ELEMENT_FUNCPARAMS=120,
    DOCBOOK_ELEMENT_FUNCPROTOTYPE=121,
    DOCBOOK_ELEMENT_FUNCSYNOPSIS=122,
    DOCBOOK_ELEMENT_FUNCSYNOPSISINFO=123,
    DOCBOOK_ELEMENT_FUNCTION=124,
    DOCBOOK_ELEMENT_GLOSSARY=125,
    DOCBOOK_ELEMENT_GLOSSARYINFO=126,
    DOCBOOK_ELEMENT_GLOSSDEF=127,
    DOCBOOK_ELEMENT_GLOSSDIV=128,
    DOCBOOK_ELEMENT_GLOSSENTRY=129,
    DOCBOOK_ELEMENT_GLOSSLIST=130,
    DOCBOOK_ELEMENT_GLOSSSEE=131,
    DOCBOOK_ELEMENT_GLOSSSEEALSO=132,
    DOCBOOK_ELEMENT_GLOSSTERM=133,
    DOCBOOK_ELEMENT_GRAPHIC=134,
    DOCBOOK_ELEMENT_GRAPHICCO=135,
    DOCBOOK_ELEMENT_GROUP=136,
    DOCBOOK_ELEMENT_GUIBUTTON=137,
    DOCBOOK_ELEMENT_GUIICON=138,
    DOCBOOK_ELEMENT_GUILABEL=139,
    DOCBOOK_ELEMENT_GUIMENU=140,
    DOCBOOK_ELEMENT_GUIMENUITEM=141,
    DOCBOOK_ELEMENT_GUISUBMENU=142,
    DOCBOOK_ELEMENT_HARDWARE=143,
    DOCBOOK_ELEMENT_HIGHLIGHTS=144,
    DOCBOOK_ELEMENT_HOLDER=145,
    DOCBOOK_ELEMENT_HONORIFIC=146,
    DOCBOOK_ELEMENT_IMAGEDATA=147,
    DOCBOOK_ELEMENT_IMAGEOBJECT=148,
    DOCBOOK_ELEMENT_IMAGEOBJECTCO=149,
    DOCBOOK_ELEMENT_IMPORTANT=150,
    DOCBOOK_ELEMENT_INDEX=151,
    DOCBOOK_ELEMENT_INDEXDIV=152,
    DOCBOOK_ELEMENT_INDEXENTRY=153,
    DOCBOOK_ELEMENT_INDEXINFO=154,
    DOCBOOK_ELEMENT_INDEXTERM=155,
    DOCBOOK_ELEMENT_INFORMALEQUATION=156,
    DOCBOOK_ELEMENT_INFORMALEXAMPLE=157,
    DOCBOOK_ELEMENT_INFORMALFIGURE=158,
    DOCBOOK_ELEMENT_INFORMALTABLE=159,
    DOCBOOK_ELEMENT_INITIALIZER=160,
    DOCBOOK_ELEMENT_INLINEEQUATION=161,
    DOCBOOK_ELEMENT_INLINEGRAPHIC=162,
    DOCBOOK_ELEMENT_INLINEMEDIAOBJECT=163,
    DOCBOOK_ELEMENT_INTERFACE=164,
    DOCBOOK_ELEMENT_INTERFACENAME=165,
    DOCBOOK_ELEMENT_INVPARTNUMBER=166,
    DOCBOOK_ELEMENT_ISBN=167,
    DOCBOOK_ELEMENT_ISSN=168,
    DOCBOOK_ELEMENT_ISSUENUM=169,
    DOCBOOK_ELEMENT_ITEMIZEDLIST=170,
    DOCBOOK_ELEMENT_ITERMSET=171,
    DOCBOOK_ELEMENT_JOBTITLE=172,
    DOCBOOK_ELEMENT_KEYCAP=173,
    DOCBOOK_ELEMENT_KEYCODE=174,
    DOCBOOK_ELEMENT_KEYCOMBO=175,
    DOCBOOK_ELEMENT_KEYSYM=176,
    DOCBOOK_ELEMENT_KEYWORD=177,
    DOCBOOK_ELEMENT_KEYWORDSET=178,
    DOCBOOK_ELEMENT_LABEL=179,
    DOCBOOK_ELEMENT_LEGALNOTICE=180,
    DOCBOOK_ELEMENT_LHS=181,
    DOCBOOK_ELEMENT_LINEAGE=182,
    DOCBOOK_ELEMENT_LINEANNOTATION=183,
    DOCBOOK_ELEMENT_LINK=184,
    DOCBOOK_ELEMENT_LISTITEM=185,
    DOCBOOK_ELEMENT_LITERAL=186,
    DOCBOOK_ELEMENT_LITERALLAYOUT=187,
    DOCBOOK_ELEMENT_LOT=188,
    DOCBOOK_ELEMENT_LOTENTRY=189,
    DOCBOOK_ELEMENT_MANVOLNUM=190,
    DOCBOOK_ELEMENT_MARKUP=191,
    DOCBOOK_ELEMENT_MEDIALABEL=192,
    DOCBOOK_ELEMENT_MEDIAOBJECT=193,
    DOCBOOK_ELEMENT_MEDIAOBJECTCO=194,
    DOCBOOK_ELEMENT_MEMBER=195,
    DOCBOOK_ELEMENT_MENUCHOICE=196,
    DOCBOOK_ELEMENT_METHODNAME=197,
    DOCBOOK_ELEMENT_METHODPARAM=198,
    DOCBOOK_ELEMENT_METHODSYNOPSIS=199,
    DOCBOOK_ELEMENT_MODESPEC=200,
    DOCBOOK_ELEMENT_MODIFIER=201,
    DOCBOOK_ELEMENT_MOUSEBUTTON=202,
    DOCBOOK_ELEMENT_MSG=203,
    DOCBOOK_ELEMENT_MSGAUD=204,
    DOCBOOK_ELEMENT_MSGENTRY=205,
    DOCBOOK_ELEMENT_MSGEXPLAN=206,
    DOCBOOK_ELEMENT_MSGINFO=207,
    DOCBOOK_ELEMENT_MSGLEVEL=208,
    DOCBOOK_ELEMENT_MSGMAIN=209,
    DOCBOOK_ELEMENT_MSGORIG=210,
    DOCBOOK_ELEMENT_MSGREL=211,
    DOCBOOK_ELEMENT_MSGSET=212,
    DOCBOOK_ELEMENT_MSGSUB=213,
    DOCBOOK_ELEMENT_MSGTEXT=214,
    DOCBOOK_ELEMENT_NONTERMINAL=215,
    DOCBOOK_ELEMENT_NOTE=216,
    DOCBOOK_ELEMENT_OBJECTINFO=217,
    DOCBOOK_ELEMENT_OLINK=218,
    DOCBOOK_ELEMENT_OOCLASS=219,
    DOCBOOK_ELEMENT_OOEXCEPTION=220,
    DOCBOOK_ELEMENT_OOINTERFACE=221,
    DOCBOOK_ELEMENT_OPTION=222,
    DOCBOOK_ELEMENT_OPTIONAL=223,
    DOCBOOK_ELEMENT_ORDEREDLIST=224,
    DOCBOOK_ELEMENT_ORGDIV=225,
    DOCBOOK_ELEMENT_ORGNAME=226,
    DOCBOOK_ELEMENT_OTHERADDR=227,
    DOCBOOK_ELEMENT_OTHERCREDIT=228,
    DOCBOOK_ELEMENT_OTHERNAME=229,
    DOCBOOK_ELEMENT_PAGENUMS=230,
    DOCBOOK_ELEMENT_PARA=231,
    DOCBOOK_ELEMENT_PARAMDEF=232,
    DOCBOOK_ELEMENT_PARAMETER=233,
    DOCBOOK_ELEMENT_PART=234,
    DOCBOOK_ELEMENT_PARTINFO=235,
    DOCBOOK_ELEMENT_PARTINTRO=236,
    DOCBOOK_ELEMENT_PERSONBLURB=237,
    DOCBOOK_ELEMENT_PERSONNAME=238,
    DOCBOOK_ELEMENT_PHONE=239,
    DOCBOOK_ELEMENT_PHRASE=240,
    DOCBOOK_ELEMENT_POB=241,
    DOCBOOK_ELEMENT_POSTCODE=242,
    DOCBOOK_ELEMENT_PREFACE=243,
    DOCBOOK_ELEMENT_PREFACEINFO=244,
    DOCBOOK_ELEMENT_PRIMARY=245,
    DOCBOOK_ELEMENT_PRIMARYIE=246,
    DOCBOOK_ELEMENT_PRINTHISTORY=247,
    DOCBOOK_ELEMENT_PROCEDURE=248,
    DOCBOOK_ELEMENT_PRODUCTION=249,
    DOCBOOK_ELEMENT_PRODUCTIONRECAP=250,
    DOCBOOK_ELEMENT_PRODUCTIONSET=251,
    DOCBOOK_ELEMENT_PRODUCTNAME=252,
    DOCBOOK_ELEMENT_PRODUCTNUMBER=253,
    DOCBOOK_ELEMENT_PROGRAMLISTING=254,
    DOCBOOK_ELEMENT_PROGRAMLISTINGCO=255,
    DOCBOOK_ELEMENT_PROMPT=256,
    DOCBOOK_ELEMENT_PROPERTY=257,
    DOCBOOK_ELEMENT_PUBDATE=258,
    DOCBOOK_ELEMENT_PUBLISHER=259,
    DOCBOOK_ELEMENT_PUBLISHERNAME=260,
    DOCBOOK_ELEMENT_PUBSNUMBER=261,
    DOCBOOK_ELEMENT_QANDADIV=262,
    DOCBOOK_ELEMENT_QANDAENTRY=263,
    DOCBOOK_ELEMENT_QANDASET=264,
    DOCBOOK_ELEMENT_QUESTION=265,
    DOCBOOK_ELEMENT_QUOTE=266,
    DOCBOOK_ELEMENT_REFCLASS=267,
    DOCBOOK_ELEMENT_REFDESCRIPTOR=268,
    DOCBOOK_ELEMENT_REFENTRY=269,
    DOCBOOK_ELEMENT_REFENTRYINFO=270,
    DOCBOOK_ELEMENT_REFENTRYTITLE=271,
    DOCBOOK_ELEMENT_REFERENCE=272,
    DOCBOOK_ELEMENT_REFERENCEINFO=273,
    DOCBOOK_ELEMENT_REFMETA=274,
    DOCBOOK_ELEMENT_REFMISCINFO=275,
    DOCBOOK_ELEMENT_REFNAME=276,
    DOCBOOK_ELEMENT_REFNAMEDIV=277,
    DOCBOOK_ELEMENT_REFPURPOSE=278,
    DOCBOOK_ELEMENT_REFSECT1=279,
    DOCBOOK_ELEMENT_REFSECT1INFO=280,
    DOCBOOK_ELEMENT_REFSECT2=281,
    DOCBOOK_ELEMENT_REFSECT2INFO=282,
    DOCBOOK_ELEMENT_REFSECT3=283,
    DOCBOOK_ELEMENT_REFSECT3INFO=284,
    DOCBOOK_ELEMENT_REFSECTION=285,
    DOCBOOK_ELEMENT_REFSECTIONINFO=286,
    DOCBOOK_ELEMENT_REFSYNOPSISDIV=287,
    DOCBOOK_ELEMENT_REFSYNOPSISDIVINFO=288,
    DOCBOOK_ELEMENT_RELEASEINFO=289,
    DOCBOOK_ELEMENT_REMARK=290,
    DOCBOOK_ELEMENT_REPLACEABLE=291,
    DOCBOOK_ELEMENT_RETURNVALUE=292,
    DOCBOOK_ELEMENT_REVDESCRIPTION=293,
    DOCBOOK_ELEMENT_REVHISTORY=294,
    DOCBOOK_ELEMENT_REVISION=295,
    DOCBOOK_ELEMENT_REVNUMBER=296,
    DOCBOOK_ELEMENT_REVREMARK=297,
    DOCBOOK_ELEMENT_RHS=298,
    DOCBOOK_ELEMENT_ROW=299,
    DOCBOOK_ELEMENT_SBR=300,
    DOCBOOK_ELEMENT_SCREEN=301,
    DOCBOOK_ELEMENT_SCREENCO=302,
    DOCBOOK_ELEMENT_SCREENINFO=303,
    DOCBOOK_ELEMENT_SCREENSHOT=304,
    DOCBOOK_ELEMENT_SECONDARY=305,
    DOCBOOK_ELEMENT_SECONDARYIE=306,
    DOCBOOK_ELEMENT_SECT1=307,
    DOCBOOK_ELEMENT_SECT1INFO=308,
    DOCBOOK_ELEMENT_SECT2=309,
    DOCBOOK_ELEMENT_SECT2INFO=310,
    DOCBOOK_ELEMENT_SECT3=311,
    DOCBOOK_ELEMENT_SECT3INFO=312,
    DOCBOOK_ELEMENT_SECT4=313,
    DOCBOOK_ELEMENT_SECT4INFO=314,
    DOCBOOK_ELEMENT_SECT5=315,
    DOCBOOK_ELEMENT_SECT5INFO=316,
    DOCBOOK_ELEMENT_SECTION=317,
    DOCBOOK_ELEMENT_SECTIONINFO=318,
    DOCBOOK_ELEMENT_SEE=319,
    DOCBOOK_ELEMENT_SEEALSO=320,
    DOCBOOK_ELEMENT_SEEALSOIE=321,
    DOCBOOK_ELEMENT_SEEIE=322,
    DOCBOOK_ELEMENT_SEG=323,
    DOCBOOK_ELEMENT_SEGLISTITEM=324,
    DOCBOOK_ELEMENT_SEGMENTEDLIST=325,
    DOCBOOK_ELEMENT_SEGTITLE=326,
    DOCBOOK_ELEMENT_SERIESVOLNUMS=327,
    DOCBOOK_ELEMENT_SET=328,
    DOCBOOK_ELEMENT_SETINDEX=329,
    DOCBOOK_ELEMENT_SETINDEXINFO=330,
    DOCBOOK_ELEMENT_SETINFO=331,
    DOCBOOK_ELEMENT_SGMLTAG=332,
    DOCBOOK_ELEMENT_SHORTAFFIL=333,
    DOCBOOK_ELEMENT_SHORTCUT=334,
    DOCBOOK_ELEMENT_SIDEBAR=335,
    DOCBOOK_ELEMENT_SIDEBARINFO=336,
    DOCBOOK_ELEMENT_SIMPARA=337,
    DOCBOOK_ELEMENT_SIMPLELIST=338,
    DOCBOOK_ELEMENT_SIMPLEMSGENTRY=339,
    DOCBOOK_ELEMENT_SIMPLESECT=340,
    DOCBOOK_ELEMENT_SPANSPEC=341,
    DOCBOOK_ELEMENT_STATE=342,
    DOCBOOK_ELEMENT_STEP=343,
    DOCBOOK_ELEMENT_STEPALTERNATIVES=344,
    DOCBOOK_ELEMENT_STREET=345,
    DOCBOOK_ELEMENT_STRUCTFIELD=346,
    DOCBOOK_ELEMENT_STRUCTNAME=347,
    DOCBOOK_ELEMENT_SUBJECT=348,
    DOCBOOK_ELEMENT_SUBJECTSET=349,
    DOCBOOK_ELEMENT_SUBJECTTERM=350,
    DOCBOOK_ELEMENT_SUBSCRIPT=351,
    DOCBOOK_ELEMENT_SUBSTEPS=352,
    DOCBOOK_ELEMENT_SUBTITLE=353,
    DOCBOOK_ELEMENT_SUPERSCRIPT=354,
    DOCBOOK_ELEMENT_SURNAME=355,
    DOCBOOK_ELEMENT_SYMBOL=356,
    DOCBOOK_ELEMENT_SYNOPFRAGMENT=357,
    DOCBOOK_ELEMENT_SYNOPFRAGMENTREF=358,
    DOCBOOK_ELEMENT_SYNOPSIS=359,
    DOCBOOK_ELEMENT_SYSTEMITEM=360,
    DOCBOOK_ELEMENT_TABLE=361,
    DOCBOOK_ELEMENT_TASK=362,
    DOCBOOK_ELEMENT_TASKPREREQUISITES=363,
    DOCBOOK_ELEMENT_TASKRELATED=364,
    DOCBOOK_ELEMENT_TASKSUMMARY=365,
    DOCBOOK_ELEMENT_TBODY=366,
    DOCBOOK_ELEMENT_TD=367,
    DOCBOOK_ELEMENT_TERM=368,
    DOCBOOK_ELEMENT_TERTIARY=369,
    DOCBOOK_ELEMENT_TERTIARYIE=370,
    DOCBOOK_ELEMENT_TEXTDATA=371,
    DOCBOOK_ELEMENT_TEXTOBJECT=372,
    DOCBOOK_ELEMENT_TFOOT=373,
    DOCBOOK_ELEMENT_TGROUP=374,
    DOCBOOK_ELEMENT_TH=375,
    DOCBOOK_ELEMENT_THEAD=376,
    DOCBOOK_ELEMENT_TIP=377,
    DOCBOOK_ELEMENT_TITLE=378,
    DOCBOOK_ELEMENT_TITLEABBREV=379,
    DOCBOOK_ELEMENT_TOC=380,
    DOCBOOK_ELEMENT_TOCBACK=381,
    DOCBOOK_ELEMENT_TOCCHAP=382,
    DOCBOOK_ELEMENT_TOCENTRY=383,
    DOCBOOK_ELEMENT_TOCFRONT=384,
    DOCBOOK_ELEMENT_TOCLEVEL1=385,
    DOCBOOK_ELEMENT_TOCLEVEL2=386,
    DOCBOOK_ELEMENT_TOCLEVEL3=387,
    DOCBOOK_ELEMENT_TOCLEVEL4=388,
    DOCBOOK_ELEMENT_TOCLEVEL5=389,
    DOCBOOK_ELEMENT_TOCPART=390,
    DOCBOOK_ELEMENT_TOKEN=391,
    DOCBOOK_ELEMENT_TR=392,
    DOCBOOK_ELEMENT_TRADEMARK=393,
    DOCBOOK_ELEMENT_TYPE=394,
    DOCBOOK_ELEMENT_ULINK=395,
    DOCBOOK_ELEMENT_UNKNOWN=0,
    DOCBOOK_ELEMENT_URI=396,
    DOCBOOK_ELEMENT_USERINPUT=397,
    DOCBOOK_ELEMENT_VARARGS=398,
    DOCBOOK_ELEMENT_VARIABLELIST=399,
    DOCBOOK_ELEMENT_VARLISTENTRY=400,
    DOCBOOK_ELEMENT_VARNAME=401,
    DOCBOOK_ELEMENT_VIDEODATA=402,
    DOCBOOK_ELEMENT_VIDEOOBJECT=403,
    DOCBOOK_ELEMENT_VOID=404,
    DOCBOOK_ELEMENT_VOLUMENUM=405,
    DOCBOOK_ELEMENT_WARNING=406,
    DOCBOOK_ELEMENT_WORDASWORD=407,
    DOCBOOK_ELEMENT_XREF=408,
    DOCBOOK_ELEMENT_YEAR=409
} docbook_element_type;

typedef struct protocol_backend protocol_backend, *Pprotocol_backend;

struct protocol_backend {
    uchar * name;
    int port;
    void (* handler)(struct connection *);
    uint need_slashes:1;
    uint need_slash_after_host:1;
    uint free_syntax:1;
    uint need_ssl:1;
    uint keep_double_slashes:1;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
};

typedef enum protocol {
    PROTOCOL_ABOUT=0,
    PROTOCOL_BACKENDS=21,
    PROTOCOL_BITTORRENT=1,
    PROTOCOL_BITTORRENT_PEER=2,
    PROTOCOL_DATA=3,
    PROTOCOL_FILE=4,
    PROTOCOL_FINGER=5,
    PROTOCOL_FSP=6,
    PROTOCOL_FTP=7,
    PROTOCOL_GOPHER=8,
    PROTOCOL_HTTP=9,
    PROTOCOL_HTTPS=10,
    PROTOCOL_JAVASCRIPT=11,
    PROTOCOL_LUA=20,
    PROTOCOL_NEWS=12,
    PROTOCOL_NNTP=13,
    PROTOCOL_NNTPS=14,
    PROTOCOL_PROXY=15,
    PROTOCOL_SMB=16,
    PROTOCOL_SNEWS=17,
    PROTOCOL_UNKNOWN=18,
    PROTOCOL_USER=19
} protocol;

typedef struct sgml_info sgml_info, *Psgml_info;

typedef enum sgml_document_type {
    SGML_DOCTYPES=4,
    SGML_DOCTYPE_DOCBOOK=0,
    SGML_DOCTYPE_HTML=1,
    SGML_DOCTYPE_RSS=2,
    SGML_DOCTYPE_XBEL=3
} sgml_document_type;

typedef struct sgml_node_info sgml_node_info, *Psgml_node_info;

typedef struct dom_string dom_string, *Pdom_string;

typedef ushort uint16_t;

struct dom_string {
    uint length;
    uchar * string;
};

struct sgml_node_info {
    struct dom_string string;
    uint16_t type;
    uint16_t flags;
};

struct sgml_info {
    enum sgml_document_type doctype;
    struct sgml_node_info * attributes;
    struct sgml_node_info * elements;
};

typedef enum sgml_element_flags {
    SGML_ELEMENT_EMPTY=2,
    SGML_ELEMENT_END_OPTIONAL=4,
    SGML_ELEMENT_OPTIONAL=1
} sgml_element_flags;

typedef enum sgml_attribute_flags {
    SGML_ATTRIBUTE_IDENTIFIER=1,
    SGML_ATTRIBUTE_REFERENCE=2
} sgml_attribute_flags;

typedef __pid_t pid_t;

typedef struct mailcap_hash_item mailcap_hash_item, *Pmailcap_hash_item;

struct mailcap_hash_item {
    struct list_head_elinks entries;
    uchar type[1];
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
};

typedef enum mailcap_option {
    MAILCAP_ASK=3,
    MAILCAP_DESCRIPTION=4,
    MAILCAP_ENABLE=1,
    MAILCAP_OPTIONS=6,
    MAILCAP_PATH=2,
    MAILCAP_PRIORITIZE=5,
    MAILCAP_TREE=0
} mailcap_option;

typedef struct mailcap_entry mailcap_entry, *Pmailcap_entry;

struct mailcap_entry {
    struct mailcap_entry * next;
    struct mailcap_entry * prev;
    uchar * testcommand;
    uchar * description;
    uint priority;
    uint needsterminal:1;
    uint copiousoutput:1;
    uchar command[1];
    undefined field_0x16;
    undefined field_0x17;
};


// WARNING! conflicting data type names: /DWARF/libio.h/_IO_marker - /libio.h/_IO_marker

typedef enum Gpm_Etype {
    GPM_DOUBLE=32,
    GPM_DOWN=4,
    GPM_DRAG=2,
    GPM_ENTER=512,
    GPM_HARD=256,
    GPM_LEAVE=1024,
    GPM_MFLAG=128,
    GPM_MOVE=1,
    GPM_SINGLE=16,
    GPM_TRIPLE=64,
    GPM_UP=8
} Gpm_Etype;

typedef struct Gpm_Connect Gpm_Connect, *PGpm_Connect;

struct Gpm_Connect {
    ushort eventMask;
    ushort defaultMask;
    ushort minMod;
    ushort maxMod;
    int pid;
    int vc;
};

typedef enum Gpm_Margin {
    GPM_BOT=2,
    GPM_LFT=4,
    GPM_RGT=8,
    GPM_TOP=1
} Gpm_Margin;

typedef struct Gpm_Event Gpm_Event, *PGpm_Event;

struct Gpm_Event {
    uchar buttons;
    uchar modifiers;
    ushort vc;
    short dx;
    short dy;
    short x;
    short y;
    enum Gpm_Etype type;
    int clicks;
    enum Gpm_Margin margin;
    short wdx;
    short wdy;
};

typedef struct css_property_info css_property_info, *Pcss_property_info;

typedef union css_property_value css_property_value, *Pcss_property_value;

typedef struct scanner scanner, *Pscanner;

typedef enum css_property_type {
    CSS_PT_BACKGROUND=1,
    CSS_PT_BACKGROUND_COLOR=2,
    CSS_PT_COLOR=3,
    CSS_PT_DISPLAY=4,
    CSS_PT_FONT_STYLE=5,
    CSS_PT_FONT_WEIGHT=6,
    CSS_PT_LAST=10,
    CSS_PT_NONE=0,
    CSS_PT_TEXT_ALIGN=7,
    CSS_PT_TEXT_DECORATION=8,
    CSS_PT_WHITE_SPACE=9
} css_property_type;

typedef enum css_property_value_type {
    CSS_VT_COLOR=1,
    CSS_VT_DISPLAY=2,
    CSS_VT_FONT_ATTRIBUTE=3,
    CSS_VT_LAST=5,
    CSS_VT_NONE=0,
    CSS_VT_TEXT_ALIGN=4
} css_property_value_type;

typedef enum css_display {
    CSS_DISP_BLOCK=1,
    CSS_DISP_INLINE=0
} css_display;

typedef struct anon_struct.conflict1 anon_struct.conflict1, *Panon_struct.conflict1;

typedef enum format_align {
    ALIGN_CENTER=1,
    ALIGN_JUSTIFY=3,
    ALIGN_LEFT=0,
    ALIGN_RIGHT=2
} format_align;

typedef struct scanner_token scanner_token, *Pscanner_token;

typedef struct scanner_info scanner_info, *Pscanner_info;

typedef struct scanner_string_mapping scanner_string_mapping, *Pscanner_string_mapping;

typedef struct scan_table_info scan_table_info, *Pscan_table_info;

typedef enum anon_enum_32_for_type {
    KP_MARK_GOTO=2,
    KP_MARK_NOTHING=0,
    KP_MARK_SET=1,
    SCAN_END=2,
    SCAN_RANGE=0,
    SCAN_STRING=1,
    TERM_FN_RESIZE=2,
    TERM_FN_TITLE=1,
    TERM_FN_TITLE_CODEPAGE=3,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096
} anon_enum_32_for_type;

typedef union scan_table_data scan_table_data, *Pscan_table_data;

typedef struct anon_struct.conflict2 anon_struct.conflict2, *Panon_struct.conflict2;

typedef struct anon_struct.conflict3 anon_struct.conflict3, *Panon_struct.conflict3;

struct anon_struct.conflict2 {
    uchar * source;
    long length;
};

struct anon_struct.conflict3 {
    uchar * start;
    long end;
};

union scan_table_data {
    struct anon_struct.conflict2 string;
    struct anon_struct.conflict3 range;
};

struct scanner_token {
    int type;
    int precedence;
    uchar * string;
    int length;
};

struct scanner {
    uchar * string;
    uchar * position;
    uchar * end;
    struct scanner_token * current;
    int tokens;
    struct scanner_info * info;
    int state;
    struct scanner_token table[10];
};

struct anon_struct.conflict1 {
    enum text_style_format add;
    enum text_style_format rem;
};

struct scanner_info {
    struct scanner_string_mapping * mappings;
    struct scan_table_info * scan_table_info;
    scanner_token * (* scan)(struct scanner *);
    int scan_table[256];
    uint initialized:1;
    undefined field_0x40d;
    undefined field_0x40e;
    undefined field_0x40f;
};

struct css_property_info {
    uchar * name;
    enum css_property_type type;
    enum css_property_value_type value_type;
    int (* parser)(struct css_property_info *, union css_property_value *, struct scanner *);
    void * parser_data;
};

struct scanner_string_mapping {
    uchar * name;
    int type;
    int base_type;
};

union css_property_value {
    void * none;
    color_T color;
    enum css_display display;
    struct anon_struct.conflict1 font_attribute;
    enum format_align text_align;
};

struct scan_table_info {
    enum anon_enum_32_for_type type;
    union scan_table_data data;
    int bits;
};

typedef struct css_property css_property, *Pcss_property;

struct css_property {
    struct css_property * next;
    struct css_property * prev;
    enum css_property_type type;
    enum css_property_value_type value_type;
    union css_property_value value;
};

typedef struct gnutls_anon_client_credentials_st gnutls_anon_client_credentials_st, *Pgnutls_anon_client_credentials_st;

typedef struct gnutls_anon_client_credentials_st * gnutls_anon_client_credentials_t;

struct gnutls_anon_client_credentials_st {
};

typedef enum gnutls_cipher_algorithm_t {
    GNUTLS_CIPHER_3DES_CBC=3,
    GNUTLS_CIPHER_3DES_PGP_CFB=201,
    GNUTLS_CIPHER_AES128_PGP_CFB=205,
    GNUTLS_CIPHER_AES192_PGP_CFB=206,
    GNUTLS_CIPHER_AES256_PGP_CFB=207,
    GNUTLS_CIPHER_AES_128_CBC=4,
    GNUTLS_CIPHER_AES_256_CBC=5,
    GNUTLS_CIPHER_ARCFOUR_128=2,
    GNUTLS_CIPHER_ARCFOUR_40=6,
    GNUTLS_CIPHER_BLOWFISH_PGP_CFB=203,
    GNUTLS_CIPHER_CAMELLIA_128_CBC=7,
    GNUTLS_CIPHER_CAMELLIA_256_CBC=8,
    GNUTLS_CIPHER_CAST5_PGP_CFB=202,
    GNUTLS_CIPHER_DES_CBC=91,
    GNUTLS_CIPHER_IDEA_PGP_CFB=200,
    GNUTLS_CIPHER_NULL=1,
    GNUTLS_CIPHER_RC2_40_CBC=90,
    GNUTLS_CIPHER_SAFER_SK128_PGP_CFB=204,
    GNUTLS_CIPHER_TWOFISH_PGP_CFB=208,
    GNUTLS_CIPHER_UNKNOWN=0
} gnutls_cipher_algorithm_t;

typedef struct gnutls_certificate_credentials_st gnutls_certificate_credentials_st, *Pgnutls_certificate_credentials_st;

typedef struct gnutls_certificate_credentials_st * gnutls_certificate_credentials_t;

struct gnutls_certificate_credentials_st {
};

typedef struct gnutls_session_int gnutls_session_int, *Pgnutls_session_int;

typedef struct gnutls_session_int * gnutls_session_t;

struct gnutls_session_int {
};

typedef struct hierbox_browser hierbox_browser, *Phierbox_browser;

typedef struct hierbox_browser_button hierbox_browser_button, *Phierbox_browser_button;

struct hierbox_browser_button {
    uchar * label;
    widget_handler_status_T (* handler)(struct dialog_data *, struct widget_data *);
    uint anonymous:1;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
};

struct hierbox_browser {
    uchar * title;
    void (* expansion_callback)(void);
    struct hierbox_browser_button * buttons;
    size_t buttons_size;
    struct list_head_elinks boxes;
    struct list_head_elinks dialogs;
    struct listbox_item root;
    struct listbox_ops * ops;
    struct listbox_data box_data;
    uint do_not_save_state:1;
    undefined field_0x61;
    undefined field_0x62;
    undefined field_0x63;
};

typedef struct hierbox_dialog_list_item hierbox_dialog_list_item, *Phierbox_dialog_list_item;

struct hierbox_dialog_list_item {
    struct hierbox_dialog_list_item * next;
    struct hierbox_dialog_list_item * prev;
    struct dialog_data * dlg_data;
};

typedef struct keys_toggle_info keys_toggle_info, *Pkeys_toggle_info;

struct keys_toggle_info {
    struct terminal * term;
    int toggle;
};

typedef enum addr_type {
    ADDR_ANY_SERVER=2,
    ADDR_IP_CLIENT=0,
    ADDR_IP_SERVER=1
} addr_type;

typedef struct socket_info socket_info, *Psocket_info;


// WARNING! conflicting data type names: /DWARF/socket.h/sockaddr - /socket.h/sockaddr

struct socket_info {
    struct sockaddr * addr;
    int size;
    int fd;
};

typedef enum delete_error {
    DELETE_ERRORS=2,
    DELETE_IMPOSSIBLE=0,
    DELETE_LOCKED=1
} delete_error;

typedef enum __socket_type {
    SOCK_CLOEXEC=524288,
    SOCK_DCCP=6,
    SOCK_DGRAM=2,
    SOCK_NONBLOCK=2048,
    SOCK_PACKET=10,
    SOCK_RAW=3,
    SOCK_RDM=4,
    SOCK_SEQPACKET=5,
    SOCK_STREAM=1
} __socket_type;

typedef void (* socket_write_T)(struct socket *);

typedef enum socket_error {
    SOCKET_CANT_READ=-4,
    SOCKET_CANT_WRITE=-5,
    SOCKET_INTERNAL_ERROR=-2,
    SOCKET_SSL_WANT_READ=-3,
    SOCKET_SYSCALL_ERROR=-1
} socket_error;

typedef enum anon_enum_32 {
    cen=2,
    undecided=0,
    xpg=1
} anon_enum_32;

typedef struct socket_weak_ref socket_weak_ref, *Psocket_weak_ref;

struct socket_weak_ref {
    struct socket_weak_ref * next;
    struct socket_weak_ref * prev;
    struct socket * socket;
};

typedef struct write_buffer write_buffer, *Pwrite_buffer;

struct write_buffer {
    socket_write_T done;
    int length;
    int pos;
    uchar data[1];
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
};

typedef enum pass_uri_type {
    PASS_URI_FRAME=0,
    PASS_URI_LINK=1,
    PASS_URI_TAB=2
} pass_uri_type;

typedef struct open_in_new open_in_new, *Popen_in_new;

struct open_in_new {
    enum term_env_type env;
    uchar * command;
    uchar * text;
};

typedef struct widget_info_text widget_info_text, *Pwidget_info_text;

struct widget_info_text {
    enum format_align align;
    uint is_label:1;
    uint is_scrollable:1;
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
};

typedef enum html_whitespace_state {
    HTML_SPACE_ADD=2,
    HTML_SPACE_NORMAL=1,
    HTML_SPACE_SUPPRESS=0
} html_whitespace_state;

typedef struct negotiate negotiate, *Pnegotiate;

struct negotiate {
    struct negotiate * next;
    struct negotiate * prev;
    struct object object;
    struct uri * uri;
    int type;
    OM_uint32 status;
    gss_ctx_id_t context;
    gss_name_t server_name;
    gss_buffer_desc output_token;
    gss_buffer_desc input_token;
};

typedef struct ewd ewd, *Pewd;

struct ewd {
    void (* fn)(void *);
    void * data;
    uint called_once:1;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
};

typedef struct dummy_enc_data dummy_enc_data, *Pdummy_enc_data;

struct dummy_enc_data {
    int fd;
};

typedef struct decoding_backend decoding_backend, *Pdecoding_backend;

struct decoding_backend {
    uchar * name;
    uchar * * extensions;
    int (* open)(struct stream_encoded *, int);
    int (* read)(struct stream_encoded *, uchar *, int);
    uchar * (* decode_buffer)(uchar *, int, int *);
    void (* close)(struct stream_encoded *);
};

typedef struct sockaddr_un sockaddr_un, *Psockaddr_un;

struct sockaddr_un {
    sa_family_t sun_family;
    char sun_path[108];
};

typedef struct dom_stack_state dom_stack_state, *Pdom_stack_state;

typedef struct dom_node dom_node, *Pdom_node;

typedef union dom_node_data dom_node_data, *Pdom_node_data;

typedef struct dom_document_node dom_document_node, *Pdom_document_node;

typedef struct dom_document_type_node dom_document_type_node, *Pdom_document_type_node;

typedef struct dom_element_node dom_element_node, *Pdom_element_node;

typedef struct dom_attribute_node dom_attribute_node, *Pdom_attribute_node;

typedef struct dom_text_node dom_text_node, *Pdom_text_node;

typedef struct dom_id dom_id, *Pdom_id;

typedef struct dom_proc_instruction_node dom_proc_instruction_node, *Pdom_proc_instruction_node;

typedef struct dom_document dom_document, *Pdom_document;

typedef struct dom_node_list dom_node_list, *Pdom_node_list;

typedef struct dom_doctype_subset_infot dom_doctype_subset_infot, *Pdom_doctype_subset_infot;

struct dom_proc_instruction_node {
    struct dom_string instruction;
    uint16_t type;
    undefined field_0xa;
    undefined field_0xb;
    struct dom_node_list * map;
};

struct dom_text_node {
    uint newlines;
    uint only_space:1;
    uint converted:1;
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
};

struct dom_id {
    struct dom_string public_id;
    struct dom_string system_id;
};

struct dom_document_node {
    struct dom_document * document;
    struct dom_node_list * children;
};

struct dom_attribute_node {
    struct dom_string value;
    uint16_t namespace_offset;
    uint16_t type;
    uchar quoted;
    uint specified:1;
    uint converted:1;
    uint id:1;
    uint reference:1;
    undefined field_0xe;
    undefined field_0xf;
};

struct dom_element_node {
    struct dom_node_list * children;
    struct dom_node_list * map;
    uint16_t namespace_offset;
    uint16_t type;
};

struct dom_document_type_node {
    struct dom_node_list * entities;
    struct dom_node_list * notations;
    struct dom_doctype_subset_infot * subset;
};

union dom_node_data {
    struct dom_document_node document;
    struct dom_document_type_node document_type;
    struct dom_element_node element;
    struct dom_attribute_node attribute;
    struct dom_text_node text;
    struct dom_id notation;
    struct dom_id entity;
    struct dom_proc_instruction_node proc_instruction;
};

struct dom_stack_state {
    struct dom_node * node;
    uint depth;
    uint immutable:1;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
};

struct dom_node {
    uint16_t type;
    uint allocated:1;
    undefined field_0x3;
    struct dom_string string;
    struct dom_node * parent;
    union dom_node_data data;
};

struct dom_node_list {
    size_t size;
    struct dom_node * entries[1];
};

struct dom_document {
};

struct dom_doctype_subset_infot {
};

typedef struct dom_stack_context_info dom_stack_context_info, *Pdom_stack_context_info;

typedef enum dom_code {
    DOM_CODE_ALLOC_ERR=-997,
    DOM_CODE_DOMSTRING_SIZE_ERR=2,
    DOM_CODE_ERR=-1000,
    DOM_CODE_FREE_NODE=-998,
    DOM_CODE_HIERARCHY_REQUEST_ERR=3,
    DOM_CODE_INCOMPLETE=-999,
    DOM_CODE_INDEX_SIZE_ERR=1,
    DOM_CODE_INUSE_ATTRIBUTE_ERR=10,
    DOM_CODE_INVALID_ACCESS_ERR=15,
    DOM_CODE_INVALID_CHARACTER_ERR=5,
    DOM_CODE_INVALID_MODIFICATION_ERR=13,
    DOM_CODE_INVALID_STATE_ERR=11,
    DOM_CODE_MAX_DEPTH_ERR=-996,
    DOM_CODE_NAMESPACE_ERR=14,
    DOM_CODE_NOT_FOUND_ERR=8,
    DOM_CODE_NOT_SUPPORTED_ERR=9,
    DOM_CODE_NO_DATA_ALLOWED_ERR=6,
    DOM_CODE_NO_MODIFICATION_ALLOWED_ERR=7,
    DOM_CODE_OK=0,
    DOM_CODE_SYNTAX_ERR=12,
    DOM_CODE_TYPE_MISMATCH_ERR=17,
    DOM_CODE_VALIDATION_ERR=16,
    DOM_CODE_VALUE_ERR=-995,
    DOM_CODE_WRONG_DOCUMENT_ERR=4
} dom_code;

typedef struct dom_stack dom_stack, *Pdom_stack;

typedef enum dom_stack_flag {
    DOM_STACK_FLAG_FREE_NODES=1,
    DOM_STACK_FLAG_NONE=0
} dom_stack_flag;

typedef struct dom_stack_context dom_stack_context, *Pdom_stack_context;

struct dom_stack_context_info {
    size_t object_size;
    dom_code (* push[13])(struct dom_stack *, struct dom_node *, void *);
    dom_code (* pop[13])(struct dom_stack *, struct dom_node *, void *);
};

struct dom_stack_context {
    void * data;
    uchar * state_objects;
    struct dom_stack_context_info * info;
};

struct dom_stack {
    struct dom_stack_state * states;
    size_t depth;
    enum dom_stack_flag flags;
    struct dom_stack_context * * contexts;
    size_t contexts_size;
    struct dom_stack_context * current;
};


// WARNING! conflicting data type names: /DWARF/time.h/timespec - /time.h/timespec

typedef struct timeval timeval, *Ptimeval;

struct timeval {
    __time_t tv_sec;
    __suseconds_t tv_usec;
};

typedef struct tm tm, *Ptm;

struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long tm_gmtoff;
    char * tm_zone;
};

typedef long milliseconds_T;

typedef struct http_version http_version, *Phttp_version;

struct http_version {
    int major;
    int minor;
};


// WARNING! conflicting data type names: /DWARF/http.c/decompress_data/anon_enum_32 - /DWARF/explodename.c/_nl_explode_name/anon_enum_32

typedef enum css_char_group {
    CSS_CHAR_ALPHA=1,
    CSS_CHAR_DIGIT=2,
    CSS_CHAR_HEX_DIGIT=4,
    CSS_CHAR_IDENT=8,
    CSS_CHAR_IDENT_START=16,
    CSS_CHAR_NEWLINE=32,
    CSS_CHAR_NON_ASCII=64,
    CSS_CHAR_SGML_MARKUP=128,
    CSS_CHAR_TOKEN=256,
    CSS_CHAR_TOKEN_START=512,
    CSS_CHAR_WHITESPACE=1024
} css_char_group;

typedef enum sgml_char_group {
    SGML_CHAR_ENTITY=2,
    SGML_CHAR_IDENT=4,
    SGML_CHAR_NEWLINE=8,
    SGML_CHAR_NOT_ATTRIBUTE=64,
    SGML_CHAR_NOT_TEXT=32,
    SGML_CHAR_WHITESPACE=16
} sgml_char_group;

typedef struct RBasic RBasic, *PRBasic;

typedef ulong VALUE;

struct RBasic {
    ulong flags;
    VALUE klass;
};

typedef union anon_union.conflict11 anon_union.conflict11, *Panon_union.conflict11;

union anon_union.conflict11 {
    long capa;
    VALUE shared;
};

typedef struct RString RString, *PRString;

typedef union anon_union_for_aux anon_union_for_aux, *Panon_union_for_aux;

union anon_union_for_aux {
    long capa;
    VALUE shared;
};

struct RString {
    struct RBasic basic;
    long len;
    char * ptr;
    union anon_union_for_aux aux;
};

typedef ulong ID;

typedef struct dom_scan_table_info dom_scan_table_info, *Pdom_scan_table_info;


// WARNING! conflicting data type names: /DWARF/scanner.h/dom_scan_table_info/anon_enum_32_for_type - /DWARF/scanner.h/scan_table_info/anon_enum_32_for_type

struct dom_scan_table_info {
    enum anon_enum_32_for_type type;
    struct dom_string data;
    int bits;
};

typedef struct dom_scanner dom_scanner, *Pdom_scanner;

typedef struct dom_scanner_token dom_scanner_token, *Pdom_scanner_token;

typedef struct dom_scanner_info dom_scanner_info, *Pdom_scanner_info;

typedef struct dom_scanner_string_mapping dom_scanner_string_mapping, *Pdom_scanner_string_mapping;

struct dom_scanner_info {
    struct dom_scanner_string_mapping * mappings;
    struct dom_scan_table_info * scan_table_info;
    dom_scanner_token * (* scan)(struct dom_scanner *);
    int scan_table[256];
    uint initialized:1;
    undefined field_0x40d;
    undefined field_0x40e;
    undefined field_0x40f;
};

struct dom_scanner_string_mapping {
    struct dom_string name;
    int type;
    int base_type;
};

struct dom_scanner_token {
    int type;
    int precedence;
    uint lineno;
    struct dom_string string;
};

struct dom_scanner {
    uchar * string;
    uchar * end;
    uchar * position;
    struct dom_scanner_token * current;
    int tokens;
    struct dom_scanner_info * info;
    uint check_complete:1;
    uint incomplete:1;
    uint detect_errors:1;
    undefined field_0x19;
    undefined field_0x1a;
    undefined field_0x1b;
    uint found_error;
    uint count_lines:1;
    undefined field_0x21;
    undefined field_0x22;
    undefined field_0x23;
    uint lineno;
    int state;
    struct dom_scanner_token table[10];
};

typedef enum sgml_scanner_state {
    SGML_STATE_ELEMENT=1,
    SGML_STATE_PROC_INST=2,
    SGML_STATE_TEXT=0
} sgml_scanner_state;

typedef struct scan_table_info.conflict scan_table_info.conflict, *Pscan_table_info.conflict;

typedef enum anon_enum_32_for_type.conflict {
    ABDAY_1=131072,
    ABDAY_2=131073,
    ABDAY_3=131074,
    ABDAY_4=131075,
    ABDAY_5=131076,
    ABDAY_6=131077,
    ABDAY_7=131078,
    ABMON_1=131086,
    ABMON_10=131095,
    ABMON_11=131096,
    ABMON_12=131097,
    ABMON_2=131087,
    ABMON_3=131088,
    ABMON_4=131089,
    ABMON_5=131090,
    ABMON_6=131091,
    ABMON_7=131092,
    ABMON_8=131093,
    ABMON_9=131094,
    ALT_DIGITS=131119,
    AM_STR=131110,
    CODESET=14,
    COMMON_DOWNLOAD_DO=0,
    CONTINUE_DOWNLOAD_DO=1,
    DAY_1=131079,
    DAY_2=131080,
    DAY_3=131081,
    DAY_4=131082,
    DAY_5=131083,
    DAY_6=131084,
    DAY_7=131085,
    DOM_SCAN_END=2,
    DOM_SCAN_RANGE=0,
    DOM_SCAN_STRING=1,
    D_FMT=131113,
    D_T_FMT=131112,
    ERA=131116,
    ERA_D_FMT=131118,
    ERA_D_T_FMT=131120,
    ERA_T_FMT=131121,
    GNUTLS_CLIENT=2,
    GNUTLS_CRD_ANON=2,
    GNUTLS_CRD_CERTIFICATE=1,
    GNUTLS_CRD_IA=5,
    GNUTLS_CRD_PSK=4,
    GNUTLS_CRD_SRP=3,
    GNUTLS_KX_ANON_DH=4,
    GNUTLS_KX_DHE_DSS=2,
    GNUTLS_KX_DHE_PSK=10,
    GNUTLS_KX_DHE_RSA=3,
    GNUTLS_KX_PSK=9,
    GNUTLS_KX_RSA=1,
    GNUTLS_KX_RSA_EXPORT=6,
    GNUTLS_KX_SRP=5,
    GNUTLS_KX_SRP_DSS=8,
    GNUTLS_KX_SRP_RSA=7,
    GNUTLS_KX_UNKNOWN=0,
    GNUTLS_MAC_MD2=5,
    GNUTLS_MAC_MD5=2,
    GNUTLS_MAC_NULL=1,
    GNUTLS_MAC_RMD160=4,
    GNUTLS_MAC_SHA1=3,
    GNUTLS_MAC_SHA256=6,
    GNUTLS_MAC_SHA384=7,
    GNUTLS_MAC_SHA512=8,
    GNUTLS_MAC_UNKNOWN=0,
    GNUTLS_SERVER=1,
    GNUTLS_SHUT_RDWR=0,
    GNUTLS_SHUT_WR=1,
    GNUTLS_SSL3=1,
    GNUTLS_TLS1_0=2,
    GNUTLS_TLS1_1=3,
    GNUTLS_TLS1_2=4,
    GNUTLS_VERSION_UNKNOWN=255,
    GNUTLS_X509_FMT_DER=0,
    GNUTLS_X509_FMT_PEM=1,
    IDNA_CONTAINS_ACE_PREFIX=8,
    IDNA_CONTAINS_LDH=3,
    IDNA_CONTAINS_MINUS=4,
    IDNA_CONTAINS_NON_LDH=3,
    IDNA_DLOPEN_ERROR=202,
    IDNA_ICONV_ERROR=9,
    IDNA_INVALID_LENGTH=5,
    IDNA_MALLOC_ERROR=201,
    IDNA_NO_ACE_PREFIX=6,
    IDNA_PUNYCODE_ERROR=2,
    IDNA_ROUNDTRIP_VERIFY_ERROR=7,
    IDNA_STRINGPREP_ERROR=1,
    IDNA_SUCCESS=0,
    IPPROTO_AH=51,
    IPPROTO_COMP=108,
    IPPROTO_DCCP=33,
    IPPROTO_DSTOPTS=60,
    IPPROTO_EGP=8,
    IPPROTO_ENCAP=98,
    IPPROTO_ESP=50,
    IPPROTO_FRAGMENT=44,
    IPPROTO_GRE=47,
    IPPROTO_HOPOPTS=0,
    IPPROTO_ICMP=1,
    IPPROTO_ICMPV6=58,
    IPPROTO_IDP=22,
    IPPROTO_IGMP=2,
    IPPROTO_IP=0,
    IPPROTO_IPIP=4,
    IPPROTO_IPV6=41,
    IPPROTO_MAX=256,
    IPPROTO_MTP=92,
    IPPROTO_NONE=59,
    IPPROTO_PIM=103,
    IPPROTO_PUP=12,
    IPPROTO_RAW=255,
    IPPROTO_ROUTING=43,
    IPPROTO_RSVP=46,
    IPPROTO_SCTP=132,
    IPPROTO_TCP=6,
    IPPROTO_TP=29,
    IPPROTO_UDP=17,
    IPPROTO_UDPLITE=136,
    KP_MARK_GOTO=2,
    KP_MARK_NOTHING=0,
    KP_MARK_SET=1,
    MON_1=131098,
    MON_10=131107,
    MON_11=131108,
    MON_12=131109,
    MON_2=131099,
    MON_3=131100,
    MON_4=131101,
    MON_5=131102,
    MON_6=131103,
    MON_7=131104,
    MON_8=131105,
    MON_9=131106,
    PM_STR=131111,
    RADIXCHAR=65536,
    SCAN_END=2,
    SCAN_RANGE=0,
    SCAN_STRING=1,
    TERM_FN_RESIZE=2,
    TERM_FN_TITLE=1,
    TERM_FN_TITLE_CODEPAGE=3,
    THOUSEP=65537,
    T_FMT=131114,
    T_FMT_AMPM=131115,
    _DATE_FMT=131180,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096,
    _NL_ADDRESS_CODESET=589836,
    _NL_ADDRESS_COUNTRY_AB2=589827,
    _NL_ADDRESS_COUNTRY_AB3=589828,
    _NL_ADDRESS_COUNTRY_CAR=589829,
    _NL_ADDRESS_COUNTRY_ISBN=589831,
    _NL_ADDRESS_COUNTRY_NAME=589825,
    _NL_ADDRESS_COUNTRY_NUM=589830,
    _NL_ADDRESS_COUNTRY_POST=589826,
    _NL_ADDRESS_LANG_AB=589833,
    _NL_ADDRESS_LANG_LIB=589835,
    _NL_ADDRESS_LANG_NAME=589832,
    _NL_ADDRESS_LANG_TERM=589834,
    _NL_ADDRESS_POSTAL_FMT=589824,
    _NL_COLLATE_CODESET=196626,
    _NL_COLLATE_COLLSEQMB=196624,
    _NL_COLLATE_COLLSEQWC=196625,
    _NL_COLLATE_EXTRAMB=196612,
    _NL_COLLATE_EXTRAWC=196619,
    _NL_COLLATE_GAP1=196614,
    _NL_COLLATE_GAP2=196615,
    _NL_COLLATE_GAP3=196616,
    _NL_COLLATE_INDIRECTMB=196613,
    _NL_COLLATE_INDIRECTWC=196620,
    _NL_COLLATE_NRULES=196608,
    _NL_COLLATE_RULESETS=196609,
    _NL_COLLATE_SYMB_EXTRAMB=196623,
    _NL_COLLATE_SYMB_HASH_SIZEMB=196621,
    _NL_COLLATE_SYMB_TABLEMB=196622,
    _NL_COLLATE_TABLEMB=196610,
    _NL_COLLATE_TABLEWC=196617,
    _NL_COLLATE_WEIGHTMB=196611,
    _NL_COLLATE_WEIGHTWC=196618,
    _NL_CTYPE_CLASS=0,
    _NL_CTYPE_CLASS32=5,
    _NL_CTYPE_CLASS_NAMES=10,
    _NL_CTYPE_CLASS_OFFSET=17,
    _NL_CTYPE_CODESET_NAME=14,
    _NL_CTYPE_EXTRA_MAP_1=72,
    _NL_CTYPE_EXTRA_MAP_10=81,
    _NL_CTYPE_EXTRA_MAP_11=82,
    _NL_CTYPE_EXTRA_MAP_12=83,
    _NL_CTYPE_EXTRA_MAP_13=84,
    _NL_CTYPE_EXTRA_MAP_14=85,
    _NL_CTYPE_EXTRA_MAP_2=73,
    _NL_CTYPE_EXTRA_MAP_3=74,
    _NL_CTYPE_EXTRA_MAP_4=75,
    _NL_CTYPE_EXTRA_MAP_5=76,
    _NL_CTYPE_EXTRA_MAP_6=77,
    _NL_CTYPE_EXTRA_MAP_7=78,
    _NL_CTYPE_EXTRA_MAP_8=79,
    _NL_CTYPE_EXTRA_MAP_9=80,
    _NL_CTYPE_GAP1=2,
    _NL_CTYPE_GAP2=4,
    _NL_CTYPE_GAP3=6,
    _NL_CTYPE_GAP4=7,
    _NL_CTYPE_GAP5=8,
    _NL_CTYPE_GAP6=9,
    _NL_CTYPE_INDIGITS0_MB=20,
    _NL_CTYPE_INDIGITS0_WC=31,
    _NL_CTYPE_INDIGITS1_MB=21,
    _NL_CTYPE_INDIGITS1_WC=32,
    _NL_CTYPE_INDIGITS2_MB=22,
    _NL_CTYPE_INDIGITS2_WC=33,
    _NL_CTYPE_INDIGITS3_MB=23,
    _NL_CTYPE_INDIGITS3_WC=34,
    _NL_CTYPE_INDIGITS4_MB=24,
    _NL_CTYPE_INDIGITS4_WC=35,
    _NL_CTYPE_INDIGITS5_MB=25,
    _NL_CTYPE_INDIGITS5_WC=36,
    _NL_CTYPE_INDIGITS6_MB=26,
    _NL_CTYPE_INDIGITS6_WC=37,
    _NL_CTYPE_INDIGITS7_MB=27,
    _NL_CTYPE_INDIGITS7_WC=38,
    _NL_CTYPE_INDIGITS8_MB=28,
    _NL_CTYPE_INDIGITS8_WC=39,
    _NL_CTYPE_INDIGITS9_MB=29,
    _NL_CTYPE_INDIGITS9_WC=40,
    _NL_CTYPE_INDIGITS_MB_LEN=19,
    _NL_CTYPE_INDIGITS_WC_LEN=30,
    _NL_CTYPE_MAP_NAMES=11,
    _NL_CTYPE_MAP_OFFSET=18,
    _NL_CTYPE_MAP_TO_NONASCII=70,
    _NL_CTYPE_MB_CUR_MAX=13,
    _NL_CTYPE_NONASCII_CASE=71,
    _NL_CTYPE_OUTDIGIT0_MB=41,
    _NL_CTYPE_OUTDIGIT0_WC=51,
    _NL_CTYPE_OUTDIGIT1_MB=42,
    _NL_CTYPE_OUTDIGIT1_WC=52,
    _NL_CTYPE_OUTDIGIT2_MB=43,
    _NL_CTYPE_OUTDIGIT2_WC=53,
    _NL_CTYPE_OUTDIGIT3_MB=44,
    _NL_CTYPE_OUTDIGIT3_WC=54,
    _NL_CTYPE_OUTDIGIT4_MB=45,
    _NL_CTYPE_OUTDIGIT4_WC=55,
    _NL_CTYPE_OUTDIGIT5_MB=46,
    _NL_CTYPE_OUTDIGIT5_WC=56,
    _NL_CTYPE_OUTDIGIT6_MB=47,
    _NL_CTYPE_OUTDIGIT6_WC=57,
    _NL_CTYPE_OUTDIGIT7_MB=48,
    _NL_CTYPE_OUTDIGIT7_WC=58,
    _NL_CTYPE_OUTDIGIT8_MB=49,
    _NL_CTYPE_OUTDIGIT8_WC=59,
    _NL_CTYPE_OUTDIGIT9_MB=50,
    _NL_CTYPE_OUTDIGIT9_WC=60,
    _NL_CTYPE_TOLOWER=3,
    _NL_CTYPE_TOLOWER32=16,
    _NL_CTYPE_TOUPPER=1,
    _NL_CTYPE_TOUPPER32=15,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING=67,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN=66,
    _NL_CTYPE_TRANSLIT_FROM_IDX=62,
    _NL_CTYPE_TRANSLIT_FROM_TBL=63,
    _NL_CTYPE_TRANSLIT_IGNORE=69,
    _NL_CTYPE_TRANSLIT_IGNORE_LEN=68,
    _NL_CTYPE_TRANSLIT_TAB_SIZE=61,
    _NL_CTYPE_TRANSLIT_TO_IDX=64,
    _NL_CTYPE_TRANSLIT_TO_TBL=65,
    _NL_CTYPE_WIDTH=12,
    _NL_IDENTIFICATION_ABBREVIATION=786443,
    _NL_IDENTIFICATION_ADDRESS=786434,
    _NL_IDENTIFICATION_APPLICATION=786442,
    _NL_IDENTIFICATION_AUDIENCE=786441,
    _NL_IDENTIFICATION_CATEGORY=786446,
    _NL_IDENTIFICATION_CODESET=786447,
    _NL_IDENTIFICATION_CONTACT=786435,
    _NL_IDENTIFICATION_DATE=786445,
    _NL_IDENTIFICATION_EMAIL=786436,
    _NL_IDENTIFICATION_FAX=786438,
    _NL_IDENTIFICATION_LANGUAGE=786439,
    _NL_IDENTIFICATION_REVISION=786444,
    _NL_IDENTIFICATION_SOURCE=786433,
    _NL_IDENTIFICATION_TEL=786437,
    _NL_IDENTIFICATION_TERRITORY=786440,
    _NL_IDENTIFICATION_TITLE=786432,
    _NL_MEASUREMENT_CODESET=720897,
    _NL_MEASUREMENT_MEASUREMENT=720896,
    _NL_MESSAGES_CODESET=327684,
    _NL_MONETARY_CODESET=262189,
    _NL_MONETARY_CONVERSION_RATE=262186,
    _NL_MONETARY_CRNCYSTR=262159,
    _NL_MONETARY_DECIMAL_POINT_WC=262187,
    _NL_MONETARY_DUO_CURRENCY_SYMBOL=262167,
    _NL_MONETARY_DUO_FRAC_DIGITS=262169,
    _NL_MONETARY_DUO_INT_CURR_SYMBOL=262166,
    _NL_MONETARY_DUO_INT_FRAC_DIGITS=262168,
    _NL_MONETARY_DUO_INT_N_CS_PRECEDES=262176,
    _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE=262177,
    _NL_MONETARY_DUO_INT_N_SIGN_POSN=262181,
    _NL_MONETARY_DUO_INT_P_CS_PRECEDES=262174,
    _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE=262175,
    _NL_MONETARY_DUO_INT_P_SIGN_POSN=262180,
    _NL_MONETARY_DUO_N_CS_PRECEDES=262172,
    _NL_MONETARY_DUO_N_SEP_BY_SPACE=262173,
    _NL_MONETARY_DUO_N_SIGN_POSN=262179,
    _NL_MONETARY_DUO_P_CS_PRECEDES=262170,
    _NL_MONETARY_DUO_P_SEP_BY_SPACE=262171,
    _NL_MONETARY_DUO_P_SIGN_POSN=262178,
    _NL_MONETARY_DUO_VALID_FROM=262184,
    _NL_MONETARY_DUO_VALID_TO=262185,
    _NL_MONETARY_THOUSANDS_SEP_WC=262188,
    _NL_MONETARY_UNO_VALID_FROM=262182,
    _NL_MONETARY_UNO_VALID_TO=262183,
    _NL_NAME_CODESET=524294,
    _NL_NAME_NAME_FMT=524288,
    _NL_NAME_NAME_GEN=524289,
    _NL_NAME_NAME_MISS=524292,
    _NL_NAME_NAME_MR=524290,
    _NL_NAME_NAME_MRS=524291,
    _NL_NAME_NAME_MS=524293,
    _NL_NUM=786449,
    _NL_NUMERIC_CODESET=65541,
    _NL_NUMERIC_DECIMAL_POINT_WC=65539,
    _NL_NUMERIC_THOUSANDS_SEP_WC=65540,
    _NL_NUM_LC_ADDRESS=589837,
    _NL_NUM_LC_COLLATE=196627,
    _NL_NUM_LC_CTYPE=86,
    _NL_NUM_LC_IDENTIFICATION=786448,
    _NL_NUM_LC_MEASUREMENT=720898,
    _NL_NUM_LC_MESSAGES=327685,
    _NL_NUM_LC_MONETARY=262190,
    _NL_NUM_LC_NAME=524295,
    _NL_NUM_LC_NUMERIC=65542,
    _NL_NUM_LC_PAPER=458755,
    _NL_NUM_LC_TELEPHONE=655365,
    _NL_NUM_LC_TIME=131183,
    _NL_PAPER_CODESET=458754,
    _NL_PAPER_HEIGHT=458752,
    _NL_PAPER_WIDTH=458753,
    _NL_TELEPHONE_CODESET=655364,
    _NL_TELEPHONE_INT_PREFIX=655363,
    _NL_TELEPHONE_INT_SELECT=655362,
    _NL_TELEPHONE_TEL_DOM_FMT=655361,
    _NL_TELEPHONE_TEL_INT_FMT=655360,
    _NL_TIME_CAL_DIRECTION=131178,
    _NL_TIME_CODESET=131182,
    _NL_TIME_ERA_ENTRIES=131123,
    _NL_TIME_ERA_NUM_ENTRIES=131122,
    _NL_TIME_FIRST_WEEKDAY=131176,
    _NL_TIME_FIRST_WORKDAY=131177,
    _NL_TIME_TIMEZONE=131179,
    _NL_TIME_WEEK_1STDAY=131174,
    _NL_TIME_WEEK_1STWEEK=131175,
    _NL_TIME_WEEK_NDAYS=131173,
    _NL_WABDAY_1=131124,
    _NL_WABDAY_2=131125,
    _NL_WABDAY_3=131126,
    _NL_WABDAY_4=131127,
    _NL_WABDAY_5=131128,
    _NL_WABDAY_6=131129,
    _NL_WABDAY_7=131130,
    _NL_WABMON_1=131138,
    _NL_WABMON_10=131147,
    _NL_WABMON_11=131148,
    _NL_WABMON_12=131149,
    _NL_WABMON_2=131139,
    _NL_WABMON_3=131140,
    _NL_WABMON_4=131141,
    _NL_WABMON_5=131142,
    _NL_WABMON_6=131143,
    _NL_WABMON_7=131144,
    _NL_WABMON_8=131145,
    _NL_WABMON_9=131146,
    _NL_WALT_DIGITS=131170,
    _NL_WAM_STR=131162,
    _NL_WDAY_1=131131,
    _NL_WDAY_2=131132,
    _NL_WDAY_3=131133,
    _NL_WDAY_4=131134,
    _NL_WDAY_5=131135,
    _NL_WDAY_6=131136,
    _NL_WDAY_7=131137,
    _NL_WD_FMT=131165,
    _NL_WD_T_FMT=131164,
    _NL_WERA_D_FMT=131169,
    _NL_WERA_D_T_FMT=131171,
    _NL_WERA_T_FMT=131172,
    _NL_WERA_YEAR=131168,
    _NL_WMON_1=131150,
    _NL_WMON_10=131159,
    _NL_WMON_11=131160,
    _NL_WMON_12=131161,
    _NL_WMON_2=131151,
    _NL_WMON_3=131152,
    _NL_WMON_4=131153,
    _NL_WMON_5=131154,
    _NL_WMON_6=131155,
    _NL_WMON_7=131156,
    _NL_WMON_8=131157,
    _NL_WMON_9=131158,
    _NL_WPM_STR=131163,
    _NL_WT_FMT=131166,
    _NL_WT_FMT_AMPM=131167,
    _NL_W_DATE_FMT=131181,
    _SC_2_CHAR_TERM=95,
    _SC_2_C_BIND=47,
    _SC_2_C_DEV=48,
    _SC_2_C_VERSION=96,
    _SC_2_FORT_DEV=49,
    _SC_2_FORT_RUN=50,
    _SC_2_LOCALEDEF=52,
    _SC_2_PBS=168,
    _SC_2_PBS_ACCOUNTING=169,
    _SC_2_PBS_CHECKPOINT=175,
    _SC_2_PBS_LOCATE=170,
    _SC_2_PBS_MESSAGE=171,
    _SC_2_PBS_TRACK=172,
    _SC_2_SW_DEV=51,
    _SC_2_UPE=97,
    _SC_2_VERSION=46,
    _SC_ADVISORY_INFO=132,
    _SC_AIO_LISTIO_MAX=23,
    _SC_AIO_MAX=24,
    _SC_AIO_PRIO_DELTA_MAX=25,
    _SC_ARG_MAX=0,
    _SC_ASYNCHRONOUS_IO=12,
    _SC_ATEXIT_MAX=87,
    _SC_AVPHYS_PAGES=86,
    _SC_BARRIERS=133,
    _SC_BASE=134,
    _SC_BC_BASE_MAX=36,
    _SC_BC_DIM_MAX=37,
    _SC_BC_SCALE_MAX=38,
    _SC_BC_STRING_MAX=39,
    _SC_CHARCLASS_NAME_MAX=45,
    _SC_CHAR_BIT=101,
    _SC_CHAR_MAX=102,
    _SC_CHAR_MIN=103,
    _SC_CHILD_MAX=1,
    _SC_CLK_TCK=2,
    _SC_CLOCK_SELECTION=137,
    _SC_COLL_WEIGHTS_MAX=40,
    _SC_CPUTIME=138,
    _SC_C_LANG_SUPPORT=135,
    _SC_C_LANG_SUPPORT_R=136,
    _SC_DELAYTIMER_MAX=26,
    _SC_DEVICE_IO=140,
    _SC_DEVICE_SPECIFIC=141,
    _SC_DEVICE_SPECIFIC_R=142,
    _SC_EQUIV_CLASS_MAX=41,
    _SC_EXPR_NEST_MAX=42,
    _SC_FD_MGMT=143,
    _SC_FIFO=144,
    _SC_FILE_ATTRIBUTES=146,
    _SC_FILE_LOCKING=147,
    _SC_FILE_SYSTEM=148,
    _SC_FSYNC=15,
    _SC_GETGR_R_SIZE_MAX=69,
    _SC_GETPW_R_SIZE_MAX=70,
    _SC_HOST_NAME_MAX=180,
    _SC_INT_MAX=104,
    _SC_INT_MIN=105,
    _SC_IOV_MAX=60,
    _SC_IPV6=235,
    _SC_JOB_CONTROL=7,
    _SC_LEVEL1_DCACHE_ASSOC=189,
    _SC_LEVEL1_DCACHE_LINESIZE=190,
    _SC_LEVEL1_DCACHE_SIZE=188,
    _SC_LEVEL1_ICACHE_ASSOC=186,
    _SC_LEVEL1_ICACHE_LINESIZE=187,
    _SC_LEVEL1_ICACHE_SIZE=185,
    _SC_LEVEL2_CACHE_ASSOC=192,
    _SC_LEVEL2_CACHE_LINESIZE=193,
    _SC_LEVEL2_CACHE_SIZE=191,
    _SC_LEVEL3_CACHE_ASSOC=195,
    _SC_LEVEL3_CACHE_LINESIZE=196,
    _SC_LEVEL3_CACHE_SIZE=194,
    _SC_LEVEL4_CACHE_ASSOC=198,
    _SC_LEVEL4_CACHE_LINESIZE=199,
    _SC_LEVEL4_CACHE_SIZE=197,
    _SC_LINE_MAX=43,
    _SC_LOGIN_NAME_MAX=71,
    _SC_LONG_BIT=106,
    _SC_MAPPED_FILES=16,
    _SC_MB_LEN_MAX=108,
    _SC_MEMLOCK=17,
    _SC_MEMLOCK_RANGE=18,
    _SC_MEMORY_PROTECTION=19,
    _SC_MESSAGE_PASSING=20,
    _SC_MONOTONIC_CLOCK=149,
    _SC_MQ_OPEN_MAX=27,
    _SC_MQ_PRIO_MAX=28,
    _SC_MULTI_PROCESS=150,
    _SC_NETWORKING=152,
    _SC_NGROUPS_MAX=3,
    _SC_NL_ARGMAX=119,
    _SC_NL_LANGMAX=120,
    _SC_NL_MSGMAX=121,
    _SC_NL_NMAX=122,
    _SC_NL_SETMAX=123,
    _SC_NL_TEXTMAX=124,
    _SC_NPROCESSORS_CONF=83,
    _SC_NPROCESSORS_ONLN=84,
    _SC_NZERO=109,
    _SC_OPEN_MAX=4,
    _SC_PAGESIZE=30,
    _SC_PASS_MAX=88,
    _SC_PHYS_PAGES=85,
    _SC_PII=53,
    _SC_PII_INTERNET=56,
    _SC_PII_INTERNET_DGRAM=62,
    _SC_PII_INTERNET_STREAM=61,
    _SC_PII_OSI=57,
    _SC_PII_OSI_CLTS=64,
    _SC_PII_OSI_COTS=63,
    _SC_PII_OSI_M=65,
    _SC_PII_SOCKET=55,
    _SC_PII_XTI=54,
    _SC_PIPE=145,
    _SC_POLL=58,
    _SC_PRIORITIZED_IO=13,
    _SC_PRIORITY_SCHEDULING=10,
    _SC_RAW_SOCKETS=236,
    _SC_READER_WRITER_LOCKS=153,
    _SC_REALTIME_SIGNALS=9,
    _SC_REGEXP=155,
    _SC_REGEX_VERSION=156,
    _SC_RE_DUP_MAX=44,
    _SC_RTSIG_MAX=31,
    _SC_SAVED_IDS=8,
    _SC_SCHAR_MAX=111,
    _SC_SCHAR_MIN=112,
    _SC_SELECT=59,
    _SC_SEMAPHORES=21,
    _SC_SEM_NSEMS_MAX=32,
    _SC_SEM_VALUE_MAX=33,
    _SC_SHARED_MEMORY_OBJECTS=22,
    _SC_SHELL=157,
    _SC_SHRT_MAX=113,
    _SC_SHRT_MIN=114,
    _SC_SIGNALS=158,
    _SC_SIGQUEUE_MAX=34,
    _SC_SINGLE_PROCESS=151,
    _SC_SPAWN=159,
    _SC_SPIN_LOCKS=154,
    _SC_SPORADIC_SERVER=160,
    _SC_SSIZE_MAX=110,
    _SC_SS_REPL_MAX=241,
    _SC_STREAMS=174,
    _SC_STREAM_MAX=5,
    _SC_SYMLOOP_MAX=173,
    _SC_SYNCHRONIZED_IO=14,
    _SC_SYSTEM_DATABASE=162,
    _SC_SYSTEM_DATABASE_R=163,
    _SC_THREADS=67,
    _SC_THREAD_ATTR_STACKADDR=77,
    _SC_THREAD_ATTR_STACKSIZE=78,
    _SC_THREAD_CPUTIME=139,
    _SC_THREAD_DESTRUCTOR_ITERATIONS=73,
    _SC_THREAD_KEYS_MAX=74,
    _SC_THREAD_PRIORITY_SCHEDULING=79,
    _SC_THREAD_PRIO_INHERIT=80,
    _SC_THREAD_PRIO_PROTECT=81,
    _SC_THREAD_PROCESS_SHARED=82,
    _SC_THREAD_ROBUST_PRIO_INHERIT=247,
    _SC_THREAD_ROBUST_PRIO_PROTECT=248,
    _SC_THREAD_SAFE_FUNCTIONS=68,
    _SC_THREAD_SPORADIC_SERVER=161,
    _SC_THREAD_STACK_MIN=75,
    _SC_THREAD_THREADS_MAX=76,
    _SC_TIMEOUTS=164,
    _SC_TIMERS=11,
    _SC_TIMER_MAX=35,
    _SC_TRACE=181,
    _SC_TRACE_EVENT_FILTER=182,
    _SC_TRACE_EVENT_NAME_MAX=242,
    _SC_TRACE_INHERIT=183,
    _SC_TRACE_LOG=184,
    _SC_TRACE_NAME_MAX=243,
    _SC_TRACE_SYS_MAX=244,
    _SC_TRACE_USER_EVENT_MAX=245,
    _SC_TTY_NAME_MAX=72,
    _SC_TYPED_MEMORY_OBJECTS=165,
    _SC_TZNAME_MAX=6,
    _SC_T_IOV_MAX=66,
    _SC_UCHAR_MAX=115,
    _SC_UINT_MAX=116,
    _SC_UIO_MAXIOV=60,
    _SC_ULONG_MAX=117,
    _SC_USER_GROUPS=166,
    _SC_USER_GROUPS_R=167,
    _SC_USHRT_MAX=118,
    _SC_V6_ILP32_OFF32=176,
    _SC_V6_ILP32_OFFBIG=177,
    _SC_V6_LP64_OFF64=178,
    _SC_V6_LPBIG_OFFBIG=179,
    _SC_V7_ILP32_OFF32=237,
    _SC_V7_ILP32_OFFBIG=238,
    _SC_V7_LP64_OFF64=239,
    _SC_V7_LPBIG_OFFBIG=240,
    _SC_VERSION=29,
    _SC_WORD_BIT=107,
    _SC_XBS5_ILP32_OFF32=125,
    _SC_XBS5_ILP32_OFFBIG=126,
    _SC_XBS5_LP64_OFF64=127,
    _SC_XBS5_LPBIG_OFFBIG=128,
    _SC_XOPEN_CRYPT=92,
    _SC_XOPEN_ENH_I18N=93,
    _SC_XOPEN_LEGACY=129,
    _SC_XOPEN_REALTIME=130,
    _SC_XOPEN_REALTIME_THREADS=131,
    _SC_XOPEN_SHM=94,
    _SC_XOPEN_STREAMS=246,
    _SC_XOPEN_UNIX=91,
    _SC_XOPEN_VERSION=89,
    _SC_XOPEN_XCU_VERSION=90,
    _SC_XOPEN_XPG2=98,
    _SC_XOPEN_XPG3=99,
    _SC_XOPEN_XPG4=100,
    __CURRENCY_SYMBOL=262145,
    __DECIMAL_POINT=65536,
    __ERA_YEAR=131117,
    __FRAC_DIGITS=262152,
    __GROUPING=65538,
    __INT_CURR_SYMBOL=262144,
    __INT_FRAC_DIGITS=262151,
    __INT_N_CS_PRECEDES=262162,
    __INT_N_SEP_BY_SPACE=262163,
    __INT_N_SIGN_POSN=262165,
    __INT_P_CS_PRECEDES=262160,
    __INT_P_SEP_BY_SPACE=262161,
    __INT_P_SIGN_POSN=262164,
    __LC_ADDRESS=9,
    __LC_ALL=6,
    __LC_COLLATE=3,
    __LC_CTYPE=0,
    __LC_IDENTIFICATION=12,
    __LC_MEASUREMENT=11,
    __LC_MESSAGES=5,
    __LC_MONETARY=4,
    __LC_NAME=8,
    __LC_NUMERIC=1,
    __LC_PAPER=7,
    __LC_TELEPHONE=10,
    __LC_TIME=2,
    __MON_DECIMAL_POINT=262146,
    __MON_GROUPING=262148,
    __MON_THOUSANDS_SEP=262147,
    __NEGATIVE_SIGN=262150,
    __NOEXPR=327681,
    __NOSTR=327683,
    __N_CS_PRECEDES=262155,
    __N_SEP_BY_SPACE=262156,
    __N_SIGN_POSN=262158,
    __POSITIVE_SIGN=262149,
    __P_CS_PRECEDES=262153,
    __P_SEP_BY_SPACE=262154,
    __P_SIGN_POSN=262157,
    __THOUSANDS_SEP=65537,
    __YESEXPR=327680,
    __YESSTR=327682
} anon_enum_32_for_type.conflict;

struct scan_table_info.conflict {
    enum anon_enum_32_for_type.conflict type;
    union scan_table_data data;
    int bits;
};

typedef enum css_token_type {
    CSS_TOKEN_ANGLE=260,
    CSS_TOKEN_AT_CHARSET=273,
    CSS_TOKEN_AT_FONT_FACE=274,
    CSS_TOKEN_AT_IMPORT=275,
    CSS_TOKEN_AT_KEYWORD=272,
    CSS_TOKEN_AT_MEDIA=276,
    CSS_TOKEN_AT_PAGE=277,
    CSS_TOKEN_DIMENSION=261,
    CSS_TOKEN_EM=262,
    CSS_TOKEN_EX=263,
    CSS_TOKEN_FREQUENCY=264,
    CSS_TOKEN_FUNCTION=269,
    CSS_TOKEN_GARBAGE=284,
    CSS_TOKEN_HASH=267,
    CSS_TOKEN_HEX_COLOR=268,
    CSS_TOKEN_IDENT=256,
    CSS_TOKEN_IMPORTANT=278,
    CSS_TOKEN_LENGTH=265,
    CSS_TOKEN_NONE=0,
    CSS_TOKEN_NUMBER=257,
    CSS_TOKEN_PERCENTAGE=258,
    CSS_TOKEN_RGB=270,
    CSS_TOKEN_SELECT_BEGIN=281,
    CSS_TOKEN_SELECT_CONTAINS=283,
    CSS_TOKEN_SELECT_END=282,
    CSS_TOKEN_SELECT_HYPHEN_LIST=280,
    CSS_TOKEN_SELECT_SPACE_LIST=279,
    CSS_TOKEN_SKIP=285,
    CSS_TOKEN_STRING=259,
    CSS_TOKEN_TIME=266,
    CSS_TOKEN_URL=271
} css_token_type;

typedef enum sgml_token_type {
    SGML_TOKEN_ATTRIBUTE=274,
    SGML_TOKEN_CDATA_SECTION=265,
    SGML_TOKEN_ELEMENT=270,
    SGML_TOKEN_ELEMENT_BEGIN=271,
    SGML_TOKEN_ELEMENT_EMPTY_END=273,
    SGML_TOKEN_ELEMENT_END=272,
    SGML_TOKEN_ENTITY=275,
    SGML_TOKEN_ERROR=280,
    SGML_TOKEN_GARBAGE=278,
    SGML_TOKEN_IDENT=256,
    SGML_TOKEN_INCOMPLETE=279,
    SGML_TOKEN_NONE=0,
    SGML_TOKEN_NOTATION=259,
    SGML_TOKEN_NOTATION_ATTLIST=264,
    SGML_TOKEN_NOTATION_COMMENT=260,
    SGML_TOKEN_NOTATION_DOCTYPE=261,
    SGML_TOKEN_NOTATION_ELEMENT=262,
    SGML_TOKEN_NOTATION_ENTITY=263,
    SGML_TOKEN_PROCESS=266,
    SGML_TOKEN_PROCESS_DATA=269,
    SGML_TOKEN_PROCESS_XML=267,
    SGML_TOKEN_PROCESS_XML_STYLESHEET=268,
    SGML_TOKEN_SKIP=281,
    SGML_TOKEN_SPACE=277,
    SGML_TOKEN_STRING=258,
    SGML_TOKEN_TAG_END=257,
    SGML_TOKEN_TEXT=276
} sgml_token_type;

typedef void * iconv_t;

typedef struct directory_entry directory_entry, *Pdirectory_entry;

struct directory_entry {
    uchar * attrib;
    uchar * name;
};

typedef struct group group, *Pgroup;

struct group {
    char * gr_name;
    char * gr_passwd;
    __gid_t gr_gid;
    char * * gr_mem;
};


// WARNING! conflicting data type names: /DWARF/termios.h/termios - /termios.h/termios

typedef struct bookmark bookmark, *Pbookmark;

struct bookmark {
    struct bookmark * next;
    struct bookmark * prev;
    struct object object;
    struct bookmark * root;
    struct listbox_item * box_item;
    uchar * title;
    uchar * url;
    struct list_head_elinks child;
};

typedef struct about_page about_page, *Pabout_page;

struct about_page {
    uchar * name;
    uchar * string;
};

typedef enum term_exec {
    TERM_EXEC_BG=0,
    TERM_EXEC_FG=1,
    TERM_EXEC_NEWWIN=2
} term_exec;

typedef struct bookmark_search_ctx bookmark_search_ctx, *Pbookmark_search_ctx;

struct bookmark_search_ctx {
    uchar * url;
    uchar * title;
    int found;
    int offset;
    int utf8_cp;
    int system_cp;
};

typedef struct kbdbind_add_hop kbdbind_add_hop, *Pkbdbind_add_hop;

typedef long action_id_T;

typedef enum keymap_id {
    KEYMAP_EDIT=1,
    KEYMAP_INVALID=-1,
    KEYMAP_MAIN=0,
    KEYMAP_MAX=3,
    KEYMAP_MENU=2
} keymap_id;

typedef struct term_event_keyboard term_event_keyboard, *Pterm_event_keyboard;

typedef int int32_t;

typedef int32_t term_event_key_T;

struct term_event_keyboard {
    term_event_key_T key;
    enum term_event_modifier_T modifier;
};

struct kbdbind_add_hop {
    struct terminal * term;
    action_id_T action_id;
    enum keymap_id keymap_id;
    struct term_event_keyboard kbd;
    struct widget_data * widget_data;
};

typedef struct extension extension, *Pextension;

struct extension {
    uchar ext_orig[1024];
    uchar ext[1024];
    uchar ct[1024];
};

typedef enum move_bookmark_flags {
    MOVE_BOOKMARK_CYCLE=2,
    MOVE_BOOKMARK_MOVED=1,
    MOVE_BOOKMARK_NONE=0
} move_bookmark_flags;

typedef struct add_option_to_tree_ctx add_option_to_tree_ctx, *Padd_option_to_tree_ctx;

struct add_option_to_tree_ctx {
    struct option_elinks * option_elinks;
    struct widget_data * widget_data;
};

typedef struct hash_item hash_item, *Phash_item;

struct hash_item {
    struct hash_item * next;
    struct hash_item * prev;
    uchar * key;
    uint keylen;
    void * value;
};

typedef struct hash hash, *Phash;

typedef ulong hash_value_T;

struct hash {
    uint width;
    hash_value_T (* func)(uchar *, uint, hash_value_T);
    struct list_head_elinks hash[1];
};

typedef struct line_info line_info, *Pline_info;

struct line_info {
    int start;
    int end;
    int last_char_width;
    int split_prev:1;
    int split_next:1;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
};

typedef enum xbel_element_type {
    XBEL_ELEMENTS=10,
    XBEL_ELEMENT_ALIAS=1,
    XBEL_ELEMENT_BOOKMARK=2,
    XBEL_ELEMENT_DESC=3,
    XBEL_ELEMENT_FOLDER=4,
    XBEL_ELEMENT_INFO=5,
    XBEL_ELEMENT_METADATA=6,
    XBEL_ELEMENT_SEPARATOR=7,
    XBEL_ELEMENT_TITLE=8,
    XBEL_ELEMENT_UNKNOWN=0,
    XBEL_ELEMENT_XBEL=9
} xbel_element_type;

typedef enum xbel_attribute_type {
    XBEL_ATTRIBUTES=10,
    XBEL_ATTRIBUTE_ADDED=1,
    XBEL_ATTRIBUTE_FOLDED=2,
    XBEL_ATTRIBUTE_HREF=3,
    XBEL_ATTRIBUTE_ID=4,
    XBEL_ATTRIBUTE_MODIFIED=5,
    XBEL_ATTRIBUTE_OWNER=6,
    XBEL_ATTRIBUTE_REF=7,
    XBEL_ATTRIBUTE_UNKNOWN=0,
    XBEL_ATTRIBUTE_VERSION=8,
    XBEL_ATTRIBUTE_VISITED=9
} xbel_attribute_type;

typedef struct http_connection_info http_connection_info, *Phttp_connection_info;

typedef enum blacklist_flags {
    SERVER_BLACKLIST_HTTP10=1,
    SERVER_BLACKLIST_NONE=0,
    SERVER_BLACKLIST_NO_CHARSET=2,
    SERVER_BLACKLIST_NO_TLS=4
} blacklist_flags;

struct http_connection_info {
    enum blacklist_flags bl_flags;
    struct http_version recv_version;
    struct http_version sent_version;
    int close;
    int length;
    int chunk_remaining;
    int code;
};

typedef enum html_element_mortality_type {
    ELEMENT_DONT_KILL=1,
    ELEMENT_IMMORTAL=0,
    ELEMENT_KILLABLE=2,
    ELEMENT_WEAK=3
} html_element_mortality_type;

typedef enum html_element_pseudo_class {
    ELEMENT_LINK=1,
    ELEMENT_VISITED=2
} html_element_pseudo_class;

typedef enum format_list_flag {
    P_ALPHA=3,
    P_COMPACT=8,
    P_LISTMASK=7,
    P_NONE=0,
    P_NUMBER=1,
    P_O=2,
    P_PLUS=3,
    P_ROMAN=5,
    P_STAR=1,
    P_alpha=2,
    P_roman=4
} format_list_flag;

typedef struct cookie_str cookie_str, *Pcookie_str;

struct cookie_str {
    uchar * str;
    uchar * nam_end;
    uchar * val_start;
    uchar * val_end;
};

typedef enum sgml_parser_type {
    SGML_PARSER_STREAM=0,
    SGML_PARSER_TREE=1
} sgml_parser_type;

typedef struct par_attrib par_attrib, *Ppar_attrib;

struct par_attrib {
    enum format_align align;
    int leftmargin;
    int rightmargin;
    int width;
    int list_level;
    uint list_number;
    int dd_margin;
    enum format_list_flag flags;
    color_T bgcolor;
};

typedef struct sgml_parser sgml_parser, *Psgml_parser;

typedef enum sgml_parser_flag {
    SGML_PARSER_COMPLETE=2,
    SGML_PARSER_COUNT_LINES=1,
    SGML_PARSER_DETECT_ERRORS=8,
    SGML_PARSER_INCREMENTAL=4
} sgml_parser_flag;

struct sgml_parser {
    enum sgml_parser_type type;
    enum sgml_parser_flag flags;
    struct sgml_info * info;
    struct dom_string uri;
    struct dom_node * root;
    enum dom_code code;
    dom_code (* error_func)(struct sgml_parser *, struct dom_string *, uint);
    struct dom_stack stack;
    struct dom_stack parsing;
};

typedef struct sgml_parser_state sgml_parser_state, *Psgml_parser_state;

struct sgml_parser_state {
    struct sgml_node_info * info;
    struct dom_scanner_token end_token;
};

typedef struct text_attrib text_attrib, *Ptext_attrib;

struct text_attrib {
    struct text_style style;
    int fontsize;
    uchar * link;
    uchar * target;
    uchar * image;
    uchar * title;
    struct form_control * form;
    color_T clink;
    color_T vlink;
    color_T bookmark_link;
    color_T image_link;
    uchar * id;
    uchar * class;
    uchar * select;
    int select_disabled;
    uint tabindex;
    unicode_val_T accesskey;
    uchar * onclick;
    uchar * ondblclick;
    uchar * onmouseover;
    uchar * onhover;
    uchar * onfocus;
    uchar * onmouseout;
    uchar * onblur;
};

typedef enum html_special_type.conflict {
    SP_CACHE_CONTROL=8,
    SP_CACHE_EXPIRES=9,
    SP_COLOR_LINK_LINES=12,
    SP_CONTROL=2,
    SP_FORM=1,
    SP_FRAME=6,
    SP_FRAMESET=5,
    SP_NOWRAP=7,
    SP_REFRESH=10,
    SP_SCRIPT=13,
    SP_STYLESHEET=11,
    SP_TABLE=3,
    SP_TAG=0,
    SP_USED=4
} html_special_type.conflict;

typedef struct xlist_head xlist_head, *Pxlist_head;

struct xlist_head {
    struct xlist_head * next;
    struct xlist_head * prev;
};

typedef struct sgml_parsing_state sgml_parsing_state, *Psgml_parsing_state;

struct sgml_parsing_state {
    struct dom_scanner scanner;
    struct dom_node * node;
    struct dom_string incomplete;
    size_t depth;
    uint resume:1;
    undefined field_0x105;
    undefined field_0x106;
    undefined field_0x107;
};

typedef struct selector_pkg selector_pkg, *Pselector_pkg;

typedef struct css_selector css_selector, *Pcss_selector;

typedef enum css_selector_relation {
    CSR_ANCESTOR=2,
    CSR_PARENT=3,
    CSR_ROOT=0,
    CSR_SPECIFITY=1
} css_selector_relation;

typedef enum css_selector_type {
    CST_CLASS=2,
    CST_ELEMENT=0,
    CST_ID=1,
    CST_INVALID=4,
    CST_PSEUDO=3
} css_selector_type;

struct selector_pkg {
    struct selector_pkg * next;
    struct selector_pkg * prev;
    struct css_selector * selector;
};

struct css_selector {
    struct css_selector * next;
    struct css_selector * prev;
    enum css_selector_relation relation;
    struct list_head_elinks leaves;
    enum css_selector_type type;
    uchar * name;
    struct list_head_elinks properties;
};

typedef enum dom_stack_action {
    DOM_STACK_POP=1,
    DOM_STACK_PUSH=0
} dom_stack_action;

typedef struct dom_stack_walk_state dom_stack_walk_state, *Pdom_stack_walk_state;

struct dom_stack_walk_state {
    struct dom_node_list * list;
    size_t index;
};

typedef struct gpm_mouse_spec gpm_mouse_spec, *Pgpm_mouse_spec;

struct gpm_mouse_spec {
    int h;
    int cons;
    void (* fn)(void *, uchar *, int);
    void * data;
};

typedef struct input_history input_history, *Pinput_history;

struct input_history {
    struct list_head_elinks entries;
    int size;
    uint dirty:1;
    uint nosave:1;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
};

typedef enum inpfield_flags {
    INPFIELD_FLOAT=1,
    INPFIELD_FLOAT2=2,
    INPFIELD_NONE=0
} inpfield_flags;

typedef struct session.conflict1 session.conflict1, *Psession.conflict1;

typedef struct kbdprefix.conflict1 kbdprefix.conflict1, *Pkbdprefix.conflict1;

typedef enum anon_enum_32_for_mark.conflict1 {
    KP_MARK_GOTO=2,
    KP_MARK_NOTHING=0,
    KP_MARK_SET=1,
    TERM_FN_RESIZE=2,
    TERM_FN_TITLE=1,
    TERM_FN_TITLE_CODEPAGE=3,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096
} anon_enum_32_for_mark.conflict1;

struct kbdprefix.conflict1 {
    int repeat_count;
    enum anon_enum_32_for_mark.conflict1 mark;
};

struct session.conflict1 {
    struct session * next;
    struct session * prev;
    struct window * tab;
    struct ses_history history;
    struct list_head_elinks more_files;
    struct download loading;
    struct uri * loading_uri;
    enum cache_mode reloadlevel;
    int redirect_cnt;
    struct document_view * doc_view;
    struct list_head_elinks scrn_frames;
    struct uri * download_uri;
    struct uri * referrer;
    struct session_task task;
    int search_direction;
    struct kbdprefix.conflict1 kbdprefix;
    int exit_query;
    timer_id_T display_timer;
    enum insert_mode insert_mode;
    enum navigate_mode navigate_mode;
    uchar * search_word;
    uchar * last_search_word;
    struct list_head_elinks type_queries;
    struct session_status status;
};

typedef struct session.conflict3 session.conflict3, *Psession.conflict3;

typedef struct kbdprefix.conflict3 kbdprefix.conflict3, *Pkbdprefix.conflict3;

typedef enum anon_enum_32_for_mark.conflict3 {
    DOM_SCAN_END=2,
    DOM_SCAN_RANGE=0,
    DOM_SCAN_STRING=1,
    KP_MARK_GOTO=2,
    KP_MARK_NOTHING=0,
    KP_MARK_SET=1,
    SCAN_END=2,
    SCAN_RANGE=0,
    SCAN_STRING=1,
    TERM_FN_RESIZE=2,
    TERM_FN_TITLE=1,
    TERM_FN_TITLE_CODEPAGE=3,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096
} anon_enum_32_for_mark.conflict3;

struct kbdprefix.conflict3 {
    int repeat_count;
    enum anon_enum_32_for_mark.conflict3 mark;
};

struct session.conflict3 {
    struct session * next;
    struct session * prev;
    struct window * tab;
    struct ses_history history;
    struct list_head_elinks more_files;
    struct download loading;
    struct uri * loading_uri;
    enum cache_mode reloadlevel;
    int redirect_cnt;
    struct document_view * doc_view;
    struct list_head_elinks scrn_frames;
    struct uri * download_uri;
    struct uri * referrer;
    struct session_task task;
    int search_direction;
    struct kbdprefix.conflict3 kbdprefix;
    int exit_query;
    timer_id_T display_timer;
    enum insert_mode insert_mode;
    enum navigate_mode navigate_mode;
    uchar * search_word;
    uchar * last_search_word;
    struct list_head_elinks type_queries;
    struct session_status status;
};

typedef struct session.conflict session.conflict, *Psession.conflict;

typedef struct kbdprefix.conflict kbdprefix.conflict, *Pkbdprefix.conflict;

typedef enum anon_enum_32_for_mark.conflict {
    KP_MARK_GOTO=2,
    KP_MARK_NOTHING=0,
    KP_MARK_SET=1,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096
} anon_enum_32_for_mark.conflict;

struct kbdprefix.conflict {
    int repeat_count;
    enum anon_enum_32_for_mark.conflict mark;
};

struct session.conflict {
    struct session * next;
    struct session * prev;
    struct window * tab;
    struct ses_history history;
    struct list_head_elinks more_files;
    struct download loading;
    struct uri * loading_uri;
    enum cache_mode reloadlevel;
    int redirect_cnt;
    struct document_view * doc_view;
    struct list_head_elinks scrn_frames;
    struct uri * download_uri;
    struct uri * referrer;
    struct session_task task;
    int search_direction;
    struct kbdprefix.conflict kbdprefix;
    int exit_query;
    timer_id_T display_timer;
    enum insert_mode insert_mode;
    enum navigate_mode navigate_mode;
    uchar * search_word;
    uchar * last_search_word;
    struct list_head_elinks type_queries;
    struct session_status status;
};

typedef struct input_line input_line, *Pinput_line;

typedef enum input_line_code {
    INPUT_LINE_CANCEL=0,
    INPUT_LINE_PROCEED=1,
    INPUT_LINE_REWIND=2
} input_line_code;

struct input_line {
    struct session * ses;
    input_line_code (* handler)(struct input_line *, int);
    void * data;
    uchar buffer[256];
};

typedef struct session.conflict5 session.conflict5, *Psession.conflict5;

typedef struct kbdprefix.conflict5 kbdprefix.conflict5, *Pkbdprefix.conflict5;

typedef enum anon_enum_32_for_mark.conflict5 {
    ABDAY_1=131072,
    ABDAY_2=131073,
    ABDAY_3=131074,
    ABDAY_4=131075,
    ABDAY_5=131076,
    ABDAY_6=131077,
    ABDAY_7=131078,
    ABMON_1=131086,
    ABMON_10=131095,
    ABMON_11=131096,
    ABMON_12=131097,
    ABMON_2=131087,
    ABMON_3=131088,
    ABMON_4=131089,
    ABMON_5=131090,
    ABMON_6=131091,
    ABMON_7=131092,
    ABMON_8=131093,
    ABMON_9=131094,
    ALT_DIGITS=131119,
    AM_STR=131110,
    CODESET=14,
    DAY_1=131079,
    DAY_2=131080,
    DAY_3=131081,
    DAY_4=131082,
    DAY_5=131083,
    DAY_6=131084,
    DAY_7=131085,
    DOM_SCAN_END=2,
    DOM_SCAN_RANGE=0,
    DOM_SCAN_STRING=1,
    D_FMT=131113,
    D_T_FMT=131112,
    ERA=131116,
    ERA_D_FMT=131118,
    ERA_D_T_FMT=131120,
    ERA_T_FMT=131121,
    GNUTLS_CLIENT=2,
    GNUTLS_CRD_ANON=2,
    GNUTLS_CRD_CERTIFICATE=1,
    GNUTLS_CRD_IA=5,
    GNUTLS_CRD_PSK=4,
    GNUTLS_CRD_SRP=3,
    GNUTLS_KX_ANON_DH=4,
    GNUTLS_KX_DHE_DSS=2,
    GNUTLS_KX_DHE_PSK=10,
    GNUTLS_KX_DHE_RSA=3,
    GNUTLS_KX_PSK=9,
    GNUTLS_KX_RSA=1,
    GNUTLS_KX_RSA_EXPORT=6,
    GNUTLS_KX_SRP=5,
    GNUTLS_KX_SRP_DSS=8,
    GNUTLS_KX_SRP_RSA=7,
    GNUTLS_KX_UNKNOWN=0,
    GNUTLS_MAC_MD2=5,
    GNUTLS_MAC_MD5=2,
    GNUTLS_MAC_NULL=1,
    GNUTLS_MAC_RMD160=4,
    GNUTLS_MAC_SHA1=3,
    GNUTLS_MAC_SHA256=6,
    GNUTLS_MAC_SHA384=7,
    GNUTLS_MAC_SHA512=8,
    GNUTLS_MAC_UNKNOWN=0,
    GNUTLS_SERVER=1,
    GNUTLS_SHUT_RDWR=0,
    GNUTLS_SHUT_WR=1,
    GNUTLS_SSL3=1,
    GNUTLS_TLS1_0=2,
    GNUTLS_TLS1_1=3,
    GNUTLS_TLS1_2=4,
    GNUTLS_VERSION_UNKNOWN=255,
    GNUTLS_X509_FMT_DER=0,
    GNUTLS_X509_FMT_PEM=1,
    IPPROTO_AH=51,
    IPPROTO_COMP=108,
    IPPROTO_DCCP=33,
    IPPROTO_DSTOPTS=60,
    IPPROTO_EGP=8,
    IPPROTO_ENCAP=98,
    IPPROTO_ESP=50,
    IPPROTO_FRAGMENT=44,
    IPPROTO_GRE=47,
    IPPROTO_HOPOPTS=0,
    IPPROTO_ICMP=1,
    IPPROTO_ICMPV6=58,
    IPPROTO_IDP=22,
    IPPROTO_IGMP=2,
    IPPROTO_IP=0,
    IPPROTO_IPIP=4,
    IPPROTO_IPV6=41,
    IPPROTO_MAX=256,
    IPPROTO_MTP=92,
    IPPROTO_NONE=59,
    IPPROTO_PIM=103,
    IPPROTO_PUP=12,
    IPPROTO_RAW=255,
    IPPROTO_ROUTING=43,
    IPPROTO_RSVP=46,
    IPPROTO_SCTP=132,
    IPPROTO_TCP=6,
    IPPROTO_TP=29,
    IPPROTO_UDP=17,
    IPPROTO_UDPLITE=136,
    KP_MARK_GOTO=2,
    KP_MARK_NOTHING=0,
    KP_MARK_SET=1,
    MON_1=131098,
    MON_10=131107,
    MON_11=131108,
    MON_12=131109,
    MON_2=131099,
    MON_3=131100,
    MON_4=131101,
    MON_5=131102,
    MON_6=131103,
    MON_7=131104,
    MON_8=131105,
    MON_9=131106,
    PM_STR=131111,
    RADIXCHAR=65536,
    SCAN_END=2,
    SCAN_RANGE=0,
    SCAN_STRING=1,
    TERM_FN_RESIZE=2,
    TERM_FN_TITLE=1,
    TERM_FN_TITLE_CODEPAGE=3,
    THOUSEP=65537,
    T_FMT=131114,
    T_FMT_AMPM=131115,
    _DATE_FMT=131180,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096,
    _NL_ADDRESS_CODESET=589836,
    _NL_ADDRESS_COUNTRY_AB2=589827,
    _NL_ADDRESS_COUNTRY_AB3=589828,
    _NL_ADDRESS_COUNTRY_CAR=589829,
    _NL_ADDRESS_COUNTRY_ISBN=589831,
    _NL_ADDRESS_COUNTRY_NAME=589825,
    _NL_ADDRESS_COUNTRY_NUM=589830,
    _NL_ADDRESS_COUNTRY_POST=589826,
    _NL_ADDRESS_LANG_AB=589833,
    _NL_ADDRESS_LANG_LIB=589835,
    _NL_ADDRESS_LANG_NAME=589832,
    _NL_ADDRESS_LANG_TERM=589834,
    _NL_ADDRESS_POSTAL_FMT=589824,
    _NL_COLLATE_CODESET=196626,
    _NL_COLLATE_COLLSEQMB=196624,
    _NL_COLLATE_COLLSEQWC=196625,
    _NL_COLLATE_EXTRAMB=196612,
    _NL_COLLATE_EXTRAWC=196619,
    _NL_COLLATE_GAP1=196614,
    _NL_COLLATE_GAP2=196615,
    _NL_COLLATE_GAP3=196616,
    _NL_COLLATE_INDIRECTMB=196613,
    _NL_COLLATE_INDIRECTWC=196620,
    _NL_COLLATE_NRULES=196608,
    _NL_COLLATE_RULESETS=196609,
    _NL_COLLATE_SYMB_EXTRAMB=196623,
    _NL_COLLATE_SYMB_HASH_SIZEMB=196621,
    _NL_COLLATE_SYMB_TABLEMB=196622,
    _NL_COLLATE_TABLEMB=196610,
    _NL_COLLATE_TABLEWC=196617,
    _NL_COLLATE_WEIGHTMB=196611,
    _NL_COLLATE_WEIGHTWC=196618,
    _NL_CTYPE_CLASS=0,
    _NL_CTYPE_CLASS32=5,
    _NL_CTYPE_CLASS_NAMES=10,
    _NL_CTYPE_CLASS_OFFSET=17,
    _NL_CTYPE_CODESET_NAME=14,
    _NL_CTYPE_EXTRA_MAP_1=72,
    _NL_CTYPE_EXTRA_MAP_10=81,
    _NL_CTYPE_EXTRA_MAP_11=82,
    _NL_CTYPE_EXTRA_MAP_12=83,
    _NL_CTYPE_EXTRA_MAP_13=84,
    _NL_CTYPE_EXTRA_MAP_14=85,
    _NL_CTYPE_EXTRA_MAP_2=73,
    _NL_CTYPE_EXTRA_MAP_3=74,
    _NL_CTYPE_EXTRA_MAP_4=75,
    _NL_CTYPE_EXTRA_MAP_5=76,
    _NL_CTYPE_EXTRA_MAP_6=77,
    _NL_CTYPE_EXTRA_MAP_7=78,
    _NL_CTYPE_EXTRA_MAP_8=79,
    _NL_CTYPE_EXTRA_MAP_9=80,
    _NL_CTYPE_GAP1=2,
    _NL_CTYPE_GAP2=4,
    _NL_CTYPE_GAP3=6,
    _NL_CTYPE_GAP4=7,
    _NL_CTYPE_GAP5=8,
    _NL_CTYPE_GAP6=9,
    _NL_CTYPE_INDIGITS0_MB=20,
    _NL_CTYPE_INDIGITS0_WC=31,
    _NL_CTYPE_INDIGITS1_MB=21,
    _NL_CTYPE_INDIGITS1_WC=32,
    _NL_CTYPE_INDIGITS2_MB=22,
    _NL_CTYPE_INDIGITS2_WC=33,
    _NL_CTYPE_INDIGITS3_MB=23,
    _NL_CTYPE_INDIGITS3_WC=34,
    _NL_CTYPE_INDIGITS4_MB=24,
    _NL_CTYPE_INDIGITS4_WC=35,
    _NL_CTYPE_INDIGITS5_MB=25,
    _NL_CTYPE_INDIGITS5_WC=36,
    _NL_CTYPE_INDIGITS6_MB=26,
    _NL_CTYPE_INDIGITS6_WC=37,
    _NL_CTYPE_INDIGITS7_MB=27,
    _NL_CTYPE_INDIGITS7_WC=38,
    _NL_CTYPE_INDIGITS8_MB=28,
    _NL_CTYPE_INDIGITS8_WC=39,
    _NL_CTYPE_INDIGITS9_MB=29,
    _NL_CTYPE_INDIGITS9_WC=40,
    _NL_CTYPE_INDIGITS_MB_LEN=19,
    _NL_CTYPE_INDIGITS_WC_LEN=30,
    _NL_CTYPE_MAP_NAMES=11,
    _NL_CTYPE_MAP_OFFSET=18,
    _NL_CTYPE_MAP_TO_NONASCII=70,
    _NL_CTYPE_MB_CUR_MAX=13,
    _NL_CTYPE_NONASCII_CASE=71,
    _NL_CTYPE_OUTDIGIT0_MB=41,
    _NL_CTYPE_OUTDIGIT0_WC=51,
    _NL_CTYPE_OUTDIGIT1_MB=42,
    _NL_CTYPE_OUTDIGIT1_WC=52,
    _NL_CTYPE_OUTDIGIT2_MB=43,
    _NL_CTYPE_OUTDIGIT2_WC=53,
    _NL_CTYPE_OUTDIGIT3_MB=44,
    _NL_CTYPE_OUTDIGIT3_WC=54,
    _NL_CTYPE_OUTDIGIT4_MB=45,
    _NL_CTYPE_OUTDIGIT4_WC=55,
    _NL_CTYPE_OUTDIGIT5_MB=46,
    _NL_CTYPE_OUTDIGIT5_WC=56,
    _NL_CTYPE_OUTDIGIT6_MB=47,
    _NL_CTYPE_OUTDIGIT6_WC=57,
    _NL_CTYPE_OUTDIGIT7_MB=48,
    _NL_CTYPE_OUTDIGIT7_WC=58,
    _NL_CTYPE_OUTDIGIT8_MB=49,
    _NL_CTYPE_OUTDIGIT8_WC=59,
    _NL_CTYPE_OUTDIGIT9_MB=50,
    _NL_CTYPE_OUTDIGIT9_WC=60,
    _NL_CTYPE_TOLOWER=3,
    _NL_CTYPE_TOLOWER32=16,
    _NL_CTYPE_TOUPPER=1,
    _NL_CTYPE_TOUPPER32=15,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING=67,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN=66,
    _NL_CTYPE_TRANSLIT_FROM_IDX=62,
    _NL_CTYPE_TRANSLIT_FROM_TBL=63,
    _NL_CTYPE_TRANSLIT_IGNORE=69,
    _NL_CTYPE_TRANSLIT_IGNORE_LEN=68,
    _NL_CTYPE_TRANSLIT_TAB_SIZE=61,
    _NL_CTYPE_TRANSLIT_TO_IDX=64,
    _NL_CTYPE_TRANSLIT_TO_TBL=65,
    _NL_CTYPE_WIDTH=12,
    _NL_IDENTIFICATION_ABBREVIATION=786443,
    _NL_IDENTIFICATION_ADDRESS=786434,
    _NL_IDENTIFICATION_APPLICATION=786442,
    _NL_IDENTIFICATION_AUDIENCE=786441,
    _NL_IDENTIFICATION_CATEGORY=786446,
    _NL_IDENTIFICATION_CODESET=786447,
    _NL_IDENTIFICATION_CONTACT=786435,
    _NL_IDENTIFICATION_DATE=786445,
    _NL_IDENTIFICATION_EMAIL=786436,
    _NL_IDENTIFICATION_FAX=786438,
    _NL_IDENTIFICATION_LANGUAGE=786439,
    _NL_IDENTIFICATION_REVISION=786444,
    _NL_IDENTIFICATION_SOURCE=786433,
    _NL_IDENTIFICATION_TEL=786437,
    _NL_IDENTIFICATION_TERRITORY=786440,
    _NL_IDENTIFICATION_TITLE=786432,
    _NL_MEASUREMENT_CODESET=720897,
    _NL_MEASUREMENT_MEASUREMENT=720896,
    _NL_MESSAGES_CODESET=327684,
    _NL_MONETARY_CODESET=262189,
    _NL_MONETARY_CONVERSION_RATE=262186,
    _NL_MONETARY_CRNCYSTR=262159,
    _NL_MONETARY_DECIMAL_POINT_WC=262187,
    _NL_MONETARY_DUO_CURRENCY_SYMBOL=262167,
    _NL_MONETARY_DUO_FRAC_DIGITS=262169,
    _NL_MONETARY_DUO_INT_CURR_SYMBOL=262166,
    _NL_MONETARY_DUO_INT_FRAC_DIGITS=262168,
    _NL_MONETARY_DUO_INT_N_CS_PRECEDES=262176,
    _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE=262177,
    _NL_MONETARY_DUO_INT_N_SIGN_POSN=262181,
    _NL_MONETARY_DUO_INT_P_CS_PRECEDES=262174,
    _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE=262175,
    _NL_MONETARY_DUO_INT_P_SIGN_POSN=262180,
    _NL_MONETARY_DUO_N_CS_PRECEDES=262172,
    _NL_MONETARY_DUO_N_SEP_BY_SPACE=262173,
    _NL_MONETARY_DUO_N_SIGN_POSN=262179,
    _NL_MONETARY_DUO_P_CS_PRECEDES=262170,
    _NL_MONETARY_DUO_P_SEP_BY_SPACE=262171,
    _NL_MONETARY_DUO_P_SIGN_POSN=262178,
    _NL_MONETARY_DUO_VALID_FROM=262184,
    _NL_MONETARY_DUO_VALID_TO=262185,
    _NL_MONETARY_THOUSANDS_SEP_WC=262188,
    _NL_MONETARY_UNO_VALID_FROM=262182,
    _NL_MONETARY_UNO_VALID_TO=262183,
    _NL_NAME_CODESET=524294,
    _NL_NAME_NAME_FMT=524288,
    _NL_NAME_NAME_GEN=524289,
    _NL_NAME_NAME_MISS=524292,
    _NL_NAME_NAME_MR=524290,
    _NL_NAME_NAME_MRS=524291,
    _NL_NAME_NAME_MS=524293,
    _NL_NUM=786449,
    _NL_NUMERIC_CODESET=65541,
    _NL_NUMERIC_DECIMAL_POINT_WC=65539,
    _NL_NUMERIC_THOUSANDS_SEP_WC=65540,
    _NL_NUM_LC_ADDRESS=589837,
    _NL_NUM_LC_COLLATE=196627,
    _NL_NUM_LC_CTYPE=86,
    _NL_NUM_LC_IDENTIFICATION=786448,
    _NL_NUM_LC_MEASUREMENT=720898,
    _NL_NUM_LC_MESSAGES=327685,
    _NL_NUM_LC_MONETARY=262190,
    _NL_NUM_LC_NAME=524295,
    _NL_NUM_LC_NUMERIC=65542,
    _NL_NUM_LC_PAPER=458755,
    _NL_NUM_LC_TELEPHONE=655365,
    _NL_NUM_LC_TIME=131183,
    _NL_PAPER_CODESET=458754,
    _NL_PAPER_HEIGHT=458752,
    _NL_PAPER_WIDTH=458753,
    _NL_TELEPHONE_CODESET=655364,
    _NL_TELEPHONE_INT_PREFIX=655363,
    _NL_TELEPHONE_INT_SELECT=655362,
    _NL_TELEPHONE_TEL_DOM_FMT=655361,
    _NL_TELEPHONE_TEL_INT_FMT=655360,
    _NL_TIME_CAL_DIRECTION=131178,
    _NL_TIME_CODESET=131182,
    _NL_TIME_ERA_ENTRIES=131123,
    _NL_TIME_ERA_NUM_ENTRIES=131122,
    _NL_TIME_FIRST_WEEKDAY=131176,
    _NL_TIME_FIRST_WORKDAY=131177,
    _NL_TIME_TIMEZONE=131179,
    _NL_TIME_WEEK_1STDAY=131174,
    _NL_TIME_WEEK_1STWEEK=131175,
    _NL_TIME_WEEK_NDAYS=131173,
    _NL_WABDAY_1=131124,
    _NL_WABDAY_2=131125,
    _NL_WABDAY_3=131126,
    _NL_WABDAY_4=131127,
    _NL_WABDAY_5=131128,
    _NL_WABDAY_6=131129,
    _NL_WABDAY_7=131130,
    _NL_WABMON_1=131138,
    _NL_WABMON_10=131147,
    _NL_WABMON_11=131148,
    _NL_WABMON_12=131149,
    _NL_WABMON_2=131139,
    _NL_WABMON_3=131140,
    _NL_WABMON_4=131141,
    _NL_WABMON_5=131142,
    _NL_WABMON_6=131143,
    _NL_WABMON_7=131144,
    _NL_WABMON_8=131145,
    _NL_WABMON_9=131146,
    _NL_WALT_DIGITS=131170,
    _NL_WAM_STR=131162,
    _NL_WDAY_1=131131,
    _NL_WDAY_2=131132,
    _NL_WDAY_3=131133,
    _NL_WDAY_4=131134,
    _NL_WDAY_5=131135,
    _NL_WDAY_6=131136,
    _NL_WDAY_7=131137,
    _NL_WD_FMT=131165,
    _NL_WD_T_FMT=131164,
    _NL_WERA_D_FMT=131169,
    _NL_WERA_D_T_FMT=131171,
    _NL_WERA_T_FMT=131172,
    _NL_WERA_YEAR=131168,
    _NL_WMON_1=131150,
    _NL_WMON_10=131159,
    _NL_WMON_11=131160,
    _NL_WMON_12=131161,
    _NL_WMON_2=131151,
    _NL_WMON_3=131152,
    _NL_WMON_4=131153,
    _NL_WMON_5=131154,
    _NL_WMON_6=131155,
    _NL_WMON_7=131156,
    _NL_WMON_8=131157,
    _NL_WMON_9=131158,
    _NL_WPM_STR=131163,
    _NL_WT_FMT=131166,
    _NL_WT_FMT_AMPM=131167,
    _NL_W_DATE_FMT=131181,
    __CURRENCY_SYMBOL=262145,
    __DECIMAL_POINT=65536,
    __ERA_YEAR=131117,
    __FRAC_DIGITS=262152,
    __GROUPING=65538,
    __INT_CURR_SYMBOL=262144,
    __INT_FRAC_DIGITS=262151,
    __INT_N_CS_PRECEDES=262162,
    __INT_N_SEP_BY_SPACE=262163,
    __INT_N_SIGN_POSN=262165,
    __INT_P_CS_PRECEDES=262160,
    __INT_P_SEP_BY_SPACE=262161,
    __INT_P_SIGN_POSN=262164,
    __LC_ADDRESS=9,
    __LC_ALL=6,
    __LC_COLLATE=3,
    __LC_CTYPE=0,
    __LC_IDENTIFICATION=12,
    __LC_MEASUREMENT=11,
    __LC_MESSAGES=5,
    __LC_MONETARY=4,
    __LC_NAME=8,
    __LC_NUMERIC=1,
    __LC_PAPER=7,
    __LC_TELEPHONE=10,
    __LC_TIME=2,
    __MON_DECIMAL_POINT=262146,
    __MON_GROUPING=262148,
    __MON_THOUSANDS_SEP=262147,
    __NEGATIVE_SIGN=262150,
    __NOEXPR=327681,
    __NOSTR=327683,
    __N_CS_PRECEDES=262155,
    __N_SEP_BY_SPACE=262156,
    __N_SIGN_POSN=262158,
    __POSITIVE_SIGN=262149,
    __P_CS_PRECEDES=262153,
    __P_SEP_BY_SPACE=262154,
    __P_SIGN_POSN=262157,
    __THOUSANDS_SEP=65537,
    __YESEXPR=327680,
    __YESSTR=327682
} anon_enum_32_for_mark.conflict5;

struct kbdprefix.conflict5 {
    int repeat_count;
    enum anon_enum_32_for_mark.conflict5 mark;
};

struct session.conflict5 {
    struct session * next;
    struct session * prev;
    struct window * tab;
    struct ses_history history;
    struct list_head_elinks more_files;
    struct download loading;
    struct uri * loading_uri;
    enum cache_mode reloadlevel;
    int redirect_cnt;
    struct document_view * doc_view;
    struct list_head_elinks scrn_frames;
    struct uri * download_uri;
    struct uri * referrer;
    struct session_task task;
    int search_direction;
    struct kbdprefix.conflict5 kbdprefix;
    int exit_query;
    timer_id_T display_timer;
    enum insert_mode insert_mode;
    enum navigate_mode navigate_mode;
    uchar * search_word;
    uchar * last_search_word;
    struct list_head_elinks type_queries;
    struct session_status status;
};

typedef struct session.conflict4 session.conflict4, *Psession.conflict4;

typedef struct kbdprefix.conflict4 kbdprefix.conflict4, *Pkbdprefix.conflict4;

typedef enum anon_enum_32_for_mark.conflict4 {
    ABDAY_1=131072,
    ABDAY_2=131073,
    ABDAY_3=131074,
    ABDAY_4=131075,
    ABDAY_5=131076,
    ABDAY_6=131077,
    ABDAY_7=131078,
    ABMON_1=131086,
    ABMON_10=131095,
    ABMON_11=131096,
    ABMON_12=131097,
    ABMON_2=131087,
    ABMON_3=131088,
    ABMON_4=131089,
    ABMON_5=131090,
    ABMON_6=131091,
    ABMON_7=131092,
    ABMON_8=131093,
    ABMON_9=131094,
    ALT_DIGITS=131119,
    AM_STR=131110,
    CODESET=14,
    DAY_1=131079,
    DAY_2=131080,
    DAY_3=131081,
    DAY_4=131082,
    DAY_5=131083,
    DAY_6=131084,
    DAY_7=131085,
    DOM_SCAN_END=2,
    DOM_SCAN_RANGE=0,
    DOM_SCAN_STRING=1,
    D_FMT=131113,
    D_T_FMT=131112,
    ERA=131116,
    ERA_D_FMT=131118,
    ERA_D_T_FMT=131120,
    ERA_T_FMT=131121,
    KP_MARK_GOTO=2,
    KP_MARK_NOTHING=0,
    KP_MARK_SET=1,
    MON_1=131098,
    MON_10=131107,
    MON_11=131108,
    MON_12=131109,
    MON_2=131099,
    MON_3=131100,
    MON_4=131101,
    MON_5=131102,
    MON_6=131103,
    MON_7=131104,
    MON_8=131105,
    MON_9=131106,
    PM_STR=131111,
    RADIXCHAR=65536,
    SCAN_END=2,
    SCAN_RANGE=0,
    SCAN_STRING=1,
    TERM_FN_RESIZE=2,
    TERM_FN_TITLE=1,
    TERM_FN_TITLE_CODEPAGE=3,
    THOUSEP=65537,
    T_FMT=131114,
    T_FMT_AMPM=131115,
    _DATE_FMT=131180,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096,
    _NL_ADDRESS_CODESET=589836,
    _NL_ADDRESS_COUNTRY_AB2=589827,
    _NL_ADDRESS_COUNTRY_AB3=589828,
    _NL_ADDRESS_COUNTRY_CAR=589829,
    _NL_ADDRESS_COUNTRY_ISBN=589831,
    _NL_ADDRESS_COUNTRY_NAME=589825,
    _NL_ADDRESS_COUNTRY_NUM=589830,
    _NL_ADDRESS_COUNTRY_POST=589826,
    _NL_ADDRESS_LANG_AB=589833,
    _NL_ADDRESS_LANG_LIB=589835,
    _NL_ADDRESS_LANG_NAME=589832,
    _NL_ADDRESS_LANG_TERM=589834,
    _NL_ADDRESS_POSTAL_FMT=589824,
    _NL_COLLATE_CODESET=196626,
    _NL_COLLATE_COLLSEQMB=196624,
    _NL_COLLATE_COLLSEQWC=196625,
    _NL_COLLATE_EXTRAMB=196612,
    _NL_COLLATE_EXTRAWC=196619,
    _NL_COLLATE_GAP1=196614,
    _NL_COLLATE_GAP2=196615,
    _NL_COLLATE_GAP3=196616,
    _NL_COLLATE_INDIRECTMB=196613,
    _NL_COLLATE_INDIRECTWC=196620,
    _NL_COLLATE_NRULES=196608,
    _NL_COLLATE_RULESETS=196609,
    _NL_COLLATE_SYMB_EXTRAMB=196623,
    _NL_COLLATE_SYMB_HASH_SIZEMB=196621,
    _NL_COLLATE_SYMB_TABLEMB=196622,
    _NL_COLLATE_TABLEMB=196610,
    _NL_COLLATE_TABLEWC=196617,
    _NL_COLLATE_WEIGHTMB=196611,
    _NL_COLLATE_WEIGHTWC=196618,
    _NL_CTYPE_CLASS=0,
    _NL_CTYPE_CLASS32=5,
    _NL_CTYPE_CLASS_NAMES=10,
    _NL_CTYPE_CLASS_OFFSET=17,
    _NL_CTYPE_CODESET_NAME=14,
    _NL_CTYPE_EXTRA_MAP_1=72,
    _NL_CTYPE_EXTRA_MAP_10=81,
    _NL_CTYPE_EXTRA_MAP_11=82,
    _NL_CTYPE_EXTRA_MAP_12=83,
    _NL_CTYPE_EXTRA_MAP_13=84,
    _NL_CTYPE_EXTRA_MAP_14=85,
    _NL_CTYPE_EXTRA_MAP_2=73,
    _NL_CTYPE_EXTRA_MAP_3=74,
    _NL_CTYPE_EXTRA_MAP_4=75,
    _NL_CTYPE_EXTRA_MAP_5=76,
    _NL_CTYPE_EXTRA_MAP_6=77,
    _NL_CTYPE_EXTRA_MAP_7=78,
    _NL_CTYPE_EXTRA_MAP_8=79,
    _NL_CTYPE_EXTRA_MAP_9=80,
    _NL_CTYPE_GAP1=2,
    _NL_CTYPE_GAP2=4,
    _NL_CTYPE_GAP3=6,
    _NL_CTYPE_GAP4=7,
    _NL_CTYPE_GAP5=8,
    _NL_CTYPE_GAP6=9,
    _NL_CTYPE_INDIGITS0_MB=20,
    _NL_CTYPE_INDIGITS0_WC=31,
    _NL_CTYPE_INDIGITS1_MB=21,
    _NL_CTYPE_INDIGITS1_WC=32,
    _NL_CTYPE_INDIGITS2_MB=22,
    _NL_CTYPE_INDIGITS2_WC=33,
    _NL_CTYPE_INDIGITS3_MB=23,
    _NL_CTYPE_INDIGITS3_WC=34,
    _NL_CTYPE_INDIGITS4_MB=24,
    _NL_CTYPE_INDIGITS4_WC=35,
    _NL_CTYPE_INDIGITS5_MB=25,
    _NL_CTYPE_INDIGITS5_WC=36,
    _NL_CTYPE_INDIGITS6_MB=26,
    _NL_CTYPE_INDIGITS6_WC=37,
    _NL_CTYPE_INDIGITS7_MB=27,
    _NL_CTYPE_INDIGITS7_WC=38,
    _NL_CTYPE_INDIGITS8_MB=28,
    _NL_CTYPE_INDIGITS8_WC=39,
    _NL_CTYPE_INDIGITS9_MB=29,
    _NL_CTYPE_INDIGITS9_WC=40,
    _NL_CTYPE_INDIGITS_MB_LEN=19,
    _NL_CTYPE_INDIGITS_WC_LEN=30,
    _NL_CTYPE_MAP_NAMES=11,
    _NL_CTYPE_MAP_OFFSET=18,
    _NL_CTYPE_MAP_TO_NONASCII=70,
    _NL_CTYPE_MB_CUR_MAX=13,
    _NL_CTYPE_NONASCII_CASE=71,
    _NL_CTYPE_OUTDIGIT0_MB=41,
    _NL_CTYPE_OUTDIGIT0_WC=51,
    _NL_CTYPE_OUTDIGIT1_MB=42,
    _NL_CTYPE_OUTDIGIT1_WC=52,
    _NL_CTYPE_OUTDIGIT2_MB=43,
    _NL_CTYPE_OUTDIGIT2_WC=53,
    _NL_CTYPE_OUTDIGIT3_MB=44,
    _NL_CTYPE_OUTDIGIT3_WC=54,
    _NL_CTYPE_OUTDIGIT4_MB=45,
    _NL_CTYPE_OUTDIGIT4_WC=55,
    _NL_CTYPE_OUTDIGIT5_MB=46,
    _NL_CTYPE_OUTDIGIT5_WC=56,
    _NL_CTYPE_OUTDIGIT6_MB=47,
    _NL_CTYPE_OUTDIGIT6_WC=57,
    _NL_CTYPE_OUTDIGIT7_MB=48,
    _NL_CTYPE_OUTDIGIT7_WC=58,
    _NL_CTYPE_OUTDIGIT8_MB=49,
    _NL_CTYPE_OUTDIGIT8_WC=59,
    _NL_CTYPE_OUTDIGIT9_MB=50,
    _NL_CTYPE_OUTDIGIT9_WC=60,
    _NL_CTYPE_TOLOWER=3,
    _NL_CTYPE_TOLOWER32=16,
    _NL_CTYPE_TOUPPER=1,
    _NL_CTYPE_TOUPPER32=15,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING=67,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN=66,
    _NL_CTYPE_TRANSLIT_FROM_IDX=62,
    _NL_CTYPE_TRANSLIT_FROM_TBL=63,
    _NL_CTYPE_TRANSLIT_IGNORE=69,
    _NL_CTYPE_TRANSLIT_IGNORE_LEN=68,
    _NL_CTYPE_TRANSLIT_TAB_SIZE=61,
    _NL_CTYPE_TRANSLIT_TO_IDX=64,
    _NL_CTYPE_TRANSLIT_TO_TBL=65,
    _NL_CTYPE_WIDTH=12,
    _NL_IDENTIFICATION_ABBREVIATION=786443,
    _NL_IDENTIFICATION_ADDRESS=786434,
    _NL_IDENTIFICATION_APPLICATION=786442,
    _NL_IDENTIFICATION_AUDIENCE=786441,
    _NL_IDENTIFICATION_CATEGORY=786446,
    _NL_IDENTIFICATION_CODESET=786447,
    _NL_IDENTIFICATION_CONTACT=786435,
    _NL_IDENTIFICATION_DATE=786445,
    _NL_IDENTIFICATION_EMAIL=786436,
    _NL_IDENTIFICATION_FAX=786438,
    _NL_IDENTIFICATION_LANGUAGE=786439,
    _NL_IDENTIFICATION_REVISION=786444,
    _NL_IDENTIFICATION_SOURCE=786433,
    _NL_IDENTIFICATION_TEL=786437,
    _NL_IDENTIFICATION_TERRITORY=786440,
    _NL_IDENTIFICATION_TITLE=786432,
    _NL_MEASUREMENT_CODESET=720897,
    _NL_MEASUREMENT_MEASUREMENT=720896,
    _NL_MESSAGES_CODESET=327684,
    _NL_MONETARY_CODESET=262189,
    _NL_MONETARY_CONVERSION_RATE=262186,
    _NL_MONETARY_CRNCYSTR=262159,
    _NL_MONETARY_DECIMAL_POINT_WC=262187,
    _NL_MONETARY_DUO_CURRENCY_SYMBOL=262167,
    _NL_MONETARY_DUO_FRAC_DIGITS=262169,
    _NL_MONETARY_DUO_INT_CURR_SYMBOL=262166,
    _NL_MONETARY_DUO_INT_FRAC_DIGITS=262168,
    _NL_MONETARY_DUO_INT_N_CS_PRECEDES=262176,
    _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE=262177,
    _NL_MONETARY_DUO_INT_N_SIGN_POSN=262181,
    _NL_MONETARY_DUO_INT_P_CS_PRECEDES=262174,
    _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE=262175,
    _NL_MONETARY_DUO_INT_P_SIGN_POSN=262180,
    _NL_MONETARY_DUO_N_CS_PRECEDES=262172,
    _NL_MONETARY_DUO_N_SEP_BY_SPACE=262173,
    _NL_MONETARY_DUO_N_SIGN_POSN=262179,
    _NL_MONETARY_DUO_P_CS_PRECEDES=262170,
    _NL_MONETARY_DUO_P_SEP_BY_SPACE=262171,
    _NL_MONETARY_DUO_P_SIGN_POSN=262178,
    _NL_MONETARY_DUO_VALID_FROM=262184,
    _NL_MONETARY_DUO_VALID_TO=262185,
    _NL_MONETARY_THOUSANDS_SEP_WC=262188,
    _NL_MONETARY_UNO_VALID_FROM=262182,
    _NL_MONETARY_UNO_VALID_TO=262183,
    _NL_NAME_CODESET=524294,
    _NL_NAME_NAME_FMT=524288,
    _NL_NAME_NAME_GEN=524289,
    _NL_NAME_NAME_MISS=524292,
    _NL_NAME_NAME_MR=524290,
    _NL_NAME_NAME_MRS=524291,
    _NL_NAME_NAME_MS=524293,
    _NL_NUM=786449,
    _NL_NUMERIC_CODESET=65541,
    _NL_NUMERIC_DECIMAL_POINT_WC=65539,
    _NL_NUMERIC_THOUSANDS_SEP_WC=65540,
    _NL_NUM_LC_ADDRESS=589837,
    _NL_NUM_LC_COLLATE=196627,
    _NL_NUM_LC_CTYPE=86,
    _NL_NUM_LC_IDENTIFICATION=786448,
    _NL_NUM_LC_MEASUREMENT=720898,
    _NL_NUM_LC_MESSAGES=327685,
    _NL_NUM_LC_MONETARY=262190,
    _NL_NUM_LC_NAME=524295,
    _NL_NUM_LC_NUMERIC=65542,
    _NL_NUM_LC_PAPER=458755,
    _NL_NUM_LC_TELEPHONE=655365,
    _NL_NUM_LC_TIME=131183,
    _NL_PAPER_CODESET=458754,
    _NL_PAPER_HEIGHT=458752,
    _NL_PAPER_WIDTH=458753,
    _NL_TELEPHONE_CODESET=655364,
    _NL_TELEPHONE_INT_PREFIX=655363,
    _NL_TELEPHONE_INT_SELECT=655362,
    _NL_TELEPHONE_TEL_DOM_FMT=655361,
    _NL_TELEPHONE_TEL_INT_FMT=655360,
    _NL_TIME_CAL_DIRECTION=131178,
    _NL_TIME_CODESET=131182,
    _NL_TIME_ERA_ENTRIES=131123,
    _NL_TIME_ERA_NUM_ENTRIES=131122,
    _NL_TIME_FIRST_WEEKDAY=131176,
    _NL_TIME_FIRST_WORKDAY=131177,
    _NL_TIME_TIMEZONE=131179,
    _NL_TIME_WEEK_1STDAY=131174,
    _NL_TIME_WEEK_1STWEEK=131175,
    _NL_TIME_WEEK_NDAYS=131173,
    _NL_WABDAY_1=131124,
    _NL_WABDAY_2=131125,
    _NL_WABDAY_3=131126,
    _NL_WABDAY_4=131127,
    _NL_WABDAY_5=131128,
    _NL_WABDAY_6=131129,
    _NL_WABDAY_7=131130,
    _NL_WABMON_1=131138,
    _NL_WABMON_10=131147,
    _NL_WABMON_11=131148,
    _NL_WABMON_12=131149,
    _NL_WABMON_2=131139,
    _NL_WABMON_3=131140,
    _NL_WABMON_4=131141,
    _NL_WABMON_5=131142,
    _NL_WABMON_6=131143,
    _NL_WABMON_7=131144,
    _NL_WABMON_8=131145,
    _NL_WABMON_9=131146,
    _NL_WALT_DIGITS=131170,
    _NL_WAM_STR=131162,
    _NL_WDAY_1=131131,
    _NL_WDAY_2=131132,
    _NL_WDAY_3=131133,
    _NL_WDAY_4=131134,
    _NL_WDAY_5=131135,
    _NL_WDAY_6=131136,
    _NL_WDAY_7=131137,
    _NL_WD_FMT=131165,
    _NL_WD_T_FMT=131164,
    _NL_WERA_D_FMT=131169,
    _NL_WERA_D_T_FMT=131171,
    _NL_WERA_T_FMT=131172,
    _NL_WERA_YEAR=131168,
    _NL_WMON_1=131150,
    _NL_WMON_10=131159,
    _NL_WMON_11=131160,
    _NL_WMON_12=131161,
    _NL_WMON_2=131151,
    _NL_WMON_3=131152,
    _NL_WMON_4=131153,
    _NL_WMON_5=131154,
    _NL_WMON_6=131155,
    _NL_WMON_7=131156,
    _NL_WMON_8=131157,
    _NL_WMON_9=131158,
    _NL_WPM_STR=131163,
    _NL_WT_FMT=131166,
    _NL_WT_FMT_AMPM=131167,
    _NL_W_DATE_FMT=131181,
    __CURRENCY_SYMBOL=262145,
    __DECIMAL_POINT=65536,
    __ERA_YEAR=131117,
    __FRAC_DIGITS=262152,
    __GROUPING=65538,
    __INT_CURR_SYMBOL=262144,
    __INT_FRAC_DIGITS=262151,
    __INT_N_CS_PRECEDES=262162,
    __INT_N_SEP_BY_SPACE=262163,
    __INT_N_SIGN_POSN=262165,
    __INT_P_CS_PRECEDES=262160,
    __INT_P_SEP_BY_SPACE=262161,
    __INT_P_SIGN_POSN=262164,
    __LC_ADDRESS=9,
    __LC_ALL=6,
    __LC_COLLATE=3,
    __LC_CTYPE=0,
    __LC_IDENTIFICATION=12,
    __LC_MEASUREMENT=11,
    __LC_MESSAGES=5,
    __LC_MONETARY=4,
    __LC_NAME=8,
    __LC_NUMERIC=1,
    __LC_PAPER=7,
    __LC_TELEPHONE=10,
    __LC_TIME=2,
    __MON_DECIMAL_POINT=262146,
    __MON_GROUPING=262148,
    __MON_THOUSANDS_SEP=262147,
    __NEGATIVE_SIGN=262150,
    __NOEXPR=327681,
    __NOSTR=327683,
    __N_CS_PRECEDES=262155,
    __N_SEP_BY_SPACE=262156,
    __N_SIGN_POSN=262158,
    __POSITIVE_SIGN=262149,
    __P_CS_PRECEDES=262153,
    __P_SEP_BY_SPACE=262154,
    __P_SIGN_POSN=262157,
    __THOUSANDS_SEP=65537,
    __YESEXPR=327680,
    __YESSTR=327682
} anon_enum_32_for_mark.conflict4;

struct kbdprefix.conflict4 {
    int repeat_count;
    enum anon_enum_32_for_mark.conflict4 mark;
};

struct session.conflict4 {
    struct session * next;
    struct session * prev;
    struct window * tab;
    struct ses_history history;
    struct list_head_elinks more_files;
    struct download loading;
    struct uri * loading_uri;
    enum cache_mode reloadlevel;
    int redirect_cnt;
    struct document_view * doc_view;
    struct list_head_elinks scrn_frames;
    struct uri * download_uri;
    struct uri * referrer;
    struct session_task task;
    int search_direction;
    struct kbdprefix.conflict4 kbdprefix;
    int exit_query;
    timer_id_T display_timer;
    enum insert_mode insert_mode;
    enum navigate_mode navigate_mode;
    uchar * search_word;
    uchar * last_search_word;
    struct list_head_elinks type_queries;
    struct session_status status;
};

typedef struct widget_info_field widget_info_field, *Pwidget_info_field;

struct widget_info_field {
    int min;
    int max;
    struct input_history * history;
    enum inpfield_flags flags;
};

typedef struct session.conflict6 session.conflict6, *Psession.conflict6;

typedef struct kbdprefix.conflict6 kbdprefix.conflict6, *Pkbdprefix.conflict6;

typedef enum anon_enum_32_for_mark.conflict6 {
    ABDAY_1=131072,
    ABDAY_2=131073,
    ABDAY_3=131074,
    ABDAY_4=131075,
    ABDAY_5=131076,
    ABDAY_6=131077,
    ABDAY_7=131078,
    ABMON_1=131086,
    ABMON_10=131095,
    ABMON_11=131096,
    ABMON_12=131097,
    ABMON_2=131087,
    ABMON_3=131088,
    ABMON_4=131089,
    ABMON_5=131090,
    ABMON_6=131091,
    ABMON_7=131092,
    ABMON_8=131093,
    ABMON_9=131094,
    ALT_DIGITS=131119,
    AM_STR=131110,
    CODESET=14,
    DAY_1=131079,
    DAY_2=131080,
    DAY_3=131081,
    DAY_4=131082,
    DAY_5=131083,
    DAY_6=131084,
    DAY_7=131085,
    DOM_SCAN_END=2,
    DOM_SCAN_RANGE=0,
    DOM_SCAN_STRING=1,
    D_FMT=131113,
    D_T_FMT=131112,
    ERA=131116,
    ERA_D_FMT=131118,
    ERA_D_T_FMT=131120,
    ERA_T_FMT=131121,
    GNUTLS_CLIENT=2,
    GNUTLS_CRD_ANON=2,
    GNUTLS_CRD_CERTIFICATE=1,
    GNUTLS_CRD_IA=5,
    GNUTLS_CRD_PSK=4,
    GNUTLS_CRD_SRP=3,
    GNUTLS_KX_ANON_DH=4,
    GNUTLS_KX_DHE_DSS=2,
    GNUTLS_KX_DHE_PSK=10,
    GNUTLS_KX_DHE_RSA=3,
    GNUTLS_KX_PSK=9,
    GNUTLS_KX_RSA=1,
    GNUTLS_KX_RSA_EXPORT=6,
    GNUTLS_KX_SRP=5,
    GNUTLS_KX_SRP_DSS=8,
    GNUTLS_KX_SRP_RSA=7,
    GNUTLS_KX_UNKNOWN=0,
    GNUTLS_MAC_MD2=5,
    GNUTLS_MAC_MD5=2,
    GNUTLS_MAC_NULL=1,
    GNUTLS_MAC_RMD160=4,
    GNUTLS_MAC_SHA1=3,
    GNUTLS_MAC_SHA256=6,
    GNUTLS_MAC_SHA384=7,
    GNUTLS_MAC_SHA512=8,
    GNUTLS_MAC_UNKNOWN=0,
    GNUTLS_SERVER=1,
    GNUTLS_SHUT_RDWR=0,
    GNUTLS_SHUT_WR=1,
    GNUTLS_SSL3=1,
    GNUTLS_TLS1_0=2,
    GNUTLS_TLS1_1=3,
    GNUTLS_TLS1_2=4,
    GNUTLS_VERSION_UNKNOWN=255,
    GNUTLS_X509_FMT_DER=0,
    GNUTLS_X509_FMT_PEM=1,
    IDNA_CONTAINS_ACE_PREFIX=8,
    IDNA_CONTAINS_LDH=3,
    IDNA_CONTAINS_MINUS=4,
    IDNA_CONTAINS_NON_LDH=3,
    IDNA_DLOPEN_ERROR=202,
    IDNA_ICONV_ERROR=9,
    IDNA_INVALID_LENGTH=5,
    IDNA_MALLOC_ERROR=201,
    IDNA_NO_ACE_PREFIX=6,
    IDNA_PUNYCODE_ERROR=2,
    IDNA_ROUNDTRIP_VERIFY_ERROR=7,
    IDNA_STRINGPREP_ERROR=1,
    IDNA_SUCCESS=0,
    IPPROTO_AH=51,
    IPPROTO_COMP=108,
    IPPROTO_DCCP=33,
    IPPROTO_DSTOPTS=60,
    IPPROTO_EGP=8,
    IPPROTO_ENCAP=98,
    IPPROTO_ESP=50,
    IPPROTO_FRAGMENT=44,
    IPPROTO_GRE=47,
    IPPROTO_HOPOPTS=0,
    IPPROTO_ICMP=1,
    IPPROTO_ICMPV6=58,
    IPPROTO_IDP=22,
    IPPROTO_IGMP=2,
    IPPROTO_IP=0,
    IPPROTO_IPIP=4,
    IPPROTO_IPV6=41,
    IPPROTO_MAX=256,
    IPPROTO_MTP=92,
    IPPROTO_NONE=59,
    IPPROTO_PIM=103,
    IPPROTO_PUP=12,
    IPPROTO_RAW=255,
    IPPROTO_ROUTING=43,
    IPPROTO_RSVP=46,
    IPPROTO_SCTP=132,
    IPPROTO_TCP=6,
    IPPROTO_TP=29,
    IPPROTO_UDP=17,
    IPPROTO_UDPLITE=136,
    KP_MARK_GOTO=2,
    KP_MARK_NOTHING=0,
    KP_MARK_SET=1,
    MON_1=131098,
    MON_10=131107,
    MON_11=131108,
    MON_12=131109,
    MON_2=131099,
    MON_3=131100,
    MON_4=131101,
    MON_5=131102,
    MON_6=131103,
    MON_7=131104,
    MON_8=131105,
    MON_9=131106,
    PM_STR=131111,
    RADIXCHAR=65536,
    SCAN_END=2,
    SCAN_RANGE=0,
    SCAN_STRING=1,
    TERM_FN_RESIZE=2,
    TERM_FN_TITLE=1,
    TERM_FN_TITLE_CODEPAGE=3,
    THOUSEP=65537,
    T_FMT=131114,
    T_FMT_AMPM=131115,
    _DATE_FMT=131180,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096,
    _NL_ADDRESS_CODESET=589836,
    _NL_ADDRESS_COUNTRY_AB2=589827,
    _NL_ADDRESS_COUNTRY_AB3=589828,
    _NL_ADDRESS_COUNTRY_CAR=589829,
    _NL_ADDRESS_COUNTRY_ISBN=589831,
    _NL_ADDRESS_COUNTRY_NAME=589825,
    _NL_ADDRESS_COUNTRY_NUM=589830,
    _NL_ADDRESS_COUNTRY_POST=589826,
    _NL_ADDRESS_LANG_AB=589833,
    _NL_ADDRESS_LANG_LIB=589835,
    _NL_ADDRESS_LANG_NAME=589832,
    _NL_ADDRESS_LANG_TERM=589834,
    _NL_ADDRESS_POSTAL_FMT=589824,
    _NL_COLLATE_CODESET=196626,
    _NL_COLLATE_COLLSEQMB=196624,
    _NL_COLLATE_COLLSEQWC=196625,
    _NL_COLLATE_EXTRAMB=196612,
    _NL_COLLATE_EXTRAWC=196619,
    _NL_COLLATE_GAP1=196614,
    _NL_COLLATE_GAP2=196615,
    _NL_COLLATE_GAP3=196616,
    _NL_COLLATE_INDIRECTMB=196613,
    _NL_COLLATE_INDIRECTWC=196620,
    _NL_COLLATE_NRULES=196608,
    _NL_COLLATE_RULESETS=196609,
    _NL_COLLATE_SYMB_EXTRAMB=196623,
    _NL_COLLATE_SYMB_HASH_SIZEMB=196621,
    _NL_COLLATE_SYMB_TABLEMB=196622,
    _NL_COLLATE_TABLEMB=196610,
    _NL_COLLATE_TABLEWC=196617,
    _NL_COLLATE_WEIGHTMB=196611,
    _NL_COLLATE_WEIGHTWC=196618,
    _NL_CTYPE_CLASS=0,
    _NL_CTYPE_CLASS32=5,
    _NL_CTYPE_CLASS_NAMES=10,
    _NL_CTYPE_CLASS_OFFSET=17,
    _NL_CTYPE_CODESET_NAME=14,
    _NL_CTYPE_EXTRA_MAP_1=72,
    _NL_CTYPE_EXTRA_MAP_10=81,
    _NL_CTYPE_EXTRA_MAP_11=82,
    _NL_CTYPE_EXTRA_MAP_12=83,
    _NL_CTYPE_EXTRA_MAP_13=84,
    _NL_CTYPE_EXTRA_MAP_14=85,
    _NL_CTYPE_EXTRA_MAP_2=73,
    _NL_CTYPE_EXTRA_MAP_3=74,
    _NL_CTYPE_EXTRA_MAP_4=75,
    _NL_CTYPE_EXTRA_MAP_5=76,
    _NL_CTYPE_EXTRA_MAP_6=77,
    _NL_CTYPE_EXTRA_MAP_7=78,
    _NL_CTYPE_EXTRA_MAP_8=79,
    _NL_CTYPE_EXTRA_MAP_9=80,
    _NL_CTYPE_GAP1=2,
    _NL_CTYPE_GAP2=4,
    _NL_CTYPE_GAP3=6,
    _NL_CTYPE_GAP4=7,
    _NL_CTYPE_GAP5=8,
    _NL_CTYPE_GAP6=9,
    _NL_CTYPE_INDIGITS0_MB=20,
    _NL_CTYPE_INDIGITS0_WC=31,
    _NL_CTYPE_INDIGITS1_MB=21,
    _NL_CTYPE_INDIGITS1_WC=32,
    _NL_CTYPE_INDIGITS2_MB=22,
    _NL_CTYPE_INDIGITS2_WC=33,
    _NL_CTYPE_INDIGITS3_MB=23,
    _NL_CTYPE_INDIGITS3_WC=34,
    _NL_CTYPE_INDIGITS4_MB=24,
    _NL_CTYPE_INDIGITS4_WC=35,
    _NL_CTYPE_INDIGITS5_MB=25,
    _NL_CTYPE_INDIGITS5_WC=36,
    _NL_CTYPE_INDIGITS6_MB=26,
    _NL_CTYPE_INDIGITS6_WC=37,
    _NL_CTYPE_INDIGITS7_MB=27,
    _NL_CTYPE_INDIGITS7_WC=38,
    _NL_CTYPE_INDIGITS8_MB=28,
    _NL_CTYPE_INDIGITS8_WC=39,
    _NL_CTYPE_INDIGITS9_MB=29,
    _NL_CTYPE_INDIGITS9_WC=40,
    _NL_CTYPE_INDIGITS_MB_LEN=19,
    _NL_CTYPE_INDIGITS_WC_LEN=30,
    _NL_CTYPE_MAP_NAMES=11,
    _NL_CTYPE_MAP_OFFSET=18,
    _NL_CTYPE_MAP_TO_NONASCII=70,
    _NL_CTYPE_MB_CUR_MAX=13,
    _NL_CTYPE_NONASCII_CASE=71,
    _NL_CTYPE_OUTDIGIT0_MB=41,
    _NL_CTYPE_OUTDIGIT0_WC=51,
    _NL_CTYPE_OUTDIGIT1_MB=42,
    _NL_CTYPE_OUTDIGIT1_WC=52,
    _NL_CTYPE_OUTDIGIT2_MB=43,
    _NL_CTYPE_OUTDIGIT2_WC=53,
    _NL_CTYPE_OUTDIGIT3_MB=44,
    _NL_CTYPE_OUTDIGIT3_WC=54,
    _NL_CTYPE_OUTDIGIT4_MB=45,
    _NL_CTYPE_OUTDIGIT4_WC=55,
    _NL_CTYPE_OUTDIGIT5_MB=46,
    _NL_CTYPE_OUTDIGIT5_WC=56,
    _NL_CTYPE_OUTDIGIT6_MB=47,
    _NL_CTYPE_OUTDIGIT6_WC=57,
    _NL_CTYPE_OUTDIGIT7_MB=48,
    _NL_CTYPE_OUTDIGIT7_WC=58,
    _NL_CTYPE_OUTDIGIT8_MB=49,
    _NL_CTYPE_OUTDIGIT8_WC=59,
    _NL_CTYPE_OUTDIGIT9_MB=50,
    _NL_CTYPE_OUTDIGIT9_WC=60,
    _NL_CTYPE_TOLOWER=3,
    _NL_CTYPE_TOLOWER32=16,
    _NL_CTYPE_TOUPPER=1,
    _NL_CTYPE_TOUPPER32=15,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING=67,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN=66,
    _NL_CTYPE_TRANSLIT_FROM_IDX=62,
    _NL_CTYPE_TRANSLIT_FROM_TBL=63,
    _NL_CTYPE_TRANSLIT_IGNORE=69,
    _NL_CTYPE_TRANSLIT_IGNORE_LEN=68,
    _NL_CTYPE_TRANSLIT_TAB_SIZE=61,
    _NL_CTYPE_TRANSLIT_TO_IDX=64,
    _NL_CTYPE_TRANSLIT_TO_TBL=65,
    _NL_CTYPE_WIDTH=12,
    _NL_IDENTIFICATION_ABBREVIATION=786443,
    _NL_IDENTIFICATION_ADDRESS=786434,
    _NL_IDENTIFICATION_APPLICATION=786442,
    _NL_IDENTIFICATION_AUDIENCE=786441,
    _NL_IDENTIFICATION_CATEGORY=786446,
    _NL_IDENTIFICATION_CODESET=786447,
    _NL_IDENTIFICATION_CONTACT=786435,
    _NL_IDENTIFICATION_DATE=786445,
    _NL_IDENTIFICATION_EMAIL=786436,
    _NL_IDENTIFICATION_FAX=786438,
    _NL_IDENTIFICATION_LANGUAGE=786439,
    _NL_IDENTIFICATION_REVISION=786444,
    _NL_IDENTIFICATION_SOURCE=786433,
    _NL_IDENTIFICATION_TEL=786437,
    _NL_IDENTIFICATION_TERRITORY=786440,
    _NL_IDENTIFICATION_TITLE=786432,
    _NL_MEASUREMENT_CODESET=720897,
    _NL_MEASUREMENT_MEASUREMENT=720896,
    _NL_MESSAGES_CODESET=327684,
    _NL_MONETARY_CODESET=262189,
    _NL_MONETARY_CONVERSION_RATE=262186,
    _NL_MONETARY_CRNCYSTR=262159,
    _NL_MONETARY_DECIMAL_POINT_WC=262187,
    _NL_MONETARY_DUO_CURRENCY_SYMBOL=262167,
    _NL_MONETARY_DUO_FRAC_DIGITS=262169,
    _NL_MONETARY_DUO_INT_CURR_SYMBOL=262166,
    _NL_MONETARY_DUO_INT_FRAC_DIGITS=262168,
    _NL_MONETARY_DUO_INT_N_CS_PRECEDES=262176,
    _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE=262177,
    _NL_MONETARY_DUO_INT_N_SIGN_POSN=262181,
    _NL_MONETARY_DUO_INT_P_CS_PRECEDES=262174,
    _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE=262175,
    _NL_MONETARY_DUO_INT_P_SIGN_POSN=262180,
    _NL_MONETARY_DUO_N_CS_PRECEDES=262172,
    _NL_MONETARY_DUO_N_SEP_BY_SPACE=262173,
    _NL_MONETARY_DUO_N_SIGN_POSN=262179,
    _NL_MONETARY_DUO_P_CS_PRECEDES=262170,
    _NL_MONETARY_DUO_P_SEP_BY_SPACE=262171,
    _NL_MONETARY_DUO_P_SIGN_POSN=262178,
    _NL_MONETARY_DUO_VALID_FROM=262184,
    _NL_MONETARY_DUO_VALID_TO=262185,
    _NL_MONETARY_THOUSANDS_SEP_WC=262188,
    _NL_MONETARY_UNO_VALID_FROM=262182,
    _NL_MONETARY_UNO_VALID_TO=262183,
    _NL_NAME_CODESET=524294,
    _NL_NAME_NAME_FMT=524288,
    _NL_NAME_NAME_GEN=524289,
    _NL_NAME_NAME_MISS=524292,
    _NL_NAME_NAME_MR=524290,
    _NL_NAME_NAME_MRS=524291,
    _NL_NAME_NAME_MS=524293,
    _NL_NUM=786449,
    _NL_NUMERIC_CODESET=65541,
    _NL_NUMERIC_DECIMAL_POINT_WC=65539,
    _NL_NUMERIC_THOUSANDS_SEP_WC=65540,
    _NL_NUM_LC_ADDRESS=589837,
    _NL_NUM_LC_COLLATE=196627,
    _NL_NUM_LC_CTYPE=86,
    _NL_NUM_LC_IDENTIFICATION=786448,
    _NL_NUM_LC_MEASUREMENT=720898,
    _NL_NUM_LC_MESSAGES=327685,
    _NL_NUM_LC_MONETARY=262190,
    _NL_NUM_LC_NAME=524295,
    _NL_NUM_LC_NUMERIC=65542,
    _NL_NUM_LC_PAPER=458755,
    _NL_NUM_LC_TELEPHONE=655365,
    _NL_NUM_LC_TIME=131183,
    _NL_PAPER_CODESET=458754,
    _NL_PAPER_HEIGHT=458752,
    _NL_PAPER_WIDTH=458753,
    _NL_TELEPHONE_CODESET=655364,
    _NL_TELEPHONE_INT_PREFIX=655363,
    _NL_TELEPHONE_INT_SELECT=655362,
    _NL_TELEPHONE_TEL_DOM_FMT=655361,
    _NL_TELEPHONE_TEL_INT_FMT=655360,
    _NL_TIME_CAL_DIRECTION=131178,
    _NL_TIME_CODESET=131182,
    _NL_TIME_ERA_ENTRIES=131123,
    _NL_TIME_ERA_NUM_ENTRIES=131122,
    _NL_TIME_FIRST_WEEKDAY=131176,
    _NL_TIME_FIRST_WORKDAY=131177,
    _NL_TIME_TIMEZONE=131179,
    _NL_TIME_WEEK_1STDAY=131174,
    _NL_TIME_WEEK_1STWEEK=131175,
    _NL_TIME_WEEK_NDAYS=131173,
    _NL_WABDAY_1=131124,
    _NL_WABDAY_2=131125,
    _NL_WABDAY_3=131126,
    _NL_WABDAY_4=131127,
    _NL_WABDAY_5=131128,
    _NL_WABDAY_6=131129,
    _NL_WABDAY_7=131130,
    _NL_WABMON_1=131138,
    _NL_WABMON_10=131147,
    _NL_WABMON_11=131148,
    _NL_WABMON_12=131149,
    _NL_WABMON_2=131139,
    _NL_WABMON_3=131140,
    _NL_WABMON_4=131141,
    _NL_WABMON_5=131142,
    _NL_WABMON_6=131143,
    _NL_WABMON_7=131144,
    _NL_WABMON_8=131145,
    _NL_WABMON_9=131146,
    _NL_WALT_DIGITS=131170,
    _NL_WAM_STR=131162,
    _NL_WDAY_1=131131,
    _NL_WDAY_2=131132,
    _NL_WDAY_3=131133,
    _NL_WDAY_4=131134,
    _NL_WDAY_5=131135,
    _NL_WDAY_6=131136,
    _NL_WDAY_7=131137,
    _NL_WD_FMT=131165,
    _NL_WD_T_FMT=131164,
    _NL_WERA_D_FMT=131169,
    _NL_WERA_D_T_FMT=131171,
    _NL_WERA_T_FMT=131172,
    _NL_WERA_YEAR=131168,
    _NL_WMON_1=131150,
    _NL_WMON_10=131159,
    _NL_WMON_11=131160,
    _NL_WMON_12=131161,
    _NL_WMON_2=131151,
    _NL_WMON_3=131152,
    _NL_WMON_4=131153,
    _NL_WMON_5=131154,
    _NL_WMON_6=131155,
    _NL_WMON_7=131156,
    _NL_WMON_8=131157,
    _NL_WMON_9=131158,
    _NL_WPM_STR=131163,
    _NL_WT_FMT=131166,
    _NL_WT_FMT_AMPM=131167,
    _NL_W_DATE_FMT=131181,
    __CURRENCY_SYMBOL=262145,
    __DECIMAL_POINT=65536,
    __ERA_YEAR=131117,
    __FRAC_DIGITS=262152,
    __GROUPING=65538,
    __INT_CURR_SYMBOL=262144,
    __INT_FRAC_DIGITS=262151,
    __INT_N_CS_PRECEDES=262162,
    __INT_N_SEP_BY_SPACE=262163,
    __INT_N_SIGN_POSN=262165,
    __INT_P_CS_PRECEDES=262160,
    __INT_P_SEP_BY_SPACE=262161,
    __INT_P_SIGN_POSN=262164,
    __LC_ADDRESS=9,
    __LC_ALL=6,
    __LC_COLLATE=3,
    __LC_CTYPE=0,
    __LC_IDENTIFICATION=12,
    __LC_MEASUREMENT=11,
    __LC_MESSAGES=5,
    __LC_MONETARY=4,
    __LC_NAME=8,
    __LC_NUMERIC=1,
    __LC_PAPER=7,
    __LC_TELEPHONE=10,
    __LC_TIME=2,
    __MON_DECIMAL_POINT=262146,
    __MON_GROUPING=262148,
    __MON_THOUSANDS_SEP=262147,
    __NEGATIVE_SIGN=262150,
    __NOEXPR=327681,
    __NOSTR=327683,
    __N_CS_PRECEDES=262155,
    __N_SEP_BY_SPACE=262156,
    __N_SIGN_POSN=262158,
    __POSITIVE_SIGN=262149,
    __P_CS_PRECEDES=262153,
    __P_SEP_BY_SPACE=262154,
    __P_SIGN_POSN=262157,
    __THOUSANDS_SEP=65537,
    __YESEXPR=327680,
    __YESSTR=327682
} anon_enum_32_for_mark.conflict6;

struct kbdprefix.conflict6 {
    int repeat_count;
    enum anon_enum_32_for_mark.conflict6 mark;
};

struct session.conflict6 {
    struct session * next;
    struct session * prev;
    struct window * tab;
    struct ses_history history;
    struct list_head_elinks more_files;
    struct download loading;
    struct uri * loading_uri;
    enum cache_mode reloadlevel;
    int redirect_cnt;
    struct document_view * doc_view;
    struct list_head_elinks scrn_frames;
    struct uri * download_uri;
    struct uri * referrer;
    struct session_task task;
    int search_direction;
    struct kbdprefix.conflict6 kbdprefix;
    int exit_query;
    timer_id_T display_timer;
    enum insert_mode insert_mode;
    enum navigate_mode navigate_mode;
    uchar * search_word;
    uchar * last_search_word;
    struct list_head_elinks type_queries;
    struct session_status status;
};

typedef struct session.conflict8 session.conflict8, *Psession.conflict8;

typedef struct kbdprefix.conflict8 kbdprefix.conflict8, *Pkbdprefix.conflict8;

typedef enum anon_enum_32_for_mark.conflict8 {
    ABDAY_1=131072,
    ABDAY_2=131073,
    ABDAY_3=131074,
    ABDAY_4=131075,
    ABDAY_5=131076,
    ABDAY_6=131077,
    ABDAY_7=131078,
    ABMON_1=131086,
    ABMON_10=131095,
    ABMON_11=131096,
    ABMON_12=131097,
    ABMON_2=131087,
    ABMON_3=131088,
    ABMON_4=131089,
    ABMON_5=131090,
    ABMON_6=131091,
    ABMON_7=131092,
    ABMON_8=131093,
    ABMON_9=131094,
    ALT_DIGITS=131119,
    AM_STR=131110,
    CODESET=14,
    COMMON_DOWNLOAD_DO=0,
    CONTINUE_DOWNLOAD_DO=1,
    DAY_1=131079,
    DAY_2=131080,
    DAY_3=131081,
    DAY_4=131082,
    DAY_5=131083,
    DAY_6=131084,
    DAY_7=131085,
    DOM_SCAN_END=2,
    DOM_SCAN_RANGE=0,
    DOM_SCAN_STRING=1,
    D_FMT=131113,
    D_T_FMT=131112,
    ERA=131116,
    ERA_D_FMT=131118,
    ERA_D_T_FMT=131120,
    ERA_T_FMT=131121,
    GNUTLS_CLIENT=2,
    GNUTLS_CRD_ANON=2,
    GNUTLS_CRD_CERTIFICATE=1,
    GNUTLS_CRD_IA=5,
    GNUTLS_CRD_PSK=4,
    GNUTLS_CRD_SRP=3,
    GNUTLS_KX_ANON_DH=4,
    GNUTLS_KX_DHE_DSS=2,
    GNUTLS_KX_DHE_PSK=10,
    GNUTLS_KX_DHE_RSA=3,
    GNUTLS_KX_PSK=9,
    GNUTLS_KX_RSA=1,
    GNUTLS_KX_RSA_EXPORT=6,
    GNUTLS_KX_SRP=5,
    GNUTLS_KX_SRP_DSS=8,
    GNUTLS_KX_SRP_RSA=7,
    GNUTLS_KX_UNKNOWN=0,
    GNUTLS_MAC_MD2=5,
    GNUTLS_MAC_MD5=2,
    GNUTLS_MAC_NULL=1,
    GNUTLS_MAC_RMD160=4,
    GNUTLS_MAC_SHA1=3,
    GNUTLS_MAC_SHA256=6,
    GNUTLS_MAC_SHA384=7,
    GNUTLS_MAC_SHA512=8,
    GNUTLS_MAC_UNKNOWN=0,
    GNUTLS_SERVER=1,
    GNUTLS_SHUT_RDWR=0,
    GNUTLS_SHUT_WR=1,
    GNUTLS_SSL3=1,
    GNUTLS_TLS1_0=2,
    GNUTLS_TLS1_1=3,
    GNUTLS_TLS1_2=4,
    GNUTLS_VERSION_UNKNOWN=255,
    GNUTLS_X509_FMT_DER=0,
    GNUTLS_X509_FMT_PEM=1,
    IDNA_CONTAINS_ACE_PREFIX=8,
    IDNA_CONTAINS_LDH=3,
    IDNA_CONTAINS_MINUS=4,
    IDNA_CONTAINS_NON_LDH=3,
    IDNA_DLOPEN_ERROR=202,
    IDNA_ICONV_ERROR=9,
    IDNA_INVALID_LENGTH=5,
    IDNA_MALLOC_ERROR=201,
    IDNA_NO_ACE_PREFIX=6,
    IDNA_PUNYCODE_ERROR=2,
    IDNA_ROUNDTRIP_VERIFY_ERROR=7,
    IDNA_STRINGPREP_ERROR=1,
    IDNA_SUCCESS=0,
    IPPROTO_AH=51,
    IPPROTO_COMP=108,
    IPPROTO_DCCP=33,
    IPPROTO_DSTOPTS=60,
    IPPROTO_EGP=8,
    IPPROTO_ENCAP=98,
    IPPROTO_ESP=50,
    IPPROTO_FRAGMENT=44,
    IPPROTO_GRE=47,
    IPPROTO_HOPOPTS=0,
    IPPROTO_ICMP=1,
    IPPROTO_ICMPV6=58,
    IPPROTO_IDP=22,
    IPPROTO_IGMP=2,
    IPPROTO_IP=0,
    IPPROTO_IPIP=4,
    IPPROTO_IPV6=41,
    IPPROTO_MAX=256,
    IPPROTO_MTP=92,
    IPPROTO_NONE=59,
    IPPROTO_PIM=103,
    IPPROTO_PUP=12,
    IPPROTO_RAW=255,
    IPPROTO_ROUTING=43,
    IPPROTO_RSVP=46,
    IPPROTO_SCTP=132,
    IPPROTO_TCP=6,
    IPPROTO_TP=29,
    IPPROTO_UDP=17,
    IPPROTO_UDPLITE=136,
    KP_MARK_GOTO=2,
    KP_MARK_NOTHING=0,
    KP_MARK_SET=1,
    MON_1=131098,
    MON_10=131107,
    MON_11=131108,
    MON_12=131109,
    MON_2=131099,
    MON_3=131100,
    MON_4=131101,
    MON_5=131102,
    MON_6=131103,
    MON_7=131104,
    MON_8=131105,
    MON_9=131106,
    PM_STR=131111,
    RADIXCHAR=65536,
    SCAN_END=2,
    SCAN_RANGE=0,
    SCAN_STRING=1,
    TERM_FN_RESIZE=2,
    TERM_FN_TITLE=1,
    TERM_FN_TITLE_CODEPAGE=3,
    THOUSEP=65537,
    T_FMT=131114,
    T_FMT_AMPM=131115,
    _DATE_FMT=131180,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096,
    _NL_ADDRESS_CODESET=589836,
    _NL_ADDRESS_COUNTRY_AB2=589827,
    _NL_ADDRESS_COUNTRY_AB3=589828,
    _NL_ADDRESS_COUNTRY_CAR=589829,
    _NL_ADDRESS_COUNTRY_ISBN=589831,
    _NL_ADDRESS_COUNTRY_NAME=589825,
    _NL_ADDRESS_COUNTRY_NUM=589830,
    _NL_ADDRESS_COUNTRY_POST=589826,
    _NL_ADDRESS_LANG_AB=589833,
    _NL_ADDRESS_LANG_LIB=589835,
    _NL_ADDRESS_LANG_NAME=589832,
    _NL_ADDRESS_LANG_TERM=589834,
    _NL_ADDRESS_POSTAL_FMT=589824,
    _NL_COLLATE_CODESET=196626,
    _NL_COLLATE_COLLSEQMB=196624,
    _NL_COLLATE_COLLSEQWC=196625,
    _NL_COLLATE_EXTRAMB=196612,
    _NL_COLLATE_EXTRAWC=196619,
    _NL_COLLATE_GAP1=196614,
    _NL_COLLATE_GAP2=196615,
    _NL_COLLATE_GAP3=196616,
    _NL_COLLATE_INDIRECTMB=196613,
    _NL_COLLATE_INDIRECTWC=196620,
    _NL_COLLATE_NRULES=196608,
    _NL_COLLATE_RULESETS=196609,
    _NL_COLLATE_SYMB_EXTRAMB=196623,
    _NL_COLLATE_SYMB_HASH_SIZEMB=196621,
    _NL_COLLATE_SYMB_TABLEMB=196622,
    _NL_COLLATE_TABLEMB=196610,
    _NL_COLLATE_TABLEWC=196617,
    _NL_COLLATE_WEIGHTMB=196611,
    _NL_COLLATE_WEIGHTWC=196618,
    _NL_CTYPE_CLASS=0,
    _NL_CTYPE_CLASS32=5,
    _NL_CTYPE_CLASS_NAMES=10,
    _NL_CTYPE_CLASS_OFFSET=17,
    _NL_CTYPE_CODESET_NAME=14,
    _NL_CTYPE_EXTRA_MAP_1=72,
    _NL_CTYPE_EXTRA_MAP_10=81,
    _NL_CTYPE_EXTRA_MAP_11=82,
    _NL_CTYPE_EXTRA_MAP_12=83,
    _NL_CTYPE_EXTRA_MAP_13=84,
    _NL_CTYPE_EXTRA_MAP_14=85,
    _NL_CTYPE_EXTRA_MAP_2=73,
    _NL_CTYPE_EXTRA_MAP_3=74,
    _NL_CTYPE_EXTRA_MAP_4=75,
    _NL_CTYPE_EXTRA_MAP_5=76,
    _NL_CTYPE_EXTRA_MAP_6=77,
    _NL_CTYPE_EXTRA_MAP_7=78,
    _NL_CTYPE_EXTRA_MAP_8=79,
    _NL_CTYPE_EXTRA_MAP_9=80,
    _NL_CTYPE_GAP1=2,
    _NL_CTYPE_GAP2=4,
    _NL_CTYPE_GAP3=6,
    _NL_CTYPE_GAP4=7,
    _NL_CTYPE_GAP5=8,
    _NL_CTYPE_GAP6=9,
    _NL_CTYPE_INDIGITS0_MB=20,
    _NL_CTYPE_INDIGITS0_WC=31,
    _NL_CTYPE_INDIGITS1_MB=21,
    _NL_CTYPE_INDIGITS1_WC=32,
    _NL_CTYPE_INDIGITS2_MB=22,
    _NL_CTYPE_INDIGITS2_WC=33,
    _NL_CTYPE_INDIGITS3_MB=23,
    _NL_CTYPE_INDIGITS3_WC=34,
    _NL_CTYPE_INDIGITS4_MB=24,
    _NL_CTYPE_INDIGITS4_WC=35,
    _NL_CTYPE_INDIGITS5_MB=25,
    _NL_CTYPE_INDIGITS5_WC=36,
    _NL_CTYPE_INDIGITS6_MB=26,
    _NL_CTYPE_INDIGITS6_WC=37,
    _NL_CTYPE_INDIGITS7_MB=27,
    _NL_CTYPE_INDIGITS7_WC=38,
    _NL_CTYPE_INDIGITS8_MB=28,
    _NL_CTYPE_INDIGITS8_WC=39,
    _NL_CTYPE_INDIGITS9_MB=29,
    _NL_CTYPE_INDIGITS9_WC=40,
    _NL_CTYPE_INDIGITS_MB_LEN=19,
    _NL_CTYPE_INDIGITS_WC_LEN=30,
    _NL_CTYPE_MAP_NAMES=11,
    _NL_CTYPE_MAP_OFFSET=18,
    _NL_CTYPE_MAP_TO_NONASCII=70,
    _NL_CTYPE_MB_CUR_MAX=13,
    _NL_CTYPE_NONASCII_CASE=71,
    _NL_CTYPE_OUTDIGIT0_MB=41,
    _NL_CTYPE_OUTDIGIT0_WC=51,
    _NL_CTYPE_OUTDIGIT1_MB=42,
    _NL_CTYPE_OUTDIGIT1_WC=52,
    _NL_CTYPE_OUTDIGIT2_MB=43,
    _NL_CTYPE_OUTDIGIT2_WC=53,
    _NL_CTYPE_OUTDIGIT3_MB=44,
    _NL_CTYPE_OUTDIGIT3_WC=54,
    _NL_CTYPE_OUTDIGIT4_MB=45,
    _NL_CTYPE_OUTDIGIT4_WC=55,
    _NL_CTYPE_OUTDIGIT5_MB=46,
    _NL_CTYPE_OUTDIGIT5_WC=56,
    _NL_CTYPE_OUTDIGIT6_MB=47,
    _NL_CTYPE_OUTDIGIT6_WC=57,
    _NL_CTYPE_OUTDIGIT7_MB=48,
    _NL_CTYPE_OUTDIGIT7_WC=58,
    _NL_CTYPE_OUTDIGIT8_MB=49,
    _NL_CTYPE_OUTDIGIT8_WC=59,
    _NL_CTYPE_OUTDIGIT9_MB=50,
    _NL_CTYPE_OUTDIGIT9_WC=60,
    _NL_CTYPE_TOLOWER=3,
    _NL_CTYPE_TOLOWER32=16,
    _NL_CTYPE_TOUPPER=1,
    _NL_CTYPE_TOUPPER32=15,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING=67,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN=66,
    _NL_CTYPE_TRANSLIT_FROM_IDX=62,
    _NL_CTYPE_TRANSLIT_FROM_TBL=63,
    _NL_CTYPE_TRANSLIT_IGNORE=69,
    _NL_CTYPE_TRANSLIT_IGNORE_LEN=68,
    _NL_CTYPE_TRANSLIT_TAB_SIZE=61,
    _NL_CTYPE_TRANSLIT_TO_IDX=64,
    _NL_CTYPE_TRANSLIT_TO_TBL=65,
    _NL_CTYPE_WIDTH=12,
    _NL_IDENTIFICATION_ABBREVIATION=786443,
    _NL_IDENTIFICATION_ADDRESS=786434,
    _NL_IDENTIFICATION_APPLICATION=786442,
    _NL_IDENTIFICATION_AUDIENCE=786441,
    _NL_IDENTIFICATION_CATEGORY=786446,
    _NL_IDENTIFICATION_CODESET=786447,
    _NL_IDENTIFICATION_CONTACT=786435,
    _NL_IDENTIFICATION_DATE=786445,
    _NL_IDENTIFICATION_EMAIL=786436,
    _NL_IDENTIFICATION_FAX=786438,
    _NL_IDENTIFICATION_LANGUAGE=786439,
    _NL_IDENTIFICATION_REVISION=786444,
    _NL_IDENTIFICATION_SOURCE=786433,
    _NL_IDENTIFICATION_TEL=786437,
    _NL_IDENTIFICATION_TERRITORY=786440,
    _NL_IDENTIFICATION_TITLE=786432,
    _NL_MEASUREMENT_CODESET=720897,
    _NL_MEASUREMENT_MEASUREMENT=720896,
    _NL_MESSAGES_CODESET=327684,
    _NL_MONETARY_CODESET=262189,
    _NL_MONETARY_CONVERSION_RATE=262186,
    _NL_MONETARY_CRNCYSTR=262159,
    _NL_MONETARY_DECIMAL_POINT_WC=262187,
    _NL_MONETARY_DUO_CURRENCY_SYMBOL=262167,
    _NL_MONETARY_DUO_FRAC_DIGITS=262169,
    _NL_MONETARY_DUO_INT_CURR_SYMBOL=262166,
    _NL_MONETARY_DUO_INT_FRAC_DIGITS=262168,
    _NL_MONETARY_DUO_INT_N_CS_PRECEDES=262176,
    _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE=262177,
    _NL_MONETARY_DUO_INT_N_SIGN_POSN=262181,
    _NL_MONETARY_DUO_INT_P_CS_PRECEDES=262174,
    _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE=262175,
    _NL_MONETARY_DUO_INT_P_SIGN_POSN=262180,
    _NL_MONETARY_DUO_N_CS_PRECEDES=262172,
    _NL_MONETARY_DUO_N_SEP_BY_SPACE=262173,
    _NL_MONETARY_DUO_N_SIGN_POSN=262179,
    _NL_MONETARY_DUO_P_CS_PRECEDES=262170,
    _NL_MONETARY_DUO_P_SEP_BY_SPACE=262171,
    _NL_MONETARY_DUO_P_SIGN_POSN=262178,
    _NL_MONETARY_DUO_VALID_FROM=262184,
    _NL_MONETARY_DUO_VALID_TO=262185,
    _NL_MONETARY_THOUSANDS_SEP_WC=262188,
    _NL_MONETARY_UNO_VALID_FROM=262182,
    _NL_MONETARY_UNO_VALID_TO=262183,
    _NL_NAME_CODESET=524294,
    _NL_NAME_NAME_FMT=524288,
    _NL_NAME_NAME_GEN=524289,
    _NL_NAME_NAME_MISS=524292,
    _NL_NAME_NAME_MR=524290,
    _NL_NAME_NAME_MRS=524291,
    _NL_NAME_NAME_MS=524293,
    _NL_NUM=786449,
    _NL_NUMERIC_CODESET=65541,
    _NL_NUMERIC_DECIMAL_POINT_WC=65539,
    _NL_NUMERIC_THOUSANDS_SEP_WC=65540,
    _NL_NUM_LC_ADDRESS=589837,
    _NL_NUM_LC_COLLATE=196627,
    _NL_NUM_LC_CTYPE=86,
    _NL_NUM_LC_IDENTIFICATION=786448,
    _NL_NUM_LC_MEASUREMENT=720898,
    _NL_NUM_LC_MESSAGES=327685,
    _NL_NUM_LC_MONETARY=262190,
    _NL_NUM_LC_NAME=524295,
    _NL_NUM_LC_NUMERIC=65542,
    _NL_NUM_LC_PAPER=458755,
    _NL_NUM_LC_TELEPHONE=655365,
    _NL_NUM_LC_TIME=131183,
    _NL_PAPER_CODESET=458754,
    _NL_PAPER_HEIGHT=458752,
    _NL_PAPER_WIDTH=458753,
    _NL_TELEPHONE_CODESET=655364,
    _NL_TELEPHONE_INT_PREFIX=655363,
    _NL_TELEPHONE_INT_SELECT=655362,
    _NL_TELEPHONE_TEL_DOM_FMT=655361,
    _NL_TELEPHONE_TEL_INT_FMT=655360,
    _NL_TIME_CAL_DIRECTION=131178,
    _NL_TIME_CODESET=131182,
    _NL_TIME_ERA_ENTRIES=131123,
    _NL_TIME_ERA_NUM_ENTRIES=131122,
    _NL_TIME_FIRST_WEEKDAY=131176,
    _NL_TIME_FIRST_WORKDAY=131177,
    _NL_TIME_TIMEZONE=131179,
    _NL_TIME_WEEK_1STDAY=131174,
    _NL_TIME_WEEK_1STWEEK=131175,
    _NL_TIME_WEEK_NDAYS=131173,
    _NL_WABDAY_1=131124,
    _NL_WABDAY_2=131125,
    _NL_WABDAY_3=131126,
    _NL_WABDAY_4=131127,
    _NL_WABDAY_5=131128,
    _NL_WABDAY_6=131129,
    _NL_WABDAY_7=131130,
    _NL_WABMON_1=131138,
    _NL_WABMON_10=131147,
    _NL_WABMON_11=131148,
    _NL_WABMON_12=131149,
    _NL_WABMON_2=131139,
    _NL_WABMON_3=131140,
    _NL_WABMON_4=131141,
    _NL_WABMON_5=131142,
    _NL_WABMON_6=131143,
    _NL_WABMON_7=131144,
    _NL_WABMON_8=131145,
    _NL_WABMON_9=131146,
    _NL_WALT_DIGITS=131170,
    _NL_WAM_STR=131162,
    _NL_WDAY_1=131131,
    _NL_WDAY_2=131132,
    _NL_WDAY_3=131133,
    _NL_WDAY_4=131134,
    _NL_WDAY_5=131135,
    _NL_WDAY_6=131136,
    _NL_WDAY_7=131137,
    _NL_WD_FMT=131165,
    _NL_WD_T_FMT=131164,
    _NL_WERA_D_FMT=131169,
    _NL_WERA_D_T_FMT=131171,
    _NL_WERA_T_FMT=131172,
    _NL_WERA_YEAR=131168,
    _NL_WMON_1=131150,
    _NL_WMON_10=131159,
    _NL_WMON_11=131160,
    _NL_WMON_12=131161,
    _NL_WMON_2=131151,
    _NL_WMON_3=131152,
    _NL_WMON_4=131153,
    _NL_WMON_5=131154,
    _NL_WMON_6=131155,
    _NL_WMON_7=131156,
    _NL_WMON_8=131157,
    _NL_WMON_9=131158,
    _NL_WPM_STR=131163,
    _NL_WT_FMT=131166,
    _NL_WT_FMT_AMPM=131167,
    _NL_W_DATE_FMT=131181,
    _SC_2_CHAR_TERM=95,
    _SC_2_C_BIND=47,
    _SC_2_C_DEV=48,
    _SC_2_C_VERSION=96,
    _SC_2_FORT_DEV=49,
    _SC_2_FORT_RUN=50,
    _SC_2_LOCALEDEF=52,
    _SC_2_PBS=168,
    _SC_2_PBS_ACCOUNTING=169,
    _SC_2_PBS_CHECKPOINT=175,
    _SC_2_PBS_LOCATE=170,
    _SC_2_PBS_MESSAGE=171,
    _SC_2_PBS_TRACK=172,
    _SC_2_SW_DEV=51,
    _SC_2_UPE=97,
    _SC_2_VERSION=46,
    _SC_ADVISORY_INFO=132,
    _SC_AIO_LISTIO_MAX=23,
    _SC_AIO_MAX=24,
    _SC_AIO_PRIO_DELTA_MAX=25,
    _SC_ARG_MAX=0,
    _SC_ASYNCHRONOUS_IO=12,
    _SC_ATEXIT_MAX=87,
    _SC_AVPHYS_PAGES=86,
    _SC_BARRIERS=133,
    _SC_BASE=134,
    _SC_BC_BASE_MAX=36,
    _SC_BC_DIM_MAX=37,
    _SC_BC_SCALE_MAX=38,
    _SC_BC_STRING_MAX=39,
    _SC_CHARCLASS_NAME_MAX=45,
    _SC_CHAR_BIT=101,
    _SC_CHAR_MAX=102,
    _SC_CHAR_MIN=103,
    _SC_CHILD_MAX=1,
    _SC_CLK_TCK=2,
    _SC_CLOCK_SELECTION=137,
    _SC_COLL_WEIGHTS_MAX=40,
    _SC_CPUTIME=138,
    _SC_C_LANG_SUPPORT=135,
    _SC_C_LANG_SUPPORT_R=136,
    _SC_DELAYTIMER_MAX=26,
    _SC_DEVICE_IO=140,
    _SC_DEVICE_SPECIFIC=141,
    _SC_DEVICE_SPECIFIC_R=142,
    _SC_EQUIV_CLASS_MAX=41,
    _SC_EXPR_NEST_MAX=42,
    _SC_FD_MGMT=143,
    _SC_FIFO=144,
    _SC_FILE_ATTRIBUTES=146,
    _SC_FILE_LOCKING=147,
    _SC_FILE_SYSTEM=148,
    _SC_FSYNC=15,
    _SC_GETGR_R_SIZE_MAX=69,
    _SC_GETPW_R_SIZE_MAX=70,
    _SC_HOST_NAME_MAX=180,
    _SC_INT_MAX=104,
    _SC_INT_MIN=105,
    _SC_IOV_MAX=60,
    _SC_IPV6=235,
    _SC_JOB_CONTROL=7,
    _SC_LEVEL1_DCACHE_ASSOC=189,
    _SC_LEVEL1_DCACHE_LINESIZE=190,
    _SC_LEVEL1_DCACHE_SIZE=188,
    _SC_LEVEL1_ICACHE_ASSOC=186,
    _SC_LEVEL1_ICACHE_LINESIZE=187,
    _SC_LEVEL1_ICACHE_SIZE=185,
    _SC_LEVEL2_CACHE_ASSOC=192,
    _SC_LEVEL2_CACHE_LINESIZE=193,
    _SC_LEVEL2_CACHE_SIZE=191,
    _SC_LEVEL3_CACHE_ASSOC=195,
    _SC_LEVEL3_CACHE_LINESIZE=196,
    _SC_LEVEL3_CACHE_SIZE=194,
    _SC_LEVEL4_CACHE_ASSOC=198,
    _SC_LEVEL4_CACHE_LINESIZE=199,
    _SC_LEVEL4_CACHE_SIZE=197,
    _SC_LINE_MAX=43,
    _SC_LOGIN_NAME_MAX=71,
    _SC_LONG_BIT=106,
    _SC_MAPPED_FILES=16,
    _SC_MB_LEN_MAX=108,
    _SC_MEMLOCK=17,
    _SC_MEMLOCK_RANGE=18,
    _SC_MEMORY_PROTECTION=19,
    _SC_MESSAGE_PASSING=20,
    _SC_MONOTONIC_CLOCK=149,
    _SC_MQ_OPEN_MAX=27,
    _SC_MQ_PRIO_MAX=28,
    _SC_MULTI_PROCESS=150,
    _SC_NETWORKING=152,
    _SC_NGROUPS_MAX=3,
    _SC_NL_ARGMAX=119,
    _SC_NL_LANGMAX=120,
    _SC_NL_MSGMAX=121,
    _SC_NL_NMAX=122,
    _SC_NL_SETMAX=123,
    _SC_NL_TEXTMAX=124,
    _SC_NPROCESSORS_CONF=83,
    _SC_NPROCESSORS_ONLN=84,
    _SC_NZERO=109,
    _SC_OPEN_MAX=4,
    _SC_PAGESIZE=30,
    _SC_PASS_MAX=88,
    _SC_PHYS_PAGES=85,
    _SC_PII=53,
    _SC_PII_INTERNET=56,
    _SC_PII_INTERNET_DGRAM=62,
    _SC_PII_INTERNET_STREAM=61,
    _SC_PII_OSI=57,
    _SC_PII_OSI_CLTS=64,
    _SC_PII_OSI_COTS=63,
    _SC_PII_OSI_M=65,
    _SC_PII_SOCKET=55,
    _SC_PII_XTI=54,
    _SC_PIPE=145,
    _SC_POLL=58,
    _SC_PRIORITIZED_IO=13,
    _SC_PRIORITY_SCHEDULING=10,
    _SC_RAW_SOCKETS=236,
    _SC_READER_WRITER_LOCKS=153,
    _SC_REALTIME_SIGNALS=9,
    _SC_REGEXP=155,
    _SC_REGEX_VERSION=156,
    _SC_RE_DUP_MAX=44,
    _SC_RTSIG_MAX=31,
    _SC_SAVED_IDS=8,
    _SC_SCHAR_MAX=111,
    _SC_SCHAR_MIN=112,
    _SC_SELECT=59,
    _SC_SEMAPHORES=21,
    _SC_SEM_NSEMS_MAX=32,
    _SC_SEM_VALUE_MAX=33,
    _SC_SHARED_MEMORY_OBJECTS=22,
    _SC_SHELL=157,
    _SC_SHRT_MAX=113,
    _SC_SHRT_MIN=114,
    _SC_SIGNALS=158,
    _SC_SIGQUEUE_MAX=34,
    _SC_SINGLE_PROCESS=151,
    _SC_SPAWN=159,
    _SC_SPIN_LOCKS=154,
    _SC_SPORADIC_SERVER=160,
    _SC_SSIZE_MAX=110,
    _SC_SS_REPL_MAX=241,
    _SC_STREAMS=174,
    _SC_STREAM_MAX=5,
    _SC_SYMLOOP_MAX=173,
    _SC_SYNCHRONIZED_IO=14,
    _SC_SYSTEM_DATABASE=162,
    _SC_SYSTEM_DATABASE_R=163,
    _SC_THREADS=67,
    _SC_THREAD_ATTR_STACKADDR=77,
    _SC_THREAD_ATTR_STACKSIZE=78,
    _SC_THREAD_CPUTIME=139,
    _SC_THREAD_DESTRUCTOR_ITERATIONS=73,
    _SC_THREAD_KEYS_MAX=74,
    _SC_THREAD_PRIORITY_SCHEDULING=79,
    _SC_THREAD_PRIO_INHERIT=80,
    _SC_THREAD_PRIO_PROTECT=81,
    _SC_THREAD_PROCESS_SHARED=82,
    _SC_THREAD_ROBUST_PRIO_INHERIT=247,
    _SC_THREAD_ROBUST_PRIO_PROTECT=248,
    _SC_THREAD_SAFE_FUNCTIONS=68,
    _SC_THREAD_SPORADIC_SERVER=161,
    _SC_THREAD_STACK_MIN=75,
    _SC_THREAD_THREADS_MAX=76,
    _SC_TIMEOUTS=164,
    _SC_TIMERS=11,
    _SC_TIMER_MAX=35,
    _SC_TRACE=181,
    _SC_TRACE_EVENT_FILTER=182,
    _SC_TRACE_EVENT_NAME_MAX=242,
    _SC_TRACE_INHERIT=183,
    _SC_TRACE_LOG=184,
    _SC_TRACE_NAME_MAX=243,
    _SC_TRACE_SYS_MAX=244,
    _SC_TRACE_USER_EVENT_MAX=245,
    _SC_TTY_NAME_MAX=72,
    _SC_TYPED_MEMORY_OBJECTS=165,
    _SC_TZNAME_MAX=6,
    _SC_T_IOV_MAX=66,
    _SC_UCHAR_MAX=115,
    _SC_UINT_MAX=116,
    _SC_UIO_MAXIOV=60,
    _SC_ULONG_MAX=117,
    _SC_USER_GROUPS=166,
    _SC_USER_GROUPS_R=167,
    _SC_USHRT_MAX=118,
    _SC_V6_ILP32_OFF32=176,
    _SC_V6_ILP32_OFFBIG=177,
    _SC_V6_LP64_OFF64=178,
    _SC_V6_LPBIG_OFFBIG=179,
    _SC_V7_ILP32_OFF32=237,
    _SC_V7_ILP32_OFFBIG=238,
    _SC_V7_LP64_OFF64=239,
    _SC_V7_LPBIG_OFFBIG=240,
    _SC_VERSION=29,
    _SC_WORD_BIT=107,
    _SC_XBS5_ILP32_OFF32=125,
    _SC_XBS5_ILP32_OFFBIG=126,
    _SC_XBS5_LP64_OFF64=127,
    _SC_XBS5_LPBIG_OFFBIG=128,
    _SC_XOPEN_CRYPT=92,
    _SC_XOPEN_ENH_I18N=93,
    _SC_XOPEN_LEGACY=129,
    _SC_XOPEN_REALTIME=130,
    _SC_XOPEN_REALTIME_THREADS=131,
    _SC_XOPEN_SHM=94,
    _SC_XOPEN_STREAMS=246,
    _SC_XOPEN_UNIX=91,
    _SC_XOPEN_VERSION=89,
    _SC_XOPEN_XCU_VERSION=90,
    _SC_XOPEN_XPG2=98,
    _SC_XOPEN_XPG3=99,
    _SC_XOPEN_XPG4=100,
    __CURRENCY_SYMBOL=262145,
    __DECIMAL_POINT=65536,
    __ERA_YEAR=131117,
    __FRAC_DIGITS=262152,
    __GROUPING=65538,
    __INT_CURR_SYMBOL=262144,
    __INT_FRAC_DIGITS=262151,
    __INT_N_CS_PRECEDES=262162,
    __INT_N_SEP_BY_SPACE=262163,
    __INT_N_SIGN_POSN=262165,
    __INT_P_CS_PRECEDES=262160,
    __INT_P_SEP_BY_SPACE=262161,
    __INT_P_SIGN_POSN=262164,
    __LC_ADDRESS=9,
    __LC_ALL=6,
    __LC_COLLATE=3,
    __LC_CTYPE=0,
    __LC_IDENTIFICATION=12,
    __LC_MEASUREMENT=11,
    __LC_MESSAGES=5,
    __LC_MONETARY=4,
    __LC_NAME=8,
    __LC_NUMERIC=1,
    __LC_PAPER=7,
    __LC_TELEPHONE=10,
    __LC_TIME=2,
    __MON_DECIMAL_POINT=262146,
    __MON_GROUPING=262148,
    __MON_THOUSANDS_SEP=262147,
    __NEGATIVE_SIGN=262150,
    __NOEXPR=327681,
    __NOSTR=327683,
    __N_CS_PRECEDES=262155,
    __N_SEP_BY_SPACE=262156,
    __N_SIGN_POSN=262158,
    __POSITIVE_SIGN=262149,
    __P_CS_PRECEDES=262153,
    __P_SEP_BY_SPACE=262154,
    __P_SIGN_POSN=262157,
    __THOUSANDS_SEP=65537,
    __YESEXPR=327680,
    __YESSTR=327682
} anon_enum_32_for_mark.conflict8;

struct kbdprefix.conflict8 {
    int repeat_count;
    enum anon_enum_32_for_mark.conflict8 mark;
};

struct session.conflict8 {
    struct session * next;
    struct session * prev;
    struct window * tab;
    struct ses_history history;
    struct list_head_elinks more_files;
    struct download loading;
    struct uri * loading_uri;
    enum cache_mode reloadlevel;
    int redirect_cnt;
    struct document_view * doc_view;
    struct list_head_elinks scrn_frames;
    struct uri * download_uri;
    struct uri * referrer;
    struct session_task task;
    int search_direction;
    struct kbdprefix.conflict8 kbdprefix;
    int exit_query;
    timer_id_T display_timer;
    enum insert_mode insert_mode;
    enum navigate_mode navigate_mode;
    uchar * search_word;
    uchar * last_search_word;
    struct list_head_elinks type_queries;
    struct session_status status;
};

typedef struct tree_node tree_node, *Ptree_node;

struct tree_node {
    uchar * name;
    uchar * text;
    struct list_head_elinks attrs;
    struct tree_node * parent;
    struct tree_node * children;
    struct tree_node * prev;
    struct tree_node * next;
};

typedef struct attributes attributes, *Pattributes;

struct attributes {
    struct attributes * next;
    struct attributes * prev;
    uchar * name;
    uchar * value;
};

typedef struct read_bookmarks_xbel read_bookmarks_xbel, *Pread_bookmarks_xbel;

struct read_bookmarks_xbel {
    int utf8_cp;
};

typedef struct module module, *Pmodule;

typedef struct option_info option_info, *Poption_info;

typedef struct event_hook_info event_hook_info, *Pevent_hook_info;

typedef enum evhook_status {
    EVENT_HOOK_STATUS_LAST=1,
    EVENT_HOOK_STATUS_NEXT=0
} evhook_status;

typedef __gnuc_va_list va_list;

struct event_hook_info {
    uchar * name;
    int priority;
    evhook_status (* callback)(va_list, void *);
    void * data;
};

struct option_info {
    struct option_elinks option_elinks;
    uchar * path;
};

struct module {
    uchar * name;
    struct option_info * options;
    struct event_hook_info * hooks;
    struct module * * submodules;
    void * data;
    void (* init)(struct module *);
    void (* done)(struct module *);
};

typedef struct secure_save_info secure_save_info, *Psecure_save_info;


// WARNING! conflicting data type names: /DWARF/stdio.h/FILE - /stdio.h/FILE

struct secure_save_info {
    FILE * fp;
    uchar * file_name;
    uchar * tmp_file_name;
    int err;
    int secure_save;
};

typedef enum secsave_errno {
    SS_ERR_ACCESS=6,
    SS_ERR_DISABLED=1,
    SS_ERR_MKSTEMP=7,
    SS_ERR_NONE=0,
    SS_ERR_OPEN_READ=3,
    SS_ERR_OPEN_WRITE=4,
    SS_ERR_OTHER=9,
    SS_ERR_OUT_OF_MEM=2,
    SS_ERR_RENAME=8,
    SS_ERR_STAT=5
} secsave_errno;

typedef enum global_history_options {
    GLOBHIST_DISPLAY_TYPE=3,
    GLOBHIST_ENABLE=1,
    GLOBHIST_MAX_ITEMS=2,
    GLOBHIST_OPTIONS=4,
    GLOBHIST_TREE=0
} global_history_options;

typedef struct s_msg_dsc s_msg_dsc, *Ps_msg_dsc;

struct s_msg_dsc {
    int n;
    uchar * msg;
};

typedef struct strerror_val strerror_val, *Pstrerror_val;

struct strerror_val {
    struct strerror_val * next;
    struct strerror_val * prev;
    uchar msg[1];
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
};

typedef struct global_history_item global_history_item, *Pglobal_history_item;

struct global_history_item {
    struct global_history_item * next;
    struct global_history_item * prev;
    struct object object;
    struct listbox_item * box_item;
    uchar * title;
    uchar * url;
    time_t last_visit;
};


// WARNING! conflicting data type names: /DWARF/kbd.c/resize_terminal_from_str/anon_enum_32 - /DWARF/explodename.c/_nl_explode_name/anon_enum_32

typedef enum term_event_special_key {
    KBD_BS=-257,
    KBD_CTRL_C=-512,
    KBD_DEL=-265,
    KBD_DOWN=-263,
    KBD_END=-267,
    KBD_ENTER=-256,
    KBD_ESC=-259,
    KBD_F1=-288,
    KBD_F10=-297,
    KBD_F11=-298,
    KBD_F12=-299,
    KBD_F2=-289,
    KBD_F3=-290,
    KBD_F4=-291,
    KBD_F5=-292,
    KBD_F6=-293,
    KBD_F7=-294,
    KBD_F8=-295,
    KBD_F9=-296,
    KBD_HOME=-266,
    KBD_INS=-264,
    KBD_LEFT=-260,
    KBD_PAGE_DOWN=-269,
    KBD_PAGE_UP=-268,
    KBD_RIGHT=-261,
    KBD_TAB=-258,
    KBD_UNDEF=-1,
    KBD_UP=-262
} term_event_special_key;

typedef struct itrm itrm, *Pitrm;

typedef struct itrm_in itrm_in, *Pitrm_in;

typedef struct itrm_out itrm_out, *Pitrm_out;

typedef struct itrm_queue itrm_queue, *Pitrm_queue;

struct itrm_queue {
    uchar * data;
    int len;
};

struct itrm_in {
    int std;
    int sock;
    int ctl;
    struct itrm_queue queue;
};

struct itrm_out {
    int std;
    int sock;
    struct itrm_queue queue;
};

struct itrm {
    struct itrm_in in;
    struct itrm_out out;
    timer_id_T timer;
    struct termios t;
    void * mouse_h;
    uchar * orig_title;
    int verase;
    int title_codepage;
    uint blocked:1;
    uint altscreen:1;
    uint touched_title:1;
    uint remote:1;
    undefined field_0x75;
    undefined field_0x76;
    undefined field_0x77;
};

typedef struct interlink_event_keyboard interlink_event_keyboard, *Pinterlink_event_keyboard;

struct interlink_event_keyboard {
    int key;
    int modifier;
};

typedef unicode_val_T term_event_char_T;

typedef struct http_code http_code, *Phttp_code;

struct http_code {
    int num;
    uchar * str;
};

typedef struct http_error_info http_error_info, *Phttp_error_info;

struct http_error_info {
    int code;
    struct uri * uri;
};

typedef enum uri_component {
    URI_BASE=-32065,
    URI_DATA=128,
    URI_DEFAULT_PORT=64,
    URI_DIR_LOCATION=2097,
    URI_DNS_HOST=2064,
    URI_FILENAME=8192,
    URI_FORM_GET=-28609,
    URI_FRAGMENT=256,
    URI_HOST=16,
    URI_HTTP_AUTH=-32717,
    URI_HTTP_CONNECT=112,
    URI_HTTP_HOST=2096,
    URI_HTTP_REFERRER=177,
    URI_HTTP_REFERRER_HOST=49,
    URI_IDN=2048,
    URI_IP_FAMILY=2,
    URI_KEEPALIVE=61,
    URI_ORIGINAL=-32321,
    URI_PASSWORD=8,
    URI_PATH=4096,
    URI_PORT=32,
    URI_POST=512,
    URI_POST_INFO=1024,
    URI_PROTOCOL=1,
    URI_PROXY=-30529,
    URI_PUBLIC=-31305,
    URI_QUERY=16384,
    URI_RARE=32320,
    URI_SERVER=-32705,
    URI_SPECIAL=28736,
    URI_USER=4
} uri_component;

typedef enum uri_errno {
    URI_ERRNO_EMPTY=1,
    URI_ERRNO_INVALID_PORT=10,
    URI_ERRNO_INVALID_PORT_RANGE=11,
    URI_ERRNO_INVALID_PROTOCOL=2,
    URI_ERRNO_IPV6_SECURITY=9,
    URI_ERRNO_NO_HOST=6,
    URI_ERRNO_NO_HOST_SLASH=8,
    URI_ERRNO_NO_PORT_COLON=7,
    URI_ERRNO_NO_SLASHES=3,
    URI_ERRNO_OK=0,
    URI_ERRNO_TOO_MANY_SLASHES=4,
    URI_ERRNO_TRAILING_DOTS=5
} uri_errno;

typedef enum parse_header_param {
    HEADER_PARAM_FOUND=0,
    HEADER_PARAM_NOT_FOUND=1,
    HEADER_PARAM_OUT_OF_MEMORY=2
} parse_header_param;

typedef struct uri_cache_entry uri_cache_entry, *Puri_cache_entry;

struct uri_cache_entry {
    struct uri uri;
    uchar string[1];
    undefined field_0x3d;
    undefined field_0x3e;
    undefined field_0x3f;
};

typedef struct uri_cache uri_cache, *Puri_cache;

struct uri_cache {
    struct hash * map;
    struct object object;
};

typedef struct progress.conflict progress.conflict, *Pprogress.conflict;

struct progress.conflict {
    struct timeval_T elapsed;
    struct timeval_T last_time;
    struct timeval_T dis_b;
    struct timeval_T estimated_time;
    int average_speed;
    int current_speed;
    uint valid:1;
    undefined field_0x29;
    undefined field_0x2a;
    undefined field_0x2b;
    off_t size;
    off_t loaded;
    off_t last_loaded;
    off_t cur_loaded;
    off_t start;
    off_t pos;
    off_t seek;
    timer_id_T timer;
    void (* timer_func)(void *);
    void * timer_func_data;
    int data_in_secs[50];
};

typedef struct dom_renderer dom_renderer, *Pdom_renderer;

typedef struct conv_table conv_table, *Pconv_table;

typedef enum convert_string_mode {
    CSM_DEFAULT=0,
    CSM_FORM=2,
    CSM_NONE=3,
    CSM_QUERY=1
} convert_string_mode;

typedef union anon_union_for_u anon_union_for_u, *Panon_union_for_u;

union anon_union_for_u {
    uchar * str;
};

struct dom_renderer {
    enum sgml_document_type doctype;
    struct document * document;
    struct conv_table * convert_table;
    enum convert_string_mode convert_mode;
    struct uri * base_uri;
    uchar * source;
    uchar * end;
    uchar * position;
    int canvas_x;
    int canvas_y;
    struct screen_char styles[13];
    struct dom_node * channel;
    struct dom_node_list * items;
    struct dom_node * item;
    struct dom_node * node;
    struct dom_string text;
};

struct conv_table {
    int t;
    union anon_union_for_u u;
};

typedef struct table_cache_entry_key table_cache_entry_key, *Ptable_cache_entry_key;

struct table_cache_entry_key {
    uchar * start;
    uchar * end;
    int align;
    int margin;
    int width;
    int x;
    int link_num;
};

typedef struct renderer_context renderer_context, *Prenderer_context;

typedef struct tag tag, *Ptag;

typedef struct link_state_info link_state_info, *Plink_state_info;

struct link_state_info {
    uchar * link;
    uchar * target;
    uchar * image;
    struct form_control * form;
};

struct renderer_context {
    int last_link_to_move;
    struct tag * last_tag_to_move;
    struct tag * last_tag_for_newline;
    struct link_state_info link_state_info;
    struct conv_table * convert_table;
    struct cache_entry * cached;
    int g_ctrl_num;
    int subscript;
    int supscript;
    uint empty_format:1;
    uint nobreak:1;
    uint nosearchable:1;
    uint nowrap:1;
    undefined field_0x31;
    undefined field_0x32;
    undefined field_0x33;
};

struct tag {
    struct tag * next;
    struct tag * prev;
    int x;
    int y;
    uchar name[1];
    undefined field_0x11;
    undefined field_0x12;
    undefined field_0x13;
};

typedef struct plain_renderer plain_renderer, *Pplain_renderer;

struct plain_renderer {
    struct document * document;
    uchar * source;
    int length;
    struct conv_table * convert_table;
    struct screen_char template;
    int max_width;
    int lineno;
    uint compress:1;
    undefined field_0x21;
    undefined field_0x22;
    undefined field_0x23;
};

typedef enum link_state {
    LINK_STATE_NEW=1,
    LINK_STATE_NONE=0,
    LINK_STATE_SAME=2
} link_state;

typedef struct table_cache_entry table_cache_entry, *Ptable_cache_entry;

typedef struct part part, *Ppart;

struct part {
    struct document * document;
    uchar * spaces;
    int spaces_len;
    uchar * char_width;
    struct box box;
    int max_width;
    int xa;
    int cx;
    int cy;
    int link_num;
};

struct table_cache_entry {
    struct table_cache_entry * next;
    struct table_cache_entry * prev;
    struct table_cache_entry_key key;
    struct part part;
};

typedef struct fragment fragment, *Pfragment;

struct fragment {
    struct fragment * next;
    struct fragment * prev;
    off_t offset;
    off_t length;
    off_t real_length;
    uchar data[1];
    undefined field_0x21;
    undefined field_0x22;
    undefined field_0x23;
};

typedef struct formhist_data formhist_data, *Pformhist_data;

struct formhist_data {
    struct formhist_data * next;
    struct formhist_data * prev;
    struct object object;
    struct list_head_elinks * submit;
    struct listbox_item * box_item;
    uint dontsave:1;
    uchar url[1];
    undefined field_0x16;
    undefined field_0x17;
};

typedef enum mime_options {
    MIME_DEFAULT_TYPE=1,
    MIME_OPTIONS=2,
    MIME_TREE=0
} mime_options;

typedef struct frameset_param frameset_param, *Pframeset_param;

struct frameset_param {
    struct frameset_desc * parent;
    int x;
    int y;
    int * width;
    int * height;
};

typedef struct mime_handler mime_handler, *Pmime_handler;

struct mime_handler {
    uchar * description;
    uchar * backend_name;
    uint ask:1;
    uint block:1;
    uchar program[1];
    undefined field_0xa;
    undefined field_0xb;
};

typedef struct keymap keymap, *Pkeymap;

struct keymap {
    uchar * str;
    enum keymap_id keymap_id;
    uchar * desc;
};

typedef struct action action, *Paction;

struct action {
    uchar * str;
    action_id_T num;
    enum keymap_id keymap_id;
    uchar * desc;
    uint flags;
};

typedef enum menu_action_offset {
    ACT_MENU_OFFSET_CANCEL=2,
    ACT_MENU_OFFSET_DELETE=3,
    ACT_MENU_OFFSET_DOWN=4,
    ACT_MENU_OFFSET_END=5,
    ACT_MENU_OFFSET_ENTER=6,
    ACT_MENU_OFFSET_EXPAND=7,
    ACT_MENU_OFFSET_HOME=8,
    ACT_MENU_OFFSET_LEFT=9,
    ACT_MENU_OFFSET_MARK_ITEM=10,
    ACT_MENU_OFFSET_NEXT_ITEM=11,
    ACT_MENU_OFFSET_NONE=0,
    ACT_MENU_OFFSET_PAGE_DOWN=12,
    ACT_MENU_OFFSET_PAGE_UP=13,
    ACT_MENU_OFFSET_PREVIOUS_ITEM=14,
    ACT_MENU_OFFSET_REDRAW=15,
    ACT_MENU_OFFSET_RIGHT=16,
    ACT_MENU_OFFSET_SCRIPTING_FUNCTION=1,
    ACT_MENU_OFFSET_SEARCH=17,
    ACT_MENU_OFFSET_SELECT=18,
    ACT_MENU_OFFSET_UNEXPAND=19,
    ACT_MENU_OFFSET_UP=20,
    MENU_ACTIONS=21
} menu_action_offset;

typedef enum kbdbind_flags {
    KBDB_DEFAULT_BINDING=8,
    KBDB_DEFAULT_KEY=4,
    KBDB_TOUCHED=2,
    KBDB_WATERMARK=1
} kbdbind_flags;

typedef struct action_list action_list, *Paction_list;

struct action_list {
    struct action * actions;
    int num_actions;
};

typedef struct keybinding keybinding, *Pkeybinding;

struct keybinding {
    struct keybinding * next;
    struct keybinding * prev;
    struct object object;
    enum keymap_id keymap_id;
    action_id_T action_id;
    struct term_event_keyboard kbd;
    int event;
    enum kbdbind_flags flags;
    struct listbox_item * box_item;
};

typedef enum menu_action {
    ACT_MENU_CANCEL=2,
    ACT_MENU_DELETE=3,
    ACT_MENU_DOWN=4,
    ACT_MENU_END=5,
    ACT_MENU_ENTER=6,
    ACT_MENU_EXPAND=7,
    ACT_MENU_HOME=8,
    ACT_MENU_LEFT=9,
    ACT_MENU_MARK_ITEM=10,
    ACT_MENU_NEXT_ITEM=11,
    ACT_MENU_NONE=0,
    ACT_MENU_PAGE_DOWN=12,
    ACT_MENU_PAGE_UP=13,
    ACT_MENU_PREVIOUS_ITEM=14,
    ACT_MENU_REDRAW=15,
    ACT_MENU_RIGHT=16,
    ACT_MENU_SCRIPTING_FUNCTION=1,
    ACT_MENU_SEARCH=17,
    ACT_MENU_SELECT=18,
    ACT_MENU_UNEXPAND=19,
    ACT_MENU_UP=20
} menu_action;

typedef enum edit_action_offset {
    ACT_EDIT_OFFSET_AUTO_COMPLETE=2,
    ACT_EDIT_OFFSET_AUTO_COMPLETE_FILE=3,
    ACT_EDIT_OFFSET_AUTO_COMPLETE_UNAMBIGUOUS=4,
    ACT_EDIT_OFFSET_BACKSPACE=5,
    ACT_EDIT_OFFSET_BEGINNING_OF_BUFFER=6,
    ACT_EDIT_OFFSET_CANCEL=7,
    ACT_EDIT_OFFSET_COPY_CLIPBOARD=8,
    ACT_EDIT_OFFSET_CUT_CLIPBOARD=9,
    ACT_EDIT_OFFSET_DELETE=10,
    ACT_EDIT_OFFSET_DOWN=11,
    ACT_EDIT_OFFSET_END=12,
    ACT_EDIT_OFFSET_END_OF_BUFFER=13,
    ACT_EDIT_OFFSET_ENTER=14,
    ACT_EDIT_OFFSET_HOME=15,
    ACT_EDIT_OFFSET_KILL_TO_BOL=16,
    ACT_EDIT_OFFSET_KILL_TO_EOL=17,
    ACT_EDIT_OFFSET_KILL_WORD_BACK=18,
    ACT_EDIT_OFFSET_LEFT=19,
    ACT_EDIT_OFFSET_MOVE_BACKWARD_WORD=20,
    ACT_EDIT_OFFSET_MOVE_FORWARD_WORD=21,
    ACT_EDIT_OFFSET_NEXT_ITEM=22,
    ACT_EDIT_OFFSET_NONE=0,
    ACT_EDIT_OFFSET_OPEN_EXTERNAL=23,
    ACT_EDIT_OFFSET_PASTE_CLIPBOARD=24,
    ACT_EDIT_OFFSET_PREVIOUS_ITEM=25,
    ACT_EDIT_OFFSET_REDRAW=26,
    ACT_EDIT_OFFSET_RIGHT=27,
    ACT_EDIT_OFFSET_SCRIPTING_FUNCTION=1,
    ACT_EDIT_OFFSET_SEARCH_TOGGLE_REGEX=28,
    ACT_EDIT_OFFSET_UP=29,
    EDIT_ACTIONS=30
} edit_action_offset;

typedef enum main_action_offset {
    ACT_MAIN_OFFSET_ABORT_CONNECTION=2,
    ACT_MAIN_OFFSET_ADD_BOOKMARK=3,
    ACT_MAIN_OFFSET_ADD_BOOKMARK_LINK=4,
    ACT_MAIN_OFFSET_ADD_BOOKMARK_TABS=5,
    ACT_MAIN_OFFSET_AUTH_MANAGER=6,
    ACT_MAIN_OFFSET_BACKSPACE_PREFIX=7,
    ACT_MAIN_OFFSET_BOOKMARK_MANAGER=8,
    ACT_MAIN_OFFSET_CACHE_MANAGER=9,
    ACT_MAIN_OFFSET_CACHE_MINIMIZE=10,
    ACT_MAIN_OFFSET_COOKIES_LOAD=12,
    ACT_MAIN_OFFSET_COOKIE_MANAGER=11,
    ACT_MAIN_OFFSET_COPY_CLIPBOARD=13,
    ACT_MAIN_OFFSET_DOCUMENT_INFO=14,
    ACT_MAIN_OFFSET_DOWNLOAD_MANAGER=15,
    ACT_MAIN_OFFSET_EXMODE=16,
    ACT_MAIN_OFFSET_FILE_MENU=17,
    ACT_MAIN_OFFSET_FIND_NEXT=18,
    ACT_MAIN_OFFSET_FIND_NEXT_BACK=19,
    ACT_MAIN_OFFSET_FORGET_CREDENTIALS=20,
    ACT_MAIN_OFFSET_FORMHIST_MANAGER=21,
    ACT_MAIN_OFFSET_FRAME_EXTERNAL_COMMAND=22,
    ACT_MAIN_OFFSET_FRAME_MAXIMIZE=23,
    ACT_MAIN_OFFSET_FRAME_NEXT=24,
    ACT_MAIN_OFFSET_FRAME_PREV=25,
    ACT_MAIN_OFFSET_GOTO_URL=26,
    ACT_MAIN_OFFSET_GOTO_URL_CURRENT=27,
    ACT_MAIN_OFFSET_GOTO_URL_CURRENT_LINK=28,
    ACT_MAIN_OFFSET_GOTO_URL_HOME=29,
    ACT_MAIN_OFFSET_HEADER_INFO=30,
    ACT_MAIN_OFFSET_HISTORY_MANAGER=31,
    ACT_MAIN_OFFSET_HISTORY_MOVE_BACK=32,
    ACT_MAIN_OFFSET_HISTORY_MOVE_FORWARD=33,
    ACT_MAIN_OFFSET_JUMP_TO_LINK=34,
    ACT_MAIN_OFFSET_KEYBINDING_MANAGER=35,
    ACT_MAIN_OFFSET_KILL_BACKGROUNDED_CONNECTIONS=36,
    ACT_MAIN_OFFSET_LINK_DOWNLOAD=37,
    ACT_MAIN_OFFSET_LINK_DOWNLOAD_IMAGE=38,
    ACT_MAIN_OFFSET_LINK_DOWNLOAD_RESUME=39,
    ACT_MAIN_OFFSET_LINK_EXTERNAL_COMMAND=40,
    ACT_MAIN_OFFSET_LINK_FOLLOW=41,
    ACT_MAIN_OFFSET_LINK_FOLLOW_RELOAD=42,
    ACT_MAIN_OFFSET_LINK_FORM_MENU=44,
    ACT_MAIN_OFFSET_LINK_MENU=43,
    ACT_MAIN_OFFSET_LUA_CONSOLE=45,
    ACT_MAIN_OFFSET_MARK_GOTO=46,
    ACT_MAIN_OFFSET_MARK_SET=47,
    ACT_MAIN_OFFSET_MENU=48,
    ACT_MAIN_OFFSET_MOVE_CURSOR_DOWN=49,
    ACT_MAIN_OFFSET_MOVE_CURSOR_LEFT=50,
    ACT_MAIN_OFFSET_MOVE_CURSOR_LINE_START=51,
    ACT_MAIN_OFFSET_MOVE_CURSOR_RIGHT=52,
    ACT_MAIN_OFFSET_MOVE_CURSOR_UP=53,
    ACT_MAIN_OFFSET_MOVE_DOCUMENT_END=54,
    ACT_MAIN_OFFSET_MOVE_DOCUMENT_START=55,
    ACT_MAIN_OFFSET_MOVE_LINK_DOWN=56,
    ACT_MAIN_OFFSET_MOVE_LINK_DOWN_LINE=57,
    ACT_MAIN_OFFSET_MOVE_LINK_LEFT=58,
    ACT_MAIN_OFFSET_MOVE_LINK_LEFT_LINE=59,
    ACT_MAIN_OFFSET_MOVE_LINK_NEXT=60,
    ACT_MAIN_OFFSET_MOVE_LINK_PREV=61,
    ACT_MAIN_OFFSET_MOVE_LINK_RIGHT=62,
    ACT_MAIN_OFFSET_MOVE_LINK_RIGHT_LINE=63,
    ACT_MAIN_OFFSET_MOVE_LINK_UP=64,
    ACT_MAIN_OFFSET_MOVE_LINK_UP_LINE=65,
    ACT_MAIN_OFFSET_MOVE_PAGE_DOWN=66,
    ACT_MAIN_OFFSET_MOVE_PAGE_UP=67,
    ACT_MAIN_OFFSET_NONE=0,
    ACT_MAIN_OFFSET_OPEN_LINK_IN_NEW_TAB=68,
    ACT_MAIN_OFFSET_OPEN_LINK_IN_NEW_TAB_IN_BACKGROUND=69,
    ACT_MAIN_OFFSET_OPEN_LINK_IN_NEW_WINDOW=70,
    ACT_MAIN_OFFSET_OPEN_NEW_TAB=71,
    ACT_MAIN_OFFSET_OPEN_NEW_TAB_IN_BACKGROUND=72,
    ACT_MAIN_OFFSET_OPEN_NEW_WINDOW=73,
    ACT_MAIN_OFFSET_OPEN_OS_SHELL=74,
    ACT_MAIN_OFFSET_OPTIONS_MANAGER=75,
    ACT_MAIN_OFFSET_QUIT=76,
    ACT_MAIN_OFFSET_REALLY_QUIT=77,
    ACT_MAIN_OFFSET_REDRAW=78,
    ACT_MAIN_OFFSET_RELOAD=79,
    ACT_MAIN_OFFSET_RERENDER=80,
    ACT_MAIN_OFFSET_RESET_FORM=81,
    ACT_MAIN_OFFSET_RESOURCE_INFO=82,
    ACT_MAIN_OFFSET_SAVE_AS=83,
    ACT_MAIN_OFFSET_SAVE_FORMATTED=84,
    ACT_MAIN_OFFSET_SAVE_OPTIONS=85,
    ACT_MAIN_OFFSET_SAVE_URL_AS=86,
    ACT_MAIN_OFFSET_SCRIPTING_FUNCTION=1,
    ACT_MAIN_OFFSET_SCROLL_DOWN=87,
    ACT_MAIN_OFFSET_SCROLL_LEFT=88,
    ACT_MAIN_OFFSET_SCROLL_RIGHT=89,
    ACT_MAIN_OFFSET_SCROLL_UP=90,
    ACT_MAIN_OFFSET_SEARCH=91,
    ACT_MAIN_OFFSET_SEARCH_BACK=92,
    ACT_MAIN_OFFSET_SEARCH_TYPEAHEAD=93,
    ACT_MAIN_OFFSET_SEARCH_TYPEAHEAD_LINK=94,
    ACT_MAIN_OFFSET_SEARCH_TYPEAHEAD_TEXT=95,
    ACT_MAIN_OFFSET_SEARCH_TYPEAHEAD_TEXT_BACK=96,
    ACT_MAIN_OFFSET_SHOW_TERM_OPTIONS=97,
    ACT_MAIN_OFFSET_SUBMIT_FORM=98,
    ACT_MAIN_OFFSET_SUBMIT_FORM_RELOAD=99,
    ACT_MAIN_OFFSET_TAB_CLOSE=100,
    ACT_MAIN_OFFSET_TAB_CLOSE_ALL_BUT_CURRENT=101,
    ACT_MAIN_OFFSET_TAB_EXTERNAL_COMMAND=102,
    ACT_MAIN_OFFSET_TAB_MENU=103,
    ACT_MAIN_OFFSET_TAB_MOVE_LEFT=104,
    ACT_MAIN_OFFSET_TAB_MOVE_RIGHT=105,
    ACT_MAIN_OFFSET_TAB_NEXT=106,
    ACT_MAIN_OFFSET_TAB_PREV=107,
    ACT_MAIN_OFFSET_TERMINAL_RESIZE=108,
    ACT_MAIN_OFFSET_TOGGLE_CSS=109,
    ACT_MAIN_OFFSET_TOGGLE_DISPLAY_IMAGES=110,
    ACT_MAIN_OFFSET_TOGGLE_DISPLAY_TABLES=111,
    ACT_MAIN_OFFSET_TOGGLE_DOCUMENT_COLORS=112,
    ACT_MAIN_OFFSET_TOGGLE_HTML_PLAIN=113,
    ACT_MAIN_OFFSET_TOGGLE_MOUSE=114,
    ACT_MAIN_OFFSET_TOGGLE_NUMBERED_LINKS=115,
    ACT_MAIN_OFFSET_TOGGLE_PLAIN_COMPRESS_EMPTY_LINES=116,
    ACT_MAIN_OFFSET_TOGGLE_WRAP_TEXT=117,
    ACT_MAIN_OFFSET_VIEW_IMAGE=118,
    MAIN_ACTIONS=119
} main_action_offset;

typedef enum action_flags {
    ACTION_FLAGS_MASK=16711680,
    ACTION_JUMP_TO_LINK=524288,
    ACTION_REQUIRE_FORM=2097152,
    ACTION_REQUIRE_LINK=1048576,
    ACTION_REQUIRE_LOCATION=262144,
    ACTION_REQUIRE_VIEW_STATE=131072,
    ACTION_RESTRICT_ANONYMOUS=65536
} action_flags;

typedef enum edit_action {
    ACT_EDIT_AUTO_COMPLETE=2,
    ACT_EDIT_AUTO_COMPLETE_FILE=3,
    ACT_EDIT_AUTO_COMPLETE_UNAMBIGUOUS=4,
    ACT_EDIT_BACKSPACE=5,
    ACT_EDIT_BEGINNING_OF_BUFFER=6,
    ACT_EDIT_CANCEL=7,
    ACT_EDIT_COPY_CLIPBOARD=8,
    ACT_EDIT_CUT_CLIPBOARD=9,
    ACT_EDIT_DELETE=10,
    ACT_EDIT_DOWN=11,
    ACT_EDIT_END=12,
    ACT_EDIT_END_OF_BUFFER=13,
    ACT_EDIT_ENTER=14,
    ACT_EDIT_HOME=15,
    ACT_EDIT_KILL_TO_BOL=16,
    ACT_EDIT_KILL_TO_EOL=17,
    ACT_EDIT_KILL_WORD_BACK=18,
    ACT_EDIT_LEFT=19,
    ACT_EDIT_MOVE_BACKWARD_WORD=20,
    ACT_EDIT_MOVE_FORWARD_WORD=21,
    ACT_EDIT_NEXT_ITEM=22,
    ACT_EDIT_NONE=0,
    ACT_EDIT_OPEN_EXTERNAL=23,
    ACT_EDIT_PASTE_CLIPBOARD=24,
    ACT_EDIT_PREVIOUS_ITEM=25,
    ACT_EDIT_REDRAW=26,
    ACT_EDIT_RIGHT=27,
    ACT_EDIT_SCRIPTING_FUNCTION=1,
    ACT_EDIT_SEARCH_TOGGLE_REGEX=28,
    ACT_EDIT_UP=29
} edit_action;

typedef struct option_type_info option_type_info, *Poption_type_info;

struct option_type_info {
    uchar * name;
    uchar * (* cmdline)(struct option_elinks *, uchar * * *, int *);
    uchar * (* read)(struct option_elinks *, uchar * *, int *);
    void (* write)(struct option_elinks *, struct string *);
    void (* dup)(struct option_elinks *, struct option_elinks *);
    int (* set)(struct option_elinks *, uchar *);
    int (* equals)(struct option_elinks *, uchar *);
    uchar * help_str;
};

typedef struct mimetypes_entry mimetypes_entry, *Pmimetypes_entry;

struct mimetypes_entry {
    uchar * content_type;
    uchar extension[1];
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
};

typedef enum mimetypes_option {
    MIMETYPES_ENABLE=1,
    MIMETYPES_OPTIONS=3,
    MIMETYPES_PATH=2,
    MIMETYPES_TREE=0
} mimetypes_option;

typedef struct entity entity, *Pentity;

struct entity {
    char * s;
    unicode_val_T c;
};

typedef struct blacklist_entry blacklist_entry, *Pblacklist_entry;

struct blacklist_entry {
    struct blacklist_entry * next;
    struct blacklist_entry * prev;
    enum blacklist_flags flags;
    uchar host[1];
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
};

typedef struct erb_protect_info erb_protect_info, *Perb_protect_info;

struct erb_protect_info {
    uchar * name;
    int argc;
    VALUE * args;
};

typedef enum referer {
    REFERER_FAKE=2,
    REFERER_NONE=0,
    REFERER_SAME_URL=1,
    REFERER_TRUE=3
} referer;

typedef struct session.conflict2 session.conflict2, *Psession.conflict2;

typedef struct kbdprefix.conflict2 kbdprefix.conflict2, *Pkbdprefix.conflict2;

typedef enum anon_enum_32_for_mark.conflict2 {
    KP_MARK_GOTO=2,
    KP_MARK_NOTHING=0,
    KP_MARK_SET=1,
    SCAN_END=2,
    SCAN_RANGE=0,
    SCAN_STRING=1,
    TERM_FN_RESIZE=2,
    TERM_FN_TITLE=1,
    TERM_FN_TITLE_CODEPAGE=3,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096
} anon_enum_32_for_mark.conflict2;

struct kbdprefix.conflict2 {
    int repeat_count;
    enum anon_enum_32_for_mark.conflict2 mark;
};

struct session.conflict2 {
    struct session * next;
    struct session * prev;
    struct window * tab;
    struct ses_history history;
    struct list_head_elinks more_files;
    struct download loading;
    struct uri * loading_uri;
    enum cache_mode reloadlevel;
    int redirect_cnt;
    struct document_view * doc_view;
    struct list_head_elinks scrn_frames;
    struct uri * download_uri;
    struct uri * referrer;
    struct session_task task;
    int search_direction;
    struct kbdprefix.conflict2 kbdprefix;
    int exit_query;
    timer_id_T display_timer;
    enum insert_mode insert_mode;
    enum navigate_mode navigate_mode;
    uchar * search_word;
    uchar * last_search_word;
    struct list_head_elinks type_queries;
    struct session_status status;
};

typedef struct session.conflict7 session.conflict7, *Psession.conflict7;

typedef struct kbdprefix.conflict7 kbdprefix.conflict7, *Pkbdprefix.conflict7;

typedef enum anon_enum_32_for_mark.conflict7 {
    ABDAY_1=131072,
    ABDAY_2=131073,
    ABDAY_3=131074,
    ABDAY_4=131075,
    ABDAY_5=131076,
    ABDAY_6=131077,
    ABDAY_7=131078,
    ABMON_1=131086,
    ABMON_10=131095,
    ABMON_11=131096,
    ABMON_12=131097,
    ABMON_2=131087,
    ABMON_3=131088,
    ABMON_4=131089,
    ABMON_5=131090,
    ABMON_6=131091,
    ABMON_7=131092,
    ABMON_8=131093,
    ABMON_9=131094,
    ALT_DIGITS=131119,
    AM_STR=131110,
    CODESET=14,
    COMMON_DOWNLOAD_DO=0,
    CONTINUE_DOWNLOAD_DO=1,
    DAY_1=131079,
    DAY_2=131080,
    DAY_3=131081,
    DAY_4=131082,
    DAY_5=131083,
    DAY_6=131084,
    DAY_7=131085,
    DOM_SCAN_END=2,
    DOM_SCAN_RANGE=0,
    DOM_SCAN_STRING=1,
    D_FMT=131113,
    D_T_FMT=131112,
    ERA=131116,
    ERA_D_FMT=131118,
    ERA_D_T_FMT=131120,
    ERA_T_FMT=131121,
    GNUTLS_CLIENT=2,
    GNUTLS_CRD_ANON=2,
    GNUTLS_CRD_CERTIFICATE=1,
    GNUTLS_CRD_IA=5,
    GNUTLS_CRD_PSK=4,
    GNUTLS_CRD_SRP=3,
    GNUTLS_KX_ANON_DH=4,
    GNUTLS_KX_DHE_DSS=2,
    GNUTLS_KX_DHE_PSK=10,
    GNUTLS_KX_DHE_RSA=3,
    GNUTLS_KX_PSK=9,
    GNUTLS_KX_RSA=1,
    GNUTLS_KX_RSA_EXPORT=6,
    GNUTLS_KX_SRP=5,
    GNUTLS_KX_SRP_DSS=8,
    GNUTLS_KX_SRP_RSA=7,
    GNUTLS_KX_UNKNOWN=0,
    GNUTLS_MAC_MD2=5,
    GNUTLS_MAC_MD5=2,
    GNUTLS_MAC_NULL=1,
    GNUTLS_MAC_RMD160=4,
    GNUTLS_MAC_SHA1=3,
    GNUTLS_MAC_SHA256=6,
    GNUTLS_MAC_SHA384=7,
    GNUTLS_MAC_SHA512=8,
    GNUTLS_MAC_UNKNOWN=0,
    GNUTLS_SERVER=1,
    GNUTLS_SHUT_RDWR=0,
    GNUTLS_SHUT_WR=1,
    GNUTLS_SSL3=1,
    GNUTLS_TLS1_0=2,
    GNUTLS_TLS1_1=3,
    GNUTLS_TLS1_2=4,
    GNUTLS_VERSION_UNKNOWN=255,
    GNUTLS_X509_FMT_DER=0,
    GNUTLS_X509_FMT_PEM=1,
    IDNA_CONTAINS_ACE_PREFIX=8,
    IDNA_CONTAINS_LDH=3,
    IDNA_CONTAINS_MINUS=4,
    IDNA_CONTAINS_NON_LDH=3,
    IDNA_DLOPEN_ERROR=202,
    IDNA_ICONV_ERROR=9,
    IDNA_INVALID_LENGTH=5,
    IDNA_MALLOC_ERROR=201,
    IDNA_NO_ACE_PREFIX=6,
    IDNA_PUNYCODE_ERROR=2,
    IDNA_ROUNDTRIP_VERIFY_ERROR=7,
    IDNA_STRINGPREP_ERROR=1,
    IDNA_SUCCESS=0,
    IPPROTO_AH=51,
    IPPROTO_COMP=108,
    IPPROTO_DCCP=33,
    IPPROTO_DSTOPTS=60,
    IPPROTO_EGP=8,
    IPPROTO_ENCAP=98,
    IPPROTO_ESP=50,
    IPPROTO_FRAGMENT=44,
    IPPROTO_GRE=47,
    IPPROTO_HOPOPTS=0,
    IPPROTO_ICMP=1,
    IPPROTO_ICMPV6=58,
    IPPROTO_IDP=22,
    IPPROTO_IGMP=2,
    IPPROTO_IP=0,
    IPPROTO_IPIP=4,
    IPPROTO_IPV6=41,
    IPPROTO_MAX=256,
    IPPROTO_MTP=92,
    IPPROTO_NONE=59,
    IPPROTO_PIM=103,
    IPPROTO_PUP=12,
    IPPROTO_RAW=255,
    IPPROTO_ROUTING=43,
    IPPROTO_RSVP=46,
    IPPROTO_SCTP=132,
    IPPROTO_TCP=6,
    IPPROTO_TP=29,
    IPPROTO_UDP=17,
    IPPROTO_UDPLITE=136,
    KP_MARK_GOTO=2,
    KP_MARK_NOTHING=0,
    KP_MARK_SET=1,
    MON_1=131098,
    MON_10=131107,
    MON_11=131108,
    MON_12=131109,
    MON_2=131099,
    MON_3=131100,
    MON_4=131101,
    MON_5=131102,
    MON_6=131103,
    MON_7=131104,
    MON_8=131105,
    MON_9=131106,
    PM_STR=131111,
    RADIXCHAR=65536,
    SCAN_END=2,
    SCAN_RANGE=0,
    SCAN_STRING=1,
    TERM_FN_RESIZE=2,
    TERM_FN_TITLE=1,
    TERM_FN_TITLE_CODEPAGE=3,
    THOUSEP=65537,
    T_FMT=131114,
    T_FMT_AMPM=131115,
    _DATE_FMT=131180,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096,
    _NL_ADDRESS_CODESET=589836,
    _NL_ADDRESS_COUNTRY_AB2=589827,
    _NL_ADDRESS_COUNTRY_AB3=589828,
    _NL_ADDRESS_COUNTRY_CAR=589829,
    _NL_ADDRESS_COUNTRY_ISBN=589831,
    _NL_ADDRESS_COUNTRY_NAME=589825,
    _NL_ADDRESS_COUNTRY_NUM=589830,
    _NL_ADDRESS_COUNTRY_POST=589826,
    _NL_ADDRESS_LANG_AB=589833,
    _NL_ADDRESS_LANG_LIB=589835,
    _NL_ADDRESS_LANG_NAME=589832,
    _NL_ADDRESS_LANG_TERM=589834,
    _NL_ADDRESS_POSTAL_FMT=589824,
    _NL_COLLATE_CODESET=196626,
    _NL_COLLATE_COLLSEQMB=196624,
    _NL_COLLATE_COLLSEQWC=196625,
    _NL_COLLATE_EXTRAMB=196612,
    _NL_COLLATE_EXTRAWC=196619,
    _NL_COLLATE_GAP1=196614,
    _NL_COLLATE_GAP2=196615,
    _NL_COLLATE_GAP3=196616,
    _NL_COLLATE_INDIRECTMB=196613,
    _NL_COLLATE_INDIRECTWC=196620,
    _NL_COLLATE_NRULES=196608,
    _NL_COLLATE_RULESETS=196609,
    _NL_COLLATE_SYMB_EXTRAMB=196623,
    _NL_COLLATE_SYMB_HASH_SIZEMB=196621,
    _NL_COLLATE_SYMB_TABLEMB=196622,
    _NL_COLLATE_TABLEMB=196610,
    _NL_COLLATE_TABLEWC=196617,
    _NL_COLLATE_WEIGHTMB=196611,
    _NL_COLLATE_WEIGHTWC=196618,
    _NL_CTYPE_CLASS=0,
    _NL_CTYPE_CLASS32=5,
    _NL_CTYPE_CLASS_NAMES=10,
    _NL_CTYPE_CLASS_OFFSET=17,
    _NL_CTYPE_CODESET_NAME=14,
    _NL_CTYPE_EXTRA_MAP_1=72,
    _NL_CTYPE_EXTRA_MAP_10=81,
    _NL_CTYPE_EXTRA_MAP_11=82,
    _NL_CTYPE_EXTRA_MAP_12=83,
    _NL_CTYPE_EXTRA_MAP_13=84,
    _NL_CTYPE_EXTRA_MAP_14=85,
    _NL_CTYPE_EXTRA_MAP_2=73,
    _NL_CTYPE_EXTRA_MAP_3=74,
    _NL_CTYPE_EXTRA_MAP_4=75,
    _NL_CTYPE_EXTRA_MAP_5=76,
    _NL_CTYPE_EXTRA_MAP_6=77,
    _NL_CTYPE_EXTRA_MAP_7=78,
    _NL_CTYPE_EXTRA_MAP_8=79,
    _NL_CTYPE_EXTRA_MAP_9=80,
    _NL_CTYPE_GAP1=2,
    _NL_CTYPE_GAP2=4,
    _NL_CTYPE_GAP3=6,
    _NL_CTYPE_GAP4=7,
    _NL_CTYPE_GAP5=8,
    _NL_CTYPE_GAP6=9,
    _NL_CTYPE_INDIGITS0_MB=20,
    _NL_CTYPE_INDIGITS0_WC=31,
    _NL_CTYPE_INDIGITS1_MB=21,
    _NL_CTYPE_INDIGITS1_WC=32,
    _NL_CTYPE_INDIGITS2_MB=22,
    _NL_CTYPE_INDIGITS2_WC=33,
    _NL_CTYPE_INDIGITS3_MB=23,
    _NL_CTYPE_INDIGITS3_WC=34,
    _NL_CTYPE_INDIGITS4_MB=24,
    _NL_CTYPE_INDIGITS4_WC=35,
    _NL_CTYPE_INDIGITS5_MB=25,
    _NL_CTYPE_INDIGITS5_WC=36,
    _NL_CTYPE_INDIGITS6_MB=26,
    _NL_CTYPE_INDIGITS6_WC=37,
    _NL_CTYPE_INDIGITS7_MB=27,
    _NL_CTYPE_INDIGITS7_WC=38,
    _NL_CTYPE_INDIGITS8_MB=28,
    _NL_CTYPE_INDIGITS8_WC=39,
    _NL_CTYPE_INDIGITS9_MB=29,
    _NL_CTYPE_INDIGITS9_WC=40,
    _NL_CTYPE_INDIGITS_MB_LEN=19,
    _NL_CTYPE_INDIGITS_WC_LEN=30,
    _NL_CTYPE_MAP_NAMES=11,
    _NL_CTYPE_MAP_OFFSET=18,
    _NL_CTYPE_MAP_TO_NONASCII=70,
    _NL_CTYPE_MB_CUR_MAX=13,
    _NL_CTYPE_NONASCII_CASE=71,
    _NL_CTYPE_OUTDIGIT0_MB=41,
    _NL_CTYPE_OUTDIGIT0_WC=51,
    _NL_CTYPE_OUTDIGIT1_MB=42,
    _NL_CTYPE_OUTDIGIT1_WC=52,
    _NL_CTYPE_OUTDIGIT2_MB=43,
    _NL_CTYPE_OUTDIGIT2_WC=53,
    _NL_CTYPE_OUTDIGIT3_MB=44,
    _NL_CTYPE_OUTDIGIT3_WC=54,
    _NL_CTYPE_OUTDIGIT4_MB=45,
    _NL_CTYPE_OUTDIGIT4_WC=55,
    _NL_CTYPE_OUTDIGIT5_MB=46,
    _NL_CTYPE_OUTDIGIT5_WC=56,
    _NL_CTYPE_OUTDIGIT6_MB=47,
    _NL_CTYPE_OUTDIGIT6_WC=57,
    _NL_CTYPE_OUTDIGIT7_MB=48,
    _NL_CTYPE_OUTDIGIT7_WC=58,
    _NL_CTYPE_OUTDIGIT8_MB=49,
    _NL_CTYPE_OUTDIGIT8_WC=59,
    _NL_CTYPE_OUTDIGIT9_MB=50,
    _NL_CTYPE_OUTDIGIT9_WC=60,
    _NL_CTYPE_TOLOWER=3,
    _NL_CTYPE_TOLOWER32=16,
    _NL_CTYPE_TOUPPER=1,
    _NL_CTYPE_TOUPPER32=15,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING=67,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN=66,
    _NL_CTYPE_TRANSLIT_FROM_IDX=62,
    _NL_CTYPE_TRANSLIT_FROM_TBL=63,
    _NL_CTYPE_TRANSLIT_IGNORE=69,
    _NL_CTYPE_TRANSLIT_IGNORE_LEN=68,
    _NL_CTYPE_TRANSLIT_TAB_SIZE=61,
    _NL_CTYPE_TRANSLIT_TO_IDX=64,
    _NL_CTYPE_TRANSLIT_TO_TBL=65,
    _NL_CTYPE_WIDTH=12,
    _NL_IDENTIFICATION_ABBREVIATION=786443,
    _NL_IDENTIFICATION_ADDRESS=786434,
    _NL_IDENTIFICATION_APPLICATION=786442,
    _NL_IDENTIFICATION_AUDIENCE=786441,
    _NL_IDENTIFICATION_CATEGORY=786446,
    _NL_IDENTIFICATION_CODESET=786447,
    _NL_IDENTIFICATION_CONTACT=786435,
    _NL_IDENTIFICATION_DATE=786445,
    _NL_IDENTIFICATION_EMAIL=786436,
    _NL_IDENTIFICATION_FAX=786438,
    _NL_IDENTIFICATION_LANGUAGE=786439,
    _NL_IDENTIFICATION_REVISION=786444,
    _NL_IDENTIFICATION_SOURCE=786433,
    _NL_IDENTIFICATION_TEL=786437,
    _NL_IDENTIFICATION_TERRITORY=786440,
    _NL_IDENTIFICATION_TITLE=786432,
    _NL_MEASUREMENT_CODESET=720897,
    _NL_MEASUREMENT_MEASUREMENT=720896,
    _NL_MESSAGES_CODESET=327684,
    _NL_MONETARY_CODESET=262189,
    _NL_MONETARY_CONVERSION_RATE=262186,
    _NL_MONETARY_CRNCYSTR=262159,
    _NL_MONETARY_DECIMAL_POINT_WC=262187,
    _NL_MONETARY_DUO_CURRENCY_SYMBOL=262167,
    _NL_MONETARY_DUO_FRAC_DIGITS=262169,
    _NL_MONETARY_DUO_INT_CURR_SYMBOL=262166,
    _NL_MONETARY_DUO_INT_FRAC_DIGITS=262168,
    _NL_MONETARY_DUO_INT_N_CS_PRECEDES=262176,
    _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE=262177,
    _NL_MONETARY_DUO_INT_N_SIGN_POSN=262181,
    _NL_MONETARY_DUO_INT_P_CS_PRECEDES=262174,
    _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE=262175,
    _NL_MONETARY_DUO_INT_P_SIGN_POSN=262180,
    _NL_MONETARY_DUO_N_CS_PRECEDES=262172,
    _NL_MONETARY_DUO_N_SEP_BY_SPACE=262173,
    _NL_MONETARY_DUO_N_SIGN_POSN=262179,
    _NL_MONETARY_DUO_P_CS_PRECEDES=262170,
    _NL_MONETARY_DUO_P_SEP_BY_SPACE=262171,
    _NL_MONETARY_DUO_P_SIGN_POSN=262178,
    _NL_MONETARY_DUO_VALID_FROM=262184,
    _NL_MONETARY_DUO_VALID_TO=262185,
    _NL_MONETARY_THOUSANDS_SEP_WC=262188,
    _NL_MONETARY_UNO_VALID_FROM=262182,
    _NL_MONETARY_UNO_VALID_TO=262183,
    _NL_NAME_CODESET=524294,
    _NL_NAME_NAME_FMT=524288,
    _NL_NAME_NAME_GEN=524289,
    _NL_NAME_NAME_MISS=524292,
    _NL_NAME_NAME_MR=524290,
    _NL_NAME_NAME_MRS=524291,
    _NL_NAME_NAME_MS=524293,
    _NL_NUM=786449,
    _NL_NUMERIC_CODESET=65541,
    _NL_NUMERIC_DECIMAL_POINT_WC=65539,
    _NL_NUMERIC_THOUSANDS_SEP_WC=65540,
    _NL_NUM_LC_ADDRESS=589837,
    _NL_NUM_LC_COLLATE=196627,
    _NL_NUM_LC_CTYPE=86,
    _NL_NUM_LC_IDENTIFICATION=786448,
    _NL_NUM_LC_MEASUREMENT=720898,
    _NL_NUM_LC_MESSAGES=327685,
    _NL_NUM_LC_MONETARY=262190,
    _NL_NUM_LC_NAME=524295,
    _NL_NUM_LC_NUMERIC=65542,
    _NL_NUM_LC_PAPER=458755,
    _NL_NUM_LC_TELEPHONE=655365,
    _NL_NUM_LC_TIME=131183,
    _NL_PAPER_CODESET=458754,
    _NL_PAPER_HEIGHT=458752,
    _NL_PAPER_WIDTH=458753,
    _NL_TELEPHONE_CODESET=655364,
    _NL_TELEPHONE_INT_PREFIX=655363,
    _NL_TELEPHONE_INT_SELECT=655362,
    _NL_TELEPHONE_TEL_DOM_FMT=655361,
    _NL_TELEPHONE_TEL_INT_FMT=655360,
    _NL_TIME_CAL_DIRECTION=131178,
    _NL_TIME_CODESET=131182,
    _NL_TIME_ERA_ENTRIES=131123,
    _NL_TIME_ERA_NUM_ENTRIES=131122,
    _NL_TIME_FIRST_WEEKDAY=131176,
    _NL_TIME_FIRST_WORKDAY=131177,
    _NL_TIME_TIMEZONE=131179,
    _NL_TIME_WEEK_1STDAY=131174,
    _NL_TIME_WEEK_1STWEEK=131175,
    _NL_TIME_WEEK_NDAYS=131173,
    _NL_WABDAY_1=131124,
    _NL_WABDAY_2=131125,
    _NL_WABDAY_3=131126,
    _NL_WABDAY_4=131127,
    _NL_WABDAY_5=131128,
    _NL_WABDAY_6=131129,
    _NL_WABDAY_7=131130,
    _NL_WABMON_1=131138,
    _NL_WABMON_10=131147,
    _NL_WABMON_11=131148,
    _NL_WABMON_12=131149,
    _NL_WABMON_2=131139,
    _NL_WABMON_3=131140,
    _NL_WABMON_4=131141,
    _NL_WABMON_5=131142,
    _NL_WABMON_6=131143,
    _NL_WABMON_7=131144,
    _NL_WABMON_8=131145,
    _NL_WABMON_9=131146,
    _NL_WALT_DIGITS=131170,
    _NL_WAM_STR=131162,
    _NL_WDAY_1=131131,
    _NL_WDAY_2=131132,
    _NL_WDAY_3=131133,
    _NL_WDAY_4=131134,
    _NL_WDAY_5=131135,
    _NL_WDAY_6=131136,
    _NL_WDAY_7=131137,
    _NL_WD_FMT=131165,
    _NL_WD_T_FMT=131164,
    _NL_WERA_D_FMT=131169,
    _NL_WERA_D_T_FMT=131171,
    _NL_WERA_T_FMT=131172,
    _NL_WERA_YEAR=131168,
    _NL_WMON_1=131150,
    _NL_WMON_10=131159,
    _NL_WMON_11=131160,
    _NL_WMON_12=131161,
    _NL_WMON_2=131151,
    _NL_WMON_3=131152,
    _NL_WMON_4=131153,
    _NL_WMON_5=131154,
    _NL_WMON_6=131155,
    _NL_WMON_7=131156,
    _NL_WMON_8=131157,
    _NL_WMON_9=131158,
    _NL_WPM_STR=131163,
    _NL_WT_FMT=131166,
    _NL_WT_FMT_AMPM=131167,
    _NL_W_DATE_FMT=131181,
    __CURRENCY_SYMBOL=262145,
    __DECIMAL_POINT=65536,
    __ERA_YEAR=131117,
    __FRAC_DIGITS=262152,
    __GROUPING=65538,
    __INT_CURR_SYMBOL=262144,
    __INT_FRAC_DIGITS=262151,
    __INT_N_CS_PRECEDES=262162,
    __INT_N_SEP_BY_SPACE=262163,
    __INT_N_SIGN_POSN=262165,
    __INT_P_CS_PRECEDES=262160,
    __INT_P_SEP_BY_SPACE=262161,
    __INT_P_SIGN_POSN=262164,
    __LC_ADDRESS=9,
    __LC_ALL=6,
    __LC_COLLATE=3,
    __LC_CTYPE=0,
    __LC_IDENTIFICATION=12,
    __LC_MEASUREMENT=11,
    __LC_MESSAGES=5,
    __LC_MONETARY=4,
    __LC_NAME=8,
    __LC_NUMERIC=1,
    __LC_PAPER=7,
    __LC_TELEPHONE=10,
    __LC_TIME=2,
    __MON_DECIMAL_POINT=262146,
    __MON_GROUPING=262148,
    __MON_THOUSANDS_SEP=262147,
    __NEGATIVE_SIGN=262150,
    __NOEXPR=327681,
    __NOSTR=327683,
    __N_CS_PRECEDES=262155,
    __N_SEP_BY_SPACE=262156,
    __N_SIGN_POSN=262158,
    __POSITIVE_SIGN=262149,
    __P_CS_PRECEDES=262153,
    __P_SEP_BY_SPACE=262154,
    __P_SIGN_POSN=262157,
    __THOUSANDS_SEP=65537,
    __YESEXPR=327680,
    __YESSTR=327682
} anon_enum_32_for_mark.conflict7;

struct kbdprefix.conflict7 {
    int repeat_count;
    enum anon_enum_32_for_mark.conflict7 mark;
};

struct session.conflict7 {
    struct session * next;
    struct session * prev;
    struct window * tab;
    struct ses_history history;
    struct list_head_elinks more_files;
    struct download loading;
    struct uri * loading_uri;
    enum cache_mode reloadlevel;
    int redirect_cnt;
    struct document_view * doc_view;
    struct list_head_elinks scrn_frames;
    struct uri * download_uri;
    struct uri * referrer;
    struct session_task task;
    int search_direction;
    struct kbdprefix.conflict7 kbdprefix;
    int exit_query;
    timer_id_T display_timer;
    enum insert_mode insert_mode;
    enum navigate_mode navigate_mode;
    uchar * search_word;
    uchar * last_search_word;
    struct list_head_elinks type_queries;
    struct session_status status;
};

typedef struct change_hook_info change_hook_info, *Pchange_hook_info;

struct change_hook_info {
    uchar * name;
    int (* change_hook)(struct session *, struct option_elinks *, struct option_elinks *);
};

typedef struct option_resolver option_resolver, *Poption_resolver;

struct option_resolver {
    int id;
    uchar * name;
};

typedef enum verbose_level {
    VERBOSE_ALL=2,
    VERBOSE_LEVELS=3,
    VERBOSE_QUIET=0,
    VERBOSE_WARNINGS=1
} verbose_level;

typedef struct anon_struct.conflict anon_struct.conflict, *Panon_struct.conflict;

struct anon_struct.conflict {
    uchar * prefix;
    uchar * suffix;
    int filename_maxlen;
    int label_maxlen;
    int display_style;
    int tagging;
    uint show_any_as_links:1;
    undefined field_0x19;
    undefined field_0x1a;
    undefined field_0x1b;
};

typedef enum html_element_type {
    HTML_ELEMENTS=93,
    HTML_ELEMENT_A=1,
    HTML_ELEMENT_ABBR=2,
    HTML_ELEMENT_ACRONYM=3,
    HTML_ELEMENT_ADDRESS=4,
    HTML_ELEMENT_APPLET=5,
    HTML_ELEMENT_AREA=6,
    HTML_ELEMENT_B=7,
    HTML_ELEMENT_BASE=8,
    HTML_ELEMENT_BASEFONT=9,
    HTML_ELEMENT_BDO=10,
    HTML_ELEMENT_BIG=11,
    HTML_ELEMENT_BLOCKQUOTE=12,
    HTML_ELEMENT_BODY=13,
    HTML_ELEMENT_BR=14,
    HTML_ELEMENT_BUTTON=15,
    HTML_ELEMENT_CAPTION=16,
    HTML_ELEMENT_CENTER=17,
    HTML_ELEMENT_CITE=18,
    HTML_ELEMENT_CODE=19,
    HTML_ELEMENT_COL=20,
    HTML_ELEMENT_COLGROUP=21,
    HTML_ELEMENT_DD=22,
    HTML_ELEMENT_DEL=23,
    HTML_ELEMENT_DFN=24,
    HTML_ELEMENT_DIR=25,
    HTML_ELEMENT_DIV=26,
    HTML_ELEMENT_DL=27,
    HTML_ELEMENT_DT=28,
    HTML_ELEMENT_EM=29,
    HTML_ELEMENT_FIELDSET=30,
    HTML_ELEMENT_FONT=31,
    HTML_ELEMENT_FORM=32,
    HTML_ELEMENT_FRAME=33,
    HTML_ELEMENT_FRAMESET=34,
    HTML_ELEMENT_H1=35,
    HTML_ELEMENT_H2=36,
    HTML_ELEMENT_H3=37,
    HTML_ELEMENT_H4=38,
    HTML_ELEMENT_H5=39,
    HTML_ELEMENT_H6=40,
    HTML_ELEMENT_HEAD=41,
    HTML_ELEMENT_HR=42,
    HTML_ELEMENT_HTML=43,
    HTML_ELEMENT_I=44,
    HTML_ELEMENT_IFRAME=45,
    HTML_ELEMENT_IMG=46,
    HTML_ELEMENT_INPUT=47,
    HTML_ELEMENT_INS=48,
    HTML_ELEMENT_ISINDEX=49,
    HTML_ELEMENT_KBD=50,
    HTML_ELEMENT_LABEL=51,
    HTML_ELEMENT_LEGEND=52,
    HTML_ELEMENT_LI=53,
    HTML_ELEMENT_LINK=54,
    HTML_ELEMENT_MAP=55,
    HTML_ELEMENT_MENU=56,
    HTML_ELEMENT_META=57,
    HTML_ELEMENT_NOFRAMES=58,
    HTML_ELEMENT_NOSCRIPT=59,
    HTML_ELEMENT_OBJECT=60,
    HTML_ELEMENT_OL=61,
    HTML_ELEMENT_OPTGROUP=62,
    HTML_ELEMENT_OPTION=63,
    HTML_ELEMENT_P=64,
    HTML_ELEMENT_PARAM=65,
    HTML_ELEMENT_PRE=66,
    HTML_ELEMENT_Q=67,
    HTML_ELEMENT_S=68,
    HTML_ELEMENT_SAMP=69,
    HTML_ELEMENT_SCRIPT=70,
    HTML_ELEMENT_SELECT=71,
    HTML_ELEMENT_SMALL=72,
    HTML_ELEMENT_SPAN=73,
    HTML_ELEMENT_STRIKE=74,
    HTML_ELEMENT_STRONG=75,
    HTML_ELEMENT_STYLE=76,
    HTML_ELEMENT_SUB=77,
    HTML_ELEMENT_SUP=78,
    HTML_ELEMENT_TABLE=79,
    HTML_ELEMENT_TBODY=80,
    HTML_ELEMENT_TD=81,
    HTML_ELEMENT_TEXTAREA=82,
    HTML_ELEMENT_TFOOT=83,
    HTML_ELEMENT_TH=84,
    HTML_ELEMENT_THEAD=85,
    HTML_ELEMENT_TITLE=86,
    HTML_ELEMENT_TR=87,
    HTML_ELEMENT_TT=88,
    HTML_ELEMENT_U=89,
    HTML_ELEMENT_UL=90,
    HTML_ELEMENT_UNKNOWN=0,
    HTML_ELEMENT_VAR=91,
    HTML_ELEMENT_XMP=92
} html_element_type;

typedef enum html_attribute_type {
    HTML_ATTRIBUTES=123,
    HTML_ATTRIBUTE_ABBR=1,
    HTML_ATTRIBUTE_ACCEPT=2,
    HTML_ATTRIBUTE_ACCEPT_CHARSET=3,
    HTML_ATTRIBUTE_ACCESSKEY=4,
    HTML_ATTRIBUTE_ACTION=5,
    HTML_ATTRIBUTE_ALIGN=6,
    HTML_ATTRIBUTE_ALINK=7,
    HTML_ATTRIBUTE_ALT=8,
    HTML_ATTRIBUTE_ARCHIVE=9,
    HTML_ATTRIBUTE_AXIS=10,
    HTML_ATTRIBUTE_BACKGROUND=11,
    HTML_ATTRIBUTE_BGCOLOR=12,
    HTML_ATTRIBUTE_BORDER=13,
    HTML_ATTRIBUTE_BORDERCOLOR=14,
    HTML_ATTRIBUTE_CELLPADDING=15,
    HTML_ATTRIBUTE_CELLSPACING=16,
    HTML_ATTRIBUTE_CHAR=17,
    HTML_ATTRIBUTE_CHAROFF=18,
    HTML_ATTRIBUTE_CHARSET=19,
    HTML_ATTRIBUTE_CHECKED=20,
    HTML_ATTRIBUTE_CITE=21,
    HTML_ATTRIBUTE_CLASS=22,
    HTML_ATTRIBUTE_CLASSID=23,
    HTML_ATTRIBUTE_CLEAR=24,
    HTML_ATTRIBUTE_CODE=25,
    HTML_ATTRIBUTE_CODEBASE=26,
    HTML_ATTRIBUTE_CODETYPE=27,
    HTML_ATTRIBUTE_COLOR=28,
    HTML_ATTRIBUTE_COLS=29,
    HTML_ATTRIBUTE_COLSPAN=30,
    HTML_ATTRIBUTE_COMPACT=31,
    HTML_ATTRIBUTE_CONTENT=32,
    HTML_ATTRIBUTE_COORDS=33,
    HTML_ATTRIBUTE_DATA=34,
    HTML_ATTRIBUTE_DATETIME=35,
    HTML_ATTRIBUTE_DECLARE=36,
    HTML_ATTRIBUTE_DEFER=37,
    HTML_ATTRIBUTE_DIR=38,
    HTML_ATTRIBUTE_DISABLED=39,
    HTML_ATTRIBUTE_ENCTYPE=40,
    HTML_ATTRIBUTE_FACE=41,
    HTML_ATTRIBUTE_FOR=42,
    HTML_ATTRIBUTE_FRAME=43,
    HTML_ATTRIBUTE_FRAMEBORDER=44,
    HTML_ATTRIBUTE_HEADERS=45,
    HTML_ATTRIBUTE_HEIGHT=46,
    HTML_ATTRIBUTE_HREF=47,
    HTML_ATTRIBUTE_HREFLANG=48,
    HTML_ATTRIBUTE_HSPACE=49,
    HTML_ATTRIBUTE_HTTP_EQUIV=50,
    HTML_ATTRIBUTE_ID=51,
    HTML_ATTRIBUTE_ISMAP=52,
    HTML_ATTRIBUTE_LABEL=53,
    HTML_ATTRIBUTE_LANG=54,
    HTML_ATTRIBUTE_LANGUAGE=55,
    HTML_ATTRIBUTE_LINK=56,
    HTML_ATTRIBUTE_LONGDESC=57,
    HTML_ATTRIBUTE_MARGINHEIGHT=58,
    HTML_ATTRIBUTE_MARGINWIDTH=59,
    HTML_ATTRIBUTE_MAXLENGTH=60,
    HTML_ATTRIBUTE_MEDIA=61,
    HTML_ATTRIBUTE_METHOD=62,
    HTML_ATTRIBUTE_MULTIPLE=63,
    HTML_ATTRIBUTE_NAME=64,
    HTML_ATTRIBUTE_NOHREF=65,
    HTML_ATTRIBUTE_NORESIZE=66,
    HTML_ATTRIBUTE_NOSHADE=67,
    HTML_ATTRIBUTE_NOWRAP=68,
    HTML_ATTRIBUTE_OBJECT=69,
    HTML_ATTRIBUTE_ONBLUR=70,
    HTML_ATTRIBUTE_ONCHANGE=71,
    HTML_ATTRIBUTE_ONCLICK=72,
    HTML_ATTRIBUTE_ONDBLCLICK=73,
    HTML_ATTRIBUTE_ONFOCUS=74,
    HTML_ATTRIBUTE_ONKEYDOWN=75,
    HTML_ATTRIBUTE_ONKEYPRESS=76,
    HTML_ATTRIBUTE_ONKEYUP=77,
    HTML_ATTRIBUTE_ONLOAD=78,
    HTML_ATTRIBUTE_ONMOUSEDOWN=79,
    HTML_ATTRIBUTE_ONMOUSEMOVE=80,
    HTML_ATTRIBUTE_ONMOUSEOUT=81,
    HTML_ATTRIBUTE_ONMOUSEOVER=82,
    HTML_ATTRIBUTE_ONMOUSEUP=83,
    HTML_ATTRIBUTE_ONRESET=84,
    HTML_ATTRIBUTE_ONSELECT=85,
    HTML_ATTRIBUTE_ONSUBMIT=86,
    HTML_ATTRIBUTE_ONUNLOAD=87,
    HTML_ATTRIBUTE_PROFILE=88,
    HTML_ATTRIBUTE_PROMPT=89,
    HTML_ATTRIBUTE_READONLY=90,
    HTML_ATTRIBUTE_REL=91,
    HTML_ATTRIBUTE_REV=92,
    HTML_ATTRIBUTE_ROWS=93,
    HTML_ATTRIBUTE_ROWSPAN=94,
    HTML_ATTRIBUTE_RULES=95,
    HTML_ATTRIBUTE_SCHEME=96,
    HTML_ATTRIBUTE_SCOPE=97,
    HTML_ATTRIBUTE_SCROLLING=98,
    HTML_ATTRIBUTE_SELECTED=99,
    HTML_ATTRIBUTE_SHAPE=100,
    HTML_ATTRIBUTE_SIZE=101,
    HTML_ATTRIBUTE_SPAN=102,
    HTML_ATTRIBUTE_SRC=103,
    HTML_ATTRIBUTE_STANDBY=104,
    HTML_ATTRIBUTE_START=105,
    HTML_ATTRIBUTE_STYLE=106,
    HTML_ATTRIBUTE_SUMMARY=107,
    HTML_ATTRIBUTE_TABINDEX=108,
    HTML_ATTRIBUTE_TARGET=109,
    HTML_ATTRIBUTE_TEXT=110,
    HTML_ATTRIBUTE_TITLE=111,
    HTML_ATTRIBUTE_TYPE=112,
    HTML_ATTRIBUTE_UNKNOWN=0,
    HTML_ATTRIBUTE_URL=113,
    HTML_ATTRIBUTE_USEMAP=114,
    HTML_ATTRIBUTE_VALIGN=115,
    HTML_ATTRIBUTE_VALUE=116,
    HTML_ATTRIBUTE_VALUETYPE=117,
    HTML_ATTRIBUTE_VERSION=118,
    HTML_ATTRIBUTE_VISIBILITY=119,
    HTML_ATTRIBUTE_VLINK=120,
    HTML_ATTRIBUTE_VSPACE=121,
    HTML_ATTRIBUTE_WIDTH=122
} html_attribute_type;

typedef enum termopt {
    TERM_OPTIONS=8,
    TERM_OPT_BLOCK_CURSOR=3,
    TERM_OPT_COLORS=4,
    TERM_OPT_M11_HACK=1,
    TERM_OPT_RESTRICT_852=2,
    TERM_OPT_TRANSPARENCY=6,
    TERM_OPT_TYPE=0,
    TERM_OPT_UNDERLINE=7,
    TERM_OPT_UTF_8_IO=5
} termopt;

typedef struct action_alias action_alias, *Paction_alias;

struct action_alias {
    uchar * str;
    action_id_T action_id;
};

typedef struct named_key named_key, *Pnamed_key;

struct named_key {
    uchar * str;
    term_event_key_T num;
};

typedef struct default_kb default_kb, *Pdefault_kb;

struct default_kb {
    struct term_event_keyboard kbd;
    action_id_T action_id;
};

typedef enum select_handler_type {
    SELECT_HANDLER_DATA=3,
    SELECT_HANDLER_ERROR=2,
    SELECT_HANDLER_READ=0,
    SELECT_HANDLER_WRITE=1
} select_handler_type;

typedef union anon_union.conflict5 anon_union.conflict5, *Panon_union.conflict5;

typedef enum dom_select_element_match {
    DOM_SELECT_ELEMENT_EMPTY=32,
    DOM_SELECT_ELEMENT_NTH_CHILD=64,
    DOM_SELECT_ELEMENT_NTH_TYPE=128,
    DOM_SELECT_ELEMENT_ROOT=16,
    DOM_SELECT_ELEMENT_UNIVERSAL=8,
    DOM_SELECT_RELATION_DESCENDANT=0,
    DOM_SELECT_RELATION_DIRECT_ADJACENT=2,
    DOM_SELECT_RELATION_DIRECT_CHILD=1,
    DOM_SELECT_RELATION_FLAGS=7,
    DOM_SELECT_RELATION_INDIRECT_ADJACENT=4
} dom_select_element_match;

typedef enum dom_select_attribute_match {
    DOM_SELECT_ATTRIBUTE_ANY=1,
    DOM_SELECT_ATTRIBUTE_BEGIN=16,
    DOM_SELECT_ATTRIBUTE_CONTAINS=64,
    DOM_SELECT_ATTRIBUTE_END=32,
    DOM_SELECT_ATTRIBUTE_EXACT=2,
    DOM_SELECT_ATTRIBUTE_HYPHEN_LIST=8,
    DOM_SELECT_ATTRIBUTE_ID=128,
    DOM_SELECT_ATTRIBUTE_SPACE_LIST=4
} dom_select_attribute_match;

typedef enum dom_select_text_match {
    DOM_SELECT_TEXT_CONTAINS=1
} dom_select_text_match;

union anon_union.conflict5 {
    enum dom_select_element_match element;
    enum dom_select_attribute_match attribute;
    enum dom_select_text_match text;
};

typedef struct dom_select_node dom_select_node, *Pdom_select_node;

typedef struct dom_select_nth_match dom_select_nth_match, *Pdom_select_nth_match;

typedef union anon_union_for_match anon_union_for_match, *Panon_union_for_match;

struct dom_select_nth_match {
    size_t step;
    size_t index;
};

union anon_union_for_match {
    enum dom_select_element_match element;
    enum dom_select_attribute_match attribute;
    enum dom_select_text_match text;
};

struct dom_select_node {
    struct dom_node node;
    struct dom_select_nth_match nth_child;
    struct dom_select_nth_match nth_type;
    union anon_union_for_match match;
};

typedef enum dom_select_pseudo {
    DOM_SELECT_PSEUDO_ACTIVE=128,
    DOM_SELECT_PSEUDO_AFTER=8,
    DOM_SELECT_PSEUDO_BEFORE=16,
    DOM_SELECT_PSEUDO_CHECKED=8192,
    DOM_SELECT_PSEUDO_CONTAINS=10000,
    DOM_SELECT_PSEUDO_DISABLED=4096,
    DOM_SELECT_PSEUDO_EMPTY=10012,
    DOM_SELECT_PSEUDO_ENABLED=2048,
    DOM_SELECT_PSEUDO_FIRST_CHILD=10003,
    DOM_SELECT_PSEUDO_FIRST_LETTER=2,
    DOM_SELECT_PSEUDO_FIRST_LINE=1,
    DOM_SELECT_PSEUDO_FIRST_TYPE=10008,
    DOM_SELECT_PSEUDO_FOCUS=512,
    DOM_SELECT_PSEUDO_HOVER=256,
    DOM_SELECT_PSEUDO_INDETERMINATE=16384,
    DOM_SELECT_PSEUDO_LAST_CHILD=10004,
    DOM_SELECT_PSEUDO_LAST_TYPE=10009,
    DOM_SELECT_PSEUDO_LINK=32,
    DOM_SELECT_PSEUDO_NTH_CHILD=10001,
    DOM_SELECT_PSEUDO_NTH_LAST_CHILD=10002,
    DOM_SELECT_PSEUDO_NTH_LAST_TYPE=10007,
    DOM_SELECT_PSEUDO_NTH_TYPE=10006,
    DOM_SELECT_PSEUDO_ONLY_CHILD=10005,
    DOM_SELECT_PSEUDO_ONLY_TYPE=10010,
    DOM_SELECT_PSEUDO_ROOT=10011,
    DOM_SELECT_PSEUDO_SELECTION=4,
    DOM_SELECT_PSEUDO_TARGET=1024,
    DOM_SELECT_PSEUDO_UNKNOWN=0,
    DOM_SELECT_PSEUDO_VISITED=64
} dom_select_pseudo;

typedef struct fd_set fd_set, *Pfd_set;

typedef long __fd_mask;

struct fd_set {
    __fd_mask __fds_bits[32];
};

typedef enum dom_select_syntax {
    DOM_SELECT_SYNTAX_CSS=0,
    DOM_SELECT_SYNTAX_PATH=1
} dom_select_syntax;

typedef struct dom_select dom_select, *Pdom_select;

struct dom_select {
    struct dom_select_node * selector;
    ulong specificity;
    enum dom_select_pseudo pseudo;
};

typedef struct bottom_half bottom_half, *Pbottom_half;

struct bottom_half {
    struct bottom_half * next;
    struct bottom_half * prev;
    void (* fn)(void *);
    void * data;
};

typedef struct thread thread, *Pthread;

struct thread {
    void (* read_func)(void *);
    void (* write_func)(void *);
    void (* error_func)(void *);
    void * data;
};

typedef struct dom_select_data dom_select_data, *Pdom_select_data;

struct dom_select_data {
    struct dom_stack stack;
    struct dom_select * select;
    struct dom_node_list * list;
};

typedef struct dom_select_state dom_select_state, *Pdom_select_state;

struct dom_select_state {
    struct dom_node * node;
};

typedef struct anon_struct anon_struct, *Panon_struct;

struct anon_struct {
    struct dom_string string;
    enum dom_select_pseudo pseudo;
};

typedef struct XML_ParserStruct XML_ParserStruct, *PXML_ParserStruct;

typedef struct XML_ParserStruct * XML_Parser;

struct XML_ParserStruct {
};

typedef enum retval {
    RET_COMMAND=7,
    RET_ERROR=1,
    RET_FATAL=4,
    RET_OK=0,
    RET_PING=5,
    RET_REMOTE=6,
    RET_SIGNAL=2,
    RET_SYNTAX=3
} retval;

typedef struct program program, *Pprogram;

struct program {
    int terminate;
    enum retval retval;
    uchar * path;
};

typedef struct list_menu list_menu, *Plist_menu;

struct list_menu {
    struct menu_item * * stack;
    int stack_size;
};

typedef uchar uint8_t;

typedef struct ftp_connection_info ftp_connection_info, *Pftp_connection_info;

struct ftp_connection_info {
    int pending_commands;
    int opc;
    int conn_state;
    int buf_pos;
    uint dir:1;
    uint rest_sent:1;
    uint use_pasv:1;
    uint use_epsv:1;
    uchar ftp_buffer[16384];
    uchar cmd_buffer[1];
    undefined field_0x4012;
    undefined field_0x4013;
};

typedef struct ftp_dir_html_format ftp_dir_html_format, *Pftp_dir_html_format;

struct ftp_dir_html_format {
    int libc_codepage;
    int colorize_dir;
    uchar dircolor[8];
};

typedef struct type_query type_query, *Ptype_query;

struct type_query {
    struct type_query * next;
    struct type_query * prev;
    struct download download;
    struct cache_entry * cached;
    struct session * ses;
    struct uri * uri;
    uchar * target_frame;
    uchar * external_handler;
    int block;
    uint cgi:1;
    undefined field_0x51;
    undefined field_0x52;
    undefined field_0x53;
};

typedef struct file_download file_download, *Pfile_download;

struct file_download {
    struct file_download * next;
    struct file_download * prev;
    struct object object;
    struct uri * uri;
    uchar * file;
    uchar * external_handler;
    struct session * ses;
    struct terminal * term;
    time_t remotetime;
    off_t seek;
    int handle;
    int redirect_cnt;
    int notify;
    struct download download;
    uint delete:1;
    uint stop:1;
    uint block:1;
    undefined field_0x69;
    undefined field_0x6a;
    undefined field_0x6b;
    struct dialog_data * dlg_data;
    struct listbox_item * box_item;
};

typedef __mode_t mode_t;

typedef short int16_t;

typedef long longptr_T;


// WARNING! conflicting data type names: /DWARF/dirent.h/DIR - /dirent.h/DIR

typedef struct dirent dirent, *Pdirent;

struct dirent {
    __ino64_t d_ino;
    __off64_t d_off;
    ushort d_reclen;
    uchar d_type;
    char d_name[256];
    undefined field_0x113;
};


// WARNING! conflicting data type names: /DWARF/utime.h/utimbuf - /utime.h/utimbuf

typedef struct anon_struct.conflict10 anon_struct.conflict10, *Panon_struct.conflict10;

struct anon_struct.conflict10 {
    void * si_addr;
};


// WARNING! conflicting data type names: /DWARF/siginfo.h/sigval_t - /siginfo.h/sigval_t

typedef union anon_union.conflict8 anon_union.conflict8, *Panon_union.conflict8;

typedef struct anon_struct.conflict6 anon_struct.conflict6, *Panon_struct.conflict6;

typedef struct anon_struct.conflict7 anon_struct.conflict7, *Panon_struct.conflict7;

typedef struct anon_struct.conflict8 anon_struct.conflict8, *Panon_struct.conflict8;

typedef struct anon_struct.conflict9 anon_struct.conflict9, *Panon_struct.conflict9;

typedef struct anon_struct.conflict11 anon_struct.conflict11, *Panon_struct.conflict11;

struct anon_struct.conflict9 {
    __pid_t si_pid;
    __uid_t si_uid;
    int si_status;
    __clock_t si_utime;
    __clock_t si_stime;
};

struct anon_struct.conflict8 {
    __pid_t si_pid;
    __uid_t si_uid;
    sigval_t si_sigval;
};

struct anon_struct.conflict11 {
    long si_band;
    int si_fd;
};

struct anon_struct.conflict6 {
    __pid_t si_pid;
    __uid_t si_uid;
};

struct anon_struct.conflict7 {
    int si_tid;
    int si_overrun;
    sigval_t si_sigval;
};

union anon_union.conflict8 {
    int _pad[29];
    struct anon_struct.conflict6 _kill;
    struct anon_struct.conflict7 _timer;
    struct anon_struct.conflict8 _rt;
    struct anon_struct.conflict9 _sigchld;
    struct anon_struct.conflict10 _sigfault;
    struct anon_struct.conflict11 _sigpoll;
};


// WARNING! conflicting data type names: /DWARF/siginfo.h/sigval - /siginfo.h/sigval


// WARNING! conflicting data type names: /DWARF/siginfo.h/siginfo - /siginfo.h/siginfo


// WARNING! conflicting data type names: /DWARF/siginfo.h/siginfo_t - /siginfo.h/siginfo_t

typedef union anon_union_for__sifields anon_union_for__sifields, *Panon_union_for__sifields;

union anon_union_for__sifields {
    int _pad[29];
    struct anon_struct.conflict6 _kill;
    struct anon_struct.conflict7 _timer;
    struct anon_struct.conflict8 _rt;
    struct anon_struct.conflict9 _sigchld;
    struct anon_struct.conflict10 _sigfault;
    struct anon_struct.conflict11 _sigpoll;
};

typedef enum parse_error {
    ERROR_COMMAND=1,
    ERROR_NOMEM=5,
    ERROR_NONE=0,
    ERROR_OPTION=3,
    ERROR_PARSE=2,
    ERROR_VALUE=4
} parse_error;

typedef struct conf_parsing_pos conf_parsing_pos, *Pconf_parsing_pos;

struct conf_parsing_pos {
    uchar * look;
    int line;
};

typedef struct parse_handler parse_handler, *Pparse_handler;

typedef struct conf_parsing_state conf_parsing_state, *Pconf_parsing_state;

struct conf_parsing_state {
    struct conf_parsing_pos pos;
    uchar * mirrored;
    uchar * filename;
};

struct parse_handler {
    uchar * command;
    parse_error (* handler)(struct option_elinks *, struct conf_parsing_state *, struct string *, int);
};

typedef enum border_char {
    BORDER_DCROSS=206,
    BORDER_DDLCORNER=200,
    BORDER_DDRCORNER=188,
    BORDER_DDTEE=203,
    BORDER_DHLINE=205,
    BORDER_DLTEE=185,
    BORDER_DRTEE=204,
    BORDER_DSCROSS=215,
    BORDER_DSDLCORNER=211,
    BORDER_DSDRCORNER=189,
    BORDER_DSDTEE=210,
    BORDER_DSLTEE=182,
    BORDER_DSRTEE=199,
    BORDER_DSULCORNER=214,
    BORDER_DSURCORNER=183,
    BORDER_DSUTEE=208,
    BORDER_DULCORNER=201,
    BORDER_DURCORNER=187,
    BORDER_DUTEE=202,
    BORDER_DVLINE=186,
    BORDER_NONE=0,
    BORDER_SCROSS=197,
    BORDER_SDCROSS=216,
    BORDER_SDDLCORNER=212,
    BORDER_SDDRCORNER=190,
    BORDER_SDDTEE=209,
    BORDER_SDLCORNER=192,
    BORDER_SDLTEE=181,
    BORDER_SDRCORNER=217,
    BORDER_SDRTEE=198,
    BORDER_SDTEE=194,
    BORDER_SDULCORNER=213,
    BORDER_SDURCORNER=184,
    BORDER_SDUTEE=207,
    BORDER_SHLINE=196,
    BORDER_SLTEE=180,
    BORDER_SRTEE=195,
    BORDER_SULCORNER=218,
    BORDER_SURCORNER=191,
    BORDER_SUTEE=193,
    BORDER_SVLINE=179
} border_char;

typedef enum screen_char_attr {
    SCREEN_ATTR_BOLD=8,
    SCREEN_ATTR_FRAME=128,
    SCREEN_ATTR_ITALIC=16,
    SCREEN_ATTR_STANDOUT=64,
    SCREEN_ATTR_UNDERLINE=32,
    SCREEN_ATTR_UNSEARCHABLE=1
} screen_char_attr;

typedef enum border_cross_direction {
    BORDER_X_DOWN=2,
    BORDER_X_LEFT=1,
    BORDER_X_RIGHT=0,
    BORDER_X_UP=3
} border_cross_direction;

typedef struct hlink hlink, *Phlink;

typedef enum hlink_type {
    LT_ALTERNATE=18,
    LT_ALTERNATE_LANG=19,
    LT_ALTERNATE_MEDIA=20,
    LT_ALTERNATE_STYLESHEET=21,
    LT_APPENDIX=11,
    LT_AUTHOR=16,
    LT_BOOKMARK=14,
    LT_CHAPTER=8,
    LT_CONTENTS=5,
    LT_COPYRIGHT=15,
    LT_GLOSSARY=7,
    LT_HELP=12,
    LT_ICON=17,
    LT_INDEX=6,
    LT_NEXT=3,
    LT_PARENT=2,
    LT_PREV=4,
    LT_SEARCH=13,
    LT_SECTION=9,
    LT_START=1,
    LT_STYLESHEET=22,
    LT_SUBSECTION=10,
    LT_UNKNOWN=0
} hlink_type;

typedef enum hlink_direction {
    LD_REL=2,
    LD_REV=1,
    LD_UNKNOWN=0
} hlink_direction;

struct hlink {
    enum hlink_type type;
    enum hlink_direction direction;
    uchar * content_type;
    uchar * media;
    uchar * href;
    uchar * hreflang;
    uchar * title;
    uchar * lang;
    uchar * name;
};

typedef struct lt_default_name lt_default_name, *Plt_default_name;

struct lt_default_name {
    enum hlink_type type;
    uchar * str;
};


// WARNING! conflicting data type names: /DWARF/session.h/anon_struct - /DWARF/select.c/get_dom_select_pseudo/anon_struct

typedef struct delayed_open delayed_open, *Pdelayed_open;

struct delayed_open {
    struct session * ses;
    struct uri * uri;
    uchar * target;
};

typedef enum remote_session_flags {
    SES_REMOTE_ADD_BOOKMARK=32,
    SES_REMOTE_CURRENT_TAB=4,
    SES_REMOTE_INFO_BOX=64,
    SES_REMOTE_NEW_TAB=1,
    SES_REMOTE_NEW_WINDOW=2,
    SES_REMOTE_PING=16,
    SES_REMOTE_PROMPT_URL=8
} remote_session_flags;


// WARNING! conflicting data type names: /DWARF/session.h/anon_enum_32 - /DWARF/explodename.c/_nl_explode_name/anon_enum_32

typedef struct frame frame, *Pframe;

struct frame {
    struct frame * next;
    struct frame * prev;
    uchar * name;
    int redirect_cnt;
    struct view_state vs;
};

typedef union anon_union.conflict9 anon_union.conflict9, *Panon_union.conflict9;

union anon_union.conflict9 {
    void (* sa_handler)(int);
    void (* sa_sigaction)(int, siginfo_t *, void *);
};

typedef struct sigaction sigaction, *Psigaction;

typedef union anon_union_for___sigaction_handler anon_union_for___sigaction_handler, *Panon_union_for___sigaction_handler;

typedef struct __sigset_t __sigset_t, *P__sigset_t;

struct __sigset_t {
    ulong __val[32];
};

union anon_union_for___sigaction_handler {
    void (* sa_handler)(int);
    void (* sa_sigaction)(int, siginfo_t *, void *);
};

struct sigaction {
    union anon_union_for___sigaction_handler __sigaction_handler;
    struct __sigset_t sa_mask;
    int sa_flags;
    void (* sa_restorer)(void);
};

typedef struct anon_struct_0 anon_struct_0, *Panon_struct_0;


// WARNING! conflicting data type names: /DWARF/cmdline.c/remote_cmd/anon_struct_0/anon_enum_32 - /DWARF/explodename.c/_nl_explode_name/anon_enum_32

struct anon_struct_0 {
    uchar * name;
    enum anon_enum_32 type;
};

typedef union YYSTYPE YYSTYPE, *PYYSTYPE;

typedef enum operator {
    divide=4,
    equal=12,
    greater_or_equal=11,
    greater_than=9,
    land=14,
    less_or_equal=10,
    less_than=8,
    lnot=2,
    lor=15,
    minus=7,
    module=5,
    mult=3,
    not_equal=13,
    num=1,
    plus=6,
    qmop=16,
    var=0
} operator;

typedef struct expression expression, *Pexpression;

typedef union anon_union_for_val anon_union_for_val, *Panon_union_for_val;

union anon_union_for_val {
    ulong num;
};

union YYSTYPE {
    ulong num;
    enum operator op;
    struct expression * exp;
};

struct expression {
    int nargs;
    enum operator operation;
    union anon_union_for_val val;
    undefined field_0xc;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
    undefined field_0x10;
    undefined field_0x11;
    undefined field_0x12;
    undefined field_0x13;
};

typedef struct file_to_load file_to_load, *Pfile_to_load;

struct file_to_load {
    struct file_to_load * next;
    struct file_to_load * prev;
    struct session * ses;
    uint req_sent:1;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
    int pri;
    struct cache_entry * cached;
    uchar * target_frame;
    struct uri * uri;
    struct download download;
};

typedef struct session_info session_info, *Psession_info;

struct session_info {
    struct session_info * next;
    struct session_info * prev;
    int id;
    timer_id_T timer;
    struct session * ses;
    struct uri * uri;
    struct uri * referrer;
    enum task_type task;
    enum cache_mode cache_mode;
};

typedef struct questions_entry questions_entry, *Pquestions_entry;

struct questions_entry {
    struct questions_entry * next;
    struct questions_entry * prev;
    void (* callback)(struct session *, void *);
    void * data;
};

typedef struct string_list_item string_list_item, *Pstring_list_item;

struct string_list_item {
    struct string_list_item * next;
    struct string_list_item * prev;
    struct string string;
};

typedef struct table_elinks table_elinks, *Ptable_elinks;

typedef struct table_cell table_cell, *Ptable_cell;

typedef struct table_column table_column, *Ptable_column;

typedef struct html_start_end html_start_end, *Phtml_start_end;

struct html_start_end {
    uchar * start;
    uchar * end;
};

struct table_column {
    int group;
    int align;
    int valign;
    int width;
};

struct table_elinks {
    struct part * part;
    struct table_cell * cells;
    uchar * fragment_id;
    color_T bgcolor;
    color_T bordercolor;
    int align;
    struct table_column * columns;
    int columns_count;
    int real_columns_count;
    int * min_cols_widths;
    int * max_cols_widths;
    int * cols_widths;
    int * cols_x;
    int cols_x_count;
    int * rows_heights;
    int cols;
    int rows;
    int real_cols;
    int real_rows;
    int border;
    int cellpadding;
    int vcellpadding;
    int cellspacing;
    int frame;
    int rules;
    int width;
    int real_width;
    int real_height;
    int min_width;
    int max_width;
    int link_num;
    uint full_width:1;
    undefined field_0x7d;
    undefined field_0x7e;
    undefined field_0x7f;
    struct html_start_end caption;
    int caption_height;
    struct html_start_end * bad_html;
    int bad_html_size;
};

struct table_cell {
    uchar * start;
    uchar * end;
    uchar * fragment_id;
    color_T bgcolor;
    int col;
    int row;
    int align;
    int valign;
    int colspan;
    int rowspan;
    int min_width;
    int max_width;
    int width;
    int height;
    int link_num;
    uint is_used:1;
    uint is_spanned:1;
    uint is_header:1;
    uint is_group:1;
    undefined field_0x3d;
    undefined field_0x3e;
    undefined field_0x3f;
};

typedef struct script_event_hook script_event_hook, *Pscript_event_hook;

typedef enum script_event_hook_type {
    SEVHOOK_ONBLUR=6,
    SEVHOOK_ONCLICK=0,
    SEVHOOK_ONDBLCLICK=1,
    SEVHOOK_ONFOCUS=4,
    SEVHOOK_ONHOVER=3,
    SEVHOOK_ONMOUSEOUT=5,
    SEVHOOK_ONMOUSEOVER=2
} script_event_hook_type;

struct script_event_hook {
    struct script_event_hook * next;
    struct script_event_hook * prev;
    enum script_event_hook_type type;
    uchar * src;
};

typedef struct node node, *Pnode;

struct node {
    struct node * next;
    struct node * prev;
    struct box box;
};

typedef union anon_union.conflict4 anon_union.conflict4, *Panon_union.conflict4;

union anon_union.conflict4 {
    uchar * name;
    struct form_control * form_control;
};

typedef struct mime_backend mime_backend, *Pmime_backend;

struct mime_backend {
    uchar * (* get_content_type)(uchar *);
    mime_handler * (* get_mime_handler)(uchar *, int);
};

typedef struct bookmarks_backend bookmarks_backend, *Pbookmarks_backend;

struct bookmarks_backend {
    uchar * (* filename)(int);
    void (* read)(FILE *);
    void (* write)(struct secure_save_info *, struct list_head_elinks *);
};

typedef union anon_union.conflict7 anon_union.conflict7, *Panon_union.conflict7;

union anon_union.conflict7 {
    struct sockaddr * ifu_broadaddr;
    struct sockaddr * ifu_dstaddr;
};

typedef struct ifaddrs ifaddrs, *Pifaddrs;

typedef union anon_union_for_ifa_ifu anon_union_for_ifa_ifu, *Panon_union_for_ifa_ifu;

union anon_union_for_ifa_ifu {
    struct sockaddr * ifu_broadaddr;
    struct sockaddr * ifu_dstaddr;
};

struct ifaddrs {
    struct ifaddrs * ifa_next;
    char * ifa_name;
    uint ifa_flags;
    struct sockaddr * ifa_addr;
    struct sockaddr * ifa_netmask;
    union anon_union_for_ifa_ifu ifa_ifu;
    void * ifa_data;
};

typedef struct dom_config_info dom_config_info, *Pdom_config_info;

typedef enum dom_config_flag {
    DOM_CONFIG_CDATA_SECTIONS=1,
    DOM_CONFIG_COMMENTS=2,
    DOM_CONFIG_ELEMENT_CONTENT_WHITESPACE=4,
    DOM_CONFIG_ENTITIES=8,
    DOM_CONFIG_NORMALIZE_CHARACTERS=16,
    DOM_CONFIG_NORMALIZE_WHITESPACE=64,
    DOM_CONFIG_UNKNOWN=32
} dom_config_flag;

struct dom_config_info {
    struct dom_string name;
    enum dom_config_flag flag;
};

typedef struct link_def link_def, *Plink_def;

struct link_def {
    uchar * link;
    uchar * target;
};

typedef __rlim64_t rlim_t;

typedef struct rlimit rlimit, *Prlimit;

struct rlimit {
    rlim_t rlim_cur;
    rlim_t rlim_max;
};


// WARNING! conflicting data type names: /DWARF/resource.h/__rlimit_resource - /resource.h/__rlimit_resource

typedef enum do_move {
    DO_MOVE_ABORT=0,
    DO_MOVE_DISPLAY=1,
    DO_MOVE_DONE=2
} do_move;

typedef struct task task, *Ptask;

struct task {
    struct session * ses;
    struct uri * uri;
    enum cache_mode cache_mode;
    struct session_task session_task;
};

typedef struct deflate_enc_data deflate_enc_data, *Pdeflate_enc_data;

typedef struct z_stream_s z_stream_s, *Pz_stream_s;

typedef void * voidpf;

typedef uint uInt;

typedef struct z_stream_s z_stream;

typedef uchar Byte;

typedef Byte Bytef;

typedef ulong uLong;

typedef struct internal_state internal_state, *Pinternal_state;

struct z_stream_s {
    Bytef * next_in;
    uInt avail_in;
    uLong total_in;
    Bytef * next_out;
    uInt avail_out;
    uLong total_out;
    char * msg;
    struct internal_state * state;
    voidpf (* zalloc)(voidpf, uInt, uInt);
    void (* zfree)(voidpf, voidpf);
    voidpf opaque;
    int data_type;
    uLong adler;
    uLong reserved;
};

struct deflate_enc_data {
    z_stream deflate_stream;
    int fdread;
    uint last_read:1;
    uint after_first_read:1;
    uchar buf[5000];
    undefined field_0x13c5;
    undefined field_0x13c6;
    undefined field_0x13c7;
};

struct internal_state {
    int dummy;
};

typedef struct interlink_event interlink_event, *Pinterlink_event;


// WARNING! conflicting data type names: /DWARF/mouse.h/interlink_event/anon_union_for_info - /DWARF/common.h/widget_data/anon_union_for_info

struct interlink_event {
    enum term_event_type ev;
    union anon_union_for_info info;
};

typedef struct known_translation_t known_translation_t, *Pknown_translation_t;

typedef struct loaded_l10nfile loaded_l10nfile, *Ploaded_l10nfile;

struct known_translation_t {
    uchar * domainname;
    int category;
    int counter;
    struct loaded_l10nfile * domain;
    uchar * translation;
    size_t translation_length;
    uchar msgid[1];
    undefined field_0x19;
    undefined field_0x1a;
    undefined field_0x1b;
};

struct loaded_l10nfile {
    uchar * filename;
    uchar * langdirname;
    int langdirnamelen;
    int decided;
    void * data;
    struct loaded_l10nfile * next;
    struct loaded_l10nfile * successor[1];
};

typedef uchar transmem_block_t;

typedef struct css_stylesheet css_stylesheet, *Pcss_stylesheet;

struct css_stylesheet {
    void (* import)(struct css_stylesheet *, struct uri *, uchar *, int);
    void * import_data;
    struct list_head_elinks selectors;
    int import_level;
};

typedef struct html_element html_element, *Phtml_element;

struct html_element {
    struct html_element * next;
    struct html_element * prev;
    enum html_element_mortality_type type;
    struct text_attrib attr;
    struct par_attrib parattr;
    int invisible;
    uchar * name;
    int namelen;
    uchar * options;
    int linebreak;
    struct frameset_desc * frameset;
    enum html_element_pseudo_class pseudo_class;
};

typedef struct html_context html_context, *Phtml_context;

typedef enum html_special_type {
} html_special_type;

struct html_context {
    struct css_stylesheet css_styles;
    struct uri * base_href;
    uchar * base_target;
    struct document_options * options;
    int doc_cp;
    struct list_head_elinks stack;
    uchar * eoff;
    int line_breax;
    int position;
    enum html_whitespace_state putsp;
    int was_li;
    uint quote_level;
    uint was_br:1;
    uint was_xmp:1;
    uint was_style:1;
    uint has_link_lines:1;
    uint was_body:1;
    uint was_body_background:1;
    undefined field_0x45;
    undefined field_0x46;
    undefined field_0x47;
    int margin;
    uchar * startf;
    int table_level;
    struct part * part;
    void (* put_chars_f)(struct html_context *, uchar *, int);
    void (* line_break_f)(struct html_context *);
    void * (* special_f)(struct html_context *, enum html_special_type, ...);
};

typedef struct html_context.conflict html_context.conflict, *Phtml_context.conflict;

struct html_context.conflict {
    struct css_stylesheet css_styles;
    struct uri * base_href;
    uchar * base_target;
    struct document_options * options;
    int doc_cp;
    struct list_head_elinks stack;
    uchar * eoff;
    int line_breax;
    int position;
    enum html_whitespace_state putsp;
    int was_li;
    uint quote_level;
    uint was_br:1;
    uint was_xmp:1;
    uint was_style:1;
    uint has_link_lines:1;
    uint was_body:1;
    uint was_body_background:1;
    undefined field_0x45;
    undefined field_0x46;
    undefined field_0x47;
    int margin;
    uchar * startf;
    int table_level;
    struct part * part;
    void (* put_chars_f)(struct html_context *, uchar *, int);
    void (* line_break_f)(struct html_context *);
    void * (* special_f)(struct html_context *, enum html_special_type.conflict, ...);
};

typedef enum html_attr_flags {
    HTML_ATTR_EAT_NL=2,
    HTML_ATTR_LITERAL_NL=8,
    HTML_ATTR_NONE=0,
    HTML_ATTR_TEST=1
} html_attr_flags;

typedef struct ftp_file_info ftp_file_info, *Pftp_file_info;

typedef enum ftp_file_type {
    FTP_FILE_DIRECTORY=100,
    FTP_FILE_PLAINFILE=45,
    FTP_FILE_SYMLINK=108,
    FTP_FILE_UNKNOWN=63
} ftp_file_type;

struct ftp_file_info {
    enum ftp_file_type type;
    struct string name;
    struct string symlink;
    off_t size;
    time_t mtime;
    uint local_time_zone:1;
    undefined field_0x21;
    undefined field_0x22;
    undefined field_0x23;
    mode_t permissions;
};


// WARNING! conflicting data type names: /DWARF/stdio.h/_IO_FILE - /stdio.h/_IO_FILE

typedef struct element_info element_info, *Pelement_info;

typedef enum element_type {
    ET_LI=3,
    ET_NESTABLE=0,
    ET_NON_NESTABLE=1,
    ET_NON_PAIRABLE=2
} element_type;

struct element_info {
    uchar * name;
    void (* open)(struct html_context *, uchar *, uchar *, uchar *, uchar * *);
    void (* close)(struct html_context *, uchar *, uchar *, uchar *, uchar * *);
    int linebreak;
    enum element_type type;
};

typedef enum ftp_unix {
    FTP_UNIX_DAY=2,
    FTP_UNIX_NAME=4,
    FTP_UNIX_PERMISSIONS=0,
    FTP_UNIX_SIZE=1,
    FTP_UNIX_TIME=3
} ftp_unix;

typedef enum ftp_eplf {
    FTP_EPLF_DIRECTORY=47,
    FTP_EPLF_FILENAME=9,
    FTP_EPLF_ID=105,
    FTP_EPLF_MTIME=109,
    FTP_EPLF_PLAINFILE=114,
    FTP_EPLF_SIZE=115
} ftp_eplf;

typedef enum dns_result {
    DNS_ASYNC=1,
    DNS_ERROR=-1,
    DNS_SUCCESS=0
} dns_result;

typedef struct widget_info_button widget_info_button, *Pwidget_info_button;

struct widget_info_button {
    int flags;
    int hotkey_pos;
    int textlen;
    int truetextlen;
    void (* done)(void *);
    void * done_data;
};

typedef struct dom_config dom_config, *Pdom_config;

typedef struct dom_error dom_error, *Pdom_error;

struct dom_error {
};

struct dom_config {
    enum dom_config_flag flags;
    void (* error_handler)(struct dom_config *, struct dom_error *);
};

typedef struct bfu_color_entry bfu_color_entry, *Pbfu_color_entry;

struct bfu_color_entry {
    color_T * background;
    color_T * foreground;
    struct color_pair colors;
};

typedef enum uri_rewrite_type {
    URI_REWRITE_DUMB=0,
    URI_REWRITE_SMART=1
} uri_rewrite_type;

typedef enum uri_rewrite_option {
    URI_REWRITE_DUMB_TEMPLATE=4,
    URI_REWRITE_DUMB_TREE=3,
    URI_REWRITE_ENABLE_DUMB=1,
    URI_REWRITE_ENABLE_SMART=2,
    URI_REWRITE_OPTIONS=7,
    URI_REWRITE_SMART_TEMPLATE=6,
    URI_REWRITE_SMART_TREE=5,
    URI_REWRITE_TREE=0
} uri_rewrite_option;

typedef struct search_dlg_hop search_dlg_hop, *Psearch_dlg_hop;

struct search_dlg_hop {
    void * data;
    union option_value values[1];
};

typedef enum typeahead_code {
    TYPEAHEAD_CANCEL=3,
    TYPEAHEAD_ERROR=1,
    TYPEAHEAD_ERROR_NO_FURTHER=2,
    TYPEAHEAD_MATCHED=0
} typeahead_code;

typedef enum search_option {
    SEARCH_OPTIONS=1,
    SEARCH_OPT_CASE=0
} search_option;

typedef enum find_error {
    FIND_ERROR_HIT_BOTTOM=3,
    FIND_ERROR_HIT_TOP=2,
    FIND_ERROR_MEMORY=5,
    FIND_ERROR_NONE=0,
    FIND_ERROR_NOT_FOUND=4,
    FIND_ERROR_NO_PREVIOUS_SEARCH=1,
    FIND_ERROR_REGEX=6
} find_error;

typedef struct dnsquery dnsquery, *Pdnsquery;

struct dnsquery {
    void (* done)(void *, struct sockaddr_storage *, int);
    void * data;
    struct sockaddr_storage * addr;
    int addrno;
    struct dnsquery * * queryref;
    int h;
    uchar name[1];
    undefined field_0x19;
    undefined field_0x1a;
    undefined field_0x1b;
};

typedef struct dnsentry dnsentry, *Pdnsentry;

struct dnsentry {
    struct dnsentry * next;
    struct dnsentry * prev;
    struct sockaddr_storage * addr;
    int addrno;
    struct timeval_T creation_time;
    uchar name[1];
    undefined field_0x19;
    undefined field_0x1a;
    undefined field_0x1b;
};

typedef struct alias_map alias_map, *Palias_map;

struct alias_map {
    uchar * alias;
    uchar * value;
};

typedef struct dom_node_search dom_node_search, *Pdom_node_search;

struct dom_node_search {
    struct dom_node * key;
    uint from;
    uint pos;
    uint to;
};

typedef struct fastfind_key_value fastfind_key_value, *Pfastfind_key_value;

struct fastfind_key_value {
    uchar * key;
    void * data;
};

typedef enum fastfind_flags {
    FF_CASE_AWARE=1,
    FF_COMPRESS=2,
    FF_LOCALE_INDEP=4,
    FF_NONE=0
} fastfind_flags;

typedef struct fastfind_index fastfind_index, *Pfastfind_index;

struct fastfind_index {
    uchar * comment;
    void (* reset)(void);
    fastfind_key_value * (* next)(void);
    void * handle;
};

typedef enum dom_node_type {
    DOM_NODES=13,
    DOM_NODE_ATTRIBUTE=2,
    DOM_NODE_CDATA_SECTION=4,
    DOM_NODE_COMMENT=8,
    DOM_NODE_DOCUMENT=9,
    DOM_NODE_DOCUMENT_FRAGMENT=11,
    DOM_NODE_DOCUMENT_TYPE=10,
    DOM_NODE_ELEMENT=1,
    DOM_NODE_ENTITY=6,
    DOM_NODE_ENTITY_REFERENCE=5,
    DOM_NODE_NOTATION=12,
    DOM_NODE_PROCESSING_INSTRUCTION=7,
    DOM_NODE_TEXT=3,
    DOM_NODE_UNKNOWN=0
} dom_node_type;

typedef enum dom_proc_instruction_type {
    DOM_PROC_INSTRUCTION=0,
    DOM_PROC_INSTRUCTION_TYPES=3,
    DOM_PROC_INSTRUCTION_XML=1,
    DOM_PROC_INSTRUCTION_XML_STYLESHEET=2
} dom_proc_instruction_type;

typedef struct fastfind_info fastfind_info, *Pfastfind_info;

typedef struct ff_data ff_data, *Pff_data;

typedef struct ff_node_c ff_node_c, *Pff_node_c;

struct ff_node_c {
    uint e:1;
    uint c:1;
    uint p:10;
    uint l:13;
    uint ch:7;
};

struct fastfind_info {
    struct ff_data * data;
    struct ff_node_c * * leafsets;
    struct ff_node_c * root_leafset;
    int min_key_len;
    int max_key_len;
    int uniq_chars_count;
    int count;
    int pointers_count;
    int leafsets_count;
    uint case_aware:1;
    uint locale_indep:1;
    uint compress:1;
    undefined field_0x25;
    undefined field_0x26;
    undefined field_0x27;
    int idxtab[128];
    uchar uniq_chars[128];
};

struct ff_data {
    void * pointer;
    int keylen;
};

typedef struct write_bookmarks_default write_bookmarks_default, *Pwrite_bookmarks_default;

struct write_bookmarks_default {
    struct secure_save_info * ssi;
    int save_folder_state;
    int codepage;
    struct conv_table * conv_table;
};


// WARNING! conflicting data type names: /DWARF/utsname.h/utsname - /utsname.h/utsname

typedef struct stat stat, *Pstat;

struct stat {
    __dev_t st_dev;
    ushort __pad1;
    undefined field_0xa;
    undefined field_0xb;
    __ino_t __st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    ushort __pad2;
    undefined field_0x2a;
    undefined field_0x2b;
    __off64_t st_size;
    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    __ino64_t st_ino;
};

typedef struct bz2_enc_data bz2_enc_data, *Pbz2_enc_data;

typedef struct bz_stream bz_stream, *Pbz_stream;

struct bz_stream {
    char * next_in;
    uint avail_in;
    uint total_in_lo32;
    uint total_in_hi32;
    char * next_out;
    uint avail_out;
    uint total_out_lo32;
    uint total_out_hi32;
    void * state;
    void * (* bzalloc)(void *, int, int);
    void (* bzfree)(void *, void *);
    void * opaque;
};

struct bz2_enc_data {
    struct bz_stream fbz_stream;
    int fdread;
    int last_read;
    uchar buf[5000];
};

typedef enum edit_dialog_type {
    EDIT_DLG_ADD=1,
    EDIT_DLG_SEARCH=0
} edit_dialog_type;

typedef struct winsize winsize, *Pwinsize;

struct winsize {
    ushort ws_row;
    ushort ws_col;
    ushort ws_xpixel;
    ushort ws_ypixel;
};

typedef enum msgbox_flags {
    MSGBOX_FREE_TEXT=1,
    MSGBOX_NO_INTL=2,
    MSGBOX_NO_TEXT_INTL=8,
    MSGBOX_SCROLLABLE=4
} msgbox_flags;

typedef struct auth_entry auth_entry, *Pauth_entry;

struct auth_entry {
    struct auth_entry * next;
    struct auth_entry * prev;
    struct object object;
    struct uri * uri;
    uchar * realm;
    uchar * nonce;
    uchar * opaque;
    struct listbox_item * box_item;
    uchar user[40];
    uchar password[40];
    uint blocked:1;
    uint valid:1;
    uint digest:1;
    undefined field_0x71;
    undefined field_0x72;
    undefined field_0x73;
};


// WARNING! conflicting data type names: /DWARF/pwd.h/passwd - /pwd.h/passwd


// WARNING! conflicting data type names: /DWARF/_UNCATEGORIZED_/__dirstream - /dirent.h/__dirstream

typedef struct gss_cred_id_desc_struct gss_cred_id_desc_struct, *Pgss_cred_id_desc_struct;

struct gss_cred_id_desc_struct {
};

typedef struct dump_output dump_output, *Pdump_output;

struct dump_output {
    size_t bufpos;
    struct string * string;
    int fd;
    uchar buf[65536];
};

typedef union anon_union anon_union, *Panon_union;

typedef struct widget_info_checkbox widget_info_checkbox, *Pwidget_info_checkbox;

struct widget_info_checkbox {
    int gid;
    int gnum;
};

union anon_union {
    struct widget_info_checkbox checkbox;
    struct widget_info_field field;
    struct widget_info_button button;
    struct widget_info_text text;
};

typedef union anon_union.conflict anon_union.conflict, *Panon_union.conflict;

union anon_union.conflict {
    struct widget_data_info_field field;
    struct widget_data_info_checkbox checkbox;
    struct widget_data_info_text text;
};

typedef enum rss_attribute_type {
    RSS_ATTRIBUTES=2,
    RSS_ATTRIBUTE_ISPERMALINK=1,
    RSS_ATTRIBUTE_UNKNOWN=0
} rss_attribute_type;

typedef enum rss_element_type {
    RSS_ELEMENTS=9,
    RSS_ELEMENT_AUTHOR=1,
    RSS_ELEMENT_CHANNEL=2,
    RSS_ELEMENT_DESCRIPTION=3,
    RSS_ELEMENT_GUID=4,
    RSS_ELEMENT_ITEM=5,
    RSS_ELEMENT_LINK=6,
    RSS_ELEMENT_PUBDATE=7,
    RSS_ELEMENT_TITLE=8,
    RSS_ELEMENT_UNKNOWN=0
} rss_element_type;

typedef struct anon_struct.conflict5 anon_struct.conflict5, *Panon_struct.conflict5;

struct anon_struct.conflict5 {
    unicode_val_T x;
    uchar * s;
};

typedef enum cookies_accept {
    COOKIES_ACCEPT_ALL=2,
    COOKIES_ACCEPT_ASK=1,
    COOKIES_ACCEPT_NONE=0
} cookies_accept;

typedef struct cookie cookie, *Pcookie;

typedef struct cookie_server cookie_server, *Pcookie_server;

struct cookie_server {
    struct cookie_server * next;
    struct cookie_server * prev;
    struct object object;
    struct listbox_item * box_item;
    uchar host[1];
    undefined field_0x11;
    undefined field_0x12;
    undefined field_0x13;
};

struct cookie {
    struct cookie * next;
    struct cookie * prev;
    struct object object;
    uchar * name;
    uchar * value;
    uchar * path;
    uchar * domain;
    struct cookie_server * server;
    time_t expires;
    int secure;
    struct listbox_item * box_item;
};

typedef enum led_option {
    LEDS_CLOCK_ALIAS=3,
    LEDS_CLOCK_ENABLE=1,
    LEDS_CLOCK_FORMAT=2,
    LEDS_CLOCK_TREE=0,
    LEDS_OPTIONS=6,
    LEDS_PANEL_ENABLE=5,
    LEDS_PANEL_TREE=4
} led_option;

typedef char XML_Char;

typedef struct table_frames table_frames, *Ptable_frames;

struct table_frames {
    uint top:1;
    uint bottom:1;
    uint left:1;
    uint right:1;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
};

typedef enum cookies_option {
    COOKIES_ACCEPT_POLICY=1,
    COOKIES_MAX_AGE=2,
    COOKIES_OPTIONS=6,
    COOKIES_PARANOID_SECURITY=3,
    COOKIES_RESAVE=5,
    COOKIES_SAVE=4,
    COOKIES_TREE=0
} cookies_option;

typedef struct c_domain c_domain, *Pc_domain;

struct c_domain {
    struct c_domain * next;
    struct c_domain * prev;
    uchar domain[1];
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
};


// WARNING! conflicting data type names: /DWARF/cookies.c/load_cookies/lexical_block_0/anon_enum_32 - /DWARF/explodename.c/_nl_explode_name/anon_enum_32

typedef struct anon_struct_1 anon_struct_1, *Panon_struct_1;

struct anon_struct_1 {
    uchar * pos;
    int len;
};

typedef union yyalloc yyalloc, *Pyyalloc;

union yyalloc {
    short yyss;
    union YYSTYPE yyvs;
};

typedef char yysigned_char;

typedef struct anon_struct.conflict4 anon_struct.conflict4, *Panon_struct.conflict4;

struct anon_struct.conflict4 {
    int n;
    uchar * s;
};

typedef enum gnutls_certificate_verify_flags {
    GNUTLS_VERIFY_ALLOW_ANY_X509_V1_CA_CRT=8,
    GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD2=16,
    GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5=32,
    GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT=2,
    GNUTLS_VERIFY_DISABLE_CA_SIGN=1,
    GNUTLS_VERIFY_DISABLE_TIME_CHECKS=64,
    GNUTLS_VERIFY_DO_NOT_ALLOW_SAME=4
} gnutls_certificate_verify_flags;


// WARNING! conflicting data type names: /DWARF/netdb.h/addrinfo - /netdb.h/addrinfo

typedef struct entity_cache entity_cache, *Pentity_cache;

struct entity_cache {
    uint hits;
    int strlen;
    int encoding;
    uchar * result;
    uchar str[20];
};

typedef struct codepage_desc codepage_desc, *Pcodepage_desc;

typedef struct table_entry table_entry, *Ptable_entry;

struct table_entry {
    uchar c;
    undefined field_0x1;
    uint16_t u;
};

struct codepage_desc {
    uchar * name;
    uchar * * aliases;
    uint16_t * highhalf;
    struct table_entry * table_elinks;
};

typedef struct md5_context md5_context, *Pmd5_context;

struct md5_context {
    uint32_t buf[4];
    uint32_t bits[2];
    uchar in[64];
};

typedef uchar md5_digest_bin_T[16];

typedef struct md5_context MD5_CTX;

typedef uchar md5_digest_hex_T[32];

typedef struct mo_file_header mo_file_header, *Pmo_file_header;

typedef uint nls_uint32;

struct mo_file_header {
    nls_uint32 magic;
    nls_uint32 revision;
    nls_uint32 nstrings;
    nls_uint32 orig_tab_offset;
    nls_uint32 trans_tab_offset;
    nls_uint32 hash_tab_size;
    nls_uint32 hash_tab_offset;
};

typedef struct string_desc string_desc, *Pstring_desc;

struct string_desc {
    nls_uint32 length;
    nls_uint32 offset;
};

typedef struct terminal_info terminal_info, *Pterminal_info;

struct terminal_info {
    struct interlink_event event;
    uchar name[32];
    uchar cwd[256];
    int system_env;
    int length;
    int session_info;
    int magic;
    uchar data[1];
    undefined field_0x141;
    undefined field_0x142;
    undefined field_0x143;
};

typedef struct term_event_size term_event_size, *Pterm_event_size;

struct term_event_size {
    int width;
    int height;
};

typedef union anon_union.conflict10 anon_union.conflict10, *Panon_union.conflict10;

union anon_union.conflict10 {
    struct term_event_mouse mouse;
    struct interlink_event_keyboard keyboard;
    struct term_event_size size;
};

typedef union anon_union.conflict1 anon_union.conflict1, *Panon_union.conflict1;

union anon_union.conflict1 {
    struct term_event_mouse mouse;
    struct term_event_keyboard keyboard;
    struct term_event_size size;
};

typedef struct submitted_value submitted_value, *Psubmitted_value;

struct submitted_value {
    struct submitted_value * next;
    struct submitted_value * prev;
    uchar * name;
    uchar * value;
    struct form_control * form_control;
    enum form_type type;
    int position;
};

typedef struct boundary_info boundary_info, *Pboundary_info;

struct boundary_info {
    int count;
    int * offsets;
    uchar string[32];
};

typedef enum utf8_step {
    UTF8_STEP_CELLS_FEWER=1,
    UTF8_STEP_CELLS_MORE=2,
    UTF8_STEP_CHARACTERS=0
} utf8_step;

typedef enum nbsp_mode {
    NBSP_MODE_ASCII=1,
    NBSP_MODE_HACK=0
} nbsp_mode;

typedef union anon_union.conflict2 anon_union.conflict2, *Panon_union.conflict2;

union anon_union.conflict2 {
    uchar * str;
    struct conv_table * tbl;
};

typedef struct in_addr in_addr, *Pin_addr;

typedef uint32_t in_addr_t;

struct in_addr {
    in_addr_t s_addr;
};

typedef uint16_t in_port_t;

typedef struct sockaddr_in sockaddr_in, *Psockaddr_in;

struct sockaddr_in {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;
    uchar sin_zero[8];
};

typedef struct sockaddr_in6 sockaddr_in6, *Psockaddr_in6;

typedef struct in6_addr in6_addr, *Pin6_addr;

typedef union anon_union_for___in6_u anon_union_for___in6_u, *Panon_union_for___in6_u;

union anon_union_for___in6_u {
    uint8_t __u6_addr8[16];
    uint16_t __u6_addr16[8];
    uint32_t __u6_addr32[4];
};

struct in6_addr {
    union anon_union_for___in6_u __in6_u;
};

struct sockaddr_in6 {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
};

typedef union anon_union.conflict3 anon_union.conflict3, *Panon_union.conflict3;

union anon_union.conflict3 {
    uint8_t __u6_addr8[16];
    uint16_t __u6_addr16[8];
    uint32_t __u6_addr32[4];
};

typedef struct host_connection host_connection, *Phost_connection;

struct host_connection {
    struct host_connection * next;
    struct host_connection * prev;
    struct object object;
    struct uri * uri;
};

typedef struct keepalive_connection keepalive_connection, *Pkeepalive_connection;

struct keepalive_connection {
    struct keepalive_connection * next;
    struct keepalive_connection * prev;
    struct uri * uri;
    void (* done)(struct connection *);
    struct timeval_T timeout;
    struct timeval_T creation_time;
    uint protocol_family:1;
    undefined field_0x21;
    undefined field_0x22;
    undefined field_0x23;
    int socket;
};

typedef struct loaded_domain loaded_domain, *Ploaded_domain;

struct loaded_domain {
    uchar * data;
    int use_mmap;
    size_t mmap_size;
    int must_swap;
    nls_uint32 nstrings;
    struct string_desc * orig_tab;
    struct string_desc * trans_tab;
    nls_uint32 hash_size;
    nls_uint32 * hash_tab;
    int codeset_cntr;
    iconv_t conv;
    uchar * * conv_tab;
    struct expression * plural;
    ulong nplurals;
};

typedef union anon_union.conflict6 anon_union.conflict6, *Panon_union.conflict6;

union anon_union.conflict6 {
    ulong num;
    struct expression * args[3];
};

typedef struct binding binding, *Pbinding;

struct binding {
    struct binding * next;
    uchar * dirname;
    int codeset_cntr;
    uchar * codeset;
    uchar domainname[1];
    undefined field_0x11;
    undefined field_0x12;
    undefined field_0x13;
};

typedef struct parse_args parse_args, *Pparse_args;

struct parse_args {
    uchar * cp;
    struct expression * res;
};

typedef struct lun_hop lun_hop, *Plun_hop;

struct lun_hop {
    struct terminal * term;
    uchar * ofile;
    uchar * file;
    void (* callback)(struct terminal *, uchar *, void *, int);
    void * data;
};

typedef struct anon_struct.conflict12 anon_struct.conflict12, *Panon_struct.conflict12;

struct anon_struct.conflict12 {
    uchar * type;
    uint plain:1;
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
};

typedef struct codw_hop codw_hop, *Pcodw_hop;

struct codw_hop {
    int magic;
    struct type_query * type_query;
    uchar * real_file;
    uchar * file;
};

typedef struct cdf_hop cdf_hop, *Pcdf_hop;

struct cdf_hop {
    uchar * * real_file;
    int safe;
    void (* callback)(struct terminal *, int, void *, int);
    void * data;
};

typedef struct cmdw_hop cmdw_hop, *Pcmdw_hop;

struct cmdw_hop {
    int magic;
    struct session * ses;
    uchar * real_file;
};

typedef struct connection.conflict connection.conflict, *Pconnection.conflict;

struct connection.conflict {
    struct connection * next;
    struct connection * prev;
    struct list_head_elinks downloads;
    struct progress * progress;
    struct uri * uri;
    struct uri * proxied_uri;
    struct uri * referrer;
    enum cache_mode cache_mode;
    struct cache_entry * cached;
    off_t from;
    off_t received;
    off_t est_length;
    enum stream_encoding content_encoding;
    struct stream_encoded * stream;
    void (* done)(struct connection *);
    uint id;
    struct connection_state state;
    struct connection_state prev_error;
    struct socket * socket;
    struct socket * data_socket;
    int tries;
    timer_id_T timer;
    int stream_pipes[2];
    uint running:1;
    uint unrestartable:1;
    uint detached:1;
    uint cgi:1;
    undefined field_0x79;
    undefined field_0x7a;
    undefined field_0x7b;
    int pri[7];
    void * info;
};

typedef enum frame_event_status {
    FRAME_EVENT_IGNORED=0,
    FRAME_EVENT_OK=2,
    FRAME_EVENT_REFRESH=1,
    FRAME_EVENT_SESSION_DESTROYED=3
} frame_event_status;

typedef struct signal_info signal_info, *Psignal_info;

struct signal_info {
    void (* handler)(void *);
    void * data;
    int critical;
    int mask;
};

typedef struct anon_struct.conflict14 anon_struct.conflict14, *Panon_struct.conflict14;

struct anon_struct.conflict14 {
    unicode_val_T ucs;
    int len;
    unicode_val_T min;
    enum term_event_modifier_T modifier;
};

typedef struct event event, *Pevent;

typedef struct event_handler event_handler, *Pevent_handler;

struct event_handler {
    evhook_status (* callback)(va_list, void *);
    int priority;
    void * data;
};

struct event {
    uchar * name;
    struct event_handler * handlers;
    uint count;
    int id;
};

typedef struct form_type_name form_type_name, *Pform_type_name;

struct form_type_name {
    enum form_type num;
    uchar * name;
};


// WARNING! conflicting data type names: /stdarg.h/__gnuc_va_list - /DWARF/stdarg.h/__gnuc_va_list


// WARNING! conflicting data type names: /time.h/timeval - /DWARF/time.h/timeval

typedef struct timezone timezone, *Ptimezone;

typedef struct timezone * __timezone_ptr_t;

struct timezone {
    int tz_minuteswest;
    int tz_dsttime;
};


// WARNING! conflicting data type names: /time.h/tm - /DWARF/time.h/tm


// WARNING! conflicting data type names: /sigaction.h/sigaction - /DWARF/sigaction.h/sigaction

typedef union _union_1048 _union_1048, *P_union_1048;

typedef void (* __sighandler_t)(int);

union _union_1048 {
    __sighandler_t sa_handler;
    void (* sa_sigaction)(int, siginfo_t *, void *);
};

typedef uint wint_t;


// WARNING! conflicting data type names: /sigset.h/__sigset_t - /DWARF/sigset.h/__sigset_t

typedef struct __sigset_t sigset_t;


// WARNING! conflicting data type names: /select.h/fd_set - /DWARF/select.h/fd_set

typedef int (* __compar_fn_t)(void *, void *);

typedef struct Elf32_Shdr Elf32_Shdr, *PElf32_Shdr;

typedef enum Elf_SectionHeaderType_x86 {
    SHT_CHECKSUM=1879048184,
    SHT_DYNAMIC=6,
    SHT_DYNSYM=11,
    SHT_FINI_ARRAY=15,
    SHT_GNU_ATTRIBUTES=1879048181,
    SHT_GNU_HASH=1879048182,
    SHT_GNU_LIBLIST=1879048183,
    SHT_GNU_verdef=1879048189,
    SHT_GNU_verneed=1879048190,
    SHT_GNU_versym=1879048191,
    SHT_GROUP=17,
    SHT_HASH=5,
    SHT_INIT_ARRAY=14,
    SHT_NOBITS=8,
    SHT_NOTE=7,
    SHT_NULL=0,
    SHT_PREINIT_ARRAY=16,
    SHT_PROGBITS=1,
    SHT_REL=9,
    SHT_RELA=4,
    SHT_SHLIB=10,
    SHT_STRTAB=3,
    SHT_SUNW_COMDAT=1879048187,
    SHT_SUNW_move=1879048186,
    SHT_SUNW_syminfo=1879048188,
    SHT_SYMTAB=2,
    SHT_SYMTAB_SHNDX=18
} Elf_SectionHeaderType_x86;

struct Elf32_Shdr {
    dword sh_name;
    enum Elf_SectionHeaderType_x86 sh_type;
    dword sh_flags;
    dword sh_addr;
    dword sh_offset;
    dword sh_size;
    dword sh_link;
    dword sh_info;
    dword sh_addralign;
    dword sh_entsize;
};

typedef struct Elf32_Dyn_x86 Elf32_Dyn_x86, *PElf32_Dyn_x86;

typedef enum Elf32_DynTag_x86 {
    DT_AUDIT=1879047932,
    DT_AUXILIARY=2147483645,
    DT_BIND_NOW=24,
    DT_CHECKSUM=1879047672,
    DT_CONFIG=1879047930,
    DT_DEBUG=21,
    DT_DEPAUDIT=1879047931,
    DT_ENCODING=32,
    DT_FEATURE_1=1879047676,
    DT_FILTER=2147483647,
    DT_FINI=13,
    DT_FINI_ARRAY=26,
    DT_FINI_ARRAYSZ=28,
    DT_FLAGS=30,
    DT_FLAGS_1=1879048187,
    DT_GNU_CONFLICT=1879047928,
    DT_GNU_CONFLICTSZ=1879047670,
    DT_GNU_HASH=1879047925,
    DT_GNU_LIBLIST=1879047929,
    DT_GNU_LIBLISTSZ=1879047671,
    DT_GNU_PRELINKED=1879047669,
    DT_HASH=4,
    DT_INIT=12,
    DT_INIT_ARRAY=25,
    DT_INIT_ARRAYSZ=27,
    DT_JMPREL=23,
    DT_MOVEENT=1879047674,
    DT_MOVESZ=1879047675,
    DT_MOVETAB=1879047934,
    DT_NEEDED=1,
    DT_NULL=0,
    DT_PLTGOT=3,
    DT_PLTPAD=1879047933,
    DT_PLTPADSZ=1879047673,
    DT_PLTREL=20,
    DT_PLTRELSZ=2,
    DT_POSFLAG_1=1879047677,
    DT_PREINIT_ARRAYSZ=33,
    DT_REL=17,
    DT_RELA=7,
    DT_RELACOUNT=1879048185,
    DT_RELAENT=9,
    DT_RELASZ=8,
    DT_RELCOUNT=1879048186,
    DT_RELENT=19,
    DT_RELSZ=18,
    DT_RPATH=15,
    DT_RUNPATH=29,
    DT_SONAME=14,
    DT_STRSZ=10,
    DT_STRTAB=5,
    DT_SYMBOLIC=16,
    DT_SYMENT=11,
    DT_SYMINENT=1879047679,
    DT_SYMINFO=1879047935,
    DT_SYMINSZ=1879047678,
    DT_SYMTAB=6,
    DT_TEXTREL=22,
    DT_TLSDESC_GOT=1879047927,
    DT_TLSDESC_PLT=1879047926,
    DT_VERDEF=1879048188,
    DT_VERDEFNUM=1879048189,
    DT_VERNEED=1879048190,
    DT_VERNEEDNUM=1879048191,
    DT_VERSYM=1879048176
} Elf32_DynTag_x86;

struct Elf32_Dyn_x86 {
    enum Elf32_DynTag_x86 d_tag;
    dword d_val;
};

typedef struct Elf32_Sym Elf32_Sym, *PElf32_Sym;

struct Elf32_Sym {
    dword st_name;
    dword st_value;
    dword st_size;
    byte st_info;
    byte st_other;
    word st_shndx;
};

typedef struct Elf32_Phdr Elf32_Phdr, *PElf32_Phdr;

typedef enum Elf_ProgramHeaderType_x86 {
    PT_DYNAMIC=2,
    PT_GNU_EH_FRAME=1685382480,
    PT_GNU_RELRO=1685382482,
    PT_GNU_STACK=1685382481,
    PT_INTERP=3,
    PT_LOAD=1,
    PT_NOTE=4,
    PT_NULL=0,
    PT_PHDR=6,
    PT_SHLIB=5,
    PT_TLS=7
} Elf_ProgramHeaderType_x86;

struct Elf32_Phdr {
    enum Elf_ProgramHeaderType_x86 p_type;
    dword p_offset;
    dword p_vaddr;
    dword p_paddr;
    dword p_filesz;
    dword p_memsz;
    dword p_flags;
    dword p_align;
};

typedef struct Elf32_Rel Elf32_Rel, *PElf32_Rel;

struct Elf32_Rel {
    dword r_offset; // location to apply the relocation action
    dword r_info; // the symbol table index and the type of relocation
};

typedef struct Elf32_Ehdr Elf32_Ehdr, *PElf32_Ehdr;

struct Elf32_Ehdr {
    byte e_ident_magic_num;
    char e_ident_magic_str[3];
    byte e_ident_class;
    byte e_ident_data;
    byte e_ident_version;
    byte e_ident_pad[9];
    word e_type;
    word e_machine;
    dword e_version;
    dword e_entry;
    dword e_phoff;
    dword e_shoff;
    dword e_flags;
    word e_ehsize;
    word e_phentsize;
    word e_phnum;
    word e_shentsize;
    word e_shnum;
    word e_shstrndx;
};


// WARNING! conflicting data type names: /grp.h/group - /DWARF/grp.h/group




undefined4 _init(void)

{
  undefined4 uStack12;
  
  __gmon_start__();
  frame_dummy();
  __do_global_ctors_aux();
  return uStack12;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fileno(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fileno(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fputs(char *__s,FILE *__stream)

{
  int iVar1;
  
  iVar1 = fputs(__s,__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void abort(void)

{
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention yet parameter storage is locked

int * __errno_location(void)

{
  int *piVar1;
  
  piVar1 = __errno_location();
  return piVar1;
}



void gnutls_mac_get(void)

{
  gnutls_mac_get();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * inet_ntop(int __af,void *__cp,char *__buf,socklen_t __len)

{
  char *pcVar1;
  
  pcVar1 = inet_ntop(__af,__cp,__buf,__len);
  return pcVar1;
}



void gnutls_global_init(void)

{
  gnutls_global_init();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

FILE * popen(char *__command,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = popen(__command,__modes);
  return pFVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void srand(uint __seed)

{
  srand(__seed);
  return;
}



void __argz_count(void)

{
  __argz_count();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int connect(int __fd,sockaddr *__addr,socklen_t __len)

{
  int iVar1;
  
  iVar1 = connect(__fd,__addr,__len);
  return iVar1;
}



void rb_define_global_function(void)

{
  rb_define_global_function();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__pid_t getpid(void)

{
  __pid_t _Var1;
  
  _Var1 = getpid();
  return _Var1;
}



void gss_release_name(void)

{
  gss_release_name();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int mkdir(char *__path,__mode_t __mode)

{
  int iVar1;
  
  iVar1 = mkdir(__path,__mode);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strerror(int __errnum)

{
  char *pcVar1;
  
  pcVar1 = strerror(__errnum);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int getsockname(int __fd,sockaddr *__addr,socklen_t *__len)

{
  int iVar1;
  
  iVar1 = getsockname(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

long sysconf(int __name)

{
  long lVar1;
  
  lVar1 = sysconf(__name);
  return lVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int memcmp(void *__s1,void *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = memcmp(__s1,__s2,__n);
  return iVar1;
}



void gnutls_certificate_type_get_name(void)

{
  gnutls_certificate_type_get_name();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)

{
  qsort(__base,__nmemb,__size,__compar);
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void freeaddrinfo(addrinfo *__ai)

{
  freeaddrinfo(__ai);
  return;
}



void gnutls_record_recv(void)

{
  gnutls_record_recv();
  return;
}



void XML_ParserCreate(void)

{
  XML_ParserCreate();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * bsearch(void *__key,void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)

{
  void *pvVar1;
  
  pvVar1 = bsearch(__key,__base,__nmemb,__size,__compar);
  return pvVar1;
}



void inflateEnd(void)

{
  inflateEnd();
  return;
}



void gss_release_buffer(void)

{
  gss_release_buffer();
  return;
}



void __isoc99_fscanf(void)

{
  __isoc99_fscanf();
  return;
}



void gnutls_record_send(void)

{
  gnutls_record_send();
  return;
}



void gnutls_handshake(void)

{
  gnutls_handshake();
  return;
}



void __fprintf_chk(void)

{
  __fprintf_chk();
  return;
}



void gnutls_protocol_get_name(void)

{
  gnutls_protocol_get_name();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__sighandler_t signal(int __sig,__sighandler_t __handler)

{
  __sighandler_t p_Var1;
  
  p_Var1 = signal(__sig,__handler);
  return p_Var1;
}



void __gmon_start__(void)

{
  __gmon_start__();
  return;
}



void gnutls_certificate_set_x509_trust_file(void)

{
  gnutls_certificate_set_x509_trust_file();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * realloc(void *__ptr,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = realloc(__ptr,__size);
  return pvVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

iconv_t iconv_open(char *__tocode,char *__fromcode)

{
  iconv_t pvVar1;
  
  pvVar1 = iconv_open(__tocode,__fromcode);
  return pvVar1;
}



void gnutls_compression_get(void)

{
  gnutls_compression_get();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int __xstat64(int __ver,char *__filename,stat64 *__stat_buf)

{
  int iVar1;
  
  iVar1 = __xstat64(__ver,__filename,__stat_buf);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

tm * localtime(time_t *__timer)

{
  tm *ptVar1;
  
  ptVar1 = localtime(__timer);
  return ptVar1;
}



void __argz_stringify(void)

{
  __argz_stringify();
  return;
}



void __printf_chk(void)

{
  __printf_chk();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double strtod(char *__nptr,char **__endptr)

{
  float10 extraout_ST0;
  
  strtod(__nptr,__endptr);
  return (double)extraout_ST0;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strchr(__s,__c);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * getenv(char *__name)

{
  char *pcVar1;
  
  pcVar1 = getenv(__name);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * calloc(size_t __nmemb,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = calloc(__nmemb,__size);
  return pvVar1;
}



void gnutls_certificate_allocate_credentials(void)

{
  gnutls_certificate_allocate_credentials();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int system(char *__command)

{
  int iVar1;
  
  iVar1 = system(__command);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strncpy(char *__dest,char *__src,size_t __n)

{
  char *pcVar1;
  
  pcVar1 = strncpy(__dest,__src,__n);
  return pcVar1;
}



void gnutls_transport_set_ptr(void)

{
  gnutls_transport_set_ptr();
  return;
}



void ruby_init(void)

{
  ruby_init();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * mremap(void *__addr,size_t __old_len,size_t __new_len,int __flags,...)

{
  void *pvVar1;
  
  pvVar1 = mremap(__addr,__old_len,__new_len,__flags);
  return pvVar1;
}



void gnutls_certificate_set_verify_flags(void)

{
  gnutls_certificate_set_verify_flags();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

ssize_t write(int __fd,void *__buf,size_t __n)

{
  ssize_t sVar1;
  
  sVar1 = write(__fd,__buf,__n);
  return sVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int listen(int __fd,int __n)

{
  int iVar1;
  
  iVar1 = listen(__fd,__n);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__off64_t lseek64(int __fd,__off64_t __offset,int __whence)

{
  undefined4 extraout_EAX;
  undefined4 extraout_EDX;
  
  lseek64(__fd,__offset,__whence);
  return CONCAT44(extraout_EDX,extraout_EAX);
}



void XML_GetErrorCode(void)

{
  XML_GetErrorCode();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * fgets(char *__s,int __n,FILE *__stream)

{
  char *pcVar1;
  
  pcVar1 = fgets(__s,__n,__stream);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int rename(char *__old,char *__new)

{
  int iVar1;
  
  iVar1 = rename(__old,__new);
  return iVar1;
}



void rb_protect(void)

{
  rb_protect();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * memset(void *__s,int __c,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memset(__s,__c,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

FILE * fopen64(char *__filename,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fopen64(__filename,__modes);
  return pFVar1;
}



void ruby_init_loadpath(void)

{
  ruby_init_loadpath();
  return;
}



void __libc_start_main(void)

{
  __libc_start_main();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * mempcpy(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = mempcpy(__dest,__src,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int execl(char *__path,char *__arg,...)

{
  int iVar1;
  
  iVar1 = execl(__path,__arg);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int _IO_getc(_IO_FILE *__fp)

{
  int iVar1;
  
  iVar1 = _IO_getc(__fp);
  return iVar1;
}



void __memcpy_chk(void)

{
  __memcpy_chk();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * stpcpy(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = stpcpy(__dest,__src);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void _exit(int __status)

{
                    // WARNING: Subroutine does not return
  _exit(__status);
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strrchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strrchr(__s,__c);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int uname(utsname *__name)

{
  int iVar1;
  
  iVar1 = uname(__name);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int tcgetattr(int __fd,termios *__termios_p)

{
  int iVar1;
  
  iVar1 = tcgetattr(__fd,__termios_p);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fseeko64(FILE *__stream,__off64_t __off,int __whence)

{
  int iVar1;
  
  iVar1 = fseeko64(__stream,__off,__whence);
  return iVar1;
}



void __vsnprintf_chk(void)

{
  __vsnprintf_chk();
  return;
}



void rb_str_new(void)

{
  rb_str_new();
  return;
}



void idna_to_ascii_lz(void)

{
  idna_to_ascii_lz();
  return;
}



void XML_GetCurrentColumnNumber(void)

{
  XML_GetCurrentColumnNumber();
  return;
}



void gnutls_cipher_set_priority(void)

{
  gnutls_cipher_set_priority();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

ssize_t read(int __fd,void *__buf,size_t __nbytes)

{
  ssize_t sVar1;
  
  sVar1 = read(__fd,__buf,__nbytes);
  return sVar1;
}



void inflateInit2_(void)

{
  inflateInit2_();
  return;
}



void __strcat_chk(void)

{
  __strcat_chk();
  return;
}



void gnutls_anon_free_client_credentials(void)

{
  gnutls_anon_free_client_credentials();
  return;
}



void gnutls_credentials_set(void)

{
  gnutls_credentials_set();
  return;
}



void gnutls_cipher_get_name(void)

{
  gnutls_cipher_get_name();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int ungetc(int __c,FILE *__stream)

{
  int iVar1;
  
  iVar1 = ungetc(__c,__stream);
  return iVar1;
}



void gnutls_init(void)

{
  gnutls_init();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int gettimeofday(timeval *__tv,__timezone_ptr_t __tz)

{
  int iVar1;
  
  iVar1 = gettimeofday(__tv,__tz);
  return iVar1;
}



void inflate(void)

{
  inflate();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

long strtol(char *__nptr,char **__endptr,int __base)

{
  long lVar1;
  
  lVar1 = strtol(__nptr,__endptr,__base);
  return lVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

FILE * fdopen(int __fd,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fdopen(__fd,__modes);
  return pFVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__int32_t ** __ctype_toupper_loc(void)

{
  __int32_t **pp_Var1;
  
  pp_Var1 = __ctype_toupper_loc();
  return pp_Var1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void free(void *__ptr)

{
  free(__ptr);
  return;
}



void rb_define_singleton_method(void)

{
  rb_define_singleton_method();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int inet_pton(int __af,char *__cp,void *__buf)

{
  int iVar1;
  
  iVar1 = inet_pton(__af,__cp,__buf);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int __lxstat64(int __ver,char *__filename,stat64 *__stat_buf)

{
  int iVar1;
  
  iVar1 = __lxstat64(__ver,__filename,__stat_buf);
  return iVar1;
}



void backtrace_symbols(void)

{
  backtrace_symbols();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * fgets_unlocked(char *__s,int __n,FILE *__stream)

{
  char *pcVar1;
  
  pcVar1 = fgets_unlocked(__s,__n,__stream);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int setpgid(__pid_t __pid,__pid_t __pgid)

{
  int iVar1;
  
  iVar1 = setpgid(__pid,__pgid);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int access(char *__name,int __type)

{
  int iVar1;
  
  iVar1 = access(__name,__type);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int sigaction(int __sig,sigaction *__act,sigaction *__oact)

{
  int iVar1;
  
  iVar1 = sigaction(__sig,__act,__oact);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fflush(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fflush(__stream);
  return iVar1;
}



void __vfprintf_chk(void)

{
  __vfprintf_chk();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

DIR * opendir(char *__name)

{
  DIR *pDVar1;
  
  pDVar1 = opendir(__name);
  return pDVar1;
}



void rb_define_module(void)

{
  rb_define_module();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int accept(int __fd,sockaddr *__addr,socklen_t *__addr_len)

{
  int iVar1;
  
  iVar1 = accept(__fd,__addr,__addr_len);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int ioctl(int __fd,ulong __request,...)

{
  int iVar1;
  
  iVar1 = ioctl(__fd,__request);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int socket(int __domain,int __type,int __protocol)

{
  int iVar1;
  
  iVar1 = socket(__domain,__type,__protocol);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int dup2(int __fd,int __fd2)

{
  int iVar1;
  
  iVar1 = dup2(__fd,__fd2);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

ushort ** __ctype_b_loc(void)

{
  ushort **ppuVar1;
  
  ppuVar1 = __ctype_b_loc();
  return ppuVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int isatty(int __fd)

{
  int iVar1;
  
  iVar1 = isatty(__fd);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int getaddrinfo(char *__name,char *__service,addrinfo *__req,addrinfo **__pai)

{
  int iVar1;
  
  iVar1 = getaddrinfo(__name,__service,__req,__pai);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__mode_t umask(__mode_t __mask)

{
  __mode_t _Var1;
  
  _Var1 = umask(__mask);
  return _Var1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fclose(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__off64_t ftello64(FILE *__stream)

{
  undefined4 extraout_EAX;
  undefined4 extraout_EDX;
  
  ftello64(__stream);
  return CONCAT44(extraout_EDX,extraout_EAX);
}



// WARNING: Unknown calling convention yet parameter storage is locked

time_t mktime(tm *__tp)

{
  time_t tVar1;
  
  tVar1 = mktime(__tp);
  return tVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fsync(int __fd)

{
  int iVar1;
  
  iVar1 = fsync(__fd);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

dirent64 * readdir64(DIR *__dirp)

{
  dirent64 *pdVar1;
  
  pdVar1 = readdir64(__dirp);
  return pdVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * tfind(void *__key,void **__rootp,__compar_fn_t __compar)

{
  void *pvVar1;
  
  pvVar1 = tfind(__key,__rootp,__compar);
  return pvVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * memcpy(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memcpy(__dest,__src,__n);
  return pvVar1;
}



void gnutls_kx_set_priority(void)

{
  gnutls_kx_set_priority();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int utime(char *__file,utimbuf *__file_times)

{
  int iVar1;
  
  iVar1 = utime(__file,__file_times);
  return iVar1;
}



void gnutls_protocol_set_priority(void)

{
  gnutls_protocol_set_priority();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

ulong strtoul(char *__nptr,char **__endptr,int __base)

{
  ulong uVar1;
  
  uVar1 = strtoul(__nptr,__endptr,__base);
  return uVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t strlen(char *__s)

{
  size_t sVar1;
  
  sVar1 = strlen(__s);
  return sVar1;
}



void gnutls_protocol_get_version(void)

{
  gnutls_protocol_get_version();
  return;
}



void gnutls_deinit(void)

{
  gnutls_deinit();
  return;
}



void rb_load_protect(void)

{
  rb_load_protect();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

uint alarm(uint __seconds)

{
  uint uVar1;
  
  uVar1 = alarm(__seconds);
  return uVar1;
}



void gnutls_anon_allocate_client_credentials(void)

{
  gnutls_anon_allocate_client_credentials();
  return;
}



void rb_class_path(void)

{
  rb_class_path();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int unlink(char *__name)

{
  int iVar1;
  
  iVar1 = unlink(__name);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t iconv(iconv_t __cd,char **__inbuf,size_t *__inbytesleft,char **__outbuf,
            size_t *__outbytesleft)

{
  size_t sVar1;
  
  sVar1 = iconv(__cd,__inbuf,__inbytesleft,__outbuf,__outbytesleft);
  return sVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

passwd * getpwuid(__uid_t __uid)

{
  passwd *ppVar1;
  
  ppVar1 = getpwuid(__uid);
  return ppVar1;
}



void BZ2_bzDecompress(void)

{
  BZ2_bzDecompress();
  return;
}



void getifaddrs(void)

{
  getifaddrs();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * setlocale(int __category,char *__locale)

{
  char *pcVar1;
  
  pcVar1 = setlocale(__category,__locale);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__pid_t waitpid(__pid_t __pid,int *__stat_loc,int __options)

{
  __pid_t _Var1;
  
  _Var1 = waitpid(__pid,__stat_loc,__options);
  return _Var1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int feof(FILE *__stream)

{
  int iVar1;
  
  iVar1 = feof(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strcpy(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = strcpy(__dest,__src);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__gid_t getegid(void)

{
  __gid_t _Var1;
  
  _Var1 = getegid();
  return _Var1;
}



void XML_GetCurrentLineNumber(void)

{
  XML_GetCurrentLineNumber();
  return;
}



void rb_inspect(void)

{
  rb_inspect();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int chdir(char *__path)

{
  int iVar1;
  
  iVar1 = chdir(__path);
  return iVar1;
}



void gnutls_mac_get_name(void)

{
  gnutls_mac_get_name();
  return;
}



void ruby_script(void)

{
  ruby_script();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * ctime(time_t *__timer)

{
  char *pcVar1;
  
  pcVar1 = ctime(__timer);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int bind(int __fd,sockaddr *__addr,socklen_t __len)

{
  int iVar1;
  
  iVar1 = bind(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__uid_t getuid(void)

{
  __uid_t _Var1;
  
  _Var1 = getuid();
  return _Var1;
}



void gnutls_certificate_verify_peers(void)

{
  gnutls_certificate_verify_peers();
  return;
}



void Gpm_GetEvent(void)

{
  Gpm_GetEvent();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int mkstemp64(char *__template)

{
  int iVar1;
  
  iVar1 = mkstemp64(__template);
  return iVar1;
}



void gnutls_compression_get_name(void)

{
  gnutls_compression_get_name();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int select(int __nfds,fd_set *__readfds,fd_set *__writefds,fd_set *__exceptfds,timeval *__timeout)

{
  int iVar1;
  
  iVar1 = select(__nfds,__readfds,__writefds,__exceptfds,__timeout);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int closedir(DIR *__dirp)

{
  int iVar1;
  
  iVar1 = closedir(__dirp);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int close(int __fd)

{
  int iVar1;
  
  iVar1 = close(__fd);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)

{
  size_t sVar1;
  
  sVar1 = fwrite(__ptr,__size,__n,__s);
  return sVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strstr(char *__haystack,char *__needle)

{
  char *pcVar1;
  
  pcVar1 = strstr(__haystack,__needle);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

time_t time(time_t *__timer)

{
  time_t tVar1;
  
  tVar1 = time(__timer);
  return tVar1;
}



void gnutls_certificate_free_credentials(void)

{
  gnutls_certificate_free_credentials();
  return;
}



void BZ2_bzDecompressEnd(void)

{
  BZ2_bzDecompressEnd();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * nl_langinfo(nl_item __item)

{
  char *pcVar1;
  
  pcVar1 = nl_langinfo(__item);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * malloc(size_t __size)

{
  void *pvVar1;
  
  pvVar1 = malloc(__size);
  return pvVar1;
}



void XML_ErrorString(void)

{
  XML_ErrorString();
  return;
}



void rb_obj_as_string(void)

{
  rb_obj_as_string();
  return;
}



void __stack_chk_fail(void)

{
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fputc(int __c,FILE *__stream)

{
  int iVar1;
  
  iVar1 = fputc(__c,__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * memrchr(void *__s,int __c,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memrchr(__s,__c,__n);
  return pvVar1;
}



void rb_define_module_function(void)

{
  rb_define_module_function();
  return;
}



void gss_delete_sec_context(void)

{
  gss_delete_sec_context();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strcasestr(char *__haystack,char *__needle)

{
  char *pcVar1;
  
  pcVar1 = strcasestr(__haystack,__needle);
  return pcVar1;
}



void freeifaddrs(void)

{
  freeifaddrs();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

group * getgrgid(__gid_t __gid)

{
  group *pgVar1;
  
  pgVar1 = getgrgid(__gid);
  return pgVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

uint sleep(uint __seconds)

{
  uint uVar1;
  
  uVar1 = sleep(__seconds);
  return uVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

ssize_t readlink(char *__path,char *__buf,size_t __len)

{
  ssize_t sVar1;
  
  sVar1 = readlink(__path,__buf,__len);
  return sVar1;
}



void backtrace(void)

{
  backtrace();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * memmove(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memmove(__dest,__src,__n);
  return pvVar1;
}



void XML_ParserFree(void)

{
  XML_ParserFree();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__int32_t ** __ctype_tolower_loc(void)

{
  __int32_t **pp_Var1;
  
  pp_Var1 = __ctype_tolower_loc();
  return pp_Var1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

wint_t towlower(wint_t __wc)

{
  wint_t wVar1;
  
  wVar1 = towlower(__wc);
  return wVar1;
}



void gnutls_certificate_type_get(void)

{
  gnutls_certificate_type_get();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * getcwd(char *__buf,size_t __size)

{
  char *pcVar1;
  
  pcVar1 = getcwd(__buf,__size);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int sigfillset(sigset_t *__set)

{
  int iVar1;
  
  iVar1 = sigfillset(__set);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int vasprintf(char **__ptr,char *__f,__gnuc_va_list __arg)

{
  int iVar1;
  
  iVar1 = vasprintf(__ptr,__f,__arg);
  return iVar1;
}



void __rawmemchr(void)

{
  __rawmemchr();
  return;
}



void XML_SetElementHandler(void)

{
  XML_SetElementHandler();
  return;
}



void gnutls_priority_set_direct(void)

{
  gnutls_priority_set_direct();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__pid_t fork(void)

{
  __pid_t _Var1;
  
  _Var1 = fork();
  return _Var1;
}



void gnutls_kx_get(void)

{
  gnutls_kx_get();
  return;
}



void gnutls_kx_get_name(void)

{
  gnutls_kx_get_name();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int __fxstat64(int __ver,int __fildes,stat64 *__stat_buf)

{
  int iVar1;
  
  iVar1 = __fxstat64(__ver,__fildes,__stat_buf);
  return iVar1;
}



void gss_import_name(void)

{
  gss_import_name();
  return;
}



void rb_str_new2(void)

{
  rb_str_new2();
  return;
}



void XML_Parse(void)

{
  XML_Parse();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int setsockopt(int __fd,int __level,int __optname,void *__optval,socklen_t __optlen)

{
  int iVar1;
  
  iVar1 = setsockopt(__fd,__level,__optname,__optval,__optlen);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int tcsetattr(int __fd,int __optional_actions,termios *__termios_p)

{
  int iVar1;
  
  iVar1 = tcsetattr(__fd,__optional_actions,__termios_p);
  return iVar1;
}



void rb_intern(void)

{
  rb_intern();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fcntl(int __fd,int __cmd,...)

{
  int iVar1;
  
  iVar1 = fcntl(__fd,__cmd);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int getrlimit64(__rlimit_resource_t __resource,rlimit64 *__rlimits)

{
  int iVar1;
  
  iVar1 = getrlimit64(__resource,__rlimits);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int rand(void)

{
  int iVar1;
  
  iVar1 = rand();
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

tm * gmtime(time_t *__timer)

{
  tm *ptVar1;
  
  ptVar1 = gmtime(__timer);
  return ptVar1;
}



void __sprintf_chk(void)

{
  __sprintf_chk();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * memchr(void *__s,int __c,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memchr(__s,__c,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int strncmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = strncmp(__s1,__s2,__n);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int open64(char *__file,int __oflag,...)

{
  int iVar1;
  
  iVar1 = open64(__file,__oflag);
  return iVar1;
}



void rb_funcall3(void)

{
  rb_funcall3();
  return;
}



void __snprintf_chk(void)

{
  __snprintf_chk();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int _IO_putc(int __c,_IO_FILE *__fp)

{
  int iVar1;
  
  iVar1 = _IO_putc(__c,__fp);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int munmap(void *__addr,size_t __len)

{
  int iVar1;
  
  iVar1 = munmap(__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int pipe(int *__pipedes)

{
  int iVar1;
  
  iVar1 = pipe(__pipedes);
  return iVar1;
}



void Gpm_Open(void)

{
  Gpm_Open();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)

{
  size_t sVar1;
  
  sVar1 = fread(__ptr,__size,__n,__stream);
  return sVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int getsockopt(int __fd,int __level,int __optname,void *__optval,socklen_t *__optlen)

{
  int iVar1;
  
  iVar1 = getsockopt(__fd,__level,__optname,__optval,__optlen);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t strftime(char *__s,size_t __maxsize,char *__format,tm *__tp)

{
  size_t sVar1;
  
  sVar1 = strftime(__s,__maxsize,__format,__tp);
  return sVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int kill(__pid_t __pid,int __sig)

{
  int iVar1;
  
  iVar1 = kill(__pid,__sig);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * mmap64(void *__addr,size_t __len,int __prot,int __flags,int __fd,__off64_t __offset)

{
  void *pvVar1;
  
  pvVar1 = mmap64(__addr,__len,__prot,__flags,__fd,__offset);
  return pvVar1;
}



void __memmove_chk(void)

{
  __memmove_chk();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * tempnam(char *__dir,char *__pfx)

{
  char *pcVar1;
  
  pcVar1 = tempnam(__dir,__pfx);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t strcspn(char *__s,char *__reject)

{
  size_t sVar1;
  
  sVar1 = strcspn(__s,__reject);
  return sVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int getpeername(int __fd,sockaddr *__addr,socklen_t *__len)

{
  int iVar1;
  
  iVar1 = getpeername(__fd,__addr,__len);
  return iVar1;
}



void BZ2_bzDecompressInit(void)

{
  BZ2_bzDecompressInit();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int ferror(FILE *__stream)

{
  int iVar1;
  
  iVar1 = ferror(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

passwd * getpwnam(char *__name)

{
  passwd *ppVar1;
  
  ppVar1 = getpwnam(__name);
  return ppVar1;
}



void gss_init_sec_context(void)

{
  gss_init_sec_context();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int strcmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcmp(__s1,__s2);
  return iVar1;
}



void XML_SetCharacterDataHandler(void)

{
  XML_SetCharacterDataHandler();
  return;
}



void gnutls_cipher_get(void)

{
  gnutls_cipher_get();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void herror(char *__str)

{
  herror(__str);
  return;
}



void __strdup(void)

{
  __strdup();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int setenv(char *__name,char *__value,int __replace)

{
  int iVar1;
  
  iVar1 = setenv(__name,__value,__replace);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void exit(int __status)

{
                    // WARNING: Subroutine does not return
  exit(__status);
}



void gnutls_bye(void)

{
  gnutls_bye();
  return;
}



void rb_define_const(void)

{
  rb_define_const();
  return;
}



void gnutls_strerror(void)

{
  gnutls_strerror();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int pclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = pclose(__stream);
  return iVar1;
}



void backtrace_symbols_fd(void)

{
  backtrace_symbols_fd();
  return;
}



void __vasprintf_chk(void)

{
  __vasprintf_chk();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__gid_t getgid(void)

{
  __gid_t _Var1;
  
  _Var1 = getgid();
  return _Var1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * tsearch(void *__key,void **__rootp,__compar_fn_t __compar)

{
  void *pvVar1;
  
  pvVar1 = tsearch(__key,__rootp,__compar);
  return pvVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__uid_t geteuid(void)

{
  __uid_t _Var1;
  
  _Var1 = geteuid();
  return _Var1;
}



void _start(void)

{
  __libc_start_main(main);
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x08059baa)
// WARNING: Removing unreachable block (ram,0x08059bb0)

void __do_global_dtors_aux(void)

{
  if (completed_7065 == '\0') {
    completed_7065 = '\x01';
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x08059bf8)

void frame_dummy(void)

{
  return;
}



// WARNING: Exceeded maximum restarts with more pending

widget_handler_status_T select_button(dialog_data *dlg_data,widget_data *widget_data)

{
  widget_handler_status_T wVar1;
  
                    // WARNING: Could not recover jumptable at 0x08059c1f. Too many branches
                    // WARNING: Treating indirect jump as call
  wVar1 = (*widget_data->widget->handler)();
  return wVar1;
}



// WARNING: Exceeded maximum restarts with more pending

widget_handler_status_T mouse_button(dialog_data *dlg_data,widget_data *widget_data)

{
  terminal *ptVar1;
  term_event *ptVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  widget_handler_T *UNRECOVERED_JUMPTABLE;
  widget_handler_status_T wVar6;
  
  ptVar1 = dlg_data->win->term;
  ptVar2 = dlg_data->term_event;
  if ((*(uint *)((int)&ptVar2->info + 8) & 7) < 3) {
    iVar3 = *(int *)((int)&ptVar2->info + 4);
    iVar4 = (widget_data->box).x;
    if ((((iVar4 <= *(int *)&ptVar2->info) && (iVar5 = (widget_data->box).y, iVar5 <= iVar3)) &&
        (*(int *)&ptVar2->info < iVar4 + (widget_data->box).width)) &&
       (iVar3 < (widget_data->box).height + iVar5)) {
      select_widget(dlg_data,widget_data);
      (ptVar1->prev_mouse_event).x = 0;
      (ptVar1->prev_mouse_event).y = 0;
      (ptVar1->prev_mouse_event).button = 0;
      if (((*(byte *)((int)&ptVar2->info + 8) & 0x20) != 0) &&
         (UNRECOVERED_JUMPTABLE = widget_data->widget->ops->select,
         UNRECOVERED_JUMPTABLE != (widget_handler_T *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x08059cee. Too many branches
                    // WARNING: Treating indirect jump as call
        wVar6 = (*UNRECOVERED_JUMPTABLE)();
        return wVar6;
      }
      return EVENT_PROCESSED;
    }
  }
  return EVENT_NOT_PROCESSED;
}



widget_handler_status_T display_button(dialog_data *dlg_data,widget_data *widget_data)

{
  uchar *p;
  terminal *term;
  uchar *text;
  uint length;
  int *piVar1;
  int x;
  int length_00;
  int length_01;
  int iVar2;
  uchar *name;
  screen_char_attr attr;
  bool bVar3;
  int local_34;
  color_pair *local_2c;
  int local_24;
  color_pair *local_20;
  
  term = dlg_data->win->term;
  bVar3 = dlg_data->widgets_data + dlg_data->selected_widget_id == widget_data;
  if (bVar3) {
    local_2c = get_bfu_color(term,"dialog.button-shortcut-selected");
    local_20 = get_bfu_color(term,(uchar *)"dialog.button-selected");
  }
  else {
    local_2c = get_bfu_color(term,(uchar *)"dialog.button-shortcut");
    local_20 = get_bfu_color(term,"dialog.button");
  }
  if ((local_2c != (color_pair *)0x0) && (local_20 != (color_pair *)0x0)) {
    if ((*(byte *)&term->field_0x38 & 2) == 0) {
      x = (widget_data->box).x;
      local_34 = x + 2;
      local_24 = (widget_data->box).width + -4;
    }
    else {
      length_00 = utf8_ptr2cells("[ ",(uchar *)0x0);
      length_01 = utf8_ptr2cells(" ]",(uchar *)0x0);
      x = (widget_data->box).x;
      local_34 = length_00 + x;
      local_24 = (-length_00 - length_01) + (widget_data->box).width;
    }
    draw_text(term,x,(widget_data->box).y,"[ ",2,0,local_20);
    if (0 < local_24) {
      text = widget_data->widget->text;
      length = *(uint *)(widget_data->widget->info + 4);
      piVar1 = get_opt_(config_options,name);
      attr = ~-(uint)(*piVar1 == 0) & SCREEN_ATTR_UNDERLINE;
      if ((*(byte *)&term->field_0x38 & 2) == 0) {
        if ((int)length < 0) {
          draw_text(term,local_34,(widget_data->box).y,text,1,attr,local_2c);
          draw_text(term,local_34 + 1,(widget_data->box).y,text + 1,local_24 + -1,0,local_20);
        }
        else {
          x = ~length + *(int *)(widget_data->widget->info + 0xc);
          if (length != 0) {
            draw_text(term,local_34,(widget_data->box).y,text,length,0,local_20);
          }
          draw_text(term,local_34 + length,(widget_data->box).y,text + length + 1,1,attr,local_2c);
          if (1 < x) {
            draw_text(term,local_34 + length + 1,(widget_data->box).y,text + length + 2,x + -1,0,
                      local_20);
          }
        }
      }
      else {
        if ((int)length < 0) {
          x = utf8_char2cells(text,(uchar *)0x0);
          length_00 = utf8charlen(text);
          length_01 = utf8_cells2bytes(text + length_00,local_24 - x,(uchar *)0x0);
          draw_text(term,local_34,(widget_data->box).y,text,length_00,attr,local_2c);
          draw_text(term,x + local_34,(widget_data->box).y,text + length_00,length_01,0,local_20);
        }
        else {
          p = text + length + 1;
          x = utf8charlen(p);
          length_00 = utf8_ptr2cells(text,text + length);
          iVar2 = (*(int *)(widget_data->widget->info + 0xc) - length) - x;
          length_01 = utf8_char2cells(p,(uchar *)0x0);
          if (length != 0) {
            draw_text(term,local_34,(widget_data->box).y,text,length,0,local_20);
          }
          draw_text(term,length_00 + local_34,(widget_data->box).y,p,x,attr,local_2c);
          if (1 < iVar2) {
            draw_text(term,length_00 + local_34 + length_01,(widget_data->box).y,
                      text + x + 1 + length,iVar2 + -1,0,local_20);
          }
        }
      }
    }
    if ((*(byte *)&term->field_0x38 & 2) == 0) {
      draw_text(term,local_34 + local_24,(widget_data->box).y," ]",2,0,local_20);
    }
    else {
      x = utf8_ptr2cells(widget_data->widget->text,(uchar *)0x0);
      draw_text(term,local_34 + ((int)~*(uint *)(widget_data->widget->info + 4) >> 0x1f) + x,
                (widget_data->box).y," ]",2,0,local_20);
    }
    if (bVar3) {
      set_cursor(term,local_34,(widget_data->box).y,1);
      dlg_data->win->x = (widget_data->box).x;
      dlg_data->win->y = (widget_data->box).y;
    }
  }
  return EVENT_PROCESSED;
}



void add_dlg_button_do(dialog *dlg,uchar *text,int flags,widget_handler_T *handler,void *data,
                      done_handler_T *done,void *done_data)

{
  int iVar1;
  uchar **ppuVar2;
  uchar *puVar3;
  void *pvVar4;
  uchar **ppuVar5;
  
  puVar3 = (uchar *)strlen((char *)text);
  iVar1 = dlg->number_of_widgets + 1;
  ppuVar5 = &dlg->title + dlg->number_of_widgets * 0xc;
  dlg->number_of_widgets = iVar1;
  ppuVar5[0x14] = (uchar *)0x3;
  ppuVar5[10] = text;
  ppuVar2 = &dlg->title + iVar1 * 0xc;
  *(widget_handler_T **)(ppuVar5 + 0xb) = handler;
  ppuVar5[0xc] = data;
  *(int *)(ppuVar2 + 2) = flags;
  *(done_handler_T **)(ppuVar5 + 0x12) = done;
  ppuVar5[0x13] = done_data;
  ppuVar2[3] = (uchar *)0xffffffff;
  ppuVar2[4] = puVar3;
  ppuVar2[5] = puVar3;
  if (1 < (int)puVar3) {
    pvVar4 = memchr(text,0x7e,(size_t)(puVar3 + -1));
    if (pvVar4 != (void *)0x0) {
      ppuVar2[4] = ppuVar2[4] + -1;
      ppuVar2[3] = (uchar *)((int)pvVar4 - (int)text);
    }
  }
  return;
}



void __regparm3 buttons_width(widget_data *widget_data,int n,int *maxwidth,int utf8)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  
  iVar1 = utf8_ptr2cells("[ ",(uchar *)0x0);
  iVar2 = utf8_ptr2cells(" ]",(uchar *)0x0);
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(n < 1);
  if (n < 1) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/button.c";
    errline = 0x60;
    elinks_internal((uchar *)"assertion n > 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (n == 0) {
    iVar4 = -2;
  }
  else {
    n = n + -1;
    iVar4 = -2;
    while( true ) {
      if (utf8 == 0) {
        iVar3 = *(int *)(widget_data->widget->info + 8) + 6;
      }
      else {
        iVar3 = utf8_ptr2cells(widget_data->widget->text,(uchar *)0x0);
        iVar3 = iVar3 + iVar2 + iVar1 + 2;
      }
      iVar4 = iVar4 + iVar3;
      if (n == 0) break;
      n = n + -1;
      widget_data = widget_data + 1;
    }
  }
  if ((maxwidth != (int *)0x0) && (*maxwidth < iVar4)) {
    *maxwidth = iVar4;
  }
  return;
}



void dlg_format_buttons(terminal *term,widget_data *widget_data,int n,int x,int *y,int w,int *rw,
                       format_align align,int format_only)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int n_00;
  widget_data *widget_data_00;
  int local_34;
  int local_20 [4];
  
  if (0 < n) {
    local_34 = 0;
    do {
      iVar6 = local_34 + 1;
      widget_data_00 = widget_data + local_34;
      if (iVar6 < n) {
        n_00 = 2;
        do {
          local_20[0] = 0;
          buttons_width(widget_data_00,n_00,local_20,(uint)(*(byte *)&term->field_0x38 >> 1) & 1);
          if (w < local_20[0]) break;
          iVar6 = iVar6 + 1;
          n_00 = n_00 + 1;
        } while (iVar6 < n);
      }
      local_20[0] = 0;
      buttons_width(widget_data_00,iVar6 - local_34,local_20,
                    (uint)(*(byte *)&term->field_0x38 >> 1) & 1);
      if (rw != (int *)0x0) {
        if (*rw < local_20[0]) {
          *rw = local_20[0];
        }
        else {
          if (w < *rw) {
            *rw = w;
          }
        }
      }
      if (format_only == 0) {
        n_00 = 0;
        if (align == ALIGN_CENTER) {
          n_00 = (w - local_20[0]) / 2;
        }
        iVar1 = utf8_ptr2cells("[ ",(uchar *)0x0);
        iVar2 = utf8_ptr2cells(" ]",(uchar *)0x0);
        if (local_34 < iVar6) {
          n_00 = n_00 + x;
          while( true ) {
            if ((*(byte *)&term->field_0x38 & 2) == 0) {
              iVar5 = *y;
              iVar3 = *(int *)(widget_data_00->widget->info + 8);
              iVar4 = 0;
              if (-1 < n_00) {
                iVar4 = n_00;
              }
              (widget_data_00->box).x = iVar4;
              (widget_data_00->box).height = 1;
              if (iVar5 < 0) {
                iVar5 = 0;
              }
              iVar3 = iVar3 + 4;
              if (iVar3 < 0) {
                iVar3 = 0;
              }
              (widget_data_00->box).y = iVar5;
              (widget_data_00->box).width = iVar3;
            }
            else {
              iVar4 = utf8_ptr2cells(widget_data_00->widget->text,(uchar *)0x0);
              iVar5 = *y;
              iVar3 = 0;
              if (-1 < n_00) {
                iVar3 = n_00;
              }
              (widget_data_00->box).x = iVar3;
              if (iVar5 < 0) {
                iVar5 = 0;
              }
              (widget_data_00->box).y = iVar5;
              iVar4 = iVar4 + iVar2 + iVar1;
              (widget_data_00->box).height = 1;
              iVar3 = 0;
              if (-1 < iVar4) {
                iVar3 = iVar4;
              }
              (widget_data_00->box).width = iVar3;
            }
            if (iVar6 <= local_34 + 1) break;
            local_34 = local_34 + 1;
            widget_data_00 = widget_data_00 + 1;
            n_00 = iVar3 + 2 + n_00;
          }
        }
      }
      *y = *y + 2;
      local_34 = iVar6;
    } while (iVar6 < n);
  }
  return;
}



void add_dlg_radio_do(dialog *dlg,uchar *text,int groupid,int groupnum,int *data)

{
  int iVar1;
  uchar **ppuVar2;
  uchar **ppuVar3;
  
  iVar1 = dlg->number_of_widgets + 1;
  ppuVar3 = &dlg->title + dlg->number_of_widgets * 0xc;
  dlg->number_of_widgets = iVar1;
  ppuVar3[0x14] = (uchar *)0x0;
  ppuVar2 = &dlg->title + iVar1 * 0xc;
  ppuVar3[10] = text;
  ppuVar2[1] = &DAT_00000004;
  *(int **)(ppuVar3 + 0xc) = data;
  *(int *)(ppuVar2 + 2) = groupid;
  *(int *)(ppuVar2 + 3) = groupnum;
  return;
}



widget_handler_status_T init_checkbox(dialog_data *dlg_data,widget_data *widget_data)

{
  int *piVar1;
  
  piVar1 = (int *)widget_data->cdata;
  if ((assert_failed == 0) && (assert_failed = ZEXT14(piVar1 == (int *)0x0), piVar1 == (int *)0x0))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/checkbox.c";
    errline = 0x60;
    elinks_internal((uchar *)"assertion cdata failed!");
  }
  if (*(int *)widget_data->widget->info == 0) {
    if (*piVar1 != 0) goto LAB_0805a77e;
  }
  else {
    if (*piVar1 == *(int *)(widget_data->widget->info + 4)) {
LAB_0805a77e:
      *(undefined4 *)widget_data->info = 1;
      return EVENT_PROCESSED;
    }
  }
  return EVENT_PROCESSED;
}



widget_handler_status_T select_checkbox(dialog_data *dlg_data,widget_data *widget_data)

{
  uint *puVar1;
  uint uVar2;
  undefined4 *puVar3;
  widget *pwVar4;
  int iVar5;
  widget_data *widget_data_00;
  
  if (*(int *)widget_data->widget->info == 0) {
    puVar1 = (uint *)widget_data->cdata;
    if ((assert_failed == 0) &&
       (assert_failed = ZEXT14(puVar1 == (uint *)0x0), puVar1 == (uint *)0x0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/checkbox.c";
      errline = 0x88;
      elinks_internal((uchar *)"assertion cdata failed!");
    }
    uVar2 = *puVar1;
    *puVar1 = (uint)(uVar2 == 0);
    *(uint *)widget_data->info = (uint)(uVar2 == 0);
  }
  else {
    iVar5 = dlg_data->number_of_widgets;
    widget_data_00 = dlg_data->widgets_data;
    if (widget_data_00 != dlg_data->widgets_data + iVar5) {
      do {
        puVar3 = (undefined4 *)widget_data_00->cdata;
        if ((widget_data_00->widget->type == WIDGET_CHECKBOX) &&
           (pwVar4 = widget_data->widget,
           *(int *)widget_data_00->widget->info == *(int *)pwVar4->info)) {
          if (assert_failed == 0) {
            assert_failed = ZEXT14(puVar3 == (undefined4 *)0x0);
            if (puVar3 == (undefined4 *)0x0) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/checkbox.c";
              errline = 0x9a;
              elinks_internal((uchar *)"assertion cdata failed!");
              pwVar4 = widget_data->widget;
            }
            else {
              pwVar4 = widget_data->widget;
            }
          }
          *puVar3 = *(undefined4 *)(pwVar4->info + 4);
          *(undefined4 *)widget_data_00->info = 0;
          display_widget(dlg_data,widget_data_00);
          iVar5 = dlg_data->number_of_widgets;
        }
        widget_data_00 = widget_data_00 + 1;
      } while (dlg_data->widgets_data + iVar5 != widget_data_00);
    }
    *(undefined4 *)widget_data->info = 1;
  }
  display_widget(dlg_data,widget_data);
  return EVENT_PROCESSED;
}



widget_handler_status_T mouse_checkbox(dialog_data *dlg_data,widget_data *widget_data)

{
  terminal *ptVar1;
  term_event *ptVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  widget_handler_T *pwVar6;
  
  ptVar1 = dlg_data->win->term;
  ptVar2 = dlg_data->term_event;
  if ((*(uint *)((int)&ptVar2->info + 8) & 7) < 3) {
    iVar3 = *(int *)((int)&ptVar2->info + 4);
    iVar4 = (widget_data->box).x;
    if ((((iVar4 <= *(int *)&ptVar2->info) && (iVar5 = (widget_data->box).y, iVar5 <= iVar3)) &&
        (*(int *)&ptVar2->info < iVar4 + (widget_data->box).width)) &&
       (iVar3 < (widget_data->box).height + iVar5)) {
      select_widget(dlg_data,widget_data);
      (ptVar1->prev_mouse_event).x = 0;
      (ptVar1->prev_mouse_event).y = 0;
      (ptVar1->prev_mouse_event).button = 0;
      if (((*(byte *)((int)&ptVar2->info + 8) & 0x20) != 0) &&
         (pwVar6 = widget_data->widget->ops->select, pwVar6 != (widget_handler_T *)0x0)) {
        (*pwVar6)(dlg_data,widget_data);
        return EVENT_PROCESSED;
      }
      return EVENT_PROCESSED;
    }
  }
  return EVENT_NOT_PROCESSED;
}



widget_handler_status_T display_checkbox(dialog_data *dlg_data,widget_data *widget_data)

{
  terminal *term;
  color_pair *color;
  uchar *text;
  bool bVar1;
  
  term = dlg_data->win->term;
  bVar1 = dlg_data->widgets_data + dlg_data->selected_widget_id == widget_data;
  if (bVar1) {
    color = get_bfu_color(term,(uchar *)"dialog.checkbox-selected");
  }
  else {
    color = get_bfu_color(term,(uchar *)"dialog.checkbox");
  }
  if (color != (color_pair *)0x0) {
    if (*(int *)widget_data->info == 0) {
      text = "[ ]";
      if (*(int *)widget_data->widget->info != 0) {
        text = "( )";
      }
    }
    else {
      text = "[X]";
      if (*(int *)widget_data->widget->info != 0) {
        text = "(X)";
      }
    }
    draw_text(term,(widget_data->box).x,(widget_data->box).y,text,3,0,color);
    if (bVar1) {
      set_cursor(term,(widget_data->box).x + 1,(widget_data->box).y,1);
      dlg_data->win->x = (widget_data->box).x;
      dlg_data->win->y = (widget_data->box).y;
    }
  }
  return EVENT_PROCESSED;
}



void dlg_format_checkbox(terminal *term,widget_data *widget_data,int x,int *y,int w,int *rw,
                        format_align align,int format_only)

{
  uchar *text;
  int iVar1;
  color_pair *color;
  int iVar2;
  
  text = widget_data->widget->text;
  iVar1 = *y;
  iVar2 = 0;
  if (-1 < x) {
    iVar2 = x;
  }
  (widget_data->box).x = iVar2;
  iVar2 = 0;
  if (-1 < iVar1) {
    iVar2 = iVar1;
  }
  (widget_data->box).y = iVar2;
  (widget_data->box).width = 3;
  (widget_data->box).height = 1;
  if (((4 < w) && (text != (uchar *)0x0)) && (*text != '\0')) {
    if (rw == (int *)0x0) {
      color = get_bfu_color(term,(uchar *)"dialog.checkbox-label");
      dlg_format_text_do(term,text,x + 4,y,w + -4,(int *)0x0,color,align,format_only);
    }
    else {
      *rw = *rw + -4;
      color = get_bfu_color(term,(uchar *)"dialog.checkbox-label");
      dlg_format_text_do(term,text,x + 4,y,w + -4,rw,color,align,format_only);
      *rw = *rw + 4;
    }
  }
  return;
}



void refresh_dialog(dialog_data *dlg_data,dialog_refresh_handler_T *handler,void *data)

{
  dialog_refresh *pdVar1;
  timer_id_T *id;
  
  pdVar1 = dlg_data->dlg->refresh;
  if (pdVar1 == (dialog_refresh *)0x0) {
    pdVar1 = (dialog_refresh *)mem_calloc(1,0xc);
    if (pdVar1 == (dialog_refresh *)0x0) {
      return;
    }
    id = &pdVar1->timer;
    dlg_data->dlg->refresh = pdVar1;
  }
  else {
    id = &pdVar1->timer;
    kill_timer(id);
  }
  pdVar1->handler = handler;
  pdVar1->data = data;
  install_timer(id,100,do_refresh_dialog,dlg_data);
  return;
}



void draw_dialog(dialog_data *dlg_data,int width,int height)

{
  terminal *term;
  int iVar1;
  color_pair *color;
  int *piVar2;
  uchar *name;
  box *box;
  int iVar3;
  int iVar4;
  
  width = width + 0xc;
  term = dlg_data->win->term;
  iVar4 = term->height;
  if (term->width < width) {
    width = term->width;
  }
  iVar1 = height + 4;
  if (iVar4 < height + 4) {
    iVar1 = iVar4;
  }
  iVar3 = (term->width - width) / 2;
  if (iVar3 < 0) {
    iVar3 = 0;
  }
  (dlg_data->box).x = iVar3;
  iVar4 = (iVar4 - iVar1) / 2;
  if (iVar4 < 0) {
    iVar4 = 0;
  }
  if (width < 0) {
    width = 0;
  }
  if (iVar1 < 0) {
    iVar1 = 0;
  }
  (dlg_data->box).width = width;
  (dlg_data->box).y = iVar4;
  (dlg_data->box).height = iVar1;
  box = &dlg_data->box;
  color = get_bfu_color(term,"dialog.generic");
  draw_box(term,box,' ',0,color);
  piVar2 = get_opt_(config_options,name);
  if (*piVar2 == 0) {
    if ((*(byte *)&term->field_0x38 & 2) != 0) {
      fix_dwchar_around_box(term,box,0,0,0);
      return;
    }
  }
  else {
    color = get_bfu_color(term,"dialog.shadow");
    draw_shadow(term,box,color,2,1);
    if ((*(byte *)&term->field_0x38 & 2) != 0) {
      fix_dwchar_around_box(term,box,0,2,1);
    }
  }
  return;
}



void __regparm3
format_widgets(terminal *term,dialog_data *dlg_data,int x,int *y,int w,int h,int *rw,int format_only
              )

{
  widget *pwVar1;
  widget_data *widget_data;
  widget_data *pwVar2;
  int iVar3;
  int n;
  int n_00;
  
  n_00 = dlg_data->number_of_widgets;
  widget_data = dlg_data->widgets_data;
  do {
    if (n_00 < 1) {
      return;
    }
    pwVar1 = widget_data->widget;
    if (WIDGET_TEXT < pwVar1->type) goto LAB_0805ae4c;
    switch(pwVar1->type) {
    case WIDGET_CHECKBOX:
      iVar3 = *(int *)pwVar1->info;
      if ((iVar3 < 1) || ((*(byte *)&dlg_data->dlg->layout & 8) == 0)) {
        dlg_format_checkbox(term,widget_data,x,y,w,rw,ALIGN_LEFT,format_only);
        if (n_00 == 1) {
          *y = *y + 1;
          return;
        }
        pwVar2 = widget_data + 1;
        if (pwVar2->widget->type == WIDGET_CHECKBOX) {
          if (*(int *)pwVar2->widget->info == iVar3) goto LAB_0805b096;
        }
        else {
          if (iVar3 == -1) {
LAB_0805b096:
            n_00 = n_00 + -1;
            iVar3 = *y + -1;
            *y = iVar3;
            break;
          }
        }
LAB_0805ae4c:
        pwVar2 = widget_data + 1;
        iVar3 = *y;
        n_00 = n_00 + -1;
      }
      else {
        n = 1;
        pwVar2 = widget_data;
        do {
          if (((pwVar2[1].widget)->type != WIDGET_CHECKBOX) ||
             (iVar3 != *(int *)(pwVar2[1].widget)->info)) {
            n_00 = n_00 + -1;
            goto LAB_0805afef;
          }
          n = n + 1;
          pwVar2 = pwVar2 + 1;
          n_00 = n_00 + -1;
        } while (n_00 != 0);
        n_00 = -1;
LAB_0805afef:
        dlg_format_group(term,widget_data,n,x,y,w,rw,format_only);
        pwVar2 = (widget_data *)(&widget_data[1].widget + (n * 3 + -3) * 4);
        iVar3 = *y;
      }
      break;
    default:
      n_00 = n_00 + -1;
      pwVar2 = widget_data + 1;
      dlg_format_field(term,widget_data,x,y,w,rw,ALIGN_LEFT,format_only);
      iVar3 = *y;
      break;
    case WIDGET_BUTTON:
      dlg_format_buttons(term,widget_data,n_00,x,y,w,rw,ALIGN_CENTER,format_only);
      return;
    case WIDGET_LISTBOX:
      n_00 = n_00 + -1;
      pwVar2 = widget_data + 1;
      dlg_format_listbox(term,widget_data,x,y,w,h,rw,ALIGN_LEFT,format_only);
      iVar3 = *y;
      break;
    case WIDGET_TEXT:
      n_00 = n_00 + -1;
      pwVar2 = widget_data + 1;
      dlg_format_text(term,widget_data,x,y,w,rw,h,format_only);
      iVar3 = *y;
    }
    *y = iVar3 + 1;
    widget_data = pwVar2;
  } while( true );
}



void generic_dialog_layouter(dialog_data *dlg_data)

{
  byte bVar1;
  terminal *term;
  size_t sVar2;
  int iVar3;
  size_t width;
  int iVar4;
  dialog *pdVar5;
  size_t w;
  int local_30;
  size_t local_24;
  int local_20 [4];
  
  term = dlg_data->win->term;
  width = (term->width * 9) / 10 - 0xc;
  w = 1;
  if (0 < (int)width) {
    sVar2 = term->width - 0xc;
    if (0 < (int)sVar2) {
      w = sVar2;
    }
    if ((int)width <= (int)w) {
      w = width;
    }
  }
  local_30 = 1;
  iVar4 = (term->height * 9) / 10 + -4;
  if (0 < iVar4) {
    iVar3 = term->height + -4;
    local_30 = 1;
    if (0 < iVar3) {
      local_30 = iVar3;
    }
    if (iVar4 <= local_30) {
      local_30 = iVar4;
    }
  }
  if ((*(byte *)&term->field_0x38 & 2) == 0) {
    pdVar5 = dlg_data->dlg;
    local_24 = strlen((char *)pdVar5->title);
    if ((int)w < (int)local_24) {
      local_24 = w;
    }
  }
  else {
    local_24 = utf8_ptr2cells(dlg_data->dlg->title,(uchar *)0x0);
    if ((int)w < (int)local_24) {
      local_24 = w;
    }
    pdVar5 = dlg_data->dlg;
  }
  local_20[0] = -(uint)((*(byte *)&pdVar5->layout & 2) == 0);
  format_widgets(term,dlg_data,0,local_20,w,local_30,(int *)&local_24,1);
  bVar1 = *(byte *)&dlg_data->dlg->layout;
  if ((bVar1 & 4) == 0) {
    width = local_24;
    if ((bVar1 & 1) == 0) goto LAB_0805b1e7;
  }
  else {
    width = dlg_data->dlg->widgets[0].datalen;
    if ((int)width <= (int)local_24) {
      width = local_24;
    }
    local_24 = width;
    width = local_24;
    if ((int)local_24 < (int)w) goto LAB_0805b1e7;
  }
  width = w;
LAB_0805b1e7:
  draw_dialog(dlg_data,width,local_20[0]);
  local_20[0] = (dlg_data->box).y + 2 + ((uint)(*(byte *)&dlg_data->dlg->layout >> 1) & 1);
  format_widgets(term,dlg_data,(dlg_data->box).x + 6,local_20,width,local_30,(int *)0x0,0);
  return;
}



int update_dialog_data(dialog_data *dlg_data)

{
  size_t __n;
  int iVar1;
  widget_data *pwVar2;
  
  iVar1 = dlg_data->number_of_widgets;
  pwVar2 = dlg_data->widgets_data;
  if (pwVar2 != dlg_data->widgets_data + iVar1) {
    do {
      __n = pwVar2->widget->datalen;
      if (__n != 0) {
        memcpy(pwVar2->widget->data,pwVar2->cdata,__n);
        iVar1 = dlg_data->number_of_widgets;
      }
      pwVar2 = pwVar2 + 1;
    } while (dlg_data->widgets_data + iVar1 != pwVar2);
  }
  return 0;
}



widget_handler_status_T cancel_dialog(dialog_data *dlg_data,widget_data *xxx)

{
  delete_window(dlg_data->win);
  return EVENT_PROCESSED;
}



void select_widget(dialog_data *dlg_data,widget_data *widget_data)

{
  int iVar1;
  
  iVar1 = dlg_data->selected_widget_id;
  dlg_data->selected_widget_id =
       ((int)((int)widget_data - (int)dlg_data->widgets_data) >> 4) * -0x55555555;
  display_widget(dlg_data,dlg_data->widgets_data + iVar1);
  display_widget(dlg_data,widget_data);
  return;
}



widget_data * select_widget_by_id(dialog_data *dlg_data,int i)

{
  widget_data *widget_data;
  
  widget_data = (widget_data *)0x0;
  if (dlg_data->number_of_widgets != i && i <= dlg_data->number_of_widgets) {
    widget_data = dlg_data->widgets_data + i;
    select_widget(dlg_data,widget_data);
  }
  return widget_data;
}



void __regparm3 select_dlg_item(dialog_data *dlg_data,widget_data *widget_data)

{
  widget_handler_T *pwVar1;
  
  select_widget(dlg_data,widget_data);
  pwVar1 = widget_data->widget->ops->select;
  if (pwVar1 != (widget_handler_T *)0x0) {
    (*pwVar1)(dlg_data,widget_data);
  }
  return;
}



void __regparm3 cycle_widget_focus(dialog_data *dlg_data,int direction)

{
  int iVar1;
  window *pwVar2;
  window *pwVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  
  iVar1 = dlg_data->selected_widget_id;
  iVar6 = dlg_data->number_of_widgets + -1;
  iVar5 = iVar1;
  do {
    iVar5 = iVar5 + direction;
    dlg_data->selected_widget_id = iVar5;
    if (iVar5 < dlg_data->number_of_widgets) {
      if (iVar5 < 0) {
        dlg_data->selected_widget_id = iVar6;
        iVar5 = iVar6;
      }
    }
    else {
      dlg_data->selected_widget_id = 0;
      iVar5 = 0;
    }
    pwVar2 = (&dlg_data->win + iVar5 * 0xc)[10];
    pwVar3 = pwVar2[1].next;
  } while (((pwVar3 == (window *)0x4) ||
           ((pwVar3 == (window *)0x5 &&
            (((((*(byte *)&pwVar2->xpos & 2) == 0 ||
               (pwVar2 = (&dlg_data->win + iVar5 * 0xc)[0xf], (int)pwVar2 < 1)) ||
              (iVar4 = (&dlg_data->box)[iVar5 * 3 + 3].width, iVar4 < 1)) || (iVar4 <= (int)pwVar2))
            )))) && (iVar1 != iVar5));
  display_widget(dlg_data,dlg_data->widgets_data + iVar1);
  display_widget(dlg_data,dlg_data->widgets_data + dlg_data->selected_widget_id);
  redraw_from_window(dlg_data->win);
  return;
}



void redraw_dialog(dialog_data *dlg_data,int layout)

{
  terminal *term;
  uchar *string;
  window *pwVar1;
  window *pwVar2;
  widget_data *widget_data;
  color_pair *color;
  size_t length;
  size_t sVar3;
  int y;
  int x;
  bool bVar4;
  size_t local_38;
  box box;
  
  term = dlg_data->win->term;
  if (layout != 0) {
    (*dlg_data->dlg->layouter)(dlg_data);
    pwVar1 = (&dlg_data->win + dlg_data->selected_widget_id * 0xc)[10];
    pwVar2 = pwVar1[1].next;
    if ((pwVar2 == (window *)0x4) ||
       ((pwVar2 == (window *)0x5 &&
        (((((*(byte *)&pwVar1->xpos & 2) == 0 ||
           (pwVar1 = (&dlg_data->win + dlg_data->selected_widget_id * 0xc)[0xf], (int)pwVar1 < 1))
          || (y = (&dlg_data->box)[dlg_data->selected_widget_id * 3 + 3].width, y < 1)) ||
         (y <= (int)pwVar1)))))) {
      cycle_widget_focus(dlg_data,1);
    }
  }
  if ((*(byte *)&dlg_data->dlg->layout & 0x10) == 0) {
    box.x = (dlg_data->box).x + 4;
    if (box.x < 0) {
      box.x = 0;
    }
    box.y = (dlg_data->box).y + 2;
    if (box.y < 0) {
      box.y = 0;
    }
    box.width = (dlg_data->box).width + -8;
    if (box.width < 0) {
      box.width = 0;
    }
    y = (dlg_data->box).height + -4;
    box.height = 0;
    if (-1 < y) {
      box.height = y;
    }
    color = get_bfu_color(term,"dialog.frame");
    draw_border(term,&box,color,2);
    if ((assert_failed == 0) &&
       (bVar4 = dlg_data->dlg->title == (uchar *)0x0, assert_failed = ZEXT14(bVar4), bVar4)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/dialog.c";
      errline = 0x5f;
      elinks_internal((uchar *)"assertion dlg_data->dlg->title failed!");
    }
    color = get_bfu_color(term,"dialog.title");
    y = box.width;
    if ((color != (color_pair *)0x0) && (2 < box.width)) {
      string = dlg_data->dlg->title;
      length = strlen((char *)string);
      if ((*(byte *)&term->field_0x38 & 2) == 0) {
        local_38 = y - 2U;
        if ((int)length <= (int)(y - 2U)) {
          local_38 = length;
        }
      }
      else {
        sVar3 = utf8_ptr2cells(string,string + length);
        local_38 = box.width - 2U;
        if ((int)sVar3 <= (int)(box.width - 2U)) {
          local_38 = sVar3;
        }
        y = box.width;
        if ((*(byte *)&term->field_0x38 & 2) != 0) {
          length = utf8_cells2bytes(string,local_38,(uchar *)0x0);
          y = box.width;
        }
      }
      x = (int)(y - local_38) / 2 + box.x;
      y = box.y + -1;
      draw_text(term,x + -1,y," ",1,0,color);
      draw_text(term,x,y,string,length,0,color);
      draw_text(term,x + local_38,y," ",1,0,color);
    }
  }
  widget_data = (widget_data *)
                (&dlg_data->widgets_data[0].widget + (dlg_data->number_of_widgets * 3 + -3) * 4);
  while (widget_data != (widget_data *)(dlg_data[-1].widgets_data[0].info + 0x10)) {
    display_widget(dlg_data,widget_data);
    widget_data = widget_data + -1;
  }
  redraw_from_window(dlg_data->win);
  return;
}



void do_refresh_dialog(dialog_data *dlg_data)

{
  dialog_refresh *pdVar1;
  dlg_refresh_code dVar2;
  
  pdVar1 = dlg_data->dlg->refresh;
  if (assert_failed == 0) {
    if ((pdVar1 == (dialog_refresh *)0x0) || (pdVar1->handler == (dialog_refresh_handler_T *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/dialog.c";
      errline = 0x2ad;
      elinks_internal((uchar *)"assertion refresh && refresh->handler failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  dVar2 = (*pdVar1->handler)(dlg_data,pdVar1->data);
  if ((dVar2 == REFRESH_STOP) || (dVar2 == REFRESH_CANCEL)) {
    pdVar1->timer = (timer_id_T)0x0;
    if (dVar2 == REFRESH_CANCEL) {
      delete_window(dlg_data->win);
      return;
    }
  }
  else {
    if (dVar2 == REFRESH_DIALOG) {
      redraw_dialog(dlg_data,1);
    }
    install_timer(&pdVar1->timer,100,do_refresh_dialog,dlg_data);
  }
  return;
}



widget_handler_status_T clear_dialog(dialog_data *dlg_data,widget_data *xxx)

{
  widget_handler_T *pwVar1;
  int iVar2;
  widget_data *pwVar3;
  
  iVar2 = dlg_data->number_of_widgets;
  pwVar3 = dlg_data->widgets_data;
  if (pwVar3 != dlg_data->widgets_data + iVar2) {
    do {
      pwVar1 = pwVar3->widget->ops->clear;
      if (pwVar1 != (widget_handler_T *)0x0) {
        (*pwVar1)(dlg_data,pwVar3);
        iVar2 = dlg_data->number_of_widgets;
      }
      pwVar3 = pwVar3 + 1;
    } while (dlg_data->widgets_data + iVar2 != pwVar3);
  }
  select_widget_by_id(dlg_data,0);
  redraw_dialog(dlg_data,0);
  return EVENT_PROCESSED;
}



int check_dialog(dialog_data *dlg_data)

{
  widget_handler_T *pwVar1;
  widget_handler_status_T wVar2;
  int iVar3;
  widget_data *widget_data;
  
  iVar3 = dlg_data->number_of_widgets;
  widget_data = dlg_data->widgets_data;
  if (widget_data != dlg_data->widgets_data + iVar3) {
    do {
      if ((widget_data->widget->type < WIDGET_BUTTON) &&
         (pwVar1 = widget_data->widget->handler, pwVar1 != (widget_handler_T *)0x0)) {
        wVar2 = (*pwVar1)(dlg_data,widget_data);
        if (wVar2 == EVENT_NOT_PROCESSED) {
          select_widget(dlg_data,widget_data);
          redraw_dialog(dlg_data,0);
          return 1;
        }
        iVar3 = dlg_data->number_of_widgets;
      }
      widget_data = widget_data + 1;
    } while (dlg_data->widgets_data + iVar3 != widget_data);
  }
  return 0;
}



widget_handler_status_T ok_dialog(dialog_data *dlg_data,widget_data *widget_data)

{
  code *pcVar1;
  undefined4 uVar2;
  int iVar3;
  widget_handler_status_T wVar4;
  
  pcVar1 = *(code **)(widget_data->widget->info + 0x10);
  uVar2 = *(undefined4 *)(widget_data->widget->info + 0x14);
  iVar3 = check_dialog(dlg_data);
  wVar4 = EVENT_NOT_PROCESSED;
  if (iVar3 == 0) {
    update_dialog_data(dlg_data);
    if (pcVar1 != (code *)0x0) {
      (*pcVar1)(uVar2);
    }
    delete_window(dlg_data->win);
    wVar4 = EVENT_PROCESSED;
  }
  return wVar4;
}



dialog_data * do_dialog(terminal *term,dialog *dlg,memory_list *ml)

{
  int iVar1;
  dialog_data *data;
  
  data = (dialog_data *)mem_calloc(1,dlg->number_of_widgets * 0x30 + 0x58);
  if (data == (dialog_data *)0x0) {
    freeml(ml);
  }
  else {
    data->dlg = dlg;
    iVar1 = dlg->number_of_widgets;
    data->ml = ml;
    data->number_of_widgets = iVar1;
    add_window(term,dialog_func,data);
  }
  return data;
}



void dialog_func(window *win,term_event *ev)

{
  byte **ppbVar1;
  int *piVar2;
  dialog_data *dlg_data;
  anon_subr_widget_handler_status_T_dialog_data_ptr_for_handle_event *paVar3;
  widget_handler_T *pwVar4;
  term_event *ev_00;
  widget_ops *pwVar5;
  void *size;
  dialog_refresh *p;
  byte **p_00;
  byte **ppbVar6;
  byte **ppbVar7;
  widget_handler_status_T wVar8;
  action_id_T aVar9;
  unicode_val_T c;
  int codepage;
  uchar *end;
  unicode_val_T c_00;
  widget *pwVar10;
  dialog *pdVar11;
  int iVar12;
  widget_data *widget_data;
  widget_data *pwVar13;
  byte bVar14;
  uchar *local_20 [4];
  
  bVar14 = 0;
  dlg_data = (dialog_data *)win->data;
  dlg_data->win = win;
  dlg_data->term_event = ev;
  paVar3 = dlg_data->dlg->handle_event;
  if (((paVar3 == (anon_subr_widget_handler_status_T_dialog_data_ptr_for_handle_event *)0x0) ||
      (wVar8 = (*paVar3)(dlg_data), wVar8 != EVENT_PROCESSED)) && (ev->ev < 6)) {
    switch(ev->ev) {
    case EVENT_INIT:
      iVar12 = dlg_data->number_of_widgets + -1;
      if (-1 < iVar12) {
        widget_data = dlg_data->widgets_data + iVar12;
        do {
          codepage = 0xc;
          pwVar13 = dlg_data->widgets_data + iVar12;
          while (codepage != 0) {
            codepage = codepage + -1;
            pwVar13->widget = (widget *)0x0;
            pwVar13 = (widget_data *)(&pwVar13->widget + (uint)bVar14 * 0x3ffffffe + 1);
          }
          pdVar11 = dlg_data->dlg;
          pwVar10 = pdVar11->widgets + iVar12;
          widget_data->widget = pwVar10;
          size = (&pdVar11->udata)[(iVar12 + 1) * 0xc];
          if (size == (void *)0x0) {
LAB_0805bd0c:
            pwVar10->ops = widget_type_to_ops[pwVar10->type];
            pwVar10 = widget_data->widget;
            if ((pwVar10->type == WIDGET_FIELD) && (*(int *)(pwVar10->info + 8) != 0)) {
              piVar2 = &(&dlg_data->box)[(iVar12 + 1) * 3].height;
              *(int **)(widget_data->info + 0xc) = piVar2;
              *(int **)(widget_data->info + 8) = piVar2;
              *(int **)(widget_data->info + 0x10) = piVar2;
            }
            pwVar4 = pwVar10->ops->init;
            if (pwVar4 != (widget_handler_T *)0x0) {
              (*pwVar4)(dlg_data,dlg_data->widgets_data + iVar12);
              pwVar10 = widget_data->widget;
            }
            if ((pwVar10->type != WIDGET_LISTBOX) &&
               ((pwVar10->type != WIDGET_TEXT ||
                (((((pwVar10->info[4] & 2) != 0 &&
                   (codepage = (widget_data->box).height, 0 < codepage)) &&
                  (0 < *(int *)(widget_data->info + 4))) &&
                 (codepage < *(int *)(widget_data->info + 4))))))) {
              dlg_data->selected_widget_id = iVar12;
            }
          }
          else {
            end = (uchar *)mem_alloc((size_t)size);
            widget_data->cdata = end;
            if (end != (uchar *)0x0) {
              memcpy(end,widget_data->widget->data,widget_data->widget->datalen);
              pwVar10 = widget_data->widget;
              goto LAB_0805bd0c;
            }
          }
          widget_data = widget_data + -1;
          iVar12 = iVar12 + -1;
        } while (-1 < iVar12);
      }
    default:
      redraw_dialog(dlg_data,1);
      return;
    case EVENT_KBD:
      iVar12 = dlg_data->selected_widget_id;
      widget_data = dlg_data->widgets_data + iVar12;
      ev_00 = dlg_data->term_event;
      pwVar5 = (dlg_data->widgets_data[iVar12].widget)->ops;
      if ((pwVar5->kbd == (widget_handler_T *)0x0) ||
         (wVar8 = (*pwVar5->kbd)(dlg_data,widget_data), wVar8 != EVENT_PROCESSED)) {
        aVar9 = kbd_action(KEYMAP_MENU,ev_00,(int *)0x0);
        switch(aVar9) {
        default:
          c = *(unicode_val_T *)&dlg_data->term_event->info;
          if ((0x20 < (int)c) &&
             ((iVar12 = *(int *)((int)&dlg_data->term_event->info + 4), iVar12 == 4 || (iVar12 == 0)
              ))) {
            widget_data = dlg_data->widgets_data;
            c = unicode_fold_label_case(c);
            codepage = get_terminal_codepage(dlg_data->win->term);
            iVar12 = dlg_data->number_of_widgets;
            if (widget_data != dlg_data->widgets_data + iVar12) {
              do {
                if (widget_data->widget->type == WIDGET_BUTTON) {
                  local_20[0] = widget_data->widget->text;
                  if (*local_20[0] != '\0') {
                    iVar12 = *(int *)(widget_data->widget->info + 4);
                    if (-1 < iVar12) {
                      local_20[0] = local_20[0] + iVar12 + 1;
                    }
                    end = (uchar *)__rawmemchr(local_20[0],0);
                    c_00 = cp_to_unicode(codepage,local_20,end);
                    if (assert_failed == 0) {
                      assert_failed = ZEXT14(c_00 == 0xfffffffd);
                      if (c_00 == 0xfffffffd) {
                        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/dialog.c";
                        errline = 0x149;
                        elinks_internal((uchar *)"assertion hk_char != UCS_NO_CHAR failed!");
                        if (assert_failed != 0) goto LAB_0805bfa8;
                      }
                      c_00 = unicode_fold_label_case(c_00);
                      if (c == c_00) {
LAB_0805bf69:
                        select_dlg_item(dlg_data,widget_data);
                        return;
                      }
                    }
                    else {
LAB_0805bfa8:
                      assert_failed = 0;
                    }
                  }
                  iVar12 = dlg_data->number_of_widgets;
                }
                widget_data = widget_data + 1;
              } while (widget_data != dlg_data->widgets_data + iVar12);
            }
          }
          break;
        case 2:
          widget_data = dlg_data->widgets_data;
          while (widget_data != dlg_data->widgets_data + dlg_data->number_of_widgets) {
            if ((widget_data->widget->type == WIDGET_BUTTON) &&
               ((widget_data->widget->info[0] & 2) != 0)) goto LAB_0805bf69;
            widget_data = widget_data + 1;
          }
          break;
        case 4:
        case 0xb:
        case 0x10:
          cycle_widget_focus(dlg_data,1);
          break;
        case 6:
          if (pwVar5->select == (widget_handler_T *)0x0) {
            if ((((dlg_data->widgets_data[iVar12].widget)->type + ~WIDGET_CHECKBOX < 2) ||
                (iVar12 = *(int *)((int)&ev_00->info + 4), iVar12 == 2)) || (iVar12 == 4)) {
              widget_data = dlg_data->widgets_data;
              while (widget_data != dlg_data->widgets_data + dlg_data->number_of_widgets) {
                if ((widget_data->widget->type == WIDGET_BUTTON) &&
                   ((widget_data->widget->info[0] & 1) != 0)) goto LAB_0805bf69;
                widget_data = widget_data + 1;
              }
            }
          }
          else {
            (*pwVar5->select)(dlg_data,widget_data);
          }
          break;
        case 9:
        case 0xe:
        case 0x14:
          cycle_widget_focus(dlg_data,-1);
          break;
        case 0xf:
          redraw_terminal_cls(dlg_data->win->term);
          break;
        case 0x12:
          if (pwVar5->select != (widget_handler_T *)0x0) {
            (*pwVar5->select)(dlg_data,widget_data);
          }
        }
      }
      break;
    case EVENT_MOUSE:
      widget_data = dlg_data->widgets_data;
      iVar12 = dlg_data->number_of_widgets;
      while (widget_data != dlg_data->widgets_data + iVar12) {
        pwVar4 = widget_data->widget->ops->mouse;
        if (pwVar4 != (widget_handler_T *)0x0) {
          wVar8 = (*pwVar4)(dlg_data,widget_data);
          if (wVar8 == EVENT_PROCESSED) {
            return;
          }
          iVar12 = dlg_data->number_of_widgets;
        }
        widget_data = widget_data + 1;
      }
      break;
    case EVENT_ABORT:
      pdVar11 = dlg_data->dlg;
      p = pdVar11->refresh;
      if (p != (dialog_refresh *)0x0) {
        kill_timer(&p->timer);
        mem_free(p);
        pdVar11 = dlg_data->dlg;
      }
      if (pdVar11->abort != (anon_subr_void_dialog_data_ptr_for_abort *)0x0) {
        (*pdVar11->abort)(dlg_data);
      }
      widget_data = dlg_data->widgets_data;
      if (dlg_data->widgets_data + dlg_data->number_of_widgets != widget_data) {
        do {
          if (widget_data->cdata != (uchar *)0x0) {
            mem_free(widget_data->cdata);
          }
          if ((widget_data->widget->type == WIDGET_FIELD) &&
             (*(int *)(widget_data->widget->info + 8) != 0)) {
            p_00 = *(byte ***)(widget_data->info + 8);
            ppbVar1 = (byte **)(widget_data->info + 8);
            ppbVar6 = p_00;
            while (ppbVar1 != ppbVar6) {
              ppbVar6 = (byte **)*ppbVar6;
            }
            ppbVar6 = *(byte ***)(widget_data->info + 0xc);
            while (ppbVar1 != ppbVar6) {
              ppbVar6 = (byte **)ppbVar6[1];
            }
            ppbVar6 = (byte **)*p_00;
            while (ppbVar7 = ppbVar6, ppbVar1 != p_00) {
              ppbVar7[1] = p_00[1];
              *(byte **)p_00[1] = *p_00;
              mem_free(p_00);
              ppbVar6 = (byte **)*ppbVar7;
              p_00 = ppbVar7;
            }
          }
          widget_data = widget_data + 1;
        } while (widget_data != dlg_data->widgets_data + dlg_data->number_of_widgets);
      }
      freeml(dlg_data->ml);
      return;
    }
  }
  return;
}



void dlg_format_group(terminal *term,widget_data *widget_data,int n,int x,int *y,int w,int *rw,
                     int format_only)

{
  uchar *string;
  color_pair *color;
  widget_type wVar1;
  size_t sVar2;
  size_t sVar3;
  int length;
  int length_00;
  widget *pwVar4;
  int iVar5;
  int lb;
  size_t local_2c;
  uint local_28;
  int local_24;
  int local_20;
  
  color = get_bfu_color(term,"dialog.text");
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(n < 1);
  if (n < 1) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/group.c";
    errline = 0x20;
    elinks_internal((uchar *)"assertion n > 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  local_20 = 0;
  do {
    if (n == 0) {
      *y = *y + 1;
      return;
    }
    pwVar4 = widget_data->widget;
    string = pwVar4->text;
    if ((*(byte *)&term->field_0x38 & 2) == 0) {
      if ((string == (uchar *)0x0) || (*string == '\0')) {
LAB_0805c095:
        local_28 = 0;
        sVar2 = 0;
        goto LAB_0805c09e;
      }
      sVar2 = strlen((char *)string);
      local_28 = (uint)(0 < (int)sVar2);
      wVar1 = pwVar4->type;
      local_24 = 3;
      if (wVar1 != WIDGET_CHECKBOX) goto LAB_0805c0ac;
LAB_0805c108:
      local_2c = 0;
      if ((-1 < (int)sVar2) &&
         (sVar3 = (w - local_24) - local_28, local_2c = sVar2, (int)sVar3 <= (int)sVar2)) {
        local_2c = sVar3;
      }
      length_00 = local_24 + local_28;
      iVar5 = local_2c + length_00 + local_20;
      if (w < iVar5) {
        *y = *y + 2;
        local_20 = 0;
        iVar5 = local_2c + length_00;
      }
      if (format_only == 0) {
        local_20 = local_20 + x;
        wVar1 = widget_data->widget->type;
        if (wVar1 == WIDGET_CHECKBOX) {
          if (local_2c != 0) {
            if ((*(byte *)&term->field_0x38 & 2) == 0) {
              draw_text(term,length_00 + local_20,*y,string,local_2c,0,color);
            }
            else {
              length = utf8_cells2bytes(string,local_2c,(uchar *)0x0);
              draw_text(term,length_00 + local_20,*y,string,length,0,color);
            }
          }
          length_00 = *y;
          length = 0;
          if (-1 < local_20) {
            length = local_20;
          }
          (widget_data->box).x = length;
          if (length_00 < 0) {
            length_00 = 0;
          }
          (widget_data->box).y = length_00;
          length_00 = 0;
          if (-1 < local_24) {
            length_00 = local_24;
          }
          (widget_data->box).height = 1;
          (widget_data->box).width = length_00;
        }
        else {
          if (wVar1 + ~WIDGET_CHECKBOX < 2) {
            if (local_2c != 0) {
              if ((*(byte *)&term->field_0x38 & 2) == 0) {
                draw_text(term,local_20,*y,string,local_2c,0,color);
              }
              else {
                length_00 = utf8_cells2bytes(string,local_2c,(uchar *)0x0);
                draw_text(term,local_20,*y,string,length_00,0,color);
              }
            }
            local_20 = local_2c + local_28 + local_20;
            length_00 = *y;
            if (local_20 < 0) {
              local_20 = 0;
            }
            (widget_data->box).x = local_20;
            length = 0;
            if (-1 < length_00) {
              length = length_00;
            }
            (widget_data->box).y = length;
            length_00 = 0;
            if (-1 < local_24) {
              length_00 = local_24;
            }
            (widget_data->box).height = 1;
            (widget_data->box).width = length_00;
          }
        }
      }
      if (rw != (int *)0x0) {
        if (*rw < iVar5) {
          *rw = iVar5;
        }
        else {
          if (w < *rw) {
            *rw = w;
          }
        }
      }
      local_20 = iVar5 + 1;
    }
    else {
      if ((string == (uchar *)0x0) || (*string == '\0')) goto LAB_0805c095;
      sVar2 = utf8_ptr2cells(string,(uchar *)0x0);
      local_28 = (uint)(0 < (int)sVar2);
      pwVar4 = widget_data->widget;
LAB_0805c09e:
      wVar1 = pwVar4->type;
      local_24 = 3;
      if (wVar1 == WIDGET_CHECKBOX) goto LAB_0805c108;
LAB_0805c0ac:
      if (wVar1 + ~WIDGET_CHECKBOX < 2) {
        if ((*(byte *)&term->field_0x38 & 2) == 0) {
          local_24 = pwVar4->datalen;
        }
        else {
          local_24 = utf8_ptr2cells((uchar *)pwVar4->data,(uchar *)0x0);
        }
        goto LAB_0805c108;
      }
    }
    n = n + -1;
    widget_data = widget_data + 1;
  } while( true );
}



void group_layouter(dialog_data *dlg_data)

{
  terminal *term;
  int n;
  size_t sVar1;
  size_t sVar2;
  size_t w;
  int local_24;
  size_t local_20 [4];
  
  term = dlg_data->win->term;
  sVar2 = (term->width * 9) / 10 - 0xc;
  w = 1;
  if (0 < (int)sVar2) {
    sVar1 = term->width - 0xc;
    if (0 < (int)sVar1) {
      w = sVar1;
    }
    if ((int)sVar2 <= (int)w) {
      w = sVar2;
    }
  }
  local_24 = 0;
  n = dlg_data->number_of_widgets + -2;
  if ((*(byte *)&term->field_0x38 & 2) == 0) {
    local_20[0] = strlen((char *)dlg_data->dlg->title);
    if ((int)w < (int)local_20[0]) {
      local_20[0] = w;
    }
  }
  else {
    local_20[0] = utf8_ptr2cells(dlg_data->dlg->title,(uchar *)0x0);
    if ((int)w < (int)local_20[0]) {
      local_20[0] = w;
    }
  }
  dlg_format_group(term,dlg_data->widgets_data,n,0,&local_24,w,(int *)local_20,1);
  local_24 = local_24 + 1;
  dlg_format_buttons(term,dlg_data->widgets_data + n,2,0,&local_24,w,(int *)local_20,ALIGN_CENTER,1)
  ;
  w = local_20[0];
  draw_dialog(dlg_data,local_20[0],local_24);
  local_24 = (dlg_data->box).y + 3;
  dlg_format_group(term,dlg_data->widgets_data,n,(dlg_data->box).x + 6,&local_24,w,(int *)0x0,0);
  local_24 = local_24 + 1;
  dlg_format_buttons(term,dlg_data->widgets_data + n,2,(dlg_data->box).x + 6,&local_24,w,
                     (int *)local_20,ALIGN_CENTER,0);
  return;
}



void __regparm3 recursively_set_expanded(listbox_item *item,int expanded)

{
  listbox_item *item_00;
  
  if (item->type == BI_FOLDER) {
    item_00 = (listbox_item *)(item->child).next;
    *(byte *)&item->field_0x18 = *(byte *)&item->field_0x18 & 0xfe | (byte)expanded & 1;
    while (item_00 != (listbox_item *)&item->child) {
      recursively_set_expanded(item_00,expanded);
      item_00 = item_00->next;
    }
  }
  return;
}



int scan_for_marks(listbox_item *item,void *info_,int *offset)

{
  if ((*(byte *)&item->field_0x18 & 4) != 0) {
    *(undefined4 *)((int)info_ + 4) = 0;
    *offset = 0;
  }
  return 0;
}



int scan_for_used(listbox_item *item,void *info_,int *offset)

{
  int iVar1;
  
  iVar1 = (**(code **)(*(int *)(*(int *)((int)info_ + 8) + 8) + 8))(item);
  if (iVar1 != 0) {
    *(listbox_item **)((int)info_ + 4) = item;
    *offset = 0;
  }
  return 0;
}



void done_listbox_context(void *context_)

{
  if (*(int *)((int)context_ + 4) != 0) {
                    // WARNING: Could not recover jumptable at 0x0805c70d. Too many branches
                    // WARNING: Treating indirect jump as call
    (**(code **)(*(int *)(*(int *)((int)context_ + 8) + 8) + 4))();
    return;
  }
  return;
}



int scan_for_matches(listbox_item *item,void *info_,int *offset)

{
  int iVar1;
  
  if (**(char **)((int)info_ + 0x10) != '\0') {
    iVar1 = (**(code **)(*(int *)(*(int *)((int)info_ + 8) + 8) + 0x1c))
                      (item,*(undefined4 *)info_,*(char **)((int)info_ + 0x10));
    if (iVar1 != 0) {
      if (iVar1 != 1) {
        return 0;
      }
      *(byte *)&item->field_0x18 = *(byte *)&item->field_0x18 & 0xfd;
      return 0;
    }
    *(listbox_item **)((int)info_ + 4) = item;
  }
  *(byte *)&item->field_0x18 = *(byte *)&item->field_0x18 | 2;
  return 0;
}



int mark_visible(listbox_item *item,void *xxx,int *offset)

{
  *(byte *)&item->field_0x18 = *(byte *)&item->field_0x18 | 2;
  return 0;
}



widget_handler_status_T push_hierbox_search_button(dialog_data *dlg_data,widget_data *button)

{
  terminal *term;
  listbox_data *plVar1;
  bool bVar2;
  
  term = dlg_data->win->term;
  plVar1 = get_listbox_widget_data(dlg_data->widgets_data);
  if (plVar1->sel != (listbox_item *)0x0) {
    if ((assert_failed == 0) &&
       (bVar2 = plVar1->ops->match ==
                (anon_subr_listbox_match_listbox_item_ptr_terminal_ptr_uchar_ptr_for_match *)0x0,
       assert_failed = ZEXT14(bVar2), bVar2)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
      errline = 0x3ce;
      elinks_internal((uchar *)"assertion box->ops->match failed!");
    }
    input_dialog(term,(memory_list *)0x0,"Search","Name",dlg_data,(input_history *)0x0,0x400,"",0,0,
                 (widget_handler_T *)0x0,search_hierbox_browser,(done_handler_T *)0x0);
  }
  return EVENT_PROCESSED;
}



void do_clear_browser(void *context_)

{
  traverse_listbox_items_list
            ((listbox_item *)(*(listbox_data **)((int)context_ + 8))->items->next,
             *(listbox_data **)((int)context_ + 8),0,0,delete_unused,context_);
  return;
}



listbox_context * __regparm3
init_listbox_context
          (listbox_data *box,terminal *term,listbox_item *item,
          anon_subr_int_listbox_item_ptr_void_ptr_int_ptr *scanner)

{
  list_head_elinks *plVar1;
  listbox_context *d;
  bool bVar2;
  
  d = (listbox_context *)mem_calloc(1,0x1c);
  if (d != (listbox_context *)0x0) {
    d->item = item;
    d->term = term;
    d->box = box;
    if (scanner != (anon_subr_int_listbox_item_ptr_void_ptr_int_ptr *)0x0) {
      if ((assert_failed == 0) &&
         (plVar1 = box->items, bVar2 = plVar1 == (list_head_elinks *)plVar1->next,
         assert_failed = ZEXT14(bVar2), bVar2)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
        errline = 0x185;
        elinks_internal((uchar *)"assertion !list_empty(*box->items) failed!");
      }
      traverse_listbox_items_list((listbox_item *)box->items->next,box,0,0,scanner,d);
    }
  }
  return d;
}



void search_hierbox_browser(void *data,uchar *text)

{
  terminal *term;
  listbox_data *box;
  listbox_context *d;
  int *piVar1;
  uchar *text_00;
  
  box = get_listbox_widget_data((widget_data *)((int)data + 0x28));
  term = *(terminal **)(*(int *)data + 0x14);
  d = init_listbox_context
                (box,term,(listbox_item *)0x0,(anon_subr_int_listbox_item_ptr_void_ptr_int_ptr *)0x0
                );
  if (d != (listbox_context *)0x0) {
    *(uchar **)&d->widget_data = text;
    traverse_listbox_items_list((listbox_item *)box->items->next,box,0,0,scan_for_matches,d);
    if ((d->item == (listbox_item *)0x0) && (*text != '\0')) {
      piVar1 = get_opt_(config_options,(uchar *)d);
      if (*piVar1 == 1) {
        beep_terminal(term);
      }
      else {
        if (*piVar1 == 2) {
          text_00 = msg_text(term,(uchar *)"Search string \'%s\' not found",text);
          info_box(term,MSGBOX_FREE_TEXT,"Search",ALIGN_CENTER,text_00);
        }
      }
      traverse_listbox_items_list((listbox_item *)box->items->next,box,0,0,mark_visible,(void *)0x0)
      ;
    }
    mem_free(d);
    return;
  }
  return;
}



widget_handler_status_T push_hierbox_info_button(dialog_data *dlg_data,widget_data *button)

{
  listbox_item *item;
  terminal *term;
  listbox_data *box;
  listbox_context *p;
  uchar *text;
  memory_list *ml;
  bool bVar1;
  
  box = get_listbox_widget_data(dlg_data->widgets_data);
  item = box->sel;
  term = dlg_data->win->term;
  if (item != (listbox_item *)0x0) {
    if ((assert_failed == 0) &&
       (bVar1 = box->ops == (listbox_ops *)0x0, assert_failed = ZEXT14(bVar1), bVar1)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
      errline = 0x1a4;
      elinks_internal((uchar *)"assertion box->ops failed!");
    }
    p = init_listbox_context(box,term,item,(anon_subr_int_listbox_item_ptr_void_ptr_int_ptr *)0x0);
    if (p != (listbox_context *)0x0) {
      text = (*box->ops->get_info)(item,term);
      if (text == (uchar *)0x0) {
        mem_free(p);
        if (item->type == BI_FOLDER) {
          info_box(term,0,"Info",ALIGN_CENTER,(uchar *)"Press space to expand this folder.");
        }
      }
      else {
        (*box->ops->lock)(item);
        ml = getml(p,0);
        msg_box(term,ml,MSGBOX_FREE_TEXT,"Info",ALIGN_LEFT,text,p,1,&DAT_081275e4,
                done_listbox_context,3);
      }
    }
  }
  return EVENT_PROCESSED;
}



void __regparm3
print_delete_error(listbox_item *item,terminal *term,listbox_ops *ops,delete_error err)

{
  uchar *p;
  string *psVar1;
  int cp_index;
  uchar *codeset;
  char *msgid;
  string msg;
  
  if (err == DELETE_IMPOSSIBLE) {
    if (item->type == BI_FOLDER) {
      if ((ops->messages == (listbox_ops_messages *)0x0) ||
         (msgid = (char *)ops->messages->cant_delete_folder, (uchar *)msgid == (uchar *)0x0)) {
        msgid = "Sorry, but the folder \"%s\" cannot be deleted.";
      }
    }
    else {
      if ((ops->messages == (listbox_ops_messages *)0x0) ||
         (msgid = (char *)ops->messages->cant_delete_item, (uchar *)msgid == (uchar *)0x0)) {
        msgid = "Sorry, but the item \"%s\" cannot be deleted.";
      }
    }
  }
  else {
    if (err != DELETE_LOCKED) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
      errline = 0x26b;
      elinks_internal((uchar *)"Bad delete error code (%d)!",err);
      return;
    }
    if (item->type == BI_FOLDER) {
      if ((ops->messages == (listbox_ops_messages *)0x0) ||
         (msgid = (char *)ops->messages->cant_delete_used_folder, (uchar *)msgid == (uchar *)0x0)) {
        msgid = "Sorry, but the folder \"%s\" is being used by something else.";
      }
    }
    else {
      if ((ops->messages == (listbox_ops_messages *)0x0) ||
         (msgid = (char *)ops->messages->cant_delete_used_item, (uchar *)msgid == (uchar *)0x0)) {
        msgid = "Sorry, but the item \"%s\" is being used by something else.";
      }
    }
  }
  p = (*ops->get_text)(item,term);
  if (p != (uchar *)0x0) {
    psVar1 = init_string(&msg);
    if (psVar1 == (string *)0x0) {
      mem_free(p);
    }
    else {
      if (((uchar *)msgid != (uchar *)0x0) && (*msgid != '\0')) {
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        msgid = (char *)gettext((uchar *)msgid);
      }
      add_format_to_string(&msg,(uchar *)msgid,p);
      mem_free(p);
      if ((item->type == BI_LEAF) && (p = (*ops->get_info)(item,term), p != (uchar *)0x0)) {
        add_format_to_string(&msg,"\n\n%s",p);
        mem_free(p);
      }
      info_box(term,MSGBOX_FREE_TEXT,(uchar *)"Delete error",ALIGN_LEFT,msg.source);
    }
  }
  return;
}



widget_handler_status_T push_hierbox_clear_button(dialog_data *dlg_data,widget_data *button)

{
  terminal *term;
  listbox_ops *ops;
  listbox_ops_messages *plVar1;
  listbox_data *box;
  listbox_context *p;
  memory_list *ml;
  char *title;
  char *text;
  
  box = get_listbox_widget_data(dlg_data->widgets_data);
  term = dlg_data->win->term;
  ops = box->ops;
  if (box->sel == (listbox_item *)0x0) {
    return EVENT_PROCESSED;
  }
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(ops == (listbox_ops *)0x0), ops == (listbox_ops *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
    errline = 0x359;
    elinks_internal((uchar *)"assertion ops failed!");
  }
  p = init_listbox_context(box,term,(listbox_item *)0x0,scan_for_used);
  if (p == (listbox_context *)0x0) {
    return EVENT_PROCESSED;
  }
  if (p->item != (listbox_item *)0x0) {
    print_delete_error(p->item,term,ops,DELETE_LOCKED);
    mem_free(p);
    return EVENT_PROCESSED;
  }
  plVar1 = ops->messages;
  if (plVar1 == (listbox_ops_messages *)0x0) {
    text = "Do you really want to remove all items?";
  }
  else {
    text = (char *)plVar1->clear_all_items;
    title = (char *)plVar1->clear_all_items_title;
    if ((uchar *)text == (uchar *)0x0) {
      text = "Do you really want to remove all items?";
    }
    if ((uchar *)title != (uchar *)0x0) goto LAB_0805cf42;
  }
  title = "Clear all items";
LAB_0805cf42:
  ml = getml(p,0);
  msg_box(term,ml,0,(uchar *)title,ALIGN_CENTER,(uchar *)text,p,2,&DAT_0812762b,do_clear_browser,1,
          &DAT_08127627,0,2);
  return EVENT_PROCESSED;
}



void __regparm3 do_delete_item(listbox_item *item,listbox_context *info,int last)

{
  listbox_ops *ops;
  int iVar1;
  
  ops = info->box->ops;
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(item == (listbox_item *)0x0), item == (listbox_item *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
    errline = 0x28c;
    elinks_internal((uchar *)"assertion item failed!");
  }
  iVar1 = (*ops->can_delete)(item);
  if (iVar1 == 0) {
    print_delete_error(item,info->term,ops,DELETE_IMPOSSIBLE);
  }
  else {
    iVar1 = (*ops->is_used)(item);
    if (iVar1 == 0) {
      (*ops->delete)(item,last);
    }
    else {
      print_delete_error(item,info->term,ops,DELETE_LOCKED);
    }
  }
  return;
}



int delete_unused(listbox_item *item,void *data_,int *offset)

{
  int iVar1;
  
  iVar1 = (**(code **)(*(int *)(*(int *)((int)data_ + 8) + 8) + 8))(item);
  if (iVar1 == 0) {
    do_delete_item(item,(listbox_context *)data_,0);
  }
  return (uint)(iVar1 == 0);
}



int delete_marked(listbox_item *item,void *data_,int *offset)

{
  int iVar1;
  
  if (((*(byte *)&item->field_0x18 & 4) != 0) &&
     (iVar1 = (**(code **)(*(int *)(*(int *)((int)data_ + 8) + 8) + 8))(item), iVar1 == 0)) {
    if (*(int *)((int)data_ + 4) == 0) {
      *(listbox_item **)((int)data_ + 4) = item;
      return 1;
    }
    do_delete_item(item,(listbox_context *)data_,0);
    return 1;
  }
  return 0;
}



widget_handler_status_T __regparm3 query_delete_selected_item(void *context_)

{
  terminal *term;
  listbox_data *box;
  listbox_ops *ops;
  listbox_item *item;
  int iVar1;
  int iVar2;
  listbox_context *p;
  uchar *p_00;
  uchar *p_01;
  uchar *text;
  memory_list *ml;
  char *format;
  
  term = *(terminal **)context_;
  box = *(listbox_data **)((int)context_ + 8);
  ops = box->ops;
  item = box->sel;
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(item == (listbox_item *)0x0), item == (listbox_item *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
    errline = 0x2d8;
    elinks_internal((uchar *)"assertion item failed!");
  }
  iVar1 = (*ops->can_delete)(item);
  if ((iVar1 == 0) || (iVar2 = (*ops->is_used)(item), iVar2 != 0)) {
    print_delete_error(item,term,ops,(uint)(iVar1 != 0));
    return EVENT_PROCESSED;
  }
  p = init_listbox_context(box,term,item,(anon_subr_int_listbox_item_ptr_void_ptr_int_ptr *)0x0);
  if (p == (listbox_context *)0x0) {
    return EVENT_PROCESSED;
  }
  p->widget_data = *(widget_data **)((int)context_ + 0x10);
  p_00 = (*ops->get_text)(item,term);
  if (p_00 == (uchar *)0x0) {
    mem_free(p);
    return EVENT_PROCESSED;
  }
  if (item->type == BI_FOLDER) {
    (*ops->lock)(item);
    if ((ops->messages == (listbox_ops_messages *)0x0) ||
       (format = (char *)ops->messages->delete_folder, (uchar *)format == (uchar *)0x0)) {
      format = "Delete the folder \"%s\" and its content?";
    }
    text = msg_text(term,(uchar *)format,p_00);
    if ((ops->messages == (listbox_ops_messages *)0x0) ||
       (format = (char *)ops->messages->delete_folder_title, (uchar *)format == (uchar *)0x0)) {
      format = "Delete folder";
    }
    ml = getml(p,0);
    msg_box(term,ml,MSGBOX_FREE_TEXT,(uchar *)format,ALIGN_CENTER,text,p,2,&DAT_0812762b,
            push_ok_delete_button,1,&DAT_08127627,done_listbox_context,2);
  }
  else {
    p_01 = (*ops->get_info)(item,term);
    (*ops->lock)(item);
    text = "";
    if (p_01 != (uchar *)0x0) {
      text = p_01;
    }
    if ((ops->messages == (listbox_ops_messages *)0x0) ||
       (format = (char *)ops->messages->delete_item, (uchar *)format == (uchar *)0x0)) {
      format = "Delete \"%s\"?\n\n%s";
    }
    text = msg_text(term,(uchar *)format,p_00,text);
    if ((ops->messages == (listbox_ops_messages *)0x0) ||
       (format = (char *)ops->messages->delete_item_title, (uchar *)format == (uchar *)0x0)) {
      format = "Delete item";
    }
    ml = getml(p,0);
    msg_box(term,ml,MSGBOX_FREE_TEXT,(uchar *)format,ALIGN_LEFT,text,p,2,&DAT_0812762b,
            push_ok_delete_button,1,&DAT_08127627,done_listbox_context,2);
    if (p_01 != (uchar *)0x0) {
      mem_free(p_01);
    }
  }
  mem_free(p_00);
  return EVENT_PROCESSED;
}



widget_handler_status_T push_hierbox_delete_button(dialog_data *dlg_data,widget_data *button)

{
  terminal *term;
  listbox_item *item;
  listbox_ops *plVar1;
  listbox_ops_messages *plVar2;
  listbox_data *box;
  listbox_context *p;
  widget_handler_status_T wVar3;
  memory_list *ml;
  char *text;
  char *title;
  
  term = dlg_data->win->term;
  box = get_listbox_widget_data(dlg_data->widgets_data);
  item = box->sel;
  plVar1 = box->ops;
  if (item == (listbox_item *)0x0) {
    return EVENT_PROCESSED;
  }
  if (assert_failed == 0) {
    if (((plVar1 == (listbox_ops *)0x0) ||
        (plVar1->can_delete == (anon_subr_int_listbox_item_ptr_for_can_delete *)0x0)) ||
       (plVar1->delete == (anon_subr_void_listbox_item_ptr_int_for_delete *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
      errline = 0x31a;
      elinks_internal((uchar *)"assertion ops && ops->can_delete && ops->delete failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  p = init_listbox_context(box,term,item,scan_for_marks);
  if (p == (listbox_context *)0x0) {
    return EVENT_PROCESSED;
  }
  p->widget_data = dlg_data->widgets_data;
  if (p->item != (listbox_item *)0x0) {
    wVar3 = query_delete_selected_item(p);
    mem_free(p);
    return wVar3;
  }
  plVar2 = plVar1->messages;
  if (plVar2 == (listbox_ops_messages *)0x0) {
    text = "Delete marked items?";
  }
  else {
    text = (char *)plVar2->delete_marked_items;
    title = (char *)plVar2->delete_marked_items_title;
    if ((uchar *)text == (uchar *)0x0) {
      text = "Delete marked items?";
    }
    if ((uchar *)title != (uchar *)0x0) goto LAB_0805d522;
  }
  title = "Delete marked items";
LAB_0805d522:
  ml = getml(p,0);
  msg_box(term,ml,0,(uchar *)title,ALIGN_CENTER,(uchar *)text,p,2,&DAT_0812762b,
          push_ok_delete_button,1,&DAT_08127627,dont_delete_marked_items,2);
  return EVENT_PROCESSED;
}



void dont_delete_marked_items(void *context_)

{
  query_delete_selected_item(context_);
  return;
}



void push_ok_delete_button(void *context_)

{
  listbox_item *item;
  listbox_item *plVar1;
  int iVar2;
  
  if (*(int *)((int)context_ + 4) == 0) {
    traverse_listbox_items_list
              ((listbox_item *)(*(listbox_data **)((int)context_ + 8))->items->next,
               *(listbox_data **)((int)context_ + 8),0,0,delete_marked,context_);
    if (*(int *)((int)context_ + 4) == 0) {
      return;
    }
    iVar2 = (**(code **)(*(int *)(*(int *)((int)context_ + 8) + 8) + 0x18))
                      (*(int *)((int)context_ + 4));
  }
  else {
    (**(code **)(*(int *)(*(int *)((int)context_ + 8) + 8) + 4))(*(int *)((int)context_ + 4));
    iVar2 = (**(code **)(*(int *)(*(int *)((int)context_ + 8) + 8) + 0x18))
                      (*(undefined4 *)((int)context_ + 4));
  }
  if (iVar2 != 0) {
    item = *(listbox_item **)((int)context_ + 4);
    plVar1 = *(listbox_item **)(iVar2 + 0xc);
    do_delete_item(item,(listbox_context *)context_,1);
    if (item == plVar1) {
      listbox_sel_move(*(widget_data **)((int)context_ + 0x10),-1);
    }
    return;
  }
  do_delete_item(*(listbox_item **)((int)context_ + 4),(listbox_context *)context_,1);
  return;
}



void __regparm3 recursively_goto_listbox(session *ses,listbox_item *item,listbox_data *box)

{
  listbox_item *item_00;
  uri *uri;
  
  if (item->type == BI_FOLDER) {
    item_00 = (listbox_item *)(item->child).next;
    while (item_00 != (listbox_item *)&item->child) {
      recursively_goto_listbox(ses,item_00,box);
      item_00 = item_00->next;
    }
  }
  else {
    if ((item->type == BI_LEAF) && (uri = (*box->ops->get_uri)(item), uri != (uri *)0x0)) {
      open_uri_in_new_tab(ses,uri,1,0);
      done_uri(uri);
    }
  }
  return;
}



widget_handler_status_T push_hierbox_goto_button(dialog_data *dlg_data,widget_data *button)

{
  listbox_item *item;
  session *ses;
  listbox_item *item_00;
  listbox_data *box;
  listbox_context *d;
  uri *uri;
  
  box = get_listbox_widget_data(dlg_data->widgets_data);
  item = box->sel;
  ses = (session *)dlg_data->dlg->udata;
  if ((item != (listbox_item *)0x0) &&
     (d = init_listbox_context(box,dlg_data->win->term,item,scan_for_marks),
     d != (listbox_context *)0x0)) {
    if (d->item == (listbox_item *)0x0) {
      d->dlg_data = dlg_data;
      traverse_listbox_items_list((listbox_item *)d->box->items->next,d->box,0,0,goto_marked,d);
    }
    else {
      if (item->type == BI_FOLDER) {
        item_00 = (listbox_item *)(item->child).next;
        while (item_00 != (listbox_item *)&item->child) {
          recursively_goto_listbox(ses,item_00,box);
          item_00 = item_00->next;
        }
      }
      else {
        if (item->type != BI_LEAF) {
          mem_free(d);
          return EVENT_PROCESSED;
        }
        uri = (*box->ops->get_uri)(item);
        if (uri != (uri *)0x0) {
          goto_uri(ses,uri);
          done_uri(uri);
        }
      }
    }
    mem_free(d);
    delete_window(dlg_data->win);
  }
  return EVENT_PROCESSED;
}



int goto_marked(listbox_item *item,void *data_,int *offset)

{
  if ((*(byte *)&item->field_0x18 & 4) != 0) {
    recursively_goto_listbox
              (*(session **)(*(int *)(*(int *)((int)data_ + 0xc) + 4) + 4),item,
               *(listbox_data **)((int)data_ + 8));
  }
  return 0;
}



widget_handler_status_T hierbox_dialog_event_handler(dialog_data *dlg_data)

{
  widget_data *widget_data;
  term_event *ev;
  term_event_type tVar1;
  void *pvVar2;
  int iVar3;
  undefined4 *puVar4;
  widget_handler_T *pwVar5;
  int **p;
  code *pcVar6;
  int *piVar7;
  widget_handler_status_T wVar8;
  uint uVar9;
  listbox_data *plVar10;
  listbox_item *item;
  
  ev = dlg_data->term_event;
  tVar1 = ev->ev;
  if (tVar1 == EVENT_KBD) {
    widget_data = dlg_data->widgets_data;
    pvVar2 = dlg_data->dlg->udata2;
    pwVar5 = (dlg_data->widgets_data[0].widget)->ops->kbd;
    if ((pwVar5 != (widget_handler_T *)0x0) &&
       (wVar8 = (*pwVar5)(dlg_data,widget_data), wVar8 == EVENT_PROCESSED)) {
      return EVENT_PROCESSED;
    }
    plVar10 = get_listbox_widget_data(widget_data);
    item = plVar10->sel;
    uVar9 = kbd_action(KEYMAP_MENU,ev,(int *)0x0);
    if (uVar9 == 0x11) {
      if (plVar10->ops->match !=
          (anon_subr_listbox_match_listbox_item_ptr_terminal_ptr_uchar_ptr_for_match *)0x0) {
        push_hierbox_search_button(dlg_data,(widget_data *)0x0);
        return EVENT_PROCESSED;
      }
    }
    else {
      if (uVar9 < 0x12) {
        if (uVar9 == 7) {
          if (item == (listbox_item *)0x0) {
            return EVENT_PROCESSED;
          }
          if (item->type != BI_FOLDER) {
            return EVENT_PROCESSED;
          }
          recursively_set_expanded(item,1);
          goto LAB_0805db02;
        }
      }
      else {
        if (uVar9 == 0x12) {
          if (item == (listbox_item *)0x0) {
            return EVENT_PROCESSED;
          }
          if (item->type == BI_FOLDER) {
            *(byte *)&item->field_0x18 =
                 *(byte *)&item->field_0x18 & 0xfe | (*(byte *)&item->field_0x18 ^ 1) & 1;
            goto LAB_0805db02;
          }
        }
        else {
          if (uVar9 == 0x13) {
            if (item == (listbox_item *)0x0) {
              return EVENT_PROCESSED;
            }
            if (((list_head_elinks *)(item->child).next == &item->child) ||
               ((*(byte *)&item->field_0x18 & 1) == 0)) {
              item = (*plVar10->ops->get_root)(item);
              if (item != (listbox_item *)0x0) {
                listbox_sel(widget_data,item);
              }
            }
            else {
              if (item->type == BI_FOLDER) {
                recursively_set_expanded(item,0);
              }
            }
LAB_0805db02:
            pcVar6 = *(code **)((int)pvVar2 + 4);
            if (pcVar6 != (code *)0x0) {
              (*pcVar6)();
            }
            display_widget(dlg_data,widget_data);
            return EVENT_PROCESSED;
          }
        }
      }
    }
  }
  else {
    if (tVar1 == EVENT_INIT) {
      pvVar2 = dlg_data->dlg->udata2;
      piVar7 = (int *)mem_alloc(0xc);
      if (piVar7 != (int *)0x0) {
        *(dialog_data **)(piVar7 + 2) = dlg_data;
        iVar3 = *(int *)((int)pvVar2 + 0x18);
        piVar7[1] = (int)pvVar2 + 0x18;
        *piVar7 = iVar3;
        *(int **)((int)pvVar2 + 0x18) = piVar7;
        *(int **)(*piVar7 + 4) = piVar7;
      }
      puVar4 = *(undefined4 **)((int)pvVar2 + 0x28);
      while (puVar4 != (undefined4 *)((int)pvVar2 + 0x28)) {
        *(byte *)(puVar4 + 6) = *(byte *)(puVar4 + 6) | 2;
        puVar4 = (undefined4 *)*puVar4;
      }
    }
    else {
      if (tVar1 == EVENT_ABORT) {
        plVar10 = get_listbox_widget_data(dlg_data->widgets_data);
        pvVar2 = dlg_data->dlg->udata2;
        if ((*(byte *)((int)pvVar2 + 0x60) & 1) == 0) {
          *(listbox_data **)((int)pvVar2 + 0x44) = plVar10->next;
          *(listbox_data **)((int)pvVar2 + 0x48) = plVar10->prev;
          *(listbox_ops **)((int)pvVar2 + 0x4c) = plVar10->ops;
          *(listbox_item **)((int)pvVar2 + 0x50) = plVar10->sel;
          *(listbox_item **)((int)pvVar2 + 0x54) = plVar10->top;
          *(int *)((int)pvVar2 + 0x58) = plVar10->sel_offset;
          *(list_head_elinks **)((int)pvVar2 + 0x5c) = plVar10->items;
        }
        plVar10->next->prev = plVar10->prev;
        plVar10->prev->next = plVar10->next;
        p = *(int ***)((int)pvVar2 + 0x18);
        while (p != (int **)((int)pvVar2 + 0x18)) {
          if (dlg_data == (dialog_data *)p[2]) {
            *(int **)(*p + 1) = p[1];
            *(int **)p[1] = *p;
            mem_free(p);
            return EVENT_NOT_PROCESSED;
          }
          p = (int **)*p;
        }
      }
    }
  }
  return EVENT_NOT_PROCESSED;
}



// WARNING: Type propagation algorithm not settling

void update_hierbox_browser(hierbox_browser *browser)

{
  list_head_elinks *plVar1;
  
  plVar1 = (list_head_elinks *)(browser->dialogs).next;
  while (plVar1 != &browser->dialogs) {
    redraw_from_window(((window *)plVar1[1].next)->next->next);
    plVar1 = (list_head_elinks *)plVar1->next;
  }
  return;
}



// WARNING: Type propagation algorithm not settling

listbox_item *
add_listbox_item(hierbox_browser *browser,listbox_item *root,listbox_item_type type,void *data,
                int add_position)

{
  listbox_item *plVar1;
  listbox_item *plVar2;
  
  if (root == (listbox_item *)0x0) {
    if ((assert_failed == 0) &&
       (assert_failed = ZEXT14(browser == (hierbox_browser *)0x0), browser == (hierbox_browser *)0x0
       )) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
      errline = 0x2e;
      elinks_internal((uchar *)"assertion browser != NULL failed: Nowhere to add new list box item")
      ;
    }
    root = &browser->root;
  }
  plVar2 = (listbox_item *)mem_calloc(1,0x20);
  if (plVar2 != (listbox_item *)0x0) {
    *(byte *)&plVar2->field_0x18 = *(byte *)&plVar2->field_0x18 | 2;
    *(list_head_elinks **)&(plVar2->child).prev = &plVar2->child;
    *(list_head_elinks **)&(plVar2->child).next = &plVar2->child;
    plVar2->udata = data;
    plVar2->type = type;
    plVar2->depth = root->depth + 1;
    if (add_position < 0) {
      plVar2->next = *(listbox_item **)(root->child).prev;
      plVar2->prev = (listbox_item *)(root->child).prev;
      ((listbox_item *)(root->child).prev)->next = plVar2;
      plVar2->next->prev = plVar2;
    }
    else {
      plVar1 = (listbox_item *)(root->child).next;
      plVar2->prev = (listbox_item *)&root->child;
      plVar2->next = plVar1;
      *(listbox_item **)&(root->child).next = plVar2;
      plVar2->next->prev = plVar2;
    }
    if (browser != (hierbox_browser *)0x0) {
      update_hierbox_browser(browser);
    }
  }
  return plVar2;
}



void done_listbox_item(hierbox_browser *browser,listbox_item *item)

{
  listbox_item *plVar1;
  listbox_data *box;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if ((item == (listbox_item *)0x0) || ((list_head_elinks *)(item->child).next != &item->child)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
    errline = 0x5c;
    elinks_internal((uchar *)"assertion item && list_empty(item->child) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  plVar1 = item->next;
  if (plVar1 != (listbox_item *)0x0) {
    box = (listbox_data *)(browser->boxes).next;
    if (box != (listbox_data *)&browser->boxes) {
      do {
        if (box->sel == item) {
          plVar1 = traverse_listbox_items_list
                             (item,box,1,1,(anon_subr_int_listbox_item_ptr_void_ptr_int_ptr *)0x0,
                              (void *)0x0);
          if ((item == plVar1) &&
             (plVar1 = traverse_listbox_items_list
                                 (item,box,-1,1,
                                  (anon_subr_int_listbox_item_ptr_void_ptr_int_ptr *)0x0,(void *)0x0
                                 ), item == plVar1)) {
            plVar1 = (listbox_item *)0x0;
          }
          box->sel = plVar1;
        }
        if (box->top == item) {
          plVar1 = traverse_listbox_items_list
                             (item,box,1,1,(anon_subr_int_listbox_item_ptr_void_ptr_int_ptr *)0x0,
                              (void *)0x0);
          if ((item == plVar1) &&
             (plVar1 = traverse_listbox_items_list
                                 (item,box,-1,1,
                                  (anon_subr_int_listbox_item_ptr_void_ptr_int_ptr *)0x0,(void *)0x0
                                 ), item == plVar1)) {
            plVar1 = (listbox_item *)0x0;
          }
          box->top = plVar1;
        }
        box = box->next;
      } while (box != (listbox_data *)&browser->boxes);
      plVar1 = item->next;
    }
    plVar1->prev = item->prev;
    item->prev->next = item->next;
    update_hierbox_browser(browser);
  }
  mem_free(item);
  return;
}



dialog_data * hierbox_browser(hierbox_browser *browser,session *ses)

{
  terminal *term;
  size_t sVar1;
  widget_handler_T *handler;
  int *piVar2;
  dialog *dlg;
  dialog_data *pdVar3;
  int cp_index;
  uchar *codeset;
  uchar *msgid;
  hierbox_browser_button *phVar4;
  int cp_index_00;
  memory_list *ml;
  uint uVar5;
  bool bVar6;
  int local_24;
  
  term = ses->tab->term;
  sVar1 = browser->buttons_size;
  piVar2 = get_opt_(cmdline_options,(uchar *)ses);
  local_24 = *piVar2;
  if (assert_failed == 0) {
    assert_failed = 0;
  }
  cp_index_00 = sVar1 * 3 + 3;
  dlg = (dialog *)mem_calloc(1,cp_index_00 * 0x10 + 0x70);
  pdVar3 = (dialog_data *)0x0;
  if (dlg != (dialog *)0x0) {
    msgid = browser->title;
    if ((msgid != (uchar *)0x0) && (*msgid != '\0')) {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      msgid = gettext(msgid);
    }
    *(byte *)&dlg->layout = *(byte *)&dlg->layout | 3;
    dlg->title = msgid;
    dlg->layouter = generic_dialog_layouter;
    dlg->handle_event = hierbox_dialog_event_handler;
    *(hierbox_browser **)&dlg->udata2 = browser;
    *(session **)&dlg->udata = ses;
    uVar5 = 0;
    add_dlg_listbox(dlg,&dlg[1].title + cp_index_00 * 4);
    if (browser->buttons_size != 0) {
      do {
        while ((phVar4 = browser->buttons + uVar5, local_24 == 0 ||
               ((*(byte *)&phVar4->field_0x8 & 1) != 0))) {
          handler = phVar4->handler;
          msgid = phVar4->label;
          if ((msgid != (uchar *)0x0) && (*msgid != '\0')) {
            if ((term != (terminal *)0x0) &&
               (cp_index_00 = get_terminal_codepage(term), cp_index_00 != current_charset)) {
              codeset = get_cp_mime_name(cp_index_00);
              bind_textdomain_codeset("elinks",codeset);
              current_charset = cp_index_00;
            }
            msgid = gettext(msgid);
          }
          uVar5 = uVar5 + 1;
          add_dlg_button_do(dlg,msgid,1,handler,(void *)0x0,(done_handler_T *)0x0,(void *)0x0);
          if (browser->buttons_size < uVar5 || browser->buttons_size == uVar5) goto LAB_0805e08d;
        }
        local_24 = local_24 + 1;
        uVar5 = uVar5 + 1;
      } while (uVar5 <= browser->buttons_size && browser->buttons_size != uVar5);
    }
LAB_0805e08d:
    if ((term != (terminal *)0x0) &&
       (cp_index_00 = get_terminal_codepage(term), cp_index_00 != current_charset)) {
      msgid = get_cp_mime_name(cp_index_00);
      bind_textdomain_codeset("elinks",msgid);
      current_charset = cp_index_00;
    }
    msgid = gettext((uchar *)"Close");
    add_dlg_button_do(dlg,msgid,2,cancel_dialog,(void *)0x0,(done_handler_T *)0x0,(void *)0x0);
    if (assert_failed == 0) {
      cp_index_00 = 0;
      if (local_24 != 0) {
        cp_index_00 = local_24 + -1;
      }
      bVar6 = (uVar5 + 2) - cp_index_00 != dlg->number_of_widgets;
      assert_failed = ZEXT14(bVar6);
      if (bVar6) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
        errline = 0x150;
        elinks_internal((uchar *)
                        "assertion button + 2 - (anonymous ? anonymous - 1 : 0) == (dlg)->number_of_widgets failed!"
                       );
      }
    }
    ml = getml(dlg,0);
    pdVar3 = do_dialog(term,dlg,ml);
  }
  return pdVar3;
}



void clear_hotkeys_cache(menu *menu)

{
  uchar *puVar1;
  int iVar2;
  menu_item *pmVar3;
  
  pmVar3 = menu->items;
  puVar1 = pmVar3->text;
  while (puVar1 != (uchar *)0x0) {
    iVar2 = menu->hotkeys;
    pmVar3->hotkey_pos = 0;
    pmVar3->hotkey_state = (uint)(iVar2 == 0);
    pmVar3 = pmVar3 + 1;
    puVar1 = pmVar3->text;
  }
  return;
}



void init_hotkeys(terminal *term,menu *menu)

{
  char *pcVar1;
  int cp_index;
  uchar *codeset;
  uchar *msgid;
  menu_item *pmVar2;
  
  pmVar2 = menu->items;
  msgid = pmVar2->text;
  do {
    while( true ) {
      if (msgid == (uchar *)0x0) {
        return;
      }
      if (menu->hotkeys == 0) break;
      if (((pmVar2->hotkey_state == HKS_CACHED) || (pmVar2->hotkey_pos != 0)) || (*msgid == '\0'))
      goto LAB_0805e206;
      if ((*(byte *)&pmVar2->flags & 0x40) == 0) {
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        msgid = gettext(msgid);
        if (*msgid == '\0') goto LAB_0805e206;
      }
      pcVar1 = strchr((char *)msgid,0x7e);
      if (pcVar1 == (char *)0x0) {
        pmVar2->hotkey_pos = 0;
        goto LAB_0805e206;
      }
      *(char **)&pmVar2->hotkey_pos = pcVar1 + (1 - (int)msgid);
      if (pcVar1 + (1 - (int)msgid) == (char *)0x0) goto LAB_0805e206;
      pmVar2->hotkey_state = HKS_CACHED;
      pmVar2 = pmVar2 + 1;
      msgid = pmVar2->text;
    }
    pmVar2->hotkey_pos = 0;
    pmVar2->hotkey_state = HKS_IGNORE;
LAB_0805e206:
    pmVar2 = pmVar2 + 1;
    msgid = pmVar2->text;
  } while( true );
}



void refresh_hotkeys(terminal *term,menu *menu)

{
  uchar *puVar1;
  int iVar2;
  menu_item *pmVar3;
  
  if (menu->lang != current_language) {
    pmVar3 = menu->items;
    puVar1 = pmVar3->text;
    while (puVar1 != (uchar *)0x0) {
      iVar2 = menu->hotkeys;
      pmVar3->hotkey_pos = 0;
      pmVar3->hotkey_state = (uint)(iVar2 == 0);
      pmVar3 = pmVar3 + 1;
      puVar1 = pmVar3->text;
    }
    init_hotkeys(term,menu);
    menu->lang = current_language;
  }
  return;
}



int __regparm3
check_hotkeys_common(menu *menu,term_event_char_T hotkey,terminal *term,int check_mode)

{
  unicode_val_T uVar1;
  int codepage;
  uchar *msgid;
  unicode_val_T c;
  uchar *codeset;
  int cp_index;
  uchar **ppuVar2;
  int iVar3;
  int local_30;
  uchar *local_20 [4];
  
  uVar1 = unicode_fold_label_case(hotkey);
  codepage = get_terminal_codepage(term);
  cp_index = menu->size;
  if (cp_index < 1) {
    return 0;
  }
  local_30 = menu->selected % cp_index;
  if (local_30 < 0) {
    local_30 = local_30 + cp_index;
  }
  iVar3 = local_30 + 1;
  if (iVar3 == cp_index) goto LAB_0805e44b;
LAB_0805e388:
  cp_index = iVar3 << 5;
  do {
    ppuVar2 = (uchar **)((int)&menu->items->text + cp_index);
    msgid = *ppuVar2;
    if ((msgid != (uchar *)0x0) && (*msgid != '\0')) {
      local_20[0] = msgid;
      if (((*(byte *)(ppuVar2 + 5) & 0x40) == 0) && (*msgid != '\0')) {
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        local_20[0] = gettext(msgid);
        if (local_20[0] == (uchar *)0x0) goto LAB_0805e438;
      }
      if (*local_20[0] != '\0') {
        if (check_mode == 0) {
          if (ppuVar2[7] == (uchar *)0x0) goto LAB_0805e438;
          local_20[0] = local_20[0] + (int)ppuVar2[7];
        }
        msgid = (uchar *)__rawmemchr(local_20[0],0);
        c = cp_to_unicode(codepage,local_20,msgid);
        if (assert_failed == 0) {
          assert_failed = ZEXT14(c == 0xfffffffd);
          if (c == 0xfffffffd) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hotkey.c";
            errline = 0xb8;
            elinks_internal((uchar *)"assertion items_hotkey != UCS_NO_CHAR failed!");
            if (assert_failed != 0) goto LAB_0805e517;
          }
          c = unicode_fold_label_case(c);
          if (uVar1 == c) {
            menu->selected = iVar3;
            return 1;
          }
        }
        else {
LAB_0805e517:
          assert_failed = 0;
        }
      }
    }
LAB_0805e438:
    if (local_30 == iVar3) {
      return 0;
    }
    iVar3 = iVar3 + 1;
    if (iVar3 != menu->size) goto LAB_0805e388;
LAB_0805e44b:
    cp_index = 0;
    iVar3 = 0;
  } while( true );
}



int check_not_so_hot_keys(menu *menu,term_event_char_T key,terminal *term)

{
  int iVar1;
  
  iVar1 = check_hotkeys_common(menu,key,term,1);
  return iVar1;
}



int check_hotkeys(menu *menu,term_event_char_T key,terminal *term)

{
  int iVar1;
  
  iVar1 = check_hotkeys_common(menu,key,term,0);
  return iVar1;
}



void add_dlg_field_do(dialog *dlg,widget_type type,uchar *label,int min,int max,
                     widget_handler_T *handler,int datalen,void *data,input_history *history,
                     inpfield_flags flags)

{
  int iVar1;
  uchar **ppuVar2;
  int iVar3;
  uchar **ppuVar4;
  
  iVar3 = dlg->number_of_widgets;
  iVar1 = iVar3 + 1;
  dlg->number_of_widgets = iVar1;
  ppuVar4 = &dlg->title + iVar3 * 0xc;
  *(widget_type *)(ppuVar4 + 0x14) = type;
  ppuVar2 = &dlg->title + iVar1 * 0xc;
  ppuVar4[10] = label;
  *(widget_handler_T **)(ppuVar4 + 0xb) = handler;
  *(int *)(ppuVar2 + 1) = datalen;
  ppuVar4[0xc] = data;
  *(input_history **)(ppuVar2 + 4) = history;
  *(inpfield_flags *)(ppuVar2 + 5) = flags;
  *(int *)(ppuVar2 + 2) = min;
  *(int *)(ppuVar2 + 3) = max;
  return;
}



widget_handler_status_T __regparm3
display_field_do(dialog_data *dlg_data,widget_data *widget_data,int hide)

{
  terminal *term;
  int iVar1;
  byte bVar2;
  int iVar3;
  color_pair *color;
  int iVar4;
  size_t sVar5;
  size_t max_cells;
  int iVar6;
  uchar *string;
  window **ppwVar7;
  int local_3c;
  int local_38;
  size_t local_30;
  box box;
  
  term = dlg_data->win->term;
  iVar1 = dlg_data->selected_widget_id;
  if ((*(byte *)&term->field_0x38 & 2) == 0) {
    iVar4 = *(int *)(widget_data->info + 4);
    iVar6 = *(int *)widget_data->info;
    iVar3 = (iVar4 + 1) - (widget_data->box).width;
    if (iVar6 < iVar3) {
      *(int *)widget_data->info = iVar3;
      iVar6 = iVar3;
    }
    else {
      if (iVar4 < iVar6) {
        *(int *)widget_data->info = iVar4;
        iVar6 = iVar4;
      }
    }
    local_38 = 0;
    local_3c = 0;
    if (iVar6 < 0) {
      *(undefined4 *)widget_data->info = 0;
      local_38 = 0;
      local_3c = 0;
    }
  }
  else {
    string = widget_data->cdata;
    local_3c = utf8_ptr2cells(string,string + *(int *)(widget_data->info + 4));
    iVar4 = (local_3c - (widget_data->box).width) + 1;
    local_38 = 0;
    if (0 < iVar4) {
      local_38 = iVar4;
    }
    iVar4 = utf8_cells2bytes(string,local_38,(uchar *)0x0);
    *(int *)widget_data->info = iVar4;
  }
  color = get_bfu_color(term,"dialog.field");
  if (color != (color_pair *)0x0) {
    draw_box(term,&widget_data->box,' ',0,color);
  }
  color = get_bfu_color(term,(uchar *)"dialog.field-text");
  if (color == (color_pair *)0x0) goto LAB_0805e719;
  string = widget_data->cdata + *(int *)widget_data->info;
  bVar2 = *(byte *)&term->field_0x38 >> 1 & 1;
  if (hide == 0) {
    if (bVar2 == 0) goto LAB_0805e6ba;
    sVar5 = utf8_ptr2cells(string,(uchar *)0x0);
    max_cells = (widget_data->box).width;
    if ((int)sVar5 <= (int)max_cells) {
      max_cells = sVar5;
    }
    bVar2 = *(byte *)&term->field_0x38;
  }
  else {
    if (bVar2 == 0) {
LAB_0805e6ba:
      local_30 = strlen((char *)string);
    }
    else {
      local_30 = utf8_ptr2chars(string,(uchar *)0x0);
    }
    max_cells = (widget_data->box).width;
    if ((int)local_30 <= (int)max_cells) {
      max_cells = local_30;
    }
    if (hide != 0) {
      box.x = (widget_data->box).x;
      box.y = (widget_data->box).y;
      box.height = (widget_data->box).height;
      box.width = max_cells;
      draw_box(term,&box,'*',0,color);
      goto LAB_0805e719;
    }
    bVar2 = *(byte *)&term->field_0x38;
  }
  if ((bVar2 & 2) != 0) {
    max_cells = utf8_cells2bytes(string,max_cells,(uchar *)0x0);
  }
  draw_text(term,(widget_data->box).x,(widget_data->box).y,string,max_cells,0,color);
LAB_0805e719:
  if (dlg_data->widgets_data + iVar1 != widget_data) {
    return EVENT_PROCESSED;
  }
  if ((*(byte *)&term->field_0x38 & 2) == 0) {
    local_38 = (int)(&dlg_data->win + (iVar1 * 3 + 3) * 4)[5] +
               (dlg_data->widgets_data[iVar1].box.x - (int)(&dlg_data->win + (iVar1 * 3 + 3) * 4)[4]
               );
  }
  else {
    local_38 = (local_3c + dlg_data->widgets_data[iVar1].box.x) - local_38;
  }
  ppwVar7 = &dlg_data->win + iVar1 * 0xc;
  set_cursor(term,local_38,(int)ppwVar7[0xd],0);
  *(window **)&dlg_data->win->x = ppwVar7[0xc];
  *(window **)&dlg_data->win->y = ppwVar7[0xd];
  return EVENT_PROCESSED;
}



widget_handler_status_T display_field_pass(dialog_data *dlg_data,widget_data *widget_data)

{
  widget_handler_status_T wVar1;
  
  wVar1 = display_field_do(dlg_data,widget_data,1);
  return wVar1;
}



widget_handler_status_T display_field(dialog_data *dlg_data,widget_data *widget_data)

{
  widget_handler_status_T wVar1;
  
  wVar1 = display_field_do(dlg_data,widget_data,0);
  return wVar1;
}



widget_handler_status_T clear_field(dialog_data *dlg_data,widget_data *widget_data)

{
  widget *pwVar1;
  size_t __n;
  
  pwVar1 = widget_data->widget;
  *(undefined4 *)(widget_data->info + 4) = 0;
  __n = pwVar1->datalen;
  if (__n != 0) {
    memset(widget_data->cdata,0,__n);
  }
  return EVENT_PROCESSED;
}



widget_handler_status_T kbd_field(dialog_data *dlg_data,widget_data *widget_data)

{
  uchar uVar1;
  byte bVar2;
  terminal *term;
  term_event *ev;
  uint uVar3;
  action_id_T action_id;
  action *paVar4;
  int *piVar5;
  size_t sVar6;
  int to;
  uchar *__src;
  size_t __n;
  ushort *puVar7;
  ushort **ppuVar8;
  unicode_val_T uVar9;
  uchar *name;
  uchar *end;
  byte *pbVar10;
  int iVar11;
  uchar *local_38;
  uchar *local_20 [4];
  
  term = dlg_data->win->term;
  ev = dlg_data->term_event;
  action_id = kbd_action(KEYMAP_EDIT,ev,(int *)0x0);
  if (action_id == -1) {
switchD_0805eae0_caseD_0:
    if ((*(int *)&ev->info < 0x20) || (*(int *)((int)&ev->info + 4) != 0)) {
      return EVENT_NOT_PROCESSED;
    }
    end = widget_data->cdata;
    sVar6 = strlen((char *)end);
    to = get_terminal_codepage(term);
    __src = u2cp_(*(unicode_val_T *)&ev->info,to,NBSP_MODE_ASCII);
    __n = strlen((char *)__src);
    if ((int)sVar6 < (int)(widget_data->widget->datalen - __n)) {
      end = end + *(int *)(widget_data->info + 4);
      memmove(end + __n,end,(sVar6 - *(int *)(widget_data->info + 4)) + 1);
      memcpy(end,__src,__n);
      *(size_t *)(widget_data->info + 4) = *(int *)(widget_data->info + 4) + __n;
    }
    goto display_field;
  }
  paVar4 = get_action(KEYMAP_EDIT,action_id);
  if (((paVar4 == (action *)0x0) || ((*(byte *)((int)&paVar4->flags + 2) & 1) != 0)) &&
     (piVar5 = get_opt_(cmdline_options,name), *piVar5 != 0)) {
    return EVENT_NOT_PROCESSED;
  }
  switch(action_id) {
  default:
    goto switchD_0805eae0_caseD_0;
  case 2:
    if (widget_data->widget->type != WIDGET_FIELD) {
      return EVENT_NOT_PROCESSED;
    }
    if (*(int *)(widget_data->widget->info + 8) == 0) {
      return EVENT_NOT_PROCESSED;
    }
    do_tab_compl(dlg_data,(list_head_elinks *)(widget_data->info + 8));
    break;
  case 3:
    if (widget_data->widget->type != WIDGET_FIELD) {
      return EVENT_NOT_PROCESSED;
    }
    if (*(int *)(widget_data->widget->info + 8) == 0) {
      return EVENT_NOT_PROCESSED;
    }
    do_tab_compl_file(dlg_data,(list_head_elinks *)(widget_data->info + 8));
    break;
  case 4:
    if (widget_data->widget->type != WIDGET_FIELD) {
      return EVENT_NOT_PROCESSED;
    }
    if (*(int *)(widget_data->widget->info + 8) == 0) {
      return EVENT_NOT_PROCESSED;
    }
    do_tab_compl_unambiguous(dlg_data,(list_head_elinks *)(widget_data->info + 8));
    break;
  case 5:
    end = *(uchar **)(widget_data->info + 4);
    if (end != (uchar *)0x0) {
      if ((*(byte *)&term->field_0x38 & 2) == 0) {
        __src = widget_data->cdata;
        sVar6 = strlen((char *)__src);
        memmove(end + (int)(__src + -1),__src + (int)end,(sVar6 - (int)end) + 1);
        *(int *)(widget_data->info + 4) = *(int *)(widget_data->info + 4) + -1;
      }
      else {
        local_20[0] = widget_data->cdata;
        __src = widget_data->cdata;
        do {
          uVar9 = utf8_to_unicode(local_20,__src + (int)(end + -1));
        } while (uVar9 != 0xfffffffd);
        __src = widget_data->cdata;
        *(uchar **)(widget_data->info + 4) = local_20[0] + -(int)__src;
        if (end != local_20[0] + -(int)__src) {
          local_20[0] = __src;
          sVar6 = strlen((char *)(__src + (int)end));
          memmove(__src + *(int *)(widget_data->info + 4),__src + (int)end,sVar6 + 1);
        }
      }
    }
    break;
  case 8:
    set_clipboard_text(widget_data->cdata);
    return EVENT_PROCESSED;
  case 9:
    set_clipboard_text(widget_data->cdata);
    *widget_data->cdata = '\0';
    *(undefined4 *)(widget_data->info + 4) = 0;
    break;
  case 10:
    end = widget_data->cdata;
    sVar6 = strlen((char *)end);
    to = *(int *)(widget_data->info + 4);
    if (to < (int)sVar6) {
      if ((*(byte *)&term->field_0x38 & 2) == 0) {
        memmove(end + to,end + to + 1,(sVar6 - to) + 1);
      }
      else {
        __src = end + to;
        local_20[0] = __src;
        utf8_to_unicode(local_20,end + sVar6);
        if (__src != local_20[0]) {
          memmove(__src,local_20[0],(size_t)(end + sVar6 + (1 - (int)local_20[0])));
        }
      }
    }
    break;
  case 0xb:
    if (widget_data->widget->type != WIDGET_FIELD) {
      return EVENT_NOT_PROCESSED;
    }
    if (*(int *)(widget_data->widget->info + 8) == 0) {
      return EVENT_NOT_PROCESSED;
    }
    if (*(byte ***)(widget_data->info + 0x10) == (byte **)(widget_data->info + 8)) {
      return EVENT_NOT_PROCESSED;
    }
    pbVar10 = **(byte ***)(widget_data->info + 0x10);
    goto LAB_0805ecc7;
  case 0xc:
    sVar6 = strlen((char *)widget_data->cdata);
    *(size_t *)(widget_data->info + 4) = sVar6;
    break;
  case 0x10:
    end = widget_data->cdata;
    __src = end + *(int *)(widget_data->info + 4);
    sVar6 = strlen((char *)__src);
    memmove(end,__src,sVar6 + 1);
  case 0xf:
    *(undefined4 *)(widget_data->info + 4) = 0;
    break;
  case 0x11:
    widget_data->cdata[*(int *)(widget_data->info + 4)] = '\0';
    break;
  case 0x12:
    end = widget_data->cdata;
    sVar6 = strlen((char *)end);
    to = *(int *)(widget_data->info + 4);
    iVar11 = to;
    if (0 < to) {
      ppuVar8 = __ctype_b_loc();
      __src = end + to;
      do {
        if ((*(byte *)((int)*ppuVar8 + (uint)__src[-1] * 2 + 1) & 0x20) == 0) {
          if (0 < iVar11) {
            __src = end + iVar11;
            goto LAB_0805ed3a;
          }
          break;
        }
        iVar11 = iVar11 + -1;
        __src = __src + -1;
      } while (0 < iVar11);
    }
    goto LAB_0805ed45;
  case 0x13:
    to = *(int *)(widget_data->info + 4);
    if (0 < to) {
      to = to + -1;
      *(int *)(widget_data->info + 4) = to;
    }
    if ((to != 0) && ((*(byte *)&term->field_0x38 & 2) != 0)) {
      end = widget_data->cdata;
      __src = end + *(int *)(widget_data->info + 4);
      uVar1 = *__src;
      *__src = '\0';
      local_20[0] = end;
      strlen_utf8(local_20);
      *__src = uVar1;
      *(uchar **)(widget_data->info + 4) = local_20[0] + -(int)end;
    }
    break;
  case 0x14:
    to = *(int *)(widget_data->info + 4);
    if (0 < to) {
      ppuVar8 = __ctype_b_loc();
      end = widget_data->cdata + to;
      do {
        puVar7 = *ppuVar8;
        if ((*(byte *)((int)puVar7 + (uint)end[-1] * 2 + 1) & 0x20) == 0) {
          to = *(int *)(widget_data->info + 4);
          if (0 < to) {
            while ((to = to + -1,
                   (*(byte *)((int)puVar7 + (uint)widget_data->cdata[to] * 2 + 1) & 0x20) == 0 &&
                   (*(int *)(widget_data->info + 4) = to, 0 < to))) {
              puVar7 = *ppuVar8;
            }
          }
          break;
        }
        to = to + -1;
        end = end + -1;
        *(int *)(widget_data->info + 4) = to;
      } while (0 < to);
    }
    break;
  case 0x15:
    ppuVar8 = __ctype_b_loc();
    pbVar10 = widget_data->cdata + *(int *)(widget_data->info + 4);
    to = *(int *)(widget_data->info + 4);
    while( true ) {
      bVar2 = *pbVar10;
      pbVar10 = pbVar10 + 1;
      if ((*(byte *)((int)*ppuVar8 + (uint)bVar2 * 2 + 1) & 0x20) == 0) break;
      *(int *)(widget_data->info + 4) = to + 1;
      to = to + 1;
    }
    if (bVar2 != 0) {
      end = widget_data->cdata + to;
      do {
        to = to + 1;
        *(int *)(widget_data->info + 4) = to;
        pbVar10 = end + 1;
        if (*pbVar10 == 0) {
          if ((*(byte *)((int)*ppuVar8 + 1) & 0x20) == 0) goto display_field;
          break;
        }
        end = end + 1;
      } while ((*(byte *)((int)*ppuVar8 + (uint)*pbVar10 * 2 + 1) & 0x20) == 0);
      end = widget_data->cdata + to;
      do {
        to = to + 1;
        *(int *)(widget_data->info + 4) = to;
        pbVar10 = end + 1;
        end = end + 1;
      } while ((*(byte *)((int)*ppuVar8 + (uint)*pbVar10 * 2 + 1) & 0x20) != 0);
    }
    break;
  case 0x18:
    end = get_clipboard_text();
    if (end != (uchar *)0x0) {
      safe_strncpy(widget_data->cdata,end,widget_data->widget->datalen);
      sVar6 = strlen((char *)widget_data->cdata);
      *(size_t *)(widget_data->info + 4) = sVar6;
      mem_free(end);
    }
    break;
  case 0x1a:
    redraw_terminal_cls(term);
    return EVENT_PROCESSED;
  case 0x1b:
    end = widget_data->cdata;
    uVar3 = *(uint *)(widget_data->info + 4);
    sVar6 = strlen((char *)end);
    if (uVar3 < sVar6) {
      if ((*(byte *)&term->field_0x38 & 2) == 0) {
        *(uint *)(widget_data->info + 4) = uVar3 + 1;
      }
      else {
        local_20[0] = end + uVar3;
        end = (uchar *)__rawmemchr(local_20[0],0);
        utf8_to_unicode(local_20,end);
        *(uchar **)(widget_data->info + 4) = local_20[0] + -(int)widget_data->cdata;
      }
    }
    break;
  case 0x1d:
    if (widget_data->widget->type != WIDGET_FIELD) {
      return EVENT_NOT_PROCESSED;
    }
    if (*(int *)(widget_data->widget->info + 8) == 0) {
      return EVENT_NOT_PROCESSED;
    }
    pbVar10 = *(byte **)(*(int *)(widget_data->info + 0x10) + 4);
    if (pbVar10 == widget_data->info + 8) {
      return EVENT_NOT_PROCESSED;
    }
LAB_0805ecc7:
    *(byte **)(widget_data->info + 0x10) = pbVar10;
    dlg_set_history(widget_data);
  }
display_field:
  display_widget(dlg_data,widget_data);
  redraw_from_window(dlg_data->win);
  return EVENT_PROCESSED;
  while( true ) {
    iVar11 = iVar11 + -1;
    __src = __src + -1;
    if (iVar11 < 1) break;
LAB_0805ed3a:
    if ((*(byte *)((int)*ppuVar8 + (uint)__src[-1] * 2 + 1) & 0x20) != 0) break;
  }
LAB_0805ed45:
  local_38 = end + to;
  memmove(end + iVar11,local_38,(sVar6 - to) + 1);
  *(int *)(widget_data->info + 4) = iVar11;
  goto display_field;
}



widget_handler_status_T mouse_field(dialog_data *dlg_data,widget_data *widget_data)

{
  term_event *ptVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  byte *pbVar6;
  size_t sVar7;
  int iVar8;
  
  ptVar1 = dlg_data->term_event;
  iVar8 = (widget_data->box).x;
  iVar2 = *(int *)&ptVar1->info;
  iVar3 = *(int *)((int)&ptVar1->info + 4);
  if ((((iVar8 <= iVar2) && (iVar4 = (widget_data->box).y, iVar4 <= iVar3)) &&
      (iVar2 < (widget_data->box).width + iVar8)) && (iVar3 < iVar4 + (widget_data->box).height)) {
    uVar5 = *(uint *)((int)&ptVar1->info + 8);
    if ((uVar5 & 7) == 3) {
      if ((((uVar5 & 0x20) == 0) && (widget_data->widget->type == WIDGET_FIELD)) &&
         ((*(int *)(widget_data->widget->info + 8) != 0 &&
          (pbVar6 = *(byte **)(*(int *)(widget_data->info + 0x10) + 4),
          pbVar6 != widget_data->info + 8)))) {
        *(byte **)(widget_data->info + 0x10) = pbVar6;
        dlg_set_history(widget_data);
        select_widget(dlg_data,widget_data);
        return EVENT_PROCESSED;
      }
    }
    else {
      if ((uVar5 & 7) != 4) {
        iVar8 = (*(int *)widget_data->info + iVar2) - iVar8;
        *(int *)(widget_data->info + 4) = iVar8;
        sVar7 = strlen((char *)widget_data->cdata);
        if ((int)sVar7 < iVar8) {
          *(size_t *)(widget_data->info + 4) = sVar7;
        }
        select_widget(dlg_data,widget_data);
        return EVENT_PROCESSED;
      }
      if ((((uVar5 & 0x20) == 0) && (widget_data->widget->type == WIDGET_FIELD)) &&
         ((*(int *)(widget_data->widget->info + 8) != 0 &&
          (*(undefined4 **)(widget_data->info + 0x10) != (undefined4 *)(widget_data->info + 8))))) {
        *(undefined4 *)(widget_data->info + 0x10) = **(undefined4 **)(widget_data->info + 0x10);
        dlg_set_history(widget_data);
        select_widget(dlg_data,widget_data);
        return EVENT_PROCESSED;
      }
    }
  }
  return EVENT_NOT_PROCESSED;
}



widget_handler_status_T init_field(dialog_data *dlg_data,widget_data *widget_data)

{
  int **ppiVar1;
  int *piVar2;
  size_t sVar3;
  int **ppiVar4;
  int *piVar5;
  
  if (((widget_data->widget->type == WIDGET_FIELD) &&
      (piVar2 = *(int **)(widget_data->widget->info + 8), piVar2 != (int *)0x0)) &&
     (piVar5 = (int *)*piVar2, piVar5 != piVar2)) {
    ppiVar1 = (int **)(widget_data->info + 8);
    do {
      sVar3 = strlen((char *)(piVar5 + 2));
      ppiVar4 = (int **)mem_alloc(sVar3 + 0xc);
      if (ppiVar4 != (int **)0x0) {
        memcpy(ppiVar4 + 2,piVar5 + 2,sVar3 + 1);
        piVar2 = *ppiVar1;
        *(int ***)(ppiVar4 + 1) = ppiVar1;
        *ppiVar4 = piVar2;
        *(int ***)ppiVar1 = ppiVar4;
        *(int ***)(*ppiVar4 + 1) = ppiVar4;
      }
      piVar5 = (int *)*piVar5;
    } while ((int *)*(int *)(widget_data->widget->info + 8) != piVar5);
  }
  sVar3 = strlen((char *)widget_data->cdata);
  *(size_t *)(widget_data->info + 4) = sVar3;
  return EVENT_PROCESSED;
}



void input_field_line(session *ses,uchar *prompt,void *data,input_history *history,
                     input_line_handler_T *handler)

{
  int iVar1;
  dialog *dlg;
  uchar **ppuVar2;
  memory_list *ml;
  uchar **ppuVar3;
  
  if ((assert_failed == 0) && (assert_failed = ZEXT14(ses == (session *)0x0), ses == (session *)0x0)
     ) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inpfield.c";
    errline = 0x370;
    elinks_internal((uchar *)"assertion ses failed!");
  }
  dlg = (dialog *)mem_calloc(1,0x160);
  if (dlg != (dialog *)0x0) {
    *(session **)&dlg[1].title = ses;
    *(input_line_handler_T **)&dlg[1].udata = handler;
    dlg[1].udata2 = data;
    *(dialog **)&dlg->udata = dlg + 1;
    *(byte *)&dlg->layout = *(byte *)&dlg->layout | 0x10;
    iVar1 = dlg->number_of_widgets + 1;
    ppuVar3 = &dlg->title + dlg->number_of_widgets * 0xc;
    dlg->number_of_widgets = iVar1;
    dlg->handle_event = input_line_event_handler;
    dlg->layouter = input_line_layouter;
    ppuVar2 = &dlg->title + iVar1 * 0xc;
    ppuVar3[0x14] = (uchar *)0x1;
    ppuVar3[0xb] = (uchar *)0x0;
    ppuVar3[10] = prompt;
    ppuVar2[1] = (uchar *)0x100;
    *(dialog_refresh **)(ppuVar3 + 0xc) = (dialog_refresh *)&dlg[1].refresh;
    ppuVar2[5] = (uchar *)0x2;
    ppuVar2[2] = (uchar *)0x0;
    ppuVar2[3] = (uchar *)0x0;
    *(input_history **)(ppuVar2 + 4) = history;
    ml = getml(dlg,0);
    do_dialog(ses->tab->term,dlg,ml);
    return;
  }
  return;
}



widget_handler_status_T input_line_event_handler(dialog_data *dlg_data)

{
  int *piVar1;
  void *pvVar2;
  code *pcVar3;
  term_event *ev;
  term_event_type tVar4;
  widget *pwVar5;
  uint uVar6;
  uchar *__s;
  input_history *history;
  byte bVar7;
  int iVar8;
  uint uVar9;
  uint uVar10;
  size_t sVar11;
  uint *puVar12;
  uint *puVar13;
  widget_handler_status_T wVar14;
  bool bVar15;
  action_id_T local_28;
  
  pvVar2 = dlg_data->dlg->udata;
  pcVar3 = *(code **)((int)pvVar2 + 4);
  ev = dlg_data->term_event;
  tVar4 = ev->ev;
  if (tVar4 == EVENT_MOUSE) {
    if (*(int *)((int)&ev->info + 4) == dlg_data->win->y) {
      return EVENT_NOT_PROCESSED;
    }
    delete_window_ev(dlg_data->win,ev);
    return EVENT_PROCESSED;
  }
  if (tVar4 < EVENT_REDRAW) {
    if (tVar4 != EVENT_KBD) {
      return EVENT_NOT_PROCESSED;
    }
    local_28 = kbd_action(KEYMAP_EDIT,ev,(int *)0x0);
    switch(local_28) {
    case 5:
      if (*(char *)((int)pvVar2 + 0xc) == '\0') goto cancel_input_line;
      break;
    case 7:
cancel_input_line:
      wVar14 = EVENT_PROCESSED;
      goto LAB_0805f47d;
    case 0xe:
    case 0x16:
    case 0x19:
      pwVar5 = dlg_data->widgets_data[0].widget;
      if ((pwVar5->type == WIDGET_FIELD) &&
         (history = *(input_history **)(pwVar5->info + 8), history != (input_history *)0x0)) {
        add_to_input_history(history,(uchar *)((int)pvVar2 + 0xc),1);
      }
    }
    kbd_field(dlg_data,dlg_data->widgets_data);
    wVar14 = (widget_handler_status_T)(local_28 == 0x1a);
  }
  else {
    if (tVar4 == EVENT_REDRAW) {
      pwVar5 = dlg_data->widgets_data[0].widget;
      if (((pwVar5->type != WIDGET_FIELD) || (*(int *)(pwVar5->info + 8) == 0)) ||
         (uVar6 = *(uint *)(dlg_data->widgets_data[0].info + 4), (int)uVar6 < 1)) {
        return EVENT_NOT_PROCESSED;
      }
      puVar13 = (uint *)((int)pvVar2 + 0xc);
      do {
        puVar12 = puVar13;
        uVar9 = *puVar12 + 0xfefefeff & ~*puVar12;
        uVar10 = uVar9 & 0x80808080;
        puVar13 = puVar12 + 1;
      } while (uVar10 == 0);
      bVar15 = (uVar9 & 0x8080) == 0;
      bVar7 = (byte)uVar10;
      if (bVar15) {
        bVar7 = (byte)(uVar10 >> 0x10);
      }
      if (bVar15) {
        puVar13 = (uint *)((int)puVar12 + 6);
      }
      if (uVar6 <= (int)puVar13 +
                   ((-3 - (uint)CARRY1(bVar7,bVar7)) - (int)(uint *)((int)pvVar2 + 0xc))) {
        return EVENT_NOT_PROCESSED;
      }
    }
    else {
      if (tVar4 != EVENT_RESIZE) {
        return EVENT_NOT_PROCESSED;
      }
    }
    wVar14 = EVENT_NOT_PROCESSED;
    local_28 = 0x1a;
  }
  update_dialog_data(dlg_data);
  while (iVar8 = (*pcVar3)(pvVar2,local_28), iVar8 != 0) {
    if (iVar8 != 2) {
      return wVar14;
    }
    __s = dlg_data->widgets_data[0].cdata;
    sVar11 = strlen((char *)__s);
    iVar8 = *(int *)(dlg_data->widgets_data[0].info + 4);
    memmove(__s + iVar8 + -1,__s + iVar8,(1 - iVar8) + sVar11);
    piVar1 = (int *)(dlg_data->widgets_data[0].info + 4);
    *piVar1 = *piVar1 + -1;
    update_dialog_data(dlg_data);
  }
  wVar14 = (widget_handler_status_T)(local_28 == 0x1a);
LAB_0805f47d:
  cancel_dialog(dlg_data,dlg_data->widgets_data);
  return wVar14;
}



widget_handler_status_T input_field_cancel(dialog_data *dlg_data,widget_data *widget_data)

{
  code *pcVar1;
  widget_handler_status_T wVar2;
  
  pcVar1 = (code *)widget_data->widget->data;
  if (pcVar1 != (code *)0x0) {
    (*pcVar1)(dlg_data->dlg->udata2);
  }
  wVar2 = cancel_dialog(dlg_data,widget_data);
  return wVar2;
}



widget_handler_status_T input_field_ok(dialog_data *dlg_data,widget_data *widget_data)

{
  code *pcVar1;
  void *pvVar2;
  uchar *data;
  widget *pwVar3;
  int iVar4;
  widget_handler_status_T wVar5;
  
  pcVar1 = (code *)widget_data->widget->data;
  pvVar2 = dlg_data->dlg->udata2;
  data = dlg_data->widgets_data[0].cdata;
  iVar4 = check_dialog(dlg_data);
  if (iVar4 != 0) {
    return EVENT_NOT_PROCESSED;
  }
  pwVar3 = dlg_data->widgets_data[0].widget;
  if ((pwVar3->type == WIDGET_FIELD) && (*(int *)(pwVar3->info + 8) != 0)) {
    add_to_input_history(*(input_history **)(dlg_data->dlg->widgets[0].info + 8),data,1);
  }
  if (pcVar1 != (code *)0x0) {
    (*pcVar1)(pvVar2,data);
  }
  wVar5 = cancel_dialog(dlg_data,widget_data);
  return wVar5;
}



void dlg_format_field(terminal *term,widget_data *widget_data,int x,int *y,int w,int *rw,
                     format_align align,int format_only)

{
  uchar *text;
  int *prev_y;
  int max_label_width;
  int iVar1;
  bool bVar2;
  color_pair *local_24;
  size_t local_20;
  
  text = widget_data->widget->text;
  if (text != (uchar *)0x0) {
    bVar2 = (*(uint *)(widget_data->widget->info + 0xc) & 3) == 0;
    if (bVar2) {
      if (*text == '\0') goto LAB_0805f818;
      local_20 = 0;
    }
    else {
      if (*text == '\0') goto LAB_0805f818;
      local_20 = strlen((char *)text);
      if (prev_y == y) {
        local_24 = (color_pair *)max_label_width;
        if (max_label_width < (int)local_20) {
          local_24 = (color_pair *)local_20;
        }
      }
      else {
        prev_y = y;
        local_24 = (color_pair *)local_20;
      }
      x = (x - local_20) + (int)local_24;
      w = (w + local_20) - (int)local_24;
      max_label_width = (int)local_24;
    }
    local_24 = (color_pair *)0x0;
    if (format_only == 0) {
      local_24 = get_bfu_color(term,"dialog.text");
    }
    dlg_format_text_do(term,text,x,y,w,rw,local_24,ALIGN_LEFT,format_only);
    if ((!bVar2) && (*text != '\0')) {
      if ((widget_data->widget->info[0xc] & 1) != 0) {
        *y = *y + -1;
        dlg_format_text_do(term,":",local_20 + x,y,w,rw,local_24,ALIGN_LEFT,format_only);
        x = x + 2;
        w = w + -2;
      }
      if ((int)local_20 < w + -5) {
        *y = *y + -1;
        w = w - local_20;
        x = x + local_20;
      }
    }
  }
LAB_0805f818:
  if (rw != (int *)0x0) {
    iVar1 = 0x2a;
    if (w < 0x2a) {
      iVar1 = w;
    }
    if (*rw < iVar1) {
      *rw = iVar1;
    }
  }
  iVar1 = *y;
  if (x < 0) {
    x = 0;
  }
  (widget_data->box).x = x;
  (widget_data->box).height = 1;
  if (iVar1 < 0) {
    iVar1 = 0;
  }
  if (w < 0) {
    w = 0;
  }
  (widget_data->box).y = iVar1;
  (widget_data->box).width = w;
  *y = *y + 1;
  return;
}



void input_line_layouter(dialog_data *dlg_data)

{
  byte bVar1;
  terminal *term;
  int local_10;
  
  bVar1 = *(byte *)(*(int *)dlg_data->dlg->udata + 0xa8);
  local_10 = ((dlg_data->win->term->height + -1) - ((uint)bVar1 & 1)) - ((uint)(bVar1 >> 1) & 1);
  term = dlg_data->win->term;
  dlg_format_field(term,dlg_data->widgets_data,0,&local_10,term->width,(int *)0x0,ALIGN_LEFT,0);
  return;
}



widget_handler_status_T check_nonempty(dialog_data *dlg_data,widget_data *widget_data)

{
  byte bVar1;
  byte *pbVar2;
  
  pbVar2 = widget_data->cdata;
  bVar1 = *pbVar2;
  while( true ) {
    if (bVar1 == 0) {
      info_box(dlg_data->win->term,0,(uchar *)"Bad string",ALIGN_CENTER,
               (uchar *)"Empty string not allowed");
      return EVENT_NOT_PROCESSED;
    }
    if (0x20 < bVar1) break;
    pbVar2 = pbVar2 + 1;
    bVar1 = *pbVar2;
  }
  return EVENT_PROCESSED;
}



widget_handler_status_T check_number(dialog_data *dlg_data,widget_data *widget_data)

{
  widget *pwVar1;
  int *piVar2;
  long lVar3;
  int iVar4;
  msgbox_flags local_58;
  char *local_4c;
  char *local_20 [4];
  
  pwVar1 = widget_data->widget;
  piVar2 = __errno_location();
  *piVar2 = 0;
  lVar3 = strtol((char *)widget_data->cdata,local_20,10);
  if (((*piVar2 == 0) && (*widget_data->cdata != '\0')) && (*local_20[0] == '\0')) {
    if (lVar3 < *(int *)pwVar1->info) {
      iVar4 = *(int *)(pwVar1->info + 4);
    }
    else {
      iVar4 = *(int *)(pwVar1->info + 4);
      if (lVar3 <= iVar4) {
        return EVENT_PROCESSED;
      }
    }
    local_4c = (char *)msg_text(dlg_data->win->term,
                                (uchar *)"Number should be in the range from %d to %d.",
                                *(int *)pwVar1->info,iVar4);
    local_58 = MSGBOX_FREE_TEXT;
  }
  else {
    local_4c = "Number expected in field";
    local_58 = 0;
  }
  info_box(dlg_data->win->term,local_58,(uchar *)"Bad number",ALIGN_CENTER,(uchar *)local_4c);
  return EVENT_NOT_PROCESSED;
}



void input_field(terminal *term,memory_list *ml,int intl,uchar *title,uchar *text,uchar *okbutton,
                uchar *cancelbutton,void *data,input_history *history,int l,uchar *def,int min,
                int max,widget_handler_T *check,anon_subr_void_void_ptr_uchar_ptr *fn,
                done_handler_T *cancelfn)

{
  dialog *dlg;
  size_t sVar1;
  size_t __n;
  uchar **ppuVar2;
  int cp_index;
  uchar *codeset;
  uchar **ppuVar3;
  bool bVar4;
  
  if (intl != 0) {
    if ((title != (uchar *)0x0) && (*title != '\0')) {
      if (term != (terminal *)0x0) {
        cp_index = get_terminal_codepage(term);
        if (cp_index != current_charset) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
      }
      title = gettext(title);
    }
    if ((text != (uchar *)0x0) && (*text != '\0')) {
      if (term != (terminal *)0x0) {
        cp_index = get_terminal_codepage(term);
        if (cp_index != current_charset) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
      }
      text = gettext(text);
    }
    if ((okbutton != (uchar *)0x0) && (*okbutton != '\0')) {
      if (term != (terminal *)0x0) {
        cp_index = get_terminal_codepage(term);
        if (cp_index != current_charset) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
      }
      okbutton = gettext(okbutton);
    }
    if ((cancelbutton != (uchar *)0x0) && (*cancelbutton != '\0')) {
      if (term != (terminal *)0x0) {
        cp_index = get_terminal_codepage(term);
        if (cp_index != current_charset) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
      }
      cancelbutton = gettext(cancelbutton);
    }
  }
  dlg = (dialog *)mem_calloc(1,l + 0xb4);
  if (dlg != (dialog *)0x0) {
    if (def != (uchar *)0x0) {
      sVar1 = strlen((char *)def);
      __n = sVar1 + 1;
      if (l < (int)(sVar1 + 1)) {
        __n = l - 1;
      }
      memcpy((dialog_refresh *)&dlg[2].refresh,def,__n);
    }
    *(byte *)&dlg->layout = *(byte *)&dlg->layout | 4;
    dlg->layouter = generic_dialog_layouter;
    dlg->title = title;
    dlg->udata2 = data;
    cp_index = dlg->number_of_widgets + 1;
    ppuVar2 = &dlg->title + dlg->number_of_widgets * 0xc;
    dlg->number_of_widgets = cp_index;
    ppuVar2[0x14] = (uchar *)0x1;
    ppuVar3 = &dlg->title + cp_index * 0xc;
    ppuVar2[10] = text;
    *(widget_handler_T **)(ppuVar2 + 0xb) = check;
    *(int *)(ppuVar3 + 1) = l;
    *(dialog_refresh **)(ppuVar2 + 0xc) = (dialog_refresh *)&dlg[2].refresh;
    ppuVar3[5] = (uchar *)0x0;
    *(input_history **)(ppuVar3 + 4) = history;
    *(int *)(ppuVar3 + 2) = min;
    *(int *)(ppuVar3 + 3) = max;
    add_dlg_button_do(dlg,okbutton,1,input_field_ok,fn,(done_handler_T *)0x0,(void *)0x0);
    add_dlg_button_do(dlg,cancelbutton,2,input_field_cancel,cancelfn,(done_handler_T *)0x0,
                      (void *)0x0);
    if ((assert_failed == 0) &&
       (bVar4 = dlg->number_of_widgets != 3, assert_failed = ZEXT14(bVar4), bVar4)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inpfield.c";
      errline = 0xef;
      elinks_internal((uchar *)"assertion 3 == (dlg)->number_of_widgets failed!");
    }
    add_to_ml(&ml,dlg,0);
    do_dialog(term,dlg,ml);
  }
  return;
}



void input_dialog(terminal *term,memory_list *ml,uchar *title,uchar *text,void *data,
                 input_history *history,int l,uchar *def,int min,int max,widget_handler_T *check,
                 anon_subr_void_void_ptr_uchar_ptr *fn,done_handler_T *cancelfn)

{
  input_field(term,ml,1,title,text,"~OK",(uchar *)"~Cancel",data,history,l,def,min,max,check,fn,
              cancelfn);
  return;
}



void dlg_set_history(widget_data *widget_data)

{
  bool bVar1;
  size_t sVar2;
  int iVar3;
  int iVar4;
  size_t __n;
  byte *pbVar5;
  
  if (assert_failed == 0) {
    if ((widget_data->widget->type != WIDGET_FIELD) ||
       (*(int *)(widget_data->widget->info + 8) == 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inphist.c";
      errline = 0x165;
      elinks_internal((uchar *)"assertion widget_has_history(widget_data) failed!");
      if (assert_failed != 0) goto LAB_0805ff30;
    }
    bVar1 = widget_data->widget->datalen < 1;
    assert_failed = ZEXT14(bVar1);
    if (!bVar1) goto LAB_0805ff30;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inphist.c";
    errline = 0x166;
    elinks_internal((uchar *)"assertion widget_data->widget->datalen > 0 failed!");
    pbVar5 = *(byte **)(widget_data->info + 0x10);
    if (pbVar5 == widget_data->info + 8) goto LAB_08060000;
  }
  else {
LAB_0805ff30:
    pbVar5 = *(byte **)(widget_data->info + 0x10);
    if (pbVar5 == widget_data->info + 8) {
LAB_08060000:
      *(undefined4 *)(widget_data->info + 4) = 0;
      iVar3 = 0;
      goto LAB_0805ff5f;
    }
  }
  iVar3 = widget_data->widget->datalen;
  sVar2 = strlen((char *)(pbVar5 + 8));
  __n = iVar3 - 1;
  if ((int)sVar2 <= (int)__n) {
    __n = sVar2;
  }
  iVar3 = 0;
  *(size_t *)(widget_data->info + 4) = __n;
  if (__n != 0) {
    memcpy(widget_data->cdata,pbVar5 + 8,__n);
    iVar3 = *(int *)(widget_data->info + 4);
  }
LAB_0805ff5f:
  widget_data->cdata[iVar3] = '\0';
  iVar4 = *(int *)(widget_data->info + 4) - (widget_data->box).width;
  iVar3 = 0;
  if (-1 < iVar4) {
    iVar3 = iVar4;
  }
  *(int *)widget_data->info = iVar3;
  return;
}



int save_input_history(input_history *history,uchar *filename)

{
  int *piVar1;
  uchar *file_name;
  secure_save_info *ssi;
  uchar *in_EDX;
  int iVar2;
  input_history *piVar3;
  
  if ((((*(byte *)&history->field_0xc & 1) == 0) || (elinks_home == (uchar *)0x0)) ||
     (piVar1 = get_opt_(cmdline_options,in_EDX), *piVar1 != 0)) {
    return 0;
  }
  file_name = straconcat(elinks_home,filename,0);
  if (file_name != (uchar *)0x0) {
    ssi = secure_open(file_name);
    mem_free(file_name);
    if (ssi != (secure_save_info *)0x0) {
      piVar3 = (input_history *)(history->entries).prev;
      iVar2 = 1;
      if (piVar3 == history) {
        if (ssi->err == 0) {
LAB_0806010b:
          *(byte *)&history->field_0xc = *(byte *)&history->field_0xc & 0xfe;
        }
      }
      else {
        while( true ) {
          secure_fputs(ssi,(char *)&piVar3->size);
          secure_fputc(ssi,10);
          if (ssi->err != 0) break;
          piVar3 = (input_history *)(piVar3->entries).prev;
          if ((piVar3 == history) || (iVar2 == 0x101)) goto LAB_0806010b;
          iVar2 = iVar2 + 1;
        }
      }
      iVar2 = secure_close(ssi);
      return iVar2;
    }
  }
  return -1;
}



void add_to_input_history(input_history *history,uchar *data,int check_duplicate)

{
  uchar *puVar1;
  uchar uVar2;
  int *p;
  void *pvVar3;
  size_t sVar4;
  uchar *__src;
  input_history *piVar5;
  int iVar6;
  void **ppvVar7;
  uchar *puVar8;
  input_history *piVar9;
  input_history *p_00;
  input_history *piVar10;
  
  if (((data != (uchar *)0x0) && (history != (input_history *)0x0)) &&
     (uVar2 = *data, uVar2 != '\0')) {
    sVar4 = strlen((char *)data);
    __src = data;
    while (uVar2 == ' ') {
      __src = __src + 1;
      sVar4 = sVar4 - 1;
      uVar2 = *__src;
    }
    if (sVar4 == 0) {
LAB_0806018d:
      *data = *__src;
    }
    else {
      if (__src[sVar4 - 1] == ' ') {
        puVar8 = __src + sVar4;
        do {
          sVar4 = sVar4 - 1;
          puVar8[-1] = '\0';
          if (sVar4 == 0) goto LAB_0806018d;
          puVar1 = puVar8 + -2;
          puVar8 = puVar8 + -1;
        } while (*puVar1 == ' ');
      }
      memmove(data,__src,sVar4 + 1);
      if (((check_duplicate != 0) && (*data != '\0')) &&
         (p_00 = (input_history *)(history->entries).next, p_00 != history)) {
        piVar10 = (input_history *)0x0;
        do {
          iVar6 = strcmp((char *)&p_00->size,(char *)data);
          piVar5 = p_00;
          piVar9 = piVar10;
          if (iVar6 == 0) {
            piVar5 = (input_history *)(p_00->entries).prev;
            *(input_history **)((int)(p_00->entries).next + 4) = piVar5;
            *(void **)(p_00->entries).prev = (p_00->entries).next;
            history->size = history->size + -1;
            if ((*(byte *)&history->field_0xc & 2) == 0) {
              *(byte *)&history->field_0xc = *(byte *)&history->field_0xc | 1;
            }
            piVar9 = p_00;
            if (piVar10 != (input_history *)0x0) {
              mem_free(p_00);
              piVar9 = piVar10;
            }
          }
          p_00 = (input_history *)(piVar5->entries).next;
          piVar10 = piVar9;
        } while (p_00 != history);
        if (piVar9 != (input_history *)0x0) {
          pvVar3 = (history->entries).next;
          *(input_history **)&(piVar9->entries).prev = history;
          (piVar9->entries).next = pvVar3;
          *(input_history **)&(history->entries).next = piVar9;
          *(input_history **)((int)(piVar9->entries).next + 4) = piVar9;
          history->size = history->size + 1;
          if ((*(byte *)&history->field_0xc & 2) != 0) {
            return;
          }
          *(byte *)&history->field_0xc = *(byte *)&history->field_0xc | 1;
          return;
        }
      }
      ppvVar7 = (void **)mem_alloc(sVar4 + 0xc);
      if (ppvVar7 != (void **)0x0) {
        memcpy(ppvVar7 + 2,data,sVar4 + 1);
        pvVar3 = (history->entries).next;
        *(input_history **)(ppvVar7 + 1) = history;
        *ppvVar7 = pvVar3;
        *(void ***)&(history->entries).next = ppvVar7;
        *(void ***)((int)*ppvVar7 + 4) = ppvVar7;
        iVar6 = history->size + 1;
        history->size = iVar6;
        if ((*(byte *)&history->field_0xc & 2) == 0) {
          *(byte *)&history->field_0xc = *(byte *)&history->field_0xc | 1;
        }
        while (0x100 < iVar6) {
          if (history == (input_history *)(history->entries).next) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inphist.c";
            errline = 0x112;
            elinks_internal("history is empty");
            history->size = 0;
            return;
          }
          p = (int *)(history->entries).prev;
          *(int *)(*p + 4) = p[1];
          *(int *)p[1] = *p;
          history->size = history->size + -1;
          if ((*(byte *)&history->field_0xc & 2) == 0) {
            *(byte *)&history->field_0xc = *(byte *)&history->field_0xc | 1;
          }
          mem_free(p);
          iVar6 = history->size;
        }
      }
    }
  }
  return;
}



int load_input_history(input_history *history,uchar *filename)

{
  byte bVar1;
  int *piVar2;
  FILE *__stream;
  uint uVar3;
  uint uVar4;
  char *pcVar5;
  uchar *in_EDX;
  uint *puVar6;
  uint *puVar7;
  int in_GS_OFFSET;
  bool bVar8;
  FILE *local_43c;
  char *local_438;
  undefined auStack1060 [4];
  uchar line [1024];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_438 = "anonymous";
  local_43c = (FILE *)cmdline_options;
  piVar2 = get_opt_(cmdline_options,in_EDX);
  if ((*piVar2 == 0) &&
     ((elinks_home == (uchar *)0x0 ||
      (local_43c = (FILE *)elinks_home, local_438 = (char *)filename,
      filename = straconcat(elinks_home,filename,0), (FILE *)filename != (FILE *)0x0)))) {
    local_438 = "rb";
    local_43c = (FILE *)filename;
    __stream = fopen64((char *)filename,"rb");
    if (elinks_home != (uchar *)0x0) {
      mem_free(filename);
      local_43c = (FILE *)filename;
    }
    if (__stream != (FILE *)0x0) {
      *(byte *)&history->field_0xc = *(byte *)&history->field_0xc | 2;
      while( true ) {
        local_438 = (char *)0x400;
        pcVar5 = fgets((char *)line,0x400,__stream);
        if (pcVar5 == (char *)0x0) break;
        puVar7 = (uint *)line;
        if (line[0] != '\0') {
          do {
            puVar6 = puVar7;
            uVar3 = *puVar6 + 0xfefefeff & ~*puVar6;
            uVar4 = uVar3 & 0x80808080;
            puVar7 = puVar6 + 1;
          } while (uVar4 == 0);
          bVar8 = (uVar3 & 0x8080) == 0;
          bVar1 = (byte)uVar4;
          if (bVar8) {
            bVar1 = (byte)(uVar4 >> 0x10);
          }
          if (bVar8) {
            puVar7 = (uint *)((int)puVar6 + 6);
          }
          auStack1060[(int)puVar7 + (-(int)line - (uint)CARRY1(bVar1,bVar1))] = 0;
        }
        add_to_input_history(history,line,0);
      }
      *(byte *)&history->field_0xc = *(byte *)&history->field_0xc & 0xfd;
      fclose(__stream);
      local_43c = __stream;
    }
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail(local_43c,local_438);
  }
  return 0;
}



void tab_complete_file_menu(terminal *term,void *path_,void *dlg_data_)

{
  auto_complete_file(term,0,(uchar *)path_,set_complete_file_menu,tab_complete_file_menu,dlg_data_);
  return;
}



void do_tab_compl_file(dialog_data *dlg_data,list_head_elinks *history)

{
  int iVar1;
  int *piVar2;
  uchar *in_EDX;
  
  iVar1 = dlg_data->selected_widget_id;
  piVar2 = get_opt_(cmdline_options,in_EDX);
  if (*piVar2 == 0) {
    tab_complete_file_menu(dlg_data->win->term,dlg_data->widgets_data[iVar1].cdata,dlg_data);
  }
  return;
}



void set_complete_file_menu(terminal *term,void *filename_,void *dlg_data_)

{
  int iVar1;
  bool bVar2;
  size_t sVar3;
  void *pvVar4;
  size_t __n;
  
  iVar1 = *(int *)((int)dlg_data_ + 0x20);
  if ((assert_failed == 0) &&
     (bVar2 = 1 < *(int *)(*(int *)((int)dlg_data_ + iVar1 * 0x30 + 0x28) + 0x2c) - 1U,
     assert_failed = ZEXT14(bVar2), bVar2)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inphist.c";
    errline = 0xa6;
    elinks_internal((uchar *)"assertion widget_is_textfield(widget_data) failed!");
  }
  sVar3 = strlen((char *)filename_);
  pvVar4 = (void *)(iVar1 * 0x30 + (int)dlg_data_);
  __n = *(int *)(*(int *)((int)pvVar4 + 0x28) + 0x10) - 1;
  if ((int)sVar3 <= (int)__n) {
    __n = sVar3;
  }
  memcpy(*(void **)((int)pvVar4 + 0x2c),filename_,__n);
  *(undefined *)(*(int *)((int)pvVar4 + 0x2c) + __n) = 0;
  pvVar4 = (void *)((iVar1 * 3 + 3) * 0x10 + (int)dlg_data_);
  *(size_t *)((int)pvVar4 + 0x14) = __n;
  *(undefined4 *)((int)pvVar4 + 0x10) = 0;
  mem_free(filename_);
  redraw_dialog((dialog_data *)dlg_data_,1);
  return;
}



void __regparm3 tab_compl_n(dialog_data *dlg_data,uchar *item,int len)

{
  int iVar1;
  bool bVar2;
  window **ppwVar3;
  window *__n;
  
  iVar1 = dlg_data->selected_widget_id;
  if ((assert_failed == 0) &&
     (bVar2 = 1 < (dlg_data->widgets_data[iVar1].widget)->type + ~WIDGET_CHECKBOX,
     assert_failed = ZEXT14(bVar2), bVar2)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inphist.c";
    errline = 0x1f;
    elinks_internal((uchar *)"assertion widget_is_textfield(widget_data) failed!");
  }
  ppwVar3 = &dlg_data->win + iVar1 * 0xc;
  __n = (window *)((int)ppwVar3[10]->data + -1);
  if (len <= (int)__n) {
    __n = (window *)len;
  }
  memcpy(ppwVar3[0xb],item,(size_t)__n);
  *(undefined *)((int)&__n->next + (int)&ppwVar3[0xb]->next) = 0;
  (&dlg_data->win + (iVar1 * 3 + 3) * 4)[5] = __n;
  (&dlg_data->win + (iVar1 * 3 + 3) * 4)[4] = (window *)0x0;
  redraw_dialog(dlg_data,1);
  return;
}



void menu_tab_compl(terminal *term,void *item_,void *dlg_data_)

{
  size_t len;
  
  len = strlen((char *)item_);
  tab_compl_n((dialog_data *)dlg_data_,(uchar *)item_,len);
  return;
}



// WARNING: Removing unreachable block (ram,0x0806078a)

void do_tab_compl_unambiguous(dialog_data *dlg_data,list_head_elinks *history)

{
  int iVar1;
  char cVar2;
  int iVar3;
  list_head_elinks *__n;
  string *psVar4;
  uchar *puVar5;
  byte bVar6;
  list_head_elinks *__src;
  uint uVar7;
  uint uVar8;
  list_head_elinks *plVar9;
  uint size;
  list_head_elinks *plVar10;
  list_head_elinks *plVar11;
  bool bVar12;
  list_head_elinks *local_30;
  string completion;
  
  iVar3 = dlg_data->selected_widget_id;
  plVar9 = (list_head_elinks *)history->next;
  if (plVar9 == history) {
    return;
  }
  local_30 = (list_head_elinks *)0x0;
  plVar11 = plVar9 + 1;
  plVar10 = (list_head_elinks *)0x0;
LAB_080607e8:
  __src = (list_head_elinks *)dlg_data->widgets_data[iVar3].cdata;
  cVar2 = *(char *)&plVar9[1].next;
  if (cVar2 != '\0') goto LAB_08060798;
LAB_080607f5:
  __n = (list_head_elinks *)0x0;
  __src = plVar11;
  do {
    if ((int)__n < (&dlg_data->box)[(iVar3 + 1) * 3].width) {
LAB_080607d2:
      __n = local_30;
      __src = plVar10;
    }
    else {
      plVar11 = __src;
      if (plVar10 == (list_head_elinks *)0x0) {
        do {
          plVar10 = plVar11;
          uVar7 = (int)plVar10->next + 0xfefefeffU & ~(uint)plVar10->next;
          uVar8 = uVar7 & 0x80808080;
          plVar11 = (list_head_elinks *)&plVar10->prev;
        } while (uVar8 == 0);
        bVar12 = (uVar7 & 0x8080) == 0;
        bVar6 = (byte)uVar8;
        if (bVar12) {
          bVar6 = (byte)(uVar8 >> 0x10);
        }
        __n = (list_head_elinks *)((int)&plVar10->prev + 2);
        if (!bVar12) {
          __n = (list_head_elinks *)&plVar10->prev;
        }
        __n = (list_head_elinks *)((int)__n + ((-3 - (uint)CARRY1(bVar6,bVar6)) - (int)__src));
      }
      else {
        __src = plVar10;
        if ((int)local_30 <= (int)__n) goto LAB_080607d2;
      }
    }
    plVar9 = (list_head_elinks *)plVar9->next;
    if (plVar9 == history) {
      if (__src == (list_head_elinks *)0x0) {
        return;
      }
      psVar4 = init_string(&completion);
      if (psVar4 == (string *)0x0) {
        return;
      }
      if (assert_failed == 0) {
        if ((int)__n < 0) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_0806081b;
        }
        else {
          assert_failed = 0;
          if (__n == (list_head_elinks *)0x0) goto LAB_08060825;
        }
        iVar1 = (int)&__n->next + completion.length;
        uVar7 = completion.length + 0xffU >> 8;
        uVar8 = completion.length + 0xffU & 0xffffff00;
        size = iVar1 + 0x100U & 0xffffff00;
        if (uVar8 <= size && size + uVar7 * -0x100 != 0) {
          puVar5 = (uchar *)mem_realloc(completion.source,size);
          if (puVar5 == (uchar *)0x0) goto LAB_08060825;
          completion.source = puVar5;
          memset(puVar5 + uVar8,0,size + uVar7 * -0x100);
        }
        if (completion.source != (uchar *)0x0) {
          memcpy(completion.source + completion.length,__src,(size_t)__n);
          completion.source[iVar1] = '\0';
          completion.length = iVar1;
        }
      }
      else {
LAB_0806081b:
        assert_failed = 0;
      }
LAB_08060825:
      add_to_string(&completion,
                    dlg_data->widgets_data[iVar3].cdata + (&dlg_data->box)[(iVar3 + 1) * 3].width);
      tab_compl_n(dlg_data,completion.source,completion.length);
      done_string(&completion);
      return;
    }
    plVar11 = plVar9 + 1;
    plVar10 = __src;
    local_30 = __n;
    if (__src == (list_head_elinks *)0x0) goto LAB_080607e8;
    cVar2 = *(char *)&plVar9[1].next;
    if (cVar2 == '\0') goto LAB_080607f5;
LAB_08060798:
    __n = plVar11;
    if (cVar2 != *(char *)&__src->next) goto LAB_080607f5;
    do {
      __n = (list_head_elinks *)((int)&__n->next + 1);
      if (*(char *)&__n->next == '\0') break;
      __src = (list_head_elinks *)((int)&__src->next + 1);
    } while (*(char *)&__n->next == *(char *)&__src->next);
    __n = (list_head_elinks *)((int)__n - (int)plVar11);
    __src = plVar11;
  } while( true );
}



void do_tab_compl(dialog_data *dlg_data,list_head_elinks *history)

{
  list_head_elinks *data;
  terminal *term;
  int iVar1;
  uchar *item;
  int iVar2;
  size_t __n;
  list_head_elinks *plVar3;
  int local_34;
  menu_item *local_20 [4];
  
  term = dlg_data->win->term;
  iVar1 = dlg_data->selected_widget_id;
  __n = (&dlg_data->box)[iVar1 * 3 + 3].width;
  local_20[0] = new_menu(FREE_LIST|NO_INTL);
  if (local_20[0] != (menu_item *)0x0) {
    plVar3 = (list_head_elinks *)history->next;
    if (plVar3 != history) {
      local_34 = 0;
      do {
        while( true ) {
          data = plVar3 + 1;
          iVar2 = strncmp((char *)dlg_data->widgets_data[iVar1].cdata,(char *)data,__n);
          if (iVar2 != 0) break;
          add_to_menu(local_20,(uchar *)data,(uchar *)0x0,ACT_MAIN_NONE,menu_tab_compl,data,NO_FLAG)
          ;
          local_34 = local_34 + 1;
          plVar3 = (list_head_elinks *)plVar3->next;
          if (plVar3 == history) goto LAB_08060a51;
        }
        plVar3 = (list_head_elinks *)plVar3->next;
      } while (plVar3 != history);
LAB_08060a51:
      if (1 < local_34) {
        do_menu_selected(term,local_20[0],dlg_data,local_34 + -1,0);
        return;
      }
      if (local_34 == 1) {
        item = (uchar *)local_20[0]->data;
        __n = strlen((char *)item);
        tab_compl_n(dlg_data,item,__n);
      }
    }
    mem_free(local_20[0]);
  }
  return;
}



void init_leds(module *module)

{
  timer_duration_backup = 0;
  return;
}



void set_led_value(led *led,uchar value)

{
  uint uVar1;
  
  if ((uchar)(*(ushort *)led >> 2) != value) {
    uVar1 = (uint)(*(ushort *)led & 0xfc03) | (uint)value << 2;
    *(short *)led = (short)uVar1;
    *(byte *)led = (byte)uVar1 | 2;
  }
  return;
}



void unset_led_value(led *led)

{
  ushort uVar1;
  
  if ((char)(*(ushort *)led >> 2) != '-') {
    uVar1 = *(ushort *)led & 0xfc03;
    *(ushort *)led = uVar1 | 0xb4;
    *(byte *)led = (byte)uVar1 | 0xb6;
  }
  return;
}



void init_led_panel(led_panel *leds)

{
  int iVar1;
  ushort uVar2;
  
  iVar1 = 0;
  do {
    *(byte *)&leds->leds[iVar1].field_0x0 = *(byte *)&leds->leds[iVar1].field_0x0 & 0xfe;
    uVar2 = *(ushort *)&leds->leds[iVar1].field_0x0;
    if ((char)(uVar2 >> 2) != '-') {
      uVar2 = uVar2 & 0xfc03;
      *(ushort *)&leds->leds[iVar1].field_0x0 = uVar2 | 0xb4;
      *(byte *)&leds->leds[iVar1].field_0x0 = (byte)uVar2 | 0xb6;
    }
    iVar1 = iVar1 + 1;
  } while (iVar1 != 6);
  return;
}



led * register_led(session *ses,int number)

{
  byte bVar1;
  
  if ((uint)number < 6) {
    number = number + 0x28;
    bVar1 = *(byte *)(&(ses->history).current + number);
    if ((bVar1 & 1) == 0) {
      *(byte *)(&(ses->history).current + number) = bVar1 | 1;
      return (led *)(&(ses->history).current + number);
    }
  }
  return (led *)0x0;
}



void unregister_led(led *led)

{
  ushort uVar1;
  
  if ((assert_failed == 0) && (assert_failed = ((uint)*(byte *)led ^ 1) & 1, assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/leds.c";
    errline = 0x155;
    elinks_internal((uchar *)"assertion led->used__ failed: Attempted to unregister unused led!");
  }
  *(byte *)led = *(byte *)led & 0xfe;
  if ((char)(*(ushort *)led >> 2) != '-') {
    uVar1 = *(ushort *)led & 0xfc03;
    *(ushort *)led = uVar1 | 0xb4;
    *(byte *)led = (byte)uVar1 | 0xb6;
  }
  return;
}



void menu_leds_info(terminal *term,void *xxx,void *xxxx)

{
  uchar *text;
  
  text = msg_text(term,(uchar *)
                       "What the different LEDs indicate:\n\n[SIJP--]\n |||||`- Unused\n ||||`-- Unused\n |||`--- A JavaScript pop-up window was blocked\n ||`---- A JavaScript error has occurred\n |`----- The state of insert mode for text-input form-fields\n |       \'i\' means modeless, \'I\' means insert mode is on\n `------ Whether an SSL connection was used\n\n\'-\' generally indicates that the LED is off."
                 );
  info_box(term,MSGBOX_FREE_TEXT|MSGBOX_SCROLLABLE,(uchar *)"LED indicators",ALIGN_LEFT,text);
  return;
}



void draw_leds(session *ses)

{
  location **pplVar1;
  terminal *term;
  int iVar2;
  int x;
  int *piVar3;
  tm *__tp;
  size_t sVar4;
  terminal *ptVar5;
  int x_00;
  int iVar6;
  byte bVar7;
  byte *pbVar8;
  uint uVar9;
  uint uVar10;
  color_pair *color;
  int iVar11;
  int y;
  char *x_01;
  int in_GS_OFFSET;
  bool bVar12;
  timer_id_T *local_cc;
  char *local_c8;
  terminal *local_88;
  undefined4 local_64;
  uchar s [64];
  int local_20;
  
  color = (color_pair *)0x0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  term = ses->tab->term;
  iVar2 = term->width;
  x = iVar2 + -9;
  term->leds_length = 0;
  local_c8 = "ui.timer.enable";
  y = term->height + -1;
  local_cc = (timer_id_T *)config_options;
  piVar3 = get_opt_(config_options,(uchar *)0x0);
  if (*piVar3 == 2) {
    local_c8 = "status.status-text";
    local_cc = (timer_id_T *)term;
    color = get_bfu_color(term,(uchar *)"status.status-text");
    if (color != (color_pair *)0x0) {
      iVar11 = term->leds_length;
      iVar6 = get_timer_duration();
      local_c8 = (char *)0x40;
      local_cc = (timer_id_T *)(terminal *)s;
      __snprintf_chk((terminal *)s,0x40,1,0x40,&DAT_08127765,iVar6);
      ptVar5 = (terminal *)s;
      do {
        local_88 = ptVar5;
        uVar9 = (uint)(local_88->next[-0xbf43].cwd + 0xbf) & ~(uint)local_88->next;
        uVar10 = uVar9 & 0x80808080;
        ptVar5 = (terminal *)&local_88->prev;
      } while (uVar10 == 0);
      bVar12 = (uVar9 & 0x8080) == 0;
      bVar7 = (byte)uVar10;
      if (bVar12) {
        bVar7 = (byte)(uVar10 >> 0x10);
      }
      if (bVar12) {
        ptVar5 = (terminal *)((int)&local_88->prev + 2);
      }
      iVar6 = (int)ptVar5 + ((-3 - (uint)CARRY1(bVar7,bVar7)) - (int)(terminal *)s);
      x_00 = iVar6 + -1;
      if (-1 < x_00) {
        pbVar8 = (byte *)((int)(terminal *)s + x_00);
        x_01 = (char *)((iVar6 + -1 + x) - iVar6);
        do {
          bVar7 = *pbVar8;
          pbVar8 = pbVar8 + -1;
          local_cc = (timer_id_T *)term;
          local_c8 = x_01;
          draw_char(term,(int)x_01,y,(uint)bVar7,0,color);
          x_00 = x_00 + -1;
          x_01 = x_01 + -1;
        } while (-1 < x_00);
      }
      term->leds_length = iVar6 + iVar11;
      goto LAB_08060cdd;
    }
  }
  else {
LAB_08060cdd:
    if (led_options[5].option_elinks.value == 0) goto LAB_08060de3;
    if (color == (color_pair *)0x0) {
      local_c8 = "status.status-text";
      local_cc = (timer_id_T *)term;
      color = get_bfu_color(term,(uchar *)"status.status-text");
      if (color == (color_pair *)0x0) goto end;
    }
    if (led_options[1].option_elinks.value != 0) {
      iVar11 = term->leds_length;
      local_64 = time((time_t *)0x0);
      __tp = localtime(&local_64);
      sVar4 = strftime((char *)s,0x40,led_options[2].option_elinks.value,__tp);
      iVar6 = sVar4 - 1;
      s[sVar4] = '\0';
      if (-1 < iVar6) {
        pbVar8 = s + iVar6;
        x_00 = ((sVar4 - 1) + (x - iVar11)) - sVar4;
        do {
          bVar7 = *pbVar8;
          pbVar8 = pbVar8 + -1;
          draw_char(term,x_00,y,(uint)bVar7,0,color);
          iVar6 = iVar6 + -1;
          x_00 = x_00 + -1;
        } while (-1 < iVar6);
      }
      term->leds_length = sVar4 + iVar11;
    }
    draw_char(term,x,y,0x5b,0,color);
    iVar11 = 0;
    x = iVar2 + -8;
    do {
      iVar6 = iVar11 + 0x28;
      iVar11 = iVar11 + 1;
      draw_char(term,x,y,(uint)(*(ushort *)(&(ses->history).current + iVar6) >> 2) & 0xff,0,color);
      pplVar1 = &(ses->history).current + iVar6;
      *(byte *)pplVar1 = *(byte *)pplVar1 & 0xfd;
      x = x + 1;
    } while (iVar11 != 6);
    local_c8 = (char *)(iVar2 + -2);
    local_cc = (timer_id_T *)term;
    draw_char(term,(int)local_c8,y,0x5d,0,color);
    term->leds_length = term->leds_length + 8;
  }
end:
  if ((drawing == 0) && (redraw_timer == (timer_id_T)0x0)) {
    local_c8 = (char *)0x64;
    local_cc = &redraw_timer;
    install_timer(&redraw_timer,100,redraw_leds,(void *)0x0);
  }
LAB_08060de3:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail(local_cc,local_c8);
  }
  return;
}



void redraw_leds(void *xxx)

{
  session *ses;
  int *piVar1;
  int iVar2;
  int iVar3;
  uchar *in_EDX;
  
  if ((led_options[5].option_elinks.value == 0) &&
     (piVar1 = get_opt_(config_options,in_EDX), *piVar1 != 2)) {
    redraw_timer = (timer_id_T)0x0;
  }
  else {
    install_timer(&redraw_timer,100,redraw_leds,(void *)0x0);
    if (drawing == 0) {
      drawing = 1;
      ses = (session *)sessions.next;
      do {
        if (ses == (session *)&sessions) {
          drawing = 0;
          return;
        }
        iVar3 = timer_duration_backup;
        if (led_options[1].option_elinks.value == 0) {
          iVar2 = 0;
          do {
            if ((*(byte *)((ses->status).leds.leds + iVar2) & 2) != 0) goto LAB_08061148;
            iVar2 = iVar2 + 1;
          } while (iVar2 != 6);
          iVar3 = get_timer_duration();
          if (iVar3 != timer_duration_backup) goto LAB_08061148;
        }
        else {
LAB_08061148:
          timer_duration_backup = iVar3;
          redraw_terminal(ses->tab->term);
          draw_leds(ses);
        }
        ses = ses->next;
      } while( true );
    }
  }
  return;
}



void done_leds(module *module)

{
  kill_timer(&redraw_timer);
  return;
}



void add_dlg_listbox(dialog *dlg,void *box_data)

{
  int iVar1;
  
  iVar1 = dlg->number_of_widgets;
  dlg->number_of_widgets = iVar1 + 1;
  (&dlg->title + iVar1 * 0xc)[0x14] = (uchar *)0x4;
  (&dlg->title + iVar1 * 0xc)[0xc] = box_data;
  return;
}



listbox_item *
traverse_listbox_items_list
          (listbox_item *item,listbox_data *box,int offset,int follow_visible,
          anon_subr_int_listbox_item_ptr_void_ptr_int_ptr *fn,void *d)

{
  byte bVar1;
  bool bVar2;
  bool bVar3;
  int iVar4;
  listbox_item *plVar5;
  listbox_item *plVar6;
  listbox_item *plVar7;
  bool bVar8;
  listbox_item *local_24;
  
  if (item == (listbox_item *)0x0) {
    return (listbox_item *)0x0;
  }
  bVar8 = offset == 0;
  if (bVar8) {
    offset = 1;
  }
  local_24 = item;
  bVar2 = false;
  plVar5 = local_24;
LAB_08061208:
  local_24 = plVar5;
  plVar6 = item;
  if (bVar2) {
    return local_24;
  }
  do {
    if (offset == 0) {
      return local_24;
    }
    item = (*box->ops->get_root)(plVar6);
    plVar7 = plVar6->prev;
    plVar5 = plVar6->next;
    if ((fn != (anon_subr_int_listbox_item_ptr_void_ptr_int_ptr *)0x0) &&
       ((follow_visible == 0 || ((*(byte *)&plVar6->field_0x18 & 2) != 0)))) {
      iVar4 = (*fn)(plVar6,d,&offset);
      if (iVar4 != 0) {
        plVar6 = (listbox_item *)0x0;
      }
      if (offset == 0) {
        bVar8 = false;
        bVar2 = false;
        item = plVar6;
        plVar5 = local_24;
        goto LAB_08061208;
      }
    }
    if (offset < 1) {
      if (!bVar8) {
        offset = offset + 1;
      }
      bVar3 = false;
      if (item == (listbox_item *)0x0) {
LAB_0806143c:
        item = plVar6;
        bVar2 = true;
        if ((listbox_item *)box->items == plVar7) goto LAB_08061453;
        if (bVar3) goto LAB_08061451;
      }
      else {
        if ((listbox_item *)&item->child == plVar7) {
          plVar5 = (*box->ops->get_root)(item);
          plVar7 = item->prev;
          if (plVar5 == (listbox_item *)0x0) {
            bVar3 = true;
            plVar6 = item;
            goto LAB_0806143c;
          }
          bVar2 = false;
          goto LAB_08061457;
        }
      }
      item = plVar7;
      (*box->ops->get_root)(item);
      if (item == (listbox_item *)0x0) goto LAB_08061414;
      if ((list_head_elinks *)(item->child).next == &item->child) goto LAB_0806147a;
      bVar1 = *(byte *)&item->field_0x18;
      break;
    }
    if (!bVar8) {
      offset = offset + -1;
    }
    if ((((plVar6 == (listbox_item *)0x0) ||
         (plVar7 = (listbox_item *)(plVar6->child).next, plVar7 == (listbox_item *)&plVar6->child))
        || ((*(byte *)&plVar6->field_0x18 & 1) == 0)) ||
       ((follow_visible != 0 && ((*(byte *)&plVar6->field_0x18 & 2) == 0)))) {
      plVar7 = (listbox_item *)0x0;
      if (item == (listbox_item *)0x0) {
LAB_08061357:
        if ((plVar5 == (listbox_item *)0x0) || ((listbox_item *)box->items == plVar5)) {
          plVar5 = plVar6;
          if (plVar7 != (listbox_item *)0x0) {
            (*box->ops->get_root)(plVar7);
            plVar5 = plVar7;
          }
          bVar2 = true;
          goto done_down;
        }
      }
      else {
        plVar7 = plVar6;
        if (plVar5 == (listbox_item *)&item->child) {
          while( true ) {
            plVar6 = item;
            item = (*box->ops->get_root)(plVar6);
            plVar5 = plVar6->next;
            if (item == (listbox_item *)0x0) break;
            if ((listbox_item *)&item->child != plVar5) goto LAB_08061370;
            if (plVar7 == (listbox_item *)0x0) {
              plVar7 = plVar6;
            }
          }
          goto LAB_08061357;
        }
      }
LAB_08061370:
      (*box->ops->get_root)(plVar5);
      bVar2 = false;
    }
    else {
      (*box->ops->get_root)(plVar7);
      bVar2 = false;
      plVar5 = plVar7;
    }
done_down:
    if ((plVar5 != (listbox_item *)0x0) &&
       ((item = plVar5, follow_visible == 0 || ((*(byte *)&plVar5->field_0x18 & 2) != 0))))
    goto LAB_08061208;
    offset = offset + 1;
    plVar6 = plVar5;
    if (bVar2) {
      return local_24;
    }
  } while( true );
joined_r0x080613d6:
  if ((bVar1 & 1) == 0) goto LAB_0806147a;
  if ((follow_visible != 0) && ((bVar1 & 2) == 0)) goto LAB_08061451;
  item = (listbox_item *)(item->child).prev;
  (*box->ops->get_root)(item);
  if (item == (listbox_item *)0x0) goto LAB_08061414;
  if ((list_head_elinks *)(item->child).next == &item->child) goto LAB_0806147a;
  bVar1 = *(byte *)&item->field_0x18;
  goto joined_r0x080613d6;
LAB_08061451:
  bVar2 = false;
LAB_08061453:
  if (item == (listbox_item *)0x0) goto LAB_0806146c;
LAB_08061457:
  plVar5 = item;
  if ((follow_visible == 0) || ((*(byte *)&item->field_0x18 & 2) != 0)) goto LAB_08061208;
LAB_0806146c:
  offset = offset + -1;
  plVar5 = local_24;
  goto LAB_08061208;
LAB_08061414:
  bVar2 = false;
  item = (listbox_item *)0x0;
  goto LAB_0806146c;
LAB_0806147a:
  bVar2 = false;
  goto LAB_08061457;
}



int calc_dist(listbox_item *item,void *data_,int *offset)

{
  if (-1 < *offset) {
    if (*offset != 0) {
      *(int *)data_ = *(int *)data_ + 1;
    }
    return 0;
  }
  *(int *)data_ = *(int *)data_ + -1;
  return 0;
}



int test_search(listbox_item *item,void *data_,int *offset)

{
  if (*(listbox_item **)((int)data_ + 4) != item) {
    *(int *)((int)data_ + 0x18) = *(int *)((int)data_ + 0x18) + 1;
    return 0;
  }
  *offset = 0;
  return 0;
}



int check_old_state(listbox_item *item,void *info_,int *offset)

{
  if (*(listbox_item **)((int)info_ + 0xc) == item) {
    *(undefined4 *)((int)info_ + 0xc) = 0;
  }
  else {
    if (*(listbox_item **)((int)info_ + 0x10) == item) {
      *(undefined4 *)((int)info_ + 0x10) = 0;
    }
    if (*(listbox_item **)((int)info_ + 0xc) != (listbox_item *)0x0) {
      return 0;
    }
  }
  if (*(int *)((int)info_ + 0x10) == 0) {
    *offset = 0;
  }
  return 0;
}



listbox_data * get_listbox_widget_data(widget_data *widget_data)

{
  bool bVar1;
  
  if ((assert_failed == 0) &&
     (bVar1 = widget_data->widget->type != WIDGET_LISTBOX, assert_failed = ZEXT14(bVar1), bVar1)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/listbox.c";
    errline = 0x26;
    elinks_internal((uchar *)"assertion widget_data->widget->type == WIDGET_LISTBOX failed!");
    return (listbox_data *)widget_data->widget->data;
  }
  return (listbox_data *)widget_data->widget->data;
}



widget_handler_status_T init_listbox(dialog_data *dlg_data,widget_data *widget_data)

{
  void *pvVar1;
  listbox_ops *plVar2;
  listbox_data *plVar3;
  listbox_data *box;
  listbox_item *plVar4;
  listbox_item *plVar5;
  
  pvVar1 = dlg_data->dlg->udata2;
  box = get_listbox_widget_data(widget_data);
  if ((*(list_head_elinks **)((int)pvVar1 + 0x28) == (list_head_elinks *)((int)pvVar1 + 0x28)) ||
     (*(int *)((int)pvVar1 + 0x5c) == 0)) goto LAB_08061692;
  box->next = *(listbox_data **)((int)pvVar1 + 0x44);
  box->prev = *(listbox_data **)((int)pvVar1 + 0x48);
  box->ops = *(listbox_ops **)((int)pvVar1 + 0x4c);
  box->sel = *(listbox_item **)((int)pvVar1 + 0x50);
  box->top = *(listbox_item **)((int)pvVar1 + 0x54);
  box->sel_offset = *(int *)((int)pvVar1 + 0x58);
  box->items = *(list_head_elinks **)((int)pvVar1 + 0x5c);
  traverse_listbox_items_list(*(listbox_item **)((int)pvVar1 + 0x28),box,0,0,check_old_state,box);
  plVar5 = (listbox_item *)0x0;
  if (box->sel == (listbox_item *)0x0) {
    plVar5 = *(listbox_item **)((int)pvVar1 + 0x50);
    box->sel = plVar5;
    if (box->top == (listbox_item *)0x0) goto LAB_080616d0;
LAB_08061687:
    plVar4 = (listbox_item *)0x0;
    box->top = (listbox_item *)0x0;
  }
  else {
    box->sel = (listbox_item *)0x0;
    if (box->top != (listbox_item *)0x0) goto LAB_08061687;
LAB_080616d0:
    plVar4 = *(listbox_item **)((int)pvVar1 + 0x54);
    box->top = plVar4;
  }
  if (plVar5 == (listbox_item *)0x0) {
    box->sel = plVar4;
  }
  if (plVar4 == (listbox_item *)0x0) {
    box->top = box->sel;
  }
LAB_08061692:
  plVar2 = *(listbox_ops **)((int)pvVar1 + 0x40);
  box->items = (list_head_elinks *)((int)pvVar1 + 0x28);
  box->ops = plVar2;
  plVar3 = *(listbox_data **)((int)pvVar1 + 0x10);
  box->prev = (listbox_data *)((int)pvVar1 + 0x10);
  box->next = plVar3;
  *(listbox_data **)((int)pvVar1 + 0x10) = box;
  box->next->prev = box;
  return EVENT_PROCESSED;
}



void listbox_sel_move(widget_data *widget_data,int dist)

{
  listbox_item *plVar1;
  int iVar2;
  listbox_data *box;
  listbox_item *item;
  listbox_item *item_00;
  
  box = get_listbox_widget_data(widget_data);
  item_00 = ((listbox_item *)box->items)->next;
  if ((listbox_item *)box->items == item_00) {
    return;
  }
  item = box->top;
  if (item == (listbox_item *)0x0) {
    plVar1 = box->sel;
    box->top = item_00;
    item = item_00;
  }
  else {
    plVar1 = box->sel;
  }
  if (plVar1 == (listbox_item *)0x0) {
    box->sel = item;
    item = box->top;
  }
  if ((item == (listbox_item *)0x0) || ((*(byte *)&item->field_0x18 & 2) != 0)) {
    item_00 = box->sel;
  }
  else {
    item_00 = traverse_listbox_items_list
                        (item,box,1,1,(anon_subr_int_listbox_item_ptr_void_ptr_int_ptr *)0x0,
                         (void *)0x0);
    box->top = item_00;
    box->sel = item_00;
  }
  if (dist == 0) {
    if ((*(byte *)&item_00->field_0x18 & 2) != 0) goto LAB_08061775;
    dist = 1;
  }
  item_00 = traverse_listbox_items_list(item_00,box,dist,1,calc_dist,&box->sel_offset);
  box->sel = item_00;
LAB_08061775:
  if (box->sel_offset < 0) {
    box->sel_offset = 0;
    box->top = box->sel;
  }
  else {
    iVar2 = (widget_data->box).height;
    if (iVar2 <= box->sel_offset) {
      box->sel_offset = iVar2 + -1;
      item_00 = traverse_listbox_items_list
                          (box->sel,box,1 - (widget_data->box).height,1,
                           (anon_subr_int_listbox_item_ptr_void_ptr_int_ptr *)0x0,(void *)0x0);
      box->top = item_00;
    }
  }
  return;
}



widget_handler_status_T kbd_listbox(dialog_data *dlg_data,widget_data *widget_data)

{
  widget_data *widget_data_00;
  listbox_item *plVar1;
  listbox_ops *plVar2;
  action_id_T aVar3;
  listbox_data *plVar4;
  int local_18;
  
  if (dlg_data->term_event->ev != EVENT_KBD) {
    return EVENT_NOT_PROCESSED;
  }
  widget_data_00 = dlg_data->widgets_data;
  aVar3 = kbd_action(KEYMAP_MENU,dlg_data->term_event,(int *)0x0);
  switch(aVar3) {
  case 3:
    plVar4 = get_listbox_widget_data(widget_data_00);
    plVar2 = plVar4->ops;
    if (((plVar2 != (listbox_ops *)0x0) &&
        (plVar2->delete != (anon_subr_void_listbox_item_ptr_int_for_delete *)0x0)) &&
       (plVar2->can_delete != (anon_subr_int_listbox_item_ptr_for_can_delete *)0x0)) {
      push_hierbox_delete_button(dlg_data,widget_data);
      return EVENT_PROCESSED;
    }
    return EVENT_PROCESSED;
  case 4:
    local_18 = 1;
    break;
  case 5:
    local_18 = 0x7fffffff;
    break;
  default:
    return EVENT_NOT_PROCESSED;
  case 8:
    local_18 = -0x7fffffff;
    break;
  case 10:
    plVar4 = get_listbox_widget_data(widget_data_00);
    plVar1 = plVar4->sel;
    if (plVar1 != (listbox_item *)0x0) {
      *(byte *)&plVar1->field_0x18 =
           *(byte *)&plVar1->field_0x18 & 0xfb |
           (byte)((((uint)(*(byte *)&plVar1->field_0x18 >> 2) ^ 1) & 1) << 2);
      listbox_sel_move(widget_data_00,1);
    }
    goto LAB_080618c0;
  case 0xc:
    plVar4 = get_listbox_widget_data(widget_data_00);
    local_18 = (dlg_data->widgets_data[0].box.height * 2 - plVar4->sel_offset) + -1;
    goto LAB_080618e8;
  case 0xd:
    plVar4 = get_listbox_widget_data(widget_data_00);
    local_18 = -plVar4->sel_offset - dlg_data->widgets_data[0].box.height;
LAB_080618e8:
    listbox_sel_move(widget_data_00,local_18);
    goto LAB_080618c0;
  case 0x14:
    local_18 = -1;
  }
  listbox_sel_move(widget_data_00,local_18);
LAB_080618c0:
  display_widget(dlg_data,widget_data_00);
  return EVENT_PROCESSED;
}



widget_handler_status_T mouse_listbox(dialog_data *dlg_data,widget_data *widget_data)

{
  term_event *ptVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  listbox_data *box;
  widget_handler_status_T wVar5;
  listbox_item *plVar6;
  int local_58;
  
  box = get_listbox_widget_data(widget_data);
  ptVar1 = dlg_data->term_event;
  plVar6 = ((listbox_item *)box->items)->next;
  if ((listbox_item *)box->items != plVar6) {
    if (box->top == (listbox_item *)0x0) {
      box->top = plVar6;
      plVar6 = box->sel;
    }
    else {
      plVar6 = box->sel;
    }
    if (plVar6 == (listbox_item *)0x0) {
      box->sel = box->top;
    }
  }
  uVar2 = *(uint *)((int)&ptVar1->info + 8);
  if ((uVar2 & 0x20) == 0) {
    if ((uVar2 & 7) == 3) {
      local_58 = -1;
    }
    else {
      if ((uVar2 & 7) != 4) goto LAB_08061a33;
      local_58 = 1;
    }
    listbox_sel_move(dlg_data->widgets_data,local_58);
    display_widget(dlg_data,dlg_data->widgets_data);
    wVar5 = EVENT_PROCESSED;
  }
  else {
LAB_08061a33:
    if ((uVar2 & 7) < 3) {
      local_58 = *(int *)((int)&ptVar1->info + 4);
      iVar3 = (widget_data->box).x;
      if ((((iVar3 <= *(int *)&ptVar1->info) && (iVar4 = (widget_data->box).y, iVar4 <= local_58))
          && (*(int *)&ptVar1->info < iVar3 + (widget_data->box).width)) &&
         (local_58 < iVar4 + (widget_data->box).height)) {
        local_58 = local_58 - iVar4;
        box->sel_offset = local_58;
        if (local_58 == 0) {
          plVar6 = box->top;
        }
        else {
          plVar6 = traverse_listbox_items_list
                             (box->top,box,local_58,1,
                              (anon_subr_int_listbox_item_ptr_void_ptr_int_ptr *)0x0,(void *)0x0);
        }
        box->sel = plVar6;
        if ((plVar6 != (listbox_item *)0x0) && (plVar6->type == BI_FOLDER)) {
          local_58 = plVar6->depth * 5 + (widget_data->box).x;
          if ((local_58 <= *(int *)&ptVar1->info) && (*(int *)&ptVar1->info <= local_58 + 2)) {
            *(byte *)&plVar6->field_0x18 =
                 *(byte *)&plVar6->field_0x18 & 0xfe | (*(byte *)&plVar6->field_0x18 ^ 1) & 1;
          }
        }
        display_widget(dlg_data,widget_data);
        return EVENT_PROCESSED;
      }
    }
    wVar5 = EVENT_NOT_PROCESSED;
  }
  return wVar5;
}



// WARNING: Type propagation algorithm not settling

int display_listbox_item(listbox_item *item,void *data_,int *offset)

{
  border_char *pbVar1;
  int x;
  listbox_item_type lVar2;
  listbox_item *plVar3;
  listbox_item *plVar4;
  int iVar5;
  color_pair *color;
  listbox_item *plVar6;
  uchar *string;
  size_t max_cells;
  size_t sVar7;
  terminal *term;
  int x_00;
  byte bVar8;
  int y;
  size_t sVar9;
  int x_01;
  int x_02;
  color_pair *local_5c;
  int local_48;
  int local_44;
  int local_40;
  border_char str [5];
  
  x_00 = item->depth;
  iVar5 = x_00 + 1;
  color = get_bfu_color(*(terminal **)data_,"menu.normal");
  if (*(listbox_item **)(*(int *)((int)data_ + 8) + 0xc) == item) {
    local_5c = get_bfu_color(*(terminal **)data_,"menu.selected");
  }
  else {
    local_5c = color;
    if ((*(byte *)&item->field_0x18 & 4) != 0) {
      local_5c = get_bfu_color(*(terminal **)data_,"menu.marked");
    }
  }
  y = *(int *)((int)data_ + 0x18) + *(int *)(*(int *)((int)data_ + 0x10) + 0xc);
  if (0 < x_00) {
    local_44 = 0;
    local_48 = 0;
    plVar6 = item;
    plVar3 = item;
    x_01 = iVar5;
    local_40 = iVar5;
    do {
      while (plVar4 = plVar6, x_01 != 0) {
        plVar6 = (listbox_item *)0x0;
        if (plVar4 != (listbox_item *)0x0) {
          plVar6 = (listbox_item *)
                   (**(code **)(*(int *)(*(int *)((int)data_ + 8) + 8) + 0x18))(plVar4);
        }
        plVar3 = plVar4;
        x_01 = x_01 + -1;
      }
      x_01 = local_44 + *(int *)(*(int *)((int)data_ + 0x10) + 8);
      draw_text(*(terminal **)data_,x_01,y,"     ",5,0,color);
      if (plVar4 == (listbox_item *)0x0) {
        plVar6 = *(listbox_item **)(*(int *)(*(int *)((int)data_ + 8) + 0x18) + 4);
      }
      else {
        plVar6 = (listbox_item *)(plVar4->child).prev;
      }
      if (plVar6 != plVar3) {
        draw_border_char(*(terminal **)data_,x_01 + 1,y,BORDER_SVLINE,color);
      }
      local_48 = local_48 + 1;
      x_01 = local_40 + -1;
      local_44 = local_44 + 5;
      plVar6 = item;
      plVar3 = item;
      local_40 = x_01;
    } while (local_48 < x_00);
  }
  if (iVar5 == 0) goto LAB_08061d5c;
  str[0] = 0x20;
  str[1] = BORDER_SRTEE;
  str[2] = BORDER_SHLINE;
  str[3] = BORDER_SHLINE;
  str[4] = 0x20;
  lVar2 = item->type;
  if (lVar2 == BI_FOLDER) {
    bVar8 = *(byte *)&item->field_0x18;
    str[0] = 0x5b;
    str[2] = 0x5d;
    str[1] = (-(uint)((bVar8 & 1) == 0) & 0xfffffffe) + 0x2d;
  }
  else {
    if ((lVar2 == BI_LEAF) || (lVar2 == BI_SEPARATOR)) {
      x_01 = (**(code **)(*(int *)(*(int *)((int)data_ + 8) + 8) + 0x18))(item);
      if (x_01 == 0) {
        plVar3 = *(listbox_item **)(*(int *)((int)data_ + 8) + 0x18);
        if (plVar3->next != item) {
          plVar3 = plVar3->prev;
          goto joined_r0x08062010;
        }
        str[1] = BORDER_SULCORNER;
      }
      else {
        plVar3 = *(listbox_item **)(x_01 + 0xc);
joined_r0x08062010:
        if (plVar3 == item) {
          str[1] = BORDER_SDLCORNER;
          bVar8 = *(byte *)&item->field_0x18;
          goto LAB_08061d05;
        }
      }
      bVar8 = *(byte *)&item->field_0x18;
    }
    else {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/listbox.c";
      errline = 0x1aa;
      elinks_internal((uchar *)"Unknown item type");
      bVar8 = *(byte *)&item->field_0x18;
    }
  }
LAB_08061d05:
  if ((bVar8 & 4) != 0) {
    str[4] = 0x2a;
  }
  x_02 = 0;
  x_01 = *(int *)(*(int *)((int)data_ + 0x10) + 8);
  do {
    pbVar1 = str + x_02;
    x = x_02 + x_00 * 5 + x_01;
    x_02 = x_02 + 1;
    draw_border_char(*(terminal **)data_,x,y,*pbVar1,color);
  } while (x_02 != 5);
LAB_08061d5c:
  x_00 = *(int *)((int)data_ + 0x10);
  x_01 = *(int *)(x_00 + 8) + iVar5 * 5;
  if (item->type == BI_SEPARATOR) {
    x_00 = iVar5 * -5 + *(int *)(x_00 + 0x10);
    if (0 < x_00) {
      iVar5 = 0;
      do {
        x_02 = iVar5 + x_01;
        iVar5 = iVar5 + 1;
        draw_border_char(*(terminal **)data_,x_02,y,BORDER_SHLINE,local_5c);
      } while (iVar5 < x_00);
    }
  }
  else {
    x_02 = *(int *)(*(int *)((int)data_ + 8) + 8);
    if ((x_02 == 0) || (*(code **)(x_02 + 0x28) == (code *)0x0)) {
      if (assert_failed == 0) {
        if ((x_02 == 0) || (*(int *)(x_02 + 0x10) == 0)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/listbox.c";
          errline = 0x1ca;
          elinks_internal((uchar *)"assertion ops && ops->get_info failed!");
        }
        else {
          assert_failed = 0;
        }
      }
      string = (uchar *)(**(code **)(x_02 + 0xc))(item,*(undefined4 *)data_);
      if (string == (uchar *)0x0) {
        return 0;
      }
      max_cells = strlen((char *)string);
      sVar9 = iVar5 * -5 + *(int *)(*(int *)((int)data_ + 0x10) + 0x10);
      sVar7 = 0;
      if (-1 < (int)sVar9) {
        sVar7 = sVar9;
      }
      if ((int)sVar7 < (int)max_cells) {
        max_cells = sVar7;
      }
      term = *(terminal **)data_;
      if ((*(byte *)&term->field_0x38 & 2) != 0) {
        max_cells = utf8_cells2bytes(string,max_cells,(uchar *)0x0);
        term = *(terminal **)data_;
      }
      draw_text(term,x_01,y,string,max_cells,0,local_5c);
      mem_free(string);
    }
    else {
      (**(code **)(x_02 + 0x28))(item,data_,x_01,y,iVar5 * -5 + *(int *)(x_00 + 0x10));
    }
  }
  if (*(listbox_item **)(*(int *)((int)data_ + 8) + 0xc) == item) {
    x_00 = *(int *)(*(int *)((int)data_ + 0x10) + 8) + 5 + item->depth * 5;
    set_cursor(*(terminal **)data_,x_00,y,1);
    *(int *)(**(int **)((int)data_ + 0xc) + 0x20) = x_00;
    *(int *)(**(int **)((int)data_ + 0xc) + 0x24) = y;
  }
  *(int *)((int)data_ + 0x18) = *(int *)((int)data_ + 0x18) + 1;
  return 0;
}



void dlg_format_listbox(terminal *term,widget_data *widget_data,int x,int *y,int w,int max_height,
                       int *rw,format_align align,int format_only)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  uchar *in_EDX;
  int iVar4;
  
  piVar1 = get_opt_(config_options,in_EDX);
  iVar3 = *piVar1;
  iVar4 = max_height + -3;
  if (iVar3 <= max_height + -3) {
    iVar4 = (max_height * 7) / 10 + -3;
    if (iVar4 < iVar3) {
      iVar4 = iVar3;
    }
  }
  iVar3 = *y;
  if (x < 0) {
    x = 0;
  }
  if (iVar3 < 0) {
    iVar3 = 0;
  }
  (widget_data->box).x = x;
  (widget_data->box).y = iVar3;
  iVar3 = w;
  if (w < 0) {
    iVar3 = 0;
  }
  iVar2 = 0;
  if (-1 < iVar4) {
    iVar2 = iVar4;
  }
  (widget_data->box).width = iVar3;
  (widget_data->box).height = iVar2;
  *y = *y + iVar4;
  if (rw != (int *)0x0) {
    *rw = w;
  }
  return;
}



int __regparm3 listbox_item_offset(listbox_data *box,listbox_item *item)

{
  uint uVar1;
  listbox_context ctx;
  
  uVar1 = 0;
  do {
    *(undefined4 *)((int)&ctx.term + uVar1) = 0;
    uVar1 = uVar1 + 4;
  } while (uVar1 < 0x1c);
  ctx.offset = 0;
  ctx.item = item;
  traverse_listbox_items_list((listbox_item *)box->items->next,box,0,1,test_search,&ctx);
  return ctx.offset;
}



void listbox_sel(widget_data *widget_data,listbox_item *item)

{
  listbox_data *box;
  int iVar1;
  int iVar2;
  
  box = get_listbox_widget_data(widget_data);
  iVar1 = listbox_item_offset(box,item);
  iVar2 = listbox_item_offset(box,box->sel);
  listbox_sel_move(widget_data,iVar1 - iVar2);
  return;
}



widget_handler_status_T display_listbox(dialog_data *dlg_data,widget_data *widget_data)

{
  color_pair *color;
  uint uVar1;
  listbox_context data;
  
  data.term = dlg_data->win->term;
  data.box = get_listbox_widget_data(widget_data);
  listbox_sel_move(widget_data,0);
  color = get_bfu_color(data.term,"menu.normal");
  draw_box(data.term,&widget_data->box,' ',0,color);
  uVar1 = 0;
  do {
    *(undefined4 *)((int)&data.term + uVar1) = 0;
    uVar1 = uVar1 + 4;
  } while (uVar1 < 0x1c);
  data.widget_data = widget_data;
  data.dlg_data = dlg_data;
  traverse_listbox_items_list
            ((data.box)->top,data.box,(widget_data->box).height,1,display_listbox_item,&data);
  return EVENT_PROCESSED;
}



int __regparm3 menu_contains(menu_item *m,int f)

{
  uchar *puVar1;
  int iVar2;
  menu_item *m_00;
  
  if (m->func != do_select_submenu) {
    return (uint)(m->data == (void *)f);
  }
  m_00 = (menu_item *)m->data;
  puVar1 = m_00->text;
  while( true ) {
    if (puVar1 == (uchar *)0x0) {
      return 0;
    }
    iVar2 = menu_contains(m_00,f);
    if (iVar2 != 0) break;
    m_00 = m_00 + 1;
    puVar1 = m_00->text;
  }
  return 1;
}



void menu_labels(menu_item *items,uchar *base,uchar **lbls)

{
  uchar *puVar1;
  menu_func_T *pmVar2;
  uchar *local_20 [4];
  
  puVar1 = items->text;
  while (puVar1 != (uchar *)0x0) {
    local_20[0] = "";
    if ((*(byte *)&items->flags & 0x10) == 0) {
      local_20[0] = base;
    }
    local_20[0] = straconcat(local_20[0],items->text,0);
    if (local_20[0] != (uchar *)0x0) {
      pmVar2 = items->func;
      if (pmVar2 == do_select_submenu) {
        add_to_strn(local_20," ");
        menu_labels((menu_item *)items->data,local_20[0],lbls);
        mem_free(local_20[0]);
      }
      else {
        if ((assert_failed == 0) &&
           (assert_failed = ZEXT14(pmVar2 != selected_item), pmVar2 != selected_item)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/listmenu.c";
          errline = 0xbc;
          elinks_internal((uchar *)"assertion item->func == selected_item failed!");
        }
        lbls[(int)items->data] = local_20[0];
      }
    }
    items = items + 1;
    puVar1 = items->text;
  }
  return;
}



// WARNING: Type propagation algorithm not settling

menu_item * detach_menu(list_menu *menu)

{
  menu_item **p;
  menu_item *pmVar1;
  
  pmVar1 = (menu_item *)0x0;
  p = menu->stack;
  if (p != (menu_item **)0x0) {
    if (menu->stack_size != 0) {
      pmVar1 = *p;
    }
    mem_free(p);
  }
  return pmVar1;
}



void free_menu(menu_item *m)

{
  uchar *p;
  menu_item *pmVar1;
  
  if (m != (menu_item *)0x0) {
    p = m->text;
    pmVar1 = m;
    while (p != (uchar *)0x0) {
      mem_free(p);
      if (pmVar1->func == do_select_submenu) {
        free_menu((menu_item *)pmVar1->data);
      }
      pmVar1 = pmVar1 + 1;
      p = pmVar1->text;
    }
    mem_free(m);
    return;
  }
  return;
}



// WARNING: Type propagation algorithm not settling

void destroy_menu(list_menu *menu)

{
  if (menu->stack != (menu_item **)0x0) {
    free_menu(*menu->stack);
  }
  detach_menu(menu);
  return;
}



void new_menu_item(list_menu *menu,uchar *name,int data,int fullname)

{
  uint uVar1;
  uchar *puVar2;
  menu_item_flags local_34;
  menu_item *pmVar3;
  menu_item **mi;
  int iVar4;
  code *local_3c;
  
  uVar1 = menu->stack_size;
  if (name == (uchar *)0x0) {
    menu->stack_size = uVar1 - 1;
    return;
  }
  if ((data == -1) || (uVar1 != 0)) {
    clr_spaces(name);
    if (*name == '\0') {
      mem_free(name);
      name = stracpy(" ");
      if (name == (uchar *)0x0) {
        return;
      }
    }
    if (data != -1) {
      mi = menu->stack + (uVar1 - 1);
      local_3c = selected_item;
      local_34 = ~-(uint)(fullname == 0) & MENU_FULLNAME;
LAB_08062540:
      add_to_menu(mi,name,(uchar *)0x0,ACT_MAIN_NONE,local_3c,(void *)data,local_34);
      if (1 < uVar1) {
        pmVar3 = menu->stack[uVar1 - 2];
        puVar2 = pmVar3->text;
        while (puVar2 != (uchar *)0x0) {
          pmVar3 = pmVar3 + 1;
          puVar2 = pmVar3->text;
        }
        *(menu_item **)&pmVar3[-1].data = *mi;
      }
      return;
    }
    mi = (menu_item **)mem_realloc(menu->stack,menu->stack_size * 4 + 4);
    if (mi != (menu_item **)0x0) {
      menu->stack = mi;
      data = (int)new_menu(NO_INTL);
      if ((menu_item *)data != (menu_item *)0x0) {
        iVar4 = menu->stack_size;
        *(int *)(menu->stack + iVar4) = data;
        iVar4 = iVar4 + 1;
        menu->stack_size = iVar4;
        if (iVar4 != 1) {
          mi = menu->stack + (uVar1 - 1);
          local_34 = SUBMENU;
          local_3c = do_select_submenu;
          goto LAB_08062540;
        }
      }
    }
  }
  mem_free(name);
  return;
}



void add_select_item(list_menu *menu,string *string,string *orig_string,uchar **value,int order,
                    int dont_add)

{
  uchar *puVar1;
  uint data;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(menu == (list_menu *)0x0 || string == (string *)0x0),
     menu == (list_menu *)0x0 || string == (string *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/listmenu.c";
    errline = 0xc9;
    elinks_internal((uchar *)"assertion menu && string failed!");
    puVar1 = string->source;
  }
  else {
    puVar1 = string->source;
  }
  if (puVar1 != (uchar *)0x0) {
    data = order - 1;
    if ((assert_failed == 0) &&
       (assert_failed = data >> 0x1f | (uint)(value == (uchar **)0x0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/listmenu.c";
      errline = 0xcd;
      elinks_internal((uchar *)"assertion value && pos >= 0 failed!");
    }
    if (value[data] == (uchar *)0x0) {
      puVar1 = memacpy(orig_string->source,orig_string->length);
      value[data] = puVar1;
    }
    if (dont_add == 0) {
      new_menu_item(menu,string->source,data,1);
      string->source = (uchar *)0x0;
      string->length = 0;
    }
    else {
      done_string(string);
    }
    done_string(orig_string);
    return;
  }
  return;
}



void init_menu(list_menu *menu)

{
  uchar *name;
  
  menu->stack_size = 0;
  menu->stack = (menu_item **)0x0;
  name = stracpy("");
  new_menu_item(menu,name,-1,0);
  return;
}



void do_select_submenu(terminal *term,void *menu_,void *ses_)

{
  uchar *puVar1;
  menu_item *m;
  int iVar2;
  int f;
  
  iVar2 = get_current_state((session *)ses_);
  puVar1 = *(uchar **)menu_;
  m = (menu_item *)menu_;
  f = 0;
  if (-1 < iVar2) {
    f = iVar2;
  }
  do {
    if (puVar1 == (uchar *)0x0) {
      f = 0;
LAB_0806285a:
      do_menu_selected(term,(menu_item *)menu_,ses_,f,0);
      return;
    }
    iVar2 = menu_contains(m,f);
    if (iVar2 != 0) {
      f = (int)((int)m - (int)menu_) >> 5;
      goto LAB_0806285a;
    }
    puVar1 = m[1].text;
    m = m + 1;
  } while( true );
}



// WARNING: Type propagation algorithm not settling

void deselect_mainmenu(terminal *term,menu *menu)

{
  menu->selected = -1;
  menu->win->next->prev = menu->win->prev;
  menu->win->prev->next = menu->win->next;
  menu->win->next = ((window *)(term->windows).prev)->next;
  menu->win->prev = (window *)(term->windows).prev;
  *(window **)(term->windows).prev = menu->win;
  menu->win->next->prev = menu->win;
  return;
}



void __regparm3 set_menu_selection(menu *menu,int pos)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  
  if (assert_failed == 0) {
    if ((pos < 0) || (menu->size <= pos)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/menu.c";
      errline = 0x15f;
      elinks_internal((uchar *)"assertion pos >= 0 && pos < menu->size failed!");
      if (assert_failed != 0) goto LAB_080629d8;
    }
    assert_failed = menu->items[pos].flags >> 7 & 1;
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/menu.c";
      errline = 0x160;
      elinks_internal((uchar *)"assertion mi_is_selectable(&menu->items[pos]) failed!");
      if (assert_failed != 0) goto LAB_080629d8;
    }
    iVar3 = (menu->box).height;
    menu->selected = pos;
    iVar1 = iVar3 + -2;
    if ((0 < iVar1) && (iVar1 != 1)) {
      iVar2 = menu->first;
      iVar3 = iVar3 + -3 >> 1;
      if (1 < iVar3) {
        iVar3 = 2;
      }
      iVar4 = iVar3 + 1 + (pos - iVar1);
      if ((iVar2 < iVar4) || (iVar4 = pos - iVar3, iVar4 < iVar2)) {
        iVar3 = menu->size;
        menu->first = iVar4;
        iVar2 = iVar4;
      }
      else {
        iVar3 = menu->size;
      }
      if (iVar2 < 0) {
        menu->first = 0;
      }
      else {
        if (iVar3 - iVar1 < iVar2) {
          menu->first = iVar3 - iVar1;
        }
      }
    }
  }
  else {
LAB_080629d8:
    assert_failed = 0;
  }
  return;
}



void __regparm3 scroll_menu(menu *menu,int steps,int wrap)

{
  int iVar1;
  bool bVar2;
  int iVar3;
  int pos;
  int iVar4;
  int local_28;
  
  iVar4 = 1;
  if (steps != 0) {
    iVar4 = steps / ((steps >> 0x1f ^ steps) - (steps >> 0x1f));
  }
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  bVar2 = menu->selected < -1;
  assert_failed = ZEXT14(bVar2);
  if (bVar2) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/menu.c";
    errline = 0x11e;
    elinks_internal((uchar *)"assertion menu->selected >= -1 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  iVar1 = menu->size;
  if (iVar1 < 1) {
no_item:
    menu->selected = -1;
    menu->first = 0;
    return;
  }
  iVar3 = menu->selected;
  pos = iVar3;
  if ((steps == 0) && (steps = 1, -1 < iVar3)) {
    pos = iVar3 + -1;
  }
  local_28 = steps - iVar4;
LAB_08062af0:
  pos = pos + iVar4;
  if (iVar3 != pos) {
    do {
      if ((pos < iVar1) || (iVar4 != 1)) {
        if ((pos < 0) && (iVar4 == -1)) {
          pos = iVar1 + -1;
          if (wrap == 0) {
            iVar4 = 0;
            pos = 0;
            goto select_item;
          }
        }
        else {
          if (-1 < *(char *)&menu->items[pos].flags) goto code_r0x08062b83;
          pos = pos + iVar4;
        }
      }
      else {
        if (wrap == 0) {
          pos = iVar1 + -1;
          iVar4 = pos * 0x20;
          goto select_item;
        }
        pos = 0;
      }
      if (iVar3 == -1) {
        iVar3 = 0;
      }
      if (pos == iVar3) break;
    } while( true );
  }
  iVar4 = pos << 5;
select_item:
  if (*(char *)((int)&menu->items->flags + iVar4) < '\0') goto no_item;
  goto LAB_08062b99;
code_r0x08062b83:
  local_28 = local_28 - iVar4;
  if (local_28 + iVar4 == 0) {
LAB_08062b99:
    set_menu_selection(menu,pos);
    return;
  }
  goto LAB_08062af0;
}



uchar * __regparm3 _(uchar *msg,terminal *term)

{
  int cp_index;
  uchar *codeset;
  
  if ((msg != (uchar *)0x0) && (*msg != '\0')) {
    if (term != (terminal *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    msg = gettext(msg);
  }
  return msg;
}



void __regparm3 select_menu_item(terminal *term,menu_item *it,void *data)

{
  void *pvVar1;
  menu_func_T *pmVar2;
  main_action action_id;
  menu_item_flags mVar3;
  int **ppiVar4;
  window *win;
  
  pvVar1 = it->data;
  pmVar2 = it->func;
  action_id = it->action_id;
  mVar3 = it->flags;
  if (-1 < (char)mVar3) {
    if ((mVar3 & SUBMENU) == NO_FLAG) {
      it->flags = mVar3 & ~FREE_DATA;
      while (win = (window *)(term->windows).next, win != (window *)&term->windows) {
        while (win->handler != menu_handler) {
          if (win->handler != mainmenu_handler) goto LAB_08062d48;
          ppiVar4 = (int **)win->data;
          ppiVar4[3] = (int *)0xffffffff;
          *(int *)(**ppiVar4 + 4) = (*ppiVar4)[1];
          *(int *)(*ppiVar4)[1] = **ppiVar4;
          **ppiVar4 = *(int *)(term->windows).prev;
          *(void **)(*ppiVar4 + 1) = (term->windows).prev;
          *(int **)(term->windows).prev = *ppiVar4;
          *(int **)(**ppiVar4 + 4) = *ppiVar4;
          redraw_terminal(term);
          win = (window *)(term->windows).next;
          if (win == (window *)&term->windows) goto LAB_08062d48;
        }
        delete_window(win);
      }
    }
LAB_08062d48:
    if ((pmVar2 == (menu_func_T *)0x0) && (action_id != ACT_MAIN_NONE)) {
      do_action((session *)data,action_id,1);
      return;
    }
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
    assert_failed = ZEXT14(pmVar2 == (menu_func_T *)0x0);
    if (pmVar2 == (menu_func_T *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/menu.c";
      errline = 0xae;
      elinks_internal((uchar *)"assertion func != NULL failed: No menu function");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    (*pmVar2)(term,pvVar1,data);
  }
  return;
}



void __regparm3 free_menu_items(menu_item *items)

{
  uchar *p;
  menu_item_flags mVar1;
  menu_item *pmVar2;
  
  if ((items != (menu_item *)0x0) &&
     (mVar1 = items->flags, (mVar1 & (FREE_LIST|FREE_TEXT|FREE_RTEXT|FREE_DATA)) != NO_FLAG)) {
    p = items->text;
    pmVar2 = items;
    if (p != (uchar *)0x0) {
      while( true ) {
        if ((mVar1 & FREE_TEXT) != NO_FLAG) {
          mem_free(p);
          mVar1 = pmVar2->flags;
        }
        if (((mVar1 & FREE_RTEXT) != NO_FLAG) && (pmVar2->rtext != (uchar *)0x0)) {
          mem_free(pmVar2->rtext);
          mVar1 = pmVar2->flags;
        }
        if (((mVar1 & FREE_DATA) != NO_FLAG) && (pmVar2->data != (void *)0x0)) {
          mem_free(pmVar2->data);
        }
        p = pmVar2[1].text;
        if (p == (uchar *)0x0) break;
        mVar1 = pmVar2[1].flags;
        pmVar2 = pmVar2 + 1;
      }
    }
    mem_free(items);
  }
  return;
}



void do_menu_selected(terminal *term,menu_item *items,void *data,int selected,int hotkeys)

{
  menu *menu;
  int iVar1;
  
  menu = (menu *)mem_calloc(1,0x3c);
  if (menu != (menu *)0x0) {
    menu->items = items;
    menu->data = data;
    menu->selected = selected;
    if ((items == (menu_item *)0x0) || (items->text == (uchar *)0x0)) {
      iVar1 = 0;
    }
    else {
      iVar1 = 0;
      do {
        items = items + 1;
        iVar1 = iVar1 + 1;
      } while (items->text != (uchar *)0x0);
    }
    menu->size = iVar1;
    menu->lang = -1;
    menu->hotkeys = hotkeys;
    refresh_hotkeys(term,menu);
    add_window(term,menu_handler,menu);
    return;
  }
  free_menu_items(items);
  return;
}



void do_menu(terminal *term,menu_item *items,void *data,int hotkeys)

{
  do_menu_selected(term,items,data,0,hotkeys);
  return;
}



void add_to_menu(menu_item **mi,uchar *text,uchar *rtext,main_action action_id,menu_func_T *func,
                void *data,menu_item_flags flags)

{
  menu_item *pmVar1;
  menu_item *p;
  uint uVar2;
  size_t size;
  int iVar3;
  int iVar4;
  uint uVar5;
  
  p = *mi;
  if (p != (menu_item *)0x0) {
    if (p->text == (uchar *)0x0) {
      iVar4 = 0;
    }
    else {
      pmVar1 = p;
      iVar4 = 0;
      do {
        iVar3 = iVar4;
        pmVar1 = pmVar1 + 1;
        iVar4 = iVar3 + 1;
      } while (pmVar1->text != (uchar *)0x0);
      uVar2 = iVar3 + 0x13U & 0xfffffff0;
      uVar5 = iVar3 + 0x11U & 0xfffffff0;
      if (uVar5 < uVar2) {
        size = uVar2 * 0x20;
        p = (menu_item *)mem_realloc(p,size);
        if (p == (menu_item *)0x0) {
          return;
        }
        *mi = p;
        memset(p + uVar5,0,size + uVar5 * -0x20);
        p = *mi;
      }
    }
    if (p != (menu_item *)0x0) {
      p = p + iVar4;
      p[1].text = p->text;
      p[1].rtext = p->rtext;
      p[1].action_id = p->action_id;
      p[1].func = p->func;
      p[1].data = p->data;
      p[1].flags = p->flags;
      p[1].hotkey_state = p->hotkey_state;
      p[1].hotkey_pos = p->hotkey_pos;
      p->text = text;
      p->rtext = rtext;
      p->action_id = action_id;
      p->func = func;
      p->data = data;
      p->flags = p->flags | flags;
      p->hotkey_state = HKS_SHOW;
      p->hotkey_pos = 0;
    }
  }
  return;
}



menu_item * new_menu(menu_item_flags flags)

{
  menu_item *pmVar1;
  uint uVar2;
  uint uVar3;
  menu_item *pmVar4;
  bool bVar5;
  byte bVar6;
  menu_item *local_10;
  
  bVar6 = 0;
  local_10 = (menu_item *)0x0;
  pmVar1 = (menu_item *)mem_realloc((void *)0x0,0x200);
  if (pmVar1 != (menu_item *)0x0) {
    bVar5 = ((uint)pmVar1 & 1) != 0;
    uVar3 = 0x200;
    pmVar4 = pmVar1;
    if (bVar5) {
      *(undefined *)&pmVar1->text = 0;
      pmVar4 = (menu_item *)((int)&pmVar1->text + 1);
      uVar3 = 0x1ff;
    }
    if (((uint)pmVar4 & 2) != 0) {
      *(undefined2 *)&pmVar4->text = 0;
      uVar3 = uVar3 - 2;
      pmVar4 = (menu_item *)((int)&pmVar4->text + 2);
    }
    uVar2 = uVar3 >> 2;
    while (uVar2 != 0) {
      uVar2 = uVar2 - 1;
      pmVar4->text = (uchar *)0x0;
      pmVar4 = (menu_item *)((int)pmVar4 + (uint)bVar6 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&pmVar4->text = 0;
      pmVar4 = (menu_item *)((int)&pmVar4->text + 2);
    }
    if (bVar5) {
      *(undefined *)&pmVar4->text = 0;
    }
    if (pmVar1 == (menu_item *)0x0) {
      local_10 = (menu_item *)0x0;
    }
    else {
      pmVar1->flags = flags;
      local_10 = pmVar1;
    }
  }
  return local_10;
}



void __regparm3 display_menu(terminal *term,menu *menu)

{
  byte *pbVar1;
  byte *pbVar2;
  int iVar3;
  color_pair *color;
  color_pair *color_00;
  color_pair *color_01;
  int *piVar4;
  color_pair *pcVar5;
  color_pair *color_02;
  screen_char_attr attr;
  uint uVar6;
  size_t length;
  string *psVar7;
  byte *msgid;
  int iVar8;
  unicode_val_T local_c0;
  int cp_index;
  uchar *codeset;
  byte bVar9;
  int iVar10;
  int iVar11;
  size_t length_00;
  int y;
  int iVar12;
  uchar *name;
  uchar *name_00;
  byte *msgid_00;
  int iVar13;
  byte **ppbVar14;
  int iVar15;
  bool bVar16;
  screen_char_attr attr_00;
  int local_a0;
  color_pair *local_50;
  uint local_4c;
  int local_48;
  size_t local_40;
  box box;
  string keystroke;
  byte *local_20 [4];
  
  color = get_bfu_color(term,"menu.normal");
  color_00 = get_bfu_color(term,"menu.selected");
  color_01 = get_bfu_color(term,"menu.frame");
  box.x = (menu->box).x + 1;
  if (box.x < 0) {
    box.x = 0;
  }
  box.y = (menu->box).y + 1;
  if (box.y < 0) {
    box.y = 0;
  }
  box.width = (menu->box).width + -2;
  if (box.width < 0) {
    box.width = 0;
  }
  iVar12 = (menu->box).height + -2;
  box.height = 0;
  if (-1 < iVar12) {
    box.height = iVar12;
  }
  draw_box(term,&box,' ',0,color);
  draw_border(term,&box,color_01,1);
  piVar4 = get_opt_(config_options,name);
  if (*piVar4 == 0) {
    if ((*(byte *)&term->field_0x38 & 2) != 0) {
      fix_dwchar_around_box(term,&box,1,0,0);
    }
  }
  else {
    color_02 = get_bfu_color(term,"dialog.shadow");
    draw_shadow(term,&menu->box,color_02,2,1);
    if ((*(byte *)&term->field_0x38 & 2) != 0) {
      fix_dwchar_around_box(term,&box,1,2,1);
    }
  }
  iVar3 = box.height;
  box.height = 1;
  iVar12 = menu->first;
  if ((iVar12 < menu->size) && (iVar12 < iVar12 + iVar3)) {
    local_48 = iVar12 << 5;
    do {
      ppbVar14 = (byte **)((int)&menu->items->text + local_48);
      bVar16 = menu->selected == iVar12;
      local_50 = color;
      if (bVar16) {
        set_cursor(term,box.x,box.y,1);
        menu->win->x = (menu->box).width + (menu->box).x;
        menu->win->y = box.y;
        draw_box(term,&box,' ',0,color_00);
        local_50 = color_00;
      }
      msgid_00 = ppbVar14[5];
      bVar9 = (byte)((uint)msgid_00 >> 8);
      local_4c = (uint)msgid_00 & 0x80;
      if (local_4c == 0) {
        msgid = *ppbVar14;
        if (msgid == (byte *)0x0) goto LAB_08063428;
        if (*msgid != 0) goto LAB_0806326e;
        if (((uint)msgid_00 & 0x20) != 0) goto LAB_08063526;
LAB_08063431:
        if (ppbVar14[2] == (byte *)0x0) {
          msgid_00 = ppbVar14[1];
          cp_index = box.y;
          if ((msgid_00 != (byte *)0x0) && (*msgid_00 != 0)) {
            if ((bVar9 & 1) != 0) {
              if ((term != (terminal *)0x0) &&
                 (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
                codeset = get_cp_mime_name(cp_index);
                bind_textdomain_codeset("elinks",codeset);
                current_charset = cp_index;
              }
              msgid_00 = gettext(msgid_00);
              cp_index = box.y;
              if (*msgid_00 == 0) goto LAB_080634d3;
            }
            iVar10 = box.width;
            cp_index = box.y;
            y = (menu->box).x;
            length_00 = box.width - 2;
            if ((0 < (int)length_00) && (length = strlen((char *)msgid_00), length != 0)) {
              if ((int)length_00 < (int)length) {
                length = length_00;
              }
              draw_text(term,(iVar10 + y) - length,cp_index,msgid_00,length,0,local_50);
              cp_index = box.y;
            }
          }
        }
        else {
          psVar7 = init_string(&keystroke);
          cp_index = box.y;
          if (psVar7 != (string *)0x0) {
            add_keystroke_action_to_string(&keystroke,(action_id_T)ppbVar14[2],KEYMAP_MAIN);
            codeset = keystroke.source;
            y = box.y;
            cp_index = (menu->box).x;
            length_00 = box.width - 2;
            if (0 < (int)length_00) {
              length = keystroke.length;
              if (keystroke.length < 0) {
                length = strlen((char *)keystroke.source);
              }
              if (length != 0) {
                if ((int)length_00 < (int)length) {
                  length = length_00;
                }
                draw_text(term,(cp_index + 2 + length_00) - length,y,codeset,length,0,local_50);
              }
            }
            done_string(&keystroke);
            cp_index = box.y;
          }
        }
      }
      else {
        msgid = *ppbVar14;
        if (msgid == (byte *)0x0) {
LAB_08063428:
          bVar9 = (byte)((uint)msgid_00 >> 8);
          if (((uint)msgid_00 & 0x20) == 0) goto LAB_08063431;
LAB_08063526:
          y = box.width + -2;
          cp_index = box.y;
          if (0 < y) {
            cp_index = (uint)(y != 1) + 1;
            draw_text(term,((menu->box).x + 2 + y) - cp_index,box.y,m_submenu,cp_index,0,local_50);
            cp_index = box.y;
          }
        }
        else {
          if (*msgid != 0) {
LAB_0806326e:
            pbVar1 = ppbVar14[7];
            if (((uint)msgid_00 & 0x40) == 0) {
              if ((term != (terminal *)0x0) &&
                 (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
                codeset = get_cp_mime_name(cp_index);
                bind_textdomain_codeset("elinks",codeset);
                current_charset = cp_index;
              }
              msgid = gettext(msgid);
              msgid_00 = ppbVar14[5];
              local_4c = (uint)msgid_00 & 0x80;
            }
            iVar10 = box.width;
            y = box.y;
            cp_index = box.x;
            if ((local_4c == 0) && (pbVar1 != (byte *)0x0)) {
              pcVar5 = get_bfu_color(term,(uchar *)"menu.hotkey.normal");
              color_02 = get_bfu_color(term,(uchar *)"menu.hotkey.selected");
              piVar4 = get_opt_(config_options,name_00);
              iVar10 = iVar10 + -2;
              attr = ~-(uint)(*piVar4 == 0) & SCREEN_ATTR_UNDERLINE;
              if (0 < iVar10) {
                if (!bVar16) {
                  color_02 = pcVar5;
                }
                iVar11 = cp_index + 1;
                if ((*(byte *)&term->field_0x38 & 2) == 0) {
                  bVar9 = *msgid;
                  if (bVar9 == 0) goto LAB_08063682;
                  iVar11 = 0;
                  uVar6 = 0;
                  msgid_00 = (byte *)0x0;
                  do {
                    if (iVar11 == 0) {
                      if (pbVar1 + -1 != msgid_00) goto LAB_08063379;
                      uVar6 = 1;
                      iVar11 = 1;
LAB_080633b1:
                      pbVar2 = msgid_00 + (1 - uVar6);
                    }
                    else {
                      if (iVar11 != 1) {
LAB_08063379:
                        draw_char(term,(cp_index + 1) - uVar6,y,(uint)bVar9,0,local_50);
                        uVar6 = (uint)(iVar11 != 0);
                        goto LAB_080633b1;
                      }
                      iVar11 = 2;
                      draw_char(term,cp_index,y,(uint)bVar9,attr,color_02);
                      uVar6 = 1;
                      pbVar2 = msgid_00;
                    }
                    if (iVar10 <= (int)pbVar2) break;
                    msgid_00 = msgid_00 + 1;
                    cp_index = cp_index + 1;
                    bVar9 = msgid[(int)msgid_00];
                  } while (bVar9 != 0);
                  msgid_00 = ppbVar14[5];
                }
                else {
                  codeset = (uchar *)__rawmemchr(msgid,0);
                  local_20[0] = msgid;
                  if (*msgid == 0) goto LAB_08063682;
                  iVar15 = 0;
                  uVar6 = 0;
                  iVar13 = 0;
                  local_40 = 0;
                  do {
                    local_c0 = utf8_to_unicode(local_20,codeset);
                    if (iVar15 == 0) {
                      if (pbVar1 != local_20[0] + -(int)msgid) goto LAB_080638a7;
                      uVar6 = 1;
                      iVar15 = 1;
LAB_0806392a:
                      iVar8 = iVar13 + 1;
                      local_40 = (iVar13 + 1) - uVar6;
                    }
                    else {
                      if (iVar15 != 1) {
LAB_080638a7:
                        iVar8 = unicode_to_cell(local_c0);
                        if (iVar8 == 2) {
                          if ((int)(local_40 + 1) < iVar10) {
                            local_a0 = (iVar11 + iVar13) - uVar6;
                            if (local_a0 + 1 < term->width) {
                              iVar13 = iVar13 + 1;
                              draw_char(term,local_a0,y,local_c0,0,local_50);
                              draw_char(term,iVar11 + (iVar13 - uVar6),y,0xfffffffd,0,local_50);
                              uVar6 = (uint)(iVar15 != 0);
                              goto LAB_0806392a;
                            }
                          }
                          else {
                            local_a0 = (iVar11 + iVar13) - uVar6;
                          }
                          local_c0 = 0x20;
                        }
                        else {
                          local_a0 = (iVar13 + iVar11) - uVar6;
                        }
                        draw_char(term,local_a0,y,local_c0,0,local_50);
                        uVar6 = (uint)(iVar15 != 0);
                        goto LAB_0806392a;
                      }
                      iVar15 = unicode_to_cell(local_c0);
                      attr_00 = attr;
                      if (iVar15 == 2) {
                        if ((iVar13 < iVar10) && (iVar15 = iVar13 + iVar11, iVar15 < term->width)) {
                          iVar13 = iVar13 + 1;
                          uVar6 = 1;
                          draw_char(term,iVar15 + -1,y,local_c0,attr,color_02);
                          iVar15 = 2;
                          draw_char(term,iVar13 + cp_index,y,0xfffffffd,0,color_02);
                          goto LAB_0806392a;
                        }
                        local_c0 = 0x20;
                        attr_00 = 0;
                      }
                      uVar6 = 1;
                      iVar15 = 2;
                      draw_char(term,iVar13 + cp_index,y,local_c0,attr_00,color_02);
                      iVar8 = iVar13 + 1;
                      local_40 = iVar13;
                    }
                    iVar13 = iVar8;
                  } while (((int)local_40 < iVar10) && (*local_20[0] != 0));
                  msgid_00 = ppbVar14[5];
                }
                goto LAB_08063428;
              }
            }
            else {
              local_40 = box.width - 2;
              if (((int)local_40 < 1) || (length_00 = strlen((char *)msgid), length_00 == 0))
              goto LAB_08063428;
              if (((*(byte *)&term->field_0x38 & 2) == 0) ||
                 (local_40 = utf8_cells2bytes(msgid,local_40,(uchar *)0x0), 0 < (int)local_40)) {
                if ((int)local_40 <= (int)length_00) {
                  length_00 = local_40;
                }
                draw_text(term,cp_index + 1,y,msgid,length_00,0,local_50);
              }
            }
LAB_08063682:
            msgid_00 = ppbVar14[5];
            goto LAB_08063428;
          }
          draw_border_char(term,(menu->box).x,box.y,BORDER_SRTEE,color_01);
          draw_box(term,&box,-0x3c,SCREEN_ATTR_FRAME,color_01);
          draw_border_char(term,box.width + box.x,box.y,BORDER_SLTEE,color_01);
          cp_index = box.y;
        }
      }
LAB_080634d3:
      box.y = cp_index + 1;
      iVar12 = iVar12 + 1;
    } while ((menu->size != iVar12 && iVar12 <= menu->size) &&
            (local_48 = local_48 + 0x20, iVar12 < iVar3 + menu->first));
  }
  redraw_from_window(menu->win);
  return;
}



void __regparm3 display_mainmenu(terminal *term,menu *menu)

{
  byte *pbVar1;
  byte *pbVar2;
  byte bVar3;
  color_pair *color;
  color_pair *color_00;
  int length;
  byte **ppbVar4;
  size_t sVar5;
  color_pair *pcVar6;
  color_pair *color_01;
  int *piVar7;
  uchar *codeset;
  int x;
  unicode_val_T local_b0;
  screen_char *psVar8;
  int iVar9;
  screen_char_attr attr;
  uchar *name;
  uint uVar10;
  int cp_index;
  int x_00;
  int iVar11;
  byte *__s;
  bool bVar12;
  int local_64;
  int local_60;
  color_pair *local_58;
  int local_54;
  int local_48;
  byte *local_44;
  int local_40;
  box box;
  byte *local_20 [4];
  
  color = get_bfu_color(term,"menu.normal");
  color_00 = get_bfu_color(term,"menu.selected");
  iVar9 = menu->selected;
  cp_index = menu->first;
  if (iVar9 < cp_index) {
    iVar9 = iVar9 - cp_index;
    cp_index = iVar9 + cp_index;
    menu->first = cp_index;
    length = menu->last + iVar9;
    menu->last = length;
LAB_08063d1b:
    if (length < 1) goto LAB_08064071;
LAB_08063d23:
    iVar9 = menu->size;
  }
  else {
    length = menu->last;
    if (iVar9 <= length) goto LAB_08063d1b;
    cp_index = cp_index - (length - iVar9);
    length = length - (length - iVar9);
    menu->first = cp_index;
    menu->last = length;
    if (0 < length) goto LAB_08063d23;
LAB_08064071:
    iVar9 = menu->size;
    length = iVar9 + -1;
    menu->last = length;
    if (length < 0) {
      menu->last = 0;
      length = 0;
      goto joined_r0x08064093;
    }
  }
  iVar9 = iVar9 + -1;
  if (iVar9 < length) {
    menu->last = iVar9;
    length = iVar9;
  }
joined_r0x08064093:
  if (cp_index < 0) {
    menu->first = 0;
  }
  else {
    if (length < cp_index) {
      menu->first = length;
    }
  }
  box.x = 0;
  box.y = 0;
  box.height = 1;
  box.width = 0;
  if (-1 < term->width) {
    box.width = term->width;
  }
  draw_box(term,&box,' ',0,color);
  local_54 = 0;
  if (menu->first != 0) {
    box.width = 2;
    draw_box(term,&box,'<',0,color);
    local_54 = menu->first;
  }
  if (menu->size <= local_54) {
LAB_08064118:
    cp_index = menu->first;
    local_54 = local_54 + -1;
    menu->last = local_54;
    if (local_54 < cp_index) {
      menu->last = cp_index;
      local_54 = cp_index;
    }
    if (local_54 < menu->size + -1) {
      if (((*(byte *)&term->field_0x38 & 2) != 0) &&
         (psVar8 = get_char(term,term->width + -2,0), psVar8->data == 0xfffffffd)) {
        draw_char_data(term,term->width + -3,0,0x20);
      }
      box.y = 0;
      box.width = 2;
      cp_index = term->width + -2;
      box.x = 0;
      if (-1 < cp_index) {
        box.x = cp_index;
      }
      box.height = 1;
      draw_box(term,&box,'>',0,color);
    }
    redraw_from_window(menu->win);
    return;
  }
  local_64 = local_54 << 5;
  local_40 = 2;
  do {
    ppbVar4 = (byte **)((int)&menu->items->text + local_64);
    local_44 = *ppbVar4;
    pbVar1 = ppbVar4[7];
    bVar12 = menu->selected == local_54;
    __s = local_44;
    if ((((*(byte *)(ppbVar4 + 5) & 0x40) == 0) && (__s = (byte *)0x0, local_44 != (byte *)0x0)) &&
       (__s = local_44, *local_44 != 0)) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      __s = gettext(local_44);
      local_44 = __s;
    }
    sVar5 = strlen((char *)__s);
    cp_index = sVar5 - (uint)(pbVar1 != (byte *)0x0);
    local_60 = cp_index;
    if ((*(byte *)&term->field_0x38 & 2) != 0) {
      local_60 = utf8_ptr2cells(local_44,(uchar *)0x0);
      local_60 = local_60 - (uint)(pbVar1 != (byte *)0x0);
    }
    local_58 = color;
    if (bVar12) {
      box.x = local_40;
      box.width = cp_index;
      if ((*(byte *)&term->field_0x38 & 2) != 0) {
        box.width = local_60;
      }
      box.width = box.width + 4;
      draw_box(term,&box,' ',0,color_00);
      set_cursor(term,local_40,0,1);
      menu->win->x = local_40;
      menu->win->y = 1;
      local_58 = color_00;
    }
    iVar9 = local_40 + 1;
    if (pbVar1 == (byte *)0x0) {
      if (cp_index < 1) goto LAB_0806400b;
      if ((*(byte *)&term->field_0x38 & 2) == 0) {
LAB_080640ca:
        length = cp_index;
      }
      else {
        length = utf8_cells2bytes(local_44,cp_index,(uchar *)0x0);
        if (length < 1) goto LAB_0806400b;
        if (cp_index <= length) goto LAB_080640ca;
      }
      draw_text(term,local_40 + 2,0,local_44,length,0,local_58);
      if (term->width + -2 <= local_60 + iVar9) goto LAB_08064118;
    }
    else {
      pcVar6 = get_bfu_color(term,(uchar *)"menu.hotkey.normal");
      color_01 = get_bfu_color(term,(uchar *)"menu.hotkey.selected");
      piVar7 = get_opt_(config_options,name);
      attr = ~-(uint)(*piVar7 == 0) & SCREEN_ATTR_UNDERLINE;
      if (0 < cp_index) {
        if (!bVar12) {
          color_01 = pcVar6;
        }
        length = local_40 + 2;
        if ((*(byte *)&term->field_0x38 & 2) == 0) {
          bVar3 = *local_44;
          if (bVar3 != 0) {
            __s = (byte *)0x0;
            length = 0;
            uVar10 = 0;
            x_00 = iVar9;
            do {
              if (length == 0) {
                if (pbVar1 + -1 != __s) goto LAB_08063f69;
                uVar10 = 1;
                length = 1;
LAB_08063fa2:
                pbVar2 = __s + (1 - uVar10);
              }
              else {
                if (length != 1) {
LAB_08063f69:
                  draw_char(term,(x_00 + 1) - uVar10,0,(uint)bVar3,0,local_58);
                  uVar10 = (uint)(length != 0);
                  goto LAB_08063fa2;
                }
                length = 2;
                draw_char(term,x_00,0,(uint)bVar3,attr,color_01);
                uVar10 = 1;
                pbVar2 = __s;
              }
              if (cp_index <= (int)pbVar2) break;
              __s = __s + 1;
              x_00 = x_00 + 1;
              bVar3 = local_44[(int)__s];
            } while (bVar3 != 0);
          }
        }
        else {
          codeset = (uchar *)__rawmemchr(local_44,0);
          local_20[0] = local_44;
          if (*local_44 != 0) {
            x_00 = 0;
            iVar11 = 0;
            uVar10 = 0;
            local_48 = 0;
            local_40 = local_40 + 1;
            do {
              local_b0 = utf8_to_unicode(local_20,codeset);
              if (iVar11 == 0) {
                if (pbVar1 == local_20[0] + -(int)local_44) {
                  uVar10 = 1;
                  iVar11 = 1;
                  goto LAB_08064369;
                }
LAB_080642df:
                x = unicode_to_cell(local_b0);
                if (x == 2) {
                  if ((local_48 + 1 < cp_index) &&
                     (x = (x_00 + length) - uVar10, x + 1 < term->width)) {
                    x_00 = x_00 + 1;
                    draw_char(term,x,0,local_b0,0,local_58);
                    draw_char(term,length + (x_00 - uVar10),0,0xfffffffd,0,local_58);
                    uVar10 = (uint)(iVar11 != 0);
                    goto LAB_08064369;
                  }
                  local_b0 = 0x20;
                }
                draw_char(term,(x_00 + length) - uVar10,0,local_b0,0,local_58);
                uVar10 = (uint)(iVar11 != 0);
LAB_08064369:
                x = x_00 + 1;
                local_48 = (x_00 + 1) - uVar10;
              }
              else {
                if (iVar11 != 1) goto LAB_080642df;
                iVar11 = unicode_to_cell(local_b0);
                if (iVar11 != 2) {
                  uVar10 = 1;
                  iVar11 = 2;
                  draw_char(term,local_40 + x_00,0,local_b0,attr,color_01);
                  goto LAB_08064369;
                }
                if ((x_00 < cp_index) && (iVar11 = x_00 + length, iVar11 < term->width)) {
                  x_00 = x_00 + 1;
                  uVar10 = 1;
                  draw_char(term,iVar11 + -1,0,local_b0,attr,color_01);
                  iVar11 = 2;
                  draw_char(term,local_40 + x_00,0,0xfffffffd,0,color_01);
                  goto LAB_08064369;
                }
                uVar10 = 1;
                iVar11 = 2;
                draw_char(term,local_40 + x_00,0,0x20,0,color_01);
                x = x_00 + 1;
                local_48 = x_00;
              }
              x_00 = x;
            } while ((local_48 < cp_index) && (*local_20[0] != 0));
          }
        }
      }
LAB_0806400b:
      if (term->width + -2 <= local_60 + iVar9) goto LAB_08064118;
    }
    local_54 = local_54 + 1;
    local_64 = local_64 + 0x20;
    if (menu->size == local_54 || menu->size < local_54) goto LAB_08064118;
    local_40 = local_60 + iVar9 + 3;
  } while( true );
}



// WARNING: Type propagation algorithm not settling

void do_mainmenu(terminal *term,menu_item *items,void *data,int sel)

{
  list_head_elinks *plVar1;
  menu *pmVar2;
  bool bVar3;
  list_head_elinks *plVar4;
  int iVar5;
  window *pwVar6;
  menu *menu;
  
  bVar3 = false;
  menu = term->main_menu;
  if (menu == (menu *)0x0) {
    menu = (menu *)mem_calloc(1,0x3c);
    term->main_menu = menu;
    if (menu == (menu *)0x0) {
      return;
    }
    bVar3 = true;
  }
  iVar5 = 0;
  if (sel != -1) {
    iVar5 = sel;
  }
  menu->selected = iVar5;
  menu->items = items;
  menu->data = data;
  if ((items == (menu_item *)0x0) || (items->text == (uchar *)0x0)) {
    iVar5 = 0;
  }
  else {
    iVar5 = 0;
    do {
      items = items + 1;
      iVar5 = iVar5 + 1;
    } while (items->text != (uchar *)0x0);
  }
  menu->size = iVar5;
  menu->hotkeys = 1;
  clear_hotkeys_cache(menu);
  init_hotkeys(term,menu);
  if (bVar3) {
    add_window(term,mainmenu_handler,menu);
    pwVar6 = menu->win;
    if (assert_failed == 0) {
      assert_failed = ZEXT14(pwVar6 == (window *)0x0);
      if (pwVar6 == (window *)0x0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/menu.c";
        errline = 0x414;
        elinks_internal((uchar *)"assertion win failed!");
        pwVar6 = menu->win;
      }
      else {
        pwVar6 = menu->win;
      }
    }
    menu->selected = -1;
    pwVar6->next->prev = pwVar6->prev;
    menu->win->prev->next = menu->win->next;
    menu->win->next = ((window *)(term->windows).prev)->next;
    menu->win->prev = (window *)(term->windows).prev;
    *(window **)(term->windows).prev = menu->win;
    menu->win->next->prev = menu->win;
  }
  else {
    plVar4 = (list_head_elinks *)(term->windows).next;
    plVar1 = &term->windows;
    if (plVar4 != plVar1) {
      pmVar2 = (menu *)plVar4[2].next;
      while (menu != pmVar2) {
        plVar4 = (list_head_elinks *)plVar4->next;
        if (plVar4 == plVar1) goto LAB_080646eb;
        pmVar2 = (menu *)plVar4[2].next;
      }
      *(void **)((int)plVar4->next + 4) = plVar4->prev;
      *(void **)plVar4->prev = plVar4->next;
      plVar4->next = (term->windows).next;
      *(list_head_elinks **)&plVar4->prev = plVar1;
      *(list_head_elinks **)&(term->windows).next = plVar4;
      *(list_head_elinks **)((int)plVar4->next + 4) = plVar4;
      display_mainmenu(term,menu);
    }
  }
LAB_080646eb:
  if (((sel != -1) && (iVar5 = menu->selected, -1 < iVar5)) && (iVar5 < menu->size)) {
    select_menu_item(term,menu->items + iVar5,menu->data);
    return;
  }
  return;
}



// WARNING: Type propagation algorithm not settling

void mainmenu_handler(window *win,term_event *ev)

{
  menu *menu;
  uint uVar1;
  action_id_T aVar2;
  size_t sVar3;
  int cp_index;
  uchar *codeset;
  uchar *msgid;
  terminal *term;
  void *data;
  int steps;
  menu_item *pmVar4;
  
  menu = (menu *)win->data;
  menu->win = win;
  if (EVENT_RESIZE < ev->ev) {
    return;
  }
  switch(ev->ev) {
  default:
    goto switchD_08064851_caseD_0;
  case EVENT_KBD:
    break;
  case EVENT_MOUSE:
    uVar1 = *(uint *)((int)&ev->info + 8);
    if (2 < (uVar1 & 7)) {
      return;
    }
    if (*(int *)((int)&ev->info + 4) == 0) {
      steps = -1;
      if (*(int *)&ev->info < 2) {
LAB_08064a98:
        scroll_menu(menu,steps,1);
        display_mainmenu(win->term,menu);
        cp_index = menu->selected;
LAB_08064ab1:
        term = win->term;
      }
      else {
        term = win->term;
        steps = 1;
        if (term->width + -2 <= *(int *)&ev->info) goto LAB_08064a98;
        pmVar4 = menu->items;
        msgid = pmVar4->text;
        if (msgid != (uchar *)0x0) {
          steps = 2;
          do {
            if (*msgid != '\0') {
              if ((*(byte *)&pmVar4->flags & 0x40) == 0) {
                if ((win->term != (terminal *)0x0) &&
                   (cp_index = get_terminal_codepage(win->term), cp_index != current_charset)) {
                  codeset = get_cp_mime_name(cp_index);
                  bind_textdomain_codeset("elinks",codeset);
                  current_charset = cp_index;
                }
                msgid = gettext(msgid);
              }
              sVar3 = strlen((char *)msgid);
              steps = (4 - (uint)(pmVar4->hotkey_pos != 0)) + steps + sVar3;
              if (*(int *)&ev->info < steps) {
                cp_index = menu->selected;
                steps = ((int)((int)pmVar4 - (int)menu->items) >> 5) - cp_index;
                if (steps != 0) goto LAB_08064a98;
                goto LAB_08064ab1;
              }
            }
            pmVar4 = pmVar4 + 1;
            msgid = pmVar4->text;
          } while (msgid != (uchar *)0x0);
          term = win->term;
        }
        cp_index = menu->selected;
      }
      if (cp_index < 0) {
        return;
      }
      if (menu->size == cp_index || menu->size < cp_index) {
        return;
      }
      data = menu->data;
      goto LAB_08064932;
    }
    if ((uVar1 & 0x20) != 0) {
      return;
    }
    term = win->term;
    menu->selected = -1;
    win->next->prev = win->prev;
    goto LAB_0806496c;
  }
  aVar2 = kbd_action(KEYMAP_MENU,ev,(int *)0x0);
  switch(aVar2) {
  default:
    if ((0x20 < (int)*(term_event_char_T *)&ev->info) &&
       (((steps = *(int *)((int)&ev->info + 4), steps == 4 || (steps == 0)) &&
        (steps = check_hotkeys(menu,*(term_event_char_T *)&ev->info,win->term), steps != 0)))) {
      display_mainmenu(win->term,menu);
      goto switchD_08064950_caseD_4;
    }
  case 2:
    term = win->term;
    menu->selected = -1;
    menu->win->next->prev = menu->win->prev;
LAB_0806496c:
    menu->win->prev->next = menu->win->next;
    menu->win->next = ((window *)(term->windows).prev)->next;
    menu->win->prev = (window *)(term->windows).prev;
    *(window **)(term->windows).prev = menu->win;
    menu->win->next->prev = menu->win;
    break;
  case 4:
  case 6:
  case 0xc:
  case 0xd:
  case 0x12:
  case 0x14:
switchD_08064950_caseD_4:
    cp_index = menu->selected;
    term = win->term;
    if ((cp_index < 0) || (menu->size <= cp_index)) {
      return;
    }
    data = menu->data;
LAB_08064932:
    select_menu_item(term,menu->items + cp_index,data);
    return;
  case 5:
    scroll_menu(menu,(menu->size + -1) - menu->selected,0);
    break;
  case 8:
    scroll_menu(menu,-menu->selected,0);
    break;
  case 9:
  case 0x10:
    if (aVar2 == 9) goto LAB_08064af1;
LAB_08064891:
    steps = 1;
    goto LAB_08064896;
  case 0xb:
  case 0xe:
    if (aVar2 == 0xb) goto LAB_08064891;
LAB_08064af1:
    steps = -1;
LAB_08064896:
    scroll_menu(menu,steps,1);
    break;
  case 0xf:
    break;
  }
switchD_08064851_caseD_0:
  display_mainmenu(win->term,menu);
  return;
}



input_line_code menu_search_handler(input_line *line,int action_id)

{
  menu *menu;
  terminal *term;
  menu_item_flags mVar1;
  void **ppvVar2;
  void *pvVar3;
  uchar *msgid;
  char *__s;
  size_t __n;
  int cp_index;
  uchar *codeset;
  int iVar4;
  int pos;
  int local_24;
  
  menu = (menu *)line->data;
  term = menu->win->term;
  iVar4 = menu->selected;
  if (action_id == 0x16) {
    iVar4 = iVar4 + 1;
  }
  else {
    if (action_id < 0x17) {
      if (action_id == 0xe) {
        ppvVar2 = (void **)(term->windows).next;
        *(void **)((int)*ppvVar2 + 4) = ppvVar2[1];
        *(void **)ppvVar2[1] = *ppvVar2;
        iVar4 = menu->selected;
        if ((-1 < iVar4) && (iVar4 < menu->size)) {
          select_menu_item(term,menu->items + iVar4,menu->data);
        }
        pvVar3 = (term->windows).next;
        *(list_head_elinks **)(ppvVar2 + 1) = &term->windows;
        *ppvVar2 = pvVar3;
        *(void ***)&(term->windows).next = ppvVar2;
        *(void ***)((int)*ppvVar2 + 4) = ppvVar2;
        return INPUT_LINE_CANCEL;
      }
    }
    else {
      if (action_id == 0x19) {
        iVar4 = iVar4 + -1;
        local_24 = -1;
        goto LAB_08064b92;
      }
      if (action_id == 0x1a) {
        return INPUT_LINE_PROCEED;
      }
    }
  }
  local_24 = 1;
LAB_08064b92:
  if (line->buffer[0] == '\0') {
    return INPUT_LINE_PROCEED;
  }
  iVar4 = iVar4 % menu->size;
  pos = iVar4;
  do {
    while( true ) {
      msgid = menu->items[pos].text;
      if (((msgid != (uchar *)0x0) && (*msgid != '\0')) &&
         (mVar1 = menu->items[pos].flags, -1 < (char)mVar1)) {
        if ((mVar1 & NO_INTL) == NO_FLAG) {
          if ((term != (terminal *)0x0) &&
             (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
            codeset = get_cp_mime_name(cp_index);
            bind_textdomain_codeset("elinks",codeset);
            current_charset = cp_index;
          }
          msgid = gettext(msgid);
        }
        msgid = stracpy(msgid);
        if (msgid != (uchar *)0x0) {
          __s = strchr((char *)msgid,0x7e);
          if (__s != (char *)0x0) {
            __n = strlen(__s);
            memmove(__s,__s + 1,__n);
          }
          __s = strcasestr((char *)msgid,(char *)line->buffer);
          mem_free(msgid);
          if (__s != (char *)0x0) {
            set_menu_selection(menu,pos);
            display_menu(term,menu);
            return INPUT_LINE_PROCEED;
          }
        }
      }
      pos = pos + local_24;
      if (menu->size != pos) break;
      pos = 0;
      if (iVar4 == 0) {
        return INPUT_LINE_CANCEL;
      }
    }
    if (pos < 0) {
      pos = menu->size + -1;
    }
  } while (pos != iVar4);
  return INPUT_LINE_CANCEL;
}



void menu_handler(window *win,term_event *ev)

{
  menu *menu;
  uint uVar1;
  void *pvVar2;
  term_event_char_T key;
  window *pwVar3;
  int iVar4;
  int iVar5;
  size_t sVar6;
  uchar *prompt;
  string *psVar7;
  action_id_T aVar8;
  uchar *codeset;
  window *pwVar9;
  menu_item_flags *pmVar10;
  int iVar11;
  int steps;
  menu_item *pmVar12;
  session *ses;
  int pos;
  int cp_index;
  terminal *term;
  int iVar13;
  bool bVar14;
  string keystroke;
  
  menu = (menu *)win->data;
  menu->win = win;
  if (EVENT_ABORT < ev->ev) {
    return;
  }
  switch(ev->ev) {
  default:
    get_parent_ptr(win,&menu->parent_x,&menu->parent_y);
  case EVENT_REDRAW:
    term = win->term;
    iVar11 = term->width + -2;
    iVar4 = term->height + -2;
    steps = menu->size;
    if (iVar4 <= menu->size) {
      steps = iVar4;
    }
    pmVar12 = menu->items;
    pos = 0;
    prompt = pmVar12->text;
    codeset = (uchar *)0x2;
    if (prompt != (uchar *)0x0) {
      pos = 0;
      do {
        if (*prompt == '\0') {
          cp_index = 0;
        }
        else {
          if ((*(byte *)&pmVar12->flags & 0x40) == 0) {
            cp_index = get_terminal_codepage(term);
            if (cp_index != current_charset) {
              codeset = get_cp_mime_name(cp_index);
              bind_textdomain_codeset("elinks",codeset);
              current_charset = cp_index;
            }
            prompt = gettext(prompt);
            if (*prompt == '\0') {
              cp_index = 0;
              goto LAB_08064f13;
            }
          }
          if ((*(byte *)&term->field_0x38 & 2) == 0) {
            sVar6 = strlen((char *)prompt);
          }
          else {
            sVar6 = utf8_ptr2cells(prompt,(uchar *)0x0);
          }
          cp_index = (2 - (uint)(pmVar12->hotkey_pos != 0)) + sVar6;
        }
LAB_08064f13:
        iVar5 = 4;
        if ((pmVar12->flags & SUBMENU) == NO_FLAG) {
          if (pmVar12->action_id == ACT_MAIN_NONE) {
            prompt = pmVar12->rtext;
            if (((prompt == (uchar *)0x0) || (*prompt == '\0')) ||
               (((pmVar12->flags & RIGHT_INTL) != NO_FLAG &&
                (prompt = _(prompt,term), *prompt == '\0')))) {
LAB_08064f98:
              iVar5 = 0;
            }
            else {
              sVar6 = strlen((char *)prompt);
              iVar5 = sVar6 + 2;
            }
          }
          else {
            psVar7 = init_string(&keystroke);
            if (psVar7 == (string *)0x0) goto LAB_08064f98;
            add_keystroke_action_to_string(&keystroke,pmVar12->action_id,KEYMAP_MAIN);
            iVar5 = keystroke.length + 2;
            done_string(&keystroke);
          }
        }
        if (iVar11 < cp_index) {
          cp_index = iVar11;
        }
        if (iVar11 - cp_index < iVar5) {
          iVar5 = iVar11 - cp_index;
        }
        if (pos < iVar5 + cp_index) {
          pos = iVar5 + cp_index;
        }
        pmVar12 = pmVar12 + 1;
        prompt = pmVar12->text;
      } while (prompt != (uchar *)0x0);
      codeset = (uchar *)(pos + 2);
      if ((int)(uchar *)(pos + 2) < 0) {
        codeset = prompt;
      }
    }
    cp_index = menu->parent_y;
    iVar5 = menu->parent_x;
    if (iVar5 < 0) {
      iVar5 = 0;
    }
    (menu->box).x = iVar5;
    iVar13 = 0;
    if (-1 < cp_index) {
      iVar13 = cp_index;
    }
    (menu->box).y = iVar13;
    *(uchar **)&(menu->box).width = codeset;
    cp_index = 0;
    if (-1 < steps + 2) {
      cp_index = steps + 2;
    }
    (menu->box).height = cp_index;
    if (iVar11 - pos < iVar5) {
      (menu->box).x = iVar11 - pos;
    }
    if (iVar4 - steps < iVar13) {
      (menu->box).y = iVar4 - steps;
    }
    scroll_menu(menu,0,1);
    display_menu(win->term,menu);
    return;
  case EVENT_KBD:
    break;
  case EVENT_MOUSE:
    uVar1 = *(uint *)((int)&ev->info + 8);
    if ((uVar1 & 7) == 3) {
      steps = -1;
    }
    else {
      if ((uVar1 & 7) != 4) {
        steps = *(int *)((int)&ev->info + 4);
        iVar4 = *(int *)&ev->info;
        iVar11 = (menu->box).x;
        if ((((iVar11 <= iVar4) && (pos = (menu->box).y, pos <= steps)) &&
            (iVar4 < iVar11 + (menu->box).width)) && (steps < (menu->box).height + pos)) {
          pos = (steps + menu->first + -1) - pos;
          if (pos < 0) {
            return;
          }
          if (menu->size <= pos) {
            return;
          }
          if (*(char *)&menu->items[pos].flags < '\0') {
            return;
          }
          set_menu_selection(menu,pos);
          display_menu(win->term,menu);
          steps = menu->selected;
          if (steps < 0) {
            return;
          }
          if (menu->size <= steps) {
            return;
          }
          select_menu_item(win->term,menu->items + steps,menu->data);
          return;
        }
        if ((uVar1 & 0x20) != 0) {
          pwVar9 = (window *)&win->term->windows;
          if (win == pwVar9) {
            return;
          }
          if (win->handler != mainmenu_handler) {
            pwVar3 = win;
            if (win->handler != menu_handler) {
              return;
            }
            while( true ) {
              pvVar2 = pwVar3->data;
              if (((*(int *)((int)pvVar2 + 0x18) <= iVar4) &&
                  (*(int *)((int)pvVar2 + 0x1c) <= steps)) &&
                 ((iVar4 < *(int *)((int)pvVar2 + 0x18) + *(int *)((int)pvVar2 + 0x20) &&
                  (steps < *(int *)((int)pvVar2 + 0x1c) + *(int *)((int)pvVar2 + 0x24))))) {
                delete_window_ev(win,ev);
                return;
              }
              pwVar3 = pwVar3->next;
              if (pwVar9 == pwVar3) {
                return;
              }
              if (pwVar3->handler == mainmenu_handler) break;
              if (pwVar3->handler != menu_handler) {
                return;
              }
            }
          }
          if (steps != 0) {
            return;
          }
          delete_window_ev(win,ev);
          return;
        }
        goto LAB_08065247;
      }
      steps = 1;
    }
    if ((uVar1 & 0x20) != 0) {
      return;
    }
    scroll_menu(menu,steps,1);
    display_menu(win->term,menu);
    return;
  case EVENT_ABORT:
    free_menu_items(menu->items);
    return;
  }
  aVar8 = kbd_action(KEYMAP_MENU,ev,(int *)0x0);
  switch(aVar8) {
  default:
    key = *(term_event_char_T *)&ev->info;
    if ((key + 299 < 0xc) || (steps = *(int *)((int)&ev->info + 4), steps == 4)) {
LAB_08065247:
      delete_window_ev(win,ev);
      return;
    }
    if ((0x20 < (int)key) && (steps == 0)) {
      steps = check_hotkeys(menu,key,win->term);
      if (steps != 0) {
        scroll_menu(menu,0,1);
        display_menu(win->term,menu);
        term = win->term;
        goto enter;
      }
      steps = check_not_so_hot_keys(menu,key,win->term);
      if (steps != 0) {
        scroll_menu(menu,0,1);
        display_menu(win->term,menu);
        return;
      }
    }
    break;
  case 2:
    if ((win->next != (window *)&win->term->windows) &&
       ((code *)(&win->next->type)[1] == mainmenu_handler)) {
      delete_window_ev(win,ev);
      return;
    }
    delete_window_ev(win,(term_event *)0x0);
    return;
  case 4:
    scroll_menu(menu,1,1);
    break;
  case 5:
    scroll_menu(menu,(menu->size + -1) - menu->selected,0);
    break;
  case 6:
  case 0x12:
    term = win->term;
    goto enter;
  case 8:
    scroll_menu(menu,-menu->selected,0);
    break;
  case 9:
  case 0x10:
    pwVar9 = win->next;
    term = win->term;
    if ((pwVar9 != (window *)&term->windows) && ((code *)(&pwVar9->type)[1] == mainmenu_handler)) {
      delete_window_ev(win,ev);
      pvVar2 = pwVar9->data;
      steps = *(int *)((int)pvVar2 + 0xc);
      if (steps < 0) {
        return;
      }
      if (*(int *)((int)pvVar2 + 8) <= steps) {
        return;
      }
      select_menu_item((terminal *)(&pwVar9->data)[1],
                       (menu_item *)(steps * 0x20 + *(int *)((int)pvVar2 + 4)),
                       *(void **)((int)pvVar2 + 0x38));
      return;
    }
    if (aVar8 != 0x10) {
      delete_window(win);
      return;
    }
enter:
    steps = menu->selected;
    if ((-1 < steps) && (steps < menu->size)) {
      select_menu_item(term,menu->items + steps,menu->data);
    }
    return;
  case 0xc:
    steps = menu->size;
    iVar4 = steps + -1;
    iVar11 = menu->selected;
    if (iVar4 <= menu->selected) {
      iVar11 = iVar4;
    }
    pos = 0;
    if (-1 < iVar11) {
      pos = iVar11;
    }
    iVar11 = pos + 1;
    cp_index = iVar4;
    if (iVar11 < steps) {
      pmVar10 = &menu->items[iVar11].flags;
      do {
        if (((*(char *)pmVar10 < '\0') && ((char *)pmVar10[-5] != (char *)0x0)) &&
           (cp_index = iVar11, *(char *)pmVar10[-5] == '\0')) break;
        iVar11 = iVar11 + 1;
        pmVar10 = pmVar10 + 8;
        cp_index = iVar4;
      } while (iVar11 < steps);
    }
    iVar4 = iVar4 - pos;
    if (4 < iVar4) {
      iVar4 = 5;
    }
    iVar11 = (cp_index - pos) + 1;
    steps = 0;
    if ((-1 < iVar11) && (steps = iVar11, iVar4 <= iVar11)) {
      steps = iVar4;
    }
    goto LAB_08065352;
  case 0xd:
    iVar4 = menu->size + -1;
    steps = menu->selected;
    if (iVar4 <= menu->selected) {
      steps = iVar4;
    }
    iVar4 = 0;
    if (-1 < steps) {
      iVar4 = steps;
    }
    steps = iVar4 + -1;
    if (0 < steps) {
      pmVar10 = &menu->items[steps].flags;
      do {
        if (((*(char *)pmVar10 < '\0') && ((char *)pmVar10[-5] != (char *)0x0)) &&
           (*(char *)pmVar10[-5] == '\0')) goto LAB_08065335;
        steps = steps + -1;
        pmVar10 = pmVar10 + -8;
      } while (0 < steps);
    }
    steps = 0;
LAB_08065335:
    iVar11 = iVar4 + 1;
    if (4 < iVar4) {
      iVar4 = 5;
    }
    iVar11 = iVar11 - steps;
    steps = 0;
    if (-1 < iVar11) {
      if (iVar4 <= iVar11) {
        iVar11 = iVar4;
      }
      steps = -iVar11;
    }
LAB_08065352:
    scroll_menu(menu,steps,0);
    break;
  case 0x11:
    bVar14 = true;
    ses = (session *)0x0;
    term = menu->win->term;
    pwVar9 = get_tab_by_number(term,term->current_tab);
    if (pwVar9 != (window *)0x0) {
      ses = (session *)pwVar9->data;
      bVar14 = ses == (session *)0x0;
    }
    prompt = _((uchar *)"Search menu/",term);
    if ((!bVar14) && (0 < menu->size)) {
      input_field_line(ses,prompt,menu,(input_history *)0x0,menu_search_handler);
    }
    break;
  case 0x14:
    scroll_menu(menu,-1,1);
  }
  display_menu(win->term,menu);
  return;
}



void abort_refreshed_msg_box_handler(dialog_data *dlg_data)

{
  uchar *p;
  
  p = dlg_data->dlg->widgets[0].text;
  if ((uchar *)dlg_data->dlg->udata != p) {
    mem_free(p);
    return;
  }
  return;
}



dlg_refresh_code refresh_msg_box(dialog_data *dlg_data,void *data)

{
  uchar *puVar1;
  
  puVar1 = (uchar *)(*(code *)data)(dlg_data->win->term,dlg_data->dlg->udata2);
  if (puVar1 != (uchar *)0x0) {
    abort_refreshed_msg_box_handler(dlg_data);
    dlg_data->dlg->widgets[0].text = puVar1;
  }
  return (uint)(puVar1 == (uchar *)0x0);
}



uchar * msg_text(terminal *term,uchar *format,...)

{
  int cp_index;
  uchar *codeset;
  uchar *p;
  int iVar1;
  uchar *puVar2;
  
  codeset = (uchar *)0x0;
  if ((format != (uchar *)0x0) && (codeset = format, *format != '\0')) {
    if (term != (terminal *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    codeset = gettext(format);
  }
  cp_index = __vsnprintf_chk(0,0,1,0xffffffff,codeset,&stack0x0000000c);
  p = (uchar *)mem_alloc(cp_index + 1U);
  puVar2 = p;
  if (p != (uchar *)0x0) {
    iVar1 = __vsnprintf_chk(p,cp_index + 1U,1,0xffffffff,codeset,&stack0x0000000c);
    if (cp_index == iVar1) {
      p[cp_index] = '\0';
    }
    else {
      puVar2 = (uchar *)0x0;
      mem_free(p);
    }
  }
  return puVar2;
}



dialog_data *
msg_box(terminal *term,memory_list *ml,msgbox_flags flags,uchar *title,format_align align,
       uchar *text,void *udata,int buttons,...)

{
  byte *pbVar1;
  done_handler_T *done;
  uchar *flags_00;
  dialog *dlg;
  dialog_data *pdVar2;
  int cp_index;
  uchar *codeset;
  uchar *codeset_00;
  uchar **ppuVar3;
  uchar **ppuVar4;
  msgbox_flags local_24;
  int local_20;
  
  if ((-1 < buttons) && (text != (uchar *)0x0)) {
    if ((flags & MSGBOX_FREE_TEXT) != 0) {
      add_one_to_ml(&ml,text);
    }
    if ((flags & MSGBOX_NO_INTL) == 0) {
      if ((title != (uchar *)0x0) && (*title != '\0')) {
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset_00 = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset_00);
          current_charset = cp_index;
        }
        title = gettext(title);
      }
      if (((flags & (MSGBOX_FREE_TEXT|MSGBOX_NO_TEXT_INTL)) == 0) && (*text != '\0')) {
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset_00 = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset_00);
          current_charset = cp_index;
        }
        text = gettext(text);
      }
    }
    local_24 = flags & MSGBOX_NO_INTL;
    dlg = (dialog *)mem_calloc(1,buttons * 0x30 + 0x54);
    if (dlg != (dialog *)0x0) {
      add_one_to_ml(&ml,dlg);
      *(byte *)&dlg->layout = *(byte *)&dlg->layout | 2;
      dlg->layouter = generic_dialog_layouter;
      dlg->title = title;
      dlg->udata2 = udata;
      if ((flags & MSGBOX_SCROLLABLE) != 0) {
        pbVar1 = dlg->widgets[0].info + 4;
        *pbVar1 = *pbVar1 | 2;
      }
      ppuVar3 = (uchar **)&stack0x00000024;
      add_dlg_text(dlg,text,align,0);
      cp_index = dlg->number_of_widgets;
      local_20 = buttons + 1;
      while (ppuVar4 = ppuVar3, cp_index < local_20) {
        while( true ) {
          codeset_00 = *ppuVar4;
          done = (done_handler_T *)ppuVar4[1];
          ppuVar3 = ppuVar4 + 3;
          flags_00 = ppuVar4[2];
          if (codeset_00 == (uchar *)0x0) break;
          if ((local_24 == 0) && (*codeset_00 != '\0')) {
            if ((term != (terminal *)0x0) &&
               (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
              codeset = get_cp_mime_name(cp_index);
              bind_textdomain_codeset("elinks",codeset);
              current_charset = cp_index;
            }
            codeset_00 = gettext(codeset_00);
          }
          add_dlg_button_do(dlg,codeset_00,(int)flags_00,ok_dialog,(void *)0x0,done,udata);
          cp_index = dlg->number_of_widgets;
          ppuVar4 = ppuVar3;
          if (local_20 <= cp_index) goto LAB_08065869;
        }
        local_20 = buttons;
        buttons = buttons + -1;
      }
LAB_08065869:
      if ((assert_failed == 0) &&
         (assert_failed = ZEXT14(local_20 != cp_index), local_20 != cp_index)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/msgbox.c";
        errline = 0x5b;
        elinks_internal((uchar *)"assertion buttons + 1 == (dlg)->number_of_widgets failed!");
      }
      pdVar2 = do_dialog(term,dlg,ml);
      return pdVar2;
    }
    freeml(ml);
  }
  return (dialog_data *)0x0;
}



dialog_data *
info_box(terminal *term,msgbox_flags flags,uchar *title,format_align align,uchar *text)

{
  dialog_data *pdVar1;
  
  pdVar1 = msg_box(term,(memory_list *)0x0,flags,title,align,text,(void *)0x0,1,&DAT_081275e4,0,3);
  return pdVar1;
}



void refreshed_msg_box(terminal *term,msgbox_flags flags,uchar *title,format_align align,
                      anon_subr_uchar_ptr_terminal_ptr_void_ptr *get_info,void *data)

{
  uchar *text;
  dialog_data *dlg_data;
  
  text = (*get_info)(term,data);
  if (text != (uchar *)0x0) {
    dlg_data = msg_box(term,(memory_list *)0x0,flags | MSGBOX_FREE_TEXT,title,align,text,data,1,
                       &DAT_081275e4,0,3);
    if (dlg_data != (dialog_data *)0x0) {
      *(uchar **)&dlg_data->dlg->udata = text;
      dlg_data->dlg->abort = abort_refreshed_msg_box_handler;
      refresh_dialog(dlg_data,refresh_msg_box,get_info);
      return;
    }
  }
  return;
}



void done_bfu_colors(void)

{
  hash *phVar1;
  hash *phVar2;
  int iVar3;
  list_head_elinks *plVar4;
  
  if (bfu_colors != (hash *)0x0) {
    if (0 < 1 << ((byte)bfu_colors->width & 0x1f)) {
      iVar3 = 0;
      phVar1 = bfu_colors;
      phVar2 = bfu_colors;
      do {
        plVar4 = (list_head_elinks *)phVar2->hash[iVar3].next;
        if (plVar4 != phVar2->hash + iVar3) {
          do {
            if (plVar4[2].next != (void *)0x0) {
              mem_free(plVar4[2].next);
              phVar1 = bfu_colors;
            }
            plVar4 = (list_head_elinks *)plVar4->next;
            phVar2 = phVar1;
          } while (phVar1->hash + iVar3 != plVar4);
        }
        iVar3 = iVar3 + 1;
      } while (iVar3 < 1 << ((byte)phVar2->width & 0x1f));
    }
    free_hash(&bfu_colors);
  }
  return;
}



// WARNING: Type propagation algorithm not settling

color_pair * get_bfu_color(terminal *term,uchar *stylename)

{
  color_mode cVar1;
  color_mode last_color_mode;
  color_mode *pcVar2;
  hash *hash;
  size_t keylen;
  hash_item *phVar3;
  char *name;
  option_elinks *tree;
  undefined4 *puVar4;
  uchar *in_EDX;
  hash *phVar5;
  uchar *name_00;
  uchar *name_01;
  undefined4 *value;
  int iVar6;
  
  if (term == (terminal *)0x0) {
    return (color_pair *)0x0;
  }
  pcVar2 = get_opt_(term->spec,in_EDX);
  cVar1 = *pcVar2;
  if (bfu_colors == (hash *)0x0) {
    bfu_colors = init_hash8();
    hash = bfu_colors;
    last_color_mode = cVar1;
    if (bfu_colors == (hash *)0x0) {
      return (color_pair *)0;
    }
  }
  else {
    hash = bfu_colors;
    if ((cVar1 != last_color_mode) &&
       (last_color_mode = cVar1, 0 < 1 << ((byte)bfu_colors->width & 0x1f))) {
      iVar6 = 0;
      phVar5 = bfu_colors;
      do {
        phVar3 = (hash_item *)phVar5->hash[iVar6].next;
        if (phVar3 != (hash_item *)(phVar5->hash + iVar6)) {
          do {
            if ((uchar *)phVar3->value != (uchar *)0x0) {
              mem_free(phVar3->value);
              hash = bfu_colors;
            }
            phVar3 = phVar3->prev;
            del_hash_item(hash,phVar3->next);
            phVar3 = phVar3->next;
            hash = bfu_colors;
            phVar5 = bfu_colors;
          } while ((hash_item *)(bfu_colors->hash + iVar6) != phVar3);
        }
        iVar6 = iVar6 + 1;
      } while (iVar6 < 1 << ((byte)phVar5->width & 0x1f));
    }
  }
  keylen = strlen((char *)stylename);
  phVar3 = get_hash_item(hash,stylename,keylen);
  if ((phVar3 == (hash_item *)0x0) ||
     (value = (undefined4 *)phVar3->value, value == (undefined4 *)0x0)) {
    name = "ui.colors.color";
    if (cVar1 == COLOR_MODE_MONO) {
      name = "ui.colors.mono";
    }
    tree = get_opt_rec_real(config_options,(uchar *)name);
    if (tree == (option_elinks *)0x0) {
      return (color_pair *)0;
    }
    tree = get_opt_rec_real(tree,stylename);
    if (tree == (option_elinks *)0x0) {
      return (color_pair *)0;
    }
    value = (undefined4 *)mem_calloc(1,0x10);
    if (value == (undefined4 *)0x0) {
      return (color_pair *)0;
    }
    tree = (option_elinks *)add_hash_item(bfu_colors,stylename,keylen,value);
    if (tree == (option_elinks *)0x0) {
      mem_free(value);
      return (color_pair *)0x0;
    }
    tree = (option_elinks *)get_opt_(tree,name_00);
    *(option_elinks **)(value + 1) = tree;
    puVar4 = get_opt_(tree,name_01);
    *(undefined4 **)value = puVar4;
  }
  else {
    puVar4 = (undefined4 *)*value;
  }
  value[2] = *puVar4;
  value[3] = *(undefined4 *)value[1];
  return (color_pair *)(value + 2);
}



void add_dlg_text(dialog *dlg,uchar *text,format_align align,int bottom_pad)

{
  int iVar1;
  int iVar2;
  
  iVar2 = dlg->number_of_widgets;
  iVar1 = iVar2 + 1;
  dlg->number_of_widgets = iVar1;
  (&dlg->title + iVar2 * 0xc)[0x14] = (uchar *)0x5;
  (&dlg->title + iVar2 * 0xc)[10] = text;
  *(format_align *)(&dlg->udata2 + iVar1 * 0xc) = align;
  *(byte *)(&dlg->refresh + iVar1 * 0xc) =
       *(byte *)(&dlg->refresh + iVar1 * 0xc) & 0xfe | bottom_pad != 0;
  return;
}



widget_handler_status_T display_text(dialog_data *dlg_data,widget_data *widget_data)

{
  int iVar1;
  window *pwVar2;
  int iVar3;
  color_pair *color;
  int iVar4;
  int iVar5;
  int iVar6;
  box box;
  
  iVar1 = *(int *)(widget_data->info + 4);
  pwVar2 = dlg_data->win;
  box.y = (widget_data->box).y;
  iVar3 = (widget_data->box).height;
  box.width = 1;
  box.x = (dlg_data->box).x + (dlg_data->box).width + -4;
  if (box.x < 0) {
    box.x = 0;
  }
  if (box.y < 0) {
    box.y = 0;
  }
  box.height = 0;
  if (-1 < iVar3) {
    box.height = iVar3;
  }
  if (((((widget_data->widget->info[4] & 2) != 0) && (0 < iVar3)) && (0 < iVar1)) &&
     ((iVar3 < iVar1 && (box.height != 0)))) {
    color = get_bfu_color(pwVar2->term,(uchar *)"dialog.scrollbar");
    draw_box(pwVar2->term,&box,' ',0,color);
    iVar4 = ((box.height + 1) * 100) / iVar1;
    iVar3 = (widget_data->box).height;
    iVar5 = ((*(int *)widget_data->info + 1) * iVar4) / 100;
    iVar6 = 0;
    if ((-1 < iVar5) && (iVar6 = iVar3 + -1, iVar5 <= iVar3 + -1)) {
      iVar6 = iVar5;
    }
    box.height = (iVar4 * (box.height + 1)) / 100;
    if (box.height < 1) {
      box.height = 1;
    }
    else {
      iVar5 = 1;
      if (0 < iVar3 - iVar6) {
        iVar5 = iVar3 - iVar6;
      }
      if (iVar5 < box.height) {
        box.height = iVar5;
      }
    }
    if (iVar1 - iVar3 == *(int *)widget_data->info) {
      iVar6 = iVar3 - box.height;
    }
    box.y = box.y + iVar6;
    *(int *)(widget_data->info + 0xc) = box.height;
    *(int *)(widget_data->info + 0x10) = box.y;
    color = get_bfu_color(pwVar2->term,(uchar *)"dialog.scrollbar-selected");
    draw_box(pwVar2->term,&box,' ',0,color);
    set_cursor(pwVar2->term,(widget_data->box).x,(widget_data->box).y,1);
    pwVar2->x = (widget_data->box).x;
    pwVar2->y = (widget_data->box).y;
  }
  return EVENT_PROCESSED;
}



void dlg_format_text_do(terminal *term,uchar *text,int x,int *y,int width,int *real_width,
                       color_pair *color,format_align align,int format_only)

{
  byte bVar1;
  size_t sVar2;
  ushort **ppuVar3;
  int iVar4;
  byte bVar5;
  uchar *puVar6;
  byte *utf8_char;
  int iVar7;
  byte *pbVar8;
  byte *local_2c;
  byte *local_24;
  byte *local_20;
  
  if (*text != '\0') {
    bVar5 = *text;
LAB_080660a8:
    if (bVar5 != 0) {
LAB_080660b0:
      bVar1 = *(byte *)&term->field_0x38 >> 1;
      sVar2 = strlen((char *)text);
      if (0 < width) {
        local_20 = (byte *)0x0;
        local_2c = local_20;
        local_24 = text;
        do {
          if ((bVar5 == 10) || (bVar5 == 0)) goto LAB_08066163;
          if ((bVar1 & 1) == 0) {
            bVar5 = local_24[1];
            utf8_char = local_24 + 1;
            if ((bVar5 != 0) && (bVar5 != 10)) {
              ppuVar3 = __ctype_b_loc();
              while ((*(byte *)((int)*ppuVar3 + (uint)bVar5 * 2 + 1) & 0x20) == 0) {
                utf8_char = utf8_char + 1;
                bVar5 = *utf8_char;
                if ((bVar5 == 10) || (bVar5 == 0)) break;
              }
            }
            local_20 = utf8_char + -(int)text;
          }
          else {
            iVar7 = utf8charlen(local_24);
            iVar4 = utf8_char2cells(local_24,text + sVar2);
            bVar5 = *local_24;
            utf8_char = local_24;
            while ((utf8_char != local_24 + iVar7 && (bVar5 != 0))) {
              utf8_char = utf8_char + 1;
              bVar5 = *utf8_char;
            }
            local_20 = local_2c + iVar4;
            pbVar8 = utf8_char;
            while (((bVar5 != 10 && (bVar5 != 0)) &&
                   (ppuVar3 = __ctype_b_loc(),
                   (*(byte *)((int)*ppuVar3 + (uint)bVar5 * 2 + 1) & 0x20) == 0))) {
              if (utf8_char < pbVar8) {
                utf8_char = utf8_char + 1;
              }
              else {
                iVar7 = utf8_char2cells(utf8_char,text + sVar2);
                local_20 = local_20 + iVar7;
                iVar7 = utf8charlen(utf8_char);
                pbVar8 = pbVar8 + iVar7;
              }
              bVar5 = *utf8_char;
            }
          }
          if (width < (int)local_20) {
            if (text == local_24) {
              if ((bVar1 & 1) == 0) {
                local_2c = (byte *)width;
                local_24 = text + width;
                goto LAB_0806631c;
              }
              iVar7 = utf8_cells2bytes(text,width,(uchar *)0x0);
              local_24 = text + iVar7;
              local_2c = (byte *)utf8_ptr2cells(text,local_24);
              goto LAB_080663c8;
            }
            goto LAB_08066163;
          }
          bVar5 = *utf8_char;
          local_2c = local_20;
          local_24 = utf8_char;
        } while( true );
      }
      goto LAB_0806634a;
    }
  }
  return;
LAB_0806631c:
  if (text == local_24 + -1) goto LAB_080663dd;
  ppuVar3 = __ctype_b_loc();
  if ((*(byte *)(*ppuVar3 + local_24[-1]) & 4) != 0) goto LAB_080663c8;
  local_2c = local_2c + -1;
  local_24 = local_24 + -1;
  goto LAB_0806631c;
LAB_080663c8:
  if (text == local_24) {
LAB_080663dd:
    puVar6 = text + width;
    local_2c = (byte *)width;
    local_24 = (byte *)width;
  }
  else {
LAB_08066163:
    local_24 = local_24 + -(int)text;
    if ((int)local_24 < 1) {
LAB_0806634a:
      puVar6 = text + 1;
      goto LAB_0806620b;
    }
    puVar6 = text + (int)local_24;
  }
  if ((real_width != (int *)0x0) && (*real_width < (int)local_2c)) {
    *(byte **)real_width = local_2c;
  }
  if (format_only == 0) {
    if (align == ALIGN_CENTER) {
      iVar7 = (width - (int)local_2c) / 2;
    }
    else {
      iVar7 = width - (int)local_2c;
      if (align != ALIGN_RIGHT) {
        iVar7 = 0;
      }
    }
    if ((assert_failed == 0) &&
       (assert_failed = ZEXT14(width < (int)local_2c || width <= iVar7),
       width < (int)local_2c || width <= iVar7)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/text.c";
      errline = 0x100;
      elinks_internal((uchar *)"assertion cells <= width && shift < width failed!");
    }
    draw_text(term,iVar7 + x,*y,text,(int)local_24,0,color);
  }
LAB_0806620b:
  text = puVar6;
  *y = *y + 1;
  bVar5 = *text;
  if (bVar5 == 0) {
    return;
  }
  ppuVar3 = __ctype_b_loc();
  if ((*(byte *)((int)*ppuVar3 + (uint)bVar5 * 2 + 1) & 0x20) == 0) goto LAB_080660a8;
  text = text + 1;
  bVar5 = *text;
  if (bVar5 == 0) {
    return;
  }
  goto LAB_080660b0;
}



void dlg_format_text(terminal *term,widget_data *widget_data,int x,int *y,int width,int *real_width,
                    int max_height,int format_only)

{
  size_t size;
  format_align align;
  char *pcVar1;
  byte bVar2;
  color_pair *color;
  ushort **ppuVar3;
  size_t sVar4;
  uint uVar5;
  uchar *puVar6;
  byte bVar7;
  int iVar8;
  int iVar9;
  widget *pwVar10;
  uchar *puVar11;
  int iVar12;
  char *pcVar13;
  uint uVar14;
  bool bVar15;
  int iVar16;
  byte *pbVar17;
  char cVar18;
  byte *utf8_char;
  byte *p;
  int local_48;
  byte *local_38;
  byte *local_34;
  byte *local_30;
  uchar *local_20;
  
  pwVar10 = widget_data->widget;
  max_height = max_height + -3;
  if (max_height < 0) {
    max_height = 0;
  }
  local_30 = pwVar10->text;
  iVar16 = (widget_data->box).width;
  iVar8 = *y;
  iVar12 = x;
  if (x < 0) {
    iVar12 = 0;
  }
  if (iVar8 < 0) {
    iVar8 = 0;
  }
  iVar9 = 0;
  if (-1 < iVar16) {
    iVar9 = iVar16;
  }
  (widget_data->box).x = iVar12;
  (widget_data->box).y = iVar8;
  (widget_data->box).width = iVar9;
  (widget_data->box).height = max_height;
  if (max_height != 0) {
    if (((pwVar10->info[4] & 2) == 0) ||
       ((*(int *)(widget_data->info + 8) == width &&
        (*(int *)(widget_data->info + 4) == max_height ||
         *(int *)(widget_data->info + 4) < max_height)))) {
      bVar15 = false;
      cVar18 = '\0';
      *(undefined4 *)widget_data->info = 0;
      pcVar13 = (char *)0x0;
    }
    else {
      if (width != iVar9) {
        bVar2 = *(byte *)&term->field_0x38 >> 1;
        local_34 = pwVar10->text;
        local_20 = widget_data->cdata;
        if (width != *(int *)(widget_data->info + 8)) {
          (widget_data->box).width = 0;
          bVar7 = *local_34;
          if (bVar7 != 0) {
            ppuVar3 = __ctype_b_loc();
            local_48 = 0;
LAB_08066558:
            if ((*(byte *)((int)*ppuVar3 + (uint)bVar7 * 2 + 1) & 0x20) != 0) {
              local_34 = local_34 + 1;
              bVar7 = *local_34;
            }
            puVar11 = local_20;
            if (bVar7 != 0) {
              utf8_char = (byte *)0x1;
              sVar4 = strlen((char *)local_34);
              local_38 = (byte *)0x1;
              p = local_38;
              if (0 < width) {
                local_30 = (byte *)0x0;
                local_38 = local_30;
                p = local_34;
                do {
                  if ((bVar7 == 10) || (bVar7 == 0)) goto LAB_08066621;
                  if ((bVar2 & 1) == 0) {
                    bVar7 = p[1];
                    utf8_char = p + 1;
                    if ((bVar7 != 0) && (bVar7 != 10)) {
                      while ((*(byte *)((int)*ppuVar3 + (uint)bVar7 * 2 + 1) & 0x20) == 0) {
                        utf8_char = utf8_char + 1;
                        bVar7 = *utf8_char;
                        if ((bVar7 == 10) || (bVar7 == 0)) break;
                      }
                    }
                    local_30 = utf8_char + -(int)local_34;
                  }
                  else {
                    iVar16 = utf8charlen(p);
                    iVar8 = utf8_char2cells(p,local_34 + sVar4);
                    bVar7 = *p;
                    utf8_char = p;
                    while ((utf8_char != p + iVar16 && (bVar7 != 0))) {
                      utf8_char = utf8_char + 1;
                      bVar7 = *utf8_char;
                    }
                    local_30 = local_38 + iVar8;
                    pbVar17 = utf8_char;
                    while (((bVar7 != 10 && (bVar7 != 0)) &&
                           ((*(byte *)((int)*ppuVar3 + (uint)bVar7 * 2 + 1) & 0x20) == 0))) {
                      if (utf8_char < pbVar17) {
                        utf8_char = utf8_char + 1;
                      }
                      else {
                        iVar16 = utf8_char2cells(utf8_char,local_34 + sVar4);
                        local_30 = local_30 + iVar16;
                        iVar16 = utf8charlen(utf8_char);
                        pbVar17 = pbVar17 + iVar16;
                      }
                      bVar7 = *utf8_char;
                    }
                  }
                  if (width < (int)local_30) {
                    if (local_34 == p) {
                      if ((bVar2 & 1) == 0) {
                        local_38 = (byte *)width;
                        p = local_34 + width;
                        goto LAB_08066824;
                      }
                      iVar16 = utf8_cells2bytes(local_34,width,(uchar *)0x0);
                      p = local_34 + iVar16;
                      local_38 = (byte *)utf8_ptr2cells(local_34,p);
                      goto LAB_08066873;
                    }
                    goto LAB_08066621;
                  }
                  bVar7 = *utf8_char;
                  local_38 = local_30;
                  p = utf8_char;
                } while( true );
              }
              goto LAB_0806663f;
            }
            goto LAB_0806669f;
          }
          puVar11 = local_20;
          local_48 = 0;
LAB_0806669f:
          widget_data->cdata = puVar11;
          *(int *)(widget_data->info + 4) = local_48;
          *(int *)(widget_data->info + 8) = width;
        }
        if (local_20 == (uchar *)0x0) {
          return;
        }
      }
      iVar16 = *(int *)widget_data->info;
      iVar8 = *(int *)(widget_data->info + 4);
      if (iVar16 < 0) {
        *(undefined4 *)widget_data->info = 0;
        iVar12 = 0;
        iVar9 = 0;
      }
      else {
        iVar9 = iVar8 - max_height;
        if (iVar9 < max_height) {
          iVar9 = max_height;
        }
        if (iVar9 < iVar16) {
          *(int *)widget_data->info = iVar9;
          iVar12 = iVar9 * 4;
        }
        else {
          iVar12 = iVar16 * 4;
          iVar9 = iVar16;
        }
      }
      local_30 = *(byte **)(widget_data->cdata + iVar12);
      cVar18 = '\0';
      pcVar13 = (char *)0x0;
      if (max_height < iVar8 - iVar9) {
        pcVar1 = *(char **)(widget_data->cdata + (iVar9 + max_height) * 4);
        if ((iVar9 + max_height < 1) || (pcVar13 = pcVar1 + -1, pcVar1[-1] != '\n')) {
          cVar18 = *pcVar1;
          pcVar13 = pcVar1;
        }
        else {
          cVar18 = '\n';
        }
        *pcVar13 = '\0';
      }
      if ((real_width != (int *)0x0) && (iVar16 = (widget_data->box).width, *real_width < iVar16)) {
        *real_width = iVar16;
      }
      bVar15 = cVar18 != '\0' && pcVar13 != (char *)0x0;
      pwVar10 = widget_data->widget;
    }
    align = *(format_align *)pwVar10->info;
    color = get_bfu_color(term,"dialog.text");
    dlg_format_text_do(term,local_30,x,y,width,real_width,color,align,format_only);
    if ((widget_data->widget->info[4] & 1) != 0) {
      *y = *y + -1;
    }
    if (bVar15) {
      *pcVar13 = cVar18;
    }
  }
  return;
LAB_08066824:
  if (local_34 == p + -1) goto LAB_0806687c;
  if ((*(byte *)(*ppuVar3 + p[-1]) & 4) != 0) goto LAB_08066873;
  local_38 = local_38 + -1;
  p = p + -1;
  goto LAB_08066824;
LAB_08066873:
  if (local_34 == p) {
LAB_0806687c:
    local_38 = (byte *)width;
    utf8_char = (byte *)width;
  }
  else {
LAB_08066621:
    utf8_char = p + -(int)local_34;
    if ((int)(p + -(int)local_34) < 1) {
      utf8_char = (byte *)0x1;
    }
  }
  p = (byte *)0x1;
  if (0 < (int)local_38) {
    p = local_38;
  }
LAB_0806663f:
  local_38 = p;
  if ((widget_data->box).width < (int)local_38) {
    *(byte **)&(widget_data->box).width = local_38;
  }
  uVar5 = local_48 + 8U & 0xfffffff8;
  uVar14 = local_48 + 7U & 0xfffffff8;
  iVar16 = local_48 + 1;
  if (uVar14 < uVar5) {
    size = uVar5 * 4;
    puVar6 = (uchar *)mem_realloc(local_20,size);
    if (puVar6 == (uchar *)0x0) goto LAB_0806669f;
    memset(puVar6 + uVar14 * 4,0,size + uVar14 * -4);
    local_20 = puVar6;
  }
  if (local_20 == (uchar *)0x0) {
    puVar11 = (uchar *)0x0;
    goto LAB_0806669f;
  }
  *(byte **)(local_20 + iVar16 * 4 + -4) = local_34;
  local_34 = local_34 + (int)utf8_char;
  bVar7 = *local_34;
  puVar11 = local_20;
  local_48 = iVar16;
  if (bVar7 == 0) goto LAB_0806669f;
  goto LAB_08066558;
}



void __regparm3 format_and_display_text(widget_data *widget_data,dialog_data *dlg_data,int current)

{
  terminal *term;
  color_pair *color;
  int iVar1;
  int iVar2;
  int max_height;
  int local_20 [4];
  
  term = dlg_data->win->term;
  local_20[0] = (widget_data->box).y;
  iVar2 = (term->height * 9) / 10 + -4;
  max_height = 1;
  if (0 < iVar2) {
    iVar1 = term->height + -4;
    if (0 < iVar1) {
      max_height = iVar1;
    }
    if (iVar2 <= max_height) {
      max_height = iVar2;
    }
  }
  iVar2 = *(int *)(widget_data->info + 4);
  if (assert_failed == 0) {
    assert_failed = -(iVar2 >> 0x1f);
    if (assert_failed == 0) {
      iVar1 = (widget_data->box).height;
    }
    else {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/text.c";
      errline = 0x19e;
      elinks_internal((uchar *)"assertion lines >= 0 failed!");
      if (assert_failed != 0) goto LAB_080669d0;
      iVar1 = (widget_data->box).height;
    }
    assert_failed = -(iVar1 >> 0x1f);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/text.c";
      errline = 0x19f;
      elinks_internal((uchar *)"assertion widget_data->box.height >= 0 failed!");
    }
  }
LAB_080669d0:
  iVar1 = 0;
  if ((-1 < current) &&
     (iVar2 = iVar2 - (widget_data->box).height, iVar1 = current, iVar2 < current)) {
    iVar1 = iVar2;
  }
  if (*(int *)widget_data->info != iVar1) {
    *(int *)widget_data->info = iVar1;
    color = get_bfu_color(term,"dialog.generic");
    draw_box(term,&widget_data->box,' ',0,color);
    dlg_format_text(term,widget_data,(widget_data->box).x,local_20,(widget_data->box).width,
                    (int *)0x0,max_height,0);
    display_text(dlg_data,widget_data);
    redraw_from_window(dlg_data->win);
  }
  return;
}



widget_handler_status_T kbd_text(dialog_data *dlg_data,widget_data *widget_data)

{
  action_id_T aVar1;
  int current;
  
  current = *(int *)widget_data->info;
  aVar1 = kbd_action(KEYMAP_MENU,dlg_data->term_event,(int *)0x0);
  switch(aVar1) {
  case 4:
    current = current + 1;
    break;
  case 5:
    current = *(int *)(widget_data->info + 4);
    break;
  default:
    return EVENT_NOT_PROCESSED;
  case 8:
    current = 0;
    break;
  case 0xc:
    current = (widget_data->box).height + current;
    break;
  case 0xd:
    current = current - (widget_data->box).height;
    break;
  case 0x14:
    current = current + -1;
  }
  format_and_display_text(widget_data,dlg_data,current);
  return EVENT_PROCESSED;
}



widget_handler_status_T mouse_text(dialog_data *dlg_data,widget_data *widget_data)

{
  int iVar1;
  int iVar2;
  term_event *ptVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  int current;
  
  iVar1 = *(int *)widget_data->info;
  iVar2 = (widget_data->box).height;
  ptVar3 = dlg_data->term_event;
  current = (widget_data->box).y;
  iVar6 = (dlg_data->box).x + (dlg_data->box).width + -6;
  if (iVar6 < 0) {
    iVar6 = 0;
  }
  iVar4 = *(int *)((int)&ptVar3->info + 4);
  if (iVar6 <= *(int *)&ptVar3->info) {
    if (current < 0) {
      current = 0;
    }
    if ((current <= iVar4) && (*(int *)&ptVar3->info < iVar6 + 5)) {
      iVar6 = 0;
      if (-1 < iVar2) {
        iVar6 = iVar2;
      }
      if (iVar4 < iVar6 + current) {
        uVar5 = *(uint *)((int)&ptVar3->info + 8) & 7;
        iVar2 = (*(int *)(widget_data->info + 0xc) / 2 - *(int *)(widget_data->info + 0x14)) +
                *(int *)(widget_data->info + 0x10);
        if (uVar5 == 2) {
          current = iVar1 + -5;
          if (iVar2 < iVar4) {
            current = iVar1 + 5;
          }
        }
        else {
          if (uVar5 < 3) {
            if (uVar5 != 0) {
              return EVENT_NOT_PROCESSED;
            }
            current = iVar1 + -1;
            if (iVar2 < iVar4) {
              current = iVar1 + 1;
            }
          }
          else {
            if (uVar5 == 3) {
              current = iVar1 + -1;
            }
            else {
              if (uVar5 != 4) {
                return EVENT_NOT_PROCESSED;
              }
              current = iVar1 + 1;
            }
          }
        }
        *(uint *)(widget_data->info + 0x14) = (uint)(iVar1 < current) * 2 + -1;
        format_and_display_text(widget_data,dlg_data,current);
        return EVENT_PROCESSED;
      }
    }
  }
  return EVENT_NOT_PROCESSED;
}



// WARNING: Exceeded maximum restarts with more pending

void display_widget(dialog_data *dlg_data,widget_data *widget_data)

{
  widget_handler_T *UNRECOVERED_JUMPTABLE;
  
  UNRECOVERED_JUMPTABLE = widget_data->widget->ops->display;
  if (UNRECOVERED_JUMPTABLE != (widget_handler_T *)0x0) {
                    // WARNING: Could not recover jumptable at 0x08066cf4. Too many branches
                    // WARNING: Treating indirect jump as call
    (*UNRECOVERED_JUMPTABLE)();
    return;
  }
  return;
}



evhook_status bookmark_change_hook(va_list ap,void *data)

{
  if (*(bookmark **)ap != bm_snapshot_last_folder) {
    return EVENT_HOOK_STATUS_NEXT;
  }
  bm_snapshot_last_folder = (bookmark *)0x0;
  return EVENT_HOOK_STATUS_NEXT;
}



int change_hook_folder_state(session *ses,option_elinks *current,option_elinks *changed)

{
  if (changed->value == 0) {
    bookmarks_dirty = 1;
  }
  return 0;
}



void bookmarks_set_dirty(void)

{
  bookmarks_dirty = 1;
  return;
}



void bookmarks_unset_dirty(void)

{
  bookmarks_dirty = 0;
  return;
}



int bookmarks_are_dirty(void)

{
  return (uint)(bookmarks_dirty == 1);
}



void __regparm3 free_bookmarks(list_head_elinks *bookmarks_list,list_head_elinks *box_items)

{
  list_head_elinks *p;
  list_head_elinks *plVar1;
  list_head_elinks *plVar2;
  list_head_elinks *plVar3;
  
  p = (list_head_elinks *)bookmarks_list->next;
  while (p != bookmarks_list) {
    if ((list_head_elinks *)p[3].prev != (list_head_elinks *)&p[3].prev) {
      free_bookmarks((list_head_elinks *)&p[3].prev,(list_head_elinks *)((int)p[2].next + 8));
    }
    mem_free(p[2].prev);
    mem_free(p[3].next);
    p = (list_head_elinks *)p->next;
  }
  p = (list_head_elinks *)box_items->next;
  plVar1 = p;
  plVar3 = box_items;
  while (plVar1 != box_items) {
    plVar1 = (list_head_elinks *)plVar1->next;
    plVar3 = plVar1;
  }
  plVar1 = (list_head_elinks *)box_items->prev;
  while (plVar1 != plVar3) {
    plVar1 = (list_head_elinks *)plVar1->prev;
  }
  plVar1 = (list_head_elinks *)p->next;
  while (plVar2 = plVar1, p != plVar3) {
    plVar2->prev = p->prev;
    *(void **)p->prev = p->next;
    mem_free(p);
    plVar1 = (list_head_elinks *)plVar2->next;
    p = plVar2;
  }
  p = (list_head_elinks *)bookmarks_list->next;
  plVar1 = p;
  plVar3 = bookmarks_list;
  while (plVar1 != bookmarks_list) {
    plVar1 = (list_head_elinks *)plVar1->next;
    plVar3 = plVar1;
  }
  plVar1 = (list_head_elinks *)bookmarks_list->prev;
  while (plVar1 != plVar3) {
    plVar1 = (list_head_elinks *)plVar1->prev;
  }
  plVar1 = (list_head_elinks *)p->next;
  while (p != plVar3) {
    plVar1->prev = p->prev;
    *(void **)p->prev = p->next;
    mem_free(p);
    p = plVar1;
    plVar1 = (list_head_elinks *)plVar1->next;
  }
  if (bookmark_cache != (hash *)0x0) {
    free_hash(&bookmark_cache);
  }
  return;
}



bookmark * get_bookmark_by_name(bookmark *folder,uchar *title)

{
  bookmark *pbVar1;
  int iVar2;
  bookmark *pbVar3;
  
  pbVar3 = (bookmark *)&bookmarks;
  if (folder != (bookmark *)0x0) {
    pbVar3 = (bookmark *)&folder->child;
  }
  pbVar1 = pbVar3->next;
  while( true ) {
    if (pbVar1 == pbVar3) {
      return (bookmark *)0x0;
    }
    iVar2 = strcmp((char *)pbVar1->title,(char *)title);
    if (iVar2 == 0) break;
    pbVar1 = pbVar1->next;
  }
  return pbVar1;
}



void open_bookmark_folder(session *ses,uchar *foldername)

{
  int iVar1;
  uri *uri;
  void **ppvVar2;
  list_head_elinks *plVar3;
  void **local_20;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(foldername == (uchar *)0x0 || ses == (session *)0x0);
  if (foldername == (uchar *)0x0 || ses == (session *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bookmarks/bookmarks.c";
    errline = 0x2de;
    elinks_internal((uchar *)"assertion foldername && ses failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  plVar3 = (list_head_elinks *)bookmarks.next;
  if ((list_head_elinks *)bookmarks.next != &bookmarks) {
    do {
      if ((*(int *)((int)plVar3[2].next + 0x10) == 1) &&
         (iVar1 = strcmp((char *)plVar3[2].prev,(char *)foldername), iVar1 == 0)) {
        ppvVar2 = (void **)plVar3[3].prev;
        if (ppvVar2 == &plVar3[3].prev) {
          return;
        }
        local_20 = (void **)0x0;
        do {
          if (((*(int *)((int)ppvVar2[4] + 0x10) - 1U < 2) || (*(uchar *)ppvVar2[6] == '\0')) ||
             (uri = get_translated_uri((uchar *)ppvVar2[6],(uchar *)0x0), uri == (uri *)0x0)) {
            ppvVar2 = (void **)*ppvVar2;
          }
          else {
            if (local_20 == (void **)0x0) {
              goto_uri(ses,uri);
              local_20 = ppvVar2;
            }
            else {
              open_uri_in_new_tab(ses,uri,1,0);
            }
            done_uri(uri);
            ppvVar2 = (void **)*ppvVar2;
          }
        } while (ppvVar2 != &plVar3[3].prev);
        return;
      }
      plVar3 = (list_head_elinks *)plVar3->next;
    } while (plVar3 != &bookmarks);
  }
  return;
}



uchar * get_auto_save_bookmark_foldername_utf8(void)

{
  uchar **ppuVar1;
  int from;
  int to;
  conv_table *convert_table;
  size_t charslen;
  uchar *chars;
  uchar *in_EDX;
  
  ppuVar1 = (uchar **)get_opt_(config_options,in_EDX);
  chars = *ppuVar1;
  if (*chars != '\0') {
    from = get_cp_index((uchar *)"System");
    to = get_cp_index("UTF-8");
    convert_table = get_translation_table(from,to);
    if (convert_table != (conv_table *)0x0) {
      charslen = strlen((char *)chars);
      chars = convert_string_elinks
                        (convert_table,chars,charslen,to,CSM_NONE,(int *)0x0,
                         (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
      return chars;
    }
  }
  return (uchar *)0x0;
}



bookmark * get_bookmark(uchar *url)

{
  hash *hash;
  size_t keylen;
  hash_item *phVar1;
  
  hash = bookmark_cache;
  if (((url != (uchar *)0x0) && (bookmark_cache != (hash *)0x0)) && (*url != '\0')) {
    keylen = strlen((char *)url);
    phVar1 = get_hash_item(hash,url,keylen);
    if (phVar1 != (hash_item *)0x0) {
      return (bookmark *)phVar1->value;
    }
  }
  return (bookmark *)0x0;
}



int update_bookmark(bookmark *bm,int codepage,uchar *title,uchar *url)

{
  hash *hash;
  int update_bookmark_event_id;
  int to;
  conv_table *convert_table;
  size_t keylen;
  hash_item *item;
  uchar *url_00;
  uchar *title_00;
  
  to = get_cp_index("UTF-8");
  convert_table = get_translation_table(codepage,to);
  if (convert_table == (conv_table *)0x0) {
    return 0;
  }
  url_00 = (uchar *)0x0;
  if (url != (uchar *)0x0) {
    keylen = strlen((char *)url);
    url_00 = convert_string_elinks
                       (convert_table,url,keylen,to,CSM_NONE,(int *)0x0,
                        (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
    if (url_00 == (uchar *)0x0) {
      return 0;
    }
    sanitize_url(url_00);
  }
  title_00 = (uchar *)0x0;
  if (title != (uchar *)0x0) {
    keylen = strlen((char *)title);
    title_00 = convert_string_elinks
                         (convert_table,title,keylen,to,CSM_NONE,(int *)0x0,
                          (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
    if (title_00 == (uchar *)0x0) {
      if (url_00 == (uchar *)0x0) {
        return 0;
      }
      mem_free(url_00);
      return 0;
    }
    sanitize_title(title_00);
  }
  if (update_bookmark_event_id == -1) {
    update_bookmark_event_id = get_event_id((uchar *)"bookmark-update");
  }
  trigger_event(update_bookmark_event_id,bm,title_00,url_00);
  if (title_00 != (uchar *)0x0) {
    if (bm->title != (uchar *)0x0) {
      mem_free(bm->title);
    }
    bm->title = title_00;
  }
  hash = bookmark_cache;
  if (url_00 == (uchar *)0x0) {
    bookmarks_dirty = 1;
    return 1;
  }
  if (bookmark_cache != (hash *)0x0) {
    title_00 = bm->url;
    if ((title_00 != (uchar *)0x0) && (*title_00 != '\0')) {
      keylen = strlen((char *)title_00);
      item = get_hash_item(hash,title_00,keylen);
      if (item != (hash_item *)0x0) {
        del_hash_item(bookmark_cache,item);
      }
      if (bookmark_cache == (hash *)0x0) {
        title_00 = bm->url;
        goto joined_r0x080672ea;
      }
    }
    hash = bookmark_cache;
    if (*url_00 != '\0') {
      keylen = strlen((char *)url_00);
      add_hash_item(hash,url_00,keylen,bm);
    }
  }
  title_00 = bm->url;
joined_r0x080672ea:
  if (title_00 != (uchar *)0x0) {
    mem_free(title_00);
  }
  bm->url = url_00;
  bookmarks_dirty = 1;
  return 1;
}



// WARNING: Type propagation algorithm not settling

bookmark * add_bookmark(bookmark *root,int place,uchar *title,uchar *url)

{
  hash *hash;
  bookmark *p;
  uchar *title_00;
  listbox_item_type type;
  size_t keylen;
  listbox_item *root_00;
  bookmark *pbVar1;
  
  p = (bookmark *)mem_calloc(1,0x24);
  pbVar1 = p;
  if (p != (bookmark *)0x0) {
    title_00 = stracpy(title);
    p->title = title_00;
    if (title_00 != (uchar *)0x0) {
      sanitize_title(title_00);
      title_00 = "";
      if (url != (uchar *)0x0) {
        title_00 = url;
      }
      title_00 = stracpy(title_00);
      p->url = title_00;
      if (title_00 != (uchar *)0x0) {
        sanitize_url(title_00);
        p->root = root;
        *(list_head_elinks **)&(p->child).prev = &p->child;
        *(list_head_elinks **)&(p->child).next = &p->child;
        if (((url == (uchar *)0x0) || (type = BI_LEAF, *url == '\0')) &&
           ((title == (uchar *)0x0 || ((*title != '-' || (type = BI_SEPARATOR, title[1] != '\0')))))
           ) {
          type = BI_FOLDER;
        }
        root_00 = (listbox_item *)0x0;
        if (root != (bookmark *)0x0) {
          root_00 = root->box_item;
        }
        root_00 = add_listbox_item(&bookmark_browser,root_00,type,p,(-(uint)(place == 0) & 2) - 1);
        p->box_item = root_00;
        if (root_00 == (listbox_item *)0x0) {
          mem_free(p->url);
          mem_free(p->title);
          mem_free(p);
          return (bookmark *)0x0;
        }
        if (place == 0) {
          if (root == (bookmark *)0x0) {
            *(list_head_elinks **)&p->prev = &bookmarks;
            p->next = bookmarks.next;
            bookmarks.next = p;
            p->next->prev = p;
          }
          else {
            pbVar1 = (bookmark *)(root->child).next;
            p->prev = (bookmark *)&root->child;
            p->next = pbVar1;
            *(bookmark **)&(root->child).next = p;
            p->next->prev = p;
          }
        }
        else {
          if (root == (bookmark *)0x0) {
            p->next = *(bookmark **)bookmarks.prev;
            p->prev = bookmarks.prev;
            *(bookmark **)bookmarks.prev = p;
            p->next->prev = p;
          }
          else {
            p->next = *(bookmark **)(root->child).prev;
            p->prev = (bookmark *)(root->child).prev;
            ((bookmark *)(root->child).prev)->next = p;
            p->next->prev = p;
          }
        }
        bookmarks_dirty = 1;
        if ((bookmark_cache == (hash *)0x0) &&
           (bookmark_cache = init_hash8(), bookmark_cache == (hash *)0x0)) {
          return p;
        }
        hash = bookmark_cache;
        title_00 = p->url;
        if (title_00 == (uchar *)0x0) {
          return p;
        }
        if (*title_00 == '\0') {
          return p;
        }
        keylen = strlen((char *)title_00);
        add_hash_item(hash,title_00,keylen,p);
        return p;
      }
      mem_free(p->title);
    }
    pbVar1 = (bookmark *)0x0;
    mem_free(p);
  }
  return pbVar1;
}



bookmark * add_bookmark_cp(bookmark *root,int place,int codepage,uchar *title,uchar *url)

{
  int to;
  conv_table *convert_table;
  size_t charslen;
  uchar *title_00;
  uchar *url_00;
  bookmark *pbVar1;
  
  to = get_cp_index("UTF-8");
  if (url == (uchar *)0x0) {
    url = "";
  }
  convert_table = get_translation_table(codepage,to);
  if (convert_table == (conv_table *)0x0) {
    return (bookmark *)0x0;
  }
  charslen = strlen((char *)title);
  title_00 = convert_string_elinks
                       (convert_table,title,charslen,to,CSM_NONE,(int *)0x0,
                        (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
  charslen = strlen((char *)url);
  url_00 = convert_string_elinks
                     (convert_table,url,charslen,to,CSM_NONE,(int *)0x0,
                      (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
  if (url_00 != (uchar *)0x0) {
    if (title_00 != (uchar *)0x0) {
      pbVar1 = add_bookmark(root,place,title_00,url_00);
      goto LAB_080676e9;
    }
  }
  else {
    pbVar1 = (bookmark *)0x0;
    if (title_00 != (uchar *)0x0) {
LAB_080676e9:
      mem_free(title_00);
      goto LAB_080676f7;
    }
  }
  pbVar1 = (bookmark *)0x0;
LAB_080676f7:
  if (url_00 != (uchar *)0x0) {
    mem_free(url_00);
  }
  return pbVar1;
}



void __regparm3 bookmark_terminal(terminal *term,bookmark *folder)

{
  int iVar1;
  session *ses;
  list_head_elinks *plVar2;
  int codepage;
  uchar *puVar3;
  int in_GS_OFFSET;
  uchar url [1024];
  uchar title [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  codepage = get_terminal_codepage(term);
  plVar2 = (list_head_elinks *)(term->windows).prev;
  do {
    while( true ) {
      if (plVar2 == &term->windows) {
        if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
          return;
        }
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      if (plVar2[1].next == (void *)0x1) break;
LAB_08067780:
      plVar2 = (list_head_elinks *)plVar2->prev;
    }
    ses = (session *)plVar2[2].next;
    puVar3 = get_current_url(ses,url,0x400);
    if ((puVar3 == (uchar *)0x0) ||
       (puVar3 = get_current_title(ses,title,0x400), puVar3 == (uchar *)0x0)) goto LAB_08067780;
    add_bookmark_cp(folder,1,codepage,title,url);
    plVar2 = (list_head_elinks *)plVar2->prev;
  } while( true );
}



void bookmark_terminal_tabs(terminal *term,uchar *foldername)

{
  bookmark *folder;
  
  folder = add_bookmark((bookmark *)0x0,1,foldername,(uchar *)0x0);
  if (folder != (bookmark *)0x0) {
    bookmark_terminal(term,folder);
    return;
  }
  return;
}



void delete_bookmark(bookmark *bm)

{
  uchar *key;
  bookmark *bm_00;
  hash *hash;
  int delete_bookmark_event_id;
  size_t keylen;
  hash_item *item;
  
  bm_00 = (bookmark *)(bm->child).next;
  hash = bookmark_cache;
  while (bookmark_cache = hash, bm_00 != (bookmark *)&bm->child) {
    delete_bookmark(bm_00);
    bm_00 = (bookmark *)(bm->child).next;
    hash = bookmark_cache;
  }
  if (((hash != (hash *)0x0) && (key = bm->url, key != (uchar *)0x0)) && (*key != '\0')) {
    keylen = strlen((char *)key);
    item = get_hash_item(hash,key,keylen);
    if (item != (hash_item *)0x0) {
      del_hash_item(bookmark_cache,item);
    }
  }
  if (delete_bookmark_event_id == -1) {
    delete_bookmark_event_id = get_event_id((uchar *)"bookmark-delete");
  }
  trigger_event(delete_bookmark_event_id,bm);
  bm->next->prev = bm->prev;
  bm->prev->next = bm->next;
  bookmarks_dirty = 1;
  done_listbox_item(&bookmark_browser,bm->box_item);
  mem_free(bm->title);
  mem_free(bm->url);
  mem_free(bm);
  return;
}



void bookmark_auto_save_tabs(terminal *term)

{
  bookmark *pbVar1;
  int *piVar2;
  uchar *foldername;
  int iVar3;
  uchar *in_EDX;
  bookmark *pbVar4;
  bookmark *bm;
  
  piVar2 = get_opt_(cmdline_options,in_EDX);
  if (((*piVar2 != 0) || (piVar2 = get_opt_(config_options,(uchar *)0x0), *piVar2 == 0)) ||
     (foldername = get_auto_save_bookmark_foldername_utf8(), foldername == (uchar *)0x0)) {
    return;
  }
  pbVar1 = *(bookmark **)bookmarks.next;
  bm = (bookmark *)bookmarks.next;
  if ((list_head_elinks *)bookmarks.next != &bookmarks) {
    do {
      while (((pbVar4 = pbVar1, bm->url != (uchar *)0x0 && (*bm->url != '\0')) ||
             (iVar3 = strcmp((char *)bm->title,(char *)foldername), iVar3 != 0))) {
        pbVar1 = pbVar4->next;
        bm = pbVar4;
        if (pbVar4 == (bookmark *)&bookmarks) goto LAB_08067a40;
      }
      delete_bookmark(bm);
      pbVar1 = pbVar4->next;
      bm = pbVar4;
    } while (pbVar4 != (bookmark *)&bookmarks);
  }
LAB_08067a40:
  bookmark_terminal_tabs(term,foldername);
  mem_free(foldername);
  return;
}



void write_bookmarks(void)

{
  int *piVar1;
  uchar *in_EDX;
  
  piVar1 = get_opt_(cmdline_options,in_EDX);
  if (*piVar1 != 0) {
    bookmarks_dirty = 0;
    return;
  }
  bookmarks_write(&bookmarks);
  return;
}



void done_bookmarks(module *module)

{
  if (bm_snapshot_last_folder != (bookmark *)0x0) {
    delete_bookmark(bm_snapshot_last_folder);
  }
  bm_snapshot_last_folder = (bookmark *)0x0;
  write_bookmarks();
  free_bookmarks(&bookmarks,&bookmark_browser.root.child);
  free_last_searched_bookmark();
  return;
}



evhook_status bookmark_write_hook(va_list ap,void *data)

{
  option_elinks *poVar1;
  int *piVar2;
  string *psVar3;
  uchar **ppuVar4;
  int codepage;
  option_elinks *folder;
  bookmark *folder_00;
  uint uVar5;
  uchar *in_EDX;
  uchar *name;
  uchar *name_00;
  uchar *name_01;
  terminal *term;
  uint width;
  option_elinks *local_5c;
  option_elinks *string;
  char *local_58;
  string folderstring;
  uchar subfoldername [4];
  
  local_58 = "ui.sessions.snapshot";
  local_5c = config_options;
  piVar2 = get_opt_(config_options,in_EDX);
  poVar1 = (option_elinks *)bm_snapshot_last_folder;
  if (*piVar2 != 0) {
    local_58 = "anonymous";
    local_5c = cmdline_options;
    piVar2 = get_opt_(cmdline_options,name);
    poVar1 = (option_elinks *)bm_snapshot_last_folder;
    if (*piVar2 == 0) {
      string = (option_elinks *)&folderstring;
      local_5c = string;
      psVar3 = init_string((string *)string);
      poVar1 = (option_elinks *)bm_snapshot_last_folder;
      if (psVar3 != (string *)0x0) {
        add_to_string((string *)string,(uchar *)"Session snapshot");
        add_to_string((string *)string," - ");
        ppuVar4 = (uchar **)get_opt_(config_options,name_00);
        add_date_to_string((string *)string,*ppuVar4,(time_t *)0x0);
        codepage = get_cp_index((uchar *)"System");
        local_58 = (char *)0x1;
        folder = (option_elinks *)
                 add_bookmark_cp((bookmark *)0x0,1,codepage,folderstring.source,(uchar *)0x0);
        done_string((string *)string);
        poVar1 = (option_elinks *)bm_snapshot_last_folder;
        local_5c = string;
        if (folder != (option_elinks *)0x0) {
          local_58 = "anonymous";
          local_5c = cmdline_options;
          piVar2 = get_opt_(cmdline_options,name_01);
          if (*piVar2 == 0) {
            if (terminals.next == terminals.prev) {
              bookmark_terminal((terminal *)terminals.next,(bookmark *)folder);
            }
            else {
              if ((list_head_elinks *)terminals.next != &terminals) {
                width = 0;
                term = (terminal *)terminals.next;
                while( true ) {
                  local_58 = (char *)0x0;
                  local_5c = (option_elinks *)subfoldername;
                  uVar5 = elinks_ulongcat((uchar *)(option_elinks *)subfoldername,(uint *)0x0,width,
                                          '\x04',0,10);
                  if (3 < uVar5) break;
                  local_58 = (char *)0x1;
                  local_5c = folder;
                  folder_00 = add_bookmark((bookmark *)folder,1,
                                           (uchar *)(option_elinks *)subfoldername,(uchar *)0x0);
                  if (folder_00 == (bookmark *)0x0) break;
                  bookmark_terminal(term,folder_00);
                  term = term->next;
                  if (term == (terminal *)&terminals) break;
                  width = width + 1;
                }
              }
            }
          }
          poVar1 = folder;
          if (bm_snapshot_last_folder != (bookmark *)0x0) {
            delete_bookmark(bm_snapshot_last_folder);
            local_5c = (option_elinks *)bm_snapshot_last_folder;
          }
        }
      }
    }
  }
  bm_snapshot_last_folder = (bookmark *)poVar1;
  write_bookmarks(local_5c,local_58);
  return EVENT_HOOK_STATUS_NEXT;
}



void read_bookmarks(void)

{
  bookmarks_read();
  return;
}



void init_bookmarks(module *module)

{
  change_hook_info bookmarks_change_hooks [2];
  
  register_change_hooks((change_hook_info *)&ram0x08101100);
  bookmarks_read();
  return;
}



void lock_bookmark(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + 1;
  return;
}



void unlock_bookmark(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



int is_bookmark_used(listbox_item *item)

{
  return (uint)(*(int *)((int)item->udata + 8) != 0);
}



listbox_item * get_bookmark_root(listbox_item *item)

{
  int iVar1;
  listbox_item *plVar2;
  
  iVar1 = *(int *)((int)item->udata + 0xc);
  plVar2 = (listbox_item *)0x0;
  if (iVar1 != 0) {
    plVar2 = *(listbox_item **)(iVar1 + 0x10);
  }
  return plVar2;
}



int can_delete_bookmark(listbox_item *item)

{
  return 1;
}



void bookmark_edit_cancel(dialog *dlg)

{
  int *piVar1;
  
  piVar1 = (int *)((int)dlg->udata2 + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



void __regparm3 update_depths(listbox_item *parent)

{
  listbox_item *parent_00;
  
  parent_00 = (listbox_item *)(parent->child).next;
  do {
    if (parent_00 == (listbox_item *)&parent->child) {
      return;
    }
    while (parent_00->depth = parent->depth + 1, parent_00->type != BI_FOLDER) {
      parent_00 = parent_00->next;
      if (parent_00 == (listbox_item *)&parent->child) {
        return;
      }
    }
    update_depths(parent_00);
    parent_00 = parent_00->next;
  } while( true );
}



void delete_bookmark_item(listbox_item *item,int last)

{
  bookmark *bm;
  bool bVar1;
  
  bm = (bookmark *)item->udata;
  if ((assert_failed == 0) &&
     (bVar1 = (bm->object).refcount != 0, assert_failed = ZEXT14(bVar1), bVar1)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bookmarks/dialogs.c";
    errline = 0x8a;
    elinks_internal((uchar *)"assertion !is_object_used(bookmark) failed!");
  }
  delete_bookmark(bm);
  if (last == 0) {
    return;
  }
  write_bookmarks();
  return;
}



uri * get_bookmark_uri(listbox_item *item)

{
  uchar *uristring;
  uri *puVar1;
  
  uristring = *(uchar **)((int)item->udata + 0x18);
  if ((uristring != (uchar *)0x0) && (*uristring != '\0')) {
    puVar1 = get_translated_uri(uristring,(uchar *)0x0);
    return puVar1;
  }
  return (uri *)0x0;
}



uchar * get_bookmark_text(listbox_item *item,terminal *term)

{
  void *pvVar1;
  int from;
  int to;
  conv_table *convert_table;
  uchar *chars;
  size_t charslen;
  
  pvVar1 = item->udata;
  from = get_cp_index("UTF-8");
  to = get_terminal_codepage(term);
  convert_table = get_translation_table(from,to);
  chars = (uchar *)0x0;
  if (convert_table != (conv_table *)0x0) {
    chars = *(uchar **)((int)pvVar1 + 0x14);
    charslen = strlen((char *)chars);
    chars = convert_string_elinks
                      (convert_table,chars,charslen,to,CSM_NONE,(int *)0x0,
                       (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
  }
  return chars;
}



uchar * __regparm3 _(terminal *term)

{
  int cp_index;
  uchar *codeset;
  terminal *in_EDX;
  
  if ((term != (terminal *)0x0) && (*(char *)&term->next != '\0')) {
    if (in_EDX != (terminal *)0x0) {
      cp_index = get_terminal_codepage(in_EDX);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    term = (terminal *)gettext((uchar *)term);
  }
  return (uchar *)term;
}



uchar * get_bookmark_info(listbox_item *item,terminal *term)

{
  void *pvVar1;
  int from;
  int to;
  conv_table *convert_table;
  string *psVar2;
  uchar *chars;
  size_t charslen;
  string info;
  
  pvVar1 = item->udata;
  from = get_cp_index("UTF-8");
  to = get_terminal_codepage(term);
  if (((item->type != BI_FOLDER) &&
      (convert_table = get_translation_table(from,to), convert_table != (conv_table *)0x0)) &&
     (psVar2 = init_string(&info), psVar2 != (string *)0x0)) {
    chars = _((terminal *)"Title");
    add_format_to_string(&info,"%s: ",chars);
    chars = *(uchar **)((int)pvVar1 + 0x14);
    charslen = strlen((char *)chars);
    convert_string_elinks
              (convert_table,chars,charslen,to,CSM_NONE,(int *)0x0,add_converted_bytes_to_string,
               &info);
    chars = _((terminal *)0x812b6c9);
    add_format_to_string(&info,"\n%s: ",chars);
    chars = *(uchar **)((int)pvVar1 + 0x18);
    charslen = strlen((char *)chars);
    convert_string_elinks
              (convert_table,chars,charslen,to,CSM_NONE,(int *)0x0,add_converted_bytes_to_string,
               &info);
    return info.source;
  }
  return (uchar *)0x0;
}



void add_converted_bytes_to_string(void *data,uchar *buf,int buflen)

{
  int iVar1;
  void *pvVar2;
  uint uVar3;
  uint size;
  
  if (assert_failed == 0) {
    if (((buf == (uchar *)0x0) || (data == (void *)0x0)) || (buflen < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_08068188;
    }
    else {
      assert_failed = 0;
    }
    if (buflen != 0) {
      iVar1 = buflen + *(int *)((int)data + 4);
      uVar3 = *(int *)((int)data + 4) + 0xffU & 0xffffff00;
      size = iVar1 + 0x100U & 0xffffff00;
      if (uVar3 < size) {
        pvVar2 = mem_realloc(*(void **)data,size);
        if (pvVar2 == (void *)0x0) {
          return;
        }
        *(void **)data = pvVar2;
        memset((void *)((int)pvVar2 + uVar3),0,size - uVar3);
      }
      if (*(int *)data != 0) {
        memcpy((void *)(*(int *)data + *(int *)((int)data + 4)),buf,buflen);
        *(undefined *)(*(int *)data + iVar1) = 0;
        *(int *)((int)data + 4) = iVar1;
      }
    }
  }
  else {
LAB_08068188:
    assert_failed = 0;
  }
  return;
}



void free_last_searched_bookmark(void)

{
  if (bm_last_searched_title != (uchar *)0x0) {
    mem_free(bm_last_searched_title);
  }
  bm_last_searched_title = (uchar *)0x0;
  if (bm_last_searched_url != (uchar *)0x0) {
    mem_free(bm_last_searched_url);
  }
  bm_last_searched_url = (uchar *)0x0;
  return;
}



widget_handler_status_T push_search_button(dialog_data *dlg_data,widget_data *widget_data)

{
  session *ses;
  terminal *term;
  int from;
  int to;
  conv_table *convert_table;
  size_t charslen;
  uchar *chars;
  uchar *src_url;
  
  ses = (session *)dlg_data->dlg->udata;
  term = dlg_data->win->term;
  if ((bm_last_searched_title != (uchar *)0x0) && (bm_last_searched_url != (uchar *)0x0)) {
    from = get_cp_index("UTF-8");
    to = get_terminal_codepage(term);
    convert_table = get_translation_table(from,to);
    chars = bm_last_searched_title;
    if (convert_table != (conv_table *)0x0) {
      charslen = strlen((char *)bm_last_searched_title);
      chars = convert_string_elinks
                        (convert_table,chars,charslen,to,CSM_NONE,(int *)0x0,
                         (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
      charslen = strlen((char *)bm_last_searched_url);
      src_url = convert_string_elinks
                          (convert_table,bm_last_searched_url,charslen,to,CSM_NONE,(int *)0x0,
                           (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
      if (src_url == (uchar *)0x0) {
        if (chars != (uchar *)0x0) {
          mem_free(chars);
        }
      }
      else {
        if (chars != (uchar *)0x0) {
          do_edit_dialog(term,1,(uchar *)"Search bookmarks",chars,src_url,ses,dlg_data,
                         bookmark_search_do,(anon_subr_void_dialog_ptr *)0x0,(void *)0x0,
                         EDIT_DLG_SEARCH);
          mem_free(chars);
          mem_free(src_url);
          return EVENT_PROCESSED;
        }
        mem_free(src_url);
      }
    }
  }
  do_edit_dialog(term,1,(uchar *)"Search bookmarks",(uchar *)0x0,(uchar *)0x0,ses,dlg_data,
                 bookmark_search_do,(anon_subr_void_dialog_ptr *)0x0,(void *)0x0,EDIT_DLG_SEARCH);
  return EVENT_PROCESSED;
}



void launch_bm_add_dialog(terminal *term,dialog_data *parent,session *ses,uchar *title,uchar *url)

{
  do_edit_dialog(term,1,(uchar *)"Add bookmark",title,url,ses,parent,bookmark_add_add,
                 (anon_subr_void_dialog_ptr *)0x0,term,EDIT_DLG_ADD);
  return;
}



void launch_bm_add_doc_dialog(terminal *term,dialog_data *parent,session *ses)

{
  launch_bm_add_dialog(term,parent,ses,(uchar *)0x0,(uchar *)0x0);
  return;
}



widget_handler_status_T push_add_button(dialog_data *dlg_data,widget_data *widget_data)

{
  launch_bm_add_doc_dialog(dlg_data->win->term,dlg_data,(session *)dlg_data->dlg->udata);
  return EVENT_PROCESSED;
}



widget_handler_status_T push_edit_button(dialog_data *dlg_data,widget_data *edit_btn)

{
  void *done_data;
  listbox_data *plVar1;
  int from;
  int to;
  conv_table *convert_table;
  size_t charslen;
  uchar *src_name;
  uchar *chars;
  
  plVar1 = get_listbox_widget_data(dlg_data->widgets_data);
  if (plVar1->sel == (listbox_item *)0x0) {
    return EVENT_PROCESSED;
  }
  done_data = plVar1->sel->udata;
  from = get_cp_index("UTF-8");
  to = get_terminal_codepage(dlg_data->win->term);
  convert_table = get_translation_table(from,to);
  if (convert_table == (conv_table *)0x0) {
    return EVENT_PROCESSED;
  }
  chars = *(uchar **)((int)done_data + 0x14);
  charslen = strlen((char *)chars);
  src_name = convert_string_elinks
                       (convert_table,chars,charslen,to,CSM_NONE,(int *)0x0,
                        (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
  chars = *(uchar **)((int)done_data + 0x18);
  charslen = strlen((char *)chars);
  chars = convert_string_elinks
                    (convert_table,chars,charslen,to,CSM_NONE,(int *)0x0,
                     (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
  if (chars != (uchar *)0x0) {
    if (src_name == (uchar *)0x0) goto LAB_0806862f;
    *(int *)((int)done_data + 8) = *(int *)((int)done_data + 8) + 1;
    do_edit_dialog(dlg_data->win->term,1,(uchar *)"Edit bookmark",src_name,chars,
                   (session *)dlg_data->dlg->udata,dlg_data,bookmark_edit_done,bookmark_edit_cancel,
                   done_data,EDIT_DLG_ADD);
  }
  else {
    if (src_name == (uchar *)0x0) {
      return EVENT_PROCESSED;
    }
  }
  mem_free(src_name);
LAB_0806862f:
  if (chars != (uchar *)0x0) {
    mem_free(chars);
  }
  return EVENT_PROCESSED;
}



void bookmark_search_do(void *data)

{
  int *piVar1;
  uchar *chars;
  uchar *chars_00;
  int from;
  conv_table *convert_table;
  size_t charslen;
  listbox_data *box;
  uchar *src;
  widget_data *widget_data;
  bool bVar2;
  bookmark_search_ctx ctx;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  ctx.url = (uchar *)0x0;
  ctx.title = (uchar *)0x0;
  ctx.found = 0;
  ctx.offset = 0;
  ctx.utf8_cp = -1;
  ctx.system_cp = -1;
  bVar2 = *(int *)((int)data + 4) == 0;
  assert_failed = ZEXT14(bVar2);
  if (bVar2) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bookmarks/dialogs.c";
    errline = 0x2ee;
    elinks_internal((uchar *)
                    "assertion dlg->udata != NULL failed: Bookmark search with NULL udata in dialog"
                   );
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  piVar1 = *(int **)((int)data + 4);
  from = get_terminal_codepage(*(terminal **)(*piVar1 + 0x14));
  ctx.system_cp = get_cp_index((uchar *)"System");
  ctx.utf8_cp = get_cp_index("UTF-8");
  chars = *(uchar **)((int)data + 0x30);
  chars_00 = *(uchar **)((int)data + 0x60);
  convert_table = get_translation_table(from,ctx.system_cp);
  if (convert_table == (conv_table *)0x0) goto free_all;
  charslen = strlen((char *)chars);
  src = (uchar *)0x0;
  ctx.title = convert_string_elinks
                        (convert_table,chars,charslen,ctx.system_cp,CSM_NONE,(int *)0x0,
                         (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
  if (ctx.title == (uchar *)0x0) goto LAB_08068911;
  convert_table = get_translation_table(from,ctx.utf8_cp);
  if (convert_table == (conv_table *)0x0) {
free_all:
    src = (uchar *)0x0;
  }
  else {
    charslen = strlen((char *)chars_00);
    ctx.url = convert_string_elinks
                        (convert_table,chars_00,charslen,ctx.utf8_cp,CSM_NONE,(int *)0x0,
                         (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
    if (ctx.url == (uchar *)0x0) goto free_all;
    charslen = strlen((char *)chars);
    src = convert_string_elinks
                    (convert_table,chars,charslen,ctx.utf8_cp,CSM_NONE,(int *)0x0,
                     (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
    chars = ctx.url;
    if (src != (uchar *)0x0) {
      if (bm_last_searched_title != (uchar *)0x0) {
        mem_free(bm_last_searched_title);
      }
      bm_last_searched_title = stracpy(src);
      if (bm_last_searched_title != (uchar *)0x0) {
        if (bm_last_searched_url != (uchar *)0x0) {
          mem_free(bm_last_searched_url);
        }
        bm_last_searched_url = stracpy(chars);
        if (bm_last_searched_url == (uchar *)0x0) {
          if (bm_last_searched_title != (uchar *)0x0) {
            mem_free(bm_last_searched_title);
          }
          bm_last_searched_title = (uchar *)0x0;
        }
        else {
          widget_data = (widget_data *)(piVar1 + 10);
          box = get_listbox_widget_data(widget_data);
          traverse_listbox_items_list(box->sel,box,0,0,test_search,&ctx);
          if (ctx.found != 0) {
            listbox_sel_move(widget_data,ctx.offset + -1);
          }
        }
      }
    }
  }
  if (ctx.title != (uchar *)0x0) {
    mem_free(ctx.title);
  }
LAB_08068911:
  if (ctx.url != (uchar *)0x0) {
    mem_free(ctx.url);
  }
  if (src != (uchar *)0x0) {
    mem_free(src);
  }
  return;
}



int test_search(listbox_item *item,void *data_,int *offset)

{
  void *pvVar1;
  conv_table *convert_table;
  size_t charslen;
  uchar *chars;
  char *pcVar2;
  
  if (*(int *)((int)data_ + 0xc) == 0) {
    *(undefined4 *)((int)data_ + 8) = 0;
    goto LAB_080689fe;
  }
  pvVar1 = item->udata;
  if (assert_failed == 0) {
    if ((*(int *)((int)data_ + 4) == 0) || (*(int *)data_ == 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bookmarks/dialogs.c";
      errline = 0x298;
      elinks_internal((uchar *)"assertion ctx->title && ctx->url failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  if ((**(char **)data_ == '\0') ||
     (pcVar2 = c_strcasestr(*(char **)((int)pvVar1 + 0x18),*(char **)data_), pcVar2 == (char *)0x0))
  {
    *(undefined4 *)((int)data_ + 8) = 0;
    if (**(char **)((int)data_ + 4) == '\0') goto LAB_080689fe;
    convert_table = get_translation_table(*(int *)((int)data_ + 0x10),*(int *)((int)data_ + 0x14));
    if (convert_table != (conv_table *)0x0) {
      chars = *(uchar **)((int)pvVar1 + 0x14);
      charslen = strlen((char *)chars);
      chars = convert_string_elinks
                        (convert_table,chars,charslen,*(int *)((int)data_ + 0x14),CSM_NONE,
                         (int *)0x0,(anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
      if (chars != (uchar *)0x0) {
        pcVar2 = strcasestr((char *)chars,*(char **)((int)data_ + 4));
        *(uint *)((int)data_ + 8) = (uint)(pcVar2 != (char *)0x0);
        mem_free(chars);
      }
    }
    if (*(int *)((int)data_ + 8) == 0) goto LAB_080689fe;
  }
  else {
    *(undefined4 *)((int)data_ + 8) = 1;
  }
  *offset = 0;
LAB_080689fe:
  *(int *)((int)data_ + 0xc) = *(int *)((int)data_ + 0xc) + 1;
  return 0;
}



move_bookmark_flags __regparm3
do_move_bookmark(bookmark *dest,int insert_as_child,list_head_elinks *src,listbox_data *box)

{
  byte bVar1;
  bookmark *pbVar2;
  int move_bookmark_event_id;
  listbox_item *plVar3;
  listbox_data *plVar4;
  int iVar5;
  move_bookmark_flags mVar6;
  bookmark *pbVar7;
  int *piVar8;
  int local_2c;
  move_bookmark_flags local_24;
  bookmark *local_20;
  
  if (move_bookmark_event_id == -1) {
    move_bookmark_event_id = get_event_id((uchar *)"bookmark-move");
  }
  pbVar7 = (bookmark *)src->next;
  local_20 = pbVar7->next;
  local_24 = MOVE_BOOKMARK_NONE;
  if (pbVar7 == (bookmark *)src) {
    return MOVE_BOOKMARK_NONE;
  }
  plVar3 = pbVar7->box_item;
  bVar1 = *(byte *)&plVar3->field_0x18;
  local_2c = insert_as_child;
  if ((bVar1 & 4) == 0) goto LAB_08068c8e;
LAB_08068b68:
  if ((pbVar7 == dest) || (pbVar7 == move_cache_root_avoid)) {
    local_24 = local_24 | MOVE_BOOKMARK_CYCLE;
    if (plVar3->type == BI_FOLDER) goto LAB_08068c94;
  }
  else {
    local_24 = local_24 | MOVE_BOOKMARK_MOVED;
    *(byte *)&plVar3->field_0x18 = bVar1 & 0xfb;
    trigger_event(move_bookmark_event_id,pbVar7,dest);
    piVar8 = (int *)bookmark_browser.dialogs.next;
    if ((list_head_elinks *)bookmark_browser.dialogs.next != &bookmark_browser.dialogs) {
      do {
        iVar5 = piVar8[2];
        plVar4 = get_listbox_widget_data((widget_data *)(iVar5 + 0x28));
        if (plVar4->top == pbVar7->box_item) {
          listbox_sel_move((widget_data *)(iVar5 + 0x28),1);
        }
        piVar8 = (int *)*piVar8;
      } while (piVar8 != (int *)0x81377d8);
    }
    pbVar7->box_item->next->prev = pbVar7->box_item->prev;
    pbVar7->box_item->prev->next = pbVar7->box_item->next;
    pbVar7->next->prev = pbVar7->prev;
    pbVar7->prev->next = pbVar7->next;
    if (local_2c == 0) {
      pbVar2 = dest->next;
      pbVar7->prev = dest;
      pbVar7->next = pbVar2;
      dest->next = pbVar7;
      pbVar7->next->prev = pbVar7;
      pbVar7->box_item->next = dest->box_item->next;
      pbVar7->box_item->prev = dest->box_item;
      dest->box_item->next = pbVar7->box_item;
      pbVar7->box_item->next->prev = pbVar7->box_item;
      dest = dest->root;
      pbVar7->root = dest;
    }
    else {
      pbVar2 = (bookmark *)(dest->child).next;
      pbVar7->prev = (bookmark *)&dest->child;
      pbVar7->next = pbVar2;
      *(bookmark **)&(dest->child).next = pbVar7;
      pbVar7->next->prev = pbVar7;
      pbVar7->box_item->next = (listbox_item *)(dest->box_item->child).next;
      pbVar7->box_item->prev = (listbox_item *)&dest->box_item->child;
      *(listbox_item **)&(dest->box_item->child).next = pbVar7->box_item;
      pbVar7->box_item->next->prev = pbVar7->box_item;
      pbVar7->root = dest;
    }
    iVar5 = 0;
    if (dest != (bookmark *)0x0) {
      iVar5 = dest->box_item->depth + 1;
    }
    pbVar7->box_item->depth = iVar5;
    local_2c = 0;
    dest = pbVar7;
    if (pbVar7->box_item->type == BI_FOLDER) {
      update_depths(pbVar7->box_item);
      local_2c = 0;
    }
  }
  do {
    pbVar2 = local_20->next;
    pbVar7 = local_20;
    while( true ) {
      local_20 = pbVar2;
      if ((bookmark *)src == pbVar7) {
        return local_24;
      }
      plVar3 = pbVar7->box_item;
      bVar1 = *(byte *)&plVar3->field_0x18;
      if ((bVar1 & 4) != 0) goto LAB_08068b68;
LAB_08068c8e:
      if (plVar3->type != BI_FOLDER) break;
LAB_08068c94:
      mVar6 = do_move_bookmark(dest,local_2c,&pbVar7->child,box);
      local_24 = local_24 | mVar6;
      pbVar2 = local_20->next;
      pbVar7 = local_20;
    }
  } while( true );
}



widget_handler_status_T push_move_button(dialog_data *dlg_data,widget_data *blah)

{
  listbox_item *plVar1;
  listbox_data *box;
  move_bookmark_flags mVar2;
  bookmark *pbVar3;
  uint insert_as_child;
  char *local_34;
  char *local_2c;
  
  box = get_listbox_widget_data(dlg_data->widgets_data);
  plVar1 = box->sel;
  if (plVar1 != (listbox_item *)0x0) {
    insert_as_child = 0;
    if (plVar1->type == BI_FOLDER) {
      insert_as_child = (uint)*(byte *)&plVar1->field_0x18 & 1;
    }
    move_cache_root_avoid = (bookmark *)0x0;
    pbVar3 = ((bookmark *)plVar1->udata)->root;
    if (pbVar3 != (bookmark *)0x0) {
      move_cache_root_avoid = (bookmark *)0x0;
      do {
        if ((*(byte *)&pbVar3->box_item->field_0x18 & 4) != 0) {
          move_cache_root_avoid = pbVar3;
        }
        pbVar3 = pbVar3->root;
      } while (pbVar3 != (bookmark *)0x0);
    }
    mVar2 = do_move_bookmark((bookmark *)plVar1->udata,insert_as_child,&bookmarks,box);
    if ((mVar2 & MOVE_BOOKMARK_MOVED) != MOVE_BOOKMARK_NONE) {
      bookmarks_set_dirty();
      write_bookmarks();
      update_hierbox_browser(&bookmark_browser);
      return EVENT_PROCESSED;
    }
    if ((mVar2 & MOVE_BOOKMARK_CYCLE) == MOVE_BOOKMARK_NONE) {
      local_2c = 
      "To move bookmarks, first mark all the bookmarks (or folders) you want to move.  This can be done with the Insert key if you\'re using the default key-bindings.  An asterisk will appear near all marked bookmarks.  Now move to where you want to have the stuff moved to, and press the \"Move\" button."
      ;
      local_34 = "Nothing to move";
    }
    else {
      local_2c = 
      "You are trying to move the marked folder inside itself. To move the folder to a different location select the new location before pressing the Move button."
      ;
      local_34 = "Cannot move folder inside itself";
    }
    info_box(dlg_data->win->term,0,(uchar *)local_34,ALIGN_LEFT,(uchar *)local_2c);
  }
  return EVENT_PROCESSED;
}



widget_handler_status_T push_add_folder_button(dialog_data *dlg_data,widget_data *widget_data)

{
  input_dialog(dlg_data->win->term,(memory_list *)0x0,(uchar *)"Add folder",(uchar *)"Folder name",
               dlg_data,(input_history *)0x0,0x400,(uchar *)0x0,0,0,(widget_handler_T *)0x0,
               do_add_folder,(done_handler_T *)0x0);
  return EVENT_PROCESSED;
}



void __regparm3 do_add_bookmark(terminal *term,dialog_data *dlg_data,uchar *title,uchar *url)

{
  listbox_item *plVar1;
  bookmark *pbVar2;
  int codepage;
  listbox_data *plVar3;
  bookmark *root;
  bookmark *pbVar4;
  
  codepage = get_terminal_codepage(term);
  if (dlg_data != (dialog_data *)0x0) {
    plVar3 = get_listbox_widget_data(dlg_data->widgets_data);
    plVar1 = plVar3->sel;
    if (plVar1 != (listbox_item *)0x0) {
      pbVar4 = (bookmark *)plVar1->udata;
      if ((plVar1->type != BI_FOLDER) || (root = pbVar4, (*(byte *)&plVar1->field_0x18 & 1) == 0)) {
        root = pbVar4->root;
      }
      goto LAB_08068f2b;
    }
  }
  pbVar4 = (bookmark *)0x0;
  root = (bookmark *)0x0;
LAB_08068f2b:
  root = add_bookmark_cp(root,1,codepage,title,url);
  if (root != (bookmark *)0x0) {
    if ((((pbVar4 != (bookmark *)0x0) && (pbVar4 != root->root)) &&
        (pbVar4->box_item != (listbox_item *)0x0)) &&
       (plVar1 = root->box_item, plVar1 != (listbox_item *)0x0)) {
      plVar1->next->prev = plVar1->prev;
      root->box_item->prev->next = root->box_item->next;
      root->next->prev = root->prev;
      root->prev->next = root->next;
      pbVar2 = pbVar4->next;
      root->prev = pbVar4;
      root->next = pbVar2;
      pbVar4->next = root;
      root->next->prev = root;
      root->box_item->next = pbVar4->box_item->next;
      root->box_item->prev = pbVar4->box_item;
      pbVar4->box_item->next = root->box_item;
      root->box_item->next->prev = root->box_item;
    }
    write_bookmarks();
    if (dlg_data != (dialog_data *)0x0) {
      listbox_sel(dlg_data->widgets_data,root->box_item);
    }
  }
  return;
}



void do_add_folder(dialog_data *dlg_data,uchar *foldername)

{
  do_add_bookmark(dlg_data->win->term,dlg_data,foldername,(uchar *)0x0);
  return;
}



void bookmark_add_add(void *data)

{
  do_add_bookmark(*(terminal **)((int)data + 8),*(dialog_data **)((int)data + 4),
                  *(uchar **)((int)data + 0x30),*(uchar **)((int)data + 0x60));
  return;
}



widget_handler_status_T push_add_separator_button(dialog_data *dlg_data,widget_data *widget_data)

{
  do_add_bookmark(dlg_data->win->term,dlg_data,"-","");
  redraw_dialog(dlg_data,1);
  return EVENT_PROCESSED;
}



void bookmark_edit_done(void *data)

{
  object *poVar1;
  bookmark *bm;
  int codepage;
  
  bm = *(bookmark **)((int)data + 8);
  codepage = get_terminal_codepage(*(terminal **)(**(int **)((int)data + 4) + 0x14));
  update_bookmark(bm,codepage,*(uchar **)((int)data + 0x30),*(uchar **)((int)data + 0x60));
  poVar1 = &bm->object;
  poVar1->refcount = poVar1->refcount + -1;
  write_bookmarks();
  return;
}



void bookmark_terminal_tabs_ok(void *term_void,uchar *foldername)

{
  int from;
  int to;
  conv_table *convert_table;
  size_t charslen;
  uchar *foldername_00;
  
  from = get_terminal_codepage((terminal *)term_void);
  to = get_cp_index("UTF-8");
  convert_table = get_translation_table(from,to);
  if (convert_table != (conv_table *)0x0) {
    charslen = strlen((char *)foldername);
    foldername_00 =
         convert_string_elinks
                   (convert_table,foldername,charslen,to,CSM_NONE,(int *)0x0,
                    (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
    if (foldername_00 != (uchar *)0x0) {
      bookmark_terminal_tabs((terminal *)term_void,foldername_00);
      mem_free(foldername_00);
      return;
    }
  }
  return;
}



void launch_bm_add_link_dialog(terminal *term,dialog_data *parent,session *ses)

{
  int iVar1;
  uchar *url_00;
  uchar *title_00;
  int in_GS_OFFSET;
  uchar url [1024];
  uchar title [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  url_00 = get_current_link_url(ses,url,0x400);
  title_00 = get_current_link_name(ses,title,0x400);
  launch_bm_add_dialog(term,parent,ses,title_00,url_00);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void bookmark_manager(session *ses)

{
  free_last_searched_bookmark();
  bookmark_browser.expansion_callback = bookmarks_set_dirty;
  hierbox_browser(&bookmark_browser,ses);
  return;
}



void bookmark_terminal_tabs_dialog(terminal *term)

{
  string *psVar1;
  int cp_index;
  uchar *codeset;
  uchar **ppuVar2;
  uchar *name;
  string string;
  
  psVar1 = init_string(&string);
  if (psVar1 != (string *)0x0) {
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Saved session");
    add_to_string(&string,codeset);
    add_to_string(&string," - ");
    ppuVar2 = (uchar **)get_opt_(config_options,name);
    add_date_to_string(&string,*ppuVar2,(time_t *)0x0);
    input_dialog(term,(memory_list *)0x0,(uchar *)"Bookmark tabs",(uchar *)"Enter folder name",term,
                 (input_history *)0x0,0x400,string.source,0,0,(widget_handler_T *)0x0,
                 bookmark_terminal_tabs_ok,(done_handler_T *)0x0);
    done_string(&string);
  }
  return;
}



void bookmarks_write(list_head_elinks *bookmarks_list)

{
  bookmarks_backend *pbVar1;
  int *piVar2;
  int iVar3;
  uchar *file_name;
  FILE *ssi;
  int iVar4;
  uchar *in_EDX;
  
  piVar2 = get_opt_(config_options,in_EDX);
  iVar4 = *piVar2;
  pbVar1 = bookmarks_backends[iVar4];
  iVar3 = bookmarks_are_dirty();
  if (((((iVar3 != 0) || (iVar4 != loaded_backend_num)) && (pbVar1 != (bookmarks_backend *)0x0)) &&
      ((pbVar1->write != (anon_subr_void_secure_save_info_ptr_list_head_elinks_ptr_for_write *)0x0
       && (elinks_home != (uchar *)0x0)))) &&
     ((pbVar1->filename != (anon_subr_uchar_ptr_int_for_filename *)0x0 &&
      ((file_name = (*pbVar1->filename)(1), file_name != (uchar *)0x0 &&
       (file_name = straconcat(elinks_home,file_name,0), file_name != (uchar *)0x0)))))) {
    ssi = (FILE *)secure_open(file_name);
    mem_free(file_name);
    if (ssi != (FILE *)0x0) {
      (*pbVar1->write)(ssi);
      iVar4 = secure_close((secure_save_info *)ssi);
      if (iVar4 == 0) {
        bookmarks_unset_dirty();
        return;
      }
    }
  }
  return;
}



void bookmarks_read(void)

{
  int iVar1;
  bookmarks_backend *pbVar2;
  int *piVar3;
  uchar *p;
  FILE *__stream;
  uchar *in_EDX;
  
  piVar3 = get_opt_(config_options,in_EDX);
  iVar1 = *piVar3;
  pbVar2 = bookmarks_backends[iVar1];
  if ((((pbVar2 != (bookmarks_backend *)0x0) &&
       (pbVar2->read != (anon_subr_void_FILE_ptr_for_read *)0x0)) &&
      (pbVar2->filename != (anon_subr_uchar_ptr_int_for_filename *)0x0)) &&
     (p = (*pbVar2->filename)(0), p != (uchar *)0x0)) {
    if ((elinks_home != (uchar *)0x0) && (p = straconcat(elinks_home,p,0), p == (uchar *)0x0)) {
      return;
    }
    __stream = (FILE *)fopen64((char *)p,"rb");
    if (elinks_home != (uchar *)0x0) {
      mem_free(p);
    }
    if (__stream != (FILE *)0x0) {
      (*pbVar2->read)(__stream);
      fclose((FILE *)__stream);
      bookmarks_unset_dirty();
      loaded_backend_num = iVar1;
    }
  }
  return;
}



uchar * filename_bookmarks_default(int writing)

{
  return "bookmarks";
}



void __regparm3
write_bookmarks_default_inner(write_bookmarks_default *out,list_head_elinks *bookmarks_list)

{
  list_head_elinks *plVar1;
  size_t charslen;
  uchar *p;
  uchar *p_00;
  uchar *puVar2;
  uchar *chars;
  
  plVar1 = (list_head_elinks *)bookmarks_list->next;
  do {
    if (plVar1 == bookmarks_list) {
      return;
    }
    chars = (uchar *)plVar1[2].prev;
    charslen = strlen((char *)chars);
    p = convert_string_elinks
                  (out->conv_table,chars,charslen,out->codepage,CSM_NONE,(int *)0x0,
                   (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
    chars = (uchar *)plVar1[3].next;
    charslen = strlen((char *)chars);
    p_00 = convert_string_elinks
                     (out->conv_table,chars,charslen,out->codepage,CSM_NONE,(int *)0x0,
                      (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
    chars = "";
    if (p_00 != (uchar *)0x0) {
      chars = p_00;
    }
    puVar2 = "";
    if (p != (uchar *)0x0) {
      puVar2 = p;
    }
    secure_fprintf(out->ssi,"%s\t%s\t%d\t",puVar2,chars,*(undefined4 *)((int)plVar1[2].next + 0x14))
    ;
    if (((*(int *)((int)plVar1[2].next + 0x10) == 1) &&
        (secure_fputc(out->ssi,0x46), out->save_folder_state != 0)) &&
       ((*(byte *)((int)plVar1[2].next + 0x18) & 1) != 0)) {
      secure_fputc(out->ssi,0x45);
    }
    secure_fputc(out->ssi,10);
    if ((p_00 == (uchar *)0x0) || (p == (uchar *)0x0)) {
      secsave_errno = SS_ERR_OTHER;
      out->ssi->err = 0xc;
      if (p != (uchar *)0x0) goto LAB_080695e7;
    }
    else {
LAB_080695e7:
      mem_free(p);
    }
    if (p_00 != (uchar *)0x0) {
      mem_free(p_00);
    }
    if (out->ssi->err != 0) {
      return;
    }
    if ((list_head_elinks *)plVar1[3].prev != (list_head_elinks *)&plVar1[3].prev) {
      write_bookmarks_default_inner(out,(list_head_elinks *)&plVar1[3].prev);
    }
    plVar1 = (list_head_elinks *)plVar1->next;
  } while( true );
}



void write_bookmarks_default(secure_save_info *ssi,list_head_elinks *bookmarks_list)

{
  int *piVar1;
  int to;
  int from;
  uchar *in_EDX;
  write_bookmarks_default out;
  
  out.ssi = ssi;
  piVar1 = get_opt_(config_options,in_EDX);
  out.save_folder_state = *piVar1;
  to = get_cp_index((uchar *)"System");
  out.codepage = to;
  from = get_cp_index("UTF-8");
  out.conv_table = get_translation_table(from,to);
  write_bookmarks_default_inner(&out,bookmarks_list);
  return;
}



void read_bookmarks_default(FILE *f)

{
  uchar *url;
  byte *pbVar1;
  uchar uVar2;
  int iVar3;
  int codepage;
  char *pcVar4;
  uchar *puVar5;
  long lVar6;
  bookmark *root;
  int iVar7;
  long lVar8;
  uchar *puVar9;
  int in_GS_OFFSET;
  int local_c40;
  bookmark *local_c3c;
  uchar *local_c34;
  uchar in_buffer [3079];
  
  iVar3 = *(int *)(in_GS_OFFSET + 0x14);
  codepage = get_cp_index((uchar *)"System");
  local_c40 = 0;
  local_c3c = (bookmark *)0x0;
LAB_08069810:
  do {
    pcVar4 = fgets((char *)in_buffer,0xc07,(FILE *)f);
    if (pcVar4 == (char *)0x0) {
      if (iVar3 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return;
    }
    puVar5 = (uchar *)strchr((char *)in_buffer,9);
  } while (((puVar5 == (uchar *)0x0) || (in_buffer == puVar5)) ||
          (0x3ff < (int)(puVar5 + -(int)in_buffer)));
  url = puVar5 + 1;
  *puVar5 = '\0';
  pcVar4 = strchr((char *)url,9);
  if (pcVar4 != (char *)0x0) goto code_r0x0806987f;
  lVar8 = 0;
  local_c34 = url;
  goto LAB_08069a32;
code_r0x0806987f:
  if ((int)(pcVar4 + -(int)url) < 0x400) {
    *pcVar4 = '\0';
    local_c34 = (uchar *)(pcVar4 + 1);
    lVar6 = strtol((char *)local_c34,(char **)0x0,10);
    iVar7 = 0;
    if (local_c3c != (bookmark *)0x0) {
      iVar7 = local_c40 + 1;
    }
    lVar8 = 0;
    if ((-1 < lVar6) && (lVar8 = lVar6, iVar7 <= lVar6)) {
      lVar8 = iVar7;
    }
    pcVar4 = strchr((char *)local_c34,9);
    if (pcVar4 == (char *)0x0) {
LAB_08069a32:
      puVar9 = (uchar *)0x0;
    }
    else {
      *pcVar4 = '\0';
      puVar9 = (uchar *)(pcVar4 + 1);
      if (puVar9 != (uchar *)0x0) {
        local_c34 = puVar9;
      }
    }
    pcVar4 = strchr((char *)local_c34,10);
    if (pcVar4 != (char *)0x0) {
      *pcVar4 = '\0';
      root = (bookmark *)0x0;
      if (lVar8 != 0) {
        if (local_c40 == lVar8) {
          root = local_c3c->root;
        }
        else {
          root = local_c3c;
          if (lVar8 <= local_c40) {
            do {
              local_c40 = local_c40 + -1;
              local_c3c = local_c3c->root;
            } while (local_c40 != lVar8);
            root = local_c3c->root;
          }
        }
      }
      local_c3c = add_bookmark_cp(root,1,codepage,in_buffer,url);
      local_c40 = lVar8;
      if (((puVar5[1] == '\0') && (in_buffer[0] == '-')) && (in_buffer[1] == '\0')) {
        local_c3c->box_item->type = BI_SEPARATOR;
      }
      else {
        if ((puVar9 != (uchar *)0x0) && (uVar2 = *puVar9, local_c3c != (bookmark *)0x0)) {
          while (uVar2 != '\0') {
            if (uVar2 == 'E') {
              pbVar1 = (byte *)&local_c3c->box_item->field_0x18;
              *pbVar1 = *pbVar1 | 1;
            }
            else {
              if (uVar2 == 'F') {
                local_c3c->box_item->type = BI_FOLDER;
              }
            }
            if (puVar9 == (uchar *)0xffffffff) break;
            puVar9 = puVar9 + 1;
            uVar2 = *puVar9;
          }
        }
      }
    }
  }
  goto LAB_08069810;
}



uchar * filename_bookmarks_xbel(int writing)

{
  if ((writing != 0) && (readok == 0)) {
    return (uchar *)0x0;
  }
  return (uchar *)"bookmarks.xbel";
}



void on_element_close(void *data,char *name)

{
  current_node = current_node->parent;
  return;
}



void __regparm3 print_xml_entities(secure_save_info *ssi,uchar *str)

{
  string *psVar1;
  size_t len;
  string entitized;
  
  entitized.source = (uchar *)0x0;
  entitized.length = 0;
  psVar1 = init_string(&entitized);
  if (psVar1 != (string *)0x0) {
    len = strlen((char *)str);
    psVar1 = add_html_to_string(&entitized,str,len);
    if (psVar1 != (string *)0x0) {
      secure_fputs(ssi,(char *)entitized.source);
      goto LAB_08069b71;
    }
  }
  secsave_errno = SS_ERR_OUT_OF_MEM;
  ssi->err = 0xc;
LAB_08069b71:
  done_string(&entitized);
  return;
}



void __regparm3
write_bookmarks_list(secure_save_info *ssi,list_head_elinks *bookmarks_list,int n,int folder_state)

{
  int iVar1;
  char *s;
  int iVar2;
  list_head_elinks *plVar3;
  
  plVar3 = (list_head_elinks *)bookmarks_list->next;
  if (plVar3 != bookmarks_list) {
    iVar1 = n + 1;
    n = n + 2;
    do {
      if (0 < iVar1) {
        iVar2 = 0;
        do {
          iVar2 = iVar2 + 1;
          secure_fputs(ssi,"    ");
        } while (iVar2 < iVar1);
      }
      iVar2 = *(int *)((int)plVar3[2].next + 0x10);
      if (iVar2 == 1) {
        if ((folder_state == 0) || ((*(byte *)((int)plVar3[2].next + 0x18) & 1) == 0)) {
          secure_fputs(ssi,"<folder folded=\"");
          s = "yes";
        }
        else {
          secure_fputs(ssi,"<folder folded=\"");
          s = "no";
        }
        secure_fputs(ssi,s);
        secure_fputs(ssi,"\">\n");
        if (0 < n) {
          iVar2 = 0;
          do {
            iVar2 = iVar2 + 1;
            secure_fputs(ssi,"    ");
          } while (iVar2 < n);
        }
        secure_fputs(ssi,"<title>");
        print_xml_entities(ssi,(uchar *)plVar3[2].prev);
        secure_fputs(ssi,"</title>\n");
        if ((list_head_elinks *)plVar3[3].prev != (list_head_elinks *)&plVar3[3].prev) {
          write_bookmarks_list(ssi,(list_head_elinks *)&plVar3[3].prev,n,folder_state);
        }
        if (0 < iVar1) {
          iVar2 = 0;
          do {
            iVar2 = iVar2 + 1;
            secure_fputs(ssi,"    ");
          } while (iVar2 < iVar1);
        }
        secure_fputs(ssi,"</folder>\n\n");
      }
      else {
        if (iVar2 == 0) {
          secure_fputs(ssi,"<bookmark href=\"");
          print_xml_entities(ssi,(uchar *)plVar3[3].next);
          secure_fputs(ssi,"\">\n");
          if (0 < n) {
            iVar2 = 0;
            do {
              iVar2 = iVar2 + 1;
              secure_fputs(ssi,"    ");
            } while (iVar2 < n);
          }
          secure_fputs(ssi,"<title>");
          print_xml_entities(ssi,(uchar *)plVar3[2].prev);
          secure_fputs(ssi,"</title>\n");
          if (0 < iVar1) {
            iVar2 = 0;
            do {
              iVar2 = iVar2 + 1;
              secure_fputs(ssi,"    ");
            } while (iVar2 < iVar1);
          }
          secure_fputs(ssi,"</bookmark>\n\n");
        }
        else {
          if (iVar2 == 2) {
            secure_fputs(ssi,"<separator/>\n\n");
          }
        }
      }
      plVar3 = (list_head_elinks *)plVar3->next;
    } while (plVar3 != bookmarks_list);
  }
  return;
}



void write_bookmarks_xbel(secure_save_info *ssi,list_head_elinks *bookmarks_list)

{
  int folder_state;
  int *piVar1;
  uchar *in_EDX;
  
  piVar1 = get_opt_(config_options,in_EDX);
  folder_state = *piVar1;
  secure_fputs(ssi,
               "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE xbel PUBLIC \"+//IDN python.org//DTD XML Bookmark Exchange Language 1.0//EN//XML\"\n\t\t       \"http://www.python.org/topics/xml/dtds/xbel-1.0.dtd\">\n\n<xbel>\n\n\n"
              );
  write_bookmarks_list(ssi,bookmarks_list,0,folder_state);
  secure_fputs(ssi,"\n</xbel>\n");
  return;
}



void __regparm3 free_node(tree_node *node)

{
  list_head_elinks *plVar1;
  list_head_elinks *plVar2;
  list_head_elinks *plVar3;
  list_head_elinks *p;
  
  plVar3 = (list_head_elinks *)(node->attrs).next;
  plVar2 = &node->attrs;
  p = plVar3;
  if (plVar3 != plVar2) {
    do {
      mem_free(plVar3[1].next);
      mem_free(plVar3[1].prev);
      plVar3 = (list_head_elinks *)plVar3->next;
    } while (plVar3 != plVar2);
    plVar3 = (list_head_elinks *)(node->attrs).next;
    p = plVar3;
  }
  while (plVar3 != plVar2) {
    plVar3 = (list_head_elinks *)plVar3->next;
  }
  plVar2 = (list_head_elinks *)(node->attrs).prev;
  while (plVar3 != plVar2) {
    plVar2 = (list_head_elinks *)plVar2->prev;
  }
  plVar2 = (list_head_elinks *)p->next;
  while (plVar1 = plVar2, p != plVar3) {
    plVar1->prev = p->prev;
    *(void **)p->prev = p->next;
    mem_free(p);
    plVar2 = (list_head_elinks *)plVar1->next;
    p = plVar1;
  }
  if (node->name != (uchar *)0x0) {
    mem_free(node->name);
  }
  if (node->text != (uchar *)0x0) {
    mem_free(node->text);
  }
  mem_free(node);
  return;
}



void __regparm3 free_xbeltree(tree_node *node)

{
  tree_node *ptVar1;
  
  if (node != (tree_node *)0x0) {
    do {
      if (node->children != (tree_node *)0x0) {
        free_xbeltree(node->children);
      }
      ptVar1 = node->next;
      free_node(node);
      node = ptVar1;
    } while (ptVar1 != (tree_node *)0x0);
  }
  return;
}



void on_text(void *data,XML_Char *text,int len)

{
  byte bVar1;
  uchar *puVar2;
  bool bVar3;
  tree_node *ptVar4;
  char *__s;
  uchar *p;
  size_t sVar5;
  int iVar6;
  size_t sVar7;
  
  if (len != 0) {
    sVar7 = 0;
    p = current_node->text;
    if (p != (uchar *)0x0) {
      sVar7 = strlen((char *)p);
    }
    __s = (char *)mem_realloc(p,sVar7 + 1 + len);
    if (__s != (char *)0x0) {
      strncpy(__s + sVar7,text,len);
      __s[sVar7 + len] = '\0';
      ptVar4 = current_node;
      sVar7 = strlen(__s);
      p = (uchar *)mem_alloc(sVar7 + 1);
      if (p != (uchar *)0x0) {
        iVar6 = 0;
        if (0 < (int)sVar7) {
          bVar3 = false;
          sVar5 = 0;
          do {
            while( true ) {
              puVar2 = (uchar *)(__s + sVar5);
              bVar1 = *puVar2 - 9;
              if ((bVar1 < 0x18) && ((1 << (bVar1 & 0x1f) & 0x800013U) != 0)) break;
              bVar3 = false;
              sVar5 = sVar5 + 1;
              p[iVar6] = *puVar2;
              iVar6 = iVar6 + 1;
              if (sVar7 == sVar5) goto LAB_0806a084;
            }
            if (!bVar3) {
              p[iVar6] = ' ';
              iVar6 = iVar6 + 1;
            }
            sVar5 = sVar5 + 1;
            bVar3 = true;
          } while (sVar7 != sVar5);
        }
LAB_0806a084:
        p[iVar6] = '\0';
      }
      ptVar4->text = p;
      mem_free(__s);
      return;
    }
  }
  return;
}



void on_element_open(void *data,char *name,char **attr)

{
  tree_node *ptVar1;
  uchar *p;
  int *p_00;
  uchar *p_01;
  tree_node *ptVar2;
  
  ptVar2 = current_node;
  ptVar1 = (tree_node *)mem_calloc(1,0x20);
  if (ptVar1 != (tree_node *)0x0) {
    if (ptVar2 == (tree_node *)0x0) {
      ptVar2 = ptVar1;
    }
    ptVar1->parent = ptVar2;
    *(list_head_elinks **)&(ptVar1->attrs).prev = &ptVar1->attrs;
    *(list_head_elinks **)&(ptVar1->attrs).next = &ptVar1->attrs;
    ptVar2 = ptVar1;
    if (root_node != (tree_node *)0x0) {
      ptVar2 = current_node->children;
      if (ptVar2 == (tree_node *)0x0) {
        current_node->children = ptVar1;
        ptVar2 = root_node;
      }
      else {
        current_node->children = ptVar1;
        ptVar1->next = ptVar2;
        current_node->children->prev = (tree_node *)0x0;
        ptVar2 = root_node;
      }
    }
    root_node = ptVar2;
    current_node = ptVar1;
    p = stracpy((uchar *)name);
    ptVar1->name = p;
    if (current_node->name == (uchar *)0x0) {
      mem_free(current_node);
      return;
    }
    while ((uchar *)*attr != (uchar *)0x0) {
      p_00 = (int *)mem_calloc(1,0x10);
      p = stracpy((uchar *)*attr);
      p_01 = stracpy(((uchar **)attr)[1]);
      if (p_00 == (int *)0x0) {
LAB_0806a1ca:
        if (p != (uchar *)0x0) {
          mem_free(p);
        }
        if (p_01 != (uchar *)0x0) {
          mem_free(p_01);
        }
        free_node(current_node);
        return;
      }
      if ((p == (uchar *)0x0) || (p_01 == (uchar *)0x0)) {
        if (p_00 != (int *)0x0) {
          mem_free(p_00);
        }
        goto LAB_0806a1ca;
      }
      *(uchar **)(p_00 + 2) = p;
      attr = (char **)((uchar **)attr + 2);
      *(uchar **)(p_00 + 3) = p_01;
      ptVar2 = current_node;
      *p_00 = *(int *)(current_node->attrs).prev;
      *(void **)(p_00 + 1) = (ptVar2->attrs).prev;
      *(int **)(ptVar2->attrs).prev = p_00;
      *(int **)(*p_00 + 4) = p_00;
    }
  }
  return;
}



int __regparm3
xbeltree_to_bookmarks_list(read_bookmarks_xbel *preload,tree_node *node,bookmark *current_parent)

{
  tree_node *ptVar1;
  list_head_elinks *plVar2;
  bookmark *lastbm;
  uchar *codeset;
  uchar *codeset_00;
  int cp_index;
  bookmark *current_parent_00;
  char *pcVar3;
  byte *pbVar4;
  char *pcVar5;
  uchar *puVar6;
  byte *pbVar7;
  bool bVar8;
  bool bVar9;
  byte bVar10;
  
  bVar10 = 0;
  bVar9 = node == (tree_node *)0x0;
  do {
    if (bVar9) {
      return 1;
    }
    cp_index = 9;
    codeset_00 = node->name;
    codeset = codeset_00;
    puVar6 = "bookmark";
    do {
      if (cp_index == 0) break;
      cp_index = cp_index + -1;
      bVar9 = *codeset == *puVar6;
      codeset = codeset + (uint)bVar10 * -2 + 1;
      puVar6 = puVar6 + (uint)bVar10 * -2 + 1;
    } while (bVar9);
    if (bVar9) {
      ptVar1 = node->children;
      while (bVar9 = ptVar1 == (tree_node *)0x0, !bVar9) {
        cp_index = 6;
        codeset_00 = "title";
        codeset = ptVar1->name;
        do {
          if (cp_index == 0) break;
          cp_index = cp_index + -1;
          bVar9 = *codeset_00 == *codeset;
          codeset_00 = codeset_00 + (uint)bVar10 * -2 + 1;
          codeset = codeset + (uint)bVar10 * -2 + 1;
        } while (bVar9);
        if (bVar9) break;
        ptVar1 = ptVar1->next;
      }
      plVar2 = (list_head_elinks *)(node->attrs).next;
      while (bVar9 = plVar2 == &node->attrs, !bVar9) {
        cp_index = 5;
        pcVar3 = (char *)plVar2[1].next;
        pcVar5 = "href";
        do {
          if (cp_index == 0) break;
          cp_index = cp_index + -1;
          bVar9 = *pcVar3 == *pcVar5;
          pcVar3 = pcVar3 + (uint)bVar10 * -2 + 1;
          pcVar5 = pcVar5 + (uint)bVar10 * -2 + 1;
        } while (bVar9);
        if (bVar9) {
          codeset_00 = (uchar *)plVar2[1].prev;
          goto LAB_0806a2d7;
        }
        plVar2 = (list_head_elinks *)plVar2->next;
      }
      codeset_00 = (uchar *)0x0;
LAB_0806a2d7:
      cp_index = preload->utf8_cp;
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      if (codeset_00 == (uchar *)0x0) {
        codeset_00 = gettext((uchar *)"No URL");
      }
      if ((ptVar1 == (tree_node *)0x0) || (codeset = ptVar1->text, codeset == (uchar *)0x0)) {
        codeset = gettext((uchar *)"No title");
      }
      lastbm = add_bookmark(current_parent,0,codeset,codeset_00);
      if (lastbm == (bookmark *)0x0) {
        return 0;
      }
      lastbm->root = current_parent;
    }
    else {
      cp_index = 7;
      codeset = codeset_00;
      puVar6 = "folder";
      do {
        if (cp_index == 0) break;
        cp_index = cp_index + -1;
        bVar9 = *codeset == *puVar6;
        codeset = codeset + (uint)bVar10 * -2 + 1;
        puVar6 = puVar6 + (uint)bVar10 * -2 + 1;
      } while (bVar9);
      if (bVar9) {
        ptVar1 = node->children;
        while (bVar9 = ptVar1 == (tree_node *)0x0, !bVar9) {
          cp_index = 6;
          codeset_00 = "title";
          codeset = ptVar1->name;
          do {
            if (cp_index == 0) break;
            cp_index = cp_index + -1;
            bVar9 = *codeset_00 == *codeset;
            codeset_00 = codeset_00 + (uint)bVar10 * -2 + 1;
            codeset = codeset + (uint)bVar10 * -2 + 1;
          } while (bVar9);
          if (bVar9) break;
          ptVar1 = ptVar1->next;
        }
        cp_index = preload->utf8_cp;
        if (cp_index != current_charset) {
          codeset_00 = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset_00);
          current_charset = cp_index;
        }
        if ((ptVar1 == (tree_node *)0x0) || (codeset_00 = ptVar1->text, codeset_00 == (uchar *)0x0))
        {
          codeset_00 = gettext((uchar *)"No title");
        }
        lastbm = add_bookmark(current_parent,0,codeset_00,(uchar *)0x0);
        if (lastbm == (bookmark *)0x0) {
          return 0;
        }
        plVar2 = (list_head_elinks *)(node->attrs).next;
        while (bVar9 = plVar2 == &node->attrs, !bVar9) {
          bVar8 = plVar2 < &node->attrs;
          cp_index = 7;
          pbVar4 = (byte *)plVar2[1].next;
          pbVar7 = (byte *)"folded";
          do {
            if (cp_index == 0) break;
            cp_index = cp_index + -1;
            bVar8 = *pbVar4 < *pbVar7;
            bVar9 = *pbVar4 == *pbVar7;
            pbVar4 = pbVar4 + (uint)bVar10 * -2 + 1;
            pbVar7 = pbVar7 + (uint)bVar10 * -2 + 1;
          } while (bVar9);
          if ((!bVar8 && !bVar9) == bVar8) {
            pcVar3 = (char *)plVar2[1].prev;
            if ((((pcVar3 != (char *)0x0) && (*pcVar3 == 'n')) && (pcVar3[1] == 'o')) &&
               (pcVar3[2] == '\0')) {
              pbVar4 = (byte *)&lastbm->box_item->field_0x18;
              *pbVar4 = *pbVar4 | 1;
            }
            break;
          }
          plVar2 = (list_head_elinks *)plVar2->next;
        }
      }
      else {
        cp_index = 10;
        codeset = "separator";
        do {
          if (cp_index == 0) break;
          cp_index = cp_index + -1;
          bVar9 = *codeset_00 == *codeset;
          codeset_00 = codeset_00 + (uint)bVar10 * -2 + 1;
          codeset = codeset + (uint)bVar10 * -2 + 1;
        } while (bVar9);
        if (bVar9) {
          lastbm = add_bookmark(current_parent,0,"-","");
          if (lastbm == (bookmark *)0x0) {
            return 0;
          }
          lastbm->root = current_parent;
        }
      }
    }
    bVar9 = node->children == (tree_node *)0x0;
    if (!bVar9) {
      cp_index = 7;
      codeset_00 = node->name;
      codeset = "folder";
      do {
        if (cp_index == 0) break;
        cp_index = cp_index + -1;
        bVar9 = *codeset_00 == *codeset;
        codeset_00 = codeset_00 + (uint)bVar10 * -2 + 1;
        codeset = codeset + (uint)bVar10 * -2 + 1;
      } while (bVar9);
      current_parent_00 = current_parent;
      if (bVar9) {
        current_parent_00 = lastbm;
      }
      cp_index = xbeltree_to_bookmarks_list(preload,node->children,current_parent_00);
      if (cp_index == 0) {
        return 0;
      }
    }
    node = node->next;
    bVar9 = node == (tree_node *)0x0;
  } while( true );
}



void read_bookmarks_xbel(FILE *f)

{
  int iVar1;
  int iVar2;
  size_t sVar3;
  int iVar4;
  uchar *fmt;
  int iVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  int in_GS_OFFSET;
  read_bookmarks_xbel preload;
  uchar in_buffer [8192];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  readok = 0;
  iVar2 = XML_ParserCreate(0);
  if (iVar2 == 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bookmarks/backend/xbel.c";
    errline = 0x69;
    fmt = gettext((uchar *)"read_bookmarks_xbel(): Error in XML_ParserCreate()");
    elinks_error(fmt);
  }
  else {
    XML_SetElementHandler(iVar2,on_element_open,on_element_close);
    XML_SetCharacterDataHandler(iVar2,on_text);
    do {
      sVar3 = fread(in_buffer,1,0x2000,(FILE *)f);
      iVar4 = ferror((FILE *)f);
      if (iVar4 != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bookmarks/backend/xbel.c";
        errline = 0x74;
        fmt = gettext((uchar *)"read_bookmarks_xbel(): Error reading %s");
        elinks_error(fmt,"bookmarks.xbel");
        goto LAB_0806a642;
      }
      iVar4 = feof((FILE *)f);
      iVar5 = XML_Parse(iVar2,in_buffer,sVar3,iVar4);
      if (iVar5 == 0) {
        uVar6 = XML_GetErrorCode(iVar2);
        uVar6 = XML_ErrorString(uVar6);
        uVar7 = XML_GetCurrentColumnNumber(iVar2);
        uVar8 = XML_GetCurrentLineNumber(iVar2);
        fmt = gettext((uchar *)
                      "Parse error while processing XBEL bookmarks in %s at line %d column %d:\n%s")
        ;
        usrerror(fmt,"bookmarks.xbel",uVar8,uVar7,uVar6);
        goto LAB_0806a642;
      }
    } while (iVar4 == 0);
    preload = get_cp_index("UTF-8");
    readok = xbeltree_to_bookmarks_list(&preload,root_node->children,(bookmark *)0x0);
LAB_0806a642:
    XML_ParserFree(iVar2);
    free_xbeltree(root_node);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ulonglong get_cache_size(void)

{
  return CONCAT44(cache_size._4_4_,(undefined4)cache_size);
}



int get_cache_entry_count(void)

{
  list_head_elinks **pplVar1;
  int iVar2;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)cache_entries.next;
  if ((list_head_elinks *)cache_entries.next != &cache_entries) {
    do {
      pplVar1 = (list_head_elinks **)&plVar3->next;
      iVar2 = iVar2 + 1;
      plVar3 = *pplVar1;
    } while (*pplVar1 != &cache_entries);
  }
  return iVar2;
}



int get_cache_entry_used_count(void)

{
  list_head_elinks **pplVar1;
  int iVar2;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)cache_entries.next;
  if ((list_head_elinks *)cache_entries.next != &cache_entries) {
    do {
      pplVar1 = (list_head_elinks **)&plVar3->next;
      iVar2 = iVar2 + (uint)(plVar3[1].next != (void *)0x0);
      plVar3 = *pplVar1;
    } while (*pplVar1 != &cache_entries);
  }
  return iVar2;
}



int cache_entry_is_valid(cache_entry *cached)

{
  cache_entry *pcVar1;
  
  if ((list_head_elinks *)cache_entries.next == &cache_entries) {
    return 0;
  }
  pcVar1 = (cache_entry *)cache_entries.next;
  if ((cache_entry *)cache_entries.next != cached) {
    do {
      pcVar1 = pcVar1->next;
      if (pcVar1 == (cache_entry *)&cache_entries) {
        return 0;
      }
    } while (cached != pcVar1);
  }
  return 1;
}



int get_cache_entry_loading_count(void)

{
  int iVar1;
  cache_entry *cached;
  int iVar2;
  
  iVar2 = 0;
  cached = (cache_entry *)cache_entries.next;
  if ((list_head_elinks *)cache_entries.next != &cache_entries) {
    do {
      iVar1 = is_entry_used(cached);
      cached = cached->next;
      iVar2 = iVar2 + iVar1;
    } while (cached != (cache_entry *)&cache_entries);
  }
  return iVar2;
}



uri * redirect_cache(cache_entry *cached,uchar *location,int get,int incomplete)

{
  byte bVar1;
  byte bVar2;
  uri *puVar3;
  char *pcVar4;
  uchar *puVar5;
  uchar *local_20 [4];
  
  if (((incomplete == 0) && (*location == '/')) && (location[1] == '\0')) {
    local_20[0] = get_uri_string(cached->uri,URI_ORIGINAL);
    if (local_20[0] == (uchar *)0x0) {
      return (uri *)0x0;
    }
    add_to_strn(local_20,location);
  }
  else {
    local_20[0] = join_urls(cached->uri,location);
  }
  if (local_20[0] == (uchar *)0x0) {
    return (uri *)0x0;
  }
  puVar5 = cached->uri->post;
  if (((puVar5 != (uchar *)0x0) && (get == 0)) && ((*(byte *)&cached->field_0x5c & 4) == 0)) {
    if (assert_failed == 0) {
      pcVar4 = strchr((char *)local_20[0],1);
      assert_failed = ZEXT14(pcVar4 != (char *)0x0);
      if (pcVar4 != (char *)0x0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
        errline = 0x2e2;
        elinks_internal((uchar *)"assertion !strchr(uristring, POST_CHAR) failed!");
      }
      puVar5 = cached->uri->post;
    }
    add_to_strn(local_20,puVar5 + -1);
  }
  if (cached->redirect != (uri *)0x0) {
    done_uri(cached->redirect);
  }
  puVar3 = get_uri(local_20[0],0);
  cached->redirect = puVar3;
  bVar1 = *(byte *)&cached->field_0x5c;
  bVar2 = (byte)((get & 1U) << 2);
  *(byte *)&cached->field_0x5c = bVar1 & 0xfb | bVar2;
  if (-1 < incomplete) {
    *(byte *)&cached->field_0x5c = bVar1 & 0xf3 | bVar2 | (byte)((incomplete & 1U) << 3);
  }
  mem_free(local_20[0]);
  return cached->redirect;
}



fragment * __regparm3 frag_alloc(size_t size)

{
  fragment *__s;
  
  __s = (fragment *)mem_mmap_alloc(size + 0x23);
  if (__s != (fragment *)0x0) {
    memset(__s,0,size + 0x23);
  }
  return __s;
}



// WARNING: Type propagation algorithm not settling

fragment * get_cache_fragment(cache_entry *cached)

{
  fragment *pfVar1;
  int iVar2;
  fragment *pfVar3;
  fragment *pfVar4;
  fragment *pfVar5;
  size_t size;
  fragment *pfVar6;
  fragment *p;
  
  p = (fragment *)(cached->frag).next;
  pfVar6 = (fragment *)&cached->frag;
  if ((p != pfVar6) && ((*(uint *)((int)&p->offset + 4) | *(uint *)&p->offset) == 0)) {
    if (p == (fragment *)(cached->frag).prev) {
      return p;
    }
    pfVar4 = p->next;
    if (pfVar6 == pfVar4) {
      return p;
    }
    iVar2 = (-*(int *)&pfVar4->prev->offset - *(int *)&pfVar4->prev->length) +
            *(int *)&pfVar4->offset;
    pfVar1 = pfVar4;
    if (0 < iVar2) {
      return p;
    }
    do {
      if (iVar2 != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
        errline = 0x1fa;
        elinks_internal((uchar *)"fragments overlap");
        return (fragment *)0x0;
      }
      pfVar1 = pfVar1->next;
      if (pfVar6 == pfVar1) goto LAB_0806aaf1;
      iVar2 = (-*(int *)&pfVar1->prev->offset - *(int *)&pfVar1->prev->length) +
              *(int *)&pfVar1->offset;
    } while (iVar2 < 1);
    if (pfVar1 == pfVar4) {
      return p;
    }
LAB_0806aaf1:
    size = 0;
    pfVar5 = p;
    if (pfVar1 != p) {
      while (pfVar3 = pfVar4, size = size + *(int *)&pfVar5->length, pfVar1 != pfVar3) {
        pfVar4 = pfVar3->next;
        pfVar5 = pfVar3;
      }
    }
    pfVar4 = frag_alloc(size);
    if (pfVar4 != (fragment *)0x0) {
      *(size_t *)&pfVar4->length = size;
      *(int *)((int)&pfVar4->length + 4) = (int)size >> 0x1f;
      *(size_t *)&pfVar4->real_length = size;
      *(int *)((int)&pfVar4->real_length + 4) = (int)size >> 0x1f;
      if (pfVar1 != p) {
        iVar2 = 0;
        do {
          memcpy(pfVar4->data + iVar2,p->data,*(size_t *)&p->length);
          pfVar5 = p->prev;
          iVar2 = iVar2 + *(int *)&p->length;
          p->next->prev = pfVar5;
          p->prev->next = p->next;
          mem_mmap_free(p,*(int *)&p->real_length + 0x23);
          p = pfVar5->next;
        } while (pfVar1 != p);
      }
      pfVar4->next = (fragment *)(cached->frag).next;
      pfVar4->prev = pfVar6;
      *(fragment **)&(cached->frag).next = pfVar4;
      pfVar4->next->prev = pfVar4;
      return pfVar4;
    }
    if ((*(uint *)((int)&p->length + 4) | *(uint *)&p->length) != 0) {
      return p;
    }
  }
  return (fragment *)0x0;
}



cache_entry * find_in_cache(uri *uri)

{
  int iVar1;
  uri *a;
  int iVar2;
  cache_entry *pcVar3;
  
  iVar1 = uri->protocol;
  pcVar3 = (cache_entry *)cache_entries.next;
  if ((list_head_elinks *)cache_entries.next != &cache_entries) {
    do {
      if ((*(byte *)&pcVar3->field_0x5c & 0x10) != 0) {
        if (iVar1 == 0xf) {
          a = pcVar3->proxy_uri;
        }
        else {
          a = pcVar3->uri;
        }
        iVar2 = compare_uri(a,uri,URI_BASE);
        if (iVar2 != 0) {
          if ((cache_entry *)cache_entries.next == pcVar3) {
            return pcVar3;
          }
          pcVar3->next->prev = pcVar3->prev;
          pcVar3->prev->next = pcVar3->next;
          *(list_head_elinks **)&pcVar3->prev = &cache_entries;
          pcVar3->next = cache_entries.next;
          cache_entries.next = pcVar3;
          pcVar3->next->prev = pcVar3;
          return pcVar3;
        }
      }
      pcVar3 = pcVar3->next;
    } while (pcVar3 != (cache_entry *)&cache_entries);
  }
  return (cache_entry *)0x0;
}



cache_entry * follow_cached_redirects(cache_entry *cached)

{
  cache_entry *pcVar1;
  uri *uri;
  int iVar2;
  
  if (cached != (cache_entry *)0x0) {
    uri = cached->redirect;
    iVar2 = 1;
    if (uri != (uri *)0x0) {
      do {
        pcVar1 = find_in_cache(uri);
        if (pcVar1 == (cache_entry *)0x0) {
          return (cache_entry *)0x0;
        }
        uri = pcVar1->redirect;
        if (uri == (uri *)0x0) {
          return pcVar1;
        }
        iVar2 = iVar2 + 1;
      } while (iVar2 != 0xb);
      cached = (cache_entry *)0x0;
    }
  }
  return cached;
}



cache_entry * get_redirected_cache_entry(uri *uri)

{
  cache_entry *cached;
  
  cached = find_in_cache(uri);
  if (cached != (cache_entry *)0x0) {
    cached = follow_cached_redirects(cached);
    return cached;
  }
  return (cache_entry *)0x0;
}



cache_entry * get_cache_entry(uri *uri)

{
  cache_entry *pcVar1;
  cache_entry *p;
  uri *puVar2;
  listbox_item *plVar3;
  bool bVar4;
  
  pcVar1 = find_in_cache(uri);
  if ((assert_failed == 0) &&
     (bVar4 = uri->fragment != (uchar *)0x0, assert_failed = ZEXT14(bVar4), bVar4)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
    errline = 0x83;
    elinks_internal((uchar *)"assertion !uri->fragment failed: Fragment in URI (%s)",uri->string);
  }
  if (pcVar1 == (cache_entry *)0x0) {
    shrink_memory(0);
    p = (cache_entry *)mem_calloc(1,100);
    if (p != (cache_entry *)0x0) {
      puVar2 = get_proxied_uri(uri);
      p->uri = puVar2;
      if (puVar2 != (uri *)0x0) {
        puVar2 = get_proxy_uri(uri,(connection_state *)0x0);
        p->proxy_uri = puVar2;
        if (puVar2 != (uri *)0x0) {
          *(byte *)&p->field_0x5c = *(byte *)&p->field_0x5c | 0x18;
          *(list_head_elinks **)&(p->frag).prev = &p->frag;
          *(list_head_elinks **)&(p->frag).next = &p->frag;
          p->cache_id = id_counter;
          id_counter = id_counter + 1;
          plVar3 = add_listbox_item(&cache_browser,(listbox_item *)0x0,BI_LEAF,p,1);
          p->box_item = plVar3;
          *(list_head_elinks **)&p->prev = &cache_entries;
          p->next = cache_entries.next;
          cache_entries.next = p;
          p->next->prev = p;
          return p;
        }
        done_uri(p->uri);
      }
      mem_free(p);
    }
  }
  return pcVar1;
}



// WARNING: Removing unreachable block (ram,0x0806ae92)
// WARNING: Removing unreachable block (ram,0x0806af5a)

void free_entry_to(cache_entry *cached,off_t offset)

{
  list_head_elinks *p;
  void *pvVar1;
  void *__n;
  int iVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  list_head_elinks *plVar6;
  void *local_2c;
  void *local_28;
  
  p = (list_head_elinks *)(cached->frag).next;
  do {
    if (p == &cached->frag) {
      return;
    }
    local_28 = (void *)((ulonglong)offset >> 0x20);
    local_2c = (void *)offset;
    plVar6 = p + 1;
    pvVar1 = p[2].next;
    if (offset < CONCAT44((int)p[2].prev + (int)p[1].prev +
                          (uint)CARRY4((uint)pvVar1,(uint)plVar6->next),
                          (int)pvVar1 + (int)plVar6->next)) {
      if (offset <= (longlong)*plVar6) {
        return;
      }
      pvVar1 = (void *)(offset - (longlong)*plVar6);
      iVar4 = (int)((ulonglong)(offset - (longlong)*plVar6) >> 0x20);
      uVar5 = -(int)pvVar1;
      iVar2 = -(iVar4 + (uint)(pvVar1 != (void *)0x0));
      iVar3 = iVar2 + *(int *)((int)&cached->data_size + 4) +
              (uint)CARRY4(uVar5,*(uint *)&cached->data_size);
      *(uint *)&cached->data_size = uVar5 + *(uint *)&cached->data_size;
      *(int *)((int)&cached->data_size + 4) = iVar3;
      if (assert_failed == 0) {
        assert_failed = -(iVar3 >> 0x1f);
        if (assert_failed != 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
          errline = 0x105;
          elinks_internal((uchar *)
                          "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld"
                          ,*(undefined4 *)&cached->data_size,
                          *(undefined4 *)((int)&cached->data_size + 4));
          if (assert_failed != 0) goto LAB_0806b050;
        }
        cache_size._4_4_ = cache_size._4_4_ + iVar2 + (uint)CARRY4((uint)cache_size,uVar5);
LAB_0806afc6:
        cache_size._0_4_ = (uint)cache_size + uVar5;
      }
      else {
LAB_0806b050:
        assert_failed = 0;
        *(undefined4 *)&cached->data_size = 0;
        *(undefined4 *)((int)&cached->data_size + 4) = 0;
        cache_size._4_4_ = cache_size._4_4_ + iVar2 + (uint)CARRY4((uint)cache_size,uVar5);
        if (assert_failed == 0) goto LAB_0806afc6;
        cache_size._0_4_ = 0;
        cache_size._4_4_ = 0;
      }
      assert_failed = 0;
      __n = (void *)((int)p[2].next - (int)pvVar1);
      p[2].prev = (void *)((int)p[2].prev + (-(uint)(p[2].next < pvVar1) - iVar4));
      p[2].next = __n;
      memmove(p + 4,(void *)((int)&p[4].next + (int)pvVar1),(size_t)__n);
      p[1].next = local_2c;
      p[1].prev = local_28;
      plVar6 = p;
    }
    else {
      uVar5 = -(int)pvVar1;
      iVar2 = -((int)p[2].prev + (uint)(pvVar1 != (void *)0x0));
      iVar3 = iVar2 + *(int *)((int)&cached->data_size + 4) +
              (uint)CARRY4(uVar5,*(uint *)&cached->data_size);
      *(uint *)&cached->data_size = uVar5 + *(uint *)&cached->data_size;
      *(int *)((int)&cached->data_size + 4) = iVar3;
      if (assert_failed == 0) {
        assert_failed = -(iVar3 >> 0x1f);
        if (assert_failed != 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
          errline = 0x105;
          elinks_internal((uchar *)
                          "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld"
                          ,*(undefined4 *)&cached->data_size,
                          *(undefined4 *)((int)&cached->data_size + 4));
          if (assert_failed != 0) goto LAB_0806b100;
        }
        cache_size._4_4_ = cache_size._4_4_ + iVar2 + (uint)CARRY4((uint)cache_size,uVar5);
LAB_0806aeeb:
        cache_size._0_4_ = (uint)cache_size + uVar5;
      }
      else {
LAB_0806b100:
        assert_failed = 0;
        *(undefined4 *)&cached->data_size = 0;
        *(undefined4 *)((int)&cached->data_size + 4) = 0;
        cache_size._4_4_ = cache_size._4_4_ + iVar2 + (uint)CARRY4((uint)cache_size,uVar5);
        if (assert_failed == 0) goto LAB_0806aeeb;
        cache_size._0_4_ = 0;
        cache_size._4_4_ = 0;
      }
      assert_failed = 0;
      plVar6 = (list_head_elinks *)p->prev;
      *(list_head_elinks **)((int)p->next + 4) = plVar6;
      *(void **)p->prev = p->next;
      mem_mmap_free(p,(int)p[3].next + 0x23);
    }
    p = (list_head_elinks *)plVar6->next;
  } while( true );
}



void __regparm3 remove_overlaps(cache_entry *cached,fragment *f,int *trunc)

{
  fragment *pfVar1;
  void *pvVar2;
  void *pvVar3;
  int iVar4;
  void *pvVar5;
  int iVar6;
  int iVar7;
  fragment *p;
  uchar *puVar8;
  uint uVar9;
  void *pvVar10;
  uchar *puVar11;
  int iVar12;
  void *pvVar13;
  void **ppvVar14;
  bool bVar15;
  byte bVar16;
  fragment *local_50;
  uchar *local_44;
  int local_2c;
  
  bVar16 = 0;
  local_44 = *(uchar **)&f->offset;
  p = f->next;
  if (p != (fragment *)&cached->frag) {
    pvVar3 = (void *)((int)local_44 + *(uint *)&f->length);
    iVar7 = *(int *)((int)&f->offset + 4) + *(int *)((int)&f->length + 4) +
            (uint)CARRY4((uint)local_44,*(uint *)&f->length);
    pvVar13 = *(void **)((int)&p->offset + 4);
    pvVar10 = *(void **)&p->offset;
    if (((int)pvVar13 <= iVar7) && ((local_50 = f, (int)pvVar13 < iVar7 || (pvVar10 < pvVar3)))) {
      do {
        pvVar5 = *(void **)&p->length;
        pvVar2 = (void *)((int)pvVar5 + (int)pvVar10);
        iVar6 = (int)*(void **)((int)&p->length + 4) + (int)pvVar13 +
                (uint)CARRY4((uint)pvVar5,(uint)pvVar10);
        if ((iVar6 < iVar7) || ((iVar6 <= iVar7 && (pvVar2 <= pvVar3)))) {
          bVar15 = true;
          puVar8 = local_50->data + (int)((int)pvVar10 - (int)local_44);
          ppvVar14 = (void **)p->data;
          do {
            if (pvVar5 == (void *)0x0) break;
            pvVar5 = (void *)((int)pvVar5 - 1);
            bVar15 = *puVar8 == *(uchar *)ppvVar14;
            puVar8 = puVar8 + (uint)bVar16 * -2 + 1;
            ppvVar14 = (void **)((int)ppvVar14 + (uint)bVar16 * -2 + 1);
          } while (bVar15);
          if (!bVar15) {
            *trunc = 1;
            goto LAB_0806b3f8;
          }
        }
        else {
          pfVar1 = (fragment *)
                   mem_mmap_realloc(local_50,*(int *)&local_50->real_length + 0x23,
                                    (int)pvVar2 + (0x23 - (int)local_44));
          if (pfVar1 == (fragment *)0x0) {
LAB_0806b3f8:
            p = local_50->next;
          }
          else {
            pfVar1->prev->next = pfVar1;
            pfVar1->next->prev = pfVar1;
            local_2c = *(int *)&pfVar1->length;
            iVar12 = *(int *)&pfVar1->next->offset;
            local_44 = pfVar1->next->data;
            iVar4 = (*(int *)&pfVar1->offset + local_2c) - iVar12;
            bVar15 = true;
            puVar8 = pfVar1->data + (iVar12 - *(int *)&pfVar1->offset);
            puVar11 = local_44;
            do {
              if (iVar4 == 0) break;
              iVar4 = iVar4 + -1;
              bVar15 = *puVar8 == *puVar11;
              puVar8 = puVar8 + (uint)bVar16 * -2 + 1;
              puVar11 = puVar11 + (uint)bVar16 * -2 + 1;
            } while (bVar15);
            if (!bVar15) {
              *trunc = 1;
              local_2c = *(int *)&pfVar1->length;
              iVar12 = *(int *)&pfVar1->next->offset;
              local_44 = pfVar1->next->data;
            }
            memcpy(pfVar1->data + local_2c,local_44 + (int)((int)pvVar3 - iVar12),
                   (size_t)((int)pvVar2 - (int)pvVar3));
            pvVar13 = (void *)((int)pvVar2 - (int)pvVar3);
            iVar4 = (iVar6 - iVar7) - (uint)(pvVar2 < pvVar3);
            iVar12 = iVar4 + *(int *)((int)&cached->data_size + 4) +
                     (uint)CARRY4((uint)pvVar13,*(uint *)&cached->data_size);
            *(uint *)&cached->data_size = (int)pvVar13 + *(uint *)&cached->data_size;
            *(int *)((int)&cached->data_size + 4) = iVar12;
            if (assert_failed == 0) {
              assert_failed = -(iVar12 >> 0x1f);
              if (assert_failed != 0) {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
                errline = 0x105;
                elinks_internal((uchar *)
                                "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld"
                                ,*(undefined4 *)&cached->data_size,
                                *(undefined4 *)((int)&cached->data_size + 4));
                if (assert_failed != 0) goto LAB_0806b4e0;
              }
              cache_size._4_4_ =
                   cache_size._4_4_ + iVar4 + (uint)CARRY4((uint)cache_size,(uint)pvVar13);
LAB_0806b2da:
              cache_size._0_4_ = (uint)cache_size + (int)pvVar13;
            }
            else {
LAB_0806b4e0:
              assert_failed = 0;
              *(undefined4 *)&cached->data_size = 0;
              *(undefined4 *)((int)&cached->data_size + 4) = 0;
              cache_size._4_4_ =
                   cache_size._4_4_ + iVar4 + (uint)CARRY4((uint)cache_size,(uint)pvVar13);
              if (assert_failed == 0) goto LAB_0806b2da;
              cache_size._0_4_ = 0;
              cache_size._4_4_ = 0;
            }
            assert_failed = 0;
            pvVar13 = (void *)((int)pvVar2 - (int)*(void **)&pfVar1->offset);
            iVar6 = (iVar6 - *(int *)((int)&pfVar1->offset + 4)) -
                    (uint)(pvVar2 < *(void **)&pfVar1->offset);
            *(void **)&pfVar1->real_length = pvVar13;
            *(int *)((int)&pfVar1->real_length + 4) = iVar6;
            *(void **)&pfVar1->length = pvVar13;
            *(int *)((int)&pfVar1->length + 4) = iVar6;
            p = pfVar1->next;
            local_50 = pfVar1;
          }
        }
        uVar9 = -(int)*(void **)&p->length;
        iVar12 = -((int)*(void **)((int)&p->length + 4) +
                  (uint)(*(void **)&p->length != (void *)0x0));
        iVar6 = iVar12 + *(int *)((int)&cached->data_size + 4) +
                (uint)CARRY4(uVar9,*(uint *)&cached->data_size);
        *(uint *)&cached->data_size = uVar9 + *(uint *)&cached->data_size;
        *(int *)((int)&cached->data_size + 4) = iVar6;
        if (assert_failed == 0) {
          assert_failed = -(iVar6 >> 0x1f);
          if (assert_failed != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
            errline = 0x105;
            elinks_internal((uchar *)
                            "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld"
                            ,*(undefined4 *)&cached->data_size,
                            *(undefined4 *)((int)&cached->data_size + 4));
            if (assert_failed != 0) goto LAB_0806b448;
          }
          cache_size._4_4_ = cache_size._4_4_ + iVar12 + (uint)CARRY4((uint)cache_size,uVar9);
LAB_0806b354:
          cache_size._0_4_ = (uint)cache_size + uVar9;
        }
        else {
LAB_0806b448:
          assert_failed = 0;
          *(undefined4 *)&cached->data_size = 0;
          *(undefined4 *)((int)&cached->data_size + 4) = 0;
          cache_size._4_4_ = cache_size._4_4_ + iVar12 + (uint)CARRY4((uint)cache_size,uVar9);
          if (assert_failed == 0) goto LAB_0806b354;
          cache_size._0_4_ = 0;
          cache_size._4_4_ = 0;
        }
        assert_failed = 0;
        p->next->prev = p->prev;
        p->prev->next = p->next;
        mem_mmap_free(p,(int)*(void **)&p->real_length + 0x23);
        p = local_50->next;
        if (p == (fragment *)&cached->frag) {
          return;
        }
        pvVar13 = *(void **)((int)&p->offset + 4);
        pvVar10 = *(void **)&p->offset;
        if (iVar7 < (int)pvVar13) {
          return;
        }
        if ((iVar7 <= (int)pvVar13) && (pvVar3 <= pvVar10)) {
          return;
        }
        local_44 = *(uchar **)&local_50->offset;
      } while( true );
    }
  }
  return;
}



void delete_entry_content(cache_entry *cached)

{
  int iVar1;
  uchar *p;
  list_head_elinks *p_00;
  uint uVar2;
  int iVar3;
  
  iVar3 = *(int *)&cached->data_size;
  iVar1 = *(int *)((int)&cached->data_size + 4);
  *(undefined4 *)&cached->data_size = 0;
  *(undefined4 *)((int)&cached->data_size + 4) = 0;
  uVar2 = -iVar3;
  iVar3 = -(iVar1 + (uint)(iVar3 != 0));
  if (assert_failed == 0) {
    cache_size._4_4_ = cache_size._4_4_ + iVar3 + (uint)CARRY4((uint)cache_size,uVar2);
  }
  else {
    assert_failed = 0;
    *(undefined4 *)&cached->data_size = 0;
    *(undefined4 *)((int)&cached->data_size + 4) = 0;
    cache_size._4_4_ = cache_size._4_4_ + iVar3 + (uint)CARRY4((uint)cache_size,uVar2);
    if (assert_failed != 0) {
      cache_size._0_4_ = 0;
      cache_size._4_4_ = 0;
      goto LAB_0806b58a;
    }
  }
  cache_size._0_4_ = (uint)cache_size + uVar2;
LAB_0806b58a:
  assert_failed = 0;
  p_00 = (list_head_elinks *)(cached->frag).next;
  while (p_00 != &cached->frag) {
    *(void **)((int)p_00->next + 4) = p_00->prev;
    *(void **)p_00->prev = p_00->next;
    mem_mmap_free(p_00,(int)p_00[3].next + 0x23);
    p_00 = (list_head_elinks *)(cached->frag).next;
  }
  cached->cache_id = id_counter;
  id_counter = id_counter + 1;
  p = cached->last_modified;
  *(byte *)&cached->field_0x5c = *(byte *)&cached->field_0x5c | 8;
  *(undefined4 *)&cached->length = 0;
  *(undefined4 *)((int)&cached->length + 4) = 0;
  if (p != (uchar *)0x0) {
    mem_free(p);
  }
  cached->last_modified = (uchar *)0x0;
  if (cached->etag != (uchar *)0x0) {
    mem_free(cached->etag);
  }
  cached->etag = (uchar *)0x0;
  return;
}



void delete_cache_entry(cache_entry *cached)

{
  int iVar1;
  bool bVar2;
  
  cached->next->prev = cached->prev;
  cached->prev->next = cached->next;
  if (assert_failed == 0) {
    bVar2 = (cached->object).refcount != 0;
    assert_failed = ZEXT14(bVar2);
    if (bVar2) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
      errline = 0x290;
      elinks_internal((uchar *)
                      "assertion !is_object_used(cached) failed: deleting locked cache entry");
      if (assert_failed != 0) goto LAB_0806b6c7;
    }
    iVar1 = is_entry_used(cached);
    assert_failed = ZEXT14(iVar1 != 0);
    if (iVar1 != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
      errline = 0x291;
      elinks_internal((uchar *)
                      "assertion !is_entry_used(cached) failed: deleting loading cache entry");
    }
  }
LAB_0806b6c7:
  delete_entry_content(cached);
  if (cached->box_item != (listbox_item *)0x0) {
    done_listbox_item(&cache_browser,cached->box_item);
  }
  if (cached->uri != (uri *)0x0) {
    done_uri(cached->uri);
  }
  if (cached->proxy_uri != (uri *)0x0) {
    done_uri(cached->proxy_uri);
  }
  if (cached->redirect != (uri *)0x0) {
    done_uri(cached->redirect);
  }
  if (cached->head != (uchar *)0x0) {
    mem_free(cached->head);
  }
  if (cached->content_type != (uchar *)0x0) {
    mem_free(cached->content_type);
  }
  if (cached->last_modified != (uchar *)0x0) {
    mem_free(cached->last_modified);
  }
  if (cached->ssl_info != (uchar *)0x0) {
    mem_free(cached->ssl_info);
  }
  if (cached->encoding_info != (uchar *)0x0) {
    mem_free(cached->encoding_info);
  }
  if (cached->etag != (uchar *)0x0) {
    mem_free(cached->etag);
  }
  mem_free(cached);
  return;
}



// WARNING: Removing unreachable block (ram,0x0806b98c)
// WARNING: Removing unreachable block (ram,0x0806b95d)
// WARNING: Removing unreachable block (ram,0x0806b9c8)

void garbage_collection(int whole)

{
  byte bVar1;
  off_t *poVar2;
  cache_entry **ppcVar3;
  uint *puVar4;
  uint uVar5;
  cache_entry *cached;
  int iVar6;
  uint uVar7;
  uint uVar8;
  uchar *in_EDX;
  uint uVar9;
  uint uVar10;
  cache_entry *cached_00;
  list_head_elinks *cached_01;
  bool bVar11;
  bool bVar12;
  ulonglong uVar13;
  uint local_54;
  uint local_50;
  
  puVar4 = get_opt_(config_options,in_EDX);
  uVar8 = *puVar4;
  uVar9 = (int)uVar8 >> 0x1f;
  if (whole == 0) {
    if (cache_size._4_4_ < uVar9) {
      return;
    }
    if ((cache_size._4_4_ <= uVar9) && ((uint)cache_size <= uVar8)) {
      return;
    }
  }
  uVar10 = 0;
  uVar7 = 0;
  local_54 = (uint)cache_size;
  local_50 = cache_size._4_4_;
  if ((list_head_elinks *)cache_entries.next != &cache_entries) {
    uVar10 = 0;
    uVar7 = 0;
    cached_00 = (cache_entry *)cache_entries.next;
    do {
      bVar11 = CARRY4(uVar10,*(uint *)&cached_00->data_size);
      uVar10 = uVar10 + *(uint *)&cached_00->data_size;
      uVar7 = uVar7 + *(int *)((int)&cached_00->data_size + 4) + (uint)bVar11;
      if (((cached_00->object).refcount != 0) || (iVar6 = is_entry_used(cached_00), iVar6 != 0)) {
        if (assert_failed == 0) {
          puVar4 = (uint *)((int)&cached_00->data_size + 4);
          bVar11 = local_50 <= *puVar4;
          if ((bVar11 && *puVar4 != local_50) ||
             ((bVar11 &&
              (local_54 <= *(uint *)&cached_00->data_size &&
               *(uint *)&cached_00->data_size != local_54)))) {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
            errline = 0x321;
            elinks_internal((uchar *)
                            "assertion new_cache_size >= cached->data_size failed: cache_size (%ld) underflow: subtracting %ld from %ld"
                            ,(uint)cache_size,cache_size._4_4_,*(undefined4 *)&cached_00->data_size,
                            *(undefined4 *)((int)&cached_00->data_size + 4),local_54,local_50);
            uVar5 = *(uint *)&cached_00->data_size;
            iVar6 = *(int *)((int)&cached_00->data_size + 4);
            if (assert_failed != 0) goto LAB_0806ba90;
          }
          else {
            assert_failed = 0;
            uVar5 = *(uint *)&cached_00->data_size;
            iVar6 = *(int *)((int)&cached_00->data_size + 4);
          }
          bVar11 = local_54 < uVar5;
          local_54 = local_54 - uVar5;
          local_50 = (local_50 - iVar6) - (uint)bVar11;
        }
        else {
LAB_0806ba90:
          assert_failed = 0;
          local_54 = 0;
          local_50 = 0;
        }
      }
      cached_00 = cached_00->next;
    } while (cached_00 != (cache_entry *)&cache_entries);
  }
  if (assert_failed == 0) {
    bVar11 = (cache_size._4_4_ ^ uVar7 | uVar10 ^ (uint)cache_size) != 0;
    assert_failed = ZEXT14(bVar11);
    if (bVar11) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
      errline = 0x32a;
      elinks_internal((uchar *)
                      "assertion old_cache_size == cache_size failed: cache_size out of sync: %ld != (actual) %ld"
                      ,(uint)cache_size,cache_size._4_4_,uVar10,uVar7);
      if (assert_failed != 0) goto LAB_0806b8de;
    }
  }
  else {
LAB_0806b8de:
    assert_failed = 0;
    cache_size._0_4_ = uVar10;
    cache_size._4_4_ = uVar7;
  }
  bVar11 = whole == 0;
  if ((local_50 <= uVar9) && (((local_50 < uVar9 || (local_54 <= uVar8)) && (bVar11)))) {
    return;
  }
  uVar13 = __udivdi3((int)((ulonglong)uVar8 * 0x5a),
                     uVar9 * 0x5a + (int)((ulonglong)uVar8 * 0x5a >> 0x20),100,0);
  if ((list_head_elinks *)cache_entries.prev != &cache_entries) {
    cached_01 = (list_head_elinks *)cache_entries.prev;
    if (CONCAT44(local_50,local_54) <= uVar13) goto LAB_0806b992;
    do {
      do {
        if (((((cache_entry *)cached_01)->object).refcount == 0) &&
           (iVar6 = is_entry_used((cache_entry *)cached_01), iVar6 == 0)) {
          if (assert_failed == 0) {
            puVar4 = (uint *)((int)&((cache_entry *)cached_01)->data_size + 4);
            bVar12 = local_50 <= *puVar4;
            if ((bVar12 && *puVar4 != local_50) ||
               ((bVar12 &&
                (local_54 <= *(uint *)&((cache_entry *)cached_01)->data_size &&
                 *(uint *)&((cache_entry *)cached_01)->data_size != local_54)))) {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
              errline = 0x348;
              elinks_internal((uchar *)
                              "assertion new_cache_size >= cached->data_size failed: cache_size (%ld) underflow: subtracting %ld from %ld"
                              ,(uint)cache_size,cache_size._4_4_,
                              *(undefined4 *)&((cache_entry *)cached_01)->data_size,
                              *(undefined4 *)((int)&((cache_entry *)cached_01)->data_size + 4),
                              local_54,local_50);
            }
            else {
              assert_failed = 0;
            }
          }
          *(byte *)&((cache_entry *)cached_01)->field_0x5c =
               *(byte *)&((cache_entry *)cached_01)->field_0x5c | 0x20;
          poVar2 = &((cache_entry *)cached_01)->data_size;
          if (assert_failed != 0) {
            assert_failed = 0;
            local_54 = 0;
            local_50 = 0;
            goto LAB_0806b97a;
          }
          bVar12 = local_54 < *(uint *)&((cache_entry *)cached_01)->data_size;
          local_54 = local_54 - *(uint *)&((cache_entry *)cached_01)->data_size;
          cached_01 = (list_head_elinks *)((cache_entry *)cached_01)->prev;
          local_50 = (local_50 - *(int *)((int)poVar2 + 4)) - (uint)bVar12;
          if (cached_01 == &cache_entries) goto LAB_0806bbc8;
        }
        else {
          *(byte *)&((cache_entry *)cached_01)->field_0x5c =
               *(byte *)&((cache_entry *)cached_01)->field_0x5c & 0xdf;
LAB_0806b97a:
          cached_01 = (list_head_elinks *)((cache_entry *)cached_01)->prev;
          if (cached_01 == &cache_entries) goto LAB_0806bbc8;
        }
      } while (uVar13 < CONCAT44(local_50,local_54));
LAB_0806b992:
    } while (!bVar11);
    goto LAB_0806b99a;
  }
LAB_0806bbc8:
  if (assert_failed == 0) {
    bVar12 = (local_54 | local_50) != 0;
    assert_failed = ZEXT14(bVar12);
    if (bVar12) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
      errline = 0x354;
      elinks_internal((uchar *)
                      "assertion new_cache_size == 0 failed: cache_size (%ld) overflow: %ld",
                      (uint)cache_size,cache_size._4_4_,local_54,local_50);
      if (assert_failed != 0) goto LAB_0806bcd0;
    }
    cached_01 = &cache_entries;
  }
  else {
LAB_0806bcd0:
    assert_failed = 0;
    cached_01 = &cache_entries;
    local_54 = 0;
    local_50 = 0;
  }
LAB_0806b99a:
  cached_00 = ((cache_entry *)cached_01)->next;
  if (cached_00 != (cache_entry *)&cache_entries) {
    cached = cached_00;
    if (!bVar11) goto LAB_0806b9fc;
    do {
      uVar9 = (int)*(void **)&cached->data_size + local_54;
      uVar8 = (int)*(void **)((int)&cached->data_size + 4) +
              CARRY4(local_54,(uint)*(void **)&cached->data_size) + local_50;
      if (CONCAT44(uVar8,uVar9) <= uVar13) {
        *(byte *)(void **)&cached->field_0x5c = *(byte *)(void **)&cached->field_0x5c & 0xdf;
        local_54 = uVar9;
        local_50 = uVar8;
      }
      ppcVar3 = &cached->next;
      cached = *ppcVar3;
    } while (*ppcVar3 != (cache_entry *)&cache_entries);
    cached_00 = cached_00->next;
    cached = cached_00->prev;
    bVar1 = *(byte *)&cached->field_0x5c;
    while( true ) {
      if ((bVar1 & 0x20) != 0) {
        delete_cache_entry(cached);
      }
      if (cached_00 == (cache_entry *)&cache_entries) break;
LAB_0806b9fc:
      cached_00 = cached_00->next;
      cached = cached_00->prev;
      bVar1 = *(byte *)&cached->field_0x5c;
    }
  }
  return;
}



cache_entry * get_validated_cache_entry(uri *uri,cache_mode cache_mode)

{
  int iVar1;
  byte bVar2;
  cache_entry *cached;
  int *piVar3;
  uchar **ppuVar4;
  time_t tVar5;
  int iVar6;
  uri *extraout_EDX;
  uri *name;
  uri *extraout_EDX_00;
  timeval_T now;
  
  if (1 < cache_mode) {
    return (cache_entry *)0x0;
  }
  cached = find_in_cache(uri);
  if (cached == (cache_entry *)0x0) {
    return (cache_entry *)0x0;
  }
  bVar2 = *(byte *)&cached->field_0x5c;
  if ((bVar2 & 8) != 0) {
    return (cache_entry *)0x0;
  }
  if ((cache_mode == CACHE_MODE_ALWAYS) || (cached->cache_mode != CACHE_MODE_NEVER)) {
    name = cached->redirect;
    if (name != (uri *)0x0) {
      piVar3 = get_opt_(config_options,(uchar *)name);
      if (*piVar3 == 0) goto LAB_0806bdec;
      bVar2 = *(byte *)&cached->field_0x5c;
      name = extraout_EDX;
    }
    if ((bVar2 & 1) != 0) {
      timeval_now(&now);
      iVar6 = timeval_cmp(&cached->max_age,&now);
      name = extraout_EDX_00;
      if (iVar6 < 1) goto LAB_0806bdec;
    }
    if (2 < cached->cache_mode) {
      return cached;
    }
    if ((cached->last_modified == (uchar *)0x0) && (cached->etag == (uchar *)0x0)) {
      return cached;
    }
    ppuVar4 = (uchar **)get_opt_(config_options,(uchar *)name);
    if ((int)*ppuVar4 < 0) {
      return cached;
    }
    iVar6 = cached->seconds;
    piVar3 = get_opt_(config_options,*ppuVar4);
    iVar1 = *piVar3;
    tVar5 = time((time_t *)0x0);
    if (tVar5 <= iVar6 + iVar1) {
      return cached;
    }
  }
  else {
LAB_0806bdec:
    if ((cached->object).refcount == 0) {
      delete_cache_entry(cached);
      return (cache_entry *)0x0;
    }
  }
  return (cache_entry *)0x0;
}



// WARNING: Type propagation algorithm not settling

void __regparm1 truncate_entry(cache_entry *cached,int final)

{
  int *piVar1;
  void *pvVar2;
  void *pvVar3;
  list_head_elinks *p;
  void *pvVar4;
  uint uVar5;
  list_head_elinks *plVar6;
  int in_ECX;
  void *pvVar7;
  void *in_EDX;
  int iVar8;
  int iVar9;
  void *pvVar10;
  
  piVar1 = (int *)((int)&cached->length + 4);
  iVar8 = *piVar1;
  if ((in_ECX <= iVar8) &&
     ((*piVar1 != in_ECX && in_ECX <= iVar8 ||
      (in_EDX <= *(void **)&cached->length && *(void **)&cached->length != in_EDX)))) {
    *(byte *)&cached->field_0x5c = *(byte *)&cached->field_0x5c | 8;
    *(void **)&cached->length = in_EDX;
    *(int *)((int)&cached->length + 4) = in_ECX;
  }
  p = (list_head_elinks *)(cached->frag).next;
  while( true ) {
    if (p == &cached->frag) {
      return;
    }
    pvVar7 = (void *)((int)in_EDX - (int)p[1].next);
    pvVar10 = (void *)((in_ECX - (int)p[1].prev) - (uint)(in_EDX < p[1].next));
    if ((assert_failed == 0) && (assert_failed = -((int)p[2].prev >> 0x1f), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
      errline = 0x244;
      elinks_internal((uchar *)"assertion f->length >= 0 failed!");
    }
    pvVar2 = p[2].prev;
    pvVar3 = p[2].next;
    if (((int)pvVar10 < (int)pvVar2) || (((int)pvVar10 <= (int)pvVar2 && (pvVar7 < pvVar3)))) break;
    p = (list_head_elinks *)p->next;
  }
  if (((int)pvVar10 < 0) || (((int)pvVar10 < 1 && (pvVar7 == (void *)0x0))))
  goto joined_r0x0806bf7e;
  pvVar4 = (void *)((int)pvVar7 - (int)pvVar3);
  iVar8 = (int)pvVar10 + (-(uint)(pvVar7 < pvVar3) - (int)pvVar2);
  iVar9 = iVar8 + (uint)CARRY4((uint)pvVar4,*(uint *)&cached->data_size) +
                  *(int *)((int)&cached->data_size + 4);
  *(uint *)&cached->data_size = (int)pvVar4 + *(uint *)&cached->data_size;
  *(int *)((int)&cached->data_size + 4) = iVar9;
  if (assert_failed == 0) {
    assert_failed = -(iVar9 >> 0x1f);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
      errline = 0x105;
      elinks_internal((uchar *)
                      "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld"
                      ,*(undefined4 *)&cached->data_size,
                      *(undefined4 *)((int)&cached->data_size + 4));
      if (assert_failed != 0) goto LAB_0806bf0c;
    }
    cache_size._4_4_ = (uint)CARRY4((uint)cache_size,(uint)pvVar4) + cache_size._4_4_;
LAB_0806c10e:
    cache_size._4_4_ = iVar8 + cache_size._4_4_;
    cache_size._0_4_ = (uint)cache_size + (int)pvVar4;
  }
  else {
LAB_0806bf0c:
    assert_failed = 0;
    *(undefined4 *)&cached->data_size = 0;
    *(undefined4 *)((int)&cached->data_size + 4) = 0;
    cache_size._4_4_ = (uint)CARRY4((uint)cache_size,(uint)pvVar4) + cache_size._4_4_;
    if (assert_failed == 0) goto LAB_0806c10e;
    cache_size._0_4_ = 0;
    cache_size._4_4_ = 0;
  }
  assert_failed = 0;
  p[2].next = pvVar7;
  p[2].prev = pvVar10;
  if ((final == 0) ||
     (plVar6 = (list_head_elinks *)mem_mmap_realloc(p,(int)p[3].next + 0x23,(int)pvVar7 + 0x23),
     plVar6 == (list_head_elinks *)0x0)) {
    p = (list_head_elinks *)p->next;
  }
  else {
    *(list_head_elinks **)((int)plVar6->next + 4) = plVar6;
    *(list_head_elinks **)&((list_head_elinks *)plVar6->prev)->next = plVar6;
    pvVar7 = *(void **)((int)(plVar6 + 2) + 4);
    plVar6[3].next = plVar6[2].next;
    *(void **)((int)(plVar6 + 3) + 4) = pvVar7;
    p = (list_head_elinks *)plVar6->next;
  }
joined_r0x0806bf7e:
  do {
    if (p == &cached->frag) {
      return;
    }
    plVar6 = (list_head_elinks *)p->next;
    uVar5 = -(int)p[2].next;
    iVar8 = -((int)p[2].prev + (uint)(p[2].next != (void *)0x0));
    iVar9 = iVar8 + *(int *)((int)&cached->data_size + 4) +
            (uint)CARRY4(uVar5,*(uint *)&cached->data_size);
    *(uint *)&cached->data_size = uVar5 + *(uint *)&cached->data_size;
    *(int *)((int)&cached->data_size + 4) = iVar9;
    if (assert_failed == 0) {
      assert_failed = -(iVar9 >> 0x1f);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
        errline = 0x105;
        elinks_internal((uchar *)
                        "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld"
                        ,*(undefined4 *)&cached->data_size,
                        *(undefined4 *)((int)&cached->data_size + 4));
        if (assert_failed != 0) goto LAB_0806c023;
      }
      cache_size._4_4_ = cache_size._4_4_ + iVar8 + (uint)CARRY4((uint)cache_size,uVar5);
LAB_0806bfb0:
      cache_size._0_4_ = (uint)cache_size + uVar5;
    }
    else {
LAB_0806c023:
      assert_failed = 0;
      *(undefined4 *)&cached->data_size = 0;
      *(undefined4 *)((int)&cached->data_size + 4) = 0;
      cache_size._4_4_ = cache_size._4_4_ + iVar8 + (uint)CARRY4((uint)cache_size,uVar5);
      if (assert_failed == 0) goto LAB_0806bfb0;
      cache_size._0_4_ = 0;
      cache_size._4_4_ = 0;
    }
    assert_failed = 0;
    *(void **)((int)p->next + 4) = p->prev;
    *(void **)p->prev = p->next;
    mem_mmap_free(p,(int)p[3].next + 0x23);
    p = plVar6;
  } while( true );
}



void normalize_cache_entry(cache_entry *cached,off_t truncate_length)

{
  time_t tVar1;
  
  if (-1 < truncate_length) {
    truncate_entry(cached,1);
    *(byte *)&cached->field_0x5c = *(byte *)&cached->field_0x5c & 0xf5;
    tVar1 = time((time_t *)0x0);
    cached->seconds = tVar1;
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x0806c360)
// WARNING: Removing unreachable block (ram,0x0806c3a5)
// WARNING: Removing unreachable block (ram,0x0806c680)
// WARNING: Removing unreachable block (ram,0x0806c3f8)

int add_fragment(cache_entry *cached,off_t offset,uchar *data,ssize_t length)

{
  int iVar1;
  longlong lVar2;
  uint uVar3;
  fragment *f;
  size_t size;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  uint uVar8;
  uint uVar9;
  int iVar10;
  fragment *f_00;
  int local_34;
  int local_20 [4];
  
  if (length == 0) {
    return 0;
  }
  local_20[0] = 0;
  iVar4 = length >> 0x1f;
  uVar9 = length + (uint)offset;
  iVar10 = iVar4 + offset._4_4_ + (uint)CARRY4(length,(uint)offset);
  iVar7 = *(int *)((int)&cached->length + 4);
  if ((iVar7 <= iVar10) &&
     ((iVar7 < iVar10 || (*(uint *)&cached->length <= uVar9 && uVar9 != *(uint *)&cached->length))))
  {
    *(uint *)&cached->length = uVar9;
    *(int *)((int)&cached->length + 4) = iVar10;
  }
  cached->cache_id = id_counter;
  id_counter = id_counter + 1;
  f_00 = (fragment *)(cached->frag).next;
  if (f_00 != (fragment *)&cached->frag) {
    uVar8 = *(uint *)&f_00->offset;
    iVar7 = *(int *)((int)&f_00->offset + 4);
    if (f_00->offset <= offset) {
      uVar3 = *(uint *)&f_00->length + uVar8;
      iVar5 = *(int *)((int)&f_00->length + 4) + iVar7 + (uint)CARRY4(*(uint *)&f_00->length,uVar8);
      lVar2 = CONCAT44(iVar5,uVar3);
      while (lVar2 < offset) {
        f_00 = f_00->next;
        if (f_00 == (fragment *)&cached->frag) goto LAB_0806c406;
        iVar7 = *(int *)((int)&f_00->offset + 4);
        uVar8 = *(uint *)&f_00->offset;
        if (offset < f_00->offset) goto LAB_0806c406;
        uVar3 = *(uint *)&f_00->length + uVar8;
        iVar5 = *(int *)((int)&f_00->length + 4) + iVar7 +
                (uint)CARRY4(*(uint *)&f_00->length,uVar8);
        lVar2 = CONCAT44(iVar5,uVar3);
      }
      if ((iVar10 < iVar5) || ((iVar10 <= iVar5 && (uVar9 <= uVar3)))) {
        local_34 = 0;
        goto LAB_0806c2f8;
      }
      iVar6 = (iVar10 - iVar7) - (uint)(uVar9 < uVar8);
      iVar1 = *(int *)((int)&f_00->real_length + 4);
      if ((iVar1 < iVar6) ||
         ((iVar1 <= iVar6 &&
          (*(uint *)&f_00->real_length <= uVar9 - uVar8 &&
           uVar9 - uVar8 != *(uint *)&f_00->real_length)))) {
        lVar2 = offset - CONCAT44(iVar7,uVar8);
        *(int *)&f_00->length = (int)lVar2;
        *(undefined4 *)((int)&f_00->length + 4) = (int)((ulonglong)lVar2 >> 0x20);
        f_00 = f_00->next;
        goto LAB_0806c406;
      }
      uVar8 = uVar9 - uVar3;
      iVar7 = (iVar10 - iVar5) - (uint)(uVar9 < uVar3);
      iVar4 = iVar7 + *(int *)((int)&cached->data_size + 4) +
              (uint)CARRY4(uVar8,*(uint *)&cached->data_size);
      *(uint *)&cached->data_size = uVar8 + *(uint *)&cached->data_size;
      *(int *)((int)&cached->data_size + 4) = iVar4;
      if (assert_failed == 0) {
        assert_failed = -(iVar4 >> 0x1f);
        if (assert_failed != 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
          errline = 0x105;
          elinks_internal((uchar *)
                          "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld"
                          ,*(undefined4 *)&cached->data_size,
                          *(undefined4 *)((int)&cached->data_size + 4));
          if (assert_failed != 0) goto LAB_0806c5f8;
        }
        cache_size._4_4_ = cache_size._4_4_ + iVar7 + (uint)CARRY4((uint)cache_size,uVar8);
LAB_0806c5a6:
        cache_size._0_4_ = (uint)cache_size + uVar8;
      }
      else {
LAB_0806c5f8:
        assert_failed = 0;
        *(undefined4 *)&cached->data_size = 0;
        *(undefined4 *)((int)&cached->data_size + 4) = 0;
        cache_size._4_4_ = cache_size._4_4_ + iVar7 + (uint)CARRY4((uint)cache_size,uVar8);
        if (assert_failed == 0) goto LAB_0806c5a6;
        cache_size._0_4_ = 0;
        cache_size._4_4_ = 0;
      }
      assert_failed = 0;
      iVar7 = *(int *)((int)&f_00->offset + 4);
      *(uint *)&f_00->length = uVar9 - *(uint *)&f_00->offset;
      *(int *)((int)&f_00->length + 4) = (iVar10 - iVar7) - (uint)(uVar9 < *(uint *)&f_00->offset);
      local_34 = 1;
LAB_0806c2f8:
      memcpy((void *)((int)f_00 + ((uint)offset - *(int *)&f_00->offset) + 0x20),data,length);
      remove_overlaps(cached,f_00,local_20);
      truncate_entry(cached,0);
      return local_34;
    }
  }
LAB_0806c406:
  size = (length | 0x3fffU) + 1;
  f = frag_alloc(size);
  if (f == (fragment *)0x0) {
    return -1;
  }
  *(uint *)&f->offset = (uint)offset;
  *(int *)((int)&f->offset + 4) = offset._4_4_;
  *(ssize_t *)&f->length = length;
  *(int *)((int)&f->length + 4) = iVar4;
  *(size_t *)&f->real_length = size;
  *(int *)((int)&f->real_length + 4) = (int)size >> 0x1f;
  memcpy(f->data,data,length);
  f->next = f_00->prev->next;
  f->prev = f_00->prev;
  f_00->prev->next = f;
  f->next->prev = f;
  iVar7 = iVar4 + *(int *)((int)&cached->data_size + 4) +
          (uint)CARRY4(length,*(uint *)&cached->data_size);
  *(uint *)&cached->data_size = length + *(uint *)&cached->data_size;
  *(int *)((int)&cached->data_size + 4) = iVar7;
  if (assert_failed == 0) {
    assert_failed = -(iVar7 >> 0x1f);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
      errline = 0x105;
      elinks_internal((uchar *)
                      "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld"
                      ,*(undefined4 *)&cached->data_size,
                      *(undefined4 *)((int)&cached->data_size + 4));
      if (assert_failed != 0) goto LAB_0806c4b7;
    }
    cache_size._4_4_ = cache_size._4_4_ + iVar4 + (uint)CARRY4((uint)cache_size,length);
  }
  else {
LAB_0806c4b7:
    assert_failed = 0;
    *(undefined4 *)&cached->data_size = 0;
    *(undefined4 *)((int)&cached->data_size + 4) = 0;
    cache_size._4_4_ = cache_size._4_4_ + iVar4 + (uint)CARRY4((uint)cache_size,length);
    if (assert_failed != 0) {
      cache_size._0_4_ = 0;
      cache_size._4_4_ = 0;
      goto LAB_0806c510;
    }
  }
  cache_size._0_4_ = (uint)cache_size + length;
LAB_0806c510:
  assert_failed = 0;
  remove_overlaps(cached,f,local_20);
  if (local_20[0] != 0) {
    truncate_entry(cached,0);
  }
  return 1;
}



void lock_cache_entry(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + 1;
  return;
}



void unlock_cache_entry(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



int is_cache_entry_used(listbox_item *item)

{
  return (uint)(*(int *)((int)item->udata + 8) != 0);
}



uri * get_cache_entry_uri(listbox_item *item)

{
  object *poVar1;
  uri *puVar2;
  
  puVar2 = *(uri **)((int)item->udata + 0x14);
  poVar1 = &puVar2->object;
  poVar1->refcount = poVar1->refcount + 1;
  return puVar2;
}



listbox_item * get_cache_entry_root(listbox_item *item)

{
  return (listbox_item *)0x0;
}



int can_delete_cache_entry(listbox_item *item)

{
  return 1;
}



void delete_cache_entry_item(listbox_item *item,int last)

{
  cache_entry *cached;
  bool bVar1;
  
  cached = (cache_entry *)item->udata;
  if ((assert_failed == 0) &&
     (bVar1 = (cached->object).refcount != 0, assert_failed = ZEXT14(bVar1), bVar1)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/dialogs.c";
    errline = 0xa7;
    elinks_internal((uchar *)"assertion !is_object_used(cached) failed!");
    delete_cache_entry(cached);
    return;
  }
  delete_cache_entry(cached);
  return;
}



listbox_match match_cache_entry(listbox_item *item,terminal *term,uchar *text)

{
  void *pvVar1;
  char *haystack;
  listbox_match lVar2;
  
  pvVar1 = item->udata;
  haystack = c_strcasestr(**(char ***)((int)pvVar1 + 0x14),(char *)text);
  lVar2 = LISTBOX_MATCH_OK;
  if (haystack == (char *)0x0) {
    haystack = *(char **)((int)pvVar1 + 0x20);
    lVar2 = LISTBOX_MATCH_NO;
    if (haystack != (char *)0x0) {
      haystack = c_strcasestr(haystack,(char *)text);
      return (uint)(haystack == (char *)0x0);
    }
  }
  return lVar2;
}



uchar * __regparm3 _(uchar *msg,terminal *term)

{
  int cp_index;
  uchar *codeset;
  
  if ((msg != (uchar *)0x0) && (*msg != '\0')) {
    if (term != (terminal *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    msg = gettext(msg);
  }
  return msg;
}



uchar * get_cache_entry_info(listbox_item *item,terminal *term)

{
  void *pvVar1;
  undefined4 uVar2;
  int iVar3;
  byte bVar4;
  string *psVar5;
  uchar *source;
  uchar **ppuVar6;
  uchar *name;
  undefined4 local_4c;
  string msg;
  time_t local_20 [4];
  
  pvVar1 = item->udata;
  if (item->type != BI_FOLDER) {
    psVar5 = init_string(&msg);
    if (psVar5 != (string *)0x0) {
      source = _("URL",term);
      add_to_string(&msg,source);
      add_to_string(&msg,": ");
      add_uri_to_string(&msg,*(uri **)((int)pvVar1 + 0x14),URI_PUBLIC);
      if (*(int *)((int)pvVar1 + 0x18) != *(int *)((int)pvVar1 + 0x14)) {
        source = _((uchar *)"Proxy URL",term);
        add_format_to_string(&msg,"\n%s: ",source);
        add_uri_to_string(&msg,*(uri **)((int)pvVar1 + 0x18),URI_PUBLIC);
      }
      if (*(int *)((int)pvVar1 + 0x1c) != 0) {
        source = _("Redirect",term);
        add_format_to_string(&msg,"\n%s: ",source);
        add_uri_to_string(&msg,*(uri **)((int)pvVar1 + 0x1c),URI_PUBLIC);
        if ((*(byte *)((int)pvVar1 + 0x5c) & 4) != 0) {
          add_to_string(&msg,(uchar *)" (GET)");
        }
      }
      uVar2 = *(undefined4 *)((int)pvVar1 + 0x40);
      local_4c = *(undefined4 *)((int)pvVar1 + 0x44);
      source = _("Size",term);
      add_format_to_string(&msg,(uchar *)"\n%s: %lld",source,uVar2,local_4c);
      uVar2 = *(undefined4 *)((int)pvVar1 + 0x48);
      local_4c = *(undefined4 *)((int)pvVar1 + 0x4c);
      source = _((uchar *)"Loaded size",term);
      add_format_to_string(&msg,(uchar *)"\n%s: %lld",source,uVar2,local_4c);
      iVar3 = *(int *)((int)pvVar1 + 0x24);
      if (iVar3 != 0) {
        source = _((uchar *)"Content type",term);
        add_format_to_string(&msg,(uchar *)"\n%s: %s",source,iVar3,local_4c);
      }
      iVar3 = *(int *)((int)pvVar1 + 0x28);
      if (iVar3 != 0) {
        source = _((uchar *)"Last modified",term);
        add_format_to_string(&msg,(uchar *)"\n%s: %s",source,iVar3,local_4c);
      }
      if (*(int *)((int)pvVar1 + 0x2c) != 0) {
        add_format_to_string
                  (&msg,(uchar *)"\n%s: %s",&DAT_08127c19,*(int *)((int)pvVar1 + 0x2c),local_4c);
      }
      iVar3 = *(int *)((int)pvVar1 + 0x30);
      if (iVar3 != 0) {
        source = _((uchar *)"SSL Cipher",term);
        add_format_to_string(&msg,(uchar *)"\n%s: %s",source,iVar3);
      }
      iVar3 = *(int *)((int)pvVar1 + 0x34);
      if (iVar3 != 0) {
        source = _("Encoding",term);
        add_format_to_string(&msg,(uchar *)"\n%s: %s",source,iVar3);
      }
      bVar4 = *(byte *)((int)pvVar1 + 0x5c);
      if ((bVar4 & 0x18) != 0x10) {
        add_char_to_string(&msg,'\n');
        source = _((uchar *)"Flags",term);
        add_to_string(&msg,source);
        add_to_string(&msg,": ");
        bVar4 = *(byte *)((int)pvVar1 + 0x5c);
        if ((bVar4 & 8) != 0) {
          source = _((uchar *)"incomplete",term);
          add_to_string(&msg,source);
          add_char_to_string(&msg,' ');
          bVar4 = *(byte *)((int)pvVar1 + 0x5c);
        }
        if ((bVar4 & 0x10) == 0) {
          source = _((uchar *)"invalid",term);
          add_to_string(&msg,source);
          bVar4 = *(byte *)((int)pvVar1 + 0x5c);
        }
      }
      if ((bVar4 & 1) == 0) {
        return msg.source;
      }
      local_20[0] = timeval_to_seconds((timeval_T *)((int)pvVar1 + 0x54));
      source = _((uchar *)"Expires",term);
      add_format_to_string(&msg,"\n%s: ",source);
      ppuVar6 = (uchar **)get_opt_(config_options,name);
      add_date_to_string(&msg,*ppuVar6,local_20);
      return msg.source;
    }
  }
  return (uchar *)0x0;
}



uchar * get_cache_entry_text(listbox_item *item,terminal *term)

{
  uchar *puVar1;
  
  puVar1 = get_uri_string(*(uri **)((int)item->udata + 0x14),URI_PUBLIC);
  return puVar1;
}



void cache_manager(session *ses)

{
  hierbox_browser(&cache_browser,ses);
  return;
}



uchar * version_cmd(option_elinks *o,uchar ***argv,int *argc)

{
  __printf_chk(1,&DAT_0813514d,full_static_version);
  fflush(stdout);
  return "";
}



uchar * remote_cmd(option_elinks *o,uchar ***argv,int *argc)

{
  byte bVar1;
  byte *s1;
  ushort *puVar2;
  ushort **ppuVar3;
  size_t sVar4;
  byte *pbVar5;
  byte *p;
  byte *pbVar6;
  char *pcVar7;
  uchar *puVar8;
  int iVar9;
  byte *pbVar10;
  byte bVar11;
  byte *__s;
  int iVar12;
  char *local_9c;
  size_t local_88;
  uint local_80;
  anon_struct_0 remote_methods [6];
  uchar *remote_argv [10];
  
  local_9c = "openURL";
  remote_methods[0].name = "openURL";
  remote_methods[0].type = REMOTE_METHOD_OPENURL;
  remote_methods[1].name = "ping";
  remote_methods[1].type = REMOTE_METHOD_PING;
  remote_methods[2].name = "addBookmark";
  remote_methods[2].type = REMOTE_METHOD_ADDBOOKMARK;
  remote_methods[3].name = "infoBox";
  remote_methods[3].type = REMOTE_METHOD_INFOBOX;
  remote_methods[4].name = "xfeDoCommand";
  remote_methods[4].type = REMOTE_METHOD_XFEDOCOMMAND;
  remote_methods[5].name = (uchar *)0x0;
  remote_methods[5].type = REMOTE_METHOD_NOT_SUPPORTED;
  if (*argc < 1) {
    o = (option_elinks *)0x8127cec;
  }
  else {
    s1 = **argv;
    bVar11 = *s1;
    if (((byte)(bVar11 + 0x9f) < 0x1a) || ((byte)(bVar11 + 0xbf) < 0x1a)) {
      local_88 = 0;
      do {
        do {
          local_88 = local_88 + 1;
          bVar11 = s1[local_88];
          p = s1 + local_88;
        } while ((byte)(bVar11 + 0x9f) < 0x1a);
      } while ((byte)(bVar11 + 0xbf) < 0x1a);
    }
    else {
      local_88 = 0;
      p = s1;
    }
    ppuVar3 = __ctype_b_loc();
    puVar2 = *ppuVar3;
    while ((*(byte *)((int)puVar2 + (uint)bVar11 * 2 + 1) & 0x20) != 0) {
      p = p + 1;
      bVar11 = *p;
    }
    sVar4 = strlen((char *)p);
    __s = p + sVar4;
    if (p < __s) {
      bVar1 = *(byte *)((int)puVar2 + (uint)__s[-1] * 2 + 1);
      while ((bVar1 & 0x20) != 0) {
        pbVar5 = __s + -1;
        if (pbVar5 <= p) goto LAB_0806ce7b;
        bVar1 = *(byte *)((int)puVar2 + (uint)__s[-2] * 2 + 1);
        __s = pbVar5;
      }
    }
    pbVar5 = __s + -(uint)(p < __s);
LAB_0806ce7b:
    if (((local_88 == 0) || (bVar11 != 0x28)) || (*pbVar5 != 0x29)) {
      remote_session_flags = remote_session_flags | SES_REMOTE_NEW_TAB;
      return (uchar *)0x0;
    }
    p = memacpy(p + 1,(int)(pbVar5 + -(int)(p + 1)));
    if (p == (byte *)0x0) {
      o = (option_elinks *)0x8127cff;
    }
    else {
      bVar11 = *p;
      local_80 = 0;
      __s = p;
      do {
        puVar2 = *ppuVar3;
        bVar1 = *(byte *)((int)puVar2 + (uint)bVar11 * 2 + 1);
        while ((bVar1 & 0x20) != 0) {
          __s = __s + 1;
          bVar11 = *__s;
          bVar1 = *(byte *)((int)puVar2 + (uint)bVar11 * 2 + 1);
        }
        if (bVar11 == 0x22) {
          pbVar5 = __s + 1;
          __s = pbVar5;
          while( true ) {
            pcVar7 = strchr((char *)__s,0x22);
            if (pcVar7 == (char *)0x0) {
              o = (option_elinks *)0x8111364;
              goto LAB_0806cf92;
            }
            bVar11 = pcVar7[1];
            __s = (byte *)(pcVar7 + 1);
            if (bVar11 != 0x22) break;
            __s = (byte *)(pcVar7 + 2);
          }
          while ((*(byte *)((int)puVar2 + (uint)bVar11 * 2 + 1) & 0x20) != 0) {
            __s = __s + 1;
            bVar11 = *__s;
          }
          if ((bVar11 != 0x2c) && (bVar11 != 0)) {
            o = (option_elinks *)0x8127d20;
            goto LAB_0806cf92;
          }
          *pcVar7 = '\0';
          bVar11 = *pbVar5;
          pbVar10 = pbVar5;
          pbVar6 = pbVar5;
          while (bVar11 != 0) {
            *pbVar10 = bVar11;
            pbVar10 = pbVar10 + 1;
            pbVar6 = pbVar6 + (uint)(*pbVar6 == 0x22) + 1;
            bVar11 = *pbVar6;
          }
          remote_argv[local_80] = pbVar5;
          local_80 = local_80 + 1;
          *pbVar10 = 0;
          bVar11 = *__s;
        }
        else {
          pbVar6 = (byte *)strchr((char *)__s,0x2c);
          pbVar5 = pbVar6 + 1;
          if (pbVar6 == (byte *)0x0) {
            sVar4 = strlen((char *)__s);
            pbVar5 = __s + sVar4;
            pbVar6 = pbVar5;
          }
          do {
            pbVar10 = pbVar6;
            if (pbVar10 <= __s) {
              if (__s == pbVar10) goto LAB_0806cf2d;
              break;
            }
            pbVar6 = pbVar10 + -1;
          } while ((*(byte *)((int)puVar2 + (uint)pbVar10[-1] * 2 + 1) & 0x20) != 0);
          remote_argv[local_80] = __s;
          local_80 = local_80 + 1;
LAB_0806cf2d:
          *pbVar10 = 0;
          bVar11 = *pbVar5;
          __s = pbVar5;
        }
        if (bVar11 == 0x2c) {
          __s = __s + 1;
          bVar11 = *__s;
        }
        if (bVar11 == 0) {
          iVar12 = 0;
          goto LAB_0806d04a;
        }
      } while (local_80 < 0xb);
      mem_free(p);
      o = (option_elinks *)0x8127d0d;
    }
  }
LAB_0806cf92:
  puVar8 = gettext((uchar *)o);
  return puVar8;
  while( true ) {
    iVar12 = iVar12 + 1;
    local_9c = (char *)remote_methods[iVar12].name;
    if ((uchar *)local_9c == (uchar *)0x0) break;
LAB_0806d04a:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/cmdline.c";
    errline = 0x142;
    iVar9 = elinks_strlcasecmp(s1,local_88,(uchar *)local_9c,0xffffffff,1);
    if (iVar9 == 0) break;
  }
  switch(remote_methods[iVar12].type) {
  case REMOTE_METHOD_OPENURL:
    if (local_80 == 0) {
      remote_session_flags = remote_session_flags | SES_REMOTE_PROMPT_URL;
    }
    else {
      if (local_80 == 2) {
        pcVar7 = strstr((char *)remote_argv[1],"new-window");
        if (pcVar7 == (char *)0x0) {
          pcVar7 = strstr((char *)remote_argv[1],"new-tab");
          if (pcVar7 == (char *)0x0) break;
          remote_session_flags = remote_session_flags | SES_REMOTE_NEW_TAB;
        }
        else {
          remote_session_flags = remote_session_flags | SES_REMOTE_NEW_WINDOW;
        }
      }
      else {
        remote_session_flags = remote_session_flags | SES_REMOTE_CURRENT_TAB;
      }
      remote_url = stracpy(remote_argv[0]);
    }
    break;
  case REMOTE_METHOD_PING:
    remote_session_flags = SES_REMOTE_PING;
    break;
  case REMOTE_METHOD_XFEDOCOMMAND:
    if ((local_80 != 0) &&
       (iVar12 = c_strcasecmp((char *)remote_argv[0],"openBrowser"), iVar12 == 0)) {
      remote_session_flags = SES_REMOTE_NEW_WINDOW;
    }
    break;
  case REMOTE_METHOD_ADDBOOKMARK:
    if (local_80 != 0) {
      remote_url = stracpy(remote_argv[0]);
      remote_session_flags = SES_REMOTE_ADD_BOOKMARK;
    }
    break;
  case REMOTE_METHOD_INFOBOX:
    if (local_80 != 0) {
      remote_url = stracpy(remote_argv[0]);
      if (remote_url != (uchar *)0x0) {
        insert_in_string(&remote_url,0,(uchar *)"about:",6);
      }
      remote_session_flags = SES_REMOTE_INFO_BOX;
    }
  }
  mem_free(p);
  if (remote_session_flags != 0) {
    *argv = *argv + 1;
    *argc = *argc + -1;
    return (uchar *)0x0;
  }
  puVar8 = gettext((uchar *)"Remote method not supported");
  return puVar8;
}



// WARNING: Could not reconcile some variable overlaps

uchar * lookup_cmd(option_elinks *o,uchar ***argv,int *argc)

{
  int iVar1;
  uchar *fmt;
  dns_result dVar2;
  char *pcVar3;
  in6_addr *__cp;
  int iVar4;
  int in_GS_OFFSET;
  int local_74;
  sockaddr_storage *local_70;
  uchar p [46];
  sockaddr_in6 addr;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  local_70 = (sockaddr_storage *)0x0;
  if (*argc == 0) {
    fmt = gettext((uchar *)"Parameter expected");
  }
  else {
    if (*argc < 2) {
      *argv = *argv + 1;
      *argc = *argc + -1;
      dVar2 = do_real_lookup((*argv)[-1],&local_70,&local_74,0);
      if (dVar2 == DNS_ERROR) {
        fmt = gettext("error");
        herror((char *)fmt);
        fmt = "";
      }
      else {
        if (0 < local_74) {
          iVar4 = 0;
          do {
            while( true ) {
              addr._0_4_ = *(uint *)(local_70 + iVar4);
              addr.sin6_flowinfo = local_70[iVar4].__ss_align;
              addr.sin6_addr.__in6_u._0_4_ = *(undefined4 *)local_70[iVar4].__ss_padding;
              addr.sin6_addr.__in6_u._4_4_ = *(undefined4 *)(local_70[iVar4].__ss_padding + 4);
              addr.sin6_addr.__in6_u._8_4_ = *(undefined4 *)(local_70[iVar4].__ss_padding + 8);
              addr.sin6_addr.__in6_u._12_4_ = *(undefined4 *)(local_70[iVar4].__ss_padding + 0xc);
              addr.sin6_scope_id = *(uint32_t *)(local_70[iVar4].__ss_padding + 0x10);
              __cp = &addr.sin6_addr;
              if (addr.sin6_family != 10) {
                __cp = (in6_addr *)&addr.sin6_flowinfo;
              }
              pcVar3 = inet_ntop(addr._0_4_ & 0xffff,__cp,(char *)p,0x2e);
              if (pcVar3 != (char *)0x0) break;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/cmdline.c";
              iVar4 = iVar4 + 1;
              errline = 0xb3;
              fmt = gettext((uchar *)"Resolver error");
              elinks_error(fmt);
              if (local_74 <= iVar4) goto LAB_0806d430;
            }
            iVar4 = iVar4 + 1;
            __printf_chk(1,&DAT_0813514d,p);
          } while (iVar4 < local_74);
        }
LAB_0806d430:
        if (local_70 != (sockaddr_storage *)0x0) {
          mem_free(local_70);
        }
        fflush(stdout);
        fmt = "";
      }
    }
    else {
      fmt = gettext((uchar *)"Too many parameters");
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return fmt;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



uchar * forcehtml_cmd(option_elinks *o,uchar ***argv,int *argc)

{
  uchar **ppuVar1;
  uchar *in_EDX;
  
  ppuVar1 = (uchar **)get_opt_(config_options,in_EDX);
  safe_strncpy(*ppuVar1,(uchar *)"text/html",0x400);
  return (uchar *)0x0;
}



uchar * eval_cmd(option_elinks *o,uchar ***argv,int *argc)

{
  uchar *puVar1;
  
  if (*argc < 1) {
    puVar1 = gettext((uchar *)"Parameter expected");
    return puVar1;
  }
  *argv = *argv + 1;
  *argc = *argc + -1;
  parse_config_file(config_options,(uchar *)"-eval",(*argv)[-1],(string *)0x0,0);
  fflush(stdout);
  return (uchar *)0x0;
}



void __regparm3 print_full_help_inner(option_elinks *tree,uchar *path,int trees)

{
  option_type oVar1;
  string *psVar2;
  uchar *local_478;
  size_t sVar3;
  size_t sVar4;
  uchar *puVar5;
  uchar *puVar6;
  int iVar7;
  uchar *msgid;
  option_elinks *tree_00;
  char *local_48c;
  int in_GS_OFFSET;
  uchar *local_480;
  uchar *local_47c;
  uchar *local_450;
  undefined2 *local_448;
  string wrapped;
  uchar saved [1024];
  uchar hexcolor [8];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  saved[0] = '\0';
  tree_00 = ((option_elinks *)tree->value)->next;
  if (tree_00 != (option_elinks *)tree->value) {
    local_448 = (undefined2 *)saved;
    do {
      while( true ) {
        msgid = tree_00->desc;
        oVar1 = tree_00->type;
        local_48c = (char *)tree_00->capt;
        if ((msgid == (uchar *)0x0) || (*msgid == '\0')) {
          msgid = "N/A";
        }
        else {
          msgid = gettext(msgid);
        }
        if (((uint)(oVar1 == OPT_TREE) != trees) ||
           (((oVar1 == OPT_ALIAS && (tree != cmdline_options)) ||
            ((*(byte *)&tree_00->flags & 1) != 0)))) break;
        if ((uchar *)local_48c == (uchar *)0x0) {
          local_48c = "Template option folder";
          iVar7 = c_strncasecmp((char *)tree_00->name,"_template_",10);
          if (iVar7 != 0) {
            msgid = tree_00->name;
            sVar3 = strlen((char *)msgid);
            safe_strncpy((uchar *)local_448,msgid,(size_t)(hexcolor + -(int)local_448));
            safe_strncpy((uchar *)((int)local_448 + sVar3),", -",
                         (size_t)(hexcolor + -(int)local_448 + -sVar3));
            local_448 = (undefined2 *)((int)local_448 + sVar3 + 3);
            break;
          }
        }
        local_478 = option_types[tree_00->type].help_str;
        if (*local_478 == '\0') {
          if (oVar1 == OPT_TREE) goto switchD_0806d7c0_caseD_9;
LAB_0806d614:
          local_47c = tree_00->name;
          local_480 = saved;
          __printf_chk(1,"    %s%s%s %s ",path,local_480,local_47c,local_478);
          switch(oVar1) {
          case OPT_BOOL:
          case OPT_INT:
          case OPT_LONG:
            puVar6 = (uchar *)tree_00->value;
            local_48c = "(default: %ld)";
            break;
          case OPT_STRING:
            puVar6 = (uchar *)tree_00->value;
            local_48c = "(default: \"%s\")";
            break;
          case OPT_CODEPAGE:
            puVar6 = get_cp_name(tree_00->value);
            local_48c = "(default: %s)";
            break;
          case OPT_LANGUAGE:
            puVar6 = language_to_name(tree_00->value);
            local_48c = "(default: \"%s\")";
            break;
          case OPT_COLOR:
            puVar6 = get_color_string(tree_00->value,hexcolor);
            local_48c = "(default: %s)";
            break;
          default:
            goto switchD_0806d7c0_caseD_7;
          case OPT_ALIAS:
            puVar6 = (uchar *)tree_00->value;
            local_48c = "(alias for %s)";
            break;
          case OPT_TREE:
            goto switchD_0806d7c0_caseD_9;
          }
          puVar5 = gettext((uchar *)local_48c);
          __printf_chk(1,puVar5,puVar6,local_480,local_47c,local_478);
        }
        else {
          local_478 = gettext(local_478);
          if (oVar1 != OPT_TREE) goto LAB_0806d614;
switchD_0806d7c0_caseD_9:
          sVar3 = strlen((char *)path);
          local_450 = tree_00->name;
          sVar4 = strlen((char *)local_450);
          if (0x400 < (int)(sVar3 + 2 + sVar4)) break;
          local_448 = (undefined2 *)saved;
          if (0 < (int)sVar3) {
            __memcpy_chk(saved,path,sVar3,0x400);
            local_448 = (undefined2 *)(saved + sVar3);
            local_450 = tree_00->name;
          }
          memcpy(local_448,local_450,sVar4 + 1);
          if (*local_48c != '\0') {
            local_48c = (char *)gettext((uchar *)local_48c);
          }
          local_448 = (undefined2 *)((uchar *)local_448 + sVar4);
          __printf_chk(1,"  %s: (%s)",local_48c,saved);
        }
switchD_0806d7c0_caseD_7:
        _IO_putc(10,stdout);
        psVar2 = init_string(&wrapped);
        if ((psVar2 == (string *)0x0) ||
           (psVar2 = wrap_option_desc(&wrapped,msgid,&indent,0x43), psVar2 == (string *)0x0)) {
          msgid = gettext((uchar *)"Out of memory formatting option documentation");
          __fprintf_chk(stderr,1,"%12s%s\n",&DAT_0812e3d8,msgid);
        }
        else {
          fwrite(wrapped.source,1,wrapped.length,(FILE *)stdout);
        }
        done_string(&wrapped);
        _IO_putc(10,stdout);
        if (tree_00->type == OPT_TREE) {
          *local_448 = 0x2e;
          print_full_help_outer(tree_00,saved);
        }
        local_448 = (undefined2 *)saved;
        saved[0] = '\0';
        tree_00 = tree_00->next;
        if ((option_elinks *)tree->value == tree_00) goto LAB_0806d738;
      }
      tree_00 = tree_00->next;
    } while ((option_elinks *)tree->value != tree_00);
  }
LAB_0806d738:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void __regparm3 print_full_help_outer(option_elinks *tree,uchar *path)

{
  print_full_help_inner(tree,path,0);
  print_full_help_inner(tree,path,1);
  return;
}



uchar * printconfigdump_cmd(option_elinks *option_elinks,uchar ***argv,int *argc)

{
  option_value *poVar1;
  uchar *p;
  uchar *in_EDX;
  
  poVar1 = get_opt_(config_options,in_EDX);
  *poVar1 = 2;
  p = create_config_string("","",config_options);
  if (p != (uchar *)0x0) {
    __printf_chk(1,0x8133695,p);
    mem_free(p);
  }
  fflush(stdout);
  return "";
}



uchar * redir_cmd(option_elinks *option_elinks,uchar ***argv,int *argc)

{
  uchar *puVar1;
  option_elinks *poVar2;
  int iVar3;
  char *name_;
  byte *pbVar4;
  byte *pbVar5;
  byte *pbVar6;
  bool bVar7;
  bool bVar8;
  bool bVar9;
  int complained;
  
  iVar3 = 8;
  bVar7 = &stack0xfffffffc < (undefined *)0x48;
  bVar9 = (undefined *)register0x00000010 == (undefined *)0x4c;
  pbVar5 = option_elinks->name;
  pbVar4 = pbVar5;
  pbVar6 = (byte *)"confdir";
  do {
    if (iVar3 == 0) break;
    iVar3 = iVar3 + -1;
    bVar7 = *pbVar4 < *pbVar6;
    bVar9 = *pbVar4 == *pbVar6;
    pbVar4 = pbVar4 + 1;
    pbVar6 = pbVar6 + 1;
  } while (bVar9);
  name_ = "config-dir";
  bVar8 = (!bVar7 && !bVar9) < bVar7;
  bVar7 = (!bVar7 && !bVar9) == bVar7;
  if (!bVar7) {
    iVar3 = 9;
    pbVar4 = pbVar5;
    pbVar6 = (byte *)"conffile";
    do {
      if (iVar3 == 0) break;
      iVar3 = iVar3 + -1;
      bVar8 = *pbVar4 < *pbVar6;
      bVar7 = *pbVar4 == *pbVar6;
      pbVar4 = pbVar4 + 1;
      pbVar6 = pbVar6 + 1;
    } while (bVar7);
    name_ = "config-file";
    bVar7 = (!bVar8 && !bVar7) == bVar8;
    if (!bVar7) {
      iVar3 = 6;
      pbVar4 = (byte *)0x813154f;
      do {
        if (iVar3 == 0) break;
        iVar3 = iVar3 + -1;
        bVar7 = *pbVar5 == *pbVar4;
        pbVar5 = pbVar5 + 1;
        pbVar4 = pbVar4 + 1;
      } while (bVar7);
      if (!bVar7) {
        puVar1 = gettext((uchar *)"Internal consistency error");
        return puVar1;
      }
      if (complained != 0) {
        return (uchar *)0x0;
      }
      complained = 1;
      puVar1 = **argv;
      if (((puVar1 != (uchar *)0x0) && ((byte)(*puVar1 - 0x30) < 2)) && (puVar1[1] == '\0')) {
        *argv = *argv + 1;
        *argc = *argc + -1;
      }
      __fprintf_chk();
      __fprintf_chk();
      __fprintf_chk();
      __fprintf_chk();
      return (uchar *)0x0;
    }
  }
  poVar2 = get_opt_rec(cmdline_options,(uchar *)name_);
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(poVar2 == (option_elinks *)0x0), poVar2 == (option_elinks *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/cmdline.c";
    errline = 0x2c1;
    elinks_internal((uchar *)"assertion option failed!");
  }
  (*option_types[poVar2->type].cmdline)(poVar2,argv,argc);
  return (uchar *)0x0;
}



retval parse_options(int argc,uchar **argv,list_head_elinks *url_list)

{
  uchar **ppuVar1;
  option_elinks *tree;
  uchar *name_;
  option_elinks *poVar2;
  uchar *source;
  char *__s;
  uchar *name__00;
  uchar **local_24;
  retval local_20 [4];
  
  tree = cmdline_options;
  local_24 = argv;
  while( true ) {
    do {
      while( true ) {
        if (argc == RET_OK) {
          return RET_OK;
        }
        argc = argc + ~RET_OK;
        ppuVar1 = local_24 + 1;
        source = *local_24;
        local_24 = ppuVar1;
        local_20[0] = argc;
        if ((*source == '-') && (source[1] != '\0')) break;
        if (url_list != (list_head_elinks *)0x0) {
          add_to_string_list(url_list,source,-1);
          argc = local_20[0];
        }
      }
      name_ = stracpy(source + 1);
      argc = local_20[0];
    } while (name_ == (uchar *)0x0);
    name__00 = source + 1;
    if (source[1] == '-') {
      name__00 = source + 2;
    }
    poVar2 = get_opt_rec(tree,name__00);
    if ((poVar2 == (option_elinks *)0x0) &&
       (poVar2 = get_opt_rec(tree,name_), poVar2 == (option_elinks *)0x0)) {
      __s = strchr((char *)(name_ + 1),0x5f);
      while (__s != (char *)0x0) {
        *__s = '-';
        __s = strchr(__s,0x5f);
      }
      poVar2 = get_opt_rec(tree,name_ + 1);
      mem_free(name_);
      if (poVar2 == (option_elinks *)0x0) break;
    }
    else {
      mem_free(name_);
    }
    if (option_types[poVar2->type].cmdline ==
        (anon_subr_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_ptr_int_ptr_for_cmdline *)0x0) break;
    source = (*option_types[poVar2->type].cmdline)(poVar2,&local_24,(int *)local_20);
    if (source != (uchar *)0x0) {
      if (*source == '\0') {
        return RET_COMMAND;
      }
      name_ = local_24[-1];
      name__00 = gettext((uchar *)"Cannot parse option %s: %s");
      usrerror(name__00,name_,source);
      return RET_SYNTAX;
    }
    argc = local_20[0];
    if (remote_url != (uchar *)0x0) {
      if (url_list != (list_head_elinks *)0x0) {
        add_to_string_list(url_list,remote_url,-1);
      }
      mem_free(remote_url);
      remote_url = (uchar *)0x0;
      argc = local_20[0];
    }
  }
  source = local_24[-1];
  name_ = gettext((uchar *)"Unknown option %s");
  usrerror(name_,source);
  return RET_SYNTAX;
}



// WARNING: Could not reconcile some variable overlaps

uchar * printhelp_cmd(option_elinks *option_elinks,uchar ***argv,int *argc)

{
  char *pcVar1;
  uchar *source;
  uchar *msgid;
  size_t sVar2;
  size_t sVar3;
  string *psVar4;
  int iVar5;
  uint uVar6;
  int *piVar7;
  string *string_00;
  option_elinks *poVar8;
  int in_GS_OFFSET;
  bool bVar9;
  byte bVar10;
  uchar *local_40;
  string string;
  uchar align [20];
  int local_20;
  
  bVar10 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  pcVar1 = strchr((char *)full_static_version,10);
  bVar9 = pcVar1 == (char *)0x0;
  if (!bVar9) {
    *pcVar1 = '\0';
  }
  __printf_chk(1,0x812e1e5,full_static_version);
  iVar5 = 0xc;
  source = option_elinks->name;
  msgid = (uchar *)"config-help";
  do {
    if (iVar5 == 0) break;
    iVar5 = iVar5 + -1;
    bVar9 = *source == *msgid;
    source = source + (uint)bVar10 * -2 + 1;
    msgid = msgid + (uint)bVar10 * -2 + 1;
  } while (bVar9);
  if (bVar9) {
    source = gettext((uchar *)"Configuration options");
    __printf_chk(1,&DAT_08127efa,source);
    print_full_help_outer(config_options,"");
  }
  else {
    source = gettext((uchar *)"Options");
    msgid = gettext((uchar *)"Usage: elinks [OPTION]... [URL]...");
    __printf_chk(1,&DAT_08127ef6,msgid,source);
    iVar5 = 10;
    source = option_elinks->name;
    msgid = (uchar *)"long-help";
    do {
      if (iVar5 == 0) break;
      iVar5 = iVar5 + -1;
      bVar9 = *source == *msgid;
      source = source + (uint)bVar10 * -2 + 1;
      msgid = msgid + (uint)bVar10 * -2 + 1;
    } while (bVar9);
    if (bVar9) {
      print_full_help_outer(cmdline_options,"-");
    }
    else {
      string_00 = (string *)0x0;
      string.source = (uchar *)0x0;
      string.length = 0;
      align._0_4_ = 0x20202020;
      align._4_4_ = 0x20202020;
      align._8_4_ = 0x20202020;
      align._12_4_ = 0x20202020;
      align._16_2_ = 0x2020;
      align[18] = ' ';
      align[19] = '\0';
      piVar7 = *(int **)(int *)cmdline_options->value;
      local_40 = "";
      poVar8 = cmdline_options;
      if (piVar7 != (int *)cmdline_options->value) {
LAB_0806e0d9:
        source = (uchar *)piVar7[3];
        sVar3 = strlen((char *)source);
        if ((*(byte *)(piVar7 + 4) & 1) == 0) {
          msgid = (uchar *)piVar7[10];
          if (msgid == (uchar *)0x0) {
            if (string_00 == (string *)0x0) {
              psVar4 = init_string(&string);
              poVar8 = cmdline_options;
              if (psVar4 == (string *)0x0) goto LAB_0806e0c2;
              source = (uchar *)piVar7[3];
              string_00 = &string;
            }
            add_to_string(string_00,source);
            add_to_string(string_00,", -");
            poVar8 = cmdline_options;
          }
          else {
            if (*msgid != '\0') {
              msgid = gettext(msgid);
            }
            source = option_types[piVar7[5]].help_str;
            if (*source != '\0') {
              source = gettext(source);
            }
            sVar2 = strlen((char *)source);
            iVar5 = 0;
            if (string_00 != (string *)0x0) {
              iVar5 = string_00->length;
            }
            uVar6 = ((0x14 - sVar3) - sVar2) - iVar5;
            if ((int)uVar6 < 0) {
              uVar6 = (uint)(*source != '\0');
            }
            align[uVar6] = '\0';
            __printf_chk(1,"  -%s%s %s%s%s\n",local_40,piVar7[3],source,align,msgid);
            align[uVar6] = ' ';
            poVar8 = cmdline_options;
            if (string_00 != (string *)0x0) {
              done_string(string_00);
              string_00 = (string *)0x0;
              poVar8 = cmdline_options;
            }
          }
        }
LAB_0806e0c2:
        piVar7 = (int *)*piVar7;
        if (piVar7 != (int *)poVar8->value) {
          local_40 = "";
          if (string_00 != (string *)0x0) {
            local_40 = string_00->source;
          }
          goto LAB_0806e0d9;
        }
      }
    }
  }
  fflush(stdout);
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return "";
}



void __regparm3 skip_quoted(conf_parsing_pos *pos)

{
  uchar *puVar1;
  uchar uVar2;
  uchar *puVar3;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  uVar2 = *pos->look;
  assert_failed = ZEXT14(uVar2 != '\'' && uVar2 != '\"');
  if (uVar2 != '\'' && uVar2 != '\"') {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/conf.c";
    errline = 0x88;
    elinks_internal((uchar *)"assertion isquote(*pos->look) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  puVar3 = pos->look;
  puVar1 = puVar3 + 1;
  pos->look = puVar1;
  uVar2 = puVar3[1];
  if (uVar2 != '\0') {
    if ((uVar2 != '\"') && (uVar2 != '\'')) {
      do {
        if ((uVar2 == '\\') && (puVar3 = puVar1 + 1, puVar1[1] != '\0')) {
          pos->look = puVar3;
          uVar2 = *puVar3;
        }
        else {
          puVar3 = pos->look;
          uVar2 = *puVar3;
        }
        if (uVar2 == '\n') {
          pos->line = pos->line + 1;
          puVar3 = pos->look;
        }
        puVar1 = puVar3 + 1;
        pos->look = puVar1;
        uVar2 = puVar3[1];
        if (uVar2 == '\0') {
          return;
        }
      } while ((uVar2 != '\'') && (uVar2 != '\"'));
    }
    pos->look = puVar1 + 1;
  }
  return;
}



void __regparm3 skip_option_value(conf_parsing_pos *pos)

{
  uchar uVar1;
  uchar *puVar2;
  
  puVar2 = pos->look;
  uVar1 = *puVar2;
  if ((uVar1 != '\'') && (uVar1 != '\"')) {
    while ((((byte)(uVar1 + 0x9f) < 0x1a ||
            ((((byte)(uVar1 + 0xbf) < 0x1a || ((byte)(uVar1 - 0x30) < 10)) || (uVar1 == '.')))) ||
           ((uVar1 == '+' || (uVar1 == '-'))))) {
      puVar2 = puVar2 + 1;
      pos->look = puVar2;
      uVar1 = *puVar2;
    }
    return;
  }
  skip_quoted(pos);
  return;
}



string * __regparm3 add_bytes_to_string__(string *string,uchar *bytes,int length)

{
  int iVar1;
  uint uVar2;
  uchar *puVar3;
  uint size;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  if (((bytes == (uchar *)0x0) || (string == (string *)0x0)) || (length < 0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 0xff;
    elinks_internal((uchar *)
                    "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  if (length == 0) {
    return string;
  }
  iVar1 = length + string->length;
  uVar2 = string->length + 0xffU & 0xffffff00;
  size = iVar1 + 0x100U & 0xffffff00;
  if (uVar2 < size) {
    puVar3 = (uchar *)mem_realloc(string->source,size);
    if (puVar3 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar3;
    memset(puVar3 + uVar2,0,size - uVar2);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  memcpy(string->source + string->length,bytes,length);
  string->source[iVar1] = '\0';
  string->length = iVar1;
  return string;
}



void __regparm3 add_cfg_header_to_string(string *string,uchar *text)

{
  size_t sVar1;
  int iVar2;
  int times;
  
  sVar1 = strlen((char *)text);
  iVar2 = sVar1 + 2;
  times = 10;
  if ((9 < iVar2) && (times = 0x50, iVar2 < 0x51)) {
    times = iVar2;
  }
  add_to_string(string,"\n\n\n");
  add_xchar_to_string(string,'#',times);
  add_to_string(string,"\n# ");
  add_to_string(string,text);
  add_to_string(string,"#\n\n");
  return;
}



void __regparm3 skip_white(conf_parsing_pos *pos)

{
  byte bVar1;
  ushort **ppuVar2;
  ushort *puVar3;
  uint uVar4;
  int iVar5;
  byte *pbVar6;
  
  pbVar6 = pos->look;
  bVar1 = *pbVar6;
  if (bVar1 != 0) {
    ppuVar2 = __ctype_b_loc();
    uVar4 = (uint)bVar1;
    puVar3 = *ppuVar2;
    do {
      while ((*(byte *)((int)puVar3 + uVar4 * 2 + 1) & 0x20) != 0) {
        if ((char)uVar4 == '\n') {
          pos->line = pos->line + 1;
          puVar3 = *ppuVar2;
        }
        pbVar6 = pbVar6 + 1;
        uVar4 = (uint)*pbVar6;
      }
      if ((char)uVar4 != '#') break;
      iVar5 = 0;
      do {
        iVar5 = iVar5 + 1;
        if (pbVar6[iVar5] == 0) break;
      } while (pbVar6[iVar5] != 10);
      pbVar6 = pbVar6 + iVar5;
      uVar4 = (uint)*pbVar6;
    } while (*pbVar6 != 0);
  }
  pos->look = pbVar6;
  return;
}



parse_error __regparm3 show_parse_error(conf_parsing_state *state,parse_error err)

{
  uchar error_msg [6] [40];
  
  if (state->filename != (uchar *)0x0) {
    __fprintf_chk(stderr,1,"%s:%d: %s\n",state->filename,(state->pos).line,"no error" + err * 0x28);
  }
  return err;
}



parse_error
parse_bind(option_elinks *opt_tree,conf_parsing_state *state,string *mirror,int is_system_conf)

{
  uchar *name;
  uchar *keymap_str;
  parse_error pVar1;
  uchar *keystroke_str;
  uchar *action_str;
  uchar *source;
  int *line;
  int iVar2;
  
  skip_white((conf_parsing_pos *)state);
  keystroke_str = (state->pos).look;
  if (*keystroke_str == '\0') goto LAB_0806e67a;
  iVar2 = (state->pos).line;
  line = &(state->pos).line;
  keymap_str = str_rd((option_elinks *)0x0,(uchar **)state,line);
  skip_white((conf_parsing_pos *)state);
  if ((keymap_str == (uchar *)0x0) || (name = (state->pos).look, *name == '\0')) {
    (state->pos).look = keystroke_str;
    (state->pos).line = iVar2;
    goto LAB_0806e67a;
  }
  iVar2 = (state->pos).line;
  keystroke_str = str_rd((option_elinks *)0x0,(uchar **)state,line);
  skip_white((conf_parsing_pos *)state);
  if (keystroke_str == (uchar *)0x0) {
    mem_free(keymap_str);
  }
  else {
    if (*(state->pos).look != '\0') {
      skip_white((conf_parsing_pos *)state);
      name = (state->pos).look;
      if (*name == '=') {
        (state->pos).look = name + 1;
        skip_white((conf_parsing_pos *)state);
        name = (state->pos).look;
        if (*name != '\0') {
          iVar2 = (state->pos).line;
          action_str = str_rd((option_elinks *)0x0,(uchar **)state,line);
          if (action_str == (uchar *)0x0) {
            mem_free(keymap_str);
            mem_free(keystroke_str);
            (state->pos).line = iVar2;
            (state->pos).look = name;
            goto LAB_0806e67a;
          }
          if (mirror == (string *)0x0) {
            line = get_opt_(cmdline_options,name);
            if (*line == 0) {
              iVar2 = bind_do(keymap_str,keystroke_str,action_str,is_system_conf);
              if (iVar2 != 0) goto LAB_0806e84e;
            }
          }
          else {
            if (is_system_conf == 0) {
              source = bind_act(keymap_str,keystroke_str);
              if (source != (uchar *)0x0) {
                add_bytes_to_string__(mirror,state->mirrored,(int)(name + -(int)state->mirrored));
                add_to_string(mirror,source);
                mem_free(source);
                state->mirrored = (state->pos).look;
                pVar1 = ERROR_NONE;
                goto LAB_0806e772;
              }
LAB_0806e84e:
              pVar1 = show_parse_error(state,ERROR_VALUE);
              goto LAB_0806e772;
            }
          }
          pVar1 = ERROR_NONE;
LAB_0806e772:
          mem_free(keymap_str);
          mem_free(keystroke_str);
          mem_free(action_str);
          return pVar1;
        }
      }
      mem_free(keymap_str);
      mem_free(keystroke_str);
      goto LAB_0806e67a;
    }
    mem_free(keymap_str);
    mem_free(keystroke_str);
  }
  (state->pos).look = name;
  (state->pos).line = iVar2;
LAB_0806e67a:
  pVar1 = show_parse_error(state,ERROR_PARSE);
  return pVar1;
}



parse_error
parse_unset(option_elinks *opt_tree,conf_parsing_state *state,string *mirror,int is_system_conf)

{
  uchar uVar1;
  uchar *src;
  uchar *puVar2;
  uchar *name;
  option_elinks *option_elinks;
  option_elinks *poVar3;
  option_flags oVar4;
  parse_error err;
  
  skip_white((conf_parsing_pos *)state);
  src = (state->pos).look;
  uVar1 = *src;
  puVar2 = src;
  if (uVar1 == '\0') {
    err = ERROR_PARSE;
  }
  else {
    while ((((((byte)(uVar1 + 0x9f) < 0x1a || ((byte)(uVar1 + 0xbf) < 0x1a)) ||
             ((byte)(uVar1 - 0x30) < 10)) || ((uVar1 == '_' || (uVar1 == '-')))) ||
           ((uVar1 == '*' || ((uVar1 == '.' || (uVar1 == '+'))))))) {
      puVar2 = puVar2 + 1;
      (state->pos).look = puVar2;
      uVar1 = *puVar2;
    }
    name = memacpy(src,(int)(puVar2 + -(int)src));
    if (name != (uchar *)0x0) {
      option_elinks = get_opt_rec_real(opt_tree,name);
      mem_free(name);
      if ((option_elinks != (option_elinks *)0x0) && ((option_elinks->flags & OPT_HIDDEN) == 0)) {
        if (mirror == (string *)0x0) {
          if ((option_elinks->flags & OPT_ALLOC) == 0) {
            mark_option_as_deleted(option_elinks);
          }
          else {
            delete_option(option_elinks);
          }
        }
        else {
          if (is_system_conf == 0) {
            poVar3 = indirect_option(option_elinks);
            oVar4 = poVar3->flags;
            if ((-1 < (char)oVar4) &&
               (option_types[option_elinks->type].write !=
                (anon_subr_void_option_elinks_ptr_string_ptr_for_write *)0x0)) {
              add_to_string(mirror,"set ");
              add_bytes_to_string__(mirror,src,(int)(puVar2 + -(int)src));
              add_to_string(mirror," = ");
              (*option_types[option_elinks->type].write)(option_elinks,mirror);
              state->mirrored = (state->pos).look;
              oVar4 = poVar3->flags;
            }
            poVar3->flags = oVar4 & ~OPT_MUST_SAVE;
          }
          else {
            option_elinks = indirect_option(option_elinks);
            oVar4 = option_elinks->flags;
            if ((char)oVar4 < '\0') {
              option_elinks->flags = oVar4 & ~OPT_MUST_SAVE;
            }
            else {
              option_elinks->flags = oVar4 | OPT_MUST_SAVE;
            }
          }
        }
      }
      return ERROR_NONE;
    }
    err = ERROR_NOMEM;
  }
  err = show_parse_error(state,err);
  return err;
}



parse_error
parse_set(option_elinks *opt_tree,conf_parsing_state *state,string *mirror,int is_system_conf)

{
  uchar uVar1;
  uchar *src;
  uchar *puVar2;
  uchar *name_;
  option_elinks *alias;
  int iVar3;
  option_elinks *poVar4;
  option_flags oVar5;
  parse_error err;
  uchar *puVar6;
  
  skip_white((conf_parsing_pos *)state);
  src = (state->pos).look;
  uVar1 = *src;
  puVar6 = src;
  if (uVar1 != '\0') {
    while ((((((byte)(uVar1 + 0x9f) < 0x1a || ((byte)(uVar1 + 0xbf) < 0x1a)) ||
             ((byte)(uVar1 - 0x30) < 10)) || ((uVar1 == '_' || (uVar1 == '-')))) ||
           ((uVar1 == '*' || ((uVar1 == '.' || (uVar1 == '+'))))))) {
      puVar6 = puVar6 + 1;
      (state->pos).look = puVar6;
      uVar1 = *puVar6;
    }
    skip_white((conf_parsing_pos *)state);
    name_ = (state->pos).look;
    if (*name_ == '=') {
      (state->pos).look = name_ + 1;
      skip_white((conf_parsing_pos *)state);
      if (*(state->pos).look != '\0') {
        name_ = memacpy(src,(int)(puVar6 + -(int)src));
        if (name_ == (uchar *)0x0) {
          err = ERROR_NOMEM;
          goto LAB_0806ead5;
        }
        iVar3 = (state->pos).line;
        puVar2 = (state->pos).look;
        if (mirror == (string *)0x0) {
          alias = get_opt_rec(opt_tree,name_);
        }
        else {
          alias = get_opt_rec_real(opt_tree,name_);
        }
        mem_free(name_);
        if ((alias == (option_elinks *)0x0) || ((*(byte *)&alias->flags & 1) != 0)) {
          show_parse_error(state,ERROR_OPTION);
          skip_option_value((conf_parsing_pos *)state);
          return ERROR_OPTION;
        }
        if (option_types[alias->type].read ==
            (anon_subr_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_int_ptr_for_read *)0x0) {
LAB_0806ecc2:
          show_parse_error(state,ERROR_VALUE);
          skip_option_value((conf_parsing_pos *)state);
          return ERROR_VALUE;
        }
        name_ = (*option_types[alias->type].read)(alias,(uchar **)state,&(state->pos).line);
        if (name_ == (uchar *)0x0) {
          (state->pos).line = iVar3;
          (state->pos).look = puVar2;
          goto LAB_0806ecc2;
        }
        if (mirror != (string *)0x0) {
          if (is_system_conf == 0) {
            poVar4 = indirect_option(alias);
            oVar5 = poVar4->flags;
            if ((char)oVar5 < '\0') {
              add_to_string(mirror,(uchar *)"unset ");
              add_bytes_to_string__(mirror,src,(int)(puVar6 + -(int)src));
              state->mirrored = (state->pos).look;
              oVar5 = poVar4->flags;
            }
            else {
              if (option_types[alias->type].write !=
                  (anon_subr_void_option_elinks_ptr_string_ptr_for_write *)0x0) {
                add_bytes_to_string__(mirror,state->mirrored,(int)(puVar2 + -(int)state->mirrored));
                (*option_types[alias->type].write)(alias,mirror);
                state->mirrored = (state->pos).look;
                oVar5 = poVar4->flags;
              }
            }
            poVar4->flags = oVar5 & ~OPT_MUST_SAVE;
          }
          else {
            poVar4 = indirect_option(alias);
            oVar5 = poVar4->flags;
            if ((-1 < (char)oVar5) &&
               (option_types[alias->type].equals !=
                (anon_subr_int_option_elinks_ptr_uchar_ptr_for_equals *)0x0)) {
              iVar3 = (*option_types[alias->type].equals)(alias,name_);
              if (iVar3 != 0) {
                poVar4->flags = poVar4->flags & ~OPT_MUST_SAVE;
                goto LAB_0806ec22;
              }
              oVar5 = poVar4->flags;
            }
            poVar4->flags = oVar5 | OPT_MUST_SAVE;
          }
LAB_0806ec22:
          mem_free(name_);
          return ERROR_NONE;
        }
        if ((option_types[alias->type].set !=
             (anon_subr_int_option_elinks_ptr_uchar_ptr_for_set *)0x0) &&
           (iVar3 = (*option_types[alias->type].set)(alias,name_), iVar3 != 0)) goto LAB_0806ec22;
        mem_free(name_);
      }
      err = ERROR_VALUE;
      goto LAB_0806ead5;
    }
  }
  err = ERROR_PARSE;
LAB_0806ead5:
  err = show_parse_error(state,err);
  return err;
}



string * wrap_option_desc(string *out,uchar *src,string *indent,int maxwidth)

{
  uint uVar1;
  uchar uVar2;
  string *psVar3;
  uint size;
  uchar *puVar4;
  uchar *puVar5;
  uint uVar6;
  uchar *__n;
  uchar *puVar7;
  uchar *source;
  
  uVar2 = *src;
  if (uVar2 == '\0') {
    return out;
  }
  puVar5 = (uchar *)0x0;
  __n = (uchar *)0x0;
  source = src;
  do {
    puVar7 = src;
    if (uVar2 == '\n') {
split:
      psVar3 = add_string_to_string(out,indent);
      if (psVar3 == (string *)0x0) {
        return (string *)0x0;
      }
      if (assert_failed != 0) {
        assert_failed = 0;
        return (string *)0x0;
      }
      __n = puVar7 + -(int)source;
      if (((source == (uchar *)0x0) || (out == (string *)0x0)) || ((int)__n < 0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) {
          assert_failed = 0;
          return (string *)0x0;
        }
      }
      else {
        assert_failed = 0;
      }
      if (__n != (uchar *)0x0) {
        puVar5 = __n + out->length;
        uVar6 = out->length + 0xff;
        uVar1 = uVar6 >> 8;
        uVar6 = uVar6 & 0xffffff00;
        size = (uint)(puVar5 + 0x100) & 0xffffff00;
        if (uVar6 <= size && size + uVar1 * -0x100 != 0) {
          puVar4 = (uchar *)mem_realloc(out->source,size);
          if (puVar4 == (uchar *)0x0) {
            return (string *)0x0;
          }
          out->source = puVar4;
          memset(puVar4 + uVar6,0,size + uVar1 * -0x100);
        }
        if (out->source == (uchar *)0x0) {
          return (string *)0x0;
        }
        memcpy(out->source + out->length,source,(size_t)__n);
        out->source[(int)puVar5] = '\0';
        *(uchar **)&out->length = puVar5;
      }
      if (out == (string *)0x0) {
        return (string *)0x0;
      }
      psVar3 = add_char_to_string(out,'\n');
      if (psVar3 == (string *)0x0) {
        return (string *)0x0;
      }
      uVar2 = src[1];
      source = puVar7 + 1;
      __n = (uchar *)0x0;
      puVar5 = src + -(int)source;
    }
    else {
      if (uVar2 == ' ') {
        __n = src;
      }
      if ((__n != (uchar *)0x0) && (puVar7 = __n, maxwidth <= (int)puVar5)) goto split;
      uVar2 = src[1];
    }
    if (uVar2 == '\0') {
      if (*source == '\0') {
        return out;
      }
      psVar3 = add_string_to_string(out,indent);
      if (((psVar3 != (string *)0x0) &&
          (psVar3 = add_to_string(out,source), psVar3 != (string *)0x0)) &&
         (psVar3 = add_char_to_string(out,'\n'), psVar3 != (string *)0x0)) {
        return out;
      }
      return (string *)0x0;
    }
    src = src + 1;
    puVar5 = puVar5 + 1;
  } while( true );
}



void smart_config_output_fn
               (string *string,option_elinks *option_elinks,uchar *path,int depth,
               int do_print_comment,int action,int i18n)

{
  string *psVar1;
  uchar *msgid;
  bool bVar2;
  string indent;
  
  if (option_elinks->type != OPT_ALIAS) {
    if (action == 1) {
      if (((((byte)comments & 2) != 0) && (msgid = option_elinks->desc, do_print_comment != 0)) &&
         (msgid != (uchar *)0x0)) {
        if (i18n != 0) {
          msgid = gettext(msgid);
        }
        psVar1 = init_string(&indent);
        if (psVar1 != (string *)0x0) {
          if (depth != 0) {
            add_xchar_to_string(&indent,' ',depth * indentation);
          }
          psVar1 = add_to_string(&indent,"#  ");
          if (psVar1 != (string *)0x0) {
            wrap_option_desc(string,msgid,&indent,0x50 - indent.length);
          }
          done_string(&indent);
        }
      }
    }
    else {
      if (action < 2) {
        if ((action == 0) && (((byte)comments & 1) != 0)) {
          if (depth != 0) {
            add_xchar_to_string(string,' ',depth * indentation);
          }
          add_to_string(string,"## ");
          if (path != (uchar *)0x0) {
            add_to_string(string,path);
            add_char_to_string(string,'.');
          }
          add_to_string(string,option_elinks->name);
          add_char_to_string(string,' ');
          add_to_string(string,option_types[option_elinks->type].help_str);
          add_char_to_string(string,'\n');
        }
      }
      else {
        if (action == 2) {
          if (depth != 0) {
            add_xchar_to_string(string,' ',depth * indentation);
          }
          if (*(char *)&option_elinks->flags < '\0') {
            add_to_string(string,"un");
          }
          add_to_string(string,"set ");
          if (path != (uchar *)0x0) {
            add_to_string(string,path);
            add_char_to_string(string,'.');
          }
          add_to_string(string,option_elinks->name);
          if (-1 < *(char *)&option_elinks->flags) {
            add_to_string(string," = ");
            if ((assert_failed == 0) &&
               (bVar2 = option_types[option_elinks->type].write ==
                        (anon_subr_void_option_elinks_ptr_string_ptr_for_write *)0x0,
               assert_failed = ZEXT14(bVar2), bVar2)) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/conf.c";
              errline = 0x38a;
              elinks_internal((uchar *)"assertion option_types[option->type].write failed!");
            }
            (*option_types[option_elinks->type].write)(option_elinks,string);
          }
          add_char_to_string(string,'\n');
          if (do_print_comment == 0) {
            return;
          }
        }
        else {
          if (action != 3) {
            return;
          }
          if (1 < do_print_comment) {
            return;
          }
        }
        add_char_to_string(string,'\n');
      }
    }
  }
  return;
}



uchar * __regparm3 read_config_file(uchar *name)

{
  int iVar1;
  uint uVar2;
  int fd;
  string *psVar3;
  size_t __n;
  uchar *puVar4;
  uint uVar5;
  uint size;
  int in_GS_OFFSET;
  string string;
  uchar cfg_buffer [1024];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  fd = open64((char *)name,0x100);
  if (-1 < fd) {
    set_bin(fd);
    psVar3 = init_string(&string);
    if (psVar3 != (string *)0x0) {
LAB_0806f33b:
      do {
        __n = read(fd,cfg_buffer,0x400);
        if ((int)__n < 1) goto LAB_0806f3ef;
        puVar4 = cfg_buffer;
        do {
          if (*puVar4 == '\0') {
            *puVar4 = ' ';
          }
          puVar4 = puVar4 + 1;
        } while (puVar4 != cfg_buffer + __n);
        if (assert_failed == 0) {
          assert_failed = 0;
          iVar1 = __n + string.length;
          uVar2 = string.length + 0xffU >> 8;
          uVar5 = string.length + 0xffU & 0xffffff00;
          size = iVar1 + 0x100U & 0xffffff00;
          if (uVar5 <= size && size + uVar2 * -0x100 != 0) {
            puVar4 = (uchar *)mem_realloc(string.source,size);
            if (puVar4 == (uchar *)0x0) goto LAB_0806f33b;
            string.source = puVar4;
            memset(puVar4 + uVar5,0,size + uVar2 * -0x100);
          }
          if (string.source != (uchar *)0x0) {
            memcpy(string.source + string.length,cfg_buffer,__n);
            string.source[iVar1] = '\0';
            string.length = iVar1;
          }
          goto LAB_0806f33b;
        }
        assert_failed = 0;
      } while( true );
    }
  }
  puVar4 = (uchar *)0x0;
LAB_0806f300:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return puVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_0806f3ef:
  if (__n != 0) {
    done_string(&string);
  }
  close(fd);
  puVar4 = string.source;
  goto LAB_0806f300;
}



void parse_config_file(option_elinks *options,uchar *name,uchar *file,string *mirror,
                      int is_system_conf)

{
  bool bVar1;
  size_t __n;
  int iVar2;
  ushort **ppuVar3;
  parse_error pVar4;
  int *piVar5;
  uchar *puVar6;
  uchar *puVar7;
  uint uVar8;
  uchar uVar9;
  uchar *in_EDX;
  uchar *name_00;
  uint size;
  uchar *__src;
  parse_handler *ppVar10;
  uchar *__n_00;
  uchar *__s1;
  byte *pbVar11;
  uint size_00;
  conf_parsing_state state;
  
  state.filename = (uchar *)0x0;
  state.pos.line = 1;
  state.pos.look = file;
  state.mirrored = file;
  if ((mirror == (string *)0x0) && (piVar5 = get_opt_(cmdline_options,in_EDX), 0 < *piVar5)) {
    state.filename = name;
  }
  bVar1 = false;
  while ((state.pos.look != (uchar *)0x0 && (*state.pos.look != '\0'))) {
    skip_white((conf_parsing_pos *)&state);
    __src = state.mirrored;
    __s1 = state.mirrored;
    if (mirror != (string *)0x0) {
      if (assert_failed == 0) {
        __n_00 = state.pos.look + -(int)state.mirrored;
        if ((state.mirrored == (uchar *)0x0) || ((int)__n_00 < 0)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_0806f4e0;
        }
        else {
          assert_failed = 0;
        }
        __s1 = state.pos.look;
        if (__n_00 != (uchar *)0x0) {
          puVar7 = __n_00 + mirror->length;
          uVar8 = mirror->length + 0xffU & 0xffffff00;
          size_00 = (uint)(puVar7 + 0x100) & 0xffffff00;
          if (uVar8 < size_00) {
            puVar6 = (uchar *)mem_realloc(mirror->source,size_00);
            __s1 = state.pos.look;
            if (puVar6 == (uchar *)0x0) goto LAB_0806f4f3;
            mirror->source = puVar6;
            memset(puVar6 + uVar8,0,size_00 - uVar8);
          }
          __s1 = state.pos.look;
          if (mirror->source != (uchar *)0x0) {
            memcpy(mirror->source + mirror->length,__src,(size_t)__n_00);
            mirror->source[(int)puVar7] = '\0';
            *(uchar **)&mirror->length = puVar7;
            __s1 = state.pos.look;
          }
        }
      }
      else {
LAB_0806f4e0:
        assert_failed = 0;
        __s1 = state.pos.look;
      }
    }
LAB_0806f4f3:
    state.mirrored = __s1;
    if (*state.pos.look == '\0') break;
    if (assert_failed == 0) {
      if ((mirror == (string *)0x0) || (state.pos.look == state.mirrored)) {
        assert_failed = 0;
      }
      else {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/conf.c";
        errline = 0x23e;
        elinks_internal((uchar *)
                        "assertion mirror == NULL || state->mirrored == state->pos.look failed!");
        if (assert_failed != 0) goto LAB_0806f6b8;
      }
      __s1 = state.pos.look;
      __src = "set";
      ppVar10 = parse_handlers;
      do {
        __n = strlen((char *)__src);
        iVar2 = strncmp((char *)__s1,(char *)__src,__n);
        if (iVar2 == 0) {
          ppuVar3 = __ctype_b_loc();
          pbVar11 = __s1 + __n;
          if ((*(byte *)((int)*ppuVar3 + (uint)*pbVar11 * 2 + 1) & 0x20) != 0) {
            state.pos.look = pbVar11;
            pVar4 = (*ppVar10->handler)(options,&state,mirror,is_system_conf);
            __src = state.mirrored;
            if (mirror != (string *)0x0) {
              if (assert_failed == 0) {
                __s1 = state.pos.look + -(int)state.mirrored;
                if ((state.mirrored == (uchar *)0x0) || ((int)__s1 < 0)) {
                  assert_failed = 1;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                  errline = 0xff;
                  elinks_internal((uchar *)
                                  "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                                 );
                  if (assert_failed != 0) goto LAB_0806f752;
                }
                else {
                  assert_failed = 0;
                }
                if (__s1 != (uchar *)0x0) {
                  __n_00 = __s1 + mirror->length;
                  size_00 = mirror->length + 0xff;
                  uVar8 = size_00 >> 8;
                  size_00 = size_00 & 0xffffff00;
                  size = (uint)(__n_00 + 0x100) & 0xffffff00;
                  if (size_00 <= size && size + uVar8 * -0x100 != 0) {
                    puVar7 = (uchar *)mem_realloc(mirror->source,size);
                    if (puVar7 == (uchar *)0x0) goto LAB_0806f818;
                    mirror->source = puVar7;
                    memset(puVar7 + size_00,0,size + uVar8 * -0x100);
                  }
                  if (mirror->source != (uchar *)0x0) {
                    memcpy(mirror->source + mirror->length,__src,(size_t)__s1);
                    mirror->source[(int)__n_00] = '\0';
                    *(uchar **)&mirror->length = __n_00;
                  }
                }
LAB_0806f818:
                state.mirrored = state.pos.look;
              }
              else {
LAB_0806f752:
                assert_failed = 0;
                state.mirrored = state.pos.look;
              }
            }
            goto LAB_0806f5c4;
          }
        }
        ppVar10 = ppVar10 + 1;
        __src = ppVar10->command;
      } while (__src != (uchar *)0x0);
      pVar4 = show_parse_error(&state,ERROR_COMMAND);
    }
    else {
LAB_0806f6b8:
      assert_failed = 0;
      pVar4 = show_parse_error(&state,ERROR_PARSE);
    }
LAB_0806f5c4:
    if (pVar4 != ERROR_NONE) {
      if (pVar4 < ERROR_OPTION) {
        while (__src = state.mirrored, uVar9 = *state.pos.look, uVar9 != '#') {
          while( true ) {
            if ((uVar9 == '\0') || (uVar9 == '\n')) goto LAB_0806f685;
            if ((uVar9 == '\'') || (uVar9 == '\"')) break;
            state.pos.look = state.pos.look + 1;
            uVar9 = *state.pos.look;
            if (uVar9 == '#') goto LAB_0806f685;
          }
          skip_quoted((conf_parsing_pos *)&state);
        }
LAB_0806f685:
        if (mirror != (string *)0x0) {
          if (assert_failed == 0) {
            __s1 = state.pos.look + -(int)state.mirrored;
            if ((state.mirrored == (uchar *)0x0) || ((int)__s1 < 0)) {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
              errline = 0xff;
              elinks_internal((uchar *)
                              "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                             );
              if (assert_failed != 0) goto LAB_0806f6a4;
            }
            else {
              assert_failed = 0;
            }
            if (__s1 != (uchar *)0x0) {
              __n_00 = __s1 + mirror->length;
              uVar8 = mirror->length + 0xffU & 0xffffff00;
              size_00 = (uint)(__n_00 + 0x100) & 0xffffff00;
              if (uVar8 < size_00) {
                puVar7 = (uchar *)mem_realloc(mirror->source,size_00);
                if (puVar7 == (uchar *)0x0) goto LAB_0806f7dd;
                mirror->source = puVar7;
                memset(puVar7 + uVar8,0,size_00 - uVar8);
              }
              if (mirror->source != (uchar *)0x0) {
                memcpy(mirror->source + mirror->length,__src,(size_t)__s1);
                mirror->source[(int)__n_00] = '\0';
                *(uchar **)&mirror->length = __n_00;
              }
            }
LAB_0806f7dd:
            state.mirrored = state.pos.look;
          }
          else {
LAB_0806f6a4:
            assert_failed = 0;
            state.mirrored = state.pos.look;
          }
        }
      }
      bVar1 = true;
    }
  }
  if ((bVar1) && (state.filename != (uchar *)0x0)) {
    fputc(7,stderr);
    piVar5 = get_opt_(cmdline_options,name_00);
    if ((*piVar5 == 0) && (piVar5 = get_opt_(cmdline_options,(uchar *)0x0), *piVar5 == 0)) {
      sleep(1);
    }
  }
  return;
}



int __regparm3
load_config_file(uchar *prefix,uchar *name,option_elinks *options,string *mirror,int is_system_conf)

{
  uchar *name_00;
  uchar *file;
  
  name_00 = straconcat(prefix,&DAT_08132419,name,0);
  if (name_00 == (uchar *)0x0) {
    return 1;
  }
  file = read_config_file(name_00);
  if (file == (uchar *)0x0) {
    mem_free(name_00);
    name_00 = straconcat(prefix,&DAT_08132419,&DAT_0813015e,name,0);
    if (name_00 == (uchar *)0x0) {
      return 2;
    }
    file = read_config_file(name_00);
    if (file == (uchar *)0x0) {
      mem_free(name_00);
      return 3;
    }
  }
  parse_config_file(options,name_00,file,mirror,is_system_conf);
  mem_free(file);
  mem_free(name_00);
  return 0;
}



uchar * create_config_string(uchar *prefix,uchar *name,option_elinks *options)

{
  uint uVar1;
  int i18n;
  uint *puVar2;
  int *piVar3;
  string *psVar4;
  int iVar5;
  char *msgid;
  uchar *in_EDX;
  uchar *name_00;
  uchar *extraout_EDX;
  uchar *name_01;
  string tmpstring;
  string config;
  
  puVar2 = get_opt_(config_options,in_EDX);
  uVar1 = *puVar2;
  piVar3 = get_opt_(config_options,name_00);
  i18n = *piVar3;
  psVar4 = init_string(&config);
  if (psVar4 == (string *)0x0) {
    return (uchar *)0x0;
  }
  prepare_mustsave_flags((list_head_elinks *)options->value,(uint)(uVar1 - 1 < 2));
  if (((uVar1 != 2) && (iVar5 = load_config_file(prefix,name,options,&config,0), iVar5 == 0)) &&
     (config.length != 0)) goto LAB_0806fcd7;
  add_to_string(&config,(uchar *)"## ELinks 0.12pre5 configuration file\n\n");
  if ((assert_failed == 0) && (assert_failed = ZEXT14(3 < uVar1), 3 < uVar1)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/conf.c";
    errline = 0x3bf;
    elinks_internal((uchar *)"assertion savestyle >= 0 && savestyle <= 3 failed!");
  }
  if (uVar1 == 1) {
LAB_0806fde8:
    msgid = 
    "## This is ELinks configuration file. You can edit it manually,\n## if you wish so; this file is edited by ELinks when you save\n## options through UI, however only option values will be altered\n## and missing options will be added at the end of file; if option\n## is not written in this file, but in some file included from it,\n## it is NOT counted as missing. Note that all your formatting,\n## own comments and so on will be kept as-is.\n"
    ;
joined_r0x0806fe67:
    if (i18n != 0) {
      msgid = (char *)gettext((uchar *)msgid);
    }
    add_to_string(&config,(uchar *)msgid);
  }
  else {
    if ((int)uVar1 < 2) {
      if (uVar1 == 0) {
        msgid = 
        "## This is ELinks configuration file. You can edit it manually,\n## if you wish so; this file is edited by ELinks when you save\n## options through UI, however only option values will be altered\n## and all your formatting, own comments etc will be kept as-is.\n"
        ;
        goto joined_r0x0806fe67;
      }
    }
    else {
      if (uVar1 == 2) {
        msgid = 
        "## This is ELinks configuration file. You can edit it manually,\n## if you wish so, but keep in mind that this file is overwritten\n## by ELinks when you save options through UI and you are out of\n## luck with your formatting and own comments then, so beware.\n"
        ;
        goto joined_r0x0806fe67;
      }
      if (uVar1 == 3) goto LAB_0806fde8;
    }
  }
  add_to_string(&config,"##\n");
  msgid = 
  "## Obviously, if you don\'t like what ELinks is going to do with\n## this file, you can change it by altering the config.saving_style\n## option. Come on, aren\'t we friendly guys after all?\n"
  ;
  if (i18n != 0) {
    msgid = (char *)gettext((uchar *)
                            "## Obviously, if you don\'t like what ELinks is going to do with\n## this file, you can change it by altering the config.saving_style\n## option. Come on, aren\'t we friendly guys after all?\n"
                           );
  }
  add_to_string(&config,(uchar *)msgid);
  config.length = (int)extraout_EDX;
LAB_0806fcd7:
  if (uVar1 != 0) {
    piVar3 = get_opt_(config_options,(uchar *)config.length);
    indentation = *piVar3;
    piVar3 = get_opt_(config_options,name_01);
    comments = *piVar3;
    psVar4 = init_string(&tmpstring);
    if (psVar4 != (string *)0x0) {
      msgid = "Automatically saved options\n";
      if (i18n != 0) {
        msgid = (char *)gettext((uchar *)"Automatically saved options\n");
      }
      add_cfg_header_to_string(&tmpstring,(uchar *)msgid);
      iVar5 = tmpstring.length;
      smart_config_string(&tmpstring,2,i18n,(list_head_elinks *)options->value,(uchar *)0x0,0,
                          smart_config_output_fn);
      if (iVar5 < tmpstring.length) {
        add_string_to_string(&config,&tmpstring);
      }
      done_string(&tmpstring);
      psVar4 = init_string(&tmpstring);
      if (psVar4 != (string *)0x0) {
        msgid = "Automatically saved keybindings\n";
        if (i18n != 0) {
          msgid = (char *)gettext((uchar *)"Automatically saved keybindings\n");
        }
        add_cfg_header_to_string(&tmpstring,(uchar *)msgid);
        i18n = tmpstring.length;
        bind_config_string(&tmpstring);
        if (i18n < tmpstring.length) {
          add_string_to_string(&config,&tmpstring);
        }
        done_string(&tmpstring);
      }
    }
  }
  return config.source;
}



int write_config(terminal *term)

{
  uchar *str;
  option_elinks *options;
  uchar *p;
  size_t sVar1;
  int stdio_error;
  secure_save_info *ssi;
  uchar **ppuVar2;
  undefined1 *puVar3;
  uchar *in_EDX;
  uchar *extraout_EDX;
  uchar *name;
  bool bVar4;
  bool bVar5;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(term == (terminal *)0x0), term == (terminal *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/conf.c";
    errline = 0x42d;
    elinks_internal((uchar *)"assertion term failed!");
    in_EDX = extraout_EDX;
  }
  options = config_options;
  if (elinks_home == (uchar *)0x0) {
    ppuVar2 = (uchar **)get_opt_(cmdline_options,in_EDX);
    write_config_dialog(term,*ppuVar2,1,0);
    return -1;
  }
  ppuVar2 = (uchar **)get_opt_(cmdline_options,(uchar *)config_options);
  str = elinks_home;
  name = *ppuVar2;
  p = create_config_string(elinks_home,name,options);
  sVar1 = strlen((char *)str);
  bVar5 = false;
  if (sVar1 == 0) {
    bVar4 = *name == '/';
LAB_0806ff54:
    puVar3 = &DAT_08132419;
    if (!bVar4) goto LAB_0806ff62;
  }
  else {
    bVar5 = str[sVar1 - 1] == '/';
    bVar4 = *name == '/';
    if (!bVar5) goto LAB_0806ff54;
  }
  puVar3 = &DAT_0812e3d8;
LAB_0806ff62:
  stdio_error = -1;
  if (p != (uchar *)0x0) {
    if (bVar5) {
      name = name + bVar4;
    }
    name = straconcat(str,puVar3,name,0);
    stdio_error = -1;
    if (name != (uchar *)0x0) {
      ssi = secure_open(name);
      stdio_error = -1;
      if (ssi != (secure_save_info *)0x0) {
        secure_fputs(ssi,(char *)p);
        stdio_error = secure_close(ssi);
        if (stdio_error == 0) {
          untouch_options((list_head_elinks *)options->value);
        }
      }
      write_config_dialog(term,name,secsave_errno,stdio_error);
      mem_free(name);
    }
    mem_free(p);
  }
  return stdio_error;
}



void load_config(void)

{
  uchar *name;
  option_elinks *options;
  uchar **ppuVar1;
  uchar *prefix;
  uchar *in_EDX;
  
  options = config_options;
  ppuVar1 = (uchar **)get_opt_(cmdline_options,in_EDX);
  name = *ppuVar1;
  load_config_file((uchar *)"/etc/elinks",name,options,(string *)0x0,1);
  prefix = elinks_home;
  if (elinks_home == (uchar *)0x0) {
    prefix = "";
  }
  load_config_file(prefix,name,options,(string *)0x0,0);
  return;
}



parse_error
parse_include(option_elinks *opt_tree,conf_parsing_state *state,string *mirror,int is_system_conf)

{
  string *mirror_00;
  uchar *name;
  uchar *prefix;
  int iVar1;
  parse_error pVar2;
  string dumbstring;
  
  mirror_00 = init_string(&dumbstring);
  if (mirror_00 == (string *)0x0) {
    pVar2 = show_parse_error(state,ERROR_NOMEM);
  }
  else {
    skip_white((conf_parsing_pos *)state);
    prefix = (state->pos).look;
    if (*prefix == '\0') {
      done_string(&dumbstring);
      pVar2 = show_parse_error(state,ERROR_PARSE);
    }
    else {
      iVar1 = (state->pos).line;
      name = str_rd((option_elinks *)0x0,(uchar **)state,&(state->pos).line);
      if (name == (uchar *)0x0) {
        done_string(&dumbstring);
        (state->pos).line = iVar1;
        (state->pos).look = prefix;
        pVar2 = show_parse_error(state,ERROR_PARSE);
      }
      else {
        mirror_00 = (string *)0x0;
        if (mirror != (string *)0x0) {
          mirror_00 = &dumbstring;
        }
        prefix = "";
        if (*name != '/') {
          prefix = elinks_home;
        }
        iVar1 = load_config_file(prefix,name,opt_tree,mirror_00,1);
        if (iVar1 == 0) {
          done_string(&dumbstring);
          mem_free(name);
          pVar2 = ERROR_NONE;
        }
        else {
          done_string(&dumbstring);
          mem_free(name);
          pVar2 = show_parse_error(state,ERROR_VALUE);
        }
      }
    }
  }
  return pVar2;
}



void lock_option(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + 1;
  return;
}



void unlock_option(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



int is_option_used(listbox_item *item)

{
  return (uint)(*(int *)((int)item->udata + 8) != 0);
}



listbox_item * get_option_root(listbox_item *item)

{
  option_elinks *poVar1;
  
  poVar1 = *(option_elinks **)((int)item->udata + 0x2c);
  if ((poVar1 != config_options) && (poVar1 != (option_elinks *)0x0)) {
    return poVar1->box_item;
  }
  return (listbox_item *)0x0;
}



int can_delete_option(listbox_item *item)

{
  int iVar1;
  uint uVar2;
  
  iVar1 = *(int *)((int)item->udata + 0x2c);
  uVar2 = 0;
  if (iVar1 != 0) {
    uVar2 = *(uint *)(iVar1 + 0x10) & 2;
  }
  return uVar2;
}



void lock_keybinding(listbox_item *item)

{
  int *piVar1;
  
  if (item->depth != 2) {
    return;
  }
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + 1;
  return;
}



void unlock_keybinding(listbox_item *item)

{
  int *piVar1;
  
  if (item->depth != 2) {
    return;
  }
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



int is_keybinding_used(listbox_item *item)

{
  if (item->depth != 2) {
    return 0;
  }
  return (uint)(*(int *)((int)item->udata + 8) != 0);
}



int can_delete_keybinding(listbox_item *item)

{
  return (uint)(item->depth == 2);
}



listbox_item * get_keybinding_action_box_item(keymap_id keymap_id,action_id_T action_id)

{
  listbox_item *plVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (listbox_item *)0x0;
  }
  assert_failed = ZEXT14(0x7f < action_id);
  if (0x7f < action_id) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
    errline = 0x21f;
    elinks_internal((uchar *)"assertion action_id < ACTION_BOX_SIZE failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (listbox_item *)0x0;
    }
    plVar1 = action_box_items[keymap_id * 0x80 + action_id];
  }
  else {
    plVar1 = action_box_items[keymap_id * 0x80 + action_id];
  }
  return plVar1;
}



listbox_item * get_keybinding_root(listbox_item *item)

{
  listbox_item *plVar1;
  
  plVar1 = (listbox_item *)0x0;
  if (item->depth != 0) {
    if (item->depth == 1) {
      return keymap_box_item[*(int *)((int)item->udata + 8)];
    }
    plVar1 = get_keybinding_action_box_item
                       (*(keymap_id *)((int)item->udata + 0xc),
                        *(action_id_T *)((int)item->udata + 0x10));
  }
  return plVar1;
}



void delete_keybinding_item(listbox_item *item,int last)

{
  keybinding *keybinding;
  
  keybinding = (keybinding *)item->udata;
  if (assert_failed == 0) {
    if ((item->depth == 2) && ((keybinding->object).refcount == 0)) {
      assert_failed = 0;
    }
    else {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
      errline = 0x2da;
      elinks_internal((uchar *)"assertion item->depth == 2 && !is_object_used(keybinding) failed!");
    }
  }
  free_keybinding(keybinding);
  return;
}



uchar * __regparm3 _(terminal *term)

{
  int cp_index;
  uchar *codeset;
  terminal *in_EDX;
  
  if ((term != (terminal *)0x0) && (*(char *)&term->next != '\0')) {
    if (in_EDX != (terminal *)0x0) {
      cp_index = get_terminal_codepage(in_EDX);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    term = (terminal *)gettext((uchar *)term);
  }
  return (uchar *)term;
}



uchar * get_keybinding_info(listbox_item *item,terminal *term)

{
  void *pvVar1;
  string *psVar2;
  uchar *puVar3;
  uchar *puVar4;
  uchar *puVar5;
  string info;
  
  pvVar1 = item->udata;
  if ((1 < item->depth) && (item->type != BI_FOLDER)) {
    psVar2 = init_string(&info);
    if (psVar2 != (string *)0x0) {
      puVar3 = get_action_name(*(keymap_id *)((int)pvVar1 + 0xc),
                               *(action_id_T *)((int)pvVar1 + 0x10));
      puVar4 = get_keymap_name(*(keymap_id *)((int)pvVar1 + 0xc));
      puVar5 = _((terminal *)"Keystroke");
      add_format_to_string(&info,"%s: ",puVar5);
      add_keystroke_to_string(&info,(term_event_keyboard *)((int)pvVar1 + 0x14),0);
      puVar5 = _((terminal *)"Action");
      add_format_to_string(&info,(uchar *)"\n%s: %s",puVar5,puVar3);
      puVar3 = _((terminal *)"Keymap");
      add_format_to_string(&info,(uchar *)"\n%s: %s",puVar3,puVar4);
      return info.source;
    }
  }
  return (uchar *)0x0;
}



widget_handler_status_T
push_kbdbind_save_button(dialog_data *dlg_data,widget_data *some_useless_info_button)

{
  write_config(dlg_data->win->term);
  return EVENT_PROCESSED;
}



widget_handler_status_T
push_kbdbind_toggle_display_button(dialog_data *dlg_data,widget_data *some_useless_info_button)

{
  keybinding_text_toggle = ZEXT14(keybinding_text_toggle == 0);
  redraw_dialog(dlg_data,0);
  return EVENT_PROCESSED;
}



widget_handler_status_T check_option_name(dialog_data *dlg_data,widget_data *widget_data)

{
  uchar uVar1;
  uchar *puVar2;
  
  puVar2 = widget_data->cdata;
  uVar1 = *puVar2;
  while( true ) {
    if (uVar1 == '\0') {
      return EVENT_PROCESSED;
    }
    if ((((0x19 < (byte)(uVar1 + 0x9f)) && (0x19 < (byte)(uVar1 + 0xbf))) &&
        (9 < (byte)(uVar1 - 0x30))) && ((uVar1 != '_' && (uVar1 != '-')))) break;
    puVar2 = puVar2 + 1;
    uVar1 = *puVar2;
  }
  info_box(dlg_data->win->term,0,(uchar *)"Bad string",ALIGN_CENTER,
           (uchar *)
           "Option names may only contain alpha-numeric characters\nin addition to \'_\' and \'-\'."
          );
  return EVENT_NOT_PROCESSED;
}



widget_handler_status_T
push_kbdbind_add_button(dialog_data *dlg_data,widget_data *some_useless_info_button)

{
  terminal *term;
  listbox_item *plVar1;
  void *pvVar2;
  listbox_data *plVar3;
  terminal **p;
  terminal *keymap_id;
  uchar *text;
  uchar *puVar4;
  memory_list *ml;
  
  term = dlg_data->win->term;
  plVar3 = get_listbox_widget_data((widget_data *)(terminal *)dlg_data->widgets_data);
  plVar1 = plVar3->sel;
  if ((plVar1 == (listbox_item *)0x0) || (plVar1->depth == 0)) {
    info_box(term,0,(uchar *)"Add keybinding",ALIGN_CENTER,(uchar *)"Need to select an action.");
  }
  else {
    p = (terminal **)mem_calloc(1,0x18);
    if (p != (terminal **)0x0) {
      *p = term;
      p[5] = (terminal *)dlg_data->widgets_data;
      if (plVar1->depth == 2) {
        pvVar2 = plVar1->udata;
        p[1] = *(terminal **)((int)pvVar2 + 0x10);
        keymap_id = *(terminal **)((int)pvVar2 + 0xc);
        p[2] = keymap_id;
      }
      else {
        pvVar2 = plVar1->udata;
        p[1] = *(terminal **)((int)pvVar2 + 4);
        keymap_id = *(terminal **)((int)pvVar2 + 8);
        p[2] = keymap_id;
      }
      text = get_keymap_name((keymap_id)keymap_id);
      puVar4 = get_action_name((keymap_id)p[2],(action_id_T)p[1]);
      text = msg_text(term,(uchar *)
                           "Action: %s\nKeymap: %s\n\nKeystroke should be written in the format: [Shift-][Ctrl-][Alt-]Key\nKey: a,b,c,...,1,2,3,...,Space,Up,PageDown,Tab,Enter,Insert,F5,...\n\nKeystroke"
                      ,puVar4,text);
      ml = getml(p,text,0);
      input_dialog(term,ml,(uchar *)"Add keybinding",text,p,(input_history *)0x0,0x400,"",0,0,
                   check_keystroke,really_add_keybinding,(done_handler_T *)0x0);
    }
  }
  return EVENT_PROCESSED;
}



widget_handler_status_T push_add_button(dialog_data *dlg_data,widget_data *some_useless_info_button)

{
  terminal *term;
  listbox_data *plVar1;
  void **p;
  memory_list *ml;
  listbox_item *plVar2;
  void *pvVar3;
  
  term = dlg_data->win->term;
  plVar1 = get_listbox_widget_data(dlg_data->widgets_data);
  plVar2 = plVar1->sel;
  if ((((plVar2 == (listbox_item *)0x0) || (pvVar3 = plVar2->udata, pvVar3 == (void *)0x0)) ||
      (((plVar2->type == BI_FOLDER && ((*(byte *)&plVar2->field_0x18 & 1) == 0)) &&
       ((plVar2 = (*plVar1->ops->get_root)(plVar2), plVar2 == (listbox_item *)0x0 ||
        (pvVar3 = plVar2->udata, pvVar3 == (void *)0x0)))))) ||
     (((*(byte *)((int)pvVar3 + 0x10) & 2) == 0 &&
      ((pvVar3 = *(void **)((int)pvVar3 + 0x2c), pvVar3 == (void *)0x0 ||
       ((*(byte *)((int)pvVar3 + 0x10) & 2) == 0)))))) {
    info_box(term,0,(uchar *)"Add option",ALIGN_CENTER,(uchar *)"Cannot add an option here.");
  }
  else {
    p = (void **)mem_alloc(8);
    if (p != (void **)0x0) {
      *p = pvVar3;
      *(widget_data **)(p + 1) = dlg_data->widgets_data;
      ml = getml(p,0);
      input_dialog(term,ml,(uchar *)"Add option","Name",p,(input_history *)0x0,0x400,"",0,0,
                   check_option_name,add_option_to_tree,(done_handler_T *)0x0);
    }
  }
  return EVENT_PROCESSED;
}



void really_really_add_keybinding(void *data)

{
  keybinding *pkVar1;
  
  if ((assert_failed == 0) && (assert_failed = ZEXT14(data == (void *)0x0), data == (void *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
    errline = 0x308;
    elinks_internal((uchar *)"assertion hop failed!");
  }
  pkVar1 = add_keybinding(*(keymap_id *)((int)data + 8),*(action_id_T *)((int)data + 4),
                          (term_event_keyboard *)((int)data + 0xc),-1);
  if ((pkVar1 != (keybinding *)0x0) && (pkVar1->box_item != (listbox_item *)0x0)) {
    listbox_sel(*(widget_data **)((int)data + 0x14),pkVar1->box_item);
  }
  return;
}



void really_add_keybinding(void *data,uchar *keystroke)

{
  int iVar1;
  terminal **p;
  string *psVar2;
  uchar *text;
  memory_list *ml;
  string canonical;
  action_id_T local_20 [4];
  
  iVar1 = keybinding_exists(*(keymap_id *)((int)data + 8),(term_event_keyboard *)((int)data + 0xc),
                            local_20);
  if ((iVar1 == 0) || (local_20[0] == 0)) {
    really_really_add_keybinding(data);
  }
  else {
    if (local_20[0] != *(int *)((int)data + 4)) {
      p = (terminal **)mem_alloc(0x18);
      if (p != (terminal **)0x0) {
        *p = *(terminal **)data;
        p[1] = *(terminal **)((int)data + 4);
        p[2] = *(terminal **)((int)data + 8);
        p[3] = *(terminal **)((int)data + 0xc);
        p[4] = *(terminal **)((int)data + 0x10);
        p[5] = *(terminal **)((int)data + 0x14);
        psVar2 = init_string(&canonical);
        if (psVar2 != (string *)0x0) {
          add_keystroke_to_string(&canonical,(term_event_keyboard *)((int)data + 0xc),0);
        }
        text = get_action_name(*(keymap_id *)((int)data + 8),local_20[0]);
        if (canonical.length != 0) {
          keystroke = canonical.source;
        }
        text = msg_text(*p,(uchar *)
                           "The keystroke \"%s\" is currently used for \"%s\".\nAre you sure you want to replace it?"
                        ,keystroke,text);
        ml = getml(p,0);
        msg_box(*p,ml,MSGBOX_FREE_TEXT,(uchar *)"Keystroke already used",ALIGN_CENTER,text,p,2,
                &DAT_0812762b,really_really_add_keybinding,1,&DAT_08127627,0,2);
        done_string(&canonical);
      }
    }
  }
  return;
}



// WARNING: Type propagation algorithm not settling

widget_handler_status_T check_keystroke(dialog_data *dlg_data,widget_data *widget_data)

{
  terminal *ptVar1;
  int iVar2;
  
  ptVar1 = (terminal *)dlg_data->dlg->udata2;
  iVar2 = parse_keystroke(widget_data->cdata,(term_event_keyboard *)((int)&ptVar1->windows + 4));
  if (-1 < iVar2) {
    return EVENT_PROCESSED;
  }
  info_box(ptVar1->next,0,(uchar *)"Add keybinding",ALIGN_CENTER,(uchar *)"Invalid keystroke.");
  return EVENT_NOT_PROCESSED;
}



void delete_option_item(listbox_item *item,int last)

{
  option_elinks *option_elinks;
  bool bVar1;
  
  option_elinks = (option_elinks *)item->udata;
  if ((assert_failed == 0) &&
     (bVar1 = (option_elinks->object).refcount != 0, assert_failed = ZEXT14(bVar1), bVar1)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
    errline = 0xee;
    elinks_internal((uchar *)"assertion !is_object_used(option) failed!");
  }
  if ((*(byte *)&option_elinks->flags & 0x20) == 0) {
    mark_option_as_deleted(option_elinks);
    return;
  }
  delete_option(option_elinks);
  return;
}



void done_keybinding_listboxes(void)

{
  int **ppiVar1;
  int **ppiVar2;
  int **ppiVar3;
  int **ppiVar4;
  list_head_elinks *p;
  int **p_00;
  list_head_elinks *plVar5;
  bool bVar6;
  int *local_28;
  int **local_20;
  
  local_28 = (int *)keybinding_browser.root.child.next;
  p = (list_head_elinks *)keybinding_browser.root.child.next;
  if ((list_head_elinks *)keybinding_browser.root.child.next != &keybinding_browser.root.child) {
    do {
      local_20 = (int **)local_28[2];
      ppiVar4 = (int **)(local_28 + 2);
      p_00 = local_20;
      if (local_20 != ppiVar4) {
        do {
          p_00 = (int **)local_20[2];
          ppiVar1 = p_00;
          while (ppiVar1 != local_20 + 2) {
            ppiVar1 = (int **)*ppiVar1;
          }
          ppiVar2 = (int **)local_20[3];
          while (ppiVar2 != ppiVar1) {
            ppiVar2 = (int **)ppiVar2[1];
          }
          ppiVar2 = (int **)*p_00;
          while (ppiVar3 = ppiVar2, p_00 != ppiVar1) {
            ppiVar3[1] = p_00[1];
            *(int **)p_00[1] = *p_00;
            mem_free(p_00);
            ppiVar2 = (int **)*ppiVar3;
            p_00 = ppiVar3;
          }
          local_20 = (int **)*local_20;
        } while (local_20 != ppiVar4);
        local_20 = (int **)local_28[2];
        p_00 = local_20;
      }
      while (local_20 != ppiVar4) {
        local_20 = (int **)*local_20;
      }
      ppiVar4 = (int **)local_28[3];
      while (ppiVar4 != local_20) {
        ppiVar4 = (int **)ppiVar4[1];
      }
      ppiVar4 = (int **)*p_00;
      while (ppiVar1 = ppiVar4, p_00 != local_20) {
        ppiVar1[1] = p_00[1];
        *(int **)p_00[1] = *p_00;
        mem_free(p_00);
        ppiVar4 = (int **)*ppiVar1;
        p_00 = ppiVar1;
      }
      local_28 = (int *)*local_28;
      p = (list_head_elinks *)keybinding_browser.root.child.next;
    } while (local_28 != (int *)0x8138268);
  }
  while (plVar5 = (list_head_elinks *)keybinding_browser.root.child.prev,
        p != &keybinding_browser.root.child) {
    p = (list_head_elinks *)p->next;
  }
  while (plVar5 != &keybinding_browser.root.child) {
    plVar5 = (list_head_elinks *)plVar5->prev;
  }
  p = (list_head_elinks *)keybinding_browser.root.child.next;
  plVar5 = *(list_head_elinks **)keybinding_browser.root.child.next;
  if ((list_head_elinks *)keybinding_browser.root.child.next != &keybinding_browser.root.child) {
    do {
      plVar5->prev = p->prev;
      *(void **)p->prev = p->next;
      mem_free(p);
      bVar6 = plVar5 != &keybinding_browser.root.child;
      p = plVar5;
      plVar5 = (list_head_elinks *)plVar5->next;
    } while (bVar6);
  }
  return;
}



uchar * __regparm3 get_range_string(option_elinks *option_elinks)

{
  string *psVar1;
  uchar *puVar2;
  string info;
  
  psVar1 = init_string(&info);
  puVar2 = (uchar *)0x0;
  if (psVar1 != (string *)0x0) {
    if (option_elinks->type == OPT_BOOL) {
      add_to_string(&info,(uchar *)"[0|1]");
      puVar2 = info.source;
    }
    else {
      puVar2 = info.source;
      if (option_elinks->type + ~OPT_BOOL < 2) {
        add_format_to_string(&info,(uchar *)"[%li..%li]",option_elinks->min,option_elinks->max);
        puVar2 = info.source;
      }
    }
  }
  return puVar2;
}



widget_handler_status_T
push_save_button(dialog_data *dlg_data,widget_data *some_useless_info_button)

{
  write_config(dlg_data->win->term);
  update_hierbox_browser(&option_browser);
  return EVENT_PROCESSED;
}



void add_option_to_tree(void *data,uchar *name)

{
  option_elinks *option_elinks;
  
  option_elinks = get_opt_rec_real(*(option_elinks **)data,name);
  if ((option_elinks != (option_elinks *)0x0) && (*(char *)&option_elinks->flags < '\0')) {
    delete_option(option_elinks);
  }
  option_elinks = get_opt_rec(*(option_elinks **)data,name);
  if (option_elinks != (option_elinks *)0x0) {
    listbox_sel(*(widget_data **)((int)data + 4),option_elinks->box_item);
    return;
  }
  return;
}



widget_handler_status_T check_valid_option(dialog_data *dlg_data,widget_data *widget_data)

{
  terminal *term;
  option_elinks *option_elinks;
  session *ses;
  uchar *p;
  int iVar1;
  int local_24;
  uchar *local_20 [4];
  
  term = dlg_data->win->term;
  option_elinks = (option_elinks *)dlg_data->dlg->udata;
  ses = (session *)dlg_data->dlg->udata2;
  local_20[0] = widget_data->cdata;
  local_24 = 0;
  commandline = 1;
  p = (*option_types[option_elinks->type].read)(option_elinks,local_20,&local_24);
  if (p != (uchar *)0x0) {
    if (option_types[option_elinks->type].set !=
        (anon_subr_int_option_elinks_ptr_uchar_ptr_for_set *)0x0) {
      iVar1 = (*option_types[option_elinks->type].set)(option_elinks,p);
      if (iVar1 != 0) {
        option_changed(ses,option_elinks);
        commandline = 0;
        mem_free(p);
        return EVENT_PROCESSED;
      }
    }
    mem_free(p);
  }
  commandline = 0;
  info_box(term,0,"Error",ALIGN_LEFT,(uchar *)"Bad option value.");
  return EVENT_NOT_PROCESSED;
}



void keybinding_manager(session *ses)

{
  hierbox_browser(&keybinding_browser,ses);
  return;
}



void options_manager(session *ses)

{
  hierbox_browser(&option_browser,ses);
  return;
}



void init_keybinding_listboxes(keymap *keymap_table,action_list *actions)

{
  listbox_item *root;
  listbox_item *plVar1;
  int *data;
  keymap *local_28;
  int local_24;
  int local_20;
  
  local_20 = 0;
  local_24 = 0;
  local_28 = keymap_table;
  do {
    root = add_listbox_item((hierbox_browser *)0x0,&keybinding_browser.root,BI_FOLDER,local_28,-1);
    if (root != (listbox_item *)0x0) {
      data = *(int **)((int)&actions->actions + local_20);
      if (*data != 0) {
        do {
          while (assert_failed == 0) {
            assert_failed = ZEXT14(0x7f < data[1]);
            if (0x7f < data[1]) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
              errline = 0x239;
              elinks_internal((uchar *)"assertion act->num < ACTION_BOX_SIZE failed!");
              if (assert_failed != 0) break;
            }
            if (1 < (uint)data[1]) {
              assert_failed = ZEXT14(data[3] == 0);
              if (data[3] == 0) {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
                errline = 0x241;
                elinks_internal((uchar *)"assertion act->desc failed!");
              }
              plVar1 = add_listbox_item((hierbox_browser *)0x0,root,BI_FOLDER,data,-1);
              if (plVar1 != (listbox_item *)0x0) {
                *(byte *)&plVar1->field_0x18 = *(byte *)&plVar1->field_0x18 | 1;
                action_box_items[data[1] + local_24 * 0x80] = plVar1;
              }
            }
            data = data + 5;
            if (*data == 0) goto LAB_08071171;
          }
          data = data + 5;
          assert_failed = 0;
        } while (*data != 0);
      }
LAB_08071171:
      keymap_box_item[local_24] = root;
    }
    local_20 = local_20 + 8;
    local_24 = local_24 + 1;
    local_28 = local_28 + 1;
    if (local_20 == 0x18) {
      return;
    }
  } while( true );
}



void disable_success_msgbox(void *dummy)

{
  option_value *poVar1;
  option_elinks *option_elinks;
  uchar *in_EDX;
  
  poVar1 = get_opt_(config_options,in_EDX);
  *poVar1 = 0;
  option_elinks = get_opt_rec(config_options,(uchar *)"ui.success_msgbox");
  option_changed((session *)0x0,option_elinks);
  return;
}



void write_config_dialog(terminal *term,uchar *config_file,int secsave_error,int stdio_error)

{
  int *piVar1;
  char *pcVar2;
  uchar *p;
  uchar *str;
  uchar *in_EDX;
  
  if ((stdio_error == 0) && (secsave_error == 0)) {
    piVar1 = get_opt_(config_options,in_EDX);
    if (*piVar1 != 0) {
      str = msg_text(term,(uchar *)"Options were saved successfully to config file %s.",config_file)
      ;
      msg_box(term,(memory_list *)0x0,MSGBOX_FREE_TEXT,(uchar *)"Write config success",ALIGN_CENTER,
              str,(void *)0x0,2,&DAT_081275e4,0,3,"~Do not show anymore",disable_success_msgbox,0);
    }
  }
  else {
    str = secsave_strerror(secsave_error,term);
    if (0 < stdio_error) {
      pcVar2 = strerror(stdio_error);
      p = straconcat(str,&DAT_0812839e,pcVar2,&DAT_0812757c,0);
      if (p != (uchar *)0x0) {
        str = msg_text(term,(uchar *)"Unable to write to config file %s.\n%s",config_file,p);
        info_box(term,MSGBOX_FREE_TEXT,(uchar *)"Write config error",ALIGN_CENTER,str);
        mem_free(p);
        return;
      }
    }
    str = msg_text(term,(uchar *)"Unable to write to config file %s.\n%s",config_file,str);
    info_box(term,MSGBOX_FREE_TEXT,(uchar *)"Write config error",ALIGN_CENTER,str);
  }
  return;
}



uchar * get_option_text(listbox_item *item,terminal *term)

{
  void *pvVar1;
  int cp_index;
  uchar *codeset;
  uchar *msgid;
  uchar *codeset_00;
  
  pvVar1 = item->udata;
  msgid = *(uchar **)((int)pvVar1 + 0x28);
  if (msgid == (uchar *)0x0) {
    msgid = *(uchar **)((int)pvVar1 + 0xc);
  }
  if ((*(byte *)((int)pvVar1 + 0x10) & 8) != 0) {
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext("modified");
    if ((msgid != (uchar *)0x0) && (*msgid != '\0')) {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      msgid = gettext(msgid);
    }
    msgid = straconcat(msgid,&DAT_0812839e,codeset,&DAT_0812757c,0);
    return msgid;
  }
  if ((msgid != (uchar *)0x0) && (*msgid != '\0')) {
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    msgid = gettext(msgid);
  }
  msgid = stracpy(msgid);
  return msgid;
}



widget_handler_status_T
push_edit_button(dialog_data *dlg_data,widget_data *some_useless_info_button)

{
  terminal *term;
  option_elinks *option_elinks;
  option_type oVar1;
  void *pvVar2;
  listbox_data *plVar3;
  string *psVar4;
  dialog *dlg;
  int cp_index;
  uchar *codeset;
  uchar *local_6c;
  uchar *codeset_00;
  memory_list *ml;
  bool bVar5;
  undefined4 local_68;
  undefined4 local_60;
  uchar *local_3c;
  uchar *local_30;
  string tvalue;
  
  term = dlg_data->win->term;
  plVar3 = get_listbox_widget_data(dlg_data->widgets_data);
  if ((plVar3->sel != (listbox_item *)0x0) &&
     (option_elinks = (option_elinks *)plVar3->sel->udata, option_elinks != (option_elinks *)0x0)) {
    oVar1 = option_elinks->type;
    if ((option_types[oVar1].write == (anon_subr_void_option_elinks_ptr_string_ptr_for_write *)0x0)
       || ((option_types[oVar1].read ==
            (anon_subr_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_int_ptr_for_read *)0x0 ||
           (option_types[oVar1].set == (anon_subr_int_option_elinks_ptr_uchar_ptr_for_set *)0x0))))
    {
      info_box(term,0,"Edit",ALIGN_LEFT,
               (uchar *)
               "This option cannot be edited. This means that this is some special option like a folder - try to press a space in order to see its contents."
              );
      return EVENT_PROCESSED;
    }
    pvVar2 = dlg_data->dlg->udata;
    psVar4 = init_string(&tvalue);
    if (psVar4 != (string *)0x0) {
      commandline = 1;
      (*option_types[option_elinks->type].write)(option_elinks,&tvalue);
      commandline = 0;
      dlg = (dialog *)mem_calloc(1,0x514);
      if (dlg == (dialog *)0x0) {
        done_string(&tvalue);
      }
      else {
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        codeset = gettext("Edit");
        dlg->title = codeset;
        dlg->layouter = generic_dialog_layouter;
        *(option_elinks **)&dlg->udata = option_elinks;
        dlg->udata2 = pvVar2;
        safe_strncpy((uchar *)&dlg[3].abort,tvalue.source,0x400);
        done_string(&tvalue);
        local_30 = option_types[option_elinks->type].name;
        if ((local_30 != (uchar *)0x0) && (*local_30 != '\0')) {
          if ((term != (terminal *)0x0) &&
             (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
            codeset = get_cp_mime_name(cp_index);
            bind_textdomain_codeset("elinks",codeset);
            current_charset = cp_index;
          }
          local_30 = gettext(local_30);
        }
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        local_6c = gettext("Type");
        codeset = option_elinks->name;
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset_00 = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset_00);
          current_charset = cp_index;
        }
        codeset_00 = gettext("Name");
        local_60 = 0;
        local_68 = 0x8132e94;
        local_3c = straconcat(codeset_00,0x8132e94,codeset,&DAT_08131ec3,local_6c,0x8132e94,local_30
                              ,0);
        codeset = option_elinks->desc;
        if (codeset == (uchar *)0x0) {
          codeset = "N/A";
        }
        if (*codeset != '\0') {
          if ((term != (terminal *)0x0) &&
             (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
            codeset_00 = get_cp_mime_name(cp_index);
            bind_textdomain_codeset("elinks",codeset_00);
            current_charset = cp_index;
          }
          codeset = gettext(codeset);
        }
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset_00 = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset_00);
          current_charset = cp_index;
        }
        codeset_00 = gettext((uchar *)"Description");
        codeset = straconcat(codeset_00,&DAT_081283c0,codeset,0,local_6c,local_68,local_30,local_60)
        ;
        local_6c = get_range_string(option_elinks);
        local_30 = local_3c;
        if (local_6c != (uchar *)0x0) {
          if ((*local_6c != '\0') &&
             (codeset_00 = straconcat(local_3c,&DAT_08134f9c,local_6c,0), codeset_00 != (uchar *)0x0
             )) {
            mem_free(local_3c);
            local_3c = codeset_00;
          }
          mem_free(local_6c);
          local_30 = local_3c;
        }
        if (local_30 == (uchar *)0x0) {
          if (codeset != (uchar *)0x0) {
            mem_free(codeset);
          }
        }
        else {
          if (codeset != (uchar *)0x0) {
            add_dlg_text(dlg,local_30,ALIGN_LEFT,0);
            if ((term != (terminal *)0x0) &&
               (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
              local_6c = get_cp_mime_name(cp_index);
              bind_textdomain_codeset("elinks",local_6c);
              current_charset = cp_index;
            }
            local_6c = gettext((uchar *)"Value");
            add_dlg_field_do(dlg,WIDGET_FIELD,local_6c,0,0,check_valid_option,0x400,&dlg[3].abort,
                             (input_history *)0x0,INPFIELD_FLOAT);
            add_dlg_text(dlg,codeset,ALIGN_LEFT,0);
            if ((term != (terminal *)0x0) &&
               (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
              local_6c = get_cp_mime_name(cp_index);
              bind_textdomain_codeset("elinks",local_6c);
              current_charset = cp_index;
            }
            local_6c = gettext("~OK");
            add_dlg_button_do(dlg,local_6c,1,ok_dialog,(void *)0x0,(done_handler_T *)0x0,(void *)0x0
                             );
            if ((term != (terminal *)0x0) &&
               (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
              local_6c = get_cp_mime_name(cp_index);
              bind_textdomain_codeset("elinks",local_6c);
              current_charset = cp_index;
            }
            local_6c = gettext((uchar *)"~Cancel");
            add_dlg_button_do(dlg,local_6c,2,cancel_dialog,(void *)0x0,(done_handler_T *)0x0,
                              (void *)0x0);
            if ((assert_failed == 0) &&
               (bVar5 = dlg->number_of_widgets != 5, assert_failed = ZEXT14(bVar5), bVar5)) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
              errline = 0x170;
              elinks_internal((uchar *)"assertion 5 == (dlg)->number_of_widgets failed!");
            }
            ml = getml(dlg,local_30,codeset,0);
            do_dialog(term,dlg,ml);
            return EVENT_PROCESSED;
          }
          mem_free(local_30);
        }
        mem_free(dlg);
      }
    }
  }
  return EVENT_PROCESSED;
}



uchar * get_keybinding_text(listbox_item *item,terminal *term)

{
  uchar **ppuVar1;
  uchar *msgid;
  int cp_index;
  uchar *codeset;
  string *psVar2;
  string info;
  
  ppuVar1 = (uchar **)item->udata;
  if (item->depth == 0) {
    if (keybinding_text_toggle != 0) {
LAB_08071c75:
      msgid = *ppuVar1;
      goto LAB_08071c77;
    }
    msgid = ppuVar1[2];
  }
  else {
    if (1 < item->depth) {
      psVar2 = init_string(&info);
      if (psVar2 == (string *)0x0) {
        return (uchar *)0x0;
      }
      add_keystroke_to_string(&info,(term_event_keyboard *)(ppuVar1 + 5),0);
      return info.source;
    }
    if (keybinding_text_toggle != 0) goto LAB_08071c75;
    msgid = ppuVar1[3];
  }
  if ((msgid != (uchar *)0x0) && (*msgid != '\0')) {
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    msgid = gettext(msgid);
  }
LAB_08071c77:
  msgid = stracpy(msgid);
  return msgid;
}



listbox_match match_option(listbox_item *item,terminal *term,uchar *text)

{
  void *pvVar1;
  listbox_match lVar2;
  char *pcVar3;
  int cp_index;
  uchar *codeset;
  uchar *msgid;
  
  pvVar1 = item->udata;
  lVar2 = LISTBOX_MATCH_IMPOSSIBLE;
  if (*(int *)((int)pvVar1 + 0x14) != 9) {
    pcVar3 = strcasestr(*(char **)((int)pvVar1 + 0xc),(char *)text);
    lVar2 = LISTBOX_MATCH_OK;
    if (pcVar3 == (char *)0x0) {
      msgid = *(uchar **)((int)pvVar1 + 0x28);
      lVar2 = LISTBOX_MATCH_NO;
      if (msgid != (uchar *)0x0) {
        if (*msgid != '\0') {
          if (term != (terminal *)0x0) {
            cp_index = get_terminal_codepage(term);
            if (cp_index != current_charset) {
              codeset = get_cp_mime_name(cp_index);
              bind_textdomain_codeset("elinks",codeset);
              current_charset = cp_index;
            }
          }
          msgid = gettext(msgid);
        }
        pcVar3 = strcasestr((char *)msgid,(char *)text);
        lVar2 = (listbox_match)(pcVar3 == (char *)0x0);
      }
    }
  }
  return lVar2;
}



listbox_match match_keybinding(listbox_item *item,terminal *term,uchar *text)

{
  char *pcVar1;
  int cp_index;
  uchar *codeset;
  uchar *msgid;
  
  if (item->depth != 1) {
    return LISTBOX_MATCH_IMPOSSIBLE;
  }
  if (keybinding_text_toggle == 0) {
    msgid = *(uchar **)(item->udata + 3);
    if (msgid == (uchar *)0x0) {
      return LISTBOX_MATCH_NO;
    }
    if (*msgid != '\0') {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      msgid = gettext(msgid);
    }
  }
  else {
    msgid = *(uchar **)item->udata;
  }
  if (msgid == (uchar *)0x0) {
    return LISTBOX_MATCH_NO;
  }
  pcVar1 = strcasestr((char *)msgid,(char *)text);
  return (uint)(pcVar1 == (char *)0x0);
}



uchar * get_option_info(listbox_item *item,terminal *term)

{
  option_elinks *option_elinks;
  string *psVar1;
  int cp_index;
  uchar *codeset;
  uchar *codeset_00;
  option_type oVar2;
  uchar *local_30;
  string value;
  string info;
  
  option_elinks = (option_elinks *)item->udata;
  psVar1 = init_string(&info);
  codeset_00 = (uchar *)0x0;
  if (psVar1 != (string *)0x0) {
    codeset_00 = option_elinks->name;
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext("Name");
    add_format_to_string(&info,"%s: %s",codeset,codeset_00);
    oVar2 = option_elinks->type;
    local_30 = option_types[oVar2].name;
    if ((local_30 != (uchar *)0x0) && (*local_30 != '\0')) {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      local_30 = gettext(local_30);
      oVar2 = option_elinks->type;
    }
    if (oVar2 == OPT_TREE) {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      codeset_00 = gettext((uchar *)"(expand by pressing space)");
      local_30 = straconcat(local_30,&DAT_08134f9c,codeset_00,0);
    }
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset_00 = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset_00);
      current_charset = cp_index;
    }
    codeset_00 = gettext("Type");
    add_format_to_string(&info,(uchar *)"\n%s: %s",codeset_00,local_30);
    oVar2 = option_elinks->type;
    if (oVar2 == OPT_TREE) {
      mem_free(local_30);
      oVar2 = option_elinks->type;
    }
    if (option_types[oVar2].write != (anon_subr_void_option_elinks_ptr_string_ptr_for_write *)0x0) {
      psVar1 = init_string(&value);
      if (psVar1 == (string *)0x0) {
        done_string(&info);
        return (uchar *)0x0;
      }
      (*option_types[option_elinks->type].write)(option_elinks,&value);
      codeset_00 = get_range_string(option_elinks);
      if (codeset_00 != (uchar *)0x0) {
        if (*codeset_00 != '\0') {
          add_to_string(&info," ");
          add_to_string(&info,codeset_00);
        }
        mem_free(codeset_00);
      }
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      codeset_00 = gettext((uchar *)"Value");
      add_format_to_string(&info,(uchar *)"\n%s: %s",codeset_00,value.source);
      done_string(&value);
      if ((*(byte *)&option_elinks->flags & 8) != 0) {
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset_00 = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset_00);
          current_charset = cp_index;
        }
        codeset_00 = gettext((uchar *)
                             "\n\nThis value has been changed since you last saved your configuration."
                            );
        add_to_string(&info,codeset_00);
      }
    }
    codeset = option_elinks->desc;
    if (codeset == (uchar *)0x0) {
      codeset = "N/A";
    }
    codeset_00 = info.source;
    if (*codeset != '\0') {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      codeset = gettext(codeset);
      codeset_00 = info.source;
      if (*codeset != '\0') {
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset_00 = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset_00);
          current_charset = cp_index;
        }
        codeset_00 = gettext((uchar *)"Description");
        add_format_to_string(&info,(uchar *)"\n\n%s:\n%s",codeset_00,codeset);
        codeset_00 = info.source;
      }
    }
  }
  return codeset_00;
}



void done_home(void)

{
  if (elinks_home != (uchar *)0x0) {
    mem_free(elinks_home);
  }
  return;
}



uchar * __regparm3 test_confdir(uchar *home,uchar *path,uchar *error_message)

{
  uchar *puVar1;
  uchar *p;
  size_t sVar2;
  uchar *fmt;
  int iVar3;
  stat st;
  
  if ((path == (uchar *)0x0) || (*path == '\0')) {
    fmt = (uchar *)0x0;
  }
  else {
    if (((home == (uchar *)0x0) || (*home == '\0')) || (*path == '/')) {
      p = stracpy(path);
    }
    else {
      p = straconcat(home,&DAT_08132419,path,0);
    }
    fmt = p;
    if (p != (uchar *)0x0) {
      sVar2 = strlen((char *)p);
      iVar3 = sVar2 - 1;
      if ((0 < iVar3) && (p[sVar2 - 1] == '/')) {
        fmt = p + sVar2;
        do {
          iVar3 = iVar3 + -1;
          if (iVar3 == 0) {
            iVar3 = 0;
            break;
          }
          puVar1 = fmt + -2;
          fmt = fmt + -1;
        } while (*puVar1 == '/');
      }
      p[iVar3 + 1] = '\0';
      iVar3 = __xstat64(3,(char *)p,(stat64 *)&st);
      if (iVar3 == 0) {
        if ((st.st_mode & 0xf000) == 0x4000) {
          first_use = 0;
          return p;
        }
      }
      else {
        iVar3 = mkdir((char *)p,0x1c0);
        if (iVar3 == 0) {
          return p;
        }
      }
      if (error_message != (uchar *)0x0) {
        fmt = gettext(error_message);
        usrerror(fmt,path,p);
        sleep(3);
      }
      fmt = (uchar *)0x0;
      mem_free(p);
    }
  }
  return fmt;
}



void init_home(void)

{
  uchar *puVar1;
  uchar *src;
  size_t sVar2;
  uchar *puVar3;
  uchar **ppuVar4;
  uchar *extraout_EDX;
  uchar *extraout_EDX_00;
  uchar *name;
  uchar *extraout_EDX_01;
  int iVar5;
  uchar *puVar6;
  uchar *local_10;
  
  first_use = 1;
  src = (uchar *)getenv("HOME");
  name = extraout_EDX;
  if ((src == (uchar *)0x0) || (src = stracpy(src), name = extraout_EDX_00, src == (uchar *)0x0)) {
    if ((program.path != (uchar *)0x0) &&
       (src = stracpy(program.path), name = extraout_EDX_01, src != (uchar *)0x0)) {
      sVar2 = strlen((char *)src);
      iVar5 = sVar2 - 1;
      if ((-1 < iVar5) && (src[sVar2 - 1] != '/')) {
        name = src + sVar2;
        do {
          iVar5 = iVar5 + -1;
          if (iVar5 == -1) {
            iVar5 = -1;
            break;
          }
          puVar6 = name + -2;
          name = name + -1;
        } while (*puVar6 != '/');
      }
      src[iVar5 + 1] = '\0';
      goto LAB_08072558;
    }
    src = (uchar *)0x0;
  }
  else {
LAB_08072558:
    sVar2 = strlen((char *)src);
    name = (uchar *)(sVar2 - 1);
    puVar6 = name;
    if ((0 < (int)name) && (src[sVar2 - 1] == '/')) {
      puVar3 = src + sVar2;
      do {
        name = name + -1;
        if (name == (uchar *)0x0) {
          puVar6 = (uchar *)0x0;
          break;
        }
        puVar1 = puVar3 + -2;
        puVar3 = puVar3 + -1;
        puVar6 = name;
      } while (*puVar1 == '/');
    }
    (puVar6 + 1)[(int)src] = '\0';
  }
  ppuVar4 = (uchar **)get_opt_(cmdline_options,name);
  local_10 = test_confdir(src,*ppuVar4,
                          (uchar *)
                          "Commandline options -config-dir set to %s, but could not create directory %s."
                         );
  if (local_10 == (uchar *)0x0) {
    name = (uchar *)getenv("ELINKS_CONFDIR");
    local_10 = test_confdir(src,name,(uchar *)
                                     "ELINKS_CONFDIR set to %s, but could not create directory %s.")
    ;
    if (((local_10 == (uchar *)0x0) &&
        (local_10 = test_confdir(src,(uchar *)".elinks",(uchar *)0x0), local_10 == (uchar *)0x0)) &&
       (local_10 = test_confdir(src,"elinks",(uchar *)0x0), local_10 == (uchar *)0x0))
    goto LAB_080725d3;
  }
  add_to_strn(&local_10,"/");
LAB_080725d3:
  if (src != (uchar *)0x0) {
    mem_free(src);
  }
  elinks_home = local_10;
  if (local_10 == (uchar *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/home.c";
    errline = 0x9c;
    name = gettext((uchar *)
                   "Unable to find or create ELinks config directory. Please check if you have $HOME variable set correctly and if you have write permission to your home directory."
                  );
    elinks_error(name);
    sleep(3);
    return;
  }
  return;
}



int keybinding_exists(keymap_id keymap_id,term_event_keyboard *kbd,action_id_T *action_id)

{
  list_head_elinks *plVar1;
  
  plVar1 = (list_head_elinks *)keymaps[keymap_id].next;
  if (plVar1 != keymaps + keymap_id) {
    do {
      if (((void *)kbd->key == plVar1[2].prev) && (plVar1[3].next == (void *)kbd->modifier)) {
        if (action_id != (action_id_T *)0x0) {
          *(void **)action_id = plVar1[2].next;
        }
        return 1;
      }
      plVar1 = (list_head_elinks *)plVar1->next;
    } while (plVar1 != keymaps + keymap_id);
  }
  return 0;
}



action_id_T kbd_action(keymap_id keymap_id,term_event *ev,int *event)

{
  list_head_elinks *plVar1;
  
  if (ev->ev == EVENT_KBD) {
    plVar1 = (list_head_elinks *)keymaps[keymap_id].next;
    if (plVar1 != keymaps + keymap_id) {
      do {
        if ((plVar1[2].prev == *(void **)&ev->info) &&
           (plVar1[3].next == *(void **)((int)&ev->info + 4))) {
          if ((event != (int *)0x0) && (plVar1[2].next == (void *)0x1)) {
            *(void **)event = plVar1[3].prev;
          }
          return (action_id_T)plVar1[2].next;
        }
        plVar1 = (list_head_elinks *)plVar1->next;
      } while (plVar1 != keymaps + keymap_id);
    }
  }
  return -1;
}



keybinding * kbd_ev_lookup(keymap_id keymap_id,term_event_keyboard *kbd,int *event)

{
  keybinding *pkVar1;
  
  pkVar1 = (keybinding *)keymaps[keymap_id].next;
  if (pkVar1 != (keybinding *)(keymaps + keymap_id)) {
    do {
      if ((kbd->key == (pkVar1->kbd).key) && ((pkVar1->kbd).modifier == kbd->modifier)) {
        if (event == (int *)0x0) {
          return pkVar1;
        }
        if ((void *)pkVar1->action_id != (void *)0x1) {
          return pkVar1;
        }
        *(void **)event = (void *)pkVar1->event;
        return pkVar1;
      }
      pkVar1 = pkVar1->next;
    } while (pkVar1 != (keybinding *)(keymaps + keymap_id));
  }
  return (keybinding *)0x0;
}



void free_keymaps(module *xxx)

{
  list_head_elinks *plVar1;
  list_head_elinks *plVar2;
  list_head_elinks *p;
  list_head_elinks *plVar3;
  int local_20;
  
  plVar3 = keymaps;
  done_keybinding_listboxes();
  local_20 = 0;
  do {
    p = (list_head_elinks *)keymaps[local_20].next;
    plVar1 = p;
    while (plVar1 != plVar3) {
      plVar1 = (list_head_elinks *)plVar1->next;
    }
    plVar1 = (list_head_elinks *)keymaps[local_20].prev;
    while (plVar1 != plVar3) {
      plVar1 = (list_head_elinks *)plVar1->prev;
    }
    plVar1 = (list_head_elinks *)p->next;
    while (plVar2 = plVar1, p != plVar3) {
      plVar2->prev = p->prev;
      *(void **)p->prev = p->next;
      mem_free(p);
      plVar1 = (list_head_elinks *)plVar2->next;
      p = plVar2;
    }
    plVar3 = plVar3 + 1;
    local_20 = local_20 + 1;
  } while (plVar3 != (list_head_elinks *)&no_autocreate);
  return;
}



uchar * get_keymap_name(keymap_id keymap_id)

{
  if ((assert_failed == 0) && (assert_failed = ZEXT14(2U < (uint)keymap_id), 2U < (uint)keymap_id))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/kbdbind.c";
    errline = 0x12a;
    elinks_internal((uchar *)"assertion keymap_id >= 0 && keymap_id < KEYMAP_MAX failed!");
    return keymap_table[keymap_id].str;
  }
  return keymap_table[keymap_id].str;
}



action * get_action(keymap_id keymap_id,action_id_T action_id)

{
  if ((assert_failed == 0) && (assert_failed = ZEXT14(2U < (uint)keymap_id), 2U < (uint)keymap_id))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/kbdbind.c";
    errline = 0x10d;
    elinks_internal((uchar *)"assertion keymap_id >= 0 && keymap_id < KEYMAP_MAX failed!");
  }
  if ((-1 < action_id) && (action_id < action_table[keymap_id].num_actions)) {
    return action_table[keymap_id].actions + action_id;
  }
  return (action *)0x0;
}



uchar * get_action_name(keymap_id keymap_id,action_id_T action_id)

{
  action *paVar1;
  uchar *puVar2;
  
  paVar1 = get_action(keymap_id,action_id);
  puVar2 = (uchar *)0x0;
  if (paVar1 != (action *)0x0) {
    puVar2 = paVar1->str;
  }
  return puVar2;
}



action_id_T get_action_from_string(keymap_id keymap_id,uchar *str)

{
  uchar *__s1;
  int iVar1;
  action *paVar2;
  
  if ((assert_failed == 0) && (assert_failed = ZEXT14(2U < (uint)keymap_id), 2U < (uint)keymap_id))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/kbdbind.c";
    errline = 0x101;
    elinks_internal((uchar *)"assertion keymap_id >= 0 && keymap_id < KEYMAP_MAX failed!");
  }
  paVar2 = action_table[keymap_id].actions;
  __s1 = paVar2->str;
  while( true ) {
    if (__s1 == (uchar *)0x0) {
      return -1;
    }
    iVar1 = strcmp((char *)__s1,(char *)str);
    if (iVar1 == 0) break;
    paVar2 = paVar2 + 1;
    __s1 = paVar2->str;
  }
  return paVar2->num;
}



keybinding * kbd_nm_lookup(keymap_id keymap_id,uchar *name)

{
  keybinding *pkVar1;
  void *pvVar2;
  
  pvVar2 = (void *)get_action_from_string(keymap_id,name);
  if (-1 < (int)pvVar2) {
    pkVar1 = (keybinding *)keymaps[keymap_id].next;
    while (pkVar1 != (keybinding *)(keymaps + keymap_id)) {
      if (pvVar2 == (void *)pkVar1->action_id) {
        return pkVar1;
      }
      pkVar1 = pkVar1->next;
    }
  }
  return (keybinding *)0x0;
}



// WARNING: Removing unreachable block (ram,0x08072bf0)
// WARNING: Could not reconcile some variable overlaps

void add_keystroke_to_string(string *str,term_event_keyboard *kbd,int escape)

{
  int __c;
  named_key *pnVar1;
  term_event_modifier_T tVar2;
  named_key *pnVar3;
  char *pcVar4;
  char *source;
  uchar key_buffer [3];
  
  key_buffer._0_2_ = 0x785c;
  key_buffer[2] = '\0';
  if (kbd->key != -1) {
    tVar2 = kbd->modifier;
    if ((tVar2 & KBD_MOD_SHIFT) != KBD_MOD_NONE) {
      add_to_string(str,(uchar *)"Shift-");
      tVar2 = kbd->modifier;
    }
    if ((tVar2 & KBD_MOD_CTRL) != KBD_MOD_NONE) {
      add_to_string(str,(uchar *)"Ctrl-");
      tVar2 = kbd->modifier;
    }
    if ((tVar2 & KBD_MOD_ALT) != KBD_MOD_NONE) {
      add_to_string(str,"Alt-");
    }
    source = "Enter";
    __c = kbd->key;
    pnVar3 = key_table;
    if (__c != -0x100) {
      do {
        source = (char *)pnVar3[1].str;
        if ((uchar *)source == (uchar *)0x0) {
          key_buffer._0_2_ = key_buffer._0_2_ & 0xff | (ushort)(byte)__c << 8;
          source = (char *)(key_buffer + 1);
          if (escape != 0) {
            pcVar4 = strchr("\'\"\\",__c);
            source = (char *)key_buffer;
            if (pcVar4 == (char *)0x0) {
              source = (char *)(key_buffer + 1);
            }
          }
          break;
        }
        pnVar1 = pnVar3 + 1;
        pnVar3 = pnVar3 + 1;
      } while (pnVar1->num != __c);
    }
    add_to_string(str,(uchar *)source);
  }
  return;
}



void bind_config_string(string *file)

{
  uchar *source;
  uchar *source_00;
  list_head_elinks *plVar1;
  list_head_elinks *plVar2;
  keymap_id keymap_id;
  
  keymap_id = KEYMAP_MAIN;
  plVar2 = keymaps;
  do {
    plVar1 = (list_head_elinks *)keymaps[keymap_id].next;
joined_r0x08072c19:
    if (plVar1 != plVar2) {
      do {
        if ((*(byte *)&plVar1[4].next & 8) == 0) {
          source = get_keymap_name(keymap_id);
          source_00 = get_action_name(keymap_id,(action_id_T)plVar1[2].next);
          if (((source_00 != (uchar *)0x0) && (source != (uchar *)0x0)) && (*source_00 != ' ')) {
            if (((uint)plVar1[4].next & 1) != 0) goto code_r0x08072c65;
            add_to_string(file,(uchar *)"bind \"");
            add_to_string(file,source);
            add_to_string(file,"\" \"");
            add_keystroke_to_string(file,(term_event_keyboard *)&plVar1[2].prev,1);
            add_to_string(file,(uchar *)"\" = \"");
            add_to_string(file,source_00);
            add_char_to_string(file,'\"');
            add_char_to_string(file,'\n');
          }
        }
        plVar1 = (list_head_elinks *)plVar1->next;
        if (plVar1 == plVar2) break;
      } while( true );
    }
    plVar2 = plVar2 + 1;
    keymap_id = keymap_id + KEYMAP_EDIT;
    if (plVar2 == (list_head_elinks *)&no_autocreate) {
      return;
    }
  } while( true );
code_r0x08072c65:
  plVar1[4].next = (void *)((uint)plVar1[4].next & 0xfffffffe);
  plVar1 = (list_head_elinks *)plVar1->next;
  goto joined_r0x08072c19;
}



void add_keystroke_action_to_string(string *string,action_id_T action_id,keymap_id keymap_id)

{
  list_head_elinks *plVar1;
  
  plVar1 = (list_head_elinks *)keymaps[keymap_id].next;
  while( true ) {
    if (plVar1 == keymaps + keymap_id) {
      return;
    }
    if ((void *)action_id == plVar1[2].next) break;
    plVar1 = (list_head_elinks *)plVar1->next;
  }
  add_keystroke_to_string(string,(term_event_keyboard *)&plVar1[2].prev,0);
  return;
}



uchar * get_keystroke(action_id_T action_id,keymap_id keymap_id)

{
  string *psVar1;
  uchar *puVar2;
  string keystroke;
  
  psVar1 = init_string(&keystroke);
  puVar2 = (uchar *)0x0;
  if ((psVar1 != (string *)0x0) &&
     (add_keystroke_action_to_string(&keystroke,action_id,keymap_id), puVar2 = keystroke.source,
     keystroke.length == 0)) {
    done_string(&keystroke);
    puVar2 = keystroke.source;
  }
  return puVar2;
}



// WARNING: Removing unreachable block (ram,0x08072e2e)

term_event_key_T read_key(uchar *key_str)

{
  uint uVar1;
  char *s1;
  int iVar2;
  named_key *pnVar3;
  
  if ((*key_str == 0) || (uVar1 = (uint)*key_str, key_str[1] != '\0')) {
    s1 = "Enter";
    pnVar3 = key_table;
    do {
      iVar2 = c_strcasecmp(s1,(char *)key_str);
      if (iVar2 == 0) {
        return pnVar3->num;
      }
      pnVar3 = pnVar3 + 1;
      s1 = (char *)pnVar3->str;
    } while ((uchar *)s1 != (uchar *)0x0);
    uVar1 = 0xffffffff;
  }
  return uVar1;
}



int parse_keystroke(uchar *s,term_event_keyboard *kbd)

{
  int c;
  
  kbd->modifier = KBD_MOD_NONE;
  while( true ) {
    while( true ) {
      while ((c = c_strncasecmp((char *)s,"Shift",5), c == 0 && ((s[5] == '+' || (s[5] == '-'))))) {
        kbd->modifier = kbd->modifier | KBD_MOD_SHIFT;
        s = s + 6;
      }
      c = c_strncasecmp((char *)s,"Ctrl",4);
      if ((c != 0) || ((s[4] != '+' && (s[4] != '-')))) break;
      kbd->modifier = kbd->modifier | KBD_MOD_CTRL;
      s = s + 5;
    }
    c = c_strncasecmp((char *)s,"Alt",3);
    if ((c != 0) || ((s[3] != '+' && (s[3] != '-')))) break;
    kbd->modifier = kbd->modifier | KBD_MOD_ALT;
    s = s + 4;
  }
  c = read_key(s);
  kbd->key = c;
  if (((*(byte *)&kbd->modifier & 2) != 0) && (-1 < c)) {
    if (0x7f < c) {
      return 0;
    }
    c = c_toupper(c);
    kbd->key = c;
  }
  if (c != -1) {
    return 0;
  }
  return -1;
}



uchar * bind_act(uchar *keymap_str,uchar *keystroke_str)

{
  list_head_elinks *plVar1;
  int iVar2;
  uchar *puVar3;
  keymap_id keymap_id;
  int iVar4;
  term_event_keyboard kbd;
  
  iVar4 = 0;
  keymap_id = KEYMAP_MAIN;
  while (iVar2 = strcmp((char *)keymap_table[keymap_id].str,(char *)keymap_str), iVar2 != 0) {
    iVar4 = iVar4 + 1;
    keymap_id = keymap_id + KEYMAP_EDIT;
    if (iVar4 == 3) {
      return (uchar *)0x0;
    }
  }
  iVar4 = parse_keystroke(keystroke_str,&kbd);
  if (iVar4 < 0) {
    return (uchar *)0x0;
  }
  plVar1 = (list_head_elinks *)keymaps[keymap_id].next;
  while( true ) {
    if (plVar1 == keymaps + keymap_id) {
      return (uchar *)0x0;
    }
    if (((void *)kbd.key == plVar1[2].prev) && (plVar1[3].next == (void *)kbd.modifier)) break;
    plVar1 = (list_head_elinks *)plVar1->next;
  }
  puVar3 = get_action_name(keymap_id,(action_id_T)plVar1[2].next);
  if (puVar3 == (uchar *)0x0) {
    return (uchar *)0x0;
  }
  plVar1[4].next = (void *)((uint)plVar1[4].next | 1);
  puVar3 = straconcat("\"",puVar3,&DAT_08128449,0);
  return puVar3;
}



uchar * get_action_name_from_keystroke(keymap_id keymap_id,uchar *keystroke_str)

{
  list_head_elinks *plVar1;
  int iVar2;
  action *paVar3;
  term_event_keyboard kbd;
  
  iVar2 = parse_keystroke(keystroke_str,&kbd);
  if (-1 < iVar2) {
    plVar1 = (list_head_elinks *)keymaps[keymap_id].next;
    while (plVar1 != keymaps + keymap_id) {
      if ((plVar1[2].prev == (void *)kbd.key) && (plVar1[3].next == (void *)kbd.modifier)) {
        paVar3 = get_action(keymap_id,(action_id_T)plVar1[2].next);
        if (paVar3 == (action *)0x0) {
          return (uchar *)0x0;
        }
        return paVar3->str;
      }
      plVar1 = (list_head_elinks *)plVar1->next;
    }
  }
  return (uchar *)0x0;
}



void free_keybinding(keybinding *keybinding)

{
  if (keybinding->box_item != (listbox_item *)0x0) {
    done_listbox_item(&keybinding_browser,keybinding->box_item);
    keybinding->box_item = (listbox_item *)0x0;
  }
  if ((keybinding->flags & KBDB_DEFAULT_KEY) != 0) {
    keybinding->flags = keybinding->flags & ~KBDB_DEFAULT_BINDING;
    keybinding->action_id = 0;
    return;
  }
  keybinding->next->prev = keybinding->prev;
  keybinding->prev->next = keybinding->next;
  mem_free(keybinding);
  return;
}



keybinding *
add_keybinding(keymap_id keymap_id,action_id_T action_id,term_event_keyboard *kbd,int event)

{
  keybinding *pkVar1;
  term_event_modifier_T tVar2;
  keybinding *keybinding;
  default_kb *pdVar3;
  listbox_item *root;
  int iVar4;
  default_kb *pdVar5;
  uint uVar6;
  default_kb *pdVar7;
  bool bVar8;
  byte bVar9;
  default_kb default_keybinding;
  
  bVar9 = 0;
  keybinding = (keybinding *)keymaps[keymap_id].next;
  pkVar1 = (keybinding *)(keymaps + keymap_id);
  if (keybinding != pkVar1) {
    do {
      if (((keybinding->kbd).key == kbd->key) && ((keybinding->kbd).modifier == kbd->modifier)) {
        iVar4 = 1;
        if ((keybinding->flags & KBDB_DEFAULT_KEY) != 0) {
          iVar4 = 2;
          keybinding->flags = keybinding->flags & ~KBDB_DEFAULT_KEY;
        }
        free_keybinding(keybinding);
        uVar6 = (uint)(iVar4 == 2);
        goto LAB_08073188;
      }
      keybinding = keybinding->next;
    } while (keybinding != pkVar1);
  }
  uVar6 = 0;
LAB_08073188:
  keybinding = (keybinding *)mem_calloc(1,0x28);
  if (keybinding != (keybinding *)0x0) {
    keybinding->keymap_id = keymap_id;
    keybinding->action_id = action_id;
    tVar2 = kbd->modifier;
    (keybinding->kbd).key = kbd->key;
    default_keybinding.kbd.key = (keybinding->kbd).key;
    (keybinding->kbd).modifier = tVar2;
    keybinding->flags = uVar6 << 2;
    keybinding->event = event;
    default_keybinding.kbd.modifier = (keybinding->kbd).modifier;
    default_keybinding.action_id = action_id;
    pdVar3 = default_keybindings[keybinding->keymap_id];
    bVar8 = (pdVar3->kbd).key == 0;
    if (!bVar8) {
      do {
        iVar4 = 0xc;
        pdVar5 = &default_keybinding;
        pdVar7 = pdVar3;
        do {
          if (iVar4 == 0) break;
          iVar4 = iVar4 + -1;
          bVar8 = *(char *)&(pdVar5->kbd).key == *(char *)&(pdVar7->kbd).key;
          pdVar5 = (default_kb *)((int)pdVar5 + (uint)bVar9 * -2 + 1);
          pdVar7 = (default_kb *)((int)pdVar7 + (uint)bVar9 * -2 + 1);
        } while (bVar8);
        if (bVar8) {
          keybinding->flags = keybinding->flags | KBDB_DEFAULT_BINDING;
          break;
        }
        pdVar3 = pdVar3 + 1;
        bVar8 = (pdVar3->kbd).key == 0;
      } while (!bVar8);
    }
    keybinding->next = (keybinding *)keymaps[keymap_id].next;
    keybinding->prev = pkVar1;
    *(keybinding **)&keymaps[keymap_id].next = keybinding;
    keybinding->next->prev = keybinding;
    if ((action_id == 0) ||
       (root = get_keybinding_action_box_item(keymap_id,action_id), root == (listbox_item *)0x0)) {
      return (keybinding *)0x0;
    }
    root = add_listbox_item(&keybinding_browser,root,BI_LEAF,keybinding,1);
    keybinding->box_item = root;
  }
  return keybinding;
}



void init_keymaps(module *xxx)

{
  int iVar1;
  default_kb *kbd;
  keybinding *pkVar2;
  keymap_id keymap_id;
  int iVar3;
  
  iVar3 = 0;
  keymap_id = KEYMAP_MAIN;
  keymaps[0].prev = keymaps;
  keymaps[0].next = keymaps;
  keymaps[1].prev = keymaps + 1;
  keymaps[1].next = keymaps + 1;
  keymaps[2].prev = keymaps + 2;
  keymaps[2].next = keymaps + 2;
  init_keybinding_listboxes(keymap_table,action_table);
  do {
    iVar1 = (default_keybindings[keymap_id]->kbd).key;
    kbd = default_keybindings[keymap_id];
    while (iVar1 != 0) {
      pkVar2 = add_keybinding(keymap_id,kbd->action_id,(term_event_keyboard *)kbd,-1);
      pkVar2->flags = pkVar2->flags | (KBDB_DEFAULT_KEY|KBDB_DEFAULT_BINDING);
      iVar1 = kbd[1].kbd.key;
      kbd = kbd + 1;
    }
    iVar3 = iVar3 + 1;
    keymap_id = keymap_id + KEYMAP_EDIT;
  } while (iVar3 != 3);
  return;
}



int bind_do(uchar *keymap_str,uchar *keystroke_str,uchar *action_str,int is_system_conf)

{
  int iVar1;
  action_id_T action_id;
  keybinding *pkVar2;
  int iVar3;
  action_alias *paVar4;
  uint keymap_id;
  term_event_keyboard kbd;
  
  keymap_id = 0;
  iVar3 = 0;
  while (iVar1 = strcmp((char *)keymap_table[keymap_id].str,(char *)keymap_str), iVar1 != 0) {
    iVar3 = iVar3 + 1;
    keymap_id = keymap_id + 1;
    if (iVar3 == 3) {
      return 1;
    }
  }
  iVar3 = parse_keystroke(keystroke_str,&kbd);
  if (iVar3 < 0) {
    return 2;
  }
  if ((assert_failed == 0) && (assert_failed = ZEXT14(2 < keymap_id), 2 < keymap_id)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/kbdbind.c";
    errline = 0x377;
    elinks_internal((uchar *)"assertion keymap_id >= 0 && keymap_id < KEYMAP_MAX failed!");
  }
  paVar4 = action_aliases[keymap_id];
  if (paVar4 != (action_alias *)0x0) {
    while (paVar4->str != (uchar *)0x0) {
      iVar3 = strcmp((char *)paVar4->str,(char *)action_str);
      if (iVar3 == 0) {
        action_id = paVar4->action_id;
        goto LAB_0807341f;
      }
      paVar4 = paVar4 + 1;
    }
  }
  action_id = get_action_from_string(keymap_id,action_str);
LAB_0807341f:
  if (action_id < 0) {
    return 3;
  }
  pkVar2 = add_keybinding(keymap_id,action_id,&kbd,-1);
  if ((pkVar2 != (keybinding *)0x0) && (is_system_conf != 0)) {
    pkVar2->flags = pkVar2->flags | (KBDB_DEFAULT_KEY|KBDB_DEFAULT_BINDING);
  }
  return 0;
}



int bind_key_to_event_name(uchar *ckmap,uchar *ckey,uchar *event_name,uchar **err)

{
  int event;
  int iVar1;
  uchar *puVar2;
  action_id_T action_id;
  keymap_id keymap_id;
  int iVar3;
  term_event_keyboard kbd;
  
  event = register_event(event_name);
  if (event == -1) {
    puVar2 = gettext((uchar *)"Error registering event");
    *err = puVar2;
  }
  else {
    iVar3 = 0;
    keymap_id = KEYMAP_MAIN;
    do {
      iVar1 = strcmp((char *)keymap_table[keymap_id].str,(char *)ckmap);
      if (iVar1 == 0) {
        iVar3 = parse_keystroke(ckey,&kbd);
        if (iVar3 < 0) {
          puVar2 = gettext((uchar *)"Error parsing keystroke");
        }
        else {
          action_id = get_action_from_string(keymap_id,(uchar *)" *scripting-function*");
          if (action_id < 0) {
            puVar2 = gettext((uchar *)"Unrecognised action (internal error)");
          }
          else {
            add_keybinding(keymap_id,action_id,&kbd,event);
            puVar2 = (uchar *)0x0;
          }
        }
        goto LAB_080734e8;
      }
      iVar3 = iVar3 + 1;
      keymap_id = keymap_id + KEYMAP_EDIT;
    } while (iVar3 != 3);
    puVar2 = gettext((uchar *)"Unrecognised keymap");
LAB_080734e8:
    *err = puVar2;
  }
  return event;
}



void add_actions_to_string
               (string *string,action_id_T *action_ids,keymap_id keymap_id,terminal *term)

{
  void *pvVar1;
  int cp_index;
  uchar *codeset;
  uchar *msgid;
  void *action_id;
  action *paVar2;
  int times;
  list_head_elinks *plVar3;
  action_id_T *local_20;
  
  if ((assert_failed == 0) && (assert_failed = ZEXT14(2U < (uint)keymap_id), 2U < (uint)keymap_id))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/kbdbind.c";
    errline = 0x1f6;
    elinks_internal((uchar *)"assertion keymap_id >= 0 && keymap_id < KEYMAP_MAX failed!");
  }
  msgid = keymap_table[keymap_id].desc;
  if ((msgid != (uchar *)0x0) && (*msgid != '\0')) {
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    msgid = gettext(msgid);
  }
  add_format_to_string(string,"%s:\n",msgid);
  action_id = (void *)*action_ids;
  if (action_id != (void *)0x0) {
    local_20 = action_ids;
    do {
      plVar3 = (list_head_elinks *)keymaps[keymap_id].next;
      if (plVar3 == keymaps + keymap_id) {
LAB_08073760:
        plVar3 = (list_head_elinks *)0x0;
      }
      else {
        pvVar1 = plVar3[2].next;
        while (action_id != pvVar1) {
          plVar3 = (list_head_elinks *)plVar3->next;
          if (plVar3 == keymaps + keymap_id) goto LAB_08073760;
          pvVar1 = plVar3[2].next;
        }
      }
      cp_index = string->length;
      msgid = (uchar *)0x0;
      paVar2 = get_action(keymap_id,(action_id_T)action_id);
      if ((paVar2 != (action *)0x0) && (msgid = paVar2->desc, msgid == (uchar *)0x0)) {
        msgid = paVar2->str;
      }
      if (plVar3 != (list_head_elinks *)0x0) {
        add_char_to_string(string,'\n');
        add_keystroke_to_string(string,(term_event_keyboard *)&plVar3[2].prev,0);
        cp_index = (cp_index - string->length) + 0xf;
        times = 1;
        if (0 < cp_index) {
          times = cp_index;
        }
        add_xchar_to_string(string,' ',times);
        if ((msgid != (uchar *)0x0) && (*msgid != '\0')) {
          if ((term != (terminal *)0x0) &&
             (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
            codeset = get_cp_mime_name(cp_index);
            bind_textdomain_codeset("elinks",codeset);
            current_charset = cp_index;
          }
          msgid = gettext(msgid);
        }
        add_to_string(string,msgid);
      }
      action_id = (void *)local_20[1];
      local_20 = local_20 + 1;
    } while (action_id != (void *)0x0);
  }
  return;
}



void prepare_mustsave_flags(list_head_elinks *tree,int set_all)

{
  list_head_elinks *plVar1;
  void *pvVar2;
  
  plVar1 = (list_head_elinks *)tree->next;
  do {
    while( true ) {
      if (plVar1 == tree) {
        return;
      }
      if (set_all != 0) break;
      pvVar2 = plVar1[2].next;
      if ((((uint)pvVar2 & 0x88) != 0) || ((undefined *)plVar1[2].prev == &DAT_00000005))
      goto LAB_080737bb;
      plVar1[2].next = (void *)((uint)pvVar2 & 0xfffffffb);
      if ((undefined *)plVar1[2].prev == &DAT_00000009) goto LAB_080737f0;
LAB_080737c7:
      plVar1 = (list_head_elinks *)plVar1->next;
    }
    pvVar2 = plVar1[2].next;
LAB_080737bb:
    plVar1[2].next = (void *)((uint)pvVar2 | 4);
    if ((undefined *)plVar1[2].prev != &DAT_00000009) goto LAB_080737c7;
LAB_080737f0:
    prepare_mustsave_flags((list_head_elinks *)plVar1[4].next,set_all);
    plVar1 = (list_head_elinks *)plVar1->next;
  } while( true );
}



void untouch_options(list_head_elinks *tree)

{
  list_head_elinks *plVar1;
  
  plVar1 = (list_head_elinks *)tree->next;
  do {
    if (plVar1 == tree) {
      return;
    }
    while (plVar1[2].next = (void *)((uint)plVar1[2].next & 0xfffffff7),
          (undefined *)plVar1[2].prev != &DAT_00000009) {
      plVar1 = (list_head_elinks *)plVar1->next;
      if (plVar1 == tree) {
        return;
      }
    }
    untouch_options((list_head_elinks *)plVar1[4].next);
    plVar1 = (list_head_elinks *)plVar1->next;
  } while( true );
}



int __regparm3 check_nonempty_tree(list_head_elinks *options)

{
  list_head_elinks *plVar1;
  int iVar2;
  
  plVar1 = (list_head_elinks *)options->next;
  do {
    if (plVar1 == options) {
      return 0;
    }
    if ((undefined *)plVar1[2].prev == &DAT_00000009) {
      iVar2 = check_nonempty_tree((list_head_elinks *)plVar1[4].next);
      if (iVar2 != 0) {
        return 1;
      }
    }
    else {
      if ((*(byte *)&plVar1[2].next & 4) != 0) {
        return 1;
      }
    }
    plVar1 = (list_head_elinks *)plVar1->next;
  } while( true );
}



int change_hook_html(session *ses,option_elinks *current,option_elinks *changed)

{
  byte *pbVar1;
  list_head_elinks *plVar2;
  
  plVar2 = (list_head_elinks *)sessions.next;
  if ((list_head_elinks *)sessions.next != &sessions) {
    do {
      pbVar1 = (byte *)((int)plVar2[1].next + 0x28);
      *pbVar1 = *pbVar1 | 1;
      plVar2 = (list_head_elinks *)plVar2->next;
    } while (plVar2 != &sessions);
  }
  return 0;
}



void call_change_hooks(session *ses,option_elinks *current,option_elinks *option_elinks)

{
  int iVar1;
  
  if (current != (option_elinks *)0x0) {
    do {
      if ((current->change_hook != (change_hook_T *)0x0) &&
         (iVar1 = (*current->change_hook)(ses,current,option_elinks), iVar1 != 0)) {
        return;
      }
      current = current->root;
    } while (current != (option_elinks *)0x0);
  }
  return;
}



void option_changed(session *ses,option_elinks *option_elinks)

{
  option_elinks->flags = option_elinks->flags | OPT_TOUCHED;
  call_change_hooks(ses,option_elinks,option_elinks);
  return;
}



void __regparm3 delete_option_do(option_elinks *option_elinks,int recursive)

{
  option_type oVar1;
  option_elinks *option_elinks_00;
  int iVar2;
  option_elinks *p;
  byte bVar3;
  
  bVar3 = 0;
  if (option_elinks->next != (option_elinks *)0x0) {
    option_elinks->next->prev = option_elinks->prev;
    option_elinks->prev->next = option_elinks->next;
    option_elinks->next = (option_elinks *)0x0;
    option_elinks->prev = (option_elinks *)0x0;
  }
  if (recursive == -1) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
    errline = 0x254;
    elinks_error((uchar *)"Orphaned option %s",option_elinks->name);
  }
  oVar1 = option_elinks->type;
  if (oVar1 == OPT_TREE) {
    p = (option_elinks *)option_elinks->value;
    if ((p != (option_elinks *)0x0) && (option_elinks_00 = p->next, p != option_elinks_00)) {
      if ((recursive == 0) && (recursive = 1, (*(byte *)&option_elinks->flags & 2) == 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
        recursive = -1;
        errline = 0x25d;
        elinks_error((uchar *)"Orphaned unregistered option in subtree %s!",option_elinks->name);
        p = (option_elinks *)option_elinks->value;
        option_elinks_00 = p->next;
        if (p != option_elinks_00) goto LAB_08073a18;
      }
      else {
LAB_08073a18:
        do {
          delete_option_do(option_elinks_00,recursive);
          option_elinks_00 = p->next;
        } while (option_elinks_00 != p);
      }
      oVar1 = option_elinks->type;
      goto joined_r0x08073a2b;
    }
  }
  else {
joined_r0x08073a2b:
    if (oVar1 == OPT_STRING) {
      if ((void *)option_elinks->value != (void *)0x0) {
        mem_free((void *)option_elinks->value);
      }
      goto LAB_080739a0;
    }
    if (oVar1 != OPT_TREE) goto LAB_080739a0;
    p = (option_elinks *)option_elinks->value;
  }
  if (p != (option_elinks *)0x0) {
    mem_free(p);
  }
LAB_080739a0:
  if (option_elinks->box_item != (listbox_item *)0x0) {
    done_listbox_item(&option_browser,option_elinks->box_item);
  }
  if ((option_elinks->flags & OPT_ALLOC) == 0) {
    if (option_elinks->capt == (uchar *)0x0) {
      iVar2 = 0xe;
      while (iVar2 != 0) {
        iVar2 = iVar2 + -1;
        option_elinks->next = (option_elinks *)0x0;
        option_elinks = (option_elinks *)((int)option_elinks + (uint)bVar3 * -8 + 4);
      }
    }
  }
  else {
    if (option_elinks->name != (uchar *)0x0) {
      mem_free(option_elinks->name);
    }
    mem_free(option_elinks);
  }
  return;
}



void unregister_options(option_info *info,option_elinks *tree)

{
  option_info *poVar1;
  int iVar2;
  option_info *option_elinks;
  int iVar3;
  
  if (info->path != (uchar *)0x0) {
    option_elinks = info;
    iVar2 = 0;
    do {
      iVar3 = iVar2;
      poVar1 = option_elinks + 1;
      option_elinks = option_elinks + 1;
      iVar2 = iVar3 + 1;
    } while (poVar1->path != (uchar *)0x0);
    if (iVar3 != -1) {
      option_elinks = info + iVar3;
      do {
        iVar3 = iVar3 + -1;
        delete_option_do((option_elinks *)option_elinks,0);
        option_elinks = option_elinks + -1;
      } while (iVar3 != -1);
    }
  }
  return;
}



void done_options(void)

{
  unregister_options(config_options_info,config_options);
  unregister_options(cmdline_options_info,cmdline_options);
  config_options->box_item = (listbox_item *)0x0;
  while ((list_head_elinks *)options_root_tree.next != &options_root_tree) {
    delete_option_do((option_elinks *)options_root_tree.next,0);
  }
  return;
}



void delete_option(option_elinks *option_elinks)

{
  delete_option_do(option_elinks,1);
  return;
}



list_head_elinks * init_options_tree(void)

{
  list_head_elinks *plVar1;
  
  plVar1 = (list_head_elinks *)mem_alloc(8);
  if (plVar1 != (list_head_elinks *)0x0) {
    *(list_head_elinks **)&plVar1->prev = plVar1;
    *(list_head_elinks **)&plVar1->next = plVar1;
  }
  return plVar1;
}



void toggle_option(session *ses,option_elinks *option_elinks)

{
  int iVar1;
  bool bVar2;
  
  iVar1 = option_elinks->value + 1;
  if (assert_failed == 0) {
    bVar2 = OPT_INT < option_elinks->type;
    assert_failed = ZEXT14(bVar2);
    if (bVar2) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0x3dc;
      elinks_internal((uchar *)
                      "assertion option->type == OPT_BOOL || option->type == OPT_INT failed!");
      if (assert_failed != 0) goto LAB_08073c1a;
    }
    bVar2 = option_elinks->max == 0;
    assert_failed = ZEXT14(bVar2);
    if (bVar2) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0x3dd;
      elinks_internal((uchar *)"assertion option->max failed!");
    }
  }
LAB_08073c1a:
  if (option_elinks->max < iVar1) {
    iVar1 = option_elinks->min;
  }
  option_elinks->value = iVar1;
  option_changed(ses,option_elinks);
  return;
}



void mark_option_as_deleted(option_elinks *option_elinks)

{
  byte *pbVar1;
  option_elinks *option_elinks_00;
  bool bVar2;
  
  if (option_elinks->type == OPT_TREE) {
    if ((assert_failed == 0) &&
       (bVar2 = option_elinks->value == 0, assert_failed = ZEXT14(bVar2), bVar2)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0x26f;
      elinks_internal((uchar *)"assertion option->value.tree failed!");
    }
    option_elinks_00 = ((option_elinks *)option_elinks->value)->next;
    if (option_elinks_00 != (option_elinks *)option_elinks->value) {
      do {
        mark_option_as_deleted(option_elinks_00);
        option_elinks_00 = option_elinks_00->next;
      } while ((option_elinks *)option_elinks->value != option_elinks_00);
    }
  }
  pbVar1 = (byte *)&option_elinks->box_item->field_0x18;
  *pbVar1 = *pbVar1 & 0xfd;
  option_elinks->flags = option_elinks->flags | (OPT_TOUCHED|OPT_DELETED);
  return;
}



void __regparm3 update_visibility(list_head_elinks *tree,int show)

{
  void *pvVar1;
  byte bVar2;
  int iVar3;
  list_head_elinks *plVar4;
  char *pcVar5;
  char *pcVar6;
  bool bVar7;
  byte bVar8;
  byte local_28;
  
  bVar8 = 0;
  plVar4 = (list_head_elinks *)tree->next;
  if (plVar4 == tree) {
    return;
  }
  local_28 = (byte)show;
  bVar2 = (local_28 & 1) * '\x02';
  do {
    while (bVar7 = *(char *)&plVar4[2].next == '\0', *(char *)&plVar4[2].next < '\0') {
LAB_08073d82:
      plVar4 = (list_head_elinks *)plVar4->next;
      if (plVar4 == tree) {
        return;
      }
    }
    iVar3 = 0xb;
    pcVar5 = (char *)plVar4[1].prev;
    pcVar6 = "_template_";
    do {
      if (iVar3 == 0) break;
      iVar3 = iVar3 + -1;
      bVar7 = *pcVar5 == *pcVar6;
      pcVar5 = pcVar5 + (uint)bVar8 * -2 + 1;
      pcVar6 = pcVar6 + (uint)bVar8 * -2 + 1;
    } while (bVar7);
    if (bVar7) {
      pvVar1 = plVar4[6].prev;
      if (pvVar1 != (void *)0x0) {
        *(byte *)((int)pvVar1 + 0x18) = *(byte *)((int)pvVar1 + 0x18) & 0xfd | bVar2;
      }
      if ((undefined *)plVar4[2].prev == &DAT_00000009) {
        update_visibility((list_head_elinks *)plVar4[4].next,show | 2);
      }
      goto LAB_08073d82;
    }
    pvVar1 = plVar4[6].prev;
    if ((pvVar1 != (void *)0x0) && ((show & 2U) != 0)) {
      *(byte *)((int)pvVar1 + 0x18) = *(byte *)((int)pvVar1 + 0x18) & 0xfd | bVar2;
    }
    if ((undefined *)plVar4[2].prev != &DAT_00000009) goto LAB_08073d82;
    update_visibility((list_head_elinks *)plVar4[4].next,show);
    plVar4 = (list_head_elinks *)plVar4->next;
    if (plVar4 == tree) {
      return;
    }
  } while( true );
}



int change_hook_stemplate(session *ses,option_elinks *current,option_elinks *changed)

{
  update_visibility((list_head_elinks *)config_options->value,changed->value);
  return 0;
}



void smart_config_string(string *str,int print_comment,int i18n,list_head_elinks *options,
                        uchar *path,int depth,
                        anon_subr_void_string_ptr_option_elinks_ptr_uchar_ptr_int_int_int_int *fn)

{
  string *psVar1;
  int local_5c;
  undefined *puVar2;
  option_elinks *poVar3;
  uint print_comment_00;
  uchar *puVar4;
  uchar *puVar5;
  bool bVar6;
  byte bVar7;
  int local_58;
  string newpath;
  
  bVar7 = 0;
  poVar3 = (option_elinks *)options->next;
  if (poVar3 != (option_elinks *)options) {
    do {
      if ((poVar3->flags & OPT_HIDDEN) == 0) {
        bVar6 = (undefined *)poVar3->type == &DAT_00000008;
        if (!bVar6) {
          local_5c = 0xb;
          puVar4 = poVar3->name;
          puVar5 = "_template_";
          do {
            if (local_5c == 0) break;
            local_5c = local_5c + -1;
            bVar6 = *puVar4 == *puVar5;
            puVar4 = puVar4 + (uint)bVar7 * -2 + 1;
            puVar5 = puVar5 + (uint)bVar7 * -2 + 1;
          } while (bVar6);
          if (!bVar6) {
            if ((undefined *)poVar3->type == &DAT_00000009) {
              local_5c = check_nonempty_tree((list_head_elinks *)poVar3->value);
              bVar6 = local_5c == 0;
            }
            else {
              bVar6 = (bool)(((byte)(poVar3->flags >> 2) ^ 1) & 1);
            }
            if (bVar6 == false) {
              if (print_comment == 0) {
                puVar2 = (undefined *)poVar3->type;
                local_5c = 0;
LAB_08073e8a:
                local_58 = print_comment;
                if (puVar2 != &DAT_00000009) {
LAB_08073e92:
                  local_58 = local_5c;
                  local_5c = local_58;
                }
              }
              else {
                bVar6 = print_comment == 1;
                if (!bVar6) {
LAB_08073f52:
                  puVar2 = (undefined *)poVar3->type;
                  local_5c = 1;
                  goto LAB_08073e8a;
                }
                local_5c = 0xb;
                puVar4 = poVar3->name;
                puVar5 = "_template_";
                do {
                  if (local_5c == 0) break;
                  local_5c = local_5c + -1;
                  bVar6 = *puVar4 == *puVar5;
                  puVar4 = puVar4 + (uint)bVar7 * -2 + 1;
                  puVar5 = puVar5 + (uint)bVar7 * -2 + 1;
                } while (bVar6);
                if ((bVar6) || ((*(byte *)&poVar3->flags & 2) == 0)) goto LAB_08073f52;
                local_5c = 1;
                if ((undefined *)poVar3->type != &DAT_00000009) goto LAB_08073e92;
                local_58 = 1;
                local_5c = 0;
              }
              (*fn)(str,poVar3,path,depth,local_58,0,i18n);
              (*fn)(str,poVar3,path,depth,local_5c,1,i18n);
              if (option_types[(int)(undefined *)poVar3->type].write ==
                  (anon_subr_void_option_elinks_ptr_string_ptr_for_write *)0x0) {
                if ((undefined *)poVar3->type == &DAT_00000009) {
                  psVar1 = init_string(&newpath);
                  if (psVar1 != (string *)0x0) {
                    if (print_comment == 2) {
                      print_comment_00 = ~-(uint)((poVar3->flags & OPT_AUTOCREATE) == 0) + 2;
                    }
                    else {
                      print_comment_00 = print_comment;
                      if (print_comment == 1) {
                        local_5c = strcmp((char *)poVar3->name,"_template_");
                        print_comment_00 = (uint)(local_5c == 0);
                      }
                    }
                    (*fn)(str,poVar3,path,depth,1,3,i18n);
                    if (path != (uchar *)0x0) {
                      add_to_string(&newpath,path);
                      add_char_to_string(&newpath,'.');
                    }
                    add_to_string(&newpath,poVar3->name);
                    smart_config_string(str,print_comment_00,i18n,(list_head_elinks *)poVar3->value,
                                        newpath.source,depth + 1,fn);
                    done_string(&newpath);
                    local_58 = 3;
                    local_5c = 1;
                    goto LAB_08073f15;
                  }
                }
              }
              else {
                local_58 = 2;
LAB_08073f15:
                (*fn)(str,poVar3,path,depth,local_5c,local_58,i18n);
              }
            }
          }
        }
      }
      poVar3 = poVar3->next;
    } while (poVar3 != (option_elinks *)options);
  }
  return;
}



int change_hook_ui(session *ses,option_elinks *current,option_elinks *changed)

{
  update_status();
  return 0;
}



int change_hook_insert_mode(session *ses,option_elinks *current,option_elinks *changed)

{
  update_status();
  return 0;
}



int change_hook_language(session *ses,option_elinks *current,option_elinks *changed)

{
  set_language(changed->value);
  return 0;
}



int change_hook_terminal(session *ses,option_elinks *current,option_elinks *changed)

{
  cls_redraw_all_terminals();
  return 0;
}



int change_hook_cache(session *ses,option_elinks *current,option_elinks *changed)

{
  shrink_memory(0);
  return 0;
}



int change_hook_active_link(session *ses,option_elinks *current,option_elinks *changed)

{
  update_cached_document_options();
  return 0;
}



int change_hook_connection(session *ses,option_elinks *current,option_elinks *changed)

{
  register_check_queue();
  return 0;
}



option_elinks * copy_option(option_elinks *template)

{
  option_elinks *poVar1;
  uchar *puVar2;
  listbox_item *plVar3;
  
  poVar1 = (option_elinks *)mem_calloc(1,0x38);
  if (poVar1 != (option_elinks *)0x0) {
    puVar2 = (uchar *)0x0;
    if (template->name != (uchar *)0x0) {
      puVar2 = stracpy(template->name);
    }
    poVar1->name = puVar2;
    poVar1->flags = template->flags | OPT_ALLOC;
    poVar1->type = template->type;
    poVar1->min = template->min;
    poVar1->max = template->max;
    poVar1->capt = template->capt;
    poVar1->desc = template->desc;
    poVar1->change_hook = template->change_hook;
    plVar3 = (listbox_item *)mem_calloc(1,0x20);
    if (plVar3 == (listbox_item *)0x0) {
      poVar1->box_item = (listbox_item *)0x0;
    }
    else {
      *(byte *)&plVar3->field_0x18 = *(byte *)&plVar3->field_0x18 | 2;
      *(list_head_elinks **)&(plVar3->child).prev = &plVar3->child;
      *(list_head_elinks **)&(plVar3->child).next = &plVar3->child;
      *(option_elinks **)&plVar3->udata = poVar1;
      plVar3->type = (uint)(poVar1->type == OPT_TREE);
      poVar1->box_item = plVar3;
      if (template->box_item != (listbox_item *)0x0) {
        plVar3->type = template->box_item->type;
        poVar1->box_item->depth = template->box_item->depth;
      }
    }
    if (option_types[template->type].dup ==
        (anon_subr_void_option_elinks_ptr_option_elinks_ptr_for_dup *)0x0) {
      poVar1->value = template->value;
      return poVar1;
    }
    (*option_types[template->type].dup)(poVar1,template);
  }
  return poVar1;
}



option_elinks * get_opt_rec(option_elinks *tree,uchar *name_)

{
  option_elinks *poVar1;
  uchar *name__00;
  char *pcVar2;
  int iVar3;
  uchar *puVar4;
  option_elinks *template;
  uchar *local_24;
  
  template = (option_elinks *)0x0;
  name__00 = stracpy(name_);
  if (name__00 != (uchar *)0x0) {
    pcVar2 = strrchr((char *)name__00,0x2e);
    local_24 = name__00;
    if (pcVar2 != (char *)0x0) {
      *pcVar2 = '\0';
      tree = get_opt_rec(tree,name__00);
      if (((tree == (option_elinks *)0x0) || (tree->type != OPT_TREE)) ||
         ((*(byte *)&tree->flags & 1) != 0)) goto LAB_080743c0;
      *pcVar2 = '.';
      local_24 = (uchar *)(pcVar2 + 1);
    }
    template = (option_elinks *)tree->value;
    poVar1 = template->next;
    while (poVar1 != template) {
      if ((poVar1->name != (uchar *)0x0) &&
         (iVar3 = strcmp((char *)poVar1->name,(char *)local_24), iVar3 == 0)) {
        mem_free(name__00);
        return poVar1;
      }
      poVar1 = poVar1->next;
    }
    if (((*(byte *)&tree->flags & 2) == 0) || (no_autocreate != 0)) {
LAB_080743c0:
      mem_free(name__00);
      return (option_elinks *)0x0;
    }
    template = get_opt_rec(tree,"_template_");
    if (assert_failed != 0) {
LAB_08074439:
      assert_failed = 0;
      mem_free(name__00);
      return (option_elinks *)0x0;
    }
    assert_failed = ZEXT14(template == (option_elinks *)0x0);
    if (template == (option_elinks *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0xd1;
      elinks_internal((uchar *)
                      "assertion template != NULL failed: Requested %s should be autocreated but %.*s._template_ is missing!"
                      ,name_,pcVar2 + -(int)name_,name_);
      if (assert_failed != 0) goto LAB_08074439;
    }
    template = copy_option(template);
    if (template != (option_elinks *)0x0) {
      if (template->name != (uchar *)0x0) {
        mem_free(template->name);
      }
      puVar4 = stracpy(local_24);
      template->name = puVar4;
      add_opt_rec(tree,"",template);
    }
    mem_free(name__00);
  }
  return template;
}



void checkout_option_values
               (option_resolver *resolvers,option_elinks *root,option_value *values,int size)

{
  option_resolver *poVar1;
  option_elinks *poVar2;
  int iVar3;
  
  if (0 < size) {
    iVar3 = 0;
    do {
      poVar2 = get_opt_rec(root,resolvers[iVar3].name);
      poVar1 = resolvers + iVar3;
      iVar3 = iVar3 + 1;
      values[poVar1->id] = poVar2->value;
    } while (iVar3 < size);
  }
  return;
}



int commit_option_values
              (option_resolver *resolvers,option_elinks *root,option_value *values,int size)

{
  undefined4 uVar1;
  option_elinks *poVar2;
  int iVar3;
  int iVar4;
  option_value *poVar5;
  undefined4 *puVar6;
  bool bVar7;
  byte bVar8;
  int local_24;
  
  bVar8 = 0;
  if (assert_failed == 0) {
    if ((((root == (option_elinks *)0x0) || (resolvers == (option_resolver *)0x0)) || (size == 0))
       || (values == (option_value *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0x425;
      elinks_internal((uchar *)"assertion resolvers && root && values && size failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  iVar4 = 0;
  local_24 = 0;
  bVar7 = size == 0;
  if (0 < size) {
    do {
      poVar2 = get_opt_rec(root,resolvers[iVar4].name);
      iVar3 = 4;
      poVar5 = &poVar2->value;
      puVar6 = values + resolvers[iVar4].id;
      do {
        if (iVar3 == 0) break;
        iVar3 = iVar3 + -1;
        bVar7 = *(char *)poVar5 == *(char *)puVar6;
        poVar5 = (option_value *)((int)poVar5 + (uint)bVar8 * -2 + 1);
        puVar6 = (undefined4 *)((int)puVar6 + (uint)bVar8 * -2 + 1);
      } while (bVar7);
      if (!bVar7) {
        uVar1 = values[resolvers[iVar4].id];
        poVar2->flags = poVar2->flags | OPT_TOUCHED;
        poVar2->value = uVar1;
        if (poVar2->change_hook != (change_hook_T *)0x0) {
          (*poVar2->change_hook)((session *)0x0,poVar2,(option_elinks *)0x0);
        }
        local_24 = local_24 + 1;
      }
      iVar4 = iVar4 + 1;
      bVar7 = size == iVar4;
    } while (!bVar7 && iVar4 <= size);
  }
  call_change_hooks((session *)0x0,root,(option_elinks *)0x0);
  return local_24;
}



void register_change_hooks(change_hook_info *change_hooks)

{
  uchar *name_;
  option_elinks *poVar1;
  
  name_ = change_hooks->name;
  while (name_ != (uchar *)0x0) {
    poVar1 = get_opt_rec(config_options,name_);
    if ((assert_failed == 0) &&
       (assert_failed = ZEXT14(poVar1 == (option_elinks *)0x0), poVar1 == (option_elinks *)0x0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0x2f3;
      elinks_internal((uchar *)"assertion option failed!");
    }
    poVar1->change_hook = change_hooks->change_hook;
    name_ = change_hooks[1].name;
    change_hooks = change_hooks + 1;
  }
  return;
}



option_value * __regparm3 get_opt_(option_elinks *tree,uchar *name)

{
  option_elinks *poVar1;
  option_elinks *in_stack_00000004;
  uchar *in_stack_00000008;
  
  poVar1 = get_opt_rec(in_stack_00000004,in_stack_00000008);
  return &poVar1->value;
}



// WARNING: Type propagation algorithm not settling

void __regparm3 add_opt_rec(option_elinks *tree,uchar *path,option_elinks *option_elinks)

{
  uchar uVar1;
  byte bVar2;
  listbox_item *plVar3;
  option_elinks *poVar4;
  byte *__s2;
  listbox_item *plVar5;
  option_elinks *poVar6;
  undefined *puVar7;
  int iVar8;
  uchar *__s1;
  option_elinks *poVar9;
  undefined *puVar10;
  uchar *puVar11;
  bool bVar12;
  bool bVar13;
  byte bVar14;
  listbox_item *local_28;
  option_elinks *local_20;
  
  bVar14 = 0;
  if (assert_failed == 0) {
    if (((option_elinks == (option_elinks *)0x0) || (path == (uchar *)0x0)) ||
       (tree == (option_elinks *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0x1a3;
      elinks_internal((uchar *)"assertion path && option && tree failed!");
      goto LAB_080746e0;
    }
    assert_failed = 0;
    uVar1 = *path;
  }
  else {
LAB_080746e0:
    uVar1 = *path;
  }
  local_20 = tree;
  if (uVar1 != '\0') {
    local_20 = get_opt_rec(tree,path);
  }
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(local_20 == (option_elinks *)0x0), local_20 == (option_elinks *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
    errline = 0x1a6;
    elinks_internal((uchar *)"assertion tree != NULL failed: Missing option tree for \'%s\'",path);
  }
  if (local_20->value == 0) {
    return;
  }
  plVar5 = option_elinks->box_item;
  if (plVar5 == (listbox_item *)0x0) {
LAB_08074738:
    bVar2 = *(byte *)&local_20->flags;
  }
  else {
    bVar12 = option_elinks->name == (uchar *)0x0;
    if (bVar12) goto LAB_08074738;
    iVar8 = 0xb;
    __s1 = option_elinks->name;
    puVar11 = "_template_";
    do {
      if (iVar8 == 0) break;
      iVar8 = iVar8 + -1;
      bVar12 = *__s1 == *puVar11;
      __s1 = __s1 + (uint)bVar14 * -2 + 1;
      puVar11 = puVar11 + (uint)bVar14 * -2 + 1;
    } while (bVar12);
    if (!bVar12) goto LAB_08074738;
    poVar6 = get_opt_rec(config_options,(uchar *)"config.show_template");
    *(byte *)&plVar5->field_0x18 =
         *(byte *)&plVar5->field_0x18 & 0xfd | ((byte)poVar6->value & 1) * '\x02';
    bVar2 = *(byte *)&local_20->flags;
  }
  if (((bVar2 & 2) != 0) && (option_elinks->desc == (uchar *)0x0)) {
    poVar6 = get_opt_rec(local_20,"_template_");
    if ((assert_failed == 0) &&
       (assert_failed = ZEXT14(poVar6 == (option_elinks *)0x0), poVar6 == (option_elinks *)0x0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0x1b1;
      elinks_internal((uchar *)"assertion template failed!");
    }
    option_elinks->desc = poVar6->desc;
  }
  option_elinks->root = local_20;
  plVar5 = local_20->box_item;
  if ((plVar5 != (listbox_item *)0x0) && (option_elinks->box_item != (listbox_item *)0x0)) {
    bVar12 = true;
    if (plVar5->next != (listbox_item *)0x0) {
      option_elinks->box_item->depth = plVar5->depth + 1;
    }
    if ((*(byte *)&local_20->flags & 0x40) != 0) goto LAB_08074887;
LAB_08074782:
    option_elinks->next = *(option_elinks **)*(int *)(local_20->value + 4);
    option_elinks->prev = *(option_elinks **)(local_20->value + 4);
    (*(option_elinks **)(local_20->value + 4))->next = option_elinks;
    option_elinks->next->prev = option_elinks;
    if (!bVar12) goto LAB_080747d5;
    option_elinks->box_item->next = *(listbox_item **)(local_20->box_item->child).prev;
    option_elinks->box_item->prev = (listbox_item *)(local_20->box_item->child).prev;
    plVar5 = (listbox_item *)(local_20->box_item->child).prev;
LAB_080747c8:
    *(listbox_item **)plVar5 = option_elinks->box_item;
    option_elinks->box_item->next->prev = option_elinks->box_item;
    goto LAB_080747d5;
  }
  bVar12 = false;
  if ((*(byte *)&local_20->flags & 0x40) == 0) goto LAB_08074782;
LAB_08074887:
  poVar6 = (option_elinks *)local_20->value;
  plVar3 = local_20->box_item;
  plVar5 = (listbox_item *)&plVar3->child;
  poVar4 = poVar6->next;
  if (poVar6 == poVar4) {
    option_elinks->next = poVar6;
    option_elinks->prev = poVar6;
    poVar6->next = option_elinks;
    option_elinks->next->prev = option_elinks;
    if (bVar12) {
      option_elinks->box_item->next = (listbox_item *)(plVar3->child).next;
      option_elinks->box_item->prev = plVar5;
      *(listbox_item **)&(plVar3->child).next = option_elinks->box_item;
      option_elinks->box_item->next->prev = option_elinks->box_item;
    }
    goto LAB_080747d5;
  }
  puVar10 = (undefined *)option_elinks->type;
  local_28 = plVar5;
  if (puVar10 == &DAT_00000009) {
    poVar9 = poVar6->prev;
    if (poVar9->type == OPT_TREE) goto LAB_080748b5;
  }
  else {
    poVar9 = poVar6->prev;
LAB_080748b5:
    iVar8 = strcmp((char *)poVar9->name,(char *)option_elinks->name);
    if ((iVar8 < 1) || ((puVar10 != &DAT_00000009 && (poVar9->type == OPT_TREE)))) {
      option_elinks->next = poVar9->next;
      option_elinks->prev = poVar6->prev;
      poVar6->prev->next = option_elinks;
      option_elinks->next->prev = option_elinks;
      if (!bVar12) goto LAB_080747d5;
      option_elinks->box_item->next = *(listbox_item **)(plVar3->child).prev;
      option_elinks->box_item->prev = (listbox_item *)(plVar3->child).prev;
      plVar5 = (listbox_item *)(plVar3->child).prev;
      goto LAB_080747c8;
    }
  }
  while (poVar4 != poVar6) {
    if (((-1 < *(char *)&poVar4->flags) && (poVar4->box_item != (listbox_item *)0x0)) &&
       (local_28 = local_28->next, assert_failed == 0)) {
      assert_failed = ZEXT14(plVar5 == local_28);
      if (plVar5 == local_28) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
        errline = 0x175;
        elinks_internal((uchar *)"assertion bpos != (struct listbox_item *) bcat failed!");
        puVar10 = (undefined *)option_elinks->type;
      }
      else {
        puVar10 = (undefined *)option_elinks->type;
      }
    }
    if ((puVar10 == &DAT_00000009) && ((undefined *)poVar4->type != &DAT_00000009))
    goto LAB_08074978;
    __s1 = poVar4->name;
    __s2 = option_elinks->name;
    iVar8 = strcmp((char *)__s1,(char *)__s2);
    if (0 < iVar8) {
      if (puVar10 == &DAT_00000009) {
        puVar7 = (undefined *)poVar4->type;
      }
      else {
        puVar7 = (undefined *)poVar4->type;
        if (puVar7 == &DAT_00000009) goto LAB_08074ab0;
      }
      if ((puVar10 != puVar7) || (bVar13 = *__s2 == 0x5f, 0x5f < *__s2)) goto LAB_08074978;
      iVar8 = 0xb;
      puVar11 = "_template_";
      goto code_r0x08074b56;
    }
LAB_08074ab0:
    poVar4 = poVar4->next;
  }
  goto LAB_080749bc;
  while( true ) {
    iVar8 = iVar8 + -1;
    bVar13 = *__s1 == *puVar11;
    __s1 = __s1 + (uint)bVar14 * -2 + 1;
    puVar11 = puVar11 + (uint)bVar14 * -2 + 1;
    if (!bVar13) break;
code_r0x08074b56:
    if (iVar8 == 0) break;
  }
  if (bVar13) {
    if (bVar12) {
      option_elinks->box_item->next = local_28->next;
      option_elinks->box_item->prev = local_28;
      local_28->next = option_elinks->box_item;
      option_elinks->box_item->next->prev = option_elinks->box_item;
    }
    poVar9 = poVar4->next;
    option_elinks->prev = poVar4;
    option_elinks->next = poVar9;
    poVar4->next = option_elinks;
    option_elinks->next->prev = option_elinks;
  }
  else {
LAB_08074978:
    if (bVar12) {
      option_elinks->box_item->next = local_28->prev->next;
      option_elinks->box_item->prev = local_28->prev;
      local_28->prev->next = option_elinks->box_item;
      option_elinks->box_item->next->prev = option_elinks->box_item;
    }
    option_elinks->next = poVar4->prev->next;
    option_elinks->prev = poVar4->prev;
    poVar4->prev->next = option_elinks;
    option_elinks->next->prev = option_elinks;
  }
LAB_080749bc:
  if (assert_failed == 0) {
    assert_failed = ZEXT14(poVar4 == poVar6);
    if (poVar4 == poVar6) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0x198;
      elinks_internal((uchar *)"assertion pos != (struct option *) cat failed!");
      if (assert_failed != 0) goto LAB_080747d5;
    }
    assert_failed = ZEXT14(plVar5 == local_28);
    if (plVar5 == local_28) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0x199;
      elinks_internal((uchar *)"assertion bpos != (struct listbox_item *) bcat failed!");
    }
  }
LAB_080747d5:
  update_hierbox_browser(&option_browser);
  return;
}



void register_options(option_info *info,option_elinks *tree)

{
  option_elinks *poVar1;
  option_info *poVar2;
  listbox_item *plVar3;
  option_type oVar4;
  list_head_elinks *plVar5;
  size_t slen;
  int iVar6;
  uchar *name;
  option_info *poVar7;
  
  if (info->path != (uchar *)0x0) {
    poVar2 = info + 1;
    do {
      poVar7 = poVar2;
      oVar4 = (info->option_elinks).type;
      if (oVar4 == OPT_ALIAS) goto LAB_08074cb0;
      if (((*(byte *)&tree->flags & 0x10) == 0) &&
         ((*(byte *)&(info->option_elinks).flags & 0x10) == 0)) {
LAB_08074d20:
        if (oVar4 == OPT_CODEPAGE) {
          name = (uchar *)(info->option_elinks).value;
          if ((assert_failed == 0) &&
             (assert_failed = ZEXT14(name == (uchar *)0x0), name == (uchar *)0x0)) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
            errline = 0x486;
            elinks_internal((uchar *)"assertion string failed!");
          }
          iVar6 = get_cp_index(name);
          (info->option_elinks).value = iVar6;
LAB_08074cb0:
          add_opt_rec(tree,(uchar *)info->path,(option_elinks *)info);
          goto LAB_08074cbc;
        }
        if (OPT_CODEPAGE < oVar4) {
          if (oVar4 == OPT_COLOR) {
            name = (uchar *)(info->option_elinks).value;
            if ((assert_failed == 0) &&
               (assert_failed = ZEXT14(name == (uchar *)0x0), name == (uchar *)0x0)) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
              errline = 0x480;
              elinks_internal((uchar *)"assertion string failed!");
            }
            slen = strlen((char *)name);
            decode_color(name,slen,&(info->option_elinks).value);
          }
          else {
            if (oVar4 == OPT_TREE) {
              plVar5 = init_options_tree();
              *(list_head_elinks **)&(info->option_elinks).value = plVar5;
              if (plVar5 == (list_head_elinks *)0x0) goto LAB_08074d50;
            }
          }
          goto LAB_08074cb0;
        }
        if (oVar4 != OPT_STRING) goto LAB_08074cb0;
        name = (uchar *)mem_alloc(0x400);
        if (name != (uchar *)0x0) {
          safe_strncpy(name,(uchar *)(info->option_elinks).value,0x400);
          *(uchar **)&(info->option_elinks).value = name;
          goto LAB_08074cb0;
        }
LAB_08074d50:
        delete_option((option_elinks *)info);
        poVar1 = (option_elinks *)poVar7->path;
      }
      else {
        plVar3 = (listbox_item *)mem_calloc(1,0x20);
        if (plVar3 != (listbox_item *)0x0) {
          *(byte *)&plVar3->field_0x18 = *(byte *)&plVar3->field_0x18 | 2;
          *(list_head_elinks **)&(plVar3->child).prev = &plVar3->child;
          *(list_head_elinks **)&(plVar3->child).next = &plVar3->child;
          *(option_info **)&plVar3->udata = info;
          plVar3->type = (uint)((info->option_elinks).type == OPT_TREE);
          (info->option_elinks).box_item = plVar3;
          oVar4 = (info->option_elinks).type;
          goto LAB_08074d20;
        }
        (info->option_elinks).box_item = (listbox_item *)0x0;
        delete_option((option_elinks *)info);
LAB_08074cbc:
        poVar1 = (option_elinks *)poVar7->path;
      }
      poVar2 = poVar7 + 1;
      info = poVar7;
    } while (poVar1 != (option_elinks *)0x0);
  }
  return;
}



option_elinks *
add_opt(option_elinks *tree,uchar *path,uchar *capt,uchar *name,option_flags flags,option_type type,
       long min,long max,longptr_T value,uchar *desc)

{
  option_elinks *option_elinks;
  uchar *puVar1;
  listbox_item *plVar2;
  size_t slen;
  
  option_elinks = (option_elinks *)mem_calloc(1,0x38);
  if (option_elinks == (option_elinks *)0x0) {
    return (option_elinks *)0x0;
  }
  puVar1 = stracpy(name);
  option_elinks->name = puVar1;
  if (puVar1 == (uchar *)0x0) goto LAB_08074fcf;
  option_elinks->type = type;
  option_elinks->flags = flags | OPT_ALLOC;
  option_elinks->min = min;
  option_elinks->max = max;
  option_elinks->capt = capt;
  option_elinks->desc = desc;
  switch(type) {
  case OPT_STRING:
  case OPT_TREE:
    if (value == 0) goto LAB_08074fcf;
  case OPT_BOOL:
  case OPT_INT:
  case OPT_LONG:
  case OPT_CODEPAGE:
  case OPT_COMMAND:
    option_elinks->value = value;
    break;
  default:
    goto switchD_08074f88_caseD_5;
  case OPT_COLOR:
    slen = strlen((char *)value);
    decode_color((uchar *)value,slen,&option_elinks->value);
    type = option_elinks->type;
switchD_08074f88_caseD_5:
    if (type == OPT_ALIAS) goto LAB_08074f6f;
    break;
  case OPT_ALIAS:
    option_elinks->value = value;
    goto LAB_08074f6f;
  }
  if (((*(byte *)&tree->flags & 0x10) != 0) || ((*(byte *)&option_elinks->flags & 0x10) != 0)) {
    plVar2 = (listbox_item *)mem_calloc(1,0x20);
    if (plVar2 == (listbox_item *)0x0) {
      option_elinks->box_item = (listbox_item *)0x0;
LAB_08074fcf:
      mem_free(option_elinks);
      return (option_elinks *)0x0;
    }
    *(byte *)&plVar2->field_0x18 = *(byte *)&plVar2->field_0x18 | 2;
    *(list_head_elinks **)&(plVar2->child).prev = &plVar2->child;
    *(list_head_elinks **)&(plVar2->child).next = &plVar2->child;
    *(option_elinks **)&plVar2->udata = option_elinks;
    plVar2->type = (uint)(option_elinks->type == OPT_TREE);
    option_elinks->box_item = plVar2;
  }
LAB_08074f6f:
  add_opt_rec(tree,path,option_elinks);
  return option_elinks;
}



void update_options_visibility(void)

{
  option_elinks *poVar1;
  
  poVar1 = get_opt_rec(config_options,(uchar *)"config.show_template");
  update_visibility((list_head_elinks *)config_options->value,poVar1->value);
  return;
}



void init_options(void)

{
  list_head_elinks *value;
  option_elinks *poVar1;
  
  value = init_options_tree();
  cmdline_options =
       add_opt(&options_root,"","",(uchar *)"cmdline",0,OPT_TREE,0,0,(longptr_T)value,"");
  register_options(cmdline_options_info,cmdline_options);
  value = init_options_tree();
  config_options =
       add_opt(&options_root,"","",(uchar *)"config",OPT_SORT,OPT_TREE,0,0,(longptr_T)value,"");
  config_options->flags = config_options->flags | OPT_LISTBOX;
  config_options->box_item = &option_browser.root;
  register_options(config_options_info,config_options);
  poVar1 = get_opt_rec(config_options,(uchar *)"terminal.linux.type");
  poVar1->value = 2;
  poVar1 = get_opt_rec(config_options,(uchar *)"terminal.linux.colors");
  poVar1->value = 1;
  poVar1 = get_opt_rec(config_options,(uchar *)"terminal.linux.m11_hack");
  poVar1->value = 1;
  poVar1 = get_opt_rec(config_options,(uchar *)"terminal.vt100.type");
  poVar1->value = 1;
  poVar1 = get_opt_rec(config_options,(uchar *)"terminal.vt110.type");
  poVar1->value = 1;
  poVar1 = get_opt_rec(config_options,(uchar *)"terminal.xterm.type");
  poVar1->value = 1;
  poVar1 = get_opt_rec(config_options,(uchar *)"terminal.xterm.underline");
  poVar1->value = 1;
  poVar1 = get_opt_rec(config_options,(uchar *)"terminal.xterm-color.type");
  poVar1->value = 1;
  poVar1 = get_opt_rec(config_options,(uchar *)"terminal.xterm-color.colors");
  poVar1->value = 1;
  poVar1 = get_opt_rec(config_options,(uchar *)"terminal.xterm-color.underline");
  poVar1->value = 1;
  poVar1 = get_opt_rec(config_options,(uchar *)"terminal.xterm-88color.type");
  poVar1->value = 1;
  poVar1 = get_opt_rec(config_options,(uchar *)"terminal.xterm-88color.colors");
  poVar1->value = 2;
  poVar1 = get_opt_rec(config_options,(uchar *)"terminal.xterm-88color.underline");
  poVar1->value = 1;
  poVar1 = get_opt_rec(config_options,(uchar *)"terminal.xterm-256color.type");
  poVar1->value = 1;
  poVar1 = get_opt_rec(config_options,(uchar *)"terminal.xterm-256color.colors");
  poVar1->value = 3;
  poVar1 = get_opt_rec(config_options,(uchar *)"terminal.xterm-256color.underline");
  poVar1->value = 1;
  register_change_hooks(change_hooks);
  return;
}



option_elinks * indirect_option(option_elinks *alias)

{
  option_elinks *poVar1;
  
  if (alias->type != OPT_ALIAS) {
    return alias;
  }
  poVar1 = get_opt_rec(config_options,(uchar *)alias->value);
  if (assert_failed == 0) {
    assert_failed = ZEXT14(poVar1 == (option_elinks *)0x0);
    if (poVar1 != (option_elinks *)0x0) {
      return poVar1;
    }
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
    errline = 0x10a;
    elinks_internal((uchar *)"assertion real != NULL failed: %s aliased to unknown option %s!",
                    alias->name,alias->value);
    if (assert_failed == 0) {
      return (option_elinks *)0x0;
    }
  }
  assert_failed = 0;
  return alias;
}



option_elinks * get_opt_rec_real(option_elinks *tree,uchar *name)

{
  option_elinks *poVar1;
  
  no_autocreate = 1;
  poVar1 = get_opt_rec(tree,name);
  no_autocreate = 0;
  return poVar1;
}



uchar * bool_cmd(option_elinks *o,uchar ***argv,int *argc)

{
  uchar uVar1;
  uchar **ppuVar2;
  
  o->value = 1;
  if (*argc != 0) {
    ppuVar2 = *argv;
    uVar1 = **ppuVar2;
    if ((uVar1 != '\0') && ((*ppuVar2)[1] == '\0')) {
      if (uVar1 == '0') {
        o->value = 0;
        ppuVar2 = *argv;
      }
      else {
        if (uVar1 != '1') {
          return (uchar *)0x0;
        }
        o->value = 1;
      }
      *argv = ppuVar2 + 1;
      *argc = *argc + -1;
    }
  }
  return (uchar *)0x0;
}



uchar * exec_cmd(option_elinks *o,uchar ***argv,int *argc)

{
  uchar *puVar1;
  
                    // WARNING: Could not recover jumptable at 0x0807543d. Too many branches
                    // WARNING: Treating indirect jump as call
  puVar1 = (uchar *)(*(code *)o->value)();
  return puVar1;
}



int num_set(option_elinks *opt,uchar *str)

{
  opt->value = *(undefined4 *)str;
  return 1;
}



int num_eq(option_elinks *opt,uchar *str)

{
  uint uVar1;
  
  uVar1 = 0;
  if (str != (uchar *)0x0) {
    uVar1 = (uint)(opt->value == *(int *)str);
  }
  return uVar1;
}



int long_set(option_elinks *opt,uchar *str)

{
  opt->value = *(undefined4 *)str;
  return 1;
}



int long_eq(option_elinks *opt,uchar *str)

{
  uint uVar1;
  
  uVar1 = 0;
  if (str != (uchar *)0x0) {
    uVar1 = (uint)(opt->value == *(int *)str);
  }
  return uVar1;
}



int str_eq(option_elinks *opt,uchar *str)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = 0;
  if (str != (uchar *)0x0) {
    iVar2 = strcmp((char *)opt->value,(char *)str);
    uVar1 = (uint)(iVar2 == 0);
  }
  return uVar1;
}



// WARNING: Type propagation algorithm not settling

void tree_dup(option_elinks *opt,option_elinks *template)

{
  option_elinks *poVar1;
  option_elinks *template_00;
  listbox_item *plVar2;
  list_head_elinks *name;
  option_elinks *poVar3;
  option_value *poVar4;
  int iVar5;
  uchar *puVar6;
  uchar *puVar7;
  bool bVar8;
  byte bVar9;
  
  bVar9 = 0;
  name = init_options_tree();
  poVar1 = (option_elinks *)template->value;
  if (name != (list_head_elinks *)0x0) {
    *(list_head_elinks **)&opt->value = name;
    template_00 = poVar1->prev;
    while (template_00 != poVar1) {
      poVar3 = copy_option(template_00);
      if (poVar3 != (option_elinks *)0x0) {
        poVar3->next = *(option_elinks **)name->prev;
        poVar3->prev = (option_elinks *)name->prev;
        ((option_elinks *)name->prev)->next = poVar3;
        poVar3->next->prev = poVar3;
        plVar2 = poVar3->box_item;
        poVar3->root = opt;
        if (plVar2 != (listbox_item *)0x0) {
          bVar8 = poVar3->name == (uchar *)0x0;
          if (!bVar8) {
            iVar5 = 0xb;
            puVar6 = poVar3->name;
            puVar7 = "_template_";
            do {
              if (iVar5 == 0) break;
              iVar5 = iVar5 + -1;
              bVar8 = *puVar6 == *puVar7;
              puVar6 = puVar6 + (uint)bVar9 * -2 + 1;
              puVar7 = puVar7 + (uint)bVar9 * -2 + 1;
            } while (bVar8);
            if (bVar8) {
              poVar4 = get_opt_(config_options,(uchar *)name);
              *(byte *)&plVar2->field_0x18 =
                   *(byte *)&plVar2->field_0x18 & 0xfd | ((byte)*poVar4 & 1) * '\x02';
            }
          }
          if (opt->box_item != (listbox_item *)0x0) {
            poVar3->box_item->next = (listbox_item *)(opt->box_item->child).next;
            poVar3->box_item->prev = (listbox_item *)&opt->box_item->child;
            *(listbox_item **)&(opt->box_item->child).next = poVar3->box_item;
            poVar3->box_item->next->prev = poVar3->box_item;
          }
        }
      }
      template_00 = template_00->prev;
    }
  }
  return;
}



int redir_eq(option_elinks *opt,uchar *str)

{
  option_elinks *poVar1;
  int iVar2;
  anon_subr_int_option_elinks_ptr_uchar_ptr_for_equals *paVar3;
  uint local_20 [4];
  
  poVar1 = get_opt_rec(config_options,(uchar *)opt->value);
  if (assert_failed == 0) {
    assert_failed = ZEXT14(poVar1 == (option_elinks *)0x0);
    if (poVar1 == (option_elinks *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c";
      errline = 0xab;
      elinks_internal((uchar *)"assertion real != NULL failed: %s aliased to unknown option %s!",
                      opt->name,opt->value);
      if (assert_failed != 0) goto LAB_080756c0;
    }
    paVar3 = option_types[poVar1->type].equals;
    iVar2 = 0;
    if (paVar3 != (anon_subr_int_option_elinks_ptr_uchar_ptr_for_equals *)0x0) {
      if (((*(byte *)((int)&opt->flags + 1) & 1) != 0) && (poVar1->type == OPT_BOOL)) {
        iVar2 = *(int *)str;
        str = (uchar *)local_20;
        local_20[0] = (uint)(iVar2 == 0);
        paVar3 = option_types[poVar1->type].equals;
      }
      iVar2 = (*paVar3)(poVar1,str);
    }
  }
  else {
LAB_080756c0:
    assert_failed = 0;
    iVar2 = 0;
  }
  return iVar2;
}



int redir_set(option_elinks *opt,uchar *str)

{
  option_elinks *poVar1;
  int iVar2;
  anon_subr_int_option_elinks_ptr_uchar_ptr_for_set *paVar3;
  uint local_20 [4];
  
  poVar1 = get_opt_rec(config_options,(uchar *)opt->value);
  if (assert_failed == 0) {
    assert_failed = ZEXT14(poVar1 == (option_elinks *)0x0);
    if (poVar1 == (option_elinks *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c";
      errline = 0x95;
      elinks_internal((uchar *)"assertion real != NULL failed: %s aliased to unknown option %s!",
                      opt->name,opt->value);
      if (assert_failed != 0) goto LAB_080757b0;
    }
    paVar3 = option_types[poVar1->type].set;
    iVar2 = 0;
    if (paVar3 != (anon_subr_int_option_elinks_ptr_uchar_ptr_for_set *)0x0) {
      if (((*(byte *)((int)&opt->flags + 1) & 1) != 0) && (poVar1->type == OPT_BOOL)) {
        iVar2 = *(int *)str;
        str = (uchar *)local_20;
        local_20[0] = (uint)(iVar2 == 0);
        paVar3 = option_types[poVar1->type].set;
      }
      iVar2 = (*paVar3)(poVar1,str);
    }
  }
  else {
LAB_080757b0:
    assert_failed = 0;
    iVar2 = 0;
  }
  return iVar2;
}



// WARNING: Exceeded maximum restarts with more pending

void redir_wr(option_elinks *opt,string *string)

{
  option_elinks *poVar1;
  
  poVar1 = get_opt_rec(config_options,(uchar *)opt->value);
  if (assert_failed == 0) {
    assert_failed = ZEXT14(poVar1 == (option_elinks *)0x0);
    if (poVar1 == (option_elinks *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c";
      errline = 0x88;
      elinks_internal((uchar *)"assertion real != NULL failed: %s aliased to unknown option %s!",
                      opt->name,opt->value);
      if (assert_failed != 0) goto LAB_08075890;
    }
    if (option_types[poVar1->type].write !=
        (anon_subr_void_option_elinks_ptr_string_ptr_for_write *)0x0) {
                    // WARNING: Could not recover jumptable at 0x08075849. Too many branches
                    // WARNING: Treating indirect jump as call
      (*option_types[poVar1->type].write)();
      return;
    }
  }
  else {
LAB_08075890:
    assert_failed = 0;
  }
  return;
}



uchar * redir_rd(option_elinks *opt,uchar **file,int *line)

{
  option_elinks *poVar1;
  uint *puVar2;
  
  poVar1 = get_opt_rec(config_options,(uchar *)opt->value);
  if (assert_failed == 0) {
    assert_failed = ZEXT14(poVar1 == (option_elinks *)0x0);
    if (poVar1 == (option_elinks *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c";
      errline = 0x76;
      elinks_internal((uchar *)"assertion real != NULL failed: %s aliased to unknown option %s!",
                      opt->name,opt->value);
      if (assert_failed != 0) goto LAB_080758db;
    }
    puVar2 = (uint *)0x0;
    if ((((option_types[poVar1->type].read !=
           (anon_subr_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_int_ptr_for_read *)0x0) &&
         (puVar2 = (uint *)(*option_types[poVar1->type].read)(poVar1,file,line),
         puVar2 != (uint *)0x0)) && ((*(byte *)((int)&opt->flags + 1) & 1) != 0)) &&
       (poVar1->type == OPT_BOOL)) {
      *puVar2 = (uint)(*puVar2 == 0);
      return (uchar *)puVar2;
    }
  }
  else {
LAB_080758db:
    assert_failed = 0;
    puVar2 = (uint *)0x0;
  }
  return (uchar *)puVar2;
}



uchar * redir_cmd(option_elinks *opt,uchar ***argv,int *argc)

{
  option_elinks *poVar1;
  uchar *puVar2;
  
  poVar1 = get_opt_rec(config_options,(uchar *)opt->value);
  if (assert_failed == 0) {
    assert_failed = ZEXT14(poVar1 == (option_elinks *)0x0);
    if (poVar1 == (option_elinks *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c";
      errline = 99;
      elinks_internal((uchar *)"assertion real != NULL failed: %s aliased to unknown option %s!",
                      opt->name,opt->value);
      if (assert_failed != 0) goto LAB_080759bb;
    }
    puVar2 = (uchar *)0x0;
    if (((option_types[poVar1->type].cmdline !=
          (anon_subr_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_ptr_int_ptr_for_cmdline *)0x0) &&
        (puVar2 = (*option_types[poVar1->type].cmdline)(poVar1,argv,argc),
        (*(byte *)((int)&opt->flags + 1) & 1) != 0)) && (poVar1->type == OPT_BOOL)) {
      poVar1->value = (uint)(poVar1->value == 0);
      return puVar2;
    }
  }
  else {
LAB_080759bb:
    assert_failed = 0;
    puVar2 = (uchar *)0x0;
  }
  return puVar2;
}



uchar * get_option_type_name(option_type type)

{
  if (assert_failed == 0) {
    assert_failed = ZEXT14(OPT_TREE < type);
    if (OPT_TREE < type) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c";
      errline = 500;
      elinks_internal((uchar *)
                      "assertion type >= 0 && type < sizeof(option_types)/sizeof(struct option_type_info) failed!"
                     );
      if (assert_failed != 0) goto LAB_08075ad8;
    }
    return option_types[type].name;
  }
LAB_08075ad8:
  assert_failed = 0;
  return "";
}



int color_eq(option_elinks *opt,uchar *str)

{
  size_t slen;
  int iVar1;
  color_T local_10 [2];
  
  if (str != (uchar *)0x0) {
    slen = strlen((char *)str);
    iVar1 = decode_color(str,slen,local_10);
    if (iVar1 == 0) {
      return (uint)(opt->value == local_10[0]);
    }
  }
  return 0;
}



int color_set(option_elinks *opt,uchar *str)

{
  size_t slen;
  int iVar1;
  
  slen = strlen((char *)str);
  iVar1 = decode_color(str,slen,&opt->value);
  return (uint)(iVar1 == 0);
}



void __regparm3 add_optstring_to_string(string *s,uchar *q,int qlen)

{
  if (commandline == 0) {
    add_char_to_string(s,'\"');
  }
  add_quoted_to_string(s,q,qlen);
  if (commandline == 0) {
    add_char_to_string(s,'\"');
  }
  return;
}



void color_wr(option_elinks *opt,string *str)

{
  int iVar1;
  uchar *q;
  size_t qlen;
  int in_GS_OFFSET;
  uchar hexcolor [8];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  q = get_color_string(opt->value,hexcolor);
  qlen = strlen((char *)q);
  add_optstring_to_string(str,q,qlen);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void str_wr(option_elinks *o,string *s)

{
  uchar *q;
  size_t sVar1;
  size_t qlen;
  
  q = (uchar *)o->value;
  sVar1 = strlen((char *)q);
  qlen = o->max - 1;
  if ((int)sVar1 <= (int)qlen) {
    qlen = sVar1;
  }
  add_optstring_to_string(s,q,qlen);
  return;
}



int lang_eq(option_elinks *opt,uchar *str)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = 0;
  if (str != (uchar *)0x0) {
    iVar2 = name_to_language(str);
    uVar1 = (uint)(iVar2 == opt->value);
  }
  return uVar1;
}



int lang_set(option_elinks *opt,uchar *str)

{
  int language;
  
  language = name_to_language(str);
  opt->value = language;
  set_language(language);
  return 1;
}



void lang_wr(option_elinks *o,string *s)

{
  uchar *q;
  size_t qlen;
  
  q = language_to_name(current_language);
  qlen = strlen((char *)q);
  add_optstring_to_string(s,q,qlen);
  return;
}



int cp_eq(option_elinks *opt,uchar *str)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = 0;
  if (str != (uchar *)0x0) {
    iVar2 = get_cp_index(str);
    uVar1 = (uint)(iVar2 == opt->value);
  }
  return uVar1;
}



int cp_set(option_elinks *opt,uchar *str)

{
  int iVar1;
  
  iVar1 = get_cp_index(str);
  if (-1 < iVar1) {
    opt->value = iVar1;
  }
  return (uint)(-1 < iVar1);
}



void cp_wr(option_elinks *o,string *s)

{
  uchar *q;
  size_t qlen;
  
  q = get_cp_config_name(o->value);
  qlen = strlen((char *)q);
  add_optstring_to_string(s,q,qlen);
  return;
}



int str_set(option_elinks *opt,uchar *str)

{
  bool bVar1;
  
  if ((assert_failed == 0) && (bVar1 = opt->value == 0, assert_failed = ZEXT14(bVar1), bVar1)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c";
    errline = 0x141;
    elinks_internal((uchar *)"assertion opt->value.string failed!");
  }
  safe_strncpy((uchar *)opt->value,str,0x400);
  return 1;
}



void str_dup(option_elinks *opt,option_elinks *template)

{
  uchar *dst;
  
  dst = (uchar *)mem_alloc(0x400);
  if (dst != (uchar *)0x0) {
    safe_strncpy(dst,(uchar *)template->value,0x400);
  }
  *(uchar **)&opt->value = dst;
  return;
}



uchar * str_rd(option_elinks *opt,uchar **file,int *line)

{
  uchar character;
  string *psVar1;
  uchar *puVar2;
  uchar *puVar3;
  uchar *puVar4;
  string str2;
  
  puVar4 = *file;
  psVar1 = init_string(&str2);
  if (psVar1 == (string *)0x0) {
    return (uchar *)0x0;
  }
  if (commandline == 0) {
    if ((*puVar4 != '\'') && (*puVar4 != '\"')) goto LAB_08075fcb;
    puVar4 = puVar4 + 1;
  }
  character = *puVar4;
  while (character != '\0') {
    if ((commandline == 0) && ((character == '\'' || (character == '\"')))) {
      if (character == '\0') goto LAB_08075fa2;
      *file = puVar4 + 1;
      goto LAB_08075f64;
    }
    puVar3 = puVar4 + 1;
    puVar2 = puVar4;
    if (character == '\\') {
      character = puVar4[1];
      puVar2 = puVar4 + 1;
      if (character == '\n') {
        puVar4[1] = ' ';
        puVar3 = puVar4 + 2;
        *line = *line + 1;
        goto LAB_08075ed8;
      }
      if ((character == '\'') || (character == '\"')) {
        puVar3 = puVar4 + 2;
      }
      else {
        puVar3 = puVar2;
        puVar2 = puVar4;
        if (character != '\\') goto LAB_08075ed8;
        puVar3 = puVar4 + 2;
      }
    }
    else {
LAB_08075ed8:
      character = *puVar2;
      if (character == '\n') {
        *line = *line + 1;
        character = *puVar2;
      }
    }
    add_char_to_string(&str2,character);
    character = *puVar3;
    puVar4 = puVar3;
  }
  if (commandline == 0) {
LAB_08075fa2:
    done_string(&str2);
    *file = puVar4;
    return (uchar *)0x0;
  }
LAB_08075f64:
  if (opt == (option_elinks *)0x0) {
    return str2.source;
  }
  if (opt->max == 0) {
    return str2.source;
  }
  if (str2.length < opt->max) {
    return str2.source;
  }
LAB_08075fcb:
  done_string(&str2);
  return (uchar *)0x0;
}



void long_wr(option_elinks *option_elinks,string *string)

{
  add_knum_to_string(string,option_elinks->value);
  return;
}



void num_wr(option_elinks *option_elinks,string *string)

{
  add_knum_to_string(string,option_elinks->value);
  return;
}



uchar * gen_cmd(option_elinks *o,uchar ***argv,int *argc)

{
  uchar *p;
  int iVar1;
  int local_20 [4];
  
  local_20[0] = 0;
  if (*argc == 0) {
    p = gettext((uchar *)"Parameter expected");
  }
  else {
    commandline = 1;
    p = (*option_types[o->type].read)(o,*argv,local_20);
    commandline = 0;
    if (p != (uchar *)0x0) {
      *argv = *argv + 1;
      *argc = *argc + -1;
      iVar1 = (*option_types[o->type].set)(o,p);
      if (iVar1 != 0) {
        mem_free(p);
        return (uchar *)0x0;
      }
      mem_free(p);
    }
    p = gettext((uchar *)"Read error");
  }
  return p;
}



uchar * num_rd(option_elinks *opt,uchar **file,int *line)

{
  byte bVar1;
  int *p;
  long lVar2;
  ushort **ppuVar3;
  int *piVar4;
  byte *local_20 [4];
  
  local_20[0] = *file;
  p = (int *)mem_alloc(4);
  piVar4 = (int *)0x0;
  if (p != (int *)0x0) {
    lVar2 = strtolx(*file,local_20);
    *p = lVar2;
    if (commandline == 0) {
      *file = local_20[0];
    }
    bVar1 = *local_20[0];
    if ((((bVar1 != 0) &&
         ((commandline != 0 ||
          ((ppuVar3 = __ctype_b_loc(), (*(byte *)((int)*ppuVar3 + (uint)bVar1 * 2 + 1) & 0x20) == 0
           && (bVar1 != 0x23)))))) || (*p < opt->min)) || (piVar4 = p, opt->max < *p)) {
      mem_free(p);
      piVar4 = (int *)0x0;
    }
  }
  return (uchar *)piVar4;
}



void done_timer(module *module)

{
  kill_timer(&periodic_save_timer);
  return;
}



void periodic_save_handler(void *xxx)

{
  int periodic_save_event_id;
  int *piVar1;
  long *plVar2;
  milliseconds_T delay;
  uchar *in_EDX;
  uchar *extraout_EDX;
  uchar *name;
  uchar *extraout_EDX_00;
  char *local_18;
  
  local_18 = "anonymous";
  piVar1 = get_opt_(cmdline_options,in_EDX);
  if (*piVar1 == 0) {
    if (periodic_save_event_id == -1) {
      periodic_save_event_id = get_event_id((uchar *)"periodic-saving");
      name = extraout_EDX_00;
    }
    else {
      trigger_event(periodic_save_event_id,local_18);
      name = extraout_EDX;
    }
    plVar2 = get_opt_(config_options,name);
    delay = sec_to_ms(*plVar2);
    if (delay != 0) {
      install_timer(&periodic_save_timer,delay,periodic_save_handler,(void *)0x0);
      return;
    }
    if ((assert_failed == 0) &&
       (assert_failed = ZEXT14(periodic_save_timer != (timer_id_T)0x0),
       periodic_save_timer != (timer_id_T)0x0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/timer.c";
      errline = 0x2a;
      elinks_internal((uchar *)"assertion periodic_save_timer == TIMER_ID_UNDEF failed!");
      return;
    }
  }
  return;
}



void init_timer(module *module)

{
  change_hook_info timer_change_hooks [2];
  
  register_change_hooks((change_hook_info *)&ram0x08101800);
  periodic_save_handler((void *)0x0);
  return;
}



int periodic_save_change_hook(session *ses,option_elinks *current,option_elinks *changed)

{
  int *piVar1;
  uchar *in_EDX;
  
  piVar1 = get_opt_(cmdline_options,in_EDX);
  if (*piVar1 == 0) {
    kill_timer(&periodic_save_timer);
    periodic_save_handler((void *)0x0);
  }
  return 0;
}



evhook_status goto_url_history_write_hook(va_list ap,void *data)

{
  save_input_history(&goto_url_history,(uchar *)"gotohist");
  return EVENT_HOOK_STATUS_NEXT;
}



void done_url_history(module *module)

{
  input_history *p;
  input_history *piVar1;
  input_history *piVar2;
  input_history *piVar3;
  
  save_input_history(&goto_url_history,(uchar *)"gotohist");
  piVar3 = (input_history *)goto_url_history.entries.next;
  p = (input_history *)goto_url_history.entries.prev;
  if ((input_history *)goto_url_history.entries.next != &goto_url_history) {
    do {
      piVar3 = (input_history *)(piVar3->entries).next;
    } while (piVar3 != &goto_url_history);
  }
  while (p != piVar3) {
    p = (input_history *)(p->entries).prev;
  }
  piVar2 = *(input_history **)goto_url_history.entries.next;
  p = (input_history *)goto_url_history.entries.next;
  while (piVar1 = piVar2, p != piVar3) {
    (piVar1->entries).prev = (p->entries).prev;
    *(void **)(p->entries).prev = (p->entries).next;
    mem_free(p);
    piVar2 = (input_history *)(piVar1->entries).next;
    p = piVar1;
  }
  return;
}



void init_url_history(module *module)

{
  load_input_history(&goto_url_history,(uchar *)"gotohist");
  return;
}



void save_cookies(terminal *term)

{
  void *pvVar1;
  list_head_elinks **pplVar2;
  int *piVar3;
  uchar *file_name;
  secure_save_info *ssi;
  time_t tVar4;
  int iVar5;
  undefined1 *puVar6;
  uchar *in_EDX;
  undefined1 *puVar7;
  list_head_elinks *plVar8;
  char *local_4c;
  
  if (cookies_nosave != 0) {
    if (assert_failed == 0) {
      assert_failed = ZEXT14(term != (terminal *)0x0);
      if (term == (terminal *)0x0) {
        return;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cookies/cookies.c";
      errline = 0x339;
      elinks_internal((uchar *)"assertion term == NULL failed!");
      if (assert_failed == 0) {
        return;
      }
    }
    assert_failed = 0;
    return;
  }
  if (elinks_home == (uchar *)0x0) {
    if (term == (terminal *)0x0) {
      return;
    }
    local_4c = "ELinks was started without a home directory.";
  }
  else {
    if ((term == (terminal *)0x0) && (cookies_dirty == 0)) {
      return;
    }
    piVar3 = get_opt_(cmdline_options,in_EDX);
    if (*piVar3 == 0) {
      file_name = straconcat(elinks_home,0x812b326,0);
      if (file_name != (uchar *)0x0) {
        ssi = secure_open(file_name);
        mem_free(file_name);
        if (ssi != (secure_save_info *)0x0) {
          tVar4 = time((time_t *)0x0);
          plVar8 = (list_head_elinks *)cookies.next;
          if ((list_head_elinks *)cookies.next != &cookies) {
            do {
              pvVar1 = plVar8[4].next;
              if ((pvVar1 != (void *)0x0) && (tVar4 < (int)pvVar1)) {
                puVar6 = (undefined1 *)plVar8[3].next;
                if (puVar6 == (undefined1 *)0x0) {
                  puVar6 = &DAT_0812e3d8;
                }
                puVar7 = (undefined1 *)plVar8[2].prev;
                if (puVar7 == (undefined1 *)0x0) {
                  puVar7 = &DAT_0812e3d8;
                }
                iVar5 = secure_fprintf(ssi,"%s\t%s\t%s\t%s\t%s\t%ld\t%d\n",plVar8[1].prev,
                                       plVar8[2].next,(int)plVar8[3].prev + 0x10,puVar7,puVar6,
                                       pvVar1,plVar8[4].prev);
                if (iVar5 < 0) break;
              }
              pplVar2 = (list_head_elinks **)&plVar8->next;
              plVar8 = *pplVar2;
            } while (*pplVar2 != &cookies);
          }
          secsave_errno = SS_ERR_OTHER;
          iVar5 = secure_close(ssi);
          if (iVar5 == 0) {
            cookies_dirty = 0;
            return;
          }
        }
        if (term == (terminal *)0x0) {
          return;
        }
        file_name = secsave_strerror(secsave_errno,term);
        info_box(term,MSGBOX_NO_TEXT_INTL,(uchar *)"Cannot save cookies",ALIGN_LEFT,file_name);
        return;
      }
      if (term == (terminal *)0x0) {
        return;
      }
      local_4c = "Out of memory";
    }
    else {
      if (term == (terminal *)0x0) {
        return;
      }
      local_4c = "ELinks was started with the -anonymous option.";
    }
  }
  info_box(term,0,(uchar *)"Cannot save cookies",ALIGN_LEFT,(uchar *)local_4c);
  return;
}



void resave_cookies_bottom_half(void *always_null)

{
  if ((cookies_options[4].option_elinks.value != 0) && (cookies_options[5].option_elinks.value != 0)
     ) {
    save_cookies((terminal *)0x0);
    return;
  }
  return;
}



void set_cookies_dirty(void)

{
  cookies_dirty = 1;
  register_bottom_half_do(resave_cookies_bottom_half,(void *)0x0);
  return;
}



cookie_server * get_cookie_server(uchar *host,int hostlen)

{
  cookie_server *pcVar1;
  size_t sVar2;
  int iVar3;
  cookie_server *data;
  listbox_item *plVar4;
  cookie_server *local_24;
  cookie_server *local_20;
  
  if ((list_head_elinks *)cookie_servers.next == &cookie_servers) {
    local_20 = (cookie_server *)0x0;
    local_24 = (cookie_server *)cookie_servers.next;
  }
  else {
    local_20 = (cookie_server *)0x0;
    local_24 = (cookie_server *)cookie_servers.next;
    do {
      sVar2 = strlen((char *)local_24->host);
      iVar3 = c_strncasecmp((char *)local_24->host,(char *)host,hostlen);
      if ((local_20 == (cookie_server *)0x0) &&
         ((0 < iVar3 || ((hostlen < (int)sVar2 && (iVar3 == 0)))))) {
        local_20 = local_24->prev;
      }
      if ((sVar2 == hostlen) && (iVar3 == 0)) {
        (local_24->object).refcount = (local_24->object).refcount + 1;
        return local_24;
      }
      local_24 = local_24->next;
    } while (local_24 != (cookie_server *)&cookie_servers);
  }
  data = (cookie_server *)mem_calloc(1,hostlen + 0x14);
  if (data != (cookie_server *)0x0) {
    memcpy(data->host,host,hostlen);
    plVar4 = add_listbox_item(&cookie_browser,(listbox_item *)0x0,BI_FOLDER,data,1);
    (data->object).refcount = (data->object).refcount + 1;
    data->box_item = plVar4;
    if (local_20 == (cookie_server *)0x0) {
      data->next = *(cookie_server **)cookie_servers.prev;
      data->prev = cookie_servers.prev;
      *(cookie_server **)cookie_servers.prev = data;
      data->next->prev = data;
      data->box_item->next->prev = data->box_item->prev;
      data->box_item->prev->next = data->box_item->next;
      data->box_item->next = *(listbox_item **)cookie_browser.root.child.prev;
      data->box_item->prev = cookie_browser.root.child.prev;
      *(listbox_item **)cookie_browser.root.child.prev = data->box_item;
      data->box_item->next->prev = data->box_item;
    }
    else {
      pcVar1 = local_20->next;
      data->prev = local_20;
      data->next = pcVar1;
      local_20->next = data;
      data->next->prev = data;
      if (local_24 != local_20) {
        data->box_item->next->prev = data->box_item->prev;
        data->box_item->prev->next = data->box_item->next;
        data->box_item->next = local_20->box_item->next;
        data->box_item->prev = local_20->box_item;
        local_20->box_item->next = data->box_item;
        data->box_item->next->prev = data->box_item;
      }
    }
  }
  return data;
}



void __regparm3 done_cookie_server(cookie_server *cs)

{
  int iVar1;
  
  iVar1 = (cs->object).refcount + -1;
  (cs->object).refcount = iVar1;
  if (iVar1 == 0) {
    if (cs->box_item != (listbox_item *)0x0) {
      done_listbox_item(&cookie_browser,cs->box_item);
    }
    cs->next->prev = cs->prev;
    cs->prev->next = cs->next;
    mem_free(cs);
  }
  return;
}



cookie * init_cookie(uchar *name,uchar *value,uchar *path,uchar *domain,cookie_server *server)

{
  cookie *p;
  
  p = (cookie *)mem_calloc(1,0x2c);
  if (p != (cookie *)0x0) {
    if ((((name != (uchar *)0x0) && (path != (uchar *)0x0)) && (value != (uchar *)0x0)) &&
       ((server != (cookie_server *)0x0 && (domain != (uchar *)0x0)))) {
      p->name = name;
      p->value = value;
      p->path = path;
      p->domain = domain;
      p->server = server;
      return p;
    }
    if (p != (cookie *)0x0) {
      mem_free(p);
    }
  }
  if (name != (uchar *)0x0) {
    mem_free(name);
  }
  if (value != (uchar *)0x0) {
    mem_free(value);
  }
  if (path != (uchar *)0x0) {
    mem_free(path);
  }
  if (domain != (uchar *)0x0) {
    mem_free(domain);
  }
  done_cookie_server(server);
  return (cookie *)0x0;
}



void done_cookie(cookie *c)

{
  if (c->box_item != (listbox_item *)0x0) {
    done_listbox_item(&cookie_browser,c->box_item);
  }
  if (c->server != (cookie_server *)0x0) {
    done_cookie_server(c->server);
  }
  if (c->name != (uchar *)0x0) {
    mem_free(c->name);
  }
  if (c->value != (uchar *)0x0) {
    mem_free(c->value);
  }
  if (c->path != (uchar *)0x0) {
    mem_free(c->path);
  }
  if (c->domain != (uchar *)0x0) {
    mem_free(c->domain);
  }
  mem_free(c);
  return;
}



void delete_cookie(cookie *c)

{
  c->next->prev = c->prev;
  c->prev->next = c->next;
  done_cookie(c);
  return;
}



void done_cookies(module *module)

{
  list_head_elinks **pplVar1;
  list_head_elinks *p;
  list_head_elinks *plVar2;
  list_head_elinks *plVar3;
  bool bVar4;
  
  plVar3 = (list_head_elinks *)c_domains.next;
  if ((list_head_elinks *)c_domains.next != &c_domains) {
    do {
      plVar3 = (list_head_elinks *)plVar3->next;
    } while (plVar3 != &c_domains);
  }
  plVar2 = (list_head_elinks *)c_domains.prev;
  if ((list_head_elinks *)c_domains.prev != plVar3) {
    do {
      pplVar1 = (list_head_elinks **)&plVar2->prev;
      plVar2 = *pplVar1;
    } while (*pplVar1 != plVar3);
  }
  plVar2 = *(list_head_elinks **)c_domains.next;
  p = (list_head_elinks *)c_domains.next;
  if ((list_head_elinks *)c_domains.next != plVar3) {
    do {
      plVar2->prev = p->prev;
      *(void **)p->prev = p->next;
      mem_free(p);
      bVar4 = plVar2 != plVar3;
      p = plVar2;
      plVar2 = (list_head_elinks *)plVar2->next;
    } while (bVar4);
  }
  if (cookies_nosave != 0) goto LAB_08076ad8;
  if (cookies_options[4].option_elinks.value == 0) goto LAB_08076ad8;
  save_cookies((terminal *)0x0);
  if ((list_head_elinks *)cookies.next != &cookies) {
    do {
      delete_cookie((cookie *)cookies.next);
LAB_08076ad8:
    } while ((list_head_elinks *)cookies.next != &cookies);
  }
  while ((list_head_elinks *)cookie_queries.next != &cookie_queries) {
    delete_cookie((cookie *)cookie_queries.next);
  }
  cookies_dirty = 0;
  return;
}



string * send_cookies(uri *uri)

{
  cookie *pcVar1;
  string header;
  int iVar2;
  uchar *server;
  time_t tVar3;
  size_t sVar4;
  size_t sVar5;
  cookie *c;
  list_head_elinks *plVar6;
  uchar *__s;
  uchar *puVar7;
  bool bVar8;
  byte bVar9;
  cookie *local_20;
  
  bVar9 = 0;
  server = uri->host;
  if (((server != (uchar *)0x0) && (uri->data != (uchar *)0x0)) &&
     (plVar6 = (list_head_elinks *)c_domains.next, (list_head_elinks *)c_domains.next != &c_domains)
     ) {
    while (iVar2 = is_in_domain((uchar *)(plVar6 + 1),server,(uint)*(ushort *)&uri->field_0x2e),
          iVar2 == 0) {
      plVar6 = (list_head_elinks *)plVar6->next;
      if (plVar6 == &c_domains) {
        return (string *)0x0;
      }
      server = uri->host;
    }
    server = get_uri_string(uri,URI_PATH);
    if (server != (uchar *)0x0) {
      init_string((string *)0x8149394);
      tVar3 = time((time_t *)0x0);
      c = (cookie *)cookies.next;
      local_20 = *(cookie **)cookies.next;
      if ((list_head_elinks *)cookies.next != &cookies) {
        do {
          iVar2 = is_in_domain(c->domain,uri->host,(uint)*(ushort *)&uri->field_0x2e);
          if (iVar2 == 0) {
LAB_08076be0:
            pcVar1 = local_20->next;
          }
          else {
            __s = c->path;
            sVar4 = strlen((char *)__s);
            sVar5 = strlen((char *)server);
            if (sVar5 < sVar4) goto LAB_08076be0;
            bVar8 = true;
            puVar7 = server;
            do {
              if (sVar4 == 0) break;
              sVar4 = sVar4 - 1;
              bVar8 = *__s == *puVar7;
              __s = __s + (uint)bVar9 * -2 + 1;
              puVar7 = puVar7 + (uint)bVar9 * -2 + 1;
            } while (bVar8);
            if (!bVar8) goto LAB_08076be0;
            if ((c->expires != 0) && (c->expires <= tVar3)) {
              delete_cookie(c);
              set_cookies_dirty();
              goto LAB_08076be0;
            }
            if ((c->secure != 0) && (uri->protocol != 10)) goto LAB_08076be0;
            if (header.length != 0) {
              add_to_string((string *)0x8149394,"; ");
            }
            add_to_string((string *)0x8149394,c->name);
            add_char_to_string((string *)0x8149394,'=');
            add_to_string((string *)0x8149394,c->value);
            pcVar1 = local_20->next;
          }
          bVar8 = local_20 != (cookie *)&cookies;
          c = local_20;
          local_20 = pcVar1;
        } while (bVar8);
      }
      mem_free(server);
      if (header.length == 0) {
        done_string((string *)0x8149394);
        return (string *)0x0;
      }
      return (string *)0x8149394;
    }
  }
  return (string *)0x0;
}



void accept_cookie(cookie *cookie)

{
  void *pvVar1;
  listbox_item *root;
  int iVar2;
  size_t sVar3;
  void **ppvVar4;
  list_head_elinks *plVar5;
  cookie *c;
  cookie *pcVar6;
  bool bVar7;
  
  root = cookie->server->box_item;
  if (root != (listbox_item *)0x0) {
    root = add_listbox_item(&cookie_browser,root,BI_LEAF,cookie,1);
    cookie->box_item = root;
  }
  if ((cookies_nosave == 0) &&
     (c = (cookie *)cookies.next, pcVar6 = *(cookie **)cookies.next,
     (list_head_elinks *)cookies.next != &cookies)) {
    do {
      iVar2 = c_strcasecmp((char *)c->name,(char *)cookie->name);
      if ((iVar2 == 0) &&
         (iVar2 = c_strcasecmp((char *)c->domain,(char *)cookie->domain), iVar2 == 0)) {
        delete_cookie(c);
      }
      bVar7 = pcVar6 != (cookie *)&cookies;
      c = pcVar6;
      pcVar6 = pcVar6->next;
    } while (bVar7);
  }
  *(list_head_elinks **)&cookie->prev = &cookies;
  cookie->next = cookies.next;
  cookies.next = cookie;
  cookie->next->prev = cookie;
  set_cookies_dirty();
  plVar5 = (list_head_elinks *)c_domains.next;
  if ((list_head_elinks *)c_domains.next != &c_domains) {
    do {
      iVar2 = c_strcasecmp((char *)(plVar5 + 1),(char *)cookie->domain);
      if (iVar2 == 0) {
        return;
      }
      plVar5 = (list_head_elinks *)plVar5->next;
    } while (plVar5 != &c_domains);
  }
  sVar3 = strlen((char *)cookie->domain);
  ppvVar4 = (void **)mem_alloc(sVar3 + 0xc);
  if (ppvVar4 == (void **)0x0) {
    return;
  }
  memcpy(ppvVar4 + 2,cookie->domain,sVar3 + 1);
  pvVar1 = plVar5->next;
  *(list_head_elinks **)(ppvVar4 + 1) = plVar5;
  *ppvVar4 = pvVar1;
  *(void ***)&plVar5->next = ppvVar4;
  *(void ***)((int)*ppvVar4 + 4) = ppvVar4;
  return;
}



void load_cookies(void)

{
  int iVar1;
  FILE *__stream;
  time_t tVar2;
  char *pcVar3;
  long lVar4;
  cookie *c;
  cookie_server *pcVar5;
  uchar *p;
  int iVar6;
  int iVar7;
  int in_GS_OFFSET;
  anon_struct_1 members [7];
  uchar in_buffer [6144];
  
  p = "cookies";
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((elinks_home == (uchar *)0x0) || (p = straconcat(elinks_home,0x812b326,0), p != (uchar *)0x0))
  {
    cookies_nosave = 1;
    done_cookies(&cookies_module);
    cookies_nosave = 0;
    __stream = fopen64((char *)p,"rb");
    if (elinks_home != (uchar *)0x0) {
      mem_free(p);
    }
    if (__stream != (FILE *)0x0) {
      cookies_nosave = 1;
      tVar2 = time((time_t *)0x0);
LAB_08076f35:
      pcVar3 = fgets((char *)in_buffer,0x1800,__stream);
      if (pcVar3 != (char *)0x0) {
        iVar7 = 0;
        iVar6 = 0;
        p = in_buffer;
        while (pcVar3 = strchr((char *)p,9), pcVar3 != (char *)0x0) {
          iVar7 = iVar7 + 1;
          members[iVar6].pos = p;
          *(char **)&members[iVar6].len = pcVar3 + -(int)p;
          iVar6 = iVar6 + 1;
          if (iVar7 == 7) {
            if (iVar6 == 7) goto LAB_08076fd3;
            goto LAB_08076f35;
          }
          p = (uchar *)(pcVar3 + 1);
        }
        if ((iVar6 == 6) && (pcVar3 = strchr((char *)p,10), pcVar3 != (char *)0x0)) {
          members[6].len = (int)(pcVar3 + -(int)p);
          members[6].pos = p;
LAB_08076fd3:
          lVar4 = strtol((char *)members[5].pos,(char **)0x0,10);
          if ((tVar2 < lVar4) && (lVar4 != 0)) {
            c = (cookie *)mem_calloc(1,0x2c);
            if (c != (cookie *)0x0) {
              pcVar5 = get_cookie_server(members[2].pos,members[2].len);
              c->server = pcVar5;
              p = memacpy(members[0].pos,members[0].len);
              c->name = p;
              p = memacpy(members[1].pos,members[1].len);
              c->value = p;
              p = memacpy(members[3].pos,members[3].len);
              c->path = p;
              p = memacpy(members[4].pos,members[4].len);
              c->domain = p;
              if ((((c->server == (cookie_server *)0x0) || (c->name == (uchar *)0x0)) ||
                  (c->value == (uchar *)0x0)) || ((c->path == (uchar *)0x0 || (p == (uchar *)0x0))))
              {
                done_cookie(c);
              }
              else {
                c->expires = lVar4;
                lVar4 = strtol((char *)members[6].pos,(char **)0x0,10);
                c->secure = (uint)(lVar4 != 0);
                accept_cookie(c);
              }
            }
          }
          else {
            set_cookies_dirty();
          }
        }
        goto LAB_08076f35;
      }
      cookies_nosave = 0;
      fclose(__stream);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void init_cookies(module *module)

{
  if (cookies_options[4].option_elinks.value == 0) {
    return;
  }
  load_cookies();
  return;
}



void set_cookie(uri *uri,uchar *str)

{
  cookie_str *pcVar1;
  parse_header_param pVar2;
  size_t __n;
  cookie_server *server;
  uchar *value;
  uchar *name;
  cookie *c;
  time_t tVar3;
  time_t tVar4;
  int iVar5;
  uint addresslen;
  uchar *domain;
  char *pcVar6;
  uchar uVar7;
  uchar *path;
  cookie_str cstr;
  uchar *local_28;
  uchar *local_24;
  uchar *local_20 [4];
  
  if (cookies_options[1].option_elinks.value == 0) {
    return;
  }
  pcVar1 = parse_cookie_str(&cstr,str);
  if (pcVar1 == (cookie_str *)0x0) {
    return;
  }
  pVar2 = parse_header_param(str,"path",local_20);
  domain = local_20[0];
  if (pVar2 == HEADER_PARAM_FOUND) {
    uVar7 = *local_20[0];
    if ((uVar7 == '\0') || (__n = strlen((char *)local_20[0]), domain[__n - 1] != '/')) {
      add_to_strn(local_20,"/");
      uVar7 = *local_20[0];
    }
    if (uVar7 != '/') {
      add_to_strn(local_20,"x");
      domain = local_20[0];
      __n = strlen((char *)local_20[0]);
      memmove(domain + 1,domain,__n - 1);
      *local_20[0] = '/';
    }
  }
  else {
    if (pVar2 != HEADER_PARAM_NOT_FOUND) {
      return;
    }
    local_20[0] = get_uri_string(uri,URI_PATH);
    if (local_20[0] == (uchar *)0x0) {
      return;
    }
    pcVar6 = strrchr((char *)local_20[0],0x2f);
    if (pcVar6 != (char *)0x0) {
      pcVar6[1] = '\0';
    }
  }
  pVar2 = parse_header_param(str,"domain",&local_24);
  if (pVar2 == HEADER_PARAM_NOT_FOUND) {
    local_24 = memacpy(uri->host,(uint)*(ushort *)&uri->field_0x2e);
  }
  domain = local_24;
  if ((local_24 != (uchar *)0x0) && (*local_24 == '.')) {
    __n = strlen((char *)local_24);
    memmove(domain,domain + 1,__n);
  }
  server = get_cookie_server(uri->host,(uint)*(ushort *)&uri->field_0x2e);
  path = local_20[0];
  domain = local_24;
  value = memacpy(cstr.val_start,(int)(cstr.val_end + -(int)cstr.val_start));
  name = memacpy(str,(int)(cstr.nam_end + -(int)str));
  c = init_cookie(name,value,path,domain,server);
  iVar5 = cookies_options[2].option_elinks.value;
  if (c == (cookie *)0x0) {
    return;
  }
  if (cookies_options[2].option_elinks.value != 0) {
    pVar2 = parse_header_param(str,(uchar *)"expires",&local_28);
    if (pVar2 == HEADER_PARAM_FOUND) {
      tVar3 = parse_date(&local_28,(uchar *)0x0,0,1);
      mem_free(local_28);
      if (tVar3 != 0) {
        if (0 < iVar5) {
          tVar4 = time((time_t *)0x0);
          iVar5 = tVar4 + iVar5 * 0x15180;
          if (iVar5 < tVar3) {
            tVar3 = iVar5;
          }
        }
        c->expires = tVar3;
      }
    }
    else {
      if (pVar2 != HEADER_PARAM_NOT_FOUND) {
        done_cookie(c);
        return;
      }
    }
  }
  pVar2 = parse_header_param(str,(uchar *)"secure",(uchar **)0x0);
  c->secure = (uint)(pVar2 == HEADER_PARAM_FOUND);
  addresslen = (uint)*(ushort *)&uri->field_0x2e;
  domain = uri->host;
  path = c->domain;
  value = path + 1;
  if (*path != '.') {
    value = path;
  }
  __n = strlen((char *)value);
  if ((int)__n <= (int)addresslen) {
    iVar5 = c_strncasecmp((char *)value,(char *)(domain + (addresslen - __n)),__n);
    if (iVar5 == 0) {
      if (addresslen == __n) goto LAB_08077420;
      iVar5 = is_ip_address(domain,addresslen);
      if (iVar5 == 0) {
        if ((cookies_options[3].option_elinks.value == 0) ||
           (((0 < (int)__n && (iVar5 = end_with_known_tld(value,__n), 0 < iVar5)) &&
            (value[iVar5 + -1] == '.')))) {
          iVar5 = 1;
        }
        else {
          iVar5 = 2;
        }
        uVar7 = *value;
        while (uVar7 != '\0') {
          if (uVar7 == '.') {
            if (iVar5 == 1) goto LAB_08077420;
            iVar5 = 1;
          }
          uVar7 = value[1];
          value = value + 1;
        }
      }
    }
    path = c->domain;
  }
  mem_free(path);
  domain = memacpy(uri->host,(uint)*(ushort *)&uri->field_0x2e);
  c->domain = domain;
LAB_08077420:
  if (cookies_options[1].option_elinks.value == 1) {
    *(list_head_elinks **)&c->prev = &cookie_queries;
    c->next = cookie_queries.next;
    cookie_queries.next = c;
    c->next->prev = c;
    add_questions_entry(accept_cookie_dialog,c);
  }
  else {
    accept_cookie(c);
  }
  return;
}



void lock_cookie(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + 1;
  return;
}



void unlock_cookie(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



int is_cookie_used(listbox_item *item)

{
  list_head_elinks *plVar1;
  
  if (item->type != BI_FOLDER) {
    return (uint)(*(int *)((int)item->udata + 8) != 0);
  }
  plVar1 = (list_head_elinks *)(item->child).next;
  while( true ) {
    if (plVar1 == &item->child) {
      return 0;
    }
    if (*(int *)((int)plVar1[3].prev + 8) != 0) break;
    plVar1 = (list_head_elinks *)plVar1->next;
  }
  return 1;
}



listbox_item * get_cookie_root(listbox_item *item)

{
  listbox_item *plVar1;
  
  plVar1 = (listbox_item *)0x0;
  if (item->type != BI_FOLDER) {
    plVar1 = *(listbox_item **)(*(int *)((int)item->udata + 0x1c) + 0xc);
  }
  return plVar1;
}



int can_delete_cookie(listbox_item *item)

{
  return 1;
}



void delete_cookie_item(listbox_item *item,int last)

{
  cookie *c;
  listbox_item *plVar1;
  listbox_item *item_00;
  listbox_item *plVar2;
  bool bVar3;
  
  c = (cookie *)item->udata;
  if (item->type != BI_FOLDER) {
    if ((assert_failed == 0) &&
       (bVar3 = (c->object).refcount != 0, assert_failed = ZEXT14(bVar3), bVar3)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cookies/dialogs.c";
      errline = 200;
      elinks_internal((uchar *)"assertion !is_object_used(cookie) failed!");
    }
    delete_cookie(c);
    set_cookies_dirty();
    return;
  }
  item_00 = (listbox_item *)(item->child).next;
  plVar2 = item_00->next;
  while (plVar1 = plVar2, item_00 != (listbox_item *)&item->child) {
    delete_cookie_item(item_00,0);
    plVar2 = plVar1->next;
    item_00 = plVar1;
  }
  return;
}



uchar * get_cookie_text(listbox_item *item,terminal *term)

{
  uchar *puVar1;
  
  if (item->type != BI_FOLDER) {
    puVar1 = stracpy(*(uchar **)((int)item->udata + 0xc));
    return puVar1;
  }
  puVar1 = stracpy((uchar *)((int)item->udata + 0x10));
  return puVar1;
}



widget_handler_status_T push_save_button(dialog_data *dlg_data,widget_data *button)

{
  save_cookies(dlg_data->win->term);
  return EVENT_PROCESSED;
}



widget_handler_status_T set_cookie_domain(dialog_data *dlg_data,widget_data *widget_data)

{
  void *pvVar1;
  uchar *src;
  
  pvVar1 = dlg_data->dlg->udata;
  src = widget_data->cdata;
  if ((pvVar1 != (void *)0x0) && (src != (uchar *)0x0)) {
    if (*(void **)((int)pvVar1 + 0x18) != (void *)0x0) {
      mem_free(*(void **)((int)pvVar1 + 0x18));
    }
    src = stracpy(src);
    *(uchar **)((int)pvVar1 + 0x18) = src;
    set_cookies_dirty();
    return EVENT_PROCESSED;
  }
  return EVENT_NOT_PROCESSED;
}



widget_handler_status_T set_cookie_value(dialog_data *dlg_data,widget_data *widget_data)

{
  void *pvVar1;
  uchar *src;
  
  pvVar1 = dlg_data->dlg->udata;
  src = widget_data->cdata;
  if ((pvVar1 != (void *)0x0) && (src != (uchar *)0x0)) {
    if (*(void **)((int)pvVar1 + 0x10) != (void *)0x0) {
      mem_free(*(void **)((int)pvVar1 + 0x10));
    }
    src = stracpy(src);
    *(uchar **)((int)pvVar1 + 0x10) = src;
    set_cookies_dirty();
    return EVENT_PROCESSED;
  }
  return EVENT_NOT_PROCESSED;
}



widget_handler_status_T set_cookie_name(dialog_data *dlg_data,widget_data *widget_data)

{
  void *pvVar1;
  uchar *src;
  
  pvVar1 = dlg_data->dlg->udata;
  src = widget_data->cdata;
  if ((pvVar1 != (void *)0x0) && (src != (uchar *)0x0)) {
    if (*(void **)((int)pvVar1 + 0xc) != (void *)0x0) {
      mem_free(*(void **)((int)pvVar1 + 0xc));
    }
    src = stracpy(src);
    *(uchar **)((int)pvVar1 + 0xc) = src;
    set_cookies_dirty();
    return EVENT_PROCESSED;
  }
  return EVENT_NOT_PROCESSED;
}



widget_handler_status_T set_cookie_secure(dialog_data *dlg_data,widget_data *widget_data)

{
  void *pvVar1;
  uchar *__nptr;
  int *piVar2;
  long lVar3;
  char *local_20 [4];
  
  pvVar1 = dlg_data->dlg->udata;
  __nptr = widget_data->cdata;
  if ((pvVar1 != (void *)0x0) && (__nptr != (uchar *)0x0)) {
    piVar2 = __errno_location();
    *piVar2 = 0;
    lVar3 = strtol((char *)__nptr,local_20,10);
    if ((*piVar2 == 0) && (*local_20[0] == '\0')) {
      *(uint *)((int)pvVar1 + 0x24) = (uint)(lVar3 != 0);
      set_cookies_dirty();
      return EVENT_PROCESSED;
    }
  }
  return EVENT_NOT_PROCESSED;
}



widget_handler_status_T set_cookie_expires(dialog_data *dlg_data,widget_data *widget_data)

{
  void *pvVar1;
  uchar *__nptr;
  int *piVar2;
  long lVar3;
  char *local_20 [4];
  
  pvVar1 = dlg_data->dlg->udata;
  __nptr = widget_data->cdata;
  if ((pvVar1 != (void *)0x0) && (__nptr != (uchar *)0x0)) {
    piVar2 = __errno_location();
    *piVar2 = 0;
    lVar3 = strtol((char *)__nptr,local_20,10);
    if ((*piVar2 == 0) && ((-1 < lVar3 && (*local_20[0] == '\0')))) {
      *(long *)((int)pvVar1 + 0x20) = lVar3;
      set_cookies_dirty();
      return EVENT_PROCESSED;
    }
  }
  return EVENT_NOT_PROCESSED;
}



void add_server_do(void *data)

{
  size_t hostlen;
  cookie_server *server;
  uchar *domain;
  uchar *path;
  uchar *value;
  uchar *name;
  cookie *cookie;
  
  if (data != (void *)0x0) {
    hostlen = strlen((char *)data);
    server = get_cookie_server((uchar *)data,hostlen);
    domain = stracpy((uchar *)data);
    path = stracpy("/");
    value = stracpy("1");
    name = stracpy("empty");
    cookie = init_cookie(name,value,path,domain,server);
    if (cookie != (cookie *)0x0) {
      accept_cookie(cookie);
      return;
    }
  }
  return;
}



void accept_cookie_in_msg_box(void *cookie_)

{
  accept_cookie((cookie *)cookie_);
  return;
}



void cookie_manager(session *ses)

{
  hierbox_browser(&cookie_browser,ses);
  return;
}



void reject_cookie_in_msg_box(void *cookie_)

{
  done_cookie((cookie *)cookie_);
  return;
}



widget_handler_status_T push_add_server_button(dialog_data *dlg_data,widget_data *button)

{
  terminal *term;
  dialog *dlg;
  widget_handler_status_T wVar1;
  int cp_index;
  uchar *codeset;
  memory_list *ml;
  bool bVar2;
  
  term = dlg_data->win->term;
  dlg = (dialog *)mem_calloc(1,0x4b4);
  wVar1 = EVENT_NOT_PROCESSED;
  if (dlg != (dialog *)0x0) {
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Add server");
    dlg->title = codeset;
    dlg->layouter = generic_dialog_layouter;
    dlg->udata = (void *)0x0;
    dlg->udata2 = (void *)0x0;
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Server name");
    add_dlg_field_do(dlg,WIDGET_FIELD,codeset,0,0,check_nonempty,0x400,&dlg[2].refresh,
                     (input_history *)0x0,INPFIELD_FLOAT);
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext("~OK");
    add_dlg_button_do(dlg,codeset,1,ok_dialog,(void *)0x0,add_server_do,&dlg[2].refresh);
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"~Cancel");
    add_dlg_button_do(dlg,codeset,2,cancel_dialog,(void *)0x0,(done_handler_T *)0x0,(void *)0x0);
    if ((assert_failed == 0) &&
       (bVar2 = dlg->number_of_widgets != 3, assert_failed = ZEXT14(bVar2), bVar2)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cookies/dialogs.c";
      errline = 0x1d8;
      elinks_internal((uchar *)"assertion 3 == (dlg)->number_of_widgets failed!");
    }
    ml = getml(dlg,0);
    do_dialog(term,dlg,ml);
    wVar1 = EVENT_PROCESSED;
  }
  return wVar1;
}



void __regparm3 build_edit_dialog(terminal *term,cookie *cookie)

{
  void **data;
  byte *s;
  cookie_server *pcVar1;
  dialog *dlg;
  int cp_index;
  uchar *codeset;
  uchar *codeset_00;
  memory_list *ml;
  bool bVar2;
  undefined4 local_68;
  undefined4 local_64;
  uint local_20 [4];
  
  local_20[0] = 0;
  dlg = (dialog *)mem_calloc(1,0x15a4);
  if (dlg != (dialog *)0x0) {
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext("Edit");
    dlg->title = codeset;
    *(cookie **)&dlg->udata = cookie;
    dlg->layouter = generic_dialog_layouter;
    dlg->udata2 = (void *)0x0;
    data = &dlg[0x29].widgets[0].data;
    s = dlg[0x35].widgets[0].info + 8;
    safe_strncpy((uchar *)(dlg + 5),cookie->name,0x400);
    safe_strncpy((uchar *)&dlg[0x11].layouter,cookie->value,0x400);
    safe_strncpy((uchar *)&dlg[0x1d].number_of_widgets,cookie->domain,0x400);
    elinks_ulongcat((uchar *)data,local_20,cookie->expires,'\0',0,10);
    local_20[0] = 0;
    local_64 = 0;
    local_68 = 10;
    elinks_ulongcat(s,local_20,cookie->secure,'\0',0,10);
    pcVar1 = cookie->server;
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Server");
    codeset = straconcat(codeset,0x8132e94,pcVar1->host,&DAT_08131ec3,0,local_68,local_64);
    if (codeset == (uchar *)0x0) {
      mem_free(dlg);
    }
    else {
      add_dlg_text(dlg,codeset,ALIGN_LEFT,0);
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      codeset_00 = gettext("Name");
      add_dlg_field_do(dlg,WIDGET_FIELD,codeset_00,0,0,set_cookie_name,0x400,dlg + 5,
                       (input_history *)0x0,INPFIELD_FLOAT);
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      codeset_00 = gettext((uchar *)"Value");
      add_dlg_field_do(dlg,WIDGET_FIELD,codeset_00,0,0,set_cookie_value,0x400,&dlg[0x11].layouter,
                       (input_history *)0x0,INPFIELD_FLOAT);
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      codeset_00 = gettext((uchar *)"Domain");
      add_dlg_field_do(dlg,WIDGET_FIELD,codeset_00,0,0,set_cookie_domain,0x400,
                       &dlg[0x1d].number_of_widgets,(input_history *)0x0,INPFIELD_FLOAT);
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      codeset_00 = gettext((uchar *)"Expires");
      add_dlg_field_do(dlg,WIDGET_FIELD,codeset_00,0,0,set_cookie_expires,0x400,data,
                       (input_history *)0x0,INPFIELD_FLOAT);
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      codeset_00 = gettext((uchar *)"Secure");
      add_dlg_field_do(dlg,WIDGET_FIELD,codeset_00,0,0,set_cookie_secure,0x400,s,
                       (input_history *)0x0,INPFIELD_FLOAT);
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      codeset_00 = gettext("~OK");
      add_dlg_button_do(dlg,codeset_00,1,ok_dialog,(void *)0x0,(done_handler_T *)0x0,(void *)0x0);
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      codeset_00 = gettext((uchar *)"~Cancel");
      add_dlg_button_do(dlg,codeset_00,2,cancel_dialog,(void *)0x0,(done_handler_T *)0x0,(void *)0x0
                       );
      if ((assert_failed == 0) &&
         (bVar2 = dlg->number_of_widgets != 8, assert_failed = ZEXT14(bVar2), bVar2)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/cookies/dialogs.c";
        errline = 0x177;
        elinks_internal((uchar *)"assertion 8 == (dlg)->number_of_widgets failed!");
      }
      ml = getml(dlg,codeset,0);
      do_dialog(term,dlg,ml);
    }
  }
  return;
}



widget_handler_status_T push_edit_button(dialog_data *dlg_data,widget_data *button)

{
  listbox_item *plVar1;
  listbox_data *plVar2;
  
  plVar2 = get_listbox_widget_data(dlg_data->widgets_data);
  plVar1 = plVar2->sel;
  if (((plVar1 != (listbox_item *)0x0) && (plVar1->type != BI_FOLDER)) &&
     ((cookie *)plVar1->udata != (cookie *)0x0)) {
    build_edit_dialog(dlg_data->win->term,(cookie *)plVar1->udata);
  }
  return EVENT_PROCESSED;
}



widget_handler_status_T push_add_button(dialog_data *dlg_data,widget_data *button)

{
  terminal *term;
  listbox_item *plVar1;
  listbox_data *plVar2;
  uchar *domain;
  uchar *path;
  uchar *value;
  uchar *name;
  cookie *cookie;
  cookie_server *server;
  bool bVar3;
  
  plVar2 = get_listbox_widget_data(dlg_data->widgets_data);
  term = dlg_data->win->term;
  plVar1 = plVar2->sel;
  if ((plVar1 != (listbox_item *)0x0) &&
     (server = (cookie_server *)plVar1->udata, server != (cookie_server *)0x0)) {
    if (plVar1->type == BI_FOLDER) {
      if (assert_failed == 0) {
        bVar3 = plVar1->depth != 0;
        assert_failed = ZEXT14(bVar3);
        if (bVar3) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/cookies/dialogs.c";
          errline = 0x197;
          elinks_internal((uchar *)"assertion box->sel->depth == 0 failed!");
        }
        server = (cookie_server *)plVar2->sel->udata;
      }
    }
    else {
      server = (cookie_server *)server[1].object.refcount;
    }
    (server->object).refcount = (server->object).refcount + 1;
    domain = stracpy(server->host);
    path = stracpy("/");
    value = stracpy("");
    name = stracpy("");
    cookie = init_cookie(name,value,path,domain,server);
    if (cookie != (cookie *)0x0) {
      accept_cookie(cookie);
      build_edit_dialog(term,cookie);
    }
  }
  return EVENT_PROCESSED;
}



void __regparm3 add_cookie_info_to_string(string *string,cookie *cookie,terminal *term)

{
  int cp_index;
  uchar *codeset;
  uchar *local_30;
  uchar **ppuVar1;
  uchar *name;
  
  local_30 = cookie->name;
  if ((term != (terminal *)0x0) &&
     (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
    codeset = get_cp_mime_name(cp_index);
    bind_textdomain_codeset("elinks",codeset);
    current_charset = cp_index;
  }
  codeset = gettext("Name");
  add_format_to_string(string,(uchar *)"\n%s: %s",codeset,local_30);
  local_30 = cookie->value;
  if ((term != (terminal *)0x0) &&
     (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
    codeset = get_cp_mime_name(cp_index);
    bind_textdomain_codeset("elinks",codeset);
    current_charset = cp_index;
  }
  codeset = gettext((uchar *)"Value");
  add_format_to_string(string,(uchar *)"\n%s: %s",codeset,local_30);
  local_30 = cookie->domain;
  if ((term != (terminal *)0x0) &&
     (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
    codeset = get_cp_mime_name(cp_index);
    bind_textdomain_codeset("elinks",codeset);
    current_charset = cp_index;
  }
  codeset = gettext((uchar *)"Domain");
  add_format_to_string(string,(uchar *)"\n%s: %s",codeset,local_30);
  local_30 = cookie->path;
  if ((term != (terminal *)0x0) &&
     (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
    codeset = get_cp_mime_name(cp_index);
    bind_textdomain_codeset("elinks",codeset);
    current_charset = cp_index;
  }
  codeset = gettext("Path");
  add_format_to_string(string,(uchar *)"\n%s: %s",codeset,local_30);
  if (cookie->expires == 0) {
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Expires");
    add_format_to_string(string,"\n%s: ",codeset,local_30);
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      local_30 = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",local_30);
      current_charset = cp_index;
    }
    local_30 = gettext((uchar *)"at quit time");
    add_to_string(string,local_30);
  }
  else {
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Expires");
    add_format_to_string(string,"\n%s: ",codeset,local_30);
    ppuVar1 = (uchar **)get_opt_(config_options,name);
    add_date_to_string(string,*ppuVar1,&cookie->expires);
  }
  local_30 = "yes";
  if (cookie->secure == 0) {
    local_30 = "no";
  }
  if (*local_30 != '\0') {
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    local_30 = gettext(local_30);
  }
  if ((term != (terminal *)0x0) &&
     (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
    codeset = get_cp_mime_name(cp_index);
    bind_textdomain_codeset("elinks",codeset);
    current_charset = cp_index;
  }
  codeset = gettext((uchar *)"Secure");
  add_format_to_string(string,(uchar *)"\n%s: %s",codeset,local_30);
  return;
}



uchar * get_cookie_info(listbox_item *item,terminal *term)

{
  cookie *cookie;
  cookie_server *pcVar1;
  string *psVar2;
  int cp_index;
  uchar *codeset;
  string string;
  
  cookie = (cookie *)item->udata;
  if (item->type != BI_FOLDER) {
    psVar2 = init_string(&string);
    if (psVar2 != (string *)0x0) {
      pcVar1 = cookie->server;
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext((uchar *)"Server");
      add_format_to_string(&string,"%s: %s",codeset,pcVar1->host);
      add_cookie_info_to_string(&string,cookie,term);
      return string.source;
    }
  }
  return (uchar *)0x0;
}



void accept_cookie_dialog(session *ses,void *data)

{
  int iVar1;
  terminal *term;
  void *udata;
  string *psVar2;
  int cp_index;
  uchar *codeset;
  string string;
  
  udata = cookie_queries.next;
  if ((assert_failed == 0) && (assert_failed = ZEXT14(ses == (session *)0x0), ses == (session *)0x0)
     ) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/cookies/dialogs.c";
    errline = 0x49;
    elinks_internal((uchar *)"assertion ses failed!");
  }
  if ((list_head_elinks *)cookie_queries.next != &cookie_queries) {
    psVar2 = init_string(&string);
    if (psVar2 != (string *)0x0) {
      *(undefined4 *)(*(int *)udata + 4) = *(undefined4 *)((int)udata + 4);
      **(undefined4 **)((int)udata + 4) = *(undefined4 *)udata;
      iVar1 = *(int *)((int)udata + 0x1c);
      term = ses->tab->term;
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext((uchar *)"Do you want to accept a cookie from %s?");
      add_format_to_string(&string,codeset,iVar1 + 0x10);
      add_to_string(&string,"\n\n");
      add_cookie_info_to_string(&string,(cookie *)udata,ses->tab->term);
      msg_box(ses->tab->term,(memory_list *)0x0,MSGBOX_FREE_TEXT,(uchar *)"Accept cookie?",
              ALIGN_LEFT,string.source,udata,2,"~Accept",accept_cookie_in_msg_box,1,"~Reject",
              reject_cookie_in_msg_box,2);
    }
  }
  return;
}



cookie_str * parse_cookie_str(cookie_str *cstr,uchar *str)

{
  ushort *puVar1;
  ushort **ppuVar2;
  byte *pbVar3;
  byte bVar4;
  
  cstr->nam_end = (uchar *)0x0;
  cstr->val_start = (uchar *)0x0;
  cstr->val_end = (uchar *)0x0;
  cstr->str = str;
  bVar4 = *str;
  if ((bVar4 != 0x3d) && (bVar4 != 0x3b)) {
    ppuVar2 = __ctype_b_loc();
    pbVar3 = str;
    while (((*(byte *)((int)*ppuVar2 + (uint)bVar4 * 2 + 1) & 0x20) == 0 && (bVar4 != 0))) {
      pbVar3 = pbVar3 + 1;
      bVar4 = *pbVar3;
      if ((bVar4 == 0x3d) || (bVar4 == 0x3b)) break;
    }
    if (pbVar3 != str) {
      cstr->nam_end = pbVar3;
      puVar1 = *ppuVar2;
      while (bVar4 = *pbVar3, (*(byte *)((int)puVar1 + (uint)bVar4 * 2 + 1) & 0x20) != 0) {
        pbVar3 = pbVar3 + 1;
      }
      if (bVar4 != 0x3b) {
        if (bVar4 == 0x3d) {
          do {
            pbVar3 = pbVar3 + 1;
          } while (*pbVar3 == 0x3d);
          bVar4 = *(byte *)((int)puVar1 + (uint)*pbVar3 * 2 + 1);
          while ((bVar4 & 0x20) != 0) {
            pbVar3 = pbVar3 + 1;
            bVar4 = *(byte *)((int)puVar1 + (uint)*pbVar3 * 2 + 1);
          }
          cstr->val_start = pbVar3;
          cstr->val_end = pbVar3;
          bVar4 = *pbVar3;
          if (bVar4 != 0x3b) {
            if (bVar4 == 0) {
              return cstr;
            }
            while( true ) {
              pbVar3 = pbVar3 + 1;
              if ((*(byte *)((int)*ppuVar2 + (uint)bVar4 * 2 + 1) & 0x20) == 0) {
                cstr->val_end = pbVar3;
              }
              bVar4 = *pbVar3;
              if (bVar4 == 0) break;
              if (bVar4 == 0x3b) {
                return cstr;
              }
            }
            return cstr;
          }
          return cstr;
        }
        if (bVar4 != 0) {
          return (cookie_str *)0x0;
        }
      }
      cstr->val_start = pbVar3;
      cstr->val_end = pbVar3;
      return cstr;
    }
  }
  return (cookie_str *)0x0;
}



void cached_header_dialog(session *ses,cache_entry *cached)

{
  uchar *__s;
  uchar *puVar1;
  size_t sVar2;
  uchar uVar3;
  int iVar4;
  byte bVar5;
  msgbox_flags flags;
  int iVar6;
  byte *pbVar7;
  char *local_20;
  
  if (((cached != (cache_entry *)0x0) && (__s = cached->head, __s != (uchar *)0x0)) &&
     (*__s != '\0')) {
    sVar2 = strlen((char *)__s);
    local_20 = (char *)mem_alloc(sVar2 + 1);
    if ((uchar *)local_20 == (uchar *)0x0) {
      return;
    }
    pbVar7 = cached->head;
    bVar5 = *pbVar7;
    if (bVar5 == 0) {
      *local_20 = '\0';
    }
    else {
      iVar6 = 0;
      iVar4 = 0;
      do {
        while ((bVar5 != 10 && (bVar5 < 0x20))) {
          if (bVar5 != 0xd) {
            ((uchar *)local_20)[iVar6] = '*';
            pbVar7 = cached->head;
            iVar6 = iVar6 + 1;
          }
          iVar4 = iVar4 + 1;
          bVar5 = pbVar7[iVar4];
          if (bVar5 == 0) goto LAB_08078dfe;
        }
        iVar4 = iVar4 + 1;
        ((uchar *)local_20)[iVar6] = bVar5;
        pbVar7 = cached->head;
        iVar6 = iVar6 + 1;
        bVar5 = pbVar7[iVar4];
      } while (bVar5 != 0);
LAB_08078dfe:
      ((uchar *)local_20)[iVar6] = '\0';
      if (iVar6 != 0) {
        iVar4 = iVar6 + -1;
        uVar3 = ((uchar *)local_20)[iVar4];
        __s = (uchar *)local_20 + iVar4;
        puVar1 = (uchar *)local_20 + iVar6 + -2;
        while (uVar3 == '\n') {
          *__s = '\0';
          if (iVar4 == 0) {
            uVar3 = *local_20;
            goto LAB_08078e3e;
          }
          uVar3 = *puVar1;
          iVar4 = iVar4 + -1;
          __s = puVar1;
          puVar1 = puVar1 + -1;
        }
      }
      uVar3 = *local_20;
LAB_08078e3e:
      flags = MSGBOX_FREE_TEXT|MSGBOX_SCROLLABLE;
      if (uVar3 != '\0') goto LAB_08078d55;
    }
    mem_free(local_20);
  }
  local_20 = s_No_header_info__0812b391;
  flags = 0;
LAB_08078d55:
  info_box(ses->tab->term,flags,(uchar *)"Header info",ALIGN_LEFT,(uchar *)local_20);
  return;
}



void nowhere_box(terminal *term,uchar *title)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(term == (terminal *)0x0);
  if (term == (terminal *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/document.c";
    errline = 0x27;
    elinks_internal((uchar *)"assertion term failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if ((title == (uchar *)0x0) || (*title == '\0')) {
    title = "Info";
  }
  info_box(term,0,title,ALIGN_CENTER,(uchar *)"You are nowhere!");
  return;
}



void protocol_header_dialog(session *ses)

{
  document *pdVar1;
  
  if ((ses->history).current != (location *)0x0) {
    if ((ses->doc_view != (document_view *)0x0) &&
       (pdVar1 = ses->doc_view->document, pdVar1 != (document *)0x0)) {
      cached_header_dialog(ses,pdVar1->cached);
    }
    return;
  }
  nowhere_box(ses->tab->term,(uchar *)"Header info");
  return;
}



uchar * __regparm3 _(terminal *term)

{
  int cp_index;
  uchar *codeset;
  terminal *in_EDX;
  
  if ((term != (terminal *)0x0) && (*(char *)&term->next != '\0')) {
    if (in_EDX != (terminal *)0x0) {
      cp_index = get_terminal_codepage(in_EDX);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    term = (terminal *)gettext((uchar *)term);
  }
  return (uchar *)term;
}



void document_info_dialog(session *ses)

{
  terminal *term;
  location *plVar1;
  cache_entry *pcVar2;
  cp_status cVar3;
  terminal *term_00;
  uint uVar4;
  document_view *doc_view;
  string *psVar5;
  int cp_index;
  uchar *codeset;
  uchar *codeset_00;
  global_history_item *pgVar6;
  undefined4 *puVar7;
  uint size;
  undefined4 *puVar8;
  link *plVar9;
  char *term_01;
  int iVar10;
  uint uVar11;
  undefined4 local_60;
  undefined4 local_5c;
  string img;
  string msg;
  
  term = ses->tab->term;
  plVar1 = (ses->history).current;
  if (plVar1 == (location *)0x0) {
    nowhere_box(term,(uchar *)0x0);
    return;
  }
  doc_view = current_frame(ses);
  psVar5 = init_string(&msg);
  if (psVar5 == (string *)0x0) {
    return;
  }
  if ((term != (terminal *)0x0) &&
     (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
    codeset = get_cp_mime_name(cp_index);
    bind_textdomain_codeset("elinks",codeset);
    current_charset = cp_index;
  }
  codeset = gettext("URL");
  add_to_string(&msg,codeset);
  add_to_string(&msg,": ");
  add_uri_to_string(&msg,(plVar1->vs).uri,URI_PUBLIC);
  add_char_to_string(&msg,'\n');
  if ((doc_view != (document_view *)0x0) &&
     (codeset = doc_view->document->title, codeset != (uchar *)0x0)) {
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset_00 = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset_00);
      current_charset = cp_index;
    }
    codeset_00 = gettext((uchar *)"Title");
    add_format_to_string(&msg,"%s: %s",codeset_00,codeset);
  }
  add_char_to_string(&msg,'\n');
  pcVar2 = doc_view->document->cached;
  if (pcVar2 != (cache_entry *)0x0) {
    local_60 = *(undefined4 *)&pcVar2->length;
    local_5c = *(undefined4 *)((int)&pcVar2->length + 4);
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext("Size");
    add_format_to_string(&msg,(uchar *)"\n%s: %lld",codeset,local_60,local_5c);
    if ((*(byte *)&pcVar2->field_0x5c & 8) != 0) {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext((uchar *)"incomplete");
      add_format_to_string(&msg," (%s)",codeset,local_60,local_5c);
    }
    codeset = get_cp_name(doc_view->document->cp);
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset_00 = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset_00);
      current_charset = cp_index;
    }
    codeset_00 = gettext((uchar *)"Codepage");
    add_format_to_string(&msg,(uchar *)"\n%s: %s",codeset_00,codeset);
    cVar3 = doc_view->document->cp_status;
    if (cVar3 == CP_STATUS_ASSUMED) {
      term_01 = "assumed";
LAB_08079b4f:
      codeset_00 = _((terminal *)term_01);
      add_format_to_string(&msg," (%s)",codeset_00,codeset);
    }
    else {
      if (cVar3 == CP_STATUS_IGNORED) {
        term_01 = "ignoring server setting";
        goto LAB_08079b4f;
      }
    }
    codeset = parse_header(pcVar2->head,(uchar *)"Server",(uchar **)0x0);
    if (codeset != (uchar *)0x0) {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      codeset_00 = gettext((uchar *)"Server");
      add_format_to_string(&msg,(uchar *)"\n%s: %s",codeset_00,codeset);
      mem_free(codeset);
    }
    codeset = pcVar2->ssl_info;
    if (codeset != (uchar *)0x0) {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      codeset_00 = gettext((uchar *)"SSL Cipher");
      add_format_to_string(&msg,(uchar *)"\n%s: %s",codeset_00,codeset);
    }
    codeset = pcVar2->encoding_info;
    if (codeset != (uchar *)0x0) {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      codeset_00 = gettext("Encoding");
      add_format_to_string(&msg,(uchar *)"\n%s: %s",codeset_00,codeset);
    }
    codeset = parse_header(pcVar2->head,"Date",(uchar **)0x0);
    if (codeset != (uchar *)0x0) {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      codeset_00 = gettext("Date");
      add_format_to_string(&msg,(uchar *)"\n%s: %s",codeset_00,codeset);
      mem_free(codeset);
    }
    codeset = pcVar2->last_modified;
    if (codeset != (uchar *)0x0) {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      codeset_00 = gettext((uchar *)"Last modified");
      add_format_to_string(&msg,(uchar *)"\n%s: %s",codeset_00,codeset);
    }
  }
  if ((term != (terminal *)0x0) &&
     (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
    codeset = get_cp_mime_name(cp_index);
    bind_textdomain_codeset("elinks",codeset);
    current_charset = cp_index;
  }
  codeset = gettext((uchar *)"Last visit time");
  add_format_to_string(&msg,"\n%s: ",codeset);
  pgVar6 = get_global_history_item(((plVar1->vs).uri)->string);
  if ((pgVar6 == (global_history_item *)0x0) ||
     (puVar7 = (undefined4 *)ctime(&pgVar6->last_visit), cp_index = msg.length,
     puVar7 == (undefined4 *)0x0)) {
    codeset = _((terminal *)"Unknown");
    add_to_string(&msg,codeset);
  }
  else {
    if (assert_failed == 0) {
      assert_failed = 0;
      iVar10 = msg.length + 0x18;
      size = msg.length + 0x118U & 0xffffff00;
      uVar4 = msg.length + 0xffU >> 8;
      uVar11 = msg.length + 0xffU & 0xffffff00;
      if (uVar11 <= size && size + uVar4 * -0x100 != 0) {
        codeset = (uchar *)mem_realloc(msg.source,size);
        if (codeset == (uchar *)0x0) goto LAB_080796d3;
        msg.source = codeset;
        memset(codeset + uVar11,0,size + uVar4 * -0x100);
      }
      if (msg.source != (uchar *)0x0) {
        puVar8 = (undefined4 *)(msg.source + msg.length);
        *puVar8 = *puVar7;
        puVar8[1] = puVar7[1];
        puVar8[2] = puVar7[2];
        puVar8[3] = puVar7[3];
        puVar8[4] = puVar7[4];
        puVar8[5] = puVar7[5];
        msg.source[cp_index + 0x18] = '\0';
        msg.length = iVar10;
      }
    }
    else {
      assert_failed = 0;
    }
  }
LAB_080796d3:
  doc_view = current_frame(ses);
  term_00 = ses->tab->term;
  if (doc_view != (document_view *)0x0) {
    add_char_to_string(&msg,'\n');
    codeset = get_current_link_info(ses,doc_view);
    if (codeset != (uchar *)0x0) {
      if ((term_00 != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term_00), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      codeset_00 = gettext("Link");
      add_format_to_string(&msg,(uchar *)"\n%s: %s",codeset_00,codeset);
      mem_free(codeset);
    }
    codeset = get_current_link_title(doc_view);
    if (codeset != (uchar *)0x0) {
      if ((term_00 != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term_00), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      codeset_00 = gettext((uchar *)"Link title");
      add_format_to_string(&msg,(uchar *)"\n%s: %s",codeset_00,codeset);
      mem_free(codeset);
    }
    plVar9 = get_current_link_in_view(doc_view);
    if (plVar9 != (link *)0x0) {
      if ((plVar9->where_img != (uchar *)0x0) &&
         (psVar5 = init_string(&img), psVar5 != (string *)0x0)) {
        add_string_uri_to_string(&img,plVar9->where_img,URI_PUBLIC);
        decode_uri_string_for_display(&img);
        if ((term_00 != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term_00), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        codeset = gettext((uchar *)"Link image");
        add_format_to_string(&msg,(uchar *)"\n%s: %s",codeset,img.source);
        done_string(&img);
      }
      pgVar6 = get_global_history_item(plVar9->where);
      if (pgVar6 != (global_history_item *)0x0) {
        term_01 = ctime(&pgVar6->last_visit);
        if (term_01 != (char *)0x0) {
          if ((term_00 != (terminal *)0x0) &&
             (cp_index = get_terminal_codepage(term_00), cp_index != current_charset)) {
            codeset = get_cp_mime_name(cp_index);
            bind_textdomain_codeset("elinks",codeset);
            current_charset = cp_index;
          }
          codeset = gettext((uchar *)"Link last visit time");
          add_format_to_string(&msg,(uchar *)"\n%s: %.24s",codeset,term_01);
        }
        codeset = pgVar6->title;
        if (*codeset != '\0') {
          if ((term_00 != (terminal *)0x0) &&
             (cp_index = get_terminal_codepage(term_00), cp_index != current_charset)) {
            codeset_00 = get_cp_mime_name(cp_index);
            bind_textdomain_codeset("elinks",codeset_00);
            current_charset = cp_index;
          }
          codeset_00 = gettext((uchar *)"Link title (from history)");
          add_format_to_string(&msg,(uchar *)"\n%s: %s",codeset_00,codeset);
        }
      }
    }
  }
  info_box(term,MSGBOX_FREE_TEXT|MSGBOX_SCROLLABLE,"Info",ALIGN_LEFT,msg.source);
  return;
}



void download_abort_function(dialog_data *dlg_data)

{
  *(undefined4 *)((int)dlg_data->dlg->udata + 0x6c) = 0;
  return;
}



void lock_file_download(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + 1;
  return;
}



void unlock_file_download(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



int is_file_download_used(listbox_item *item)

{
  return (uint)(*(int *)((int)item->udata + 8) != 0);
}



uchar * get_file_download_info(listbox_item *item,terminal *term)

{
  return (uchar *)0x0;
}



uri * get_file_download_uri(listbox_item *item)

{
  object *poVar1;
  uri *puVar2;
  
  puVar2 = *(uri **)((int)item->udata + 0xc);
  poVar1 = &puVar2->object;
  poVar1->refcount = poVar1->refcount + 1;
  return puVar2;
}



listbox_item * get_file_download_root(listbox_item *item)

{
  return (listbox_item *)0x0;
}



int can_delete_file_download(listbox_item *item)

{
  return 1;
}



void done_download_display(file_download *file_download)

{
  if (file_download->box_item != (listbox_item *)0x0) {
    done_listbox_item(&download_browser,file_download->box_item);
    file_download->box_item = (listbox_item *)0x0;
  }
  return;
}



dlg_refresh_code refresh_file_download(dialog_data *dlg_data,void *data)

{
  int iVar1;
  
  iVar1 = are_there_downloads();
  return -(uint)(iVar1 == 0) & 3;
}



void delete_file_download(listbox_item *item,int last)

{
  void *data;
  bool bVar1;
  
  data = item->udata;
  if ((assert_failed == 0) &&
     (bVar1 = *(int *)((int)data + 8) != 0, assert_failed = ZEXT14(bVar1), bVar1)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/download.c";
    errline = 0x15b;
    elinks_internal((uchar *)"assertion !is_object_used(file_download) failed!");
  }
  register_bottom_half_do(do_abort_download,data);
  return;
}



widget_handler_status_T push_delete_button(dialog_data *dlg_data,widget_data *widget_data)

{
  void *data;
  
  data = dlg_data->dlg->udata;
  *(byte *)((int)data + 0x68) = *(byte *)((int)data + 0x68) | 1;
  *(int *)((int)data + 8) = *(int *)((int)data + 8) + -1;
  register_bottom_half_do(do_abort_download,data);
  return EVENT_PROCESSED;
}



widget_handler_status_T dlg_abort_download(dialog_data *dlg_data,widget_data *widget_data)

{
  int *piVar1;
  void *data;
  
  data = dlg_data->dlg->udata;
  piVar1 = (int *)((int)data + 8);
  *piVar1 = *piVar1 + -1;
  register_bottom_half_do(do_abort_download,data);
  return EVENT_PROCESSED;
}



widget_handler_status_T dlg_undisplay_download(dialog_data *dlg_data,widget_data *widget_data)

{
  int *piVar1;
  void *data;
  
  data = dlg_data->dlg->udata;
  piVar1 = (int *)((int)data + 8);
  *piVar1 = *piVar1 + -1;
  register_bottom_half_do(undisplay_download,data);
  return EVENT_PROCESSED;
}



void do_abort_download(file_download *file_download)

{
  file_download *pfVar1;
  
  pfVar1 = (file_download *)downloads.next;
  if ((list_head_elinks *)downloads.next != &downloads) {
    do {
      if (file_download == pfVar1) {
        *(byte *)&file_download->field_0x68 = *(byte *)&file_download->field_0x68 | 2;
        abort_download(file_download);
        return;
      }
      pfVar1 = pfVar1->next;
    } while (pfVar1 != (file_download *)&downloads);
  }
  return;
}



uchar * get_file_download_text(listbox_item *item,terminal *term)

{
  uchar *src;
  
  src = get_uri_string(*(uri **)((int)item->udata + 0xc),URI_PUBLIC);
  if (src != (uchar *)0x0) {
    if ((*(byte *)&term->field_0x38 & 2) != 0) {
      decode_uri(src);
      return src;
    }
    decode_uri_for_display(src);
  }
  return src;
}



void draw_file_download(listbox_item *item,listbox_context *context,int x,int y,int width)

{
  void *pvVar1;
  progress *progress;
  dialog_refresh *pdVar2;
  uchar *stylename;
  color_pair *color;
  size_t length;
  int x_00;
  size_t length_00;
  
  pvVar1 = item->udata;
  if (width < 4) {
    return;
  }
  stylename = "menu.selected";
  if ((context->box->sel != item) &&
     (stylename = "menu.normal", (*(byte *)&item->field_0x18 & 4) != 0)) {
    stylename = "menu.marked";
  }
  color = get_bfu_color(context->term,stylename);
  stylename = get_file_download_text(item,context->term);
  if (stylename == (uchar *)0x0) {
    return;
  }
  length = strlen((char *)stylename);
  length_00 = width - 0x13;
  if ((int)length_00 <= (int)(length * 0x32) / 100) {
    length_00 = width - 3;
  }
  if ((int)length < (int)length_00) {
    draw_text(context->term,x,y,stylename,length,0,color);
    length_00 = length;
  }
  else {
    draw_text(context->term,x,y,stylename,length_00,0,color);
    if ((int)length_00 < (int)length) {
      x_00 = length_00 + x;
      length_00 = length_00 + 3;
      draw_text(context->term,x_00,y,"...",3,0,color);
    }
  }
  mem_free(stylename);
  progress = *(progress **)((int)pvVar1 + 0x50);
  if ((((progress != (progress *)0x0) && (-1 < *(int *)((int)&progress->size + 4))) &&
      (*(int *)((int)pvVar1 + 0x54) == 8)) && (x_00 = has_progress(progress), x_00 != 0)) {
    pdVar2 = context->dlg_data->dlg->refresh;
    if ((pdVar2 == (dialog_refresh *)0x0) || (pdVar2->timer == (timer_id_T)0x0)) {
      refresh_dialog(context->dlg_data,refresh_file_download,(void *)0x0);
    }
    if ((int)(length_00 + 0xf) < width) {
      draw_progress_bar(*(progress **)((int)pvVar1 + 0x50),context->term,width + -0xf + x,y,0xf,
                        (uchar *)0x0,(color_pair *)0x0);
    }
  }
  return;
}



void init_download_display(file_download *file_download)

{
  listbox_item *plVar1;
  
  plVar1 = add_listbox_item(&download_browser,(listbox_item *)0x0,BI_LEAF,file_download,1);
  file_download->box_item = plVar1;
  return;
}



void download_manager(session *ses)

{
  hierbox_browser(&download_browser,ses);
  download_browser._96_1_ = download_browser._96_1_ | 1;
  return;
}



void undisplay_download(file_download *file_download)

{
  file_download *pfVar1;
  
  pfVar1 = (file_download *)downloads.next;
  if ((list_head_elinks *)downloads.next != &downloads) {
    do {
      if (file_download == pfVar1) {
        if (file_download->dlg_data == (dialog_data *)0x0) {
          return;
        }
        cancel_dialog(file_download->dlg_data,(widget_data *)0x0);
        return;
      }
      pfVar1 = pfVar1->next;
    } while (pfVar1 != (file_download *)&downloads);
  }
  return;
}



widget_handler_status_T dlg_set_notify(dialog_data *dlg_data,widget_data *widget_data)

{
  file_download *file_download;
  
  file_download = (file_download *)dlg_data->dlg->udata;
  file_download->notify = 1;
  undisplay_download(file_download);
  return EVENT_PROCESSED;
}



void download_dialog_layouter(dialog_data *dlg_data)

{
  void *pvVar1;
  terminal *term;
  color_pair *color;
  uchar *text;
  uchar *src;
  size_t sVar2;
  int iVar3;
  int x;
  int width;
  uint local_38;
  int *local_34;
  int local_24;
  int local_20 [4];
  
  pvVar1 = dlg_data->dlg->udata;
  term = dlg_data->win->term;
  x = (term->width * 9) / 10 + -0xc;
  width = 1;
  if (0 < x) {
    iVar3 = term->width + -0xc;
    if (0 < iVar3) {
      width = iVar3;
    }
    if (x <= width) {
      width = x;
    }
  }
  local_24 = 0;
  local_20[0] = width;
  color = get_bfu_color(term,"dialog.text");
  text = get_download_msg((download *)((int)pvVar1 + 0x38),term,1,1,"\n");
  x = download_is_progressing((download *)((int)pvVar1 + 0x38));
  local_38 = 0;
  if (x != 0) {
    local_38 = ~*(uint *)(*(int *)((int)pvVar1 + 0x50) + 0x30) >> 0x1f;
  }
  redraw_below_window(dlg_data->win);
  *(dialog_data **)((int)pvVar1 + 0x6c) = dlg_data;
  if (text != (uchar *)0x0) {
    src = get_uri_string(*(uri **)((int)pvVar1 + 0xc),URI_PUBLIC);
    if (src != (uchar *)0x0) {
      if ((*(byte *)&term->field_0x38 & 2) == 0) {
        decode_uri_for_display(src);
      }
      else {
        decode_uri(src);
      }
      sVar2 = strlen((char *)src);
      if (local_38 == 0) {
        dlg_format_text_do(term,src,0,&local_24,width,local_20,color,ALIGN_LEFT,1);
        local_24 = local_24 + 1;
      }
      else {
        if (width < 0x14) {
          width = 0x14;
        }
        dlg_format_text_do(term,src,0,&local_24,width,local_20,color,ALIGN_LEFT,1);
        local_24 = local_24 + 3;
      }
      local_34 = &local_24;
      dlg_format_text_do(term,text,0,local_34,width,local_20,color,ALIGN_LEFT,1);
      local_24 = local_24 + 1;
      dlg_format_buttons(term,dlg_data->widgets_data,dlg_data->number_of_widgets,0,local_34,width,
                         local_20,ALIGN_CENTER,1);
      draw_dialog(dlg_data,width,local_24);
      width = local_20[0];
      if ((local_20[0] < (int)sVar2) && (src[local_20[0]] = '\0', 4 < local_20[0])) {
        src[local_20[0] + -1] = '.';
        src[local_20[0] + -2] = '.';
        src[local_20[0] + -3] = '.';
      }
      local_24 = (dlg_data->box).y + 3;
      x = (dlg_data->box).x + 6;
      dlg_format_text_do(term,src,x,local_34,local_20[0],(int *)0x0,color,ALIGN_LEFT,0);
      if (local_38 != 0) {
        local_24 = local_24 + 1;
        draw_progress_bar(*(progress **)((int)pvVar1 + 0x50),term,x,local_24,width,(uchar *)0x0,
                          (color_pair *)0x0);
        local_24 = local_24 + 1;
      }
      local_24 = local_24 + 1;
      dlg_format_text_do(term,text,x,local_34,width,(int *)0x0,color,ALIGN_LEFT,0);
      local_24 = local_24 + 1;
      dlg_format_buttons(term,dlg_data->widgets_data,dlg_data->number_of_widgets,x,local_34,width,
                         (int *)0x0,ALIGN_CENTER,0);
      mem_free(src);
    }
    mem_free(text);
  }
  return;
}



void display_download(terminal *term,file_download *file_download,session *ses)

{
  file_download *pfVar1;
  dialog *dlg;
  int cp_index;
  uchar *codeset;
  memory_list *ml;
  bool bVar2;
  
  pfVar1 = (file_download *)downloads.next;
  if ((list_head_elinks *)downloads.next != &downloads) {
    do {
      if (file_download == pfVar1) {
        dlg = (dialog *)mem_calloc(1,0xe4);
        if (dlg == (dialog *)0x0) {
          return;
        }
        undisplay_download(file_download);
        file_download->ses = ses;
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        codeset = gettext((uchar *)"Download");
        dlg->title = codeset;
        dlg->layouter = download_dialog_layouter;
        dlg->abort = download_abort_function;
        *(file_download **)&dlg->udata = file_download;
        (file_download->object).refcount = (file_download->object).refcount + 1;
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        codeset = gettext((uchar *)"~Background");
        add_dlg_button_do(dlg,codeset,3,dlg_undisplay_download,(void *)0x0,(done_handler_T *)0x0,
                          (void *)0x0);
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        codeset = gettext((uchar *)"Background with ~notify");
        add_dlg_button_do(dlg,codeset,3,dlg_set_notify,(void *)0x0,(done_handler_T *)0x0,(void *)0x0
                         );
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        codeset = gettext((uchar *)"~Abort");
        add_dlg_button_do(dlg,codeset,0,dlg_abort_download,(void *)0x0,(done_handler_T *)0x0,
                          (void *)0x0);
        if (file_download->external_handler == (uchar *)0x0) {
          if ((term != (terminal *)0x0) &&
             (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
            codeset = get_cp_mime_name(cp_index);
            bind_textdomain_codeset("elinks",codeset);
            current_charset = cp_index;
          }
          codeset = gettext((uchar *)"Abort and ~delete file");
          add_dlg_button_do(dlg,codeset,0,push_delete_button,(void *)0x0,(done_handler_T *)0x0,
                            (void *)0x0);
        }
        if ((assert_failed == 0) &&
           (bVar2 = ~-(uint)(file_download->external_handler == (uchar *)0x0) + 4 !=
                    dlg->number_of_widgets, assert_failed = ZEXT14(bVar2), bVar2)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/download.c";
          errline = 0x10e;
          elinks_internal((uchar *)
                          "assertion 4 - !!file_download->external_handler == (dlg)->number_of_widgets failed!"
                         );
        }
        ml = getml(dlg,0);
        do_dialog(term,dlg,ml);
        return;
      }
      pfVar1 = pfVar1->next;
    } while (pfVar1 != (file_download *)&downloads);
  }
  return;
}



widget_handler_status_T push_info_button(dialog_data *dlg_data,widget_data *button)

{
  terminal *term;
  session *ses;
  listbox_data *plVar1;
  file_download *file_download;
  
  file_download = (file_download *)0x0;
  plVar1 = get_listbox_widget_data(dlg_data->widgets_data);
  term = dlg_data->win->term;
  ses = (session *)dlg_data->dlg->udata;
  if (plVar1->sel != (listbox_item *)0x0) {
    file_download = (file_download *)plVar1->sel->udata;
  }
  if ((assert_failed == 0) && (assert_failed = ZEXT14(ses == (session *)0x0), ses == (session *)0x0)
     ) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/download.c";
    errline = 0x1d8;
    elinks_internal((uchar *)"assertion ses failed!");
  }
  if (file_download != (file_download *)0x0) {
    delete_window(dlg_data->win);
    display_download(term,file_download,ses);
  }
  return EVENT_PROCESSED;
}



widget_handler_status_T my_cancel_dialog(dialog_data *dlg_data,widget_data *widget_data)

{
  widget_handler_status_T wVar1;
  
  (*(code *)widget_data->widget->data)(dlg_data->dlg);
  wVar1 = cancel_dialog(dlg_data,widget_data);
  return wVar1;
}



void do_edit_dialog(terminal *term,int intl,uchar *title,uchar *src_name,uchar *src_url,session *ses
                   ,dialog_data *parent,done_handler_T *when_done,
                   anon_subr_void_dialog_ptr *when_cancel,void *done_data,
                   edit_dialog_type dialog_type)

{
  uchar **data;
  dialog *dlg;
  anon_subr_void_dialog_data_ptr_for_abort **data_00;
  int cp_index;
  uchar *codeset;
  memory_list *ml;
  bool bVar1;
  code *local_68;
  
  if (((intl != 0) && (title != (uchar *)0x0)) && (*title != '\0')) {
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    title = gettext(title);
  }
  dlg = (dialog *)mem_calloc(1,0x914);
  if (dlg != (dialog *)0x0) {
    data_00 = &dlg[3].abort;
    data = &dlg[0xf].widgets[0].text;
    if (src_name == (uchar *)0x0) {
      get_current_title(ses,(uchar *)data_00,0x400);
    }
    else {
      safe_strncpy((uchar *)data_00,src_name,0x400);
    }
    if (src_url == (uchar *)0x0) {
      get_current_url(ses,(uchar *)data,0x400);
    }
    else {
      safe_strncpy((uchar *)data,src_url,0x400);
    }
    *(byte *)&dlg->layout = *(byte *)&dlg->layout | 1;
    dlg->title = title;
    dlg->layouter = generic_dialog_layouter;
    *(dialog_data **)&dlg->udata = parent;
    dlg->udata2 = done_data;
    if (dialog_type == EDIT_DLG_ADD) {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext("Name");
      local_68 = check_nonempty;
    }
    else {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext("Name");
      local_68 = (widget_handler_T *)0x0;
    }
    add_dlg_field_do(dlg,WIDGET_FIELD,codeset,0,0,local_68,0x400,data_00,(input_history *)0x0,
                     INPFIELD_NONE);
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext("URL");
    add_dlg_field_do(dlg,WIDGET_FIELD,codeset,0,0,(widget_handler_T *)0x0,0x400,data,
                     (input_history *)0x0,INPFIELD_NONE);
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext("~OK");
    add_dlg_button_do(dlg,codeset,1,ok_dialog,(void *)0x0,when_done,dlg);
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"C~lear");
    add_dlg_button_do(dlg,codeset,0,clear_dialog,(void *)0x0,(done_handler_T *)0x0,(void *)0x0);
    if (when_cancel == (anon_subr_void_dialog_ptr *)0x0) {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext((uchar *)"~Cancel");
      add_dlg_button_do(dlg,codeset,2,cancel_dialog,(void *)0x0,(done_handler_T *)0x0,(void *)0x0);
    }
    else {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext((uchar *)"~Cancel");
      add_dlg_button_do(dlg,codeset,2,my_cancel_dialog,when_cancel,(done_handler_T *)0x0,(void *)0x0
                       );
    }
    if ((assert_failed == 0) &&
       (bVar1 = dlg->number_of_widgets != 5, assert_failed = ZEXT14(bVar1), bVar1)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/edit.c";
      errline = 0x6c;
      elinks_internal((uchar *)"assertion 5 == (dlg)->number_of_widgets failed!");
    }
    ml = getml(dlg,0);
    do_dialog(term,dlg,ml);
    return;
  }
  return;
}



void resource_info(terminal *term)

{
  refreshed_msg_box(term,0,(uchar *)"Resources",ALIGN_LEFT,get_resource_info,(void *)0x0);
  return;
}



void menu_copying(terminal *term,void *xxx,void *xxxx)

{
  uchar *text;
  
  text = msg_text(term,(uchar *)
                       "ELinks %s\n\n%set al.\n\nThis program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, specifically version 2 of the License."
                  ,0x81324c6,
                                    
                  "(C) 1999 - 2002 Mikulas Patocka\n(C) 2001 - 2004 Petr Baudis\n(C) 2002 - 2007 Jonas Fonseca\n"
                 );
  info_box(term,MSGBOX_FREE_TEXT,"Copying",ALIGN_CENTER,text);
  return;
}



void menu_keys(terminal *term,void *d_,void *xxx)

{
  terminal **p;
  string *psVar1;
  memory_list *ml;
  int iVar2;
  keymap_id keymap_id;
  action_id_T *paVar3;
  int iStack516;
  action_id_T action_ids [119];
  string keys;
  
  iVar2 = 0x77;
  paVar3 = action_ids;
  while (iVar2 != 0) {
    iVar2 = iVar2 + -1;
    *paVar3 = 0;
    paVar3 = paVar3 + 1;
  }
  action_ids[0] = 0x30;
  action_ids[1] = 0x4c;
  action_ids[2] = 0x3c;
  action_ids[3] = 0x3d;
  action_ids[4] = 0x57;
  action_ids[5] = 0x5a;
  action_ids[6] = 0x58;
  action_ids[7] = 0x59;
  action_ids[8] = 0x20;
  action_ids[9] = 0x1a;
  action_ids[10] = 0x1b;
  action_ids[11] = 0xe;
  action_ids[12] = 0x1e;
  action_ids[13] = 0x5b;
  action_ids[14] = 0x5c;
  action_ids[15] = 0x12;
  action_ids[16] = 0x13;
  action_ids[17] = 0x29;
  action_ids[18] = 0x25;
  action_ids[19] = 0x71;
  p = (terminal **)mem_calloc(1,8);
  if (p != (terminal **)0x0) {
    psVar1 = init_string(&keys);
    if (psVar1 == (string *)0x0) {
      mem_free(p);
      return;
    }
    *p = term;
    p[1] = d_;
    if (d_ == (void *)0x0) {
      add_actions_to_string(&keys,action_ids,KEYMAP_MAIN,term);
    }
    else {
      iVar2 = 0;
      do {
        iVar2 = iVar2 + 1;
        (&iStack516)[iVar2] = iVar2;
      } while (iVar2 != 0x76);
      iVar2 = 0;
      keymap_id = KEYMAP_MAIN;
      while( true ) {
        add_actions_to_string(&keys,action_ids,keymap_id,term);
        if (keymap_id + KEYMAP_EDIT != KEYMAP_MAX) {
          add_to_string(&keys,"\n\n");
        }
        if (assert_failed == 0) {
          assert_failed = 0;
        }
        if (keymap_id == KEYMAP_MAIN) {
          action_ids[30] = 0;
        }
        else {
          if (keymap_id == KEYMAP_EDIT) {
            action_ids[21] = 0;
          }
        }
        if (iVar2 == 2) break;
        iVar2 = iVar2 + 1;
        keymap_id = keymap_id + KEYMAP_EDIT;
      }
    }
    ml = getml(p,0);
    msg_box(term,ml,MSGBOX_FREE_TEXT|MSGBOX_SCROLLABLE,"Keys",ALIGN_LEFT,keys.source,p,2,
            &DAT_081275e4,0,3,"~Toggle display",push_toggle_keys_display_button,1);
  }
  return;
}



void push_toggle_keys_display_button(void *data)

{
  menu_keys(*(terminal **)data,(void *)(uint)(*(int *)((int)data + 4) == 0),(void *)0x0);
  return;
}



void menu_about(terminal *term,void *xxx,void *xxxx)

{
  uchar *text;
  
  text = get_dyn_full_version(term,1);
  info_box(term,MSGBOX_FREE_TEXT,(uchar *)"About",ALIGN_CENTER,text);
  return;
}



uchar * get_resource_info(terminal *term,void *data)

{
  list_head_elinks **pplVar1;
  string *psVar2;
  int cp_index;
  uchar *codeset;
  ulong n;
  list_head_elinks *plVar3;
  ulong n_00;
  ulonglong uVar4;
  string info;
  
  psVar2 = init_string(&info);
  codeset = (uchar *)0x0;
  if (psVar2 != (string *)0x0) {
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Resources");
    add_to_string(&info,codeset);
    add_to_string(&info,": ");
    n = get_file_handles_count();
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = ngettext((uchar *)"%ld handle",(uchar *)"%ld handles",n);
    add_format_to_string(&info,codeset,n);
    add_to_string(&info,", ");
    n = get_timers_count();
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = ngettext((uchar *)"%ld timer",(uchar *)"%ld timers",n);
    add_format_to_string(&info,codeset,n);
    add_to_string(&info,".\n");
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Connections");
    add_to_string(&info,codeset);
    add_to_string(&info,": ");
    n = get_connections_count();
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = ngettext((uchar *)"%ld connection",(uchar *)"%ld connections",n);
    add_format_to_string(&info,codeset,n);
    add_to_string(&info,", ");
    n = get_connections_connecting_count();
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = ngettext((uchar *)"%ld connecting",(uchar *)"%ld connecting",n);
    add_format_to_string(&info,codeset,n);
    add_to_string(&info,", ");
    n = get_connections_transfering_count();
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = ngettext((uchar *)"%ld transferring",(uchar *)"%ld transferring",n);
    add_format_to_string(&info,codeset,n);
    add_to_string(&info,", ");
    n = get_keepalive_connections_count();
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = ngettext((uchar *)"%ld keepalive",(uchar *)"%ld keepalive",n);
    add_format_to_string(&info,codeset,n);
    add_to_string(&info,".\n");
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Memory cache");
    add_to_string(&info,codeset);
    add_to_string(&info,": ");
    uVar4 = get_cache_size();
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = ngettext((uchar *)"%ld byte",(uchar *)"%ld bytes",(ulong)uVar4);
    add_format_to_string(&info,codeset,(ulong)uVar4,(int)(uVar4 >> 0x20));
    add_to_string(&info,", ");
    n = get_cache_entry_count();
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = ngettext((uchar *)"%ld file",(uchar *)"%ld files",n);
    add_format_to_string(&info,codeset,n);
    add_to_string(&info,", ");
    n = get_cache_entry_used_count();
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = ngettext((uchar *)"%ld in use",(uchar *)"%ld in use",n);
    add_format_to_string(&info,codeset,n);
    add_to_string(&info,", ");
    n = get_cache_entry_loading_count();
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = ngettext((uchar *)"%ld loading",(uchar *)"%ld loading",n);
    add_format_to_string(&info,codeset,n);
    add_to_string(&info,".\n");
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Document cache");
    add_to_string(&info,codeset);
    add_to_string(&info,": ");
    n = get_format_cache_size();
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = ngettext((uchar *)"%ld formatted",(uchar *)"%ld formatted",n);
    add_format_to_string(&info,codeset,n);
    add_to_string(&info,", ");
    n = get_format_cache_used_count();
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = ngettext((uchar *)"%ld in use",(uchar *)"%ld in use",n);
    add_format_to_string(&info,codeset,n);
    add_to_string(&info,", ");
    n = get_format_cache_refresh_count();
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = ngettext((uchar *)"%ld refreshing",(uchar *)"%ld refreshing",n);
    add_format_to_string(&info,codeset,n);
    add_to_string(&info,".\n");
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Interlinking");
    add_to_string(&info,codeset);
    add_to_string(&info,": ");
    if ((*(byte *)&term->field_0x38 & 1) == 0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext((uchar *)"slave terminal");
    }
    else {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext((uchar *)"master terminal");
    }
    n = 0;
    add_to_string(&info,codeset);
    add_to_string(&info,", ");
    plVar3 = (list_head_elinks *)terminals.next;
    if ((list_head_elinks *)terminals.next != &terminals) {
      do {
        pplVar1 = (list_head_elinks **)&plVar3->next;
        n = n + 1;
        plVar3 = *pplVar1;
      } while (*pplVar1 != &terminals);
    }
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = ngettext((uchar *)"%ld terminal",(uchar *)"%ld terminals",n);
    n_00 = 0;
    add_format_to_string(&info,codeset,n);
    add_to_string(&info,", ");
    plVar3 = (list_head_elinks *)sessions.next;
    if ((list_head_elinks *)sessions.next != &sessions) {
      do {
        pplVar1 = (list_head_elinks **)&plVar3->next;
        n_00 = n_00 + 1;
        plVar3 = *pplVar1;
      } while (*pplVar1 != &sessions);
    }
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = ngettext((uchar *)"%ld session",(uchar *)"%ld sessions",n_00);
    add_format_to_string(&info,codeset,n_00);
    add_char_to_string(&info,'.');
    codeset = info.source;
  }
  return codeset;
}



void dont_exit_prog(void *ses_)

{
  *(undefined4 *)((int)ses_ + 0x88) = 0;
  return;
}



void add_uri_command_to_menu(menu_item **mi,pass_uri_type type,uchar *text)

{
  bool bVar1;
  uint **ppuVar2;
  uint **ppuVar3;
  menu_item_flags flags;
  int iVar4;
  uchar *in_EDX;
  uint *puVar5;
  byte *pbVar6;
  bool bVar7;
  bool bVar8;
  byte bVar9;
  main_action local_28;
  
  bVar9 = 0;
  ppuVar2 = (uint **)get_opt_(config_options,in_EDX);
  ppuVar2 = (uint **)*ppuVar2;
  local_28 = ACT_MAIN_TAB_EXTERNAL_COMMAND;
  if (type < PASS_URI_TAB) {
    local_28 = *(main_action *)((int)&CSWTCH_174 + type * 4);
  }
  ppuVar3 = (uint **)*ppuVar2;
  bVar8 = ppuVar3 == ppuVar2;
  if (!bVar8) {
    bVar1 = false;
    do {
      bVar7 = ppuVar3 < ppuVar2;
      iVar4 = 0xb;
      puVar5 = ppuVar3[3];
      pbVar6 = (byte *)0x813178d;
      do {
        if (iVar4 == 0) break;
        iVar4 = iVar4 + -1;
        bVar7 = *(byte *)puVar5 < *pbVar6;
        bVar8 = *(byte *)puVar5 == *pbVar6;
        puVar5 = (uint *)((int)puVar5 + (uint)bVar9 * -2 + 1);
        pbVar6 = pbVar6 + (uint)bVar9 * -2 + 1;
      } while (bVar8);
      if ((!bVar7 && !bVar8) != bVar7) {
        if (bVar1) {
          flags = SUBMENU;
          goto LAB_0807bf35;
        }
        bVar1 = true;
      }
      ppuVar3 = (uint **)*ppuVar3;
      bVar8 = ppuVar3 == ppuVar2;
    } while (!bVar8);
    if (bVar1) {
      flags = NO_FLAG;
LAB_0807bf35:
      add_to_menu(mi,text,(uchar *)0x0,local_28,(menu_func_T *)0x0,(void *)0x0,flags);
      return;
    }
  }
  return;
}



void do_setup_menu(terminal *term,void *xxx,void *ses_)

{
  int *piVar1;
  uchar *in_EDX;
  
  piVar1 = get_opt_(cmdline_options,in_EDX);
  if (*piVar1 != 0) {
    do_menu(term,setup_menu_anon,ses_,1);
    return;
  }
  do_menu(term,setup_menu,ses_,1);
  return;
}



void do_submenu(terminal *term,void *menu_,void *ses_)

{
  do_menu(term,(menu_item *)menu_,ses_,1);
  return;
}



void __regparm3 history_menu_common(terminal *term,session *ses,int unhist)

{
  uchar *text;
  location *data;
  menu_item *local_20 [4];
  
  local_20[0] = (menu_item *)0x0;
  data = (ses->history).current;
  if (data != (location *)0x0) {
    if (unhist == 0) {
      data = data->prev;
    }
    else {
      data = data->next;
    }
    while ((location *)&ses->history != data) {
      if ((local_20[0] == (menu_item *)0x0) &&
         (local_20[0] = new_menu(FREE_LIST|FREE_TEXT|NO_INTL), local_20[0] == (menu_item *)0x0)) {
        return;
      }
      text = get_uri_string((data->vs).uri,URI_PUBLIC);
      if (text != (uchar *)0x0) {
        add_to_menu(local_20,text,(uchar *)0x0,ACT_MAIN_NONE,go_historywards,data,NO_FLAG);
      }
      if (unhist == 0) {
        data = data->prev;
      }
      else {
        data = data->next;
      }
    }
    if (local_20[0] != (menu_item *)0x0) {
      do_menu(term,local_20[0],ses,0);
      return;
    }
  }
  do_menu(term,no_hist_menu,ses,0);
  return;
}



void unhistory_menu(terminal *term,void *xxx,void *ses_)

{
  history_menu_common(term,(session *)ses_,1);
  return;
}



void history_menu(terminal *term,void *xxx,void *ses_)

{
  history_menu_common(term,(session *)ses_,0);
  return;
}



void do_pass_uri_to_command(terminal *term,void *command_,void *xxx)

{
  exec_on_terminal(term,(uchar *)command_,"",TERM_EXEC_BG);
  mem_free(command_);
  return;
}



void add_new_win_to_menu(menu_item **mi,uchar *text,terminal *term)

{
  int iVar1;
  int *piVar2;
  menu_item_flags flags;
  uchar *name;
  uchar *name_00;
  
  iVar1 = can_open_in_new(term);
  if (iVar1 != 0) {
    piVar2 = get_opt_(cmdline_options,name);
    if (*piVar2 == 0) {
      piVar2 = get_opt_(cmdline_options,(uchar *)0x0);
      if (*piVar2 == 0) {
        piVar2 = get_opt_(cmdline_options,name_00);
        if (*piVar2 == 0) {
          flags = NO_FLAG;
          if (iVar1 != 1) {
            flags = SUBMENU;
          }
          add_to_menu(mi,text,(uchar *)0x0,ACT_MAIN_OPEN_LINK_IN_NEW_WINDOW,open_in_new_window,
                      send_open_in_new_window,flags);
        }
      }
    }
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x0807c34b)

void open_in_new_window(terminal *term,void *func_,void *ses_)

{
  int iVar1;
  uint uVar2;
  open_in_new *data;
  menu_item *local_20 [4];
  
  if (assert_failed == 0) {
    if (((ses_ == (void *)0x0) || (term == (terminal *)0x0)) || (func_ == (void *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
      errline = 0x2c4;
      elinks_internal((uchar *)"assertion term && ses && func failed!");
      if (assert_failed != 0) goto LAB_0807c2e8;
    }
    else {
      assert_failed = 0;
    }
    iVar1 = can_open_in_new(term);
    if (iVar1 != 0) {
      if (iVar1 == 1) {
        local_20[0] = (menu_item *)0x0;
      }
      else {
        local_20[0] = new_menu(FREE_LIST);
        if (local_20[0] == (menu_item *)0x0) {
          return;
        }
      }
      uVar2 = ENV_XWIN;
      data = open_in_new;
      do {
        if ((term->environment & uVar2) != 0) {
          if (local_20[0] == (menu_item *)0x0) {
            (*(code *)func_)(term,data,ses_);
            return;
          }
          add_to_menu(local_20,data->text,(uchar *)0x0,ACT_MAIN_NONE,(menu_func_T *)func_,data,
                      NO_FLAG);
        }
        uVar2 = data[1].env;
        data = data + 1;
      } while (uVar2 != 0);
      do_menu(term,local_20[0],ses_,1);
      return;
    }
  }
  else {
LAB_0807c2e8:
    assert_failed = 0;
  }
  return;
}



void __regparm3 add_cmdline_bool_option(string *string,uchar *name)

{
  int *piVar1;
  
  piVar1 = get_opt_(cmdline_options,name);
  if (*piVar1 != 0) {
    add_to_string(string," -");
    add_to_string(string,name);
  }
  return;
}



void open_uri_in_new_window
               (session *ses,uri *uri,uri *referrer,term_env_type env,cache_mode cache_mode,
               task_type task)

{
  int iVar1;
  int *piVar2;
  int iVar3;
  string *psVar4;
  uchar *in_EDX;
  char *local_58;
  string parameters;
  
  local_58 = "session-ring";
  piVar2 = get_opt_(cmdline_options,in_EDX);
  iVar1 = *piVar2;
  if (assert_failed == 0) {
    assert_failed = ZEXT14(env == ~ENV_ANY || ses == (session *)0x0);
    if (env == ~ENV_ANY || ses == (session *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
      errline = 0x280;
      elinks_internal((uchar *)"assertion env && ses failed!",local_58);
      if (assert_failed != 0) goto LAB_0807c565;
    }
    iVar3 = add_session_info(ses,uri,referrer,cache_mode,task);
    if (0 < iVar3) {
      psVar4 = init_string(&parameters);
      if (psVar4 != (string *)0x0) {
        add_format_to_string(&parameters,(uchar *)"-base-session %d",iVar3);
        if (iVar1 != 0) {
          add_format_to_string(&parameters,(uchar *)" -session-ring %d",iVar1);
        }
        if (uri == (uri *)0x0) {
          add_cmdline_bool_option(&parameters,(uchar *)"localhost");
          add_cmdline_bool_option(&parameters,(uchar *)"no-home");
          add_cmdline_bool_option(&parameters,(uchar *)"no-connect");
        }
        open_new_window(ses->tab->term,program.path,env,parameters.source);
        done_string(&parameters);
      }
    }
  }
  else {
LAB_0807c565:
    assert_failed = 0;
  }
  return;
}



void send_open_new_window(terminal *term,open_in_new *open,session *ses)

{
  open_uri_in_new_window(ses,(uri *)0x0,(uri *)0x0,open->env,CACHE_MODE_NORMAL,TASK_NONE);
  return;
}



void send_open_in_new_window(terminal *term,open_in_new *open,session *ses)

{
  int iVar1;
  document_view *doc_view;
  uri *uri;
  link *link;
  
  if (assert_failed == 0) {
    if (((open == (open_in_new *)0x0) || (term == (terminal *)0x0)) || (ses == (session *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
      errline = 0x2a2;
      elinks_internal((uchar *)"assertion term && open && ses failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    else {
      assert_failed = 0;
    }
    doc_view = current_frame(ses);
    if (assert_failed == 0) {
      if (((doc_view == (document_view *)0x0) || (doc_view->vs == (view_state *)0x0)) ||
         (doc_view->document == (document *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
        errline = 0x2a5;
        elinks_internal((uchar *)"assertion doc_view && doc_view->vs && doc_view->document failed!")
        ;
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
        if (doc_view == (document_view *)0x0) {
          return;
        }
      }
      else {
        assert_failed = 0;
      }
      iVar1 = doc_view->vs->current_link;
      if (iVar1 < 0) {
        return;
      }
      if (iVar1 < doc_view->document->nlinks) {
        link = doc_view->document->links + iVar1;
        if (link == (link *)0x0) {
          return;
        }
        uri = get_link_uri(ses,doc_view,link);
        if (uri != (uri *)0x0) {
          open_uri_in_new_window(ses,uri,(uri *)0x0,open->env,CACHE_MODE_NORMAL,TASK_NONE);
          done_uri(uri);
          return;
        }
        return;
      }
      return;
    }
  }
  assert_failed = 0;
  return;
}



void free_history_lists(void)

{
  input_history *p;
  input_history *piVar1;
  input_history *piVar2;
  bool bVar3;
  
  piVar2 = (input_history *)file_history.entries.next;
  if ((input_history *)file_history.entries.next != &file_history) {
    do {
      piVar2 = (input_history *)(piVar2->entries).next;
    } while (piVar2 != &file_history);
  }
  piVar1 = (input_history *)file_history.entries.prev;
  if ((input_history *)file_history.entries.prev != piVar2) {
    do {
      piVar1 = (input_history *)(piVar1->entries).prev;
    } while (piVar1 != piVar2);
  }
  piVar1 = *(input_history **)file_history.entries.next;
  p = (input_history *)file_history.entries.next;
  if ((input_history *)file_history.entries.next != piVar2) {
    do {
      (piVar1->entries).prev = (p->entries).prev;
      *(void **)(p->entries).prev = (p->entries).next;
      mem_free(p);
      bVar3 = piVar1 != piVar2;
      p = piVar1;
      piVar1 = (input_history *)(piVar1->entries).next;
    } while (bVar3);
  }
  trigger_event_name((uchar *)"free-history");
  return;
}



void dialog_goto_url(session *ses,uchar *url)

{
  input_dialog(ses->tab->term,(memory_list *)0x0,"Go to URL",(uchar *)"Enter URL",ses,
               &goto_url_history,0x400,url,0,0,(widget_handler_T *)0x0,goto_url_with_hook,
               (done_handler_T *)0x0);
  return;
}



void save_url_as(session *ses)

{
  input_dialog(ses->tab->term,(memory_list *)0x0,(uchar *)"Save URL",(uchar *)"Enter URL",ses,
               &goto_url_history,0x400,"",0,0,(widget_handler_T *)0x0,save_url,(done_handler_T *)0x0
              );
  return;
}



void activate_bfu_technology(session *ses,int item)

{
  do_mainmenu(ses->tab->term,main_menu,ses,item);
  return;
}



void menu_url_shortcut(terminal *term,void *url_,void *ses_)

{
  uri *uri;
  
  uri = get_uri((uchar *)url_,0);
  if (uri != (uri *)0x0) {
    goto_uri((session *)ses_,uri);
    done_uri(uri);
    return;
  }
  return;
}



void do_file_menu(terminal *term,void *xxx,void *ses_)

{
  menu_item_flags *pmVar1;
  menu_item *items;
  size_t __n;
  int *piVar2;
  int iVar3;
  uchar *in_EDX;
  uchar *name;
  uchar *name_00;
  menu_item *__dest;
  menu_item_flags mVar4;
  int iVar5;
  menu_item *__src;
  menu_item *pmVar6;
  byte bVar7;
  
  bVar7 = 0;
  pmVar1 = get_opt_(cmdline_options,in_EDX);
  mVar4 = *pmVar1;
  items = (menu_item *)mem_alloc(0x2e0);
  if (items != (menu_item *)0x0) {
    if (mVar4 == NO_FLAG) {
      piVar2 = get_opt_(cmdline_options,name);
      __src = items;
      if ((*piVar2 == 0) && (piVar2 = get_opt_(cmdline_options,name_00), *piVar2 == 0)) {
        iVar3 = can_open_in_new(term);
        if (iVar3 != 0) {
          if (iVar3 != 1) {
            mVar4 = SUBMENU;
          }
          items->text = "Open ~new window";
          items->rtext = (uchar *)0x0;
          items->action_id = ACT_MAIN_OPEN_NEW_WINDOW;
          items->func = open_in_new_window;
          *(code **)&items->data = send_open_new_window;
          items->flags = mVar4;
          items->hotkey_state = HKS_SHOW;
          items->hotkey_pos = 0;
          __src = items + 1;
        }
        iVar3 = 0x38;
        __dest = file_menu11;
        pmVar6 = __src;
        while (iVar3 != 0) {
          iVar3 = iVar3 + -1;
          pmVar6->text = __dest->text;
          __dest = (menu_item *)(&__dest->text + (uint)bVar7 * 0x3ffffffe + 1);
          pmVar6 = (menu_item *)((int)pmVar6 + (uint)bVar7 * -8 + 4);
        }
      }
      else {
        iVar3 = 0x38;
        __dest = file_menu11;
        pmVar6 = items;
        while (iVar3 != 0) {
          iVar3 = iVar3 + -1;
          pmVar6->text = __dest->text;
          __dest = (menu_item *)(&__dest->text + (uint)bVar7 * 0x3ffffffe + 1);
          pmVar6 = (menu_item *)((int)pmVar6 + (uint)bVar7 * -8 + 4);
        }
      }
      iVar3 = 0x28;
      __dest = file_menu21;
      pmVar6 = __src + 7;
      while (iVar3 != 0) {
        iVar3 = iVar3 + -1;
        pmVar6->text = __dest->text;
        __dest = (menu_item *)(&__dest->text + (uint)bVar7 * 0x3ffffffe + 1);
        pmVar6 = (menu_item *)((int)pmVar6 + (uint)bVar7 * -8 + 4);
      }
      iVar3 = 0x28;
      __dest = file_menu22;
      pmVar6 = __src + 0xc;
      while (iVar3 != 0) {
        iVar3 = iVar3 + -1;
        pmVar6->text = __dest->text;
        __dest = (menu_item *)(&__dest->text + (uint)bVar7 * 0x3ffffffe + 1);
        pmVar6 = (menu_item *)((int)pmVar6 + (uint)bVar7 * -8 + 4);
      }
      __dest = __src + 0x11;
      iVar5 = 1;
      iVar3 = can_open_os_shell(term->environment);
      if (iVar3 != 0) {
        __src[0x11].text = "~OS shell";
        iVar5 = 0;
        __src[0x11].rtext = (uchar *)0x0;
        __src[0x11].action_id = ACT_MAIN_OPEN_OS_SHELL;
        __src[0x11].func = (menu_func_T *)0x0;
        __src[0x11].data = (void *)0x0;
        __src[0x11].flags = NO_FLAG;
        __src[0x11].hotkey_state = HKS_SHOW;
        __src[0x11].hotkey_pos = 0;
        __dest = __src + 0x12;
      }
    }
    else {
      iVar3 = 0x38;
      __src = file_menu11;
      __dest = items;
      while (iVar3 != 0) {
        iVar3 = iVar3 + -1;
        __dest->text = __src->text;
        __src = (menu_item *)(&__src->text + (uint)bVar7 * 0x3ffffffe + 1);
        __dest = (menu_item *)((int)__dest + (uint)bVar7 * -8 + 4);
      }
      iVar3 = 0x28;
      __src = file_menu22;
      __dest = items + 7;
      while (iVar3 != 0) {
        iVar3 = iVar3 + -1;
        __dest->text = __src->text;
        __src = (menu_item *)(&__src->text + (uint)bVar7 * 0x3ffffffe + 1);
        __dest = (menu_item *)((int)__dest + (uint)bVar7 * -8 + 4);
      }
      __dest = items + 0xc;
      iVar5 = 1;
    }
    iVar3 = can_resize_window(term->environment);
    if (iVar3 == 0) {
      __n = (3 - iVar5) * 0x20;
      __src = file_menu3 + iVar5;
    }
    else {
      __dest->text = "Resize t~erminal";
      __src = file_menu3;
      __n = 0x60;
      __dest->rtext = (uchar *)0x0;
      __dest->action_id = ACT_MAIN_TERMINAL_RESIZE;
      __dest->func = (menu_func_T *)0x0;
      __dest->data = (void *)0x0;
      __dest->flags = NO_FLAG;
      __dest->hotkey_state = HKS_SHOW;
      __dest->hotkey_pos = 0;
      __dest = __dest + 1;
    }
    memcpy(__dest,__src,__n);
    __src = items;
    while (__src < __dest + 3) {
      __src->flags = __src->flags | FREE_LIST;
      __src = __src + 1;
    }
    do_menu(term,items,ses_,1);
  }
  return;
}



void go_historywards(terminal *term,void *target_,void *ses_)

{
  go_history((session *)ses_,(location *)target_);
  return;
}



void tab_menu(session *ses,int x,int y,int place_above_cursor)

{
  document *pdVar1;
  uchar *puVar2;
  int *piVar3;
  int iVar4;
  int iVar5;
  uchar *in_EDX;
  char *local_58;
  menu_item *local_20 [4];
  
  local_58 = "anonymous";
  piVar3 = get_opt_(cmdline_options,in_EDX);
  iVar5 = *piVar3;
  if (assert_failed == 0) {
    if ((ses == (session *)0x0) || (ses->tab == (window *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
      errline = 0xe7;
      elinks_internal((uchar *)"assertion ses && ses->tab failed!",local_58);
      if (assert_failed != 0) goto LAB_0807d080;
    }
    else {
      assert_failed = 0;
    }
    iVar4 = number_of_tabs(ses->tab->term);
    local_20[0] = new_menu(FREE_LIST);
    if (local_20[0] != (menu_item *)0x0) {
      add_to_menu(local_20,(uchar *)"Go ~back",(uchar *)0x0,ACT_MAIN_HISTORY_MOVE_BACK,
                  (menu_func_T *)0x0,(void *)0x0,NO_FLAG);
      add_to_menu(local_20,(uchar *)"Go for~ward",(uchar *)0x0,ACT_MAIN_HISTORY_MOVE_FORWARD,
                  (menu_func_T *)0x0,(void *)0x0,NO_FLAG);
      if ((ses->history).current != (location *)0x0) {
        add_to_menu(local_20,"",(uchar *)0x0,ACT_MAIN_NONE,(menu_func_T *)0x0,(void *)0x0,NO_SELECT)
        ;
        if (iVar5 == 0) {
          add_to_menu(local_20,(uchar *)"Bookm~ark document",(uchar *)0x0,ACT_MAIN_ADD_BOOKMARK,
                      (menu_func_T *)0x0,(void *)0x0,NO_FLAG);
        }
        add_to_menu(local_20,(uchar *)"Toggle ~HTML/plain",(uchar *)0x0,ACT_MAIN_TOGGLE_HTML_PLAIN,
                    (menu_func_T *)0x0,(void *)0x0,NO_FLAG);
        add_to_menu(local_20,(uchar *)"~Reload",(uchar *)0x0,ACT_MAIN_RELOAD,(menu_func_T *)0x0,
                    (void *)0x0,NO_FLAG);
        if (((ses->doc_view != (document_view *)0x0) &&
            (pdVar1 = ses->doc_view->document, pdVar1 != (document *)0x0)) &&
           (pdVar1->frame_desc != (frameset_desc *)0x0)) {
          add_to_menu(local_20,(uchar *)"Frame at ~full-screen",(uchar *)0x0,ACT_MAIN_FRAME_MAXIMIZE
                      ,(menu_func_T *)0x0,(void *)0x0,NO_FLAG);
          add_uri_command_to_menu
                    (local_20,PASS_URI_FRAME,(uchar *)"~Pass frame URI to external command");
        }
      }
      add_to_menu(local_20,"",(uchar *)0x0,ACT_MAIN_NONE,(menu_func_T *)0x0,(void *)0x0,NO_SELECT);
      if (iVar4 < 2) {
        add_to_menu(local_20,(uchar *)"~Close tab",(uchar *)0x0,ACT_MAIN_TAB_CLOSE,
                    (menu_func_T *)0x0,(void *)0x0,NO_FLAG);
      }
      else {
        add_to_menu(local_20,(uchar *)"Nex~t tab",(uchar *)0x0,ACT_MAIN_TAB_NEXT,(menu_func_T *)0x0,
                    (void *)0x0,NO_FLAG);
        add_to_menu(local_20,(uchar *)"Pre~v tab",(uchar *)0x0,ACT_MAIN_TAB_PREV,(menu_func_T *)0x0,
                    (void *)0x0,NO_FLAG);
        add_to_menu(local_20,(uchar *)"~Close tab",(uchar *)0x0,ACT_MAIN_TAB_CLOSE,
                    (menu_func_T *)0x0,(void *)0x0,NO_FLAG);
        add_to_menu(local_20,(uchar *)"C~lose all tabs but the current",(uchar *)0x0,
                    ACT_MAIN_TAB_CLOSE_ALL_BUT_CURRENT,(menu_func_T *)0x0,(void *)0x0,NO_FLAG);
        if (iVar5 == 0) {
          add_to_menu(local_20,(uchar *)"B~ookmark all tabs",(uchar *)0x0,ACT_MAIN_ADD_BOOKMARK_TABS
                      ,(menu_func_T *)0x0,(void *)0x0,NO_FLAG);
        }
      }
      if ((ses->history).current != (location *)0x0) {
        add_uri_command_to_menu(local_20,PASS_URI_TAB,(uchar *)"Pass tab URI to e~xternal command");
      }
      if (place_above_cursor != 0) {
        iVar5 = 0;
        puVar2 = local_20[0]->text;
        while (puVar2 != (uchar *)0x0) {
          iVar5 = iVar5 + 1;
          puVar2 = local_20[0][iVar5].text;
        }
        iVar5 = (y + -1) - iVar5;
        y = 0;
        if (-1 < iVar5) {
          y = iVar5;
        }
      }
      ses->tab->x = x;
      ses->tab->y = y;
      do_menu(ses->tab->term,local_20[0],ses,1);
      return;
    }
  }
  else {
LAB_0807d080:
    assert_failed = 0;
  }
  return;
}



void really_exit_prog(void *ses_)

{
  register_bottom_half_do(destroy_terminal,*(void **)(*(int *)((int)ses_ + 8) + 0x14));
  return;
}



void query_exit(session *ses)

{
  terminal *term;
  int iVar1;
  char *text;
  
  ses->exit_query = 1;
  term = ses->tab->term;
  if (term->next == term->prev) {
    iVar1 = are_there_downloads();
    if (iVar1 != 0) {
      text = "Do you really want to exit ELinks (and terminate all downloads)?";
      term = ses->tab->term;
      goto LAB_0807d1b6;
    }
    term = ses->tab->term;
  }
  text = "Do you really want to exit ELinks?";
LAB_0807d1b6:
  msg_box(term,(memory_list *)0x0,0,(uchar *)"Exit ELinks",ALIGN_CENTER,(uchar *)text,ses,2,
          &DAT_0812762b,really_exit_prog,1,&DAT_08127627,dont_exit_prog,2);
  return;
}



void exit_prog(session *ses,int query)

{
  int iVar1;
  
  if ((assert_failed == 0) && (assert_failed = ZEXT14(ses == (session *)0x0), ses == (session *)0x0)
     ) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
    errline = 0x8b;
    elinks_internal((uchar *)"assertion ses failed!");
  }
  if (ses->exit_query == 0) {
    if ((query == 0) &&
       ((terminals.next != terminals.prev || (iVar1 = are_there_downloads(), iVar1 == 0)))) {
      really_exit_prog(ses);
      return;
    }
    query_exit(ses);
    return;
  }
  return;
}



frame_event_status pass_uri_to_command(session *ses,document_view *doc_view,int which_type)

{
  int iVar1;
  uint uVar2;
  char cVar3;
  int **ppiVar4;
  uchar *text;
  string *psVar5;
  uint uVar6;
  uchar *len;
  uchar *src;
  int iVar7;
  size_t sVar8;
  uchar *in_EDX;
  uint size;
  link *link;
  int **ppiVar9;
  size_t __n;
  int *__src;
  char *pcVar10;
  int *piVar11;
  bool bVar12;
  byte bVar13;
  int local_40;
  uri *local_3c;
  string string;
  menu_item *local_20 [4];
  
  bVar13 = 0;
  ppiVar4 = (int **)get_opt_(config_options,in_EDX);
  ppiVar4 = (int **)*ppiVar4;
  if (which_type == 0) {
    local_3c = doc_view->document->uri;
    (local_3c->object).refcount = (local_3c->object).refcount + 1;
  }
  else {
    if (which_type == 1) {
      if (doc_view == (document_view *)0x0) {
        return FRAME_EVENT_OK;
      }
      iVar7 = doc_view->vs->current_link;
      if (iVar7 < 0) {
        return FRAME_EVENT_OK;
      }
      if (doc_view->document->nlinks <= iVar7) {
        return FRAME_EVENT_OK;
      }
      link = doc_view->document->links + iVar7;
      if (link == (link *)0x0) {
        return FRAME_EVENT_OK;
      }
      local_3c = get_link_uri(ses,doc_view,link);
      if (local_3c == (uri *)0x0) {
        return FRAME_EVENT_OK;
      }
    }
    else {
      local_3c = ses->doc_view->document->uri;
      (local_3c->object).refcount = (local_3c->object).refcount + 1;
    }
  }
  local_20[0] = new_menu(FREE_LIST|FREE_TEXT|FREE_DATA|NO_INTL);
  if (local_20[0] == (menu_item *)0x0) {
    done_uri(local_3c);
    return FRAME_EVENT_OK;
  }
  ppiVar9 = (int **)*ppiVar4;
  bVar12 = ppiVar9 == ppiVar4;
  if (bVar12) {
    done_uri(local_3c);
  }
  else {
    local_40 = 0;
    do {
      iVar7 = 0xb;
      __src = ppiVar9[3];
      pcVar10 = "_template_";
      do {
        if (iVar7 == 0) break;
        iVar7 = iVar7 + -1;
        bVar12 = *(char *)__src == *pcVar10;
        __src = (int *)((int)__src + (uint)bVar13 * -2 + 1);
        pcVar10 = pcVar10 + (uint)bVar13 * -2 + 1;
      } while (bVar12);
      if ((!bVar12) && (text = stracpy((uchar *)ppiVar9[3]), text != (uchar *)0x0)) {
        __src = ppiVar9[8];
        psVar5 = init_string(&string);
        if (psVar5 != (string *)0x0) {
LAB_0807d3c6:
          cVar3 = *(char *)__src;
          if (cVar3 != '\0') {
            do {
              sVar8 = 0;
              __n = 0;
              piVar11 = __src;
              if (cVar3 != '%') {
                do {
                  sVar8 = sVar8 + 1;
                  __n = sVar8;
                  piVar11 = (int *)(sVar8 + (int)__src);
                  if (*(char *)((int)__src + sVar8) == '%') break;
                } while (*(char *)((int)__src + sVar8) != '\0');
              }
              if (assert_failed == 0) {
                if ((int)__n < 0) {
                  assert_failed = 1;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                  errline = 0xff;
                  elinks_internal((uchar *)
                                  "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                                 );
                  if (assert_failed != 0) goto LAB_0807d402;
                }
                else {
                  assert_failed = 0;
                }
                if (__n != 0) {
                  iVar7 = __n + string.length;
                  uVar2 = string.length + 0xffU >> 8;
                  uVar6 = string.length + 0xffU & 0xffffff00;
                  size = iVar7 + 0x100U & 0xffffff00;
                  if (uVar6 <= size && size + uVar2 * -0x100 != 0) {
                    src = (uchar *)mem_realloc(string.source,size);
                    if (src == (uchar *)0x0) goto LAB_0807d410;
                    string.source = src;
                    memset(src + uVar6,0,size + uVar2 * -0x100);
                  }
                  if (string.source != (uchar *)0x0) {
                    memcpy(string.source + string.length,__src,__n);
                    string.source[iVar7] = '\0';
                    string.length = iVar7;
                  }
                }
              }
              else {
LAB_0807d402:
                assert_failed = 0;
              }
LAB_0807d410:
              iVar7 = string.length;
              cVar3 = *(char *)piVar11;
              if (cVar3 == '%') goto LAB_0807d4c8;
              __src = piVar11;
              if (cVar3 == '\0') break;
            } while( true );
          }
          if (string.source == (uchar *)0x0) goto LAB_0807d780;
          add_to_menu(local_20,text,(uchar *)0x0,ACT_MAIN_NONE,do_pass_uri_to_command,string.source,
                      NO_FLAG);
          local_40 = local_40 + 1;
          ppiVar9 = (int **)*ppiVar9;
          goto joined_r0x0807d46e;
        }
LAB_0807d780:
        mem_free(text);
      }
      ppiVar9 = (int **)*ppiVar9;
joined_r0x0807d46e:
      bVar12 = ppiVar9 == ppiVar4;
    } while (!bVar12);
    done_uri(local_3c);
    if (1 < local_40) {
      do_menu(ses->tab->term,local_20[0],ses,1);
      return FRAME_EVENT_OK;
    }
    if (local_40 == 1) {
      do_pass_uri_to_command(ses->tab->term,local_20[0]->data,ses);
      goto LAB_0807d49d;
    }
  }
  mem_free(local_20[0]->data);
LAB_0807d49d:
  mem_free(local_20[0]->text);
  mem_free(local_20[0]);
  return FRAME_EVENT_OK;
LAB_0807d4c8:
  if (*(char *)((int)piVar11 + 1) == '%') {
    add_char_to_string(&string,'%');
  }
  else {
    if (*(char *)((int)piVar11 + 1) == 'c') {
      src = local_3c->string;
      if (local_3c->post == (uchar *)0x0) {
        len = (uchar *)strlen((char *)src);
      }
      else {
        len = local_3c->post + (-1 - (int)src);
      }
      add_shell_quoted_to_string(&string,src,(int)len);
    }
    else {
      if (assert_failed == 0) {
        assert_failed = 0;
        size = string.length + 0x102U & 0xffffff00;
        uVar2 = string.length + 0xffU >> 8;
        uVar6 = string.length + 0xffU & 0xffffff00;
        iVar1 = string.length + 2;
        if (uVar6 <= size && size + uVar2 * -0x100 != 0) {
          src = (uchar *)mem_realloc(string.source,size);
          if (src == (uchar *)0x0) goto LAB_0807d536;
          string.source = src;
          memset(src + uVar6,0,size + uVar2 * -0x100);
        }
        if (string.source != (uchar *)0x0) {
          *(undefined2 *)(string.source + string.length) = *(undefined2 *)piVar11;
          string.source[iVar7 + 2] = '\0';
          string.length = iVar1;
        }
      }
      else {
        assert_failed = 0;
      }
    }
  }
LAB_0807d536:
  __src = (int *)((int)piVar11 + (2 - (uint)(*(char *)((int)piVar11 + 1) == '\0')));
  goto LAB_0807d3c6;
}



void query_file(session *ses,uri *uri,void *data,anon_subr_void_void_ptr_uchar_ptr *std,
               anon_subr_void_void_ptr *cancel,int interactive)

{
  protocol_external_handler_T *ppVar1;
  uint uVar2;
  string *psVar3;
  uchar **ppuVar4;
  uchar *name;
  string def;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(uri == (uri *)0x0 || ses == (session *)0x0);
    if (uri == (uri *)0x0 || ses == (session *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
      errline = 0x230;
      elinks_internal((uchar *)"assertion ses && uri failed!");
      if (assert_failed != 0) goto LAB_0807d8c8;
    }
    if (uri->protocol == 0x12) {
      assert_failed = 0;
      print_error_dialog(ses,(connection_state)0xfffe7951,uri,PRI_CANCEL);
    }
    else {
      ppVar1 = get_protocol_external_handler(ses->tab->term,uri);
      if (ppVar1 == (protocol_external_handler_T *)0x0) {
        psVar3 = init_string(&def);
        if (psVar3 != (string *)0x0) {
          ppuVar4 = (uchar **)get_opt_(config_options,name);
          add_to_string(&def,*ppuVar4);
          if ((def.length != 0) && (def.source[def.length + -1] != '/')) {
            add_char_to_string(&def,'/');
          }
          add_mime_filename_to_string(&def,uri);
          if ((*(byte *)&ses->tab->term->field_0x38 & 2) == 0) {
            decode_uri_string_for_display(&def);
          }
          else {
            decode_uri_string(&def);
          }
          if (interactive == 0) {
            (*std)(data,def.source);
          }
          else {
            input_dialog(ses->tab->term,(memory_list *)0x0,(uchar *)"Download",
                         (uchar *)"Save to file",data,&file_history,0x400,def.source,0,0,
                         check_nonempty,std,(done_handler_T *)cancel);
          }
          done_string(&def);
        }
      }
      else {
        if (assert_failed == 0) {
          uVar2 = 0xfffe7950;
        }
        else {
          uVar2 = 0xfffe795d;
        }
        assert_failed = 0;
        print_error_dialog(ses,(connection_state)(ulonglong)uVar2,uri,PRI_CANCEL);
      }
    }
  }
  else {
LAB_0807d8c8:
    assert_failed = 0;
  }
  return;
}



void save_url(session *ses,uchar *url)

{
  uri *puVar1;
  document_view *pdVar2;
  uint uVar3;
  
  if (assert_failed == 0) {
    if ((((ses == (session *)0x0) || (ses->tab == (window *)0x0)) || (url == (uchar *)0x0)) ||
       (ses->tab->term == (terminal *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
      errline = 0x46;
      elinks_internal((uchar *)"assertion ses && ses->tab && ses->tab->term && url failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    else {
      assert_failed = 0;
    }
    if (*url == '\0') {
      return;
    }
    puVar1 = get_translated_uri(url,ses->tab->term->cwd);
    if (puVar1 == (uri *)0x0) {
      if (assert_failed == 0) {
        uVar3 = 0xfffe7957;
      }
      else {
        uVar3 = 0xfffe795d;
      }
      assert_failed = 0;
      print_error_dialog(ses,(connection_state)(ulonglong)uVar3,(uri *)0x0,PRI_CANCEL);
      return;
    }
    if (ses->download_uri != (uri *)0x0) {
      done_uri(ses->download_uri);
    }
    ses->download_uri = puVar1;
    pdVar2 = current_frame(ses);
    if (assert_failed == 0) {
      if (((pdVar2 == (document_view *)0x0) || (pdVar2->document == (document *)0x0)) ||
         (pdVar2->document->uri == (uri *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
        errline = 0x56;
        elinks_internal((uchar *)
                        "assertion doc_view && doc_view->document && doc_view->document->uri failed!"
                       );
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
      }
      else {
        assert_failed = 0;
      }
      set_session_referrer(ses,pdVar2->document->uri);
      query_file(ses,ses->download_uri,ses,start_download,(anon_subr_void_void_ptr *)0x0,1);
      return;
    }
  }
  assert_failed = 0;
  return;
}



void auto_complete_file(terminal *term,int no_elevator,uchar *path,menu_func_T *file_func,
                       menu_func_T *dir_func,void *data)

{
  char *pcVar1;
  uchar uVar2;
  void *p;
  directory_entry *pdVar3;
  int *piVar4;
  uri *uri;
  byte *src;
  uchar *p_00;
  menu_item *pmVar5;
  size_t __n;
  directory_entry *p_01;
  int cp_index;
  uchar *text;
  uchar *codeset;
  uchar *in_EDX;
  uchar *extraout_EDX;
  directory_entry *pdVar6;
  int local_3c;
  int local_34;
  menu_item *local_24;
  byte *local_20 [4];
  
  if (assert_failed == 0) {
    if ((((data == (void *)0x0) || (term == (terminal *)0x0)) || (dir_func == (menu_func_T *)0x0))
       || (file_func == (menu_func_T *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
      errline = 0x41a;
      elinks_internal((uchar *)"assertion term && data && file_func && dir_func && data failed!");
      in_EDX = extraout_EDX;
    }
    else {
      assert_failed = 0;
      in_EDX = (uchar *)data;
    }
  }
  piVar4 = get_opt_(cmdline_options,in_EDX);
  if (*piVar4 == 0) {
    if (*path == '\0') {
      path = "./";
    }
    uri = get_translated_uri(path,term->cwd);
    if (uri != (uri *)0x0) {
      if (uri->protocol == 4) {
        local_20[0] = get_uri_string(uri,URI_PATH);
        done_uri(uri);
        if (local_20[0] != (byte *)0x0) {
          src = get_filename_position(local_20[0]);
          if (*src != 0) {
            cp_index = file_is_dir(local_20[0]);
            if (cp_index == 0) {
              if ((*src != 0) && (cp_index = file_exists(local_20[0]), cp_index != 0)) {
                (*file_func)(term,local_20[0],data);
                return;
              }
            }
            else {
              __n = strlen((char *)local_20[0]);
              src = local_20[0] + __n;
            }
          }
          p_00 = stracpy(src);
          *src = 0;
          if (src[-1] != 0x2f) {
            local_24 = (menu_item *)((uint)local_24 & 0xffffff00 | (uint)*local_20[0]);
            insert_in_string(local_20,(int)(src + -(int)local_20[0]),(uchar *)&local_24,1);
          }
          src = local_20[0];
          pmVar5 = new_menu(FREE_LIST|NO_INTL);
          local_24 = pmVar5;
          __n = strlen((char *)p_00);
          if (pmVar5 != (menu_item *)0x0) {
            p_01 = get_directory_entries(src,1);
            if (p_01 != (directory_entry *)0x0) {
              if (p_01->name == (uchar *)0x0) {
                mem_free(p_01);
              }
              else {
                local_3c = 0;
                local_34 = 0;
                pdVar6 = p_01;
                do {
                  while( true ) {
                    uVar2 = *pdVar6->attrib;
                    mem_free(pdVar6->attrib);
                    if (((uVar2 == '-') || (uVar2 == 'd')) &&
                       (cp_index = file_can_read(pdVar6->name), cp_index != 0)) break;
LAB_0807ddf8:
                    mem_free(pdVar6->name);
LAB_0807de03:
                    pdVar3 = pdVar6 + 1;
                    pdVar6 = pdVar6 + 1;
                    if (pdVar3->name == (uchar *)0x0) goto LAB_0807def0;
                  }
                  text = get_filename_position(pdVar6->name);
                  cp_index = strncmp((char *)p_00,(char *)text,__n);
                  if ((cp_index != 0) ||
                     ((((no_elevator != 0 && (*text == '.')) && (text[1] == '.')) &&
                      (text[2] == '\0')))) goto LAB_0807ddf8;
                  if (uVar2 != 'd') {
                    if (local_3c == 0) {
                      if (local_34 != 0) {
                        add_to_menu(&local_24,"",(uchar *)0x0,ACT_MAIN_NONE,(menu_func_T *)0x0,
                                    (void *)0x0,NO_SELECT);
                      }
                      if ((term != (terminal *)0x0) &&
                         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
                        codeset = get_cp_mime_name(cp_index);
                        bind_textdomain_codeset("elinks",codeset);
                        current_charset = cp_index;
                      }
                      codeset = gettext((uchar *)"Files:");
                      add_to_menu(&local_24,codeset,(uchar *)0x0,ACT_MAIN_NONE,(menu_func_T *)0x0,
                                  (void *)0x0,NO_SELECT);
                      add_to_menu(&local_24,"",(uchar *)0x0,ACT_MAIN_NONE,(menu_func_T *)0x0,
                                  (void *)0x0,NO_SELECT);
                    }
                    add_to_menu(&local_24,text,(uchar *)0x0,ACT_MAIN_NONE,file_func,pdVar6->name,
                                FREE_DATA);
                    local_3c = local_3c + 1;
                    goto LAB_0807de03;
                  }
                  if (local_34 == 0) {
                    if ((term != (terminal *)0x0) &&
                       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
                      codeset = get_cp_mime_name(cp_index);
                      bind_textdomain_codeset("elinks",codeset);
                      current_charset = cp_index;
                    }
                    codeset = gettext((uchar *)"Directories:");
                    add_to_menu(&local_24,codeset,(uchar *)0x0,ACT_MAIN_NONE,(menu_func_T *)0x0,
                                (void *)0x0,NO_SELECT);
                    add_to_menu(&local_24,"",(uchar *)0x0,ACT_MAIN_NONE,(menu_func_T *)0x0,
                                (void *)0x0,NO_SELECT);
                  }
                  add_to_menu(&local_24,text,(uchar *)0x0,ACT_MAIN_NONE,dir_func,pdVar6->name,
                              FREE_DATA|SUBMENU);
                  local_34 = local_34 + 1;
                  pdVar3 = pdVar6 + 1;
                  pdVar6 = pdVar6 + 1;
                } while (pdVar3->name != (uchar *)0x0);
LAB_0807def0:
                mem_free(p_01);
                if ((local_34 != 0) || (local_3c != 0)) {
                  if (local_34 + local_3c == 1) {
                    p = local_24[2].data;
                    mem_free(local_24);
                    if (local_3c == 0) {
                      __n = strlen((char *)src);
                      pcVar1 = (char *)((int)p + __n);
                      if (((*pcVar1 == '.') && (pcVar1[1] == '.')) && (pcVar1[2] == '\0')) {
                        do_menu(term,empty_directory_menu,(void *)0x0,0);
                      }
                      else {
                        (*dir_func)(term,p,data);
                      }
                      mem_free(p);
                    }
                    else {
                      (*file_func)(term,p,data);
                    }
                  }
                  else {
                    do_menu(term,local_24,data,0);
                  }
                  goto LAB_0807df39;
                }
              }
            }
            mem_free(local_24);
          }
LAB_0807df39:
          mem_free(local_20[0]);
          mem_free(p_00);
          return;
        }
      }
      else {
        done_uri(uri);
      }
    }
  }
  return;
}



void push_resize_button(void *data)

{
  int iVar1;
  int in_GS_OFFSET;
  uchar str [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __snprintf_chk(str,0x400,1,0x400,"%s,%s,%d,%d",width_str,height_str,
                 *(undefined4 *)((int)data + 0x2c),*(undefined4 *)((int)data + 0x30));
  do_terminal_function((terminal *)data,'\x02',str);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void menu_language_list(terminal *term,void *xxx,void *ses)

{
  uchar *rtext;
  void *data;
  void *pvVar1;
  menu_item *local_10;
  
  local_10 = new_menu(FREE_LIST);
  if (local_10 != (menu_item *)0x0) {
    if (languages[0].name != (uchar *)0x0) {
      data = (void *)0x0;
      do {
        rtext = language_to_iso639((int)data);
        pvVar1 = (void *)((int)data + 1);
        add_to_menu(&local_10,languages[(int)data].name,rtext,ACT_MAIN_NONE,menu_set_language,data,
                    NO_FLAG);
        data = pvVar1;
      } while (languages[(int)pvVar1].name != (uchar *)0x0);
    }
    do_menu_selected(term,local_10,ses,current_language,0);
  }
  return;
}



void menu_set_language(terminal *term,void *pcp_,void *xxx)

{
  set_language((int)pcp_);
  cls_redraw_all_terminals();
  return;
}



widget_handler_status_T push_ok_button(dialog_data *dlg_data,widget_data *button)

{
  terminal *ptVar1;
  option_value *values;
  widget_handler_status_T wVar2;
  
  ptVar1 = dlg_data->win->term;
  values = (option_value *)dlg_data->dlg->udata;
  update_dialog_data(dlg_data);
  commit_option_values(resolvers,ptVar1->spec,values,8);
  if (button->widget->handler != push_ok_button) {
    return EVENT_PROCESSED;
  }
  wVar2 = cancel_dialog(dlg_data,button);
  return wVar2;
}



widget_handler_status_T push_save_button(dialog_data *dlg_data,widget_data *button)

{
  push_ok_button(dlg_data,button);
  write_config(dlg_data->win->term);
  return EVENT_PROCESSED;
}



void charset_list(terminal *term,void *xxx,void *ses_)

{
  int cp_index;
  uchar *__s1;
  uchar *data;
  int iVar1;
  uchar *text;
  int selected;
  menu_item *local_20 [4];
  
  cp_index = get_terminal_codepage(term);
  __s1 = get_cp_mime_name(cp_index);
  local_20[0] = new_menu(FREE_LIST);
  if (local_20[0] != (menu_item *)0x0) {
    selected = 0;
    cp_index = 0;
    while( true ) {
      text = get_cp_name(cp_index);
      if (text == (uchar *)0x0) break;
      data = get_cp_mime_name(cp_index);
      iVar1 = strcmp((char *)__s1,(char *)data);
      if (iVar1 == 0) {
        selected = cp_index;
      }
      data = get_cp_config_name(cp_index);
      add_to_menu(local_20,text,(uchar *)0x0,ACT_MAIN_NONE,display_codepage,data,NO_FLAG);
      cp_index = cp_index + 1;
    }
    do_menu_selected(term,local_20[0],ses_,selected,0);
  }
  return;
}



void display_codepage(terminal *term,void *name_,void *xxx)

{
  option_elinks *option_elinks;
  int iVar1;
  
  option_elinks = get_opt_rec(term->spec,"charset");
  iVar1 = get_cp_index((uchar *)name_);
  if ((assert_failed == 0) && (assert_failed = ZEXT14(iVar1 == -1), iVar1 == -1)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/options.c";
    errline = 0x24;
    elinks_internal((uchar *)"assertion index != -1 failed: %s",name_);
  }
  if (iVar1 != option_elinks->value) {
    option_elinks->value = iVar1;
    option_changed((session *)0x0,option_elinks);
  }
  cls_redraw_all_terminals();
  return;
}



void resize_terminal_dialog(terminal *term)

{
  int cp_index;
  dialog *dlg;
  uchar *codeset;
  memory_list *ml;
  uint width;
  uint width_00;
  bool bVar1;
  
  width_00 = term->width;
  width = term->height;
  if (0x3e6 < (int)width_00) {
    width_00 = 999;
  }
  if (0x3e6 < (int)width) {
    width = 999;
  }
  cp_index = can_resize_window(term->environment);
  if (cp_index != 0) {
    elinks_ulongcat(width_str,(uint *)0x0,width_00,'\x03',0x20,10);
    elinks_ulongcat(height_str,(uint *)0x0,width,'\x03',0x20,10);
    dlg = (dialog *)mem_calloc(1,0xe4);
    if (dlg != (dialog *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext((uchar *)"Resize terminal");
      dlg->title = codeset;
      dlg->layouter = group_layouter;
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext((uchar *)"Width=");
      add_dlg_field_do(dlg,WIDGET_FIELD,codeset,1,999,check_number,4,width_str,(input_history *)0x0,
                       INPFIELD_NONE);
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext((uchar *)"Height=");
      add_dlg_field_do(dlg,WIDGET_FIELD,codeset,1,999,check_number,4,height_str,(input_history *)0x0
                       ,INPFIELD_NONE);
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext("~OK");
      add_dlg_button_do(dlg,codeset,1,ok_dialog,(void *)0x0,push_resize_button,term);
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext((uchar *)"~Cancel");
      add_dlg_button_do(dlg,codeset,2,cancel_dialog,(void *)0x0,(done_handler_T *)0x0,(void *)0x0);
      if ((assert_failed == 0) &&
         (bVar1 = dlg->number_of_widgets != 4, assert_failed = ZEXT14(bVar1), bVar1)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/options.c";
        errline = 0x13e;
        elinks_internal((uchar *)"assertion 4 == (dlg)->number_of_widgets failed!");
      }
      ml = getml(dlg,0);
      do_dialog(term,dlg,ml);
      return;
    }
  }
  return;
}



void terminal_options(terminal *term,void *xxx,session *ses)

{
  byte *text;
  widget *values;
  int iVar1;
  byte bVar2;
  int *data;
  int cp_index;
  dialog *dlg;
  uchar *codeset;
  memory_list *ml;
  uchar *codeset_00;
  uint uVar3;
  uint uVar4;
  uchar *in_EDX;
  size_t eltsize;
  uint *puVar5;
  uint *puVar6;
  int iVar7;
  int in_GS_OFFSET;
  bool bVar8;
  size_t local_430;
  uchar auStack1059 [3];
  uchar help_text [1024];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  data = get_opt_(cmdline_options,in_EDX);
  iVar1 = *data;
  if (term->height < 0x1f) {
    eltsize = 0x435;
    cp_index = 0;
    local_430 = 1;
  }
  else {
    codeset = term->spec->name;
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset_00 = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset_00);
      current_charset = cp_index;
    }
    codeset_00 = gettext((uchar *)
                         "The environmental variable TERM is set to \'%s\'.\n\nELinks maintains separate sets of values for these options\nand chooses the appropriate set based on the value of TERM.\nThis allows you to configure the settings appropriately for\neach terminal in which you run ELinks."
                        );
    __snprintf_chk(help_text,0x3fd,1,0x400,codeset_00,codeset);
    puVar6 = (uint *)help_text;
    do {
      puVar5 = puVar6;
      uVar3 = *puVar5 + 0xfefefeff & ~*puVar5;
      uVar4 = uVar3 & 0x80808080;
      puVar6 = puVar5 + 1;
    } while (uVar4 == 0);
    bVar8 = (uVar3 & 0x8080) == 0;
    bVar2 = (byte)uVar4;
    if (bVar8) {
      bVar2 = (byte)(uVar4 >> 0x10);
    }
    if (bVar8) {
      puVar6 = (uint *)((int)puVar5 + 6);
    }
    iVar7 = (int)puVar6 + ((-3 - (uint)CARRY1(bVar2,bVar2)) - (int)help_text);
    local_430 = iVar7 + 3;
    auStack1059[iVar7 + 3] = '\n';
    cp_index = iVar7 + 2;
    auStack1059[iVar7 + 4] = '\n';
    eltsize = iVar7 + 0x437;
  }
  help_text[cp_index] = '\0';
  dlg = (dialog *)mem_calloc(1,eltsize);
  if (dlg != (dialog *)0x0) {
    values = dlg[0xc].widgets;
    checkout_option_values(resolvers,term->spec,(option_value *)values,8);
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext("Terminal options");
    *(byte *)&dlg->layout = *(byte *)&dlg->layout | 2;
    text = dlg[0xc].widgets[0].info + 0xc;
    dlg->title = codeset;
    dlg->layouter = generic_dialog_layouter;
    *(widget **)&dlg->udata = values;
    memcpy(text,help_text,local_430);
    add_dlg_text(dlg,text,ALIGN_LEFT,1);
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Frame handling:");
    add_dlg_text(dlg,codeset,ALIGN_LEFT,1);
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"No frames");
    add_dlg_radio_do(dlg,codeset,1,0,(int *)values);
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"VT 100 frames");
    add_dlg_radio_do(dlg,codeset,1,1,(int *)values);
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Linux or OS/2 frames");
    add_dlg_radio_do(dlg,codeset,1,2,(int *)values);
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"FreeBSD frames");
    add_dlg_radio_do(dlg,codeset,1,4,(int *)values);
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"KOI8-R frames");
    add_dlg_radio_do(dlg,codeset,1,3,(int *)values);
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Color mode:");
    add_dlg_text(dlg,codeset,ALIGN_LEFT,1);
    data = &dlg[0xc].widgets[0].datalen;
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"No colors (mono)");
    add_dlg_radio_do(dlg,codeset,2,0,data);
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"16 colors");
    add_dlg_radio_do(dlg,codeset,2,1,data);
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"88 colors");
    add_dlg_radio_do(dlg,codeset,2,2,data);
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"256 colors");
    add_dlg_radio_do(dlg,codeset,2,3,data);
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Switch fonts for line drawing");
    add_dlg_radio_do(dlg,codeset,0,0,(int *)&dlg[0xc].widgets[0].text);
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Restrict frames in cp850/852");
    add_dlg_radio_do(dlg,codeset,0,0,(int *)&dlg[0xc].widgets[0].handler);
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Block cursor");
    add_dlg_radio_do(dlg,codeset,0,0,(int *)&dlg[0xc].widgets[0].data);
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Transparency");
    add_dlg_radio_do(dlg,codeset,0,0,(int *)(dlg[0xc].widgets[0].info + 4));
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Underline");
    add_dlg_radio_do(dlg,codeset,0,0,(int *)(dlg[0xc].widgets[0].info + 8));
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext("UTF-8 I/O");
    add_dlg_radio_do(dlg,codeset,0,0,(int *)dlg[0xc].widgets[0].info);
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext("~OK");
    add_dlg_button_do(dlg,codeset,1,push_ok_button,(void *)0x0,(done_handler_T *)0x0,(void *)0x0);
    if (iVar1 == 0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext((uchar *)"Sa~ve");
      add_dlg_button_do(dlg,codeset,1,push_save_button,(void *)0x0,(done_handler_T *)0x0,(void *)0x0
                       );
    }
    cp_index = get_terminal_codepage(term);
    if (cp_index != current_charset) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"~Cancel");
    add_dlg_button_do(dlg,codeset,2,cancel_dialog,(void *)0x0,(done_handler_T *)0x0,(void *)0x0);
    if ((assert_failed == 0) &&
       (bVar8 = 0x15 - iVar1 != dlg->number_of_widgets, assert_failed = ZEXT14(bVar8), bVar8)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/options.c";
      errline = 0xef;
      elinks_internal((uchar *)
                      "assertion (19 + 1 + 1 + 0) - anonymous == (dlg)->number_of_widgets failed!");
    }
    ml = getml(dlg,0);
    do_dialog(term,dlg,ml);
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void draw_progress_bar(progress *progress,terminal *term,int x,int y,int width,uchar *text,
                      color_pair *meter_color)

{
  longlong lVar1;
  char cVar2;
  size_t sVar3;
  int iVar4;
  uint uVar5;
  uint local_44;
  box barprogress;
  uint local_20 [4];
  uchar s [5];
  
  iVar4 = *(int *)((int)&progress->size + 4);
  if ((iVar4 < 1) && ((iVar4 < 0 || (*(int *)&progress->size == 0)))) {
    local_44 = 0;
  }
  else {
    lVar1 = (ulonglong)*(uint *)&progress->pos * 100;
    local_44 = __divdi3((int)lVar1,
                        (int)((ulonglong)lVar1 >> 0x20) + *(int *)((int)&progress->pos + 4) * 100,
                        *(int *)&progress->size,iVar4);
  }
  if ((text == (uchar *)0x0) && (2 < width)) {
    width = width - 2;
    draw_text(term,x,y,"[",1,0,(color_pair *)0x0);
    draw_text(term,width + x + 1,y,"]",1,0,(color_pair *)0x0);
    x = x + 1;
  }
  if (meter_color == (color_pair *)0x0) {
    meter_color = get_bfu_color(term,"dialog.meter");
  }
  barprogress.height = 1;
  barprogress.width = (int)(local_44 * width) / 100;
  if (width < barprogress.width) {
    barprogress.width = width;
  }
  barprogress.x = 0;
  if (-1 < x) {
    barprogress.x = x;
  }
  barprogress.y = y;
  if (y < 0) {
    barprogress.y = 0;
  }
  if (barprogress.width < 0) {
    barprogress.width = 0;
  }
  draw_box(term,&barprogress,' ',0,meter_color);
  if (text == (uchar *)0x0) {
    if (1 < width) {
      cVar2 = '\x05';
      if (width < 6) {
        cVar2 = (char)width;
      }
      local_20[0] = 0;
      iVar4 = elinks_ulongcat(s,local_20,local_44,cVar2 + -1,0,10);
      if (iVar4 == 0) {
        uVar5 = local_20[0] + 1;
        iVar4 = -local_20[0];
      }
      else {
        s[0] = '?';
        iVar4 = -1;
        uVar5 = 2;
        local_20[0] = 1;
      }
      s[local_20[0]] = '%';
      local_20[0] = uVar5;
      if ((assert_failed == 0) && (assert_failed = ZEXT14((uint)width < uVar5), (uint)width < uVar5)
         ) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/progress.c";
        errline = 0x88;
        elinks_internal((uchar *)"assertion slen <= width failed!");
      }
      text = s;
      x = ((uint)(iVar4 + width) >> 1) + x;
      width = local_20[0];
    }
  }
  else {
    sVar3 = strlen((char *)text);
    if ((int)sVar3 <= width) {
      width = sVar3;
    }
  }
  draw_text(term,x,y,text,width,0,(color_pair *)0x0);
  return;
}



uchar * get_progress_msg(progress *progress,terminal *term,int wide,int full,uchar *separator)

{
  uchar uVar1;
  size_t sVar2;
  string *psVar3;
  int cp_index;
  uchar *codeset;
  char *msgid;
  bool bVar4;
  string msg;
  
  sVar2 = strlen((char *)separator);
  uVar1 = separator[sVar2 - 1];
  psVar3 = init_string(&msg);
  codeset = (uchar *)0x0;
  if (psVar3 != (string *)0x0) {
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Received");
    add_to_string(&msg,codeset);
    add_char_to_string(&msg,' ');
    add_xnum_to_string(&msg,progress->pos);
    if (-1 < *(int *)((int)&progress->size + 4)) {
      add_char_to_string(&msg,' ');
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext("of");
      add_to_string(&msg,codeset);
      add_char_to_string(&msg,' ');
      add_xnum_to_string(&msg,progress->size);
    }
    bVar4 = uVar1 == '\n';
    add_to_string(&msg,separator);
    if (wide == 0) {
      msgid = "speed";
      if (bVar4) {
        msgid = "Speed";
      }
      if (*msgid != '\0') {
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        msgid = (char *)gettext((uchar *)msgid);
      }
      add_to_string(&msg,(uchar *)msgid);
      add_char_to_string(&msg,' ');
      add_xnum_to_string(&msg,(longlong)progress->average_speed);
      add_to_string(&msg,"/s");
    }
    else {
      msgid = "avg";
      if ((full != 0) && (msgid = "average speed", bVar4)) {
        msgid = "Average speed";
      }
      if (*msgid != '\0') {
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        msgid = (char *)gettext((uchar *)msgid);
      }
      add_to_string(&msg,(uchar *)msgid);
      add_char_to_string(&msg,' ');
      add_xnum_to_string(&msg,(longlong)progress->average_speed);
      add_to_string(&msg,"/s");
      add_to_string(&msg,", ");
      msgid = "current speed";
      if (full == 0) {
        msgid = "cur";
      }
      if (*msgid != '\0') {
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        msgid = (char *)gettext((uchar *)msgid);
      }
      add_to_string(&msg,(uchar *)msgid);
      add_char_to_string(&msg,' ');
      add_xnum_to_string(&msg,(longlong)progress->current_speed);
      add_to_string(&msg,"/s");
      msgid = "ETT";
      add_to_string(&msg,separator);
      if ((full != 0) && (msgid = "elapsed time", bVar4)) {
        msgid = "Elapsed time";
      }
      if (*msgid != '\0') {
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        msgid = (char *)gettext((uchar *)msgid);
      }
      add_to_string(&msg,(uchar *)msgid);
      add_char_to_string(&msg,' ');
      add_timeval_to_string(&msg,(timeval_T *)progress);
    }
    codeset = msg.source;
    if (((-1 < *(int *)((int)&progress->size + 4)) &&
        (cp_index = *(int *)((int)&progress->loaded + 4), -1 < cp_index)) &&
       ((0 < cp_index || (*(int *)&progress->loaded != 0)))) {
      msgid = "estimated time";
      add_to_string(&msg,", ");
      if (full == 0) {
        msgid = "ETA";
      }
      if (*msgid != '\0') {
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        msgid = (char *)gettext((uchar *)msgid);
      }
      add_to_string(&msg,(uchar *)msgid);
      add_char_to_string(&msg,' ');
      add_timeval_to_string(&msg,&progress->estimated_time);
      codeset = msg.source;
    }
  }
  return codeset;
}



string * __regparm3 add_bytes_to_string__(string *string,uchar *bytes,int length)

{
  int iVar1;
  uint uVar2;
  uchar *puVar3;
  uint size;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  if (((bytes == (uchar *)0x0) || (string == (string *)0x0)) || (length < 0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 0xff;
    elinks_internal((uchar *)
                    "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  if (length == 0) {
    return string;
  }
  iVar1 = length + string->length;
  uVar2 = string->length + 0xffU & 0xffffff00;
  size = iVar1 + 0x100U & 0xffffff00;
  if (uVar2 < size) {
    puVar3 = (uchar *)mem_realloc(string->source,size);
    if (puVar3 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar3;
    memset(puVar3 + uVar2,0,size - uVar2);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  memcpy(string->source + string->length,bytes,length);
  string->source[iVar1] = '\0';
  string->length = iVar1;
  return string;
}



void update_status(void)

{
  byte bVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  terminal *term;
  terminal_screen *ptVar7;
  int iVar8;
  uint *puVar9;
  int *piVar10;
  terminal *ptVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  char cVar15;
  uchar *in_EDX;
  uchar *name;
  uchar *name_00;
  uchar *name_01;
  uchar *name_02;
  uchar *name_03;
  uchar *name_04;
  session *ses;
  uint uVar16;
  bool bVar17;
  bool bVar18;
  byte local_3c;
  byte local_30;
  int local_2c;
  uint local_24;
  uint local_20;
  
  puVar9 = get_opt_(config_options,in_EDX);
  local_24 = *puVar9;
  puVar9 = get_opt_(config_options,name);
  local_20 = *puVar9;
  piVar10 = get_opt_(config_options,name_00);
  iVar2 = *piVar10;
  puVar9 = get_opt_(config_options,name_01);
  uVar3 = *puVar9;
  puVar9 = get_opt_(config_options,name_02);
  uVar4 = *puVar9;
  piVar10 = get_opt_(config_options,name_03);
  iVar5 = *piVar10;
  piVar10 = get_opt_(config_options,name_04);
  iVar6 = *piVar10;
  if ((list_head_elinks *)sessions.next != &sessions) {
    local_3c = (byte)uVar3;
    local_2c = 1;
    local_30 = (byte)uVar4;
    ptVar11 = (terminal *)0x0;
    ses = (session *)sessions.next;
    do {
      term = ses->tab->term;
      if (term != ptVar11) {
        local_2c = number_of_tabs(term);
      }
      bVar1 = *(byte *)&ses->status;
      uVar12 = (uint)bVar1;
      cVar15 = (char)(bVar1 * '\x02') >> 6;
      uVar13 = (int)cVar15;
      if (cVar15 < '\0') {
        uVar13 = local_24;
      }
      bVar17 = ((uint)(bVar1 >> 2) & 1) != uVar13;
      if (bVar17) {
        uVar12 = uVar12 & 0xfffffffb | (uVar13 & 1) << 2;
        *(char *)&ses->status = (char)uVar12;
      }
      cVar15 = (char)uVar12 * '\b' >> 6;
      uVar16 = (int)cVar15;
      if (cVar15 < '\0') {
        uVar16 = local_20;
      }
      bVar18 = (uVar12 >> 1 & 1) != uVar16;
      if (bVar18) {
        uVar12 = uVar12 & 0xfffffffd | (uVar16 & 1) * 2;
        *(char *)&ses->status = (char)uVar12;
      }
      bVar18 = bVar18 || bVar17;
      uVar14 = 0;
      if (0 < iVar2) {
        uVar14 = (uint)(1 < local_2c || iVar2 != 1);
      }
      if (uVar14 != (uVar12 & 1)) {
        uVar14 = 0;
        if (0 < iVar2) {
          uVar14 = (uint)(1 < local_2c || iVar2 != 1);
        }
        uVar12 = uVar12 & 0xfffffffe | uVar14;
        bVar18 = true;
        *(char *)&ses->status = (char)uVar12;
      }
      if (((uVar12 & 1) != 0) &&
         (bVar1 = *(byte *)&(ses->status).field_0x34, ((uint)(bVar1 >> 2) & 1) != uVar3)) {
        bVar18 = true;
        *(byte *)&(ses->status).field_0x34 = bVar1 & 0xfb | (local_3c & 1) * '\x04';
      }
      bVar1 = *(byte *)&(ses->status).field_0x8;
      if (((uint)bVar1 & 1) != uVar4) {
        bVar18 = true;
        *(byte *)&(ses->status).field_0x8 = bVar1 & 0xfe | local_30 & 1;
      }
      *(byte *)&ses->status = (byte)uVar12 & 0x7f | (byte)(iVar5 << 7);
      if (iVar6 == 0) {
        ses->insert_mode = INSERT_MODE_LESS;
LAB_080800ca:
        if (!bVar18) goto LAB_080800d2;
LAB_08080251:
        render_document_frames(ses,1);
        ptVar7 = term->screen;
        iVar8 = term->height;
        if (0 < ptVar7->dirty_from) {
          ptVar7->dirty_from = 0;
        }
        if (iVar8 <= ptVar7->dirty_to) goto LAB_080800d2;
        ptVar7->dirty_to = iVar8;
        ses = ses->next;
      }
      else {
        if (ses->insert_mode != INSERT_MODE_LESS) goto LAB_080800ca;
        ses->insert_mode = INSERT_MODE_OFF;
        if (bVar18) goto LAB_08080251;
LAB_080800d2:
        ses = ses->next;
      }
      ptVar11 = term;
      local_24 = uVar13;
      local_20 = uVar16;
    } while (ses != (session *)&sessions);
  }
  return;
}



uchar * get_download_msg(download *download,terminal *term,int wide,int full,uchar *separator)

{
  int iVar1;
  uchar *src;
  
  iVar1 = download_is_progressing(download);
  if (iVar1 != 0) {
    src = get_progress_msg(download->progress,term,wide,full,separator);
    return src;
  }
  src = get_state_message(download->state,term);
  src = stracpy(src);
  return src;
}



void print_screen_status(session *ses)

{
  terminal *term;
  document *pdVar1;
  cache_entry *pcVar2;
  anon_enum_32_for_mark aVar3;
  progress *progress;
  byte bVar4;
  int iVar5;
  window *pwVar6;
  color_pair *color;
  color_pair *pcVar7;
  color_pair *pcVar8;
  color_pair *pcVar9;
  color_pair *color_00;
  download *download;
  window *pwVar10;
  document_view *doc_view;
  int cp_index;
  uchar *str;
  uchar *str_00;
  size_t length;
  int length_00;
  int *piVar11;
  string *psVar12;
  int iVar13;
  size_t length_01;
  connection_basic_state cVar14;
  uchar *p;
  int x;
  session *extraout_EDX;
  int width;
  session *extraout_EDX_00;
  session *ses_00;
  session *extraout_EDX_01;
  int in_GS_OFFSET;
  bool bVar15;
  byte bVar16;
  int local_80;
  color_pair *local_7c;
  uchar *local_74;
  uchar *local_70;
  box box;
  string title;
  uint local_4c;
  uchar tab_info [8];
  int local_20;
  
  bVar16 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  term = ses->tab->term;
  iVar5 = number_of_tabs(term);
  pwVar10 = ses->tab;
  pwVar6 = get_tab_by_number(term,term->current_tab);
  if (pwVar10 != pwVar6) goto LAB_08080388;
  bVar4 = *(byte *)&ses->status;
  ses_00 = extraout_EDX;
  if ((char)bVar4 < '\0') {
    if ((((ses->doc_view == (document_view *)0x0) ||
         (pdVar1 = ses->doc_view->document, pdVar1 == (document *)0x0)) ||
        (str_00 = pdVar1->title, str_00 == (uchar *)0x0)) || (*str_00 == '\0')) {
      str_00 = stracpy("ELinks");
    }
    else {
      str_00 = straconcat(str_00," - ELinks",0);
    }
    ses_00 = ses;
    if (str_00 == (uchar *)0x0) {
      bVar4 = *(byte *)&ses->status;
    }
    else {
      length = strlen((char *)str_00);
      if (((ses == last_ses) && (str = (ses->status).last_title, str != (uchar *)0x0)) &&
         (length_01 = strlen((char *)str), length == length_01)) {
        bVar15 = true;
        p = str_00;
        do {
          if (length == 0) break;
          length = length - 1;
          bVar15 = *str == *p;
          str = str + (uint)bVar16 * -2 + 1;
          p = p + (uint)bVar16 * -2 + 1;
        } while (bVar15);
        if (!bVar15) goto LAB_08080910;
      }
      else {
LAB_08080910:
        length_00 = set_terminal_title(term,str_00);
        if (-1 < length_00) {
          str = (ses->status).last_title;
          if (str != (uchar *)0x0) {
            mem_free(str);
            ses_00 = extraout_EDX_00;
          }
          (ses->status).last_title = str_00;
          last_ses = ses;
          bVar4 = *(byte *)&ses->status;
          goto LAB_08080958;
        }
      }
      mem_free(str_00);
      bVar4 = *(byte *)&ses->status;
      ses_00 = extraout_EDX_01;
    }
  }
LAB_08080958:
  if ((bVar4 & 4) != 0) {
    piVar11 = get_opt_(config_options,(uchar *)ses_00);
    if (*piVar11 == 0) {
      box.x = 0;
      box.y = 0;
      box.height = 1;
      box.width = 0;
      if (-1 < term->width) {
        box.width = term->width;
      }
      color = get_bfu_color(term,(uchar *)"title.title-bar");
      draw_box(term,&box,' ',0,color);
    }
    doc_view = current_frame(ses);
    if (doc_view == (document_view *)0x0) {
      bVar4 = *(byte *)&ses->status;
    }
    else {
      if (doc_view->document == (document *)0x0) {
        bVar4 = *(byte *)&ses->status;
      }
      else {
        psVar12 = init_string(&title);
        if (psVar12 != (string *)0x0) {
          pdVar1 = doc_view->document;
          length_00 = (doc_view->box).height;
          x = pdVar1->height;
          if ((length_00 < x) && (doc_view->vs != (view_state *)0x0)) {
            width = 1;
            cp_index = doc_view->vs->y + length_00;
            if (length_00 != 0) {
              width = (x + -1 + length_00) / length_00;
            }
            iVar13 = width;
            if (((cp_index < x) && (iVar13 = 1, length_00 != 0)) &&
               (iVar13 = (cp_index - length_00 / 2) / length_00 + 1, width <= iVar13)) {
              iVar13 = width;
            }
            length_00 = __snprintf_chk(tab_info,0x28,1,0x28," (%d/%d)",iVar13,width);
            if (length_00 < 0) goto LAB_08081078;
          }
          else {
LAB_08081078:
            length_00 = 0;
          }
          str_00 = pdVar1->title;
          if (str_00 != (uchar *)0x0) {
            length_01 = (term->width + -4) - length_00;
            length = 0;
            if (-1 < (int)length_01) {
              length = length_01;
            }
            if ((*(byte *)&term->field_0x38 & 2) == 0) {
              length_01 = strlen((char *)str_00);
              local_70 = (uchar *)length_01;
              if ((int)length_01 < (int)length) goto LAB_08080ea8;
              add_bytes_to_string__(&title,str_00,length);
            }
            else {
              local_70 = (uchar *)utf8_ptr2cells(str_00,(uchar *)0x0);
              if ((int)length < (int)local_70) {
                local_70 = (uchar *)length;
              }
              length_01 = utf8_cells2bytes(pdVar1->title,(int)local_70,(uchar *)0x0);
              str_00 = pdVar1->title;
LAB_08080ea8:
              add_bytes_to_string__(&title,str_00,length_01);
              if (local_70 != (uchar *)length) goto LAB_08080ebd;
            }
            add_bytes_to_string__(&title,"...",3);
          }
LAB_08080ebd:
          if (length_00 != 0) {
            add_bytes_to_string__(&title,tab_info,length_00);
          }
          if (title.length != 0) {
            if ((*(byte *)&term->field_0x38 & 2) == 0) {
              x = ~title.length + term->width;
            }
            else {
              length_00 = term->width;
              x = utf8_ptr2cells(title.source,title.source + title.length);
              x = (length_00 + -1) - x;
            }
            if (x < 1) {
              x = 0;
            }
            color = get_bfu_color(term,(uchar *)"title.title-text");
            draw_text(term,x,0,title.source,title.length,0,color);
          }
          done_string(&title);
        }
        bVar4 = *(byte *)&ses->status;
      }
    }
  }
  if ((bVar4 & 2) == 0) {
LAB_08080968:
    bVar16 = *(byte *)&(ses->status).field_0x8;
  }
  else {
    local_4c = 0;
    download = get_current_download(ses);
    aVar3 = (ses->kbdprefix).mark;
    if (aVar3 == KP_MARK_NOTHING) {
      length_00 = (ses->kbdprefix).repeat_count;
      if (length_00 == 0) {
        if (download == (download *)0x0) goto LAB_08080a99;
        doc_view = current_frame(ses);
        if ((doc_view != (document_view *)0x0) && (doc_view->vs != (view_state *)0x0)) {
          length_00 = doc_view->vs->current_link;
          if (((download->state).basic == S_INTERRUPTED) && (length_00 != last_current_link)) {
            if (assert_failed == 0) {
              cVar14 = S_OK;
            }
            else {
              cVar14 = S_INTERNAL;
            }
            assert_failed = 0;
            (download->state).basic = cVar14;
            (download->state).syserr = 0;
          }
          last_current_link = length_00;
          if ((download->state).basic == S_OK) {
            length_00 = doc_view->vs->current_link;
            if (((length_00 < 0) || (doc_view->document->nlinks <= length_00)) ||
               (doc_view->document->links + length_00 == (link *)0x0)) {
              if (ses->navigate_mode != NAVIGATE_CURSOR_ROUTING) goto LAB_08080fe6;
              str = msg_text(term,(uchar *)"Cursor position: %dx%d",ses->tab->x + 1,ses->tab->y + 1)
              ;
            }
            else {
              str = get_current_link_info(ses,doc_view);
              if ((str != (uchar *)0x0) && (p = get_current_link_title(doc_view), p != (uchar *)0x0)
                 ) {
                if ((assert_failed == 0) && (assert_failed = ZEXT14(*p == '\0'), *p == '\0')) {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/status.c";
                  errline = 0x99;
                  elinks_internal((uchar *)"assertion *link_title failed!");
                }
                str_00 = straconcat(str,&DAT_081327ae,p,0);
                mem_free(str);
                mem_free(p);
                if (str_00 != (uchar *)0x0) goto LAB_08080a9b;
              }
            }
            str_00 = str;
            if (str_00 != (uchar *)0x0) goto LAB_08080a9b;
          }
        }
LAB_08080fe6:
        str_00 = get_download_msg(download,term,(uint)(0x50 < term->width),
                                  (uint)(0x82 < term->width),", ");
      }
      else {
        str_00 = msg_text(term,(uchar *)"Keyboard prefix: %d",length_00);
      }
    }
    else {
      if (aVar3 == KP_MARK_SET) {
        str_00 = msg_text(term,(uchar *)"Enter a mark to set");
      }
      else {
        if (aVar3 == KP_MARK_NOTHING) {
          if (assert_failed == 0) {
            assert_failed = 1;
            str_00 = (uchar *)0x0;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/status.c";
            errline = 0xb5;
            elinks_internal((uchar *)"assertion 0 failed!");
          }
          else {
LAB_08080a99:
            str_00 = (uchar *)0x0;
          }
        }
        else {
          if (aVar3 != KP_MARK_GOTO) goto LAB_08080a99;
          str_00 = msg_text(term,(uchar *)"Enter a mark to which to jump");
        }
      }
    }
LAB_08080a9b:
    box.width = term->width;
    box.x = 0;
    box.height = 1;
    box.y = term->height + -1;
    if (box.y < 0) {
      box.y = 0;
    }
    if (box.width < 0) {
      box.width = 0;
    }
    color = get_bfu_color(term,(uchar *)"status.status-bar");
    draw_box(term,&box,' ',0,color);
    if ((iVar5 < 2) || ((*(byte *)&ses->status & 1) != 0)) {
      color = (color_pair *)0x0;
    }
    else {
      tab_info[local_4c] = '[';
      local_4c = local_4c + 1;
      elinks_ulongcat(tab_info,&local_4c,term->current_tab + 1,'\x04',0,10);
      tab_info[local_4c] = ']';
      tab_info[local_4c + 1] = ' ';
      tab_info[local_4c + 2] = '\0';
      local_4c = local_4c + 2;
      color = get_bfu_color(term,(uchar *)"status.status-text");
      draw_text(term,0,term->height + -1,tab_info,local_4c,0,color);
    }
    if (str_00 == (uchar *)0x0) goto LAB_08080968;
    if (color == (color_pair *)0x0) {
      color = get_bfu_color(term,(uchar *)"status.status-text");
    }
    length = strlen((char *)str_00);
    draw_text(term,local_4c,term->height + -1,str_00,length,0,color);
    mem_free(str_00);
    length_00 = download_is_progressing(download);
    if (length_00 == 0) {
LAB_08080c00:
      bVar16 = *(byte *)&(ses->status).field_0x8;
    }
    else {
      progress = download->progress;
      length_00 = *(int *)((int)&progress->size + 4);
      if (length_00 < 0) {
        bVar16 = *(byte *)&(ses->status).field_0x8;
      }
      else {
        if ((length_00 < 1) && (*(int *)&progress->size == 0)) {
          bVar16 = *(byte *)&(ses->status).field_0x8;
        }
        else {
          bVar16 = *(byte *)&(ses->status).field_0x8;
          length_00 = term->width + -1;
          if ((bVar16 & 1) != 0) {
            length_00 = length_00 - term->leds_length;
          }
          x = (-1 - local_4c) + (length_00 - length);
          if ((-1 < x) && (5 < x)) {
            width = 0x14;
            if (x < 0x15) {
              width = x;
            }
            draw_progress_bar(progress,term,length_00 - width,term->height + -1,width,(uchar *)0x0,
                              (color_pair *)0x0);
            goto LAB_08080c00;
          }
        }
      }
    }
  }
  if ((bVar16 & 1) != 0) {
    if ((ses->doc_view != (document_view *)0x0) &&
       (pdVar1 = ses->doc_view->document, pdVar1 != (document *)0x0)) {
      pcVar2 = pdVar1->cached;
      if (pcVar2 == (cache_entry *)0x0) {
        set_led_value((ses->status).ssl_led,'?');
      }
      else {
        if (pcVar2->ssl_info == (uchar *)0x0) {
          unset_led_value((ses->status).ssl_led);
        }
        else {
          set_led_value((ses->status).ssl_led,'S');
        }
      }
    }
    if (ses->insert_mode == INSERT_MODE_LESS) {
      set_led_value((ses->status).insert_mode_led,'i');
    }
    else {
      if (ses->insert_mode == INSERT_MODE_ON) {
        set_led_value((ses->status).insert_mode_led,'I');
      }
      else {
        unset_led_value((ses->status).insert_mode_led);
      }
    }
    draw_leds(ses);
  }
  bVar16 = *(byte *)&(ses->status).field_0x34;
  if ((bVar16 & 1) == 0) {
    *(byte *)&(ses->status).field_0x34 = bVar16 | 1;
  }
LAB_08080388:
  if ((*(byte *)&ses->status & 1) != 0) {
    color = get_bfu_color(term,"tabs.normal");
    pcVar7 = get_bfu_color(term,"tabs.selected");
    pcVar8 = get_bfu_color(term,"tabs.loading");
    pcVar9 = get_bfu_color(term,"tabs.unvisited");
    color_00 = get_bfu_color(term,"tabs.separator");
    box.width = term->width;
    length_00 = 1;
    if (0 < box.width / iVar5) {
      length_00 = box.width / iVar5;
    }
    local_80 = box.width - iVar5 * length_00;
    if (local_80 < 0) {
      local_80 = 0;
    }
    x = 1;
    if (0 < local_80 / iVar5) {
      x = local_80 / iVar5;
    }
    if ((*(byte *)&(ses->status).field_0x34 & 4) == 0) {
      box.width = 0;
      width = term->height - (2 - (uint)((*(byte *)&ses->status & 2) == 0));
      box.y = 0;
      if (-1 < width) {
        box.y = width;
      }
    }
    else {
      box.y = (uint)(*(byte *)&ses->status >> 2) & 1;
      if (box.width < 0) {
        box.width = 0;
      }
    }
    box.height = 1;
    box.x = 0;
    if (0 < iVar5) {
      width = 0;
      do {
        pwVar10 = get_tab_by_number(term,width);
        ses_00 = (session *)pwVar10->data;
        str_00 = (uchar *)(length_00 - 1U);
        if (local_80 != 0) {
          local_80 = local_80 - x;
          str_00 = (uchar *)(length_00 - 1U) + x;
        }
        if ((ses_00 == (session *)0x0) ||
           (doc_view = current_frame(ses_00), doc_view == (document_view *)0x0)) {
          cp_index = get_terminal_codepage(term);
          if (cp_index != current_charset) {
            str = get_cp_mime_name(cp_index);
            bind_textdomain_codeset("elinks",str);
            current_charset = cp_index;
          }
          local_74 = gettext((uchar *)"No document");
        }
        else {
          local_74 = doc_view->document->title;
          if ((local_74 == (uchar *)0x0) || (*local_74 == '\0')) {
            cp_index = get_terminal_codepage(term);
            if (cp_index != current_charset) {
              str = get_cp_mime_name(cp_index);
              bind_textdomain_codeset("elinks",str);
              current_charset = cp_index;
            }
            local_74 = gettext((uchar *)"Untitled");
          }
        }
        if (width != 0) {
          draw_char(term,box.x,box.y,0xb3,SCREEN_ATTR_FRAME,color_00);
          box.x = box.x + 1;
        }
        local_7c = pcVar7;
        if (width == term->current_tab) {
LAB_080806de:
          box.width = (int)(str_00 + 1);
          draw_box(term,&box,' ',0,local_7c);
          if ((*(byte *)&term->field_0x38 & 2) == 0) {
            str = (uchar *)strlen((char *)local_74);
            if ((int)str_00 <= (int)str) {
              str = str_00;
            }
          }
          else {
            str = utf8_step_forward(local_74,(uchar *)0x0,(int)str_00,UTF8_STEP_CELLS_FEWER,
                                    (int *)0x0);
            str = str + -(int)local_74;
          }
          draw_text(term,box.x,box.y,local_74,(int)str,0,local_7c);
        }
        else {
          download = get_current_download(ses_00);
          if (((download == (download *)0x0) || (local_7c = pcVar8, (download->state).basic == S_OK)
              ) && ((ses_00 == (session *)0x0 ||
                    (local_7c = color, (*(byte *)&(ses_00->status).field_0x34 & 1) == 0)))) {
            local_7c = pcVar9;
          }
          cp_index = download_is_progressing(download);
          if (cp_index == 0) goto LAB_080806de;
          cp_index = *(int *)((int)&download->progress->size + 4);
          if ((cp_index < 0) || ((cp_index < 1 && (*(int *)&download->progress->size == 0))))
          goto LAB_080806de;
          box.width = (int)(str_00 + 1);
          draw_box(term,&box,' ',0,local_7c);
          draw_progress_bar(download->progress,term,box.x,box.y,(int)str_00,local_74,
                            (color_pair *)0x0);
        }
        local_70 = str_00 + 1;
        pwVar10->xpos = box.x;
        if (width != iVar5 + -1) {
          local_70 = str_00;
        }
        width = width + 1;
        *(uchar **)&pwVar10->width = local_70;
        box.x = (int)(str_00 + box.x);
      } while (width < iVar5);
    }
  }
  redraw_from_window(ses->tab);
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



line * realloc_lines(document *document,int y)

{
  line *plVar1;
  uint uVar2;
  size_t size;
  uint uVar3;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (line *)0x0;
  }
  assert_failed = ZEXT14(document == (document *)0x0);
  if (document == (document *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/docdata.c";
    errline = 0x14;
    elinks_internal((uchar *)"assertion document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (line *)0x0;
    }
  }
  if (y < document->height) {
LAB_080813da:
    plVar1 = document->data + y;
  }
  else {
    uVar3 = document->height + 0x7fU & 0xffffff80;
    uVar2 = y + 0x80U & 0xffffff80;
    if (uVar3 < uVar2) {
      size = uVar2 * 8;
      plVar1 = (line *)mem_realloc(document->data,size);
      if (plVar1 != (line *)0x0) {
        document->data = plVar1;
        memset(plVar1 + uVar3,0,size + uVar3 * -8);
        goto LAB_08081436;
      }
    }
    else {
LAB_08081436:
      if (document->data != (line *)0x0) {
        document->height = y + 1;
        goto LAB_080813da;
      }
    }
    plVar1 = (line *)0x0;
  }
  return plVar1;
}



int get_format_cache_size(void)

{
  list_head_elinks **pplVar1;
  int iVar2;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)format_cache.next;
  if ((list_head_elinks *)format_cache.next != &format_cache) {
    do {
      pplVar1 = (list_head_elinks **)&plVar3->next;
      iVar2 = iVar2 + 1;
      plVar3 = *pplVar1;
    } while (*pplVar1 != &format_cache);
  }
  return iVar2;
}



int get_format_cache_used_count(void)

{
  list_head_elinks **pplVar1;
  int iVar2;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)format_cache.next;
  if ((list_head_elinks *)format_cache.next != &format_cache) {
    do {
      pplVar1 = (list_head_elinks **)&plVar3->next;
      iVar2 = iVar2 + (uint)(plVar3[1].next != (void *)0x0);
      plVar3 = *pplVar1;
    } while (*pplVar1 != &format_cache);
  }
  return iVar2;
}



int get_format_cache_refresh_count(void)

{
  list_head_elinks **pplVar1;
  int iVar2;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)format_cache.next;
  if ((list_head_elinks *)format_cache.next != &format_cache) {
    do {
      if ((int *)plVar3[0x19].prev != (int *)0x0) {
        iVar2 = (iVar2 + 1) - (uint)(*(int *)plVar3[0x19].prev == 0);
      }
      pplVar1 = (list_head_elinks **)&plVar3->next;
      plVar3 = *pplVar1;
    } while (*pplVar1 != &format_cache);
  }
  return iVar2;
}



void done_documents(module *module)

{
  free_tags_lookup();
  free_table_cache();
  return;
}



void init_documents(module *module)

{
  init_tags_lookup();
  return;
}



ulong get_document_css_magic(document *document)

{
  uri *uri;
  cache_entry *pcVar1;
  int iVar2;
  ulong uVar3;
  
  uVar3 = 0;
  iVar2 = 0;
  if (0 < (document->css_imports).size) {
    uVar3 = 0;
    do {
      uri = (document->css_imports).uris[iVar2];
      if (uri != (uri *)0x0) {
        pcVar1 = find_in_cache(uri);
        if (pcVar1 != (cache_entry *)0x0) {
          uVar3 = uVar3 + *(int *)&pcVar1->data_size + pcVar1->cache_id;
        }
      }
      iVar2 = iVar2 + 1;
    } while ((document->css_imports).size != iVar2 && iVar2 <= (document->css_imports).size);
  }
  return uVar3;
}



int find_tag(document *document,uchar *name,int namelen)

{
  list_head_elinks *plVar1;
  int iVar2;
  
  plVar1 = (list_head_elinks *)(document->tags).next;
  while( true ) {
    if (plVar1 == &document->tags) {
      return -1;
    }
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
    errline = 0xbe;
    iVar2 = elinks_strlcasecmp((uchar *)(plVar1 + 2),0xffffffff,name,namelen,1);
    if (iVar2 == 0) break;
    plVar1 = (list_head_elinks *)plVar1->next;
  }
  return (int)plVar1[1].prev;
}



void release_document(document *document)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(document == (document *)0x0);
  if (document == (document *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
    errline = 0xad;
    elinks_internal((uchar *)"assertion document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (document->refresh != (document_refresh *)0x0) {
    kill_document_refresh(document->refresh);
  }
  (document->object).refcount = (document->object).refcount + -1;
  if ((document *)format_cache.next != document) {
    document->next->prev = document->prev;
    document->prev->next = document->next;
    *(list_head_elinks **)&document->prev = &format_cache;
    document->next = format_cache.next;
    format_cache.next = document;
    document->next->prev = document;
  }
  return;
}



void __regparm3 free_frameset_desc(frameset_desc *frameset_desc)

{
  frameset_desc *frameset_desc_00;
  uchar *p;
  uri *uri;
  frameset_desc *pfVar1;
  int iVar2;
  
  if (0 < frameset_desc->n) {
    iVar2 = 0;
    pfVar1 = frameset_desc;
    do {
      frameset_desc_00 = pfVar1->frame_desc[0].subframe;
      if (frameset_desc_00 != (frameset_desc *)0x0) {
        free_frameset_desc(frameset_desc_00);
      }
      p = pfVar1->frame_desc[0].name;
      if (p != (uchar *)0x0) {
        mem_free(p);
      }
      uri = pfVar1->frame_desc[0].uri;
      if (uri != (uri *)0x0) {
        done_uri(uri);
      }
      iVar2 = iVar2 + 1;
      pfVar1 = (frameset_desc *)pfVar1->frame_desc;
    } while (frameset_desc->n != iVar2 && iVar2 <= frameset_desc->n);
  }
  mem_free(frameset_desc);
  return;
}



void done_link_members(link *link)

{
  list_head_elinks *p;
  list_head_elinks *p_00;
  list_head_elinks *plVar1;
  bool bVar2;
  
  p = link->event_hooks;
  if (p != (list_head_elinks *)0x0) {
    p_00 = (list_head_elinks *)p->next;
    plVar1 = (list_head_elinks *)p_00->next;
    if (p_00 != p) {
      do {
        if (p_00[1].prev != (void *)0x0) {
          mem_free(p_00[1].prev);
        }
        mem_free(p_00);
        p = link->event_hooks;
        bVar2 = p != plVar1;
        p_00 = plVar1;
        plVar1 = (list_head_elinks *)plVar1->next;
      } while (bVar2);
    }
    mem_free(p);
  }
  if ((link->type < LINK_BUTTON) && ((void *)link->data != (void *)0x0)) {
    mem_free((void *)link->data);
  }
  if (link->where != (uchar *)0x0) {
    mem_free(link->where);
  }
  if (link->target != (uchar *)0x0) {
    mem_free(link->target);
  }
  if (link->title != (uchar *)0x0) {
    mem_free(link->title);
  }
  if (link->where_img != (uchar *)0x0) {
    mem_free(link->where_img);
  }
  if (link->points == (point *)0x0) {
    return;
  }
  mem_free(link->points);
  return;
}



void done_document(document *document)

{
  object *poVar1;
  list_head_elinks *p;
  form *form;
  list_head_elinks *plVar2;
  list_head_elinks *p_00;
  list_head_elinks *plVar3;
  link *link;
  line *p_01;
  int iVar4;
  int iVar5;
  bool bVar6;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(document == (document *)0x0);
  if (document == (document *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
    errline = 0x6e;
    elinks_internal((uchar *)"assertion document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  bVar6 = (document->object).refcount != 0;
  assert_failed = ZEXT14(bVar6);
  if (bVar6) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
    errline = 0x71;
    elinks_internal((uchar *)
                    "assertion !is_object_used(document) failed: Attempt to free locked formatted data."
                   );
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  bVar6 = document->cached == (cache_entry *)0x0;
  assert_failed = ZEXT14(bVar6);
  if (bVar6) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
    errline = 0x74;
    elinks_internal((uchar *)"assertion document->cached failed!");
  }
  poVar1 = &document->cached->object;
  poVar1->refcount = poVar1->refcount + -1;
  if (document->uri != (uri *)0x0) {
    done_uri(document->uri);
  }
  if (document->title != (uchar *)0x0) {
    mem_free(document->title);
  }
  if (document->frame_desc != (frameset_desc *)0x0) {
    free_frameset_desc(document->frame_desc);
  }
  if (document->refresh != (document_refresh *)0x0) {
    done_document_refresh(document->refresh);
  }
  link = document->links;
  if (link != (link *)0x0) {
    if (0 < document->nlinks) {
      iVar5 = 0;
      iVar4 = 0;
      while( true ) {
        link = (link *)((int)&link->accesskey + iVar5);
        iVar4 = iVar4 + 1;
        iVar5 = iVar5 + 0x34;
        done_link_members(link);
        if (document->nlinks == iVar4 || document->nlinks < iVar4) break;
        link = document->links;
      }
      link = document->links;
    }
    mem_free(link);
  }
  p_01 = document->data;
  if (p_01 != (line *)0x0) {
    if (0 < document->height) {
      iVar4 = 0;
      do {
        if (p_01[iVar4].chars != (screen_char *)0x0) {
          mem_free(p_01[iVar4].chars);
          p_01 = document->data;
        }
        iVar4 = iVar4 + 1;
      } while (document->height != iVar4 && iVar4 <= document->height);
    }
    mem_free(p_01);
  }
  if (document->lines1 != (link **)0x0) {
    mem_free(document->lines1);
  }
  if (document->lines2 != (link **)0x0) {
    mem_free(document->lines2);
  }
  done_document_options(&document->options);
  form = (form *)(document->forms).next;
  while (form != (form *)&document->forms) {
    done_form(form);
    form = (form *)(document->forms).next;
  }
  free_uri_list(&document->css_imports);
  p = (list_head_elinks *)(document->tags).next;
  p_00 = p;
  while (p_00 != &document->tags) {
    p_00 = (list_head_elinks *)p_00->next;
  }
  plVar2 = (list_head_elinks *)(document->tags).prev;
  while (plVar2 != p_00) {
    plVar2 = (list_head_elinks *)plVar2->prev;
  }
  plVar2 = (list_head_elinks *)p->next;
  while (p != p_00) {
    plVar2->prev = p->prev;
    *(void **)p->prev = p->next;
    mem_free(p);
    p = plVar2;
    plVar2 = (list_head_elinks *)plVar2->next;
  }
  p_00 = (list_head_elinks *)(document->nodes).next;
  p = &document->nodes;
  plVar2 = p_00;
  while (p != plVar2) {
    plVar2 = (list_head_elinks *)plVar2->next;
  }
  plVar2 = (list_head_elinks *)(document->nodes).prev;
  while (plVar2 != p) {
    plVar2 = (list_head_elinks *)plVar2->prev;
  }
  plVar2 = (list_head_elinks *)p_00->next;
  while (plVar3 = plVar2, p_00 != p) {
    plVar3->prev = p_00->prev;
    *(void **)p_00->prev = p_00->next;
    mem_free(p_00);
    plVar2 = (list_head_elinks *)plVar3->next;
    p_00 = plVar3;
  }
  if (document->search != (search *)0x0) {
    mem_free(document->search);
  }
  if (document->slines1 != (search **)0x0) {
    mem_free(document->slines1);
  }
  if (document->slines2 != (search **)0x0) {
    mem_free(document->slines2);
  }
  document->next->prev = document->prev;
  document->prev->next = document->next;
  mem_free(document);
  return;
}



void shrink_format_cache(int whole)

{
  int iVar1;
  document *pdVar2;
  int *piVar3;
  document *document;
  uchar *in_EDX;
  document *pdVar4;
  int iVar5;
  bool bVar6;
  char *local_38;
  
  iVar5 = 0;
  local_38 = "document.cache.format.size";
  piVar3 = get_opt_(config_options,in_EDX);
  iVar1 = *piVar3;
  document = (document *)format_cache.next;
  pdVar4 = *(document **)format_cache.next;
  if ((list_head_elinks *)format_cache.next != &format_cache) {
    do {
      if ((document->object).refcount == 0) {
        if (document->cached->cache_id == document->cache_id) {
          iVar5 = iVar5 + 1;
          goto LAB_08081bcb;
        }
        done_document(document);
        pdVar2 = pdVar4->next;
      }
      else {
LAB_08081bcb:
        pdVar2 = pdVar4->next;
      }
      bVar6 = pdVar4 != (document *)&format_cache;
      document = pdVar4;
      pdVar4 = pdVar2;
    } while (bVar6);
  }
  if (assert_failed == 0) {
    assert_failed = -(iVar5 >> 0x1f);
    if (assert_failed == 0) goto LAB_08081c1d;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
    errline = 0x126;
    elinks_internal((uchar *)
                    "assertion format_cache_entries >= 0 failed: format_cache_entries underflow on entry"
                    ,local_38);
    if (assert_failed == 0) goto LAB_08081c1d;
  }
  assert_failed = 0;
  iVar5 = 0;
LAB_08081c1d:
  document = (document *)format_cache.prev;
  pdVar4 = *(document **)((int)format_cache.prev + 4);
  if ((list_head_elinks *)format_cache.prev != &format_cache) {
    do {
      if ((document->object).refcount == 0) {
        if ((iVar5 <= iVar1) && (whole == 0)) break;
        iVar5 = iVar5 + -1;
        done_document(document);
      }
      bVar6 = pdVar4 != (document *)&format_cache;
      document = pdVar4;
      pdVar4 = pdVar4->prev;
    } while (bVar6);
  }
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = -(iVar5 >> 0x1f);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
    errline = 0x135;
    elinks_internal((uchar *)
                    "assertion format_cache_entries >= 0 failed: format_cache_entries underflow",
                    local_38);
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  return;
}



document * get_cached_document(cache_entry *cached,document_options *options)

{
  ulong uVar1;
  int iVar2;
  ulong uVar3;
  document *document;
  document *pdVar4;
  bool bVar5;
  
  document = (document *)format_cache.next;
  pdVar4 = *(document **)format_cache.next;
  if ((list_head_elinks *)format_cache.next != &format_cache) {
    do {
      iVar2 = compare_uri(document->uri,cached->uri,0);
      if ((iVar2 != 0) && (iVar2 = compare_opt(&document->options,options), iVar2 == 0)) {
        if (((*(byte *)&options->field_0x5c & 4) == 0) &&
           ((cached->cache_id == document->cache_id &&
            (uVar1 = document->css_magic, uVar3 = get_document_css_magic(document), uVar1 == uVar3))
           )) {
          if ((document *)format_cache.next != document) {
            document->next->prev = document->prev;
            document->prev->next = document->next;
            *(list_head_elinks **)&document->prev = &format_cache;
            document->next = format_cache.next;
            format_cache.next = document;
            document->next->prev = document;
          }
          (document->object).refcount = (document->object).refcount + 1;
          return document;
        }
        if ((document->object).refcount == 0) {
          done_document(document);
        }
      }
      bVar5 = pdVar4 != (document *)&format_cache;
      document = pdVar4;
      pdVar4 = pdVar4->next;
    } while (bVar5);
  }
  return (document *)0x0;
}



document * init_document(cache_entry *cached,document_options *options)

{
  object *poVar1;
  uri *puVar2;
  uint uVar3;
  document *pdVar4;
  
  pdVar4 = (document *)mem_calloc(1,0x118);
  if (pdVar4 != (document *)0x0) {
    puVar2 = cached->uri;
    poVar1 = &puVar2->object;
    poVar1->refcount = poVar1->refcount + 1;
    pdVar4->uri = puVar2;
    uVar3 = cached->cache_id;
    (cached->object).refcount = (cached->object).refcount + 1;
    (pdVar4->object).refcount = (pdVar4->object).refcount + 1;
    pdVar4->cache_id = uVar3;
    *(list_head_elinks **)&(pdVar4->forms).prev = &pdVar4->forms;
    *(list_head_elinks **)&(pdVar4->forms).next = &pdVar4->forms;
    *(list_head_elinks **)&(pdVar4->tags).prev = &pdVar4->tags;
    *(list_head_elinks **)&(pdVar4->tags).next = &pdVar4->tags;
    pdVar4->cached = cached;
    *(list_head_elinks **)&(pdVar4->nodes).prev = &pdVar4->nodes;
    *(list_head_elinks **)&(pdVar4->nodes).next = &pdVar4->nodes;
    copy_opt(&pdVar4->options,options);
    *(list_head_elinks **)&pdVar4->prev = &format_cache;
    pdVar4->next = format_cache.next;
    format_cache.next = pdVar4;
    pdVar4->next->prev = pdVar4;
  }
  return pdVar4;
}



// WARNING: Could not reconcile some variable overlaps

void update_cached_document_options(void)

{
  void *pvVar1;
  void *pvVar2;
  uint uVar3;
  uchar *name;
  list_head_elinks **pplVar4;
  void **ppvVar5;
  uint *puVar6;
  list_head_elinks *plVar7;
  uchar *in_EDX;
  uchar *name_00;
  uchar *name_01;
  uchar *name_02;
  active_link_options active_link;
  
  ppvVar5 = (void **)get_opt_(config_options,in_EDX);
  pvVar1 = *ppvVar5;
  ppvVar5 = (void **)get_opt_(config_options,name_00);
  pvVar2 = *ppvVar5;
  puVar6 = get_opt_(config_options,name_01);
  uVar3 = *puVar6;
  puVar6 = get_opt_(config_options,(uchar *)(uVar3 & 1));
  name_02 = (uchar *)((*puVar6 & 1) << 3);
  puVar6 = get_opt_(config_options,name_02);
  name = (uchar *)((*puVar6 & 1) * 2);
  puVar6 = get_opt_(config_options,name);
  active_link._0_4_ =
       (void *)(uint)(byte)((byte)(uchar *)(uVar3 & 1) | (byte)name_02 | (byte)name & 0xfb |
                           (byte)((*puVar6 & 1) << 2));
  plVar7 = (list_head_elinks *)format_cache.next;
  if ((list_head_elinks *)format_cache.next != &format_cache) {
    do {
      plVar7[0xd].prev = active_link._0_4_;
      plVar7[0xe].next = pvVar1;
      plVar7[0xe].prev = pvVar2;
      pplVar4 = (list_head_elinks **)&plVar7->next;
      plVar7 = *pplVar4;
    } while (*pplVar4 != &format_cache);
  }
  return;
}



void get_screen_char_template(screen_char *template,document_options *options,text_style style)

{
  color_pair colors;
  
  template->attr = '\0';
  template->data = 0x20;
  if (style.attr != 0) {
    if ((style.attr & 4) != 0) {
      template->attr = ' ';
    }
    if ((style.attr & 1) != 0) {
      template->attr = template->attr | 8;
    }
    if ((style.attr & 2) != 0) {
      template->attr = template->attr | 0x10;
    }
    if ((style.attr & 0x10) != 0) {
      template->attr = template->attr | 0x80;
    }
  }
  set_term_color(template,&colors,options->color_flags,options->color_mode);
  return;
}



uchar * form_type2str(form_type num)

{
  int iVar1;
  
  iVar1 = 1;
  if (num == FC_TEXT) {
    iVar1 = 0;
  }
  else {
    while (form_type2name[iVar1].num != num) {
      iVar1 = iVar1 + 1;
      if (iVar1 == 10) {
        return (uchar *)0x0;
      }
    }
  }
  return form_type2name[iVar1].name;
}



int has_form_submit(form *form)

{
  list_head_elinks *plVar1;
  list_head_elinks *plVar2;
  int iVar3;
  bool bVar4;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(form == (form *)0x0);
    if (form == (form *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/forms.c";
      errline = 0x70;
      elinks_internal((uchar *)"assertion form failed!");
      if (assert_failed != 0) goto LAB_08082150;
    }
    plVar1 = &form->items;
    bVar4 = (list_head_elinks *)(form->items).next == plVar1;
    assert_failed = ZEXT14(bVar4);
    if (bVar4) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/forms.c";
      errline = 0x73;
      elinks_internal((uchar *)"assertion !list_empty(form->items) failed: form has no items");
    }
    plVar2 = (list_head_elinks *)(form->items).next;
    while( true ) {
      if (plVar1 == plVar2) {
        return 0;
      }
      if ((int)plVar2[2].prev - 7U < 2) break;
      plVar2 = (list_head_elinks *)plVar2->next;
    }
    iVar3 = 1;
  }
  else {
LAB_08082150:
    assert_failed = 0;
    iVar3 = 0;
  }
  return iVar3;
}



void done_form_control(form_control *fc)

{
  int iVar1;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(fc == (form_control *)0x0);
    if (fc == (form_control *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/forms.c";
      errline = 0x98;
      elinks_internal((uchar *)"assertion fc failed!");
      if (assert_failed != 0) goto LAB_080822b0;
    }
    if (fc->id != (uchar *)0x0) {
      mem_free(fc->id);
    }
    if (fc->name != (uchar *)0x0) {
      mem_free(fc->name);
    }
    if (fc->alt != (uchar *)0x0) {
      mem_free(fc->alt);
    }
    if (fc->default_value != (uchar *)0x0) {
      mem_free(fc->default_value);
    }
    if (0 < fc->nvalues) {
      iVar1 = 0;
      do {
        if (fc->values[iVar1] != (uchar *)0x0) {
          mem_free(fc->values[iVar1]);
        }
        if (fc->labels[iVar1] != (uchar *)0x0) {
          mem_free(fc->labels[iVar1]);
        }
        iVar1 = iVar1 + 1;
      } while (fc->nvalues != iVar1 && iVar1 <= fc->nvalues);
    }
    if (fc->values != (uchar **)0x0) {
      mem_free(fc->values);
    }
    if (fc->labels != (uchar **)0x0) {
      mem_free(fc->labels);
    }
    if (fc->menu != (menu_item *)0x0) {
      free_menu(fc->menu);
      return;
    }
  }
  else {
LAB_080822b0:
    assert_failed = 0;
  }
  return;
}



void done_form(form *form)

{
  form_control *pfVar1;
  form_control *p;
  form_control *pfVar2;
  form_control *fc;
  
  if (form->next != (form *)0x0) {
    form->next->prev = form->prev;
    form->prev->next = form->next;
  }
  if (form->action != (uchar *)0x0) {
    mem_free(form->action);
  }
  if (form->name != (uchar *)0x0) {
    mem_free(form->name);
  }
  if (form->onsubmit != (uchar *)0x0) {
    mem_free(form->onsubmit);
  }
  if (form->target != (uchar *)0x0) {
    mem_free(form->target);
  }
  fc = (form_control *)(form->items).next;
  pfVar2 = (form_control *)&form->items;
  p = fc;
  if (fc != pfVar2) {
    do {
      done_form_control(fc);
      fc = fc->next;
    } while (fc != pfVar2);
    fc = (form_control *)(form->items).next;
    p = fc;
  }
  while (fc != pfVar2) {
    fc = fc->next;
  }
  fc = (form_control *)(form->items).prev;
  while (fc != pfVar2) {
    fc = fc->prev;
  }
  fc = p->next;
  while (pfVar1 = fc, p != pfVar2) {
    pfVar1->prev = p->prev;
    p->prev->next = p->next;
    mem_free(p);
    fc = pfVar1->next;
    p = pfVar1;
  }
  mem_free(form);
  return;
}



int get_form_control_link(document *document,form_control *fc)

{
  int iVar1;
  form_control *pfVar2;
  link *plVar3;
  
  if (fc->type != FC_HIDDEN) {
    if ((*(byte *)&document->field_0x114 & 1) == 0) {
      sort_links(document);
    }
    if (0 < document->nlinks) {
      plVar3 = document->links;
      iVar1 = 0;
      do {
        pfVar2 = (form_control *)0x0;
        if (LINK_MAP < plVar3->type) {
          pfVar2 = (form_control *)plVar3->data;
        }
        if (pfVar2 == fc) {
          return iVar1;
        }
        iVar1 = iVar1 + 1;
        plVar3 = plVar3 + 1;
      } while (iVar1 < document->nlinks);
    }
    if (assert_failed == 0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/forms.c";
      errline = 0x8e;
      elinks_internal((uchar *)"assertion 0 failed: Form control has no link.");
      return -1;
    }
  }
  return -1;
}



form * init_form(void)

{
  form *pfVar1;
  
  pfVar1 = (form *)mem_calloc(1,0x2c);
  if (pfVar1 != (form *)0x0) {
    pfVar1->form_end = 0x7fffffff;
    *(list_head_elinks **)&(pfVar1->items).prev = &pfVar1->items;
    *(list_head_elinks **)&(pfVar1->items).next = &pfVar1->items;
  }
  return pfVar1;
}



int str2form_type(uchar *s)

{
  int iVar1;
  int iVar2;
  
  iVar2 = 0;
  do {
    iVar1 = strcmp((char *)form_type2name[iVar2].name,(char *)s);
    if (iVar1 == 0) {
      return form_type2name[iVar2].num;
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 != 10);
  return -1;
}



void toggle_document_option(session *ses,uchar *option_name)

{
  option_elinks *option_elinks;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if ((((ses == (session *)0x0) || (ses->doc_view == (document_view *)0x0)) ||
      (ses->tab == (window *)0x0)) || (ses->tab->term == (terminal *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/options.c";
    errline = 0x81;
    elinks_internal((uchar *)"assertion ses && ses->doc_view && ses->tab && ses->tab->term failed!")
    ;
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  if (ses->doc_view->vs != (view_state *)0x0) {
    option_elinks = get_opt_rec(config_options,option_name);
    toggle_option(ses,option_elinks);
    draw_formatted(ses,1);
    return;
  }
  nowhere_box(ses->tab->term,(uchar *)0x0);
  return;
}



void done_document_options(document_options *options)

{
  if (options->framename != (uchar *)0x0) {
    mem_free(options->framename);
  }
  mem_free((options->image_link).prefix);
  mem_free((options->image_link).suffix);
  return;
}



void copy_opt(document_options *o1,document_options *o2)

{
  uchar *puVar1;
  uchar **ppuVar2;
  int iVar3;
  uchar *name;
  uchar *name_00;
  document_options *pdVar4;
  document_options *pdVar5;
  
  iVar3 = 0x22;
  pdVar4 = o2;
  pdVar5 = o1;
  while (iVar3 != 0) {
    iVar3 = iVar3 + -1;
    pdVar5->color_mode = pdVar4->color_mode;
    pdVar4 = (document_options *)&pdVar4->cp;
    pdVar5 = (document_options *)&pdVar5->cp;
  }
  puVar1 = stracpy(o2->framename);
  o1->framename = puVar1;
  ppuVar2 = (uchar **)get_opt_(config_options,name);
  puVar1 = stracpy(*ppuVar2);
  (o1->image_link).prefix = puVar1;
  ppuVar2 = (uchar **)get_opt_(config_options,name_00);
  puVar1 = stracpy(*ppuVar2);
  (o1->image_link).suffix = puVar1;
  return;
}



int compare_opt(document_options *o1,document_options *o2)

{
  uint uVar1;
  int iVar2;
  document_options *pdVar3;
  document_options *pdVar4;
  bool bVar5;
  
  iVar2 = 0x48;
  bVar5 = (undefined *)register0x00000010 == (undefined *)0x3c;
  pdVar3 = o1;
  pdVar4 = o2;
  do {
    if (iVar2 == 0) break;
    iVar2 = iVar2 + -1;
    bVar5 = *(char *)&pdVar3->color_mode == *(char *)&pdVar4->color_mode;
    pdVar3 = (document_options *)((int)&pdVar3->color_mode + 1);
    pdVar4 = (document_options *)((int)&pdVar4->color_mode + 1);
  } while (bVar5);
  if (((((bVar5) && (iVar2 = c_strcasecmp((char *)o1->framename,(char *)o2->framename), iVar2 == 0))
       && ((o1->box).x == (o2->box).x)) && ((o1->box).y == (o2->box).y)) &&
     ((((*(byte *)&o1->field_0x5c & 1) == 0 && ((*(byte *)&o2->field_0x5c & 1) == 0)) ||
      ((o1->box).height == (o2->box).height)))) {
    if (((*(byte *)&o1->field_0x5c & 2) != 0) || (uVar1 = 0, (*(byte *)&o2->field_0x5c & 2) != 0)) {
      uVar1 = (uint)((o1->box).width != (o2->box).width);
    }
  }
  else {
    uVar1 = 1;
  }
  return uVar1;
}



void init_document_options(document_options *doo)

{
  byte bVar1;
  uint uVar2;
  int *piVar3;
  color_T *pcVar4;
  uint *puVar5;
  option_value *poVar6;
  int iVar7;
  uchar *in_EDX;
  uchar *name;
  uchar *name_00;
  uchar *name_01;
  uchar *name_02;
  uchar *name_03;
  uchar *name_04;
  uchar *name_05;
  uchar *name_06;
  uchar *name_07;
  uchar *name_08;
  uchar *name_09;
  uchar *name_10;
  uchar *name_11;
  uchar *name_12;
  uchar *name_13;
  uchar *name_14;
  uchar *name_15;
  uchar *name_16;
  uchar *name_17;
  uchar *name_18;
  uchar *name_19;
  uchar *name_20;
  document_options *pdVar8;
  
  iVar7 = 0x22;
  pdVar8 = doo;
  while (iVar7 != 0) {
    iVar7 = iVar7 + -1;
    pdVar8->color_mode = COLOR_MODE_MONO;
    pdVar8 = (document_options *)&pdVar8->cp;
  }
  piVar3 = get_opt_(config_options,in_EDX);
  doo->assume_cp = *piVar3;
  piVar3 = get_opt_(config_options,name);
  doo->hard_assume = *piVar3;
  piVar3 = get_opt_(config_options,name_00);
  doo->use_document_colors = *piVar3;
  piVar3 = get_opt_(config_options,name_01);
  doo->margin = *piVar3;
  piVar3 = get_opt_(config_options,name_02);
  doo->num_links_key = *piVar3;
  piVar3 = get_opt_(config_options,name_03);
  doo->meta_link_display = *piVar3;
  piVar3 = get_opt_(config_options,name_04);
  doo->default_form_input_size = *piVar3;
  pcVar4 = get_opt_(config_options,name_05);
  (doo->default_style).fg = *pcVar4;
  pcVar4 = get_opt_(config_options,name_06);
  (doo->default_style).bg = *pcVar4;
  pcVar4 = get_opt_(config_options,name_07);
  doo->default_link = *pcVar4;
  pcVar4 = get_opt_(config_options,name_08);
  doo->default_vlink = *pcVar4;
  pcVar4 = get_opt_(config_options,name_09);
  doo->default_bookmark_link = *pcVar4;
  pcVar4 = get_opt_(config_options,name_10);
  doo->default_image_link = *pcVar4;
  pcVar4 = get_opt_(config_options,name_11);
  (doo->active_link).fg = *pcVar4;
  pcVar4 = get_opt_(config_options,name_12);
  (doo->active_link).bg = *pcVar4;
  piVar3 = get_opt_(config_options,name_13);
  if (*piVar3 != 0) {
    doo->color_flags = doo->color_flags | COLOR_INCREASE_CONTRAST;
  }
  piVar3 = get_opt_(config_options,name_14);
  if (*piVar3 != 0) {
    doo->color_flags = doo->color_flags | COLOR_ENSURE_CONTRAST;
  }
  puVar5 = get_opt_(config_options,name_15);
  uVar2 = *puVar5;
  *(byte *)&doo->field_0x44 = *(byte *)&doo->field_0x44 & 0xfe | (byte)(uchar *)(uVar2 & 1);
  puVar5 = get_opt_(config_options,(uchar *)(uVar2 & 1));
  name_16 = (uchar *)((*puVar5 & 1) * 2);
  *(byte *)&doo->field_0x44 = *(byte *)&doo->field_0x44 & 0xfd | (byte)name_16;
  puVar5 = get_opt_(config_options,name_16);
  name_16 = (uchar *)((*puVar5 & 1) << 2);
  *(byte *)&doo->field_0x45 = *(byte *)&doo->field_0x45 & 0xfb | (byte)name_16;
  puVar5 = get_opt_(config_options,name_16);
  name_16 = (uchar *)((*puVar5 & 1) << 3);
  *(byte *)&doo->field_0x45 = *(byte *)&doo->field_0x45 & 0xf7 | (byte)name_16;
  puVar5 = get_opt_(config_options,name_16);
  uVar2 = *puVar5;
  *(byte *)&doo->field_0x45 = *(byte *)&doo->field_0x45 & 0xfe | (byte)(uchar *)(uVar2 & 1);
  puVar5 = get_opt_(config_options,(uchar *)(uVar2 & 1));
  name_16 = (uchar *)((*puVar5 & 1) * 2);
  *(byte *)&doo->field_0x45 = *(byte *)&doo->field_0x45 & 0xfd | (byte)name_16;
  puVar5 = get_opt_(config_options,name_16);
  name_16 = (uchar *)((*puVar5 & 1) << 5);
  *(byte *)&doo->field_0x45 = *(byte *)&doo->field_0x45 & 0xdf | (byte)name_16;
  puVar5 = get_opt_(config_options,name_16);
  name_16 = (uchar *)((*puVar5 & 1) << 4);
  *(byte *)&doo->field_0x45 = *(byte *)&doo->field_0x45 & 0xef | (byte)name_16;
  puVar5 = get_opt_(config_options,name_16);
  uVar2 = *puVar5;
  *(byte *)&doo->active_link = *(byte *)&doo->active_link & 0xfe | (byte)(uchar *)(uVar2 & 1);
  puVar5 = get_opt_(config_options,(uchar *)(uVar2 & 1));
  name_16 = (uchar *)((*puVar5 & 1) << 3);
  *(byte *)&doo->active_link = *(byte *)&doo->active_link & 0xf7 | (byte)name_16;
  puVar5 = get_opt_(config_options,name_16);
  name_16 = (uchar *)((*puVar5 & 1) * 2);
  *(byte *)&doo->active_link = *(byte *)&doo->active_link & 0xfd | (byte)name_16;
  puVar5 = get_opt_(config_options,name_16);
  name_16 = (uchar *)((*puVar5 & 1) << 2);
  *(byte *)&doo->active_link = *(byte *)&doo->active_link & 0xfb | (byte)name_16;
  puVar5 = get_opt_(config_options,name_16);
  name_16 = (uchar *)((*puVar5 & 1) << 3);
  *(byte *)&doo->field_0x44 = *(byte *)&doo->field_0x44 & 0xf7 | (byte)name_16;
  puVar5 = get_opt_(config_options,name_16);
  name_16 = (uchar *)((*puVar5 & 1) << 2);
  *(byte *)&doo->field_0x44 = *(byte *)&doo->field_0x44 & 0xfb | (byte)name_16;
  puVar5 = get_opt_(config_options,name_16);
  name_16 = (uchar *)((*puVar5 & 1) << 4);
  *(byte *)&doo->field_0x44 = *(byte *)&doo->field_0x44 & 0xef | (byte)name_16;
  puVar5 = get_opt_(config_options,name_16);
  name_16 = (uchar *)((*puVar5 & 1) << 5);
  *(byte *)&doo->field_0x44 = *(byte *)&doo->field_0x44 & 0xdf | (byte)name_16;
  puVar5 = get_opt_(config_options,name_16);
  name_16 = (uchar *)((*puVar5 & 1) << 6);
  *(byte *)&doo->field_0x44 = *(byte *)&doo->field_0x44 & 0xbf | (byte)name_16;
  piVar3 = get_opt_(config_options,name_16);
  iVar7 = *piVar3;
  bVar1 = *(byte *)&doo->field_0x44;
  doo->framename = "";
  (doo->image_link).prefix = "";
  *(byte *)&doo->field_0x44 = bVar1 & 0x7f | (byte)(uchar *)(iVar7 << 7);
  (doo->image_link).suffix = "";
  piVar3 = get_opt_(config_options,(uchar *)(iVar7 << 7));
  (doo->image_link).filename_maxlen = *piVar3;
  piVar3 = get_opt_(config_options,name_17);
  (doo->image_link).label_maxlen = *piVar3;
  piVar3 = get_opt_(config_options,name_18);
  (doo->image_link).display_style = *piVar3;
  piVar3 = get_opt_(config_options,name_19);
  (doo->image_link).tagging = *piVar3;
  poVar6 = get_opt_(config_options,name_20);
  *(byte *)&(doo->image_link).field_0x18 =
       *(byte *)&(doo->image_link).field_0x18 & 0xfe | (byte)*poVar6 & 1;
  return;
}



void start_document_refreshes(session *ses)

{
  document *pdVar1;
  timer_id_T id;
  list_head_elinks *plVar2;
  uchar **ppuVar3;
  int *piVar4;
  milliseconds_T mVar5;
  int iVar6;
  int delay;
  uchar *in_EDX;
  uchar *extraout_EDX;
  
  if ((assert_failed == 0) && (assert_failed = ZEXT14(ses == (session *)0x0), ses == (session *)0x0)
     ) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/refresh.c";
    errline = 0x7f;
    elinks_internal((uchar *)"assertion ses failed!");
    in_EDX = extraout_EDX;
  }
  if (((ses->doc_view != (document_view *)0x0) &&
      (pdVar1 = ses->doc_view->document, pdVar1 != (document *)0x0)) &&
     (pdVar1->refresh != (document_refresh *)0x0)) {
    ppuVar3 = (uchar **)get_opt_(config_options,in_EDX);
    if (*ppuVar3 != (uchar *)0x0) {
      id = (timer_id_T)ses->doc_view->document->refresh;
      piVar4 = get_opt_(config_options,*ppuVar3);
      delay = *piVar4;
      mVar5 = sec_to_ms((long)id->prev);
      if (((*(byte *)((int)&id->interval + 4) & 1) != 0) && (id->next == (timer *)0x0)) {
        plVar2 = (list_head_elinks *)(ses->type_queries).next;
        while (plVar2 != &ses->type_queries) {
          iVar6 = compare_uri(*(uri **)&id->interval,(uri *)plVar2[8].next,URI_BASE);
          if (iVar6 != 0) {
            return;
          }
          plVar2 = (list_head_elinks *)plVar2->next;
        }
        if (delay <= mVar5) {
          delay = mVar5;
        }
        install_timer((timer_id_T *)id,delay,do_document_refresh,ses);
      }
    }
  }
  return;
}



void do_document_refresh(void *data)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  int iVar3;
  
  puVar1 = *(undefined4 **)(*(int *)(*(int *)((int)data + 0x5c) + 0x14) + 0xcc);
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(puVar1 == (undefined4 *)0x0), puVar1 == (undefined4 *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/refresh.c";
    errline = 0x49;
    elinks_internal((uchar *)"assertion refresh failed!");
  }
  *puVar1 = 0;
  puVar2 = *(undefined4 **)((int)data + 0xa0);
  while (puVar2 != (undefined4 *)((int)data + 0xa0)) {
    iVar3 = compare_uri((uri *)puVar1[2],(uri *)puVar2[0x10],URI_BASE);
    if (iVar3 != 0) {
      return;
    }
    puVar2 = (undefined4 *)*puVar2;
  }
  iVar3 = compare_uri((uri *)puVar1[2],*(uri **)(*(int *)(*(int *)((int)data + 0x5c) + 0x14) + 0xb8)
                      ,0);
  if (iVar3 == 0) {
    goto_uri_frame((session *)data,(uri *)puVar1[2],(uchar *)0x0,CACHE_MODE_NORMAL);
    *(byte *)(puVar1 + 3) = *(byte *)(puVar1 + 3) & 0xfe;
    return;
  }
  reload((session *)data,CACHE_MODE_FORCE_RELOAD);
  return;
}



void kill_document_refresh(document_refresh *refresh)

{
  kill_timer((timer_id_T *)refresh);
  return;
}



void done_document_refresh(document_refresh *refresh)

{
  kill_timer((timer_id_T *)refresh);
  done_uri(refresh->uri);
  mem_free(refresh);
  return;
}



document_refresh * init_document_refresh(uchar *url,ulong seconds)

{
  document_refresh *p;
  uri *puVar1;
  document_refresh *pdVar2;
  
  p = (document_refresh *)mem_alloc(0x10);
  pdVar2 = p;
  if (p != (document_refresh *)0x0) {
    puVar1 = get_uri(url,0);
    p->uri = puVar1;
    if (puVar1 == (uri *)0x0) {
      pdVar2 = (document_refresh *)0x0;
      mem_free(p);
    }
    else {
      *(byte *)&p->field_0xc = *(byte *)&p->field_0xc | 1;
      p->timer = (timer_id_T)0x0;
      p->seconds = seconds;
    }
  }
  return pdVar2;
}



int comp_links(void *v1,void *v2)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  assert_failed = ZEXT14(v2 == (void *)0x0 || v1 == (void *)0x0);
  if (v2 == (void *)0x0 || v1 == (void *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
    errline = 0x204;
    elinks_internal((uchar *)"assertion l1 && l2 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  return *(int *)((int)v1 + 0x20) - *(int *)((int)v2 + 0x20);
}



conv_table *
get_convert_table(uchar *head,int to_cp,int default_cp,int *from_cp,cp_status *cp_status,
                 int ignore_server_cp)

{
  conv_table *pcVar1;
  uchar *name;
  uchar *puVar2;
  int iVar3;
  uchar *local_24;
  uchar *local_20 [4];
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (conv_table *)0x0;
  }
  local_20[0] = head;
  assert_failed = ZEXT14(head == (uchar *)0x0);
  if (head == (uchar *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
    errline = 0x247;
    elinks_internal((uchar *)"assertion head failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (conv_table *)0x0;
    }
  }
  if (ignore_server_cp != 0) {
    if (cp_status != (cp_status *)0x0) {
      *cp_status = CP_STATUS_IGNORED;
    }
    if (from_cp != (int *)0x0) {
      *from_cp = default_cp;
    }
    pcVar1 = get_translation_table(default_cp,to_cp);
    return pcVar1;
  }
  do {
    while( true ) {
      name = parse_header(local_20[0],(uchar *)"Content-Type",local_20);
      if (name == (uchar *)0x0) {
        name = parse_header(head,(uchar *)"Content-Charset",(uchar **)0x0);
        if (name != (uchar *)0x0) {
          iVar3 = get_cp_index(name);
          mem_free(name);
          if (iVar3 != -1) goto LAB_080831ad;
        }
        name = parse_header(head,"Charset",(uchar **)0x0);
        if (name != (uchar *)0x0) {
          iVar3 = get_cp_index(name);
          mem_free(name);
          if (iVar3 != -1) goto LAB_080831ad;
        }
        if (cp_status != (cp_status *)0x0) {
          *cp_status = CP_STATUS_ASSUMED;
        }
        goto LAB_080831bd;
      }
      while (puVar2 = parse_header(local_20[0],(uchar *)"Content-Type",local_20),
            puVar2 != (uchar *)0x0) {
        mem_free(name);
        name = puVar2;
      }
      parse_header_param(name,"charset",&local_24);
      if (local_24 != (uchar *)0x0) break;
      mem_free(name);
    }
    iVar3 = get_cp_index(local_24);
    mem_free(local_24);
    mem_free(name);
  } while (iVar3 == -1);
LAB_080831ad:
  default_cp = iVar3;
  if (cp_status != (cp_status *)0x0) {
    *cp_status = CP_STATUS_SERVER;
  }
LAB_080831bd:
  if (from_cp != (int *)0x0) {
    *from_cp = default_cp;
  }
  pcVar1 = get_translation_table(default_cp,to_cp);
  return pcVar1;
}



void sort_links(document *document)

{
  size_t count;
  link *link;
  link **pplVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  bool bVar5;
  uint local_20;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(document == (document *)0x0);
  if (document == (document *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
    errline = 0x20e;
    elinks_internal((uchar *)"assertion document failed!");
    iVar3 = iRam00000104;
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    iVar3 = document->nlinks;
  }
  if ((iVar3 != 0) && ((*(byte *)&document->field_0x114 & 1) == 0)) {
    bVar5 = document->links == (link *)0x0;
    assert_failed = ZEXT14(bVar5);
    if (bVar5) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
      errline = 0x213;
      elinks_internal((uchar *)"assertion document->links failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    qsort(document->links,document->nlinks,0x34,comp_links);
    count = document->height;
    if (count != 0) {
      if (document->lines1 != (link **)0x0) {
        mem_free(document->lines1);
        count = document->height;
      }
      link = (link *)mem_calloc(count,4);
      *(link **)&document->lines1 = link;
      if (document->lines2 != (link **)0x0) {
        mem_free(document->lines2);
        link = (link *)document->lines1;
      }
      if (link != (link *)0x0) {
        pplVar1 = (link **)mem_calloc(document->height,4);
        document->lines2 = pplVar1;
        if (pplVar1 == (link **)0x0) {
          mem_free(document->lines1);
          return;
        }
        local_20 = 0;
        if (0 < document->nlinks) {
          do {
            link = document->links + local_20;
            if (link->npoints == 0) {
              done_link_members(link);
              memmove(link,link + 1,(~local_20 + document->nlinks) * 0x34);
              iVar3 = document->nlinks + -1;
              document->nlinks = iVar3;
              local_20 = local_20 - 1;
            }
            else {
              iVar3 = link->points->y;
              iVar4 = link->points[link->npoints + -1].y;
              iVar2 = iVar4;
              if (iVar4 < iVar3) {
                iVar2 = iVar3;
                iVar3 = iVar4;
              }
              iVar4 = iVar3 * 4;
              do {
                while (assert_failed != 0) {
LAB_08083467:
                  iVar3 = iVar3 + 1;
                  iVar4 = iVar4 + 4;
                  assert_failed = 0;
                  if (iVar2 < iVar3) goto LAB_0808347c;
                }
                bVar5 = document->height == iVar3 || document->height < iVar3;
                assert_failed = ZEXT14(bVar5);
                if (bVar5) {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
                  errline = 0x235;
                  elinks_internal((uchar *)
                                  "assertion j < document->height failed: link out of screen");
                  if (assert_failed != 0) goto LAB_08083467;
                }
                *(link **)((int)document->lines2 + iVar4) = document->links + local_20;
                pplVar1 = (link **)((int)document->lines1 + iVar4);
                if (*pplVar1 == (link *)0x0) {
                  *pplVar1 = document->links + local_20;
                }
                iVar3 = iVar3 + 1;
                iVar4 = iVar4 + 4;
              } while (iVar3 <= iVar2);
LAB_0808347c:
              iVar3 = document->nlinks;
            }
            local_20 = local_20 + 1;
          } while ((int)local_20 < iVar3);
        }
        *(byte *)&document->field_0x114 = *(byte *)&document->field_0x114 | 1;
      }
    }
  }
  return;
}



void render_document(view_state *vs,document_view *doc_view,document_options *options)

{
  uri *uri;
  byte bVar1;
  document_view *pdVar2;
  cache_entry *cached;
  document *document;
  int iVar3;
  fragment *pfVar4;
  uchar *filename;
  ulong uVar5;
  uri_component components;
  stream_encoding encoding;
  bool bVar6;
  string buffer;
  int local_20 [4];
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if (((doc_view == (document_view *)0x0) || (vs == (view_state *)0x0)) ||
     (options == (document_options *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
    errline = 0x119;
    elinks_internal((uchar *)"assertion vs && doc_view && options failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  filename = doc_view->name;
  doc_view->name = (uchar *)0x0;
  detach_formatted(doc_view);
  doc_view->name = filename;
  doc_view->vs = vs;
  doc_view->last_y = -1;
  doc_view->last_x = -1;
  pdVar2 = vs->doc_view;
  if (pdVar2 != (document_view *)0x0) {
    if (assert_failed == 0) {
      bVar6 = pdVar2->vs != vs;
      assert_failed = ZEXT14(bVar6);
      if (bVar6) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
        errline = 0x139;
        elinks_internal((uchar *)"assertion vs->doc_view->vs == vs failed!");
      }
      pdVar2 = vs->doc_view;
    }
    pdVar2->used = 0;
    vs->doc_view->vs = (view_state *)0x0;
    vs->doc_view = (document_view *)0x0;
  }
  vs->doc_view = doc_view;
  cached = find_in_cache(vs->uri);
  if (cached == (cache_entry *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
    errline = 0x146;
    elinks_internal((uchar *)"document %s to format not found",vs->uri->string);
    return;
  }
  document = get_cached_document(cached,options);
  if (document != (document *)0x0) {
    doc_view->document = document;
    goto LAB_080836ea;
  }
  document = init_document(cached,options);
  if (document == (document *)0x0) {
    return;
  }
  doc_view->document = document;
  if ((doc_view->session != (session *)0x0) && (1 < doc_view->session->reloadlevel)) {
    iVar3 = vs->form_info_len;
    while (0 < iVar3) {
      done_form_state((form_state *)(&vs->form_info->form_view + iVar3 * 9 + -9));
      iVar3 = vs->form_info_len + -1;
      vs->form_info_len = iVar3;
    }
  }
  shrink_memory(0);
  uri = cached->uri;
  pfVar4 = get_cache_fragment(cached);
  buffer.source = "";
  buffer.length = 0;
  if (pfVar4 != (fragment *)0x0) {
    buffer.source = pfVar4->data;
    buffer.length = *(int *)&pfVar4->length;
  }
  if (uri->protocol == 4) {
LAB_08083908:
    encoding = ENCODING_NONE;
  }
  else {
    encoding = ENCODING_NONE;
    filename = get_extension_from_uri(uri);
    if (filename != (uchar *)0x0) {
      encoding = guess_encoding(filename);
      mem_free(filename);
      if (encoding != ENCODING_NONE) {
        local_20[0] = 0;
        filename = decode_encoded_buffer(encoding,buffer.source,buffer.length,local_20);
        if (filename == (uchar *)0x0) goto LAB_08083908;
        buffer.length = local_20[0];
        buffer.source = filename;
      }
    }
  }
  if ((*(byte *)&(document->options).field_0x45 & 0x40) == 0) {
    if (cached->content_type != (uchar *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
      errline = 0x105;
      iVar3 = elinks_strlcasecmp((uchar *)"application/rss+xml",0x13,cached->content_type,0xffffffff
                                 ,1);
      if (iVar3 == 0) goto LAB_080838b8;
    }
    render_html_document(cached,document,&buffer);
  }
  else {
    if ((cached->content_type == (uchar *)0x0) ||
       ((((iVar3 = c_strcasecmp("text/html",(char *)cached->content_type), iVar3 != 0 &&
          (iVar3 = c_strcasecmp("application/xhtml+xml",(char *)cached->content_type), iVar3 != 0))
         && ((iVar3 = c_strcasecmp("application/docbook+xml",(char *)cached->content_type),
             iVar3 != 0 &&
             (((iVar3 = c_strcasecmp("application/rss+xml",(char *)cached->content_type), iVar3 != 0
               && (iVar3 = c_strcasecmp("application/xbel+xml",(char *)cached->content_type),
                  iVar3 != 0)) &&
              (iVar3 = c_strcasecmp("application/x-xbel",(char *)cached->content_type), iVar3 != 0))
             )))) &&
        (iVar3 = c_strcasecmp("application/xbel",(char *)cached->content_type), iVar3 != 0)))) {
      render_plain_document(cached,document,&buffer);
    }
    else {
LAB_080838b8:
      render_dom_document(cached,document,&buffer);
    }
  }
  if (encoding != ENCODING_NONE) {
    done_string(&buffer);
  }
  sort_links(document);
  if (document->title == (uchar *)0x0) {
    components = URI_PUBLIC;
    if (document->uri->protocol == 4) {
      components = URI_PATH;
    }
    filename = get_uri_string(document->uri,components);
    document->title = filename;
    if (filename != (uchar *)0x0) {
      if ((*(byte *)&(doc_view->document->options).field_0x5c & 0x10) == 0) {
        decode_uri_for_display(filename);
      }
      else {
        decode_uri(filename);
      }
    }
  }
  uVar5 = get_document_css_magic(document);
  document->css_magic = uVar5;
LAB_080836ea:
  (doc_view->box).x = (document->options).box.x;
  (doc_view->box).y = (document->options).box.y;
  (doc_view->box).width = (document->options).box.width;
  (doc_view->box).height = (document->options).box.height;
  bVar1 = *(byte *)&(document->options).field_0x5c;
  if ((bVar1 & 2) == 0) {
    (doc_view->box).width = (options->box).width;
    bVar1 = *(byte *)&(document->options).field_0x5c;
  }
  if ((bVar1 & 1) == 0) {
    (doc_view->box).height = (options->box).height;
    return;
  }
  return;
}



void render_document_frames(session *ses,int no_cache)

{
  byte bVar1;
  location *plVar2;
  terminal *ptVar3;
  document *pdVar4;
  document_view *pdVar5;
  color_mode *pcVar6;
  int *piVar7;
  document_view *doc_view;
  document_view *pdVar8;
  int iVar9;
  uchar *name;
  uchar *name_00;
  uint uVar10;
  view_state *vs;
  bool bVar11;
  document_view *local_b0;
  document_options doc_opts;
  
  if (ses->doc_view == (document_view *)0x0) {
    pdVar8 = (document_view *)mem_calloc(1,0x3c);
    ses->doc_view = pdVar8;
    if (pdVar8 == (document_view *)0x0) {
      return;
    }
    pdVar8->session = ses;
    ses->doc_view->search_word = &ses->search_word;
  }
  plVar2 = (ses->history).current;
  vs = &plVar2->vs;
  if (plVar2 == (location *)0x0) {
    vs = (view_state *)0x0;
  }
  init_document_options(&doc_opts);
  ptVar3 = ses->tab->term;
  name = (uchar *)ptVar3->height;
  doc_opts.box.width = ptVar3->width;
  doc_opts.box.x = 0;
  if (doc_opts.box.width < 0) {
    doc_opts.box.width = 0;
  }
  if ((int)name < 0) {
    name = (uchar *)0x0;
  }
  bVar1 = *(byte *)&ses->status;
  bVar11 = (bVar1 & 4) != 0;
  if (bVar11) {
    name = name + -1;
  }
  doc_opts.box.y = ZEXT14(bVar11);
  doc_opts.box.height = (int)name;
  if ((bVar1 & 2) != 0) {
    doc_opts.box.height = (int)(name + -1);
  }
  if (((bVar1 & 1) != 0) &&
     (doc_opts.box.height = doc_opts.box.height + -1, (*(byte *)&(ses->status).field_0x34 & 4) != 0)
     ) {
    doc_opts.box.y = doc_opts.box.y + 1;
  }
  pcVar6 = get_opt_(ses->tab->term->spec,name);
  doc_opts.color_mode = *pcVar6;
  piVar7 = get_opt_(ses->tab->term->spec,name_00);
  if (*piVar7 == 0) {
    doc_opts.color_flags = doc_opts.color_flags | COLOR_ENHANCE_UNDERLINE;
  }
  doc_opts.cp = get_terminal_codepage(ses->tab->term);
  doc_opts._92_1_ =
       doc_opts._92_1_ & 0xf3 | (byte)((no_cache & 1U) << 2) |
       (byte)(((uint)no_cache >> 1 & 1) << 3);
  if (vs == (view_state *)0x0) {
    doc_opts._69_1_ = doc_opts._69_1_ | 0x40;
  }
  else {
    if (vs->plain < 0) {
      vs->plain = 0;
      uVar10 = 0;
    }
    else {
      uVar10 = vs->plain & 1;
    }
    doc_opts._69_1_ = doc_opts._69_1_ & 0x3f | (byte)(uVar10 << 6) | *(char *)&vs->field_0x2c << 7;
  }
  doc_view = (document_view *)(ses->scrn_frames).next;
  pdVar8 = (document_view *)&ses->scrn_frames;
  while (pdVar8 != doc_view) {
    doc_view->used = 0;
    doc_view = doc_view->next;
  }
  if (vs != (view_state *)0x0) {
    render_document(vs,ses->doc_view,&doc_opts);
  }
  pdVar4 = ses->doc_view->document;
  if ((pdVar4 == (document *)0x0) || (pdVar4->frame_desc == (frameset_desc *)0x0)) {
    local_b0 = (document_view *)0x0;
  }
  else {
    local_b0 = current_frame(ses);
    format_frames(ses,ses->doc_view->document->frame_desc,&doc_opts,0);
  }
  doc_view = (document_view *)(ses->scrn_frames).next;
  while (pdVar8 != doc_view) {
    while (pdVar5 = doc_view->prev, doc_view->used == 0) {
      detach_formatted(doc_view);
      doc_view->next->prev = doc_view->prev;
      doc_view->prev->next = doc_view->next;
      mem_free(doc_view);
      doc_view = pdVar5->next;
      if (pdVar8 == doc_view) goto LAB_08083cef;
    }
    doc_view = doc_view->next;
  }
LAB_08083cef:
  if ((local_b0 != (document_view *)0x0) &&
     (doc_view = (document_view *)(ses->scrn_frames).next, pdVar8 != doc_view)) {
    iVar9 = 0;
    do {
      while ((doc_view->document != (document *)0x0 &&
             (doc_view->document->frame_desc != (frameset_desc *)0x0))) {
        doc_view = doc_view->next;
        if (pdVar8 == doc_view) {
          return;
        }
      }
      if (doc_view == local_b0) {
        (((ses->history).current)->vs).current_link = iVar9;
        return;
      }
      doc_view = doc_view->next;
      iVar9 = iVar9 + 1;
    } while (pdVar8 != doc_view);
  }
  return;
}



void apply_css_selector_style
               (html_context *html_context,html_element *element,css_selector *selector)

{
  css_property *pcVar1;
  bool bVar2;
  
  pcVar1 = (css_property *)(selector->properties).next;
  do {
    if (pcVar1 == (css_property *)&selector->properties) {
      return;
    }
    if (assert_failed == 0) {
      bVar2 = CSS_PT_WHITE_SPACE < pcVar1->type;
      assert_failed = ZEXT14(bVar2);
      if (bVar2) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
        errline = 0x114;
        elinks_internal((uchar *)"assertion property->type < CSS_PT_LAST failed!");
        if (assert_failed != 0) goto LAB_08083dfb;
      }
      assert_failed = ZEXT14(css_appliers[pcVar1->type] == (css_applier_T *)0x0);
      if (css_appliers[pcVar1->type] == (css_applier_T *)0x0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
        errline = 0x118;
        elinks_internal((uchar *)"assertion css_appliers[property->type] failed!");
      }
    }
LAB_08083dfb:
    (*css_appliers[pcVar1->type])(html_context,element,pcVar1);
    pcVar1 = pcVar1->next;
  } while( true );
}



void css_apply_text_align(html_context *html_context,html_element *element,css_property *prop)

{
  bool bVar1;
  
  if ((assert_failed == 0) &&
     (bVar1 = prop->value_type != CSS_VT_TEXT_ALIGN, assert_failed = ZEXT14(bVar1), bVar1)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
    errline = 0x65;
    elinks_internal((uchar *)"assertion prop->value_type == CSS_VT_TEXT_ALIGN failed!");
    (element->parattr).align = *(format_align *)&prop->value;
    return;
  }
  (element->parattr).align = *(format_align *)&prop->value;
  return;
}



void css_apply_font_attribute(html_context *html_context,html_element *element,css_property *prop)

{
  text_style_format tVar1;
  bool bVar2;
  
  if ((assert_failed == 0) &&
     (bVar2 = prop->value_type != CSS_VT_FONT_ATTRIBUTE, assert_failed = ZEXT14(bVar2), bVar2)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
    errline = 0x59;
    elinks_internal((uchar *)"assertion prop->value_type == CSS_VT_FONT_ATTRIBUTE failed!");
  }
  tVar1 = *(text_style_format *)&prop->value | (element->attr).style.attr;
  (element->attr).style.attr = tVar1;
  (element->attr).style.attr = ~*(uint *)((int)&prop->value + 4) & tVar1;
  return;
}



void css_apply_display(html_context *html_context,html_element *element,css_property *prop)

{
  bool bVar1;
  
  if ((assert_failed == 0) &&
     (bVar1 = prop->value_type != CSS_VT_DISPLAY, assert_failed = ZEXT14(bVar1), bVar1)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
    errline = 0x43;
    elinks_internal((uchar *)"assertion prop->value_type == CSS_VT_DISPLAY failed!");
  }
  if (*(int *)&prop->value == 0) {
    element->linebreak = 0;
    return;
  }
  if (*(int *)&prop->value != 1) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
    errline = 0x50;
    elinks_internal((uchar *)"Bad prop->value.display %d");
    return;
  }
  element->linebreak = 2;
  return;
}



void css_apply_color(html_context *html_context,html_element *element,css_property *prop)

{
  bool bVar1;
  
  if ((assert_failed == 0) &&
     (bVar1 = prop->value_type != CSS_VT_COLOR, assert_failed = ZEXT14(bVar1), bVar1)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
    errline = 0x2e;
    elinks_internal((uchar *)"assertion prop->value_type == CSS_VT_COLOR failed!");
  }
  if ((html_context->options->color_mode != COLOR_MODE_MONO) &&
     (0 < html_context->options->use_document_colors)) {
    (element->attr).style.fg = *(color_T *)&prop->value;
  }
  return;
}



void css_apply_background_color(html_context *html_context,html_element *element,css_property *prop)

{
  bool bVar1;
  
  if ((assert_failed == 0) &&
     (bVar1 = prop->value_type != CSS_VT_COLOR, assert_failed = ZEXT14(bVar1), bVar1)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
    errline = 0x39;
    elinks_internal((uchar *)"assertion prop->value_type == CSS_VT_COLOR failed!");
  }
  if ((html_context->options->color_mode != COLOR_MODE_MONO) &&
     (html_context->options->use_document_colors == 2)) {
    (element->attr).style.bg = *(color_T *)&prop->value;
    return;
  }
  return;
}



void __regparm3
examine_element(html_context *html_context,css_selector *base,css_selector_type seltype,
               css_selector_relation rel,list_head_elinks *selectors,html_element *element)

{
  html_element_pseudo_class hVar1;
  css_selector *sel2;
  uchar *name;
  html_element *element_00;
  uchar *puVar2;
  html_element *element_01;
  list_head_elinks *selectors_00;
  css_selector_type local_30;
  html_element *local_28;
  
  if ((seltype == CST_ELEMENT) &&
     (element_00 = (html_element *)&html_context->stack, element->namelen != 0)) {
    sel2 = find_css_selector(selectors,CST_ELEMENT,rel,"*",1);
    if (sel2 != (css_selector *)0x0) {
      selectors_00 = &sel2->leaves;
      merge_css_selectors(base,sel2);
      element_01 = element->next;
      if (element_01 != element_00) {
        do {
          examine_element(html_context,base,CST_ELEMENT,CSR_ANCESTOR,selectors_00,element_01);
          element_01 = element_01->next;
        } while (element_00 != element_01);
        examine_element(html_context,base,CST_ELEMENT,CSR_PARENT,selectors_00,element->next);
      }
      examine_element(html_context,base,CST_ID,CSR_SPECIFITY,selectors_00,element);
    }
    sel2 = find_css_selector(selectors,CST_ELEMENT,rel,element->name,element->namelen);
    if (sel2 != (css_selector *)0x0) {
      selectors_00 = &sel2->leaves;
      merge_css_selectors(base,sel2);
      element_01 = element->next;
      if (element_01 != element_00) {
        do {
          examine_element(html_context,base,CST_ELEMENT,CSR_ANCESTOR,selectors_00,element_01);
          element_01 = element_01->next;
        } while (element_00 != element_01);
        examine_element(html_context,base,CST_ELEMENT,CSR_PARENT,selectors_00,element->next);
      }
      examine_element(html_context,base,CST_ID,CSR_SPECIFITY,selectors_00,element);
    }
  }
  local_28 = (html_element *)&html_context->stack;
  name = element->options;
  do {
    if (name == (uchar *)0x0) {
      return;
    }
    hVar1 = element->pseudo_class;
    if ((hVar1 & ELEMENT_LINK) != 0) {
      sel2 = find_css_selector(selectors,CST_PSEUDO,rel,"link",-1);
      if (sel2 != (css_selector *)0x0) {
        selectors_00 = &sel2->leaves;
        merge_css_selectors(base,sel2);
        element_00 = element->next;
        if (element_00 != local_28) {
          do {
            examine_element(html_context,base,CST_ELEMENT,CSR_ANCESTOR,selectors_00,element_00);
            element_00 = element_00->next;
          } while (local_28 != element_00);
          examine_element(html_context,base,CST_ELEMENT,CSR_PARENT,selectors_00,element->next);
        }
        examine_element(html_context,base,CST_INVALID,CSR_SPECIFITY,selectors_00,element);
      }
      hVar1 = element->pseudo_class;
    }
    if (((hVar1 & ELEMENT_VISITED) != 0) &&
       (sel2 = find_css_selector(selectors,CST_PSEUDO,rel,"visited",-1), sel2 != (css_selector *)0x0
       )) {
      selectors_00 = &sel2->leaves;
      merge_css_selectors(base,sel2);
      element_00 = element->next;
      if (local_28 != element_00) {
        do {
          examine_element(html_context,base,CST_ELEMENT,CSR_ANCESTOR,selectors_00,element_00);
          element_00 = element_00->next;
        } while (local_28 != element_00);
        examine_element(html_context,base,CST_ELEMENT,CSR_PARENT,selectors_00,element->next);
      }
      examine_element(html_context,base,CST_INVALID,CSR_SPECIFITY,selectors_00,element);
    }
    name = (element->attr).class;
    if ((seltype < CST_PSEUDO) && (name != (uchar *)0x0)) {
      while( true ) {
        while (*name == ' ') {
          name = name + 1;
        }
        puVar2 = name;
        if (*name == '\0') break;
        do {
          puVar2 = puVar2 + 1;
          if (*puVar2 == '\0') break;
        } while (*puVar2 != ' ');
        sel2 = find_css_selector(selectors,CST_CLASS,rel,name,(int)(puVar2 + -(int)name));
        name = puVar2;
        if (sel2 != (css_selector *)0x0) {
          selectors_00 = &sel2->leaves;
          merge_css_selectors(base,sel2);
          element_00 = element->next;
          if (local_28 != element_00) {
            do {
              examine_element(html_context,base,CST_ELEMENT,CSR_ANCESTOR,selectors_00,element_00);
              element_00 = element_00->next;
            } while (local_28 != element_00);
            examine_element(html_context,base,CST_ELEMENT,CSR_PARENT,selectors_00,element->next);
          }
          examine_element(html_context,base,CST_PSEUDO,CSR_SPECIFITY,selectors_00,element);
        }
      }
    }
    name = (element->attr).id;
    if (CST_ID < seltype) {
      return;
    }
    if (name == (uchar *)0x0) {
      return;
    }
    sel2 = find_css_selector(selectors,CST_ID,rel,name,-1);
    if (sel2 == (css_selector *)0x0) {
      return;
    }
    selectors = &sel2->leaves;
    merge_css_selectors(base,sel2);
    element_00 = element->next;
    if (local_28 != element_00) {
      do {
        examine_element(html_context,base,CST_ELEMENT,CSR_ANCESTOR,selectors,element_00);
        element_00 = element_00->next;
      } while (local_28 != element_00);
      examine_element(html_context,base,CST_ELEMENT,CSR_PARENT,selectors,element->next);
    }
    local_30 = CST_CLASS;
    rel = CSR_SPECIFITY;
    name = element->options;
    seltype = local_30;
  } while( true );
}



css_selector *
get_css_selector_for_element
          (html_context *html_context,html_element *element,css_stylesheet *css,
          list_head_elinks *html_stack)

{
  css_selector *base;
  uchar *string;
  css_selector *sel2;
  scanner scanner;
  
  if (assert_failed == 0) {
    if (((element == (html_element *)0x0) || (css == (css_stylesheet *)0x0)) ||
       (element->options == (uchar *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
      errline = 0xe8;
      elinks_internal((uchar *)"assertion element && element->options && css failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  base = init_css_selector((list_head_elinks *)0x0,CST_ELEMENT,(uchar *)0x0,0);
  if (base != (css_selector *)0x0) {
    examine_element(html_context,base,CST_ELEMENT,CSR_ROOT,&css->selectors,element);
    string = get_attr_value(element->options,"style",html_context->doc_cp,HTML_ATTR_NONE);
    if (string != (uchar *)0x0) {
      sel2 = init_css_selector((list_head_elinks *)0x0,CST_ELEMENT,(uchar *)0x0,0);
      if (sel2 != (css_selector *)0x0) {
        init_scanner(&scanner,&css_scanner_info,string,(uchar *)0x0);
        css_parse_properties(&sel2->properties,&scanner);
        merge_css_selectors(base,sel2);
        done_css_selector(sel2);
      }
      mem_free(string);
    }
  }
  return base;
}



void css_apply(html_context *html_context,html_element *element,css_stylesheet *css,
              list_head_elinks *html_stack)

{
  css_selector *selector;
  
  selector = get_css_selector_for_element(html_context,element,css,html_stack);
  if (selector != (css_selector *)0x0) {
    apply_css_selector_style(html_context,element,selector);
    done_css_selector(selector);
    return;
  }
  return;
}



void done_css(module *module)

{
  done_css_stylesheet(&default_stylesheet);
  return;
}



void import_css_file(css_stylesheet *css,uri *base_uri,uchar *url,int urllen)

{
  uint uVar1;
  string *psVar2;
  uint uVar3;
  uchar *puVar4;
  int iVar5;
  uint size;
  string local_34;
  string filename;
  string string;
  
  if (*url == '\0') {
    return;
  }
  if (9 < css->import_level) {
    return;
  }
  psVar2 = init_string(&filename);
  if (psVar2 == (string *)0x0) {
    return;
  }
  if ((*url != '/') && (elinks_home != (uchar *)0x0)) {
    add_to_string(&filename,elinks_home);
  }
  if (assert_failed == 0) {
    if (urllen < 0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_08084933;
    }
    else {
      assert_failed = 0;
      if (urllen == 0) goto LAB_0808493d;
    }
    iVar5 = urllen + filename.length;
    uVar1 = filename.length + 0xffU >> 8;
    uVar3 = filename.length + 0xffU & 0xffffff00;
    size = iVar5 + 0x100U & 0xffffff00;
    if (uVar3 <= size && size + uVar1 * -0x100 != 0) {
      puVar4 = (uchar *)mem_realloc(filename.source,size);
      if (puVar4 == (uchar *)0x0) goto LAB_0808493d;
      filename.source = puVar4;
      memset(puVar4 + uVar3,0,size + uVar1 * -0x100);
    }
    if (filename.source != (uchar *)0x0) {
      memcpy(filename.source + filename.length,url,urllen);
      filename.source[iVar5] = '\0';
      filename.length = iVar5;
    }
  }
  else {
LAB_08084933:
    assert_failed = 0;
  }
LAB_0808493d:
  read_encoded_file(&local_34,&filename);
  if (local_34.source == (uchar *)0xfffe7960) {
    css->import_level = css->import_level + 1;
    css_parse_stylesheet(css,base_uri,string.source,string.source + string.length);
    done_string(&string);
    css->import_level = css->import_level + -1;
  }
  done_string(&filename);
  return;
}



void import_default_css(void)

{
  uchar *url;
  uchar **ppuVar1;
  size_t urllen;
  uchar *in_EDX;
  
  ppuVar1 = (uchar **)get_opt_(config_options,in_EDX);
  url = *ppuVar1;
  if ((list_head_elinks *)default_stylesheet.selectors.next != &default_stylesheet.selectors) {
    done_css_stylesheet(&default_stylesheet);
  }
  if (*url != '\0') {
    urllen = strlen((char *)url);
    import_css_file(&default_stylesheet,(uri *)0x0,url,urllen);
  }
  return;
}



void init_css(module *module)

{
  change_hook_info css_change_hooks [2];
  
  register_change_hooks((change_hook_info *)&ram0x081019c8);
  import_default_css();
  return;
}



int change_hook_css(session *ses,option_elinks *current,option_elinks *changed)

{
  session **ppsVar1;
  int iVar2;
  uchar *puVar3;
  session *ses_00;
  uchar *puVar4;
  bool bVar5;
  
  iVar2 = 0xb;
  bVar5 = (undefined *)register0x00000010 == &DAT_0000001c;
  puVar3 = changed->name;
  puVar4 = "stylesheet";
  do {
    if (iVar2 == 0) break;
    iVar2 = iVar2 + -1;
    bVar5 = *puVar3 == *puVar4;
    puVar3 = puVar3 + 1;
    puVar4 = puVar4 + 1;
  } while (bVar5);
  if (bVar5) {
    import_default_css();
  }
  ses_00 = (session *)sessions.next;
  if ((list_head_elinks *)sessions.next != &sessions) {
    do {
      draw_formatted(ses_00,1);
      ppsVar1 = &ses_00->next;
      ses_00 = *ppsVar1;
    } while (*ppsVar1 != (session *)&sessions);
  }
  return 0;
}



void import_css(css_stylesheet *css,uri *uri)

{
  int iVar1;
  cache_entry *cached;
  fragment *pfVar2;
  
  if ((uri != (uri *)0x0) && (css->import_level < 10)) {
    cached = get_redirected_cache_entry(uri);
    if (cached != (cache_entry *)0x0) {
      pfVar2 = get_cache_fragment(cached);
      if (pfVar2 != (fragment *)0x0) {
        iVar1 = *(int *)&pfVar2->length;
        css->import_level = css->import_level + 1;
        css_parse_stylesheet(css,uri,pfVar2->data,pfVar2->data + iVar1);
        css->import_level = css->import_level + -1;
        return;
      }
    }
  }
  return;
}



css_selector * __regparm3
reparent_selector(list_head_elinks *sels,css_selector *selector,css_selector **watch)

{
  css_selector *sel1;
  css_selector *selector_00;
  
  sel1 = find_css_selector(sels,selector->type,selector->relation,selector->name,-1);
  if (sel1 != (css_selector *)0x0) {
    merge_css_selectors(sel1,selector);
    selector_00 = (css_selector *)(selector->leaves).next;
    if (selector_00 != (css_selector *)&selector->leaves) {
      do {
        reparent_selector(&sel1->leaves,selector_00,watch);
        selector_00 = (css_selector *)(selector->leaves).next;
      } while (selector_00 != (css_selector *)&selector->leaves);
    }
    if (*watch == selector) {
      *watch = sel1;
    }
    done_css_selector(selector);
    return sel1;
  }
  if (selector->next != (css_selector *)0x0) {
    selector->next->prev = selector->prev;
    selector->prev->next = selector->next;
  }
  sel1 = (css_selector *)sels->next;
  *(list_head_elinks **)&selector->prev = sels;
  selector->next = sel1;
  *(css_selector **)&sels->next = selector;
  selector->next->prev = selector;
  return selector;
}



void css_parse_properties(list_head_elinks *props,scanner *scanner)

{
  scanner_token *psVar1;
  int iVar2;
  uchar *puVar3;
  void *pvVar4;
  scanner_token *psVar5;
  void **p;
  int iVar6;
  css_property_info *propinfo;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(scanner == (scanner *)0x0 || props == (list_head_elinks *)0x0),
     scanner == (scanner *)0x0 || props == (list_head_elinks *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
    errline = 0x1e;
    elinks_internal((uchar *)"assertion props && scanner failed!");
  }
LAB_08084d0b:
  iVar6 = scanner->tokens;
LAB_08084d0e:
  if (iVar6 < 1) {
    return;
  }
  do {
    psVar1 = scanner->current;
    psVar5 = scanner->table + iVar6;
    if (psVar5 <= psVar1) {
      return;
    }
    if (psVar1 == (scanner_token *)0x0) {
      return;
    }
    iVar2 = psVar1->type;
    if (iVar2 == 0x7d) {
      return;
    }
    if (iVar2 == 0x100) {
      if ((psVar1 + 1 < psVar5) && (psVar1[1].type == 0x3a)) {
        propinfo = css_property_info;
        puVar3 = css_property_info[0].name;
        break;
      }
    }
    else {
      if (iVar2 == 0x7b) goto LAB_08084e70;
    }
    skip_scanner_tokens(scanner,0x3b,0x100);
    iVar6 = scanner->tokens;
    if (iVar6 < 1) {
      return;
    }
  } while( true );
joined_r0x08084d81:
  if (puVar3 == (uchar *)0x0) goto LAB_08084ebd;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
  errline = 0x39;
  iVar6 = elinks_strlcasecmp(psVar1->string,psVar1->length,propinfo->name,0xffffffff,1);
  if (iVar6 == 0) goto LAB_08084dd6;
  puVar3 = propinfo[1].name;
  propinfo = propinfo + 1;
  goto joined_r0x08084d81;
LAB_08084ebd:
  propinfo = (css_property_info *)0x0;
LAB_08084dd6:
  psVar5 = skip_scanner_tokens(scanner,0x3a,0);
  if (psVar5 == (scanner_token *)0x0) {
    if (assert_failed == 0) {
      if ((0 < scanner->tokens) && (scanner->current < scanner->table + scanner->tokens)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
        errline = 0x41;
        elinks_internal((uchar *)"assertion !scanner_has_tokens(scanner) failed!");
        return;
      }
      assert_failed = 0;
    }
    return;
  }
  if ((propinfo != (css_property_info *)0x0) && (p = (void **)mem_calloc(1,0x18), p != (void **)0x0)
     ) {
    p[2] = (void *)propinfo->type;
    p[3] = (void *)propinfo->value_type;
    iVar6 = css_parse_value(propinfo,(css_property_value *)(p + 4),scanner);
    if (iVar6 == 0) {
      mem_free(p);
    }
    else {
      pvVar4 = props->next;
      *(list_head_elinks **)(p + 1) = props;
      *p = pvVar4;
      *(void ***)&props->next = p;
      *(void ***)((int)*p + 4) = p;
    }
  }
  skip_scanner_tokens(scanner,0x3b,0x100);
  goto LAB_08084d0b;
LAB_08084e70:
  scanner->current = psVar1 + 1;
  if (psVar5 <= psVar1 + 2) {
    (*scanner->info->scan)(scanner);
    iVar6 = scanner->tokens;
  }
  goto LAB_08084d0e;
}



void __regparm3 skip_css_block(scanner *scanner)

{
  scanner_token *psVar1;
  scanner_token *psVar2;
  scanner_token *psVar3;
  int iVar4;
  int iVar5;
  
  psVar3 = skip_scanner_tokens(scanner,0x7b,0x200);
  if ((((psVar3 != (scanner_token *)0x0) && (iVar4 = scanner->tokens, 0 < iVar4)) &&
      (psVar3 = scanner->current, psVar3 < scanner->table + iVar4)) &&
     ((psVar3 != (scanner_token *)0x0 && (psVar3->precedence < 0x401)))) {
    iVar5 = 1;
    while( true ) {
      if (psVar3->type == 0x7b) {
        iVar5 = iVar5 + 1;
      }
      else {
        iVar5 = iVar5 - (uint)(psVar3->type == 0x7d);
      }
      if (iVar4 < 1) break;
      psVar2 = scanner->current;
      psVar1 = scanner->table + iVar4;
      if (psVar1 <= psVar2) {
        return;
      }
      psVar3 = psVar2 + 1;
      scanner->current = psVar3;
      if (psVar2 + 2 < psVar1) {
        if (psVar1 <= psVar3) {
          return;
        }
      }
      else {
        psVar3 = (*scanner->info->scan)(scanner);
      }
      if (psVar3 == (scanner_token *)0x0) {
        return;
      }
      if (iVar5 < 1) {
        return;
      }
      if (0x400 < psVar3->precedence) {
        return;
      }
      iVar4 = scanner->tokens;
    }
  }
  return;
}



void css_parse_stylesheet(css_stylesheet *css,uri *base_uri,uchar *string,uchar *end)

{
  uchar uVar1;
  list_head_elinks **pplVar2;
  list_head_elinks *p;
  list_head_elinks *plVar3;
  list_head_elinks *plVar4;
  css_selector *pcVar5;
  list_head_elinks *sels;
  scanner_token *psVar6;
  list_head_elinks *sels_00;
  css_selector_relation cVar7;
  uint uVar8;
  int namelen;
  scanner_token *psVar9;
  uchar *name;
  css_selector *pcVar10;
  css_selector *selector;
  uint uVar11;
  bool bVar12;
  bool bVar13;
  bool bVar14;
  css_selector_type local_100;
  css_selector *local_fc;
  css_selector *local_f8;
  scanner_token *local_f4;
  void **local_f0;
  scanner scanner;
  list_head_elinks properties;
  list_head_elinks selectors;
  
  init_scanner(&scanner,&css_scanner_info,string,end);
  sels_00 = &css->selectors;
LAB_08085068:
  while( true ) {
    if ((scanner.tokens < 1) || (scanner.table + scanner.tokens <= scanner.current)) {
      return;
    }
    psVar9 = scanner.current;
    if (scanner.table + scanner.tokens <= scanner.current) {
      psVar9 = (scanner_token *)0x0;
    }
    if ((assert_failed == 0) &&
       (assert_failed = ZEXT14(psVar9 == (scanner_token *)0x0), psVar9 == (scanner_token *)0x0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
      errline = 0x229;
      elinks_internal((uchar *)"assertion token failed!");
    }
    if (5 < psVar9->type - 0x110U) break;
    namelen = iRam00000000;
    if ((0 < scanner.tokens) && (scanner.current < scanner.table + scanner.tokens)) {
      namelen = (scanner.current)->type;
    }
    if (namelen - 0x110U < 6) {
                    // WARNING: Could not recover jumptable at 0x0808512e. Too many branches
                    // WARNING: Treating indirect jump as call
      (*(code *)(&PTR_DAT_081019d8)[namelen - 0x110U])();
      return;
    }
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
    errline = 0xb4;
    elinks_internal((uchar *)"@-rule parser called without atrule.");
  }
  selectors.next = &selectors;
  selector = (css_selector *)0x0;
  properties.next = &properties;
  uVar11 = 0;
  bVar14 = true;
  local_fc = (css_selector *)0x0;
  local_f8 = (css_selector *)0x0;
  local_f0 = (void **)0x0;
  properties.prev = properties.next;
  selectors.prev = selectors.next;
LAB_080851de:
  psVar9 = scanner.current;
  if ((scanner.tokens < 1) || (scanner.table + scanner.tokens <= scanner.current))
  goto LAB_080852c1;
  if (assert_failed == 0) {
    assert_failed = ZEXT14(scanner.current == (scanner_token *)0x0);
    if (scanner.current == (scanner_token *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
      errline = 0x116;
      elinks_internal((uchar *)"assertion token failed!");
      if (assert_failed != 0) goto LAB_0808522b;
    }
    assert_failed = uVar11;
    if (uVar11 != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
      errline = 0x117;
      elinks_internal((uchar *)"assertion !last_fragment failed!");
    }
  }
LAB_0808522b:
  namelen = psVar9->type;
  if (((namelen == 0x7d) || (namelen == 0x7b)) || (namelen == 0x3b)) goto LAB_080852c1;
  if (namelen == 0x100) {
    if (local_f0 == (void **)0x0) {
      namelen = psVar9->length;
      cVar7 = CSR_ROOT;
      name = psVar9->string;
      local_100 = CST_ELEMENT;
    }
    else {
      namelen = psVar9->length;
      cVar7 = CSR_ANCESTOR;
      name = psVar9->string;
      local_100 = CST_ELEMENT;
    }
  }
  else {
    if (namelen != 0x3e) {
      if (namelen < 0x3f) {
        if (namelen == 0x2e) {
          local_100 = CST_CLASS;
        }
        else {
          if (namelen != 0x3a) goto LAB_080851a6;
          local_100 = CST_PSEUDO;
        }
        if (bVar14) {
          cVar7 = CSR_ANCESTOR;
        }
        else {
          cVar7 = CSR_SPECIFITY;
        }
        goto LAB_080854c5;
      }
      uVar8 = namelen - 0x10b;
      if (uVar8 < 2) {
        local_100 = CST_ID;
        cVar7 = CSR_ANCESTOR - (uint)!bVar14;
        goto LAB_08085485;
      }
LAB_080851a6:
      psVar9 = skip_scanner_tokens(&scanner,0x2c,0);
      if (((psVar9 == (scanner_token *)0x0) && (0 < scanner.tokens)) &&
         ((scanner.current < scanner.table + scanner.tokens &&
          (psVar9 = scanner.current + 1, psVar6 = scanner.current + 2, scanner.current = psVar9,
          scanner.table + scanner.tokens <= psVar6)))) {
        (*(scanner.info)->scan)(&scanner);
      }
      goto LAB_080851de;
    }
    local_100 = CST_ELEMENT;
    cVar7 = CSR_PARENT;
    uVar8 = 0xffffff33;
LAB_08085485:
    if (1 < uVar8) {
LAB_080854c5:
      if ((scanner.tokens < 1) ||
         (psVar9 = scanner.table + scanner.tokens, psVar9 <= scanner.current)) goto LAB_080852c1;
      psVar6 = scanner.current + 1;
      if (scanner.current + 2 < psVar9) {
        scanner.current = psVar6;
        if (psVar9 <= psVar6) goto LAB_080852c1;
      }
      else {
        scanner.current = psVar6;
        psVar6 = (*(scanner.info)->scan)(&scanner);
      }
      if (psVar6 == (scanner_token *)0x0) goto LAB_080852c1;
      if (psVar6->type == 0x100) {
        namelen = psVar6->length;
        name = psVar6->string;
        goto LAB_08085273;
      }
      goto LAB_080851de;
    }
    name = psVar9->string + 1;
    namelen = psVar9->length + -1;
    psVar9->string = name;
    psVar9->length = namelen;
  }
LAB_08085273:
  if (name + namelen < scanner.end) {
    uVar1 = name[namelen];
    if ((uVar1 == '.') || (uVar1 == '#')) {
      bVar14 = false;
    }
    else {
      bVar14 = uVar1 != ':';
    }
  }
  if ((scanner.tokens < 1) || (psVar9 = scanner.table + scanner.tokens, psVar9 <= scanner.current))
  goto LAB_080852c1;
  local_f4 = scanner.current + 1;
  if (scanner.current + 2 < psVar9) {
    scanner.current = local_f4;
    if (psVar9 <= local_f4) goto LAB_080852c1;
  }
  else {
    scanner.current = local_f4;
    local_f4 = (*(scanner.info)->scan)(&scanner);
  }
  if (local_f4 == (scanner_token *)0x0) goto LAB_080852c1;
  bVar12 = local_f4->type == 0x7b;
  bVar13 = local_f4->type == 0x2c;
  uVar11 = (uint)(bVar12 || bVar13);
  if (local_f0 == (void **)0x0) {
    if ((css == (css_stylesheet *)0x0) || (sels = sels_00, !bVar12 && !bVar13)) {
      sels = (list_head_elinks *)0x0;
    }
    pcVar10 = get_css_selector(sels,local_100,CSR_ROOT,name,namelen);
    if ((pcVar10 == (css_selector *)0x0) ||
       (local_f0 = (void **)mem_calloc(1,0xc), local_f0 == (void **)0x0)) goto LAB_080851de;
    *local_f0 = selectors.next;
    *(list_head_elinks **)(local_f0 + 1) = &selectors;
    *(void ***)((int)*local_f0 + 4) = local_f0;
    *(css_selector **)(local_f0 + 2) = pcVar10;
    pcVar5 = pcVar10;
    selectors.next = local_f0;
    if (cVar7 != CSR_SPECIFITY) {
LAB_0808562c:
      pcVar10 = (css_selector *)0x0;
      selector = pcVar5;
    }
LAB_08085630:
    if (bVar12 || bVar13) {
      bVar14 = true;
      pcVar10 = (css_selector *)0x0;
      selector = (css_selector *)0x0;
      local_fc = (css_selector *)0x0;
      local_f0 = (void **)0x0;
    }
  }
  else {
    if (cVar7 != CSR_SPECIFITY) {
      if ((css == (css_stylesheet *)0x0) || (sels = sels_00, !bVar12 && !bVar13)) {
        sels = (list_head_elinks *)0x0;
      }
      pcVar5 = get_css_selector(sels,local_100,CSR_ROOT,name,namelen);
      if (pcVar5 != (css_selector *)0x0) {
        if ((assert_failed == 0) &&
           (assert_failed = ZEXT14(selector == (css_selector *)0x0), selector == (css_selector *)0x0
           )) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
          errline = 0x1ad;
          elinks_internal((uchar *)"assertion prev_element_selector failed!");
        }
        pcVar10 = (css_selector *)(pcVar5->leaves).next;
        selector->prev = (css_selector *)&pcVar5->leaves;
        selector->next = pcVar10;
        *(css_selector **)&(pcVar5->leaves).next = selector;
        selector->next->prev = selector;
        selector->relation = cVar7;
        local_fc = selector;
        goto LAB_0808562c;
      }
      goto LAB_080851de;
    }
    pcVar5 = local_f8;
    if (local_f8 == (css_selector *)0x0) {
      pcVar5 = selector;
    }
    if ((assert_failed == 0) &&
       (assert_failed = ZEXT14(pcVar5 == (css_selector *)0x0), pcVar5 == (css_selector *)0x0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
      errline = 0x17f;
      elinks_internal((uchar *)"assertion base_sel failed!");
    }
    pcVar10 = get_css_selector(&pcVar5->leaves,local_100,CSR_SPECIFITY,name,namelen);
    if (pcVar10 == (css_selector *)0x0) goto LAB_080851de;
    if (local_fc != (css_selector *)0x0) {
      local_fc->next->prev = local_fc->prev;
      local_fc->prev->next = local_fc->next;
      local_fc->next = (css_selector *)(pcVar10->leaves).next;
      local_fc->prev = (css_selector *)&pcVar10->leaves;
      *(css_selector **)&(pcVar10->leaves).next = local_fc;
      local_fc->next->prev = local_fc;
    }
    if (pcVar5 == (css_selector *)local_f0[2]) {
      *(css_selector **)(local_f0 + 2) = pcVar10;
    }
    if (bVar12 || bVar13) {
      if ((assert_failed == 0) &&
         (assert_failed = ZEXT14(selector == (css_selector *)0x0), selector == (css_selector *)0x0))
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
        errline = 0x19b;
        elinks_internal((uchar *)"assertion prev_element_selector failed!");
      }
      selector->relation = CSR_ROOT;
      selector = reparent_selector(sels_00,selector,(css_selector **)(local_f0 + 2));
      goto LAB_08085630;
    }
  }
  local_f8 = pcVar10;
  if (local_f4->type == 0x2c) {
    if (((0 < scanner.tokens) && (scanner.current < scanner.table + scanner.tokens)) &&
       (psVar9 = scanner.current + 1, psVar6 = scanner.current + 2, scanner.current = psVar9,
       scanner.table + scanner.tokens <= psVar6)) {
      uVar11 = 0;
      (*(scanner.info)->scan)(&scanner);
      goto LAB_080851de;
    }
  }
  else {
    if (local_f4->type == 0x7b) goto LAB_080852c1;
  }
  uVar11 = 0;
  goto LAB_080851de;
LAB_080852c1:
  if (local_f0 != (void **)0x0) {
    if (selector != (css_selector *)0x0) {
      done_css_selector(selector);
    }
    *(void **)((int)*local_f0 + 4) = local_f0[1];
    *(void **)local_f0[1] = *local_f0;
    mem_free(local_f0);
  }
  if (&selectors != (list_head_elinks *)selectors.next) {
    psVar9 = skip_scanner_tokens(&scanner,0x7b,0x200);
    if (psVar9 != (scanner_token *)0x0) {
      css_parse_properties(&properties,&scanner);
      skip_scanner_tokens(&scanner,0x7d,0x400);
      sels = (list_head_elinks *)selectors.next;
      while (p = (list_head_elinks *)selectors.next, sels != &selectors) {
        add_selector_properties((css_selector *)sels[1].next,&properties);
        sels = (list_head_elinks *)sels->next;
      }
      while (sels = (list_head_elinks *)selectors.prev, p != &selectors) {
        p = (list_head_elinks *)p->next;
      }
      while (sels != p) {
        sels = (list_head_elinks *)sels->prev;
      }
      plVar4 = (list_head_elinks *)((list_head_elinks *)selectors.next)->next;
      sels = (list_head_elinks *)selectors.next;
      while (plVar3 = plVar4, sels != p) {
        plVar3->prev = sels->prev;
        *(void **)sels->prev = sels->next;
        mem_free(sels);
        plVar4 = (list_head_elinks *)plVar3->next;
        sels = plVar3;
      }
      sels = (list_head_elinks *)properties.next;
      p = (list_head_elinks *)properties.prev;
      if ((list_head_elinks *)properties.next == &properties) {
        sels = &properties;
      }
      else {
        do {
          sels = (list_head_elinks *)sels->next;
        } while (sels != &properties);
      }
      while (p != sels) {
        p = (list_head_elinks *)p->prev;
      }
      plVar4 = (list_head_elinks *)((list_head_elinks *)properties.next)->next;
      p = (list_head_elinks *)properties.next;
      while (plVar3 = plVar4, p != sels) {
        plVar3->prev = p->prev;
        *(void **)p->prev = p->next;
        mem_free(p);
        plVar4 = (list_head_elinks *)plVar3->next;
        p = plVar3;
      }
      goto LAB_08085068;
    }
    sels = (list_head_elinks *)selectors.next;
    if (&selectors != (list_head_elinks *)selectors.next) {
      do {
        pplVar2 = (list_head_elinks **)&sels->next;
        sels = *pplVar2;
        p = (list_head_elinks *)selectors.prev;
      } while (&selectors != *pplVar2);
      while (&selectors != p) {
        p = (list_head_elinks *)p->prev;
      }
      p = *(list_head_elinks **)selectors.next;
      sels = (list_head_elinks *)selectors.next;
      while (plVar4 = p, &selectors != sels) {
        plVar4->prev = sels->prev;
        *(void **)sels->prev = sels->next;
        mem_free(sels);
        p = (list_head_elinks *)plVar4->next;
        sels = plVar4;
      }
    }
  }
  skip_scanner_tokens(&scanner,0x7d,0x400);
  goto LAB_08085068;
}



// WARNING: Type propagation algorithm not settling

scanner_token * scan_css_tokens(scanner *scanner)

{
  scanner_token *__dest;
  byte *__s;
  byte bVar1;
  scanner_token *psVar2;
  uint uVar3;
  byte bVar4;
  uint __c;
  uchar *puVar5;
  void *pvVar6;
  scanner *psVar7;
  scanner_token *__src;
  size_t __n;
  byte *pbVar8;
  int local_50;
  byte *ident;
  uchar *puVar9;
  scanner *psVar10;
  byte *end;
  byte *end_00;
  byte local_3c;
  byte *local_30;
  scanner *local_20;
  
  __dest = scanner->table;
  psVar2 = scanner->current;
  local_50 = (int)scanner + ((scanner->tokens * 0x10 + 0x1c) - (int)psVar2) >> 4;
  __src = psVar2;
  if (local_50 < 1) {
    local_50 = 0;
    __src = __dest;
  }
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(psVar2 == (scanner_token *)0x0), psVar2 == (scanner_token *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.h";
    errline = 0xd8;
    elinks_internal((uchar *)"assertion scanner->current failed!");
  }
  __n = 0xa0;
  if (local_50 != 0) {
    memmove(__dest,__src,local_50 * 0x10);
    __src = scanner->table + local_50;
    __n = local_50 * -0x10 + 0xa0;
  }
  memset(__src,0,__n);
  if (scanner->position == (uchar *)0x0) {
    if (local_50 == 0) {
      local_50 = -1;
    }
    scanner->tokens = local_50;
    scanner->current = __dest;
    if (assert_failed == 0) {
      if ((local_50 < 10) || (scanner->table + 1 < scanner->table + local_50)) {
        assert_failed = 0;
      }
      else {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.h";
        errline = 0xe7;
        elinks_internal((uchar *)"assertion check_scanner(scanner) failed!");
      }
    }
    local_50 = scanner->tokens;
  }
  else {
    scanner->tokens = local_50;
    if (__dest != (scanner_token *)0x0) {
      local_20 = (scanner *)(scanner->table + local_50);
      psVar10 = scanner + 1;
      if ((psVar10 <= local_20) ||
         (end = scanner->position, scanner->end < end || scanner->end == end)) {
joined_r0x080864be:
        if ((assert_failed == 0) && (assert_failed = ZEXT14(psVar10 < local_20), psVar10 < local_20)
           ) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.h";
          errline = 0xf9;
          elinks_internal((uchar *)"assertion end <= scanner->table + SCANNER_TOKENS failed!");
        }
        local_50 = (int)((int)local_20 - (int)__dest) >> 4;
        scanner->tokens = local_50;
        scanner->current = __dest;
        if (scanner->end <= scanner->position) {
          scanner->position = (uchar *)0x0;
        }
        if (assert_failed == 0) {
          if ((local_50 < 10) || (scanner->current + 1 < scanner->table + local_50)) {
            assert_failed = 0;
          }
          else {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.h";
            errline = 0x100;
            elinks_internal((uchar *)"assertion check_scanner(scanner) failed!");
          }
        }
        if (0 < scanner->tokens) {
          if (scanner->current < scanner->table + scanner->tokens) {
            return scanner->current;
          }
          return (scanner_token *)0x0;
        }
        return (scanner_token *)0x0;
      }
      do {
        local_3c = *end;
        __c = (uint)local_3c;
        ident = end;
        if ((*(byte *)((int)css_scanner_info.scan_table + __c * 4 + 1) & 4) != 0) {
          do {
            ident = ident + 1;
            scanner->position = ident;
            if (scanner->end <= ident) goto joined_r0x080864be;
            local_3c = *ident;
            __c = (uint)local_3c;
          } while ((*(byte *)((int)css_scanner_info.scan_table + __c * 4 + 1) & 4) != 0);
        }
        if ((assert_failed == 0) && (assert_failed = ZEXT14(local_3c == 0), local_3c == 0)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/scanner.c";
          errline = 0x84;
          elinks_internal((uchar *)"assertion first_char failed!");
          local_3c = 0;
        }
        end = ident + 1;
        local_20->end = ident;
        uVar3 = css_scanner_info.scan_table[__c];
        if ((uVar3 & 0x100) != 0) {
          puVar9 = (uchar *)(uint)local_3c;
          goto LAB_08086081;
        }
        if (((uVar3 & 2) == 0) && (local_3c != 0x2e)) {
          if ((uVar3 & 0x10) == 0) {
            if ((uVar3 & 0x200) == 0) {
LAB_08086337:
              puVar9 = (uchar *)0x11c;
            }
            else {
              if (local_3c == 0x23) {
                if ((css_scanner_info.scan_table[*end] & 4U) == 0) {
                  if ((css_scanner_info.scan_table[*end] & 8U) == 0) goto LAB_08086337;
                  ident = end;
                  if (end < scanner->end) {
                    do {
                      end = ident + 1;
                      if (scanner->end <= end) break;
                      pbVar8 = ident + 1;
                      ident = end;
                    } while ((*(byte *)(css_scanner_info.scan_table + *pbVar8) & 8) != 0);
                    goto LAB_08086547;
                  }
                  puVar9 = (uchar *)0x10b;
                }
                else {
                  pbVar8 = scanner->end;
                  if (end < pbVar8) {
                    do {
                      end = end + 1;
                      if (pbVar8 <= end) break;
                    } while ((*(byte *)(css_scanner_info.scan_table + *end) & 4) != 0);
                  }
                  if (((end + ~(uint)ident == (byte *)0x6) || (end + ~(uint)ident == (byte *)0x3))
                     && ((*(byte *)(css_scanner_info.scan_table + *end) & 8) == 0)) {
                    puVar9 = (uchar *)0x10c;
                  }
                  else {
                    if ((end < pbVar8) &&
                       (ident = end, (*(byte *)(css_scanner_info.scan_table + *end) & 8) != 0)) {
                      do {
                        end = ident + 1;
                        if (pbVar8 <= end) break;
                        end_00 = ident + 1;
                        ident = end;
                      } while ((*(byte *)(css_scanner_info.scan_table + *end_00) & 8) != 0);
LAB_08086547:
                      puVar9 = (uchar *)0x10b;
                    }
                    else {
                      puVar9 = (uchar *)0x10b;
                    }
                  }
                }
                goto LAB_08086081;
              }
              if (local_3c != 0x40) {
                if (local_3c == 0x2a) {
                  if (*end != 0x3d) goto LAB_0808620e;
                  end = ident + 2;
                  puVar9 = (uchar *)0x11b;
                  goto LAB_08086081;
                }
                if (local_3c == 0x5e) {
                  if (*end != 0x3d) goto LAB_08086337;
                  end = ident + 2;
                  puVar9 = (uchar *)0x119;
                  goto LAB_08086081;
                }
                if (local_3c == 0x24) {
                  if (*end != 0x3d) goto LAB_08086337;
                  end = ident + 2;
                  puVar9 = (uchar *)0x11a;
                  goto LAB_08086081;
                }
                if (local_3c == 0x7c) {
                  if (*end != 0x3d) goto LAB_08086337;
                  end = ident + 2;
                  puVar9 = (uchar *)0x118;
                  goto LAB_08086081;
                }
                if (local_3c == 0x21) {
                  if (end < scanner->end) {
                    bVar1 = *(byte *)((int)css_scanner_info.scan_table + (uint)*end * 4 + 1);
                    ident = end;
                    while ((end = ident, (bVar1 & 4) != 0 && (end = ident + 1, end < scanner->end)))
                    {
                      bVar1 = *(byte *)((int)css_scanner_info.scan_table + (uint)ident[1] * 4 + 1);
                      ident = end;
                    }
                  }
                  local_50 = c_strncasecmp((char *)end,"important",9);
                  if (local_50 == 0) {
                    end = end + 9;
                    puVar9 = (uchar *)0x116;
                  }
                  else {
                    puVar9 = (uchar *)0x11c;
                  }
                  goto LAB_08086081;
                }
                if ((local_3c != 0x27) && (local_3c != 0x22)) {
                  if ((local_3c != 0x2d) && (local_3c != 0x3c)) {
                    if (local_3c == 0x2f) {
                      if (*end == 0x2a) {
                        pbVar8 = ident + 2;
                        ident = ident + 3;
                        while (pbVar8 < scanner->end) {
                          if ((*pbVar8 == 0x2a) && (*ident == 0x2f)) {
                            end = pbVar8 + 2;
                            puVar9 = (uchar *)0x11d;
                            goto LAB_08086081;
                          }
                          pbVar8 = pbVar8 + 1;
                          ident = ident + 1;
                        }
                        goto LAB_08086b4e;
                      }
                    }
                    else {
                      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/scanner.c";
                      errline = 0x157;
                      elinks_internal((uchar *)
                                      "Someone forgot to put code for recognizing tokens which start with \'%c\'."
                                      ,__c);
                    }
                    goto LAB_08086337;
                  }
                  bVar1 = *end;
                  if (bVar1 == 0x2f) {
                    puVar9 = (uchar *)0x0;
                    goto LAB_08086081;
                  }
                  if ((end < scanner->end) &&
                     (pbVar8 = end, *(char *)(css_scanner_info.scan_table + bVar1) < '\0')) {
                    do {
                      ident = pbVar8;
                      pbVar8 = ident + 1;
                      if (scanner->end <= pbVar8) break;
                    } while (*(char *)(css_scanner_info.scan_table + *pbVar8) < '\0');
                    if (1 < (int)(pbVar8 + -(int)end)) {
                      if (local_3c == 0x3c) {
                        if (bVar1 == 0x21) goto LAB_08086b4e;
                      }
                      else {
                        if ((local_3c == 0x2d) && (*ident == 0x3e)) {
LAB_08086b4e:
                          end = pbVar8;
                          puVar9 = (uchar *)0x11d;
                          goto LAB_08086081;
                        }
                      }
                    }
                  }
LAB_080868aa:
                  puVar9 = (uchar *)0x11c;
                  goto LAB_08086081;
                }
                pvVar6 = memchr(end,__c,(size_t)(scanner->end + -(int)end));
                if (pvVar6 == (void *)0x0) goto LAB_080868aa;
                puVar9 = (uchar *)0x103;
                __src = (scanner_token *)((int)pvVar6 - (int)end);
                local_20->end = end;
                end = (byte *)((int)pvVar6 + 1);
                goto LAB_0808644f;
              }
              if ((css_scanner_info.scan_table[*end] & 0x10U) == 0) goto LAB_08086337;
              pbVar8 = end;
              if ((end < scanner->end) && ((css_scanner_info.scan_table[*end] & 8U) != 0)) {
                do {
                  pbVar8 = pbVar8 + 1;
                  if (scanner->end <= pbVar8) break;
                } while ((*(byte *)(css_scanner_info.scan_table + *pbVar8) & 8) != 0);
              }
              local_50 = 0x110;
              ident = end;
LAB_080861ac:
              end = pbVar8;
              puVar9 = (uchar *)map_scanner_string(scanner,ident,end,local_50);
            }
            goto LAB_08086081;
          }
          pbVar8 = scanner->end;
          end_00 = end;
          while (end_00 < pbVar8) {
            bVar1 = *end_00;
            if ((*(byte *)(css_scanner_info.scan_table + bVar1) & 8) == 0) goto joined_r0x08086208;
            end_00 = end_00 + 1;
          }
          bVar1 = *end_00;
joined_r0x08086208:
          end = end_00;
          if (bVar1 != 0x28) {
LAB_0808620e:
            puVar9 = (uchar *)0x100;
            goto LAB_08086081;
          }
          end = end_00 + 1;
          local_30 = end;
          if (end < pbVar8) {
            bVar1 = end_00[1];
            if (bVar1 == 0x29) goto LAB_08086692;
            if ((bVar1 != 0x7d) && (bVar1 != 0x7b)) {
              while (bVar1 != 0x3b) {
                if ((bVar1 == 0x27) || (bVar1 == 0x22)) {
                  __s = local_30 + 1;
                  pvVar6 = memchr(__s,(uint)bVar1,(size_t)(pbVar8 + -(int)local_30));
                  local_30 = (byte *)((int)pvVar6 + 1);
                  if (pvVar6 == (void *)0x0) {
                    local_30 = __s;
                  }
                }
                else {
                  local_30 = local_30 + 1;
                }
                if (pbVar8 <= local_30) goto LAB_0808661d;
                bVar1 = *local_30;
                if (bVar1 == 0x29) goto LAB_08086692;
                if ((bVar1 == 0x7d) || (bVar1 == 0x7b)) break;
              }
            }
LAB_08086443:
            __src = (scanner_token *)0xffffffff;
            puVar9 = (uchar *)0x11c;
          }
          else {
LAB_0808661d:
            if (*local_30 != 0x29) goto LAB_08086443;
LAB_08086692:
            puVar9 = (uchar *)map_scanner_string(scanner,ident,end_00,0x10d);
            if (puVar9 == (uchar *)0x10d) {
              __src = (scanner_token *)0xffffffff;
              end_00 = local_30;
LAB_080866cb:
              local_30 = end_00;
              if (assert_failed == 0) {
                if ((puVar9 != (uchar *)0x10e) || (*local_30 == 0x28)) {
LAB_080866e7:
                  if ((puVar9 == (uchar *)0x10f) && (*local_30 != 0x29)) {
                    assert_failed = 1;
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/scanner.c";
                    errline = 0xd4;
                    elinks_internal((uchar *)
                                    "assertion type != CSS_TOKEN_URL || *string == \')\' failed!");
                    if (assert_failed != 0) {
                      end = local_30 + 1;
                      goto LAB_0808644f;
                    }
                  }
                  else {
LAB_08086a20:
                    if ((puVar9 == (uchar *)0x10d) && (*local_30 != 0x29)) {
                      assert_failed = 1;
                      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/scanner.c";
                      errline = 0xd5;
                      elinks_internal((uchar *)
                                      "assertion type != CSS_TOKEN_FUNCTION || *string == \')\' failed!"
                                     );
                      end = local_30 + 1;
                      goto LAB_0808644f;
                    }
                  }
                  assert_failed = 0;
                  end = local_30 + 1;
                  goto LAB_0808644f;
                }
                assert_failed = 1;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/scanner.c";
                errline = 0xd3;
                elinks_internal((uchar *)
                                "assertion type != CSS_TOKEN_RGB || *string == \'(\' failed!");
                if (assert_failed == 0) goto LAB_08086a20;
              }
            }
            else {
              __src = (scanner_token *)0xffffffff;
              if (puVar9 != (uchar *)0x10f) goto LAB_080866cb;
              while (end < scanner->end) {
                bVar1 = *end;
                if ((*(byte *)((int)css_scanner_info.scan_table + (uint)bVar1 * 4 + 1) & 4) == 0)
                goto LAB_08086a8c;
                end = end + 1;
              }
              bVar1 = *end;
LAB_08086a8c:
              ident = local_30;
              do {
                pbVar8 = ident;
                ident = pbVar8 + -1;
                if (ident < scanner->string) {
                  bVar4 = *ident;
                  break;
                }
                bVar4 = *ident;
              } while ((*(byte *)((int)css_scanner_info.scan_table + (uint)bVar4 * 4 + 1) & 4) != 0)
              ;
              if ((bVar1 == 0x27) || (bVar1 == 0x22)) {
                end = end + 1;
              }
              if ((bVar4 == 0x27) || (bVar4 == 0x22)) {
                ident = pbVar8 + -2;
              }
              __src = (scanner_token *)(ident + (1 - (int)end));
              local_20->end = end;
              if (assert_failed == 0) {
                assert_failed = -((int)__src >> 0x1f);
                if (assert_failed != 0) {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/scanner.c";
                  errline = 0xcf;
                  elinks_internal((uchar *)"assertion real_length >= 0 failed!");
                  end_00 = local_30;
                  goto LAB_080866cb;
                }
                goto LAB_080866e7;
              }
            }
            end = local_30 + 1;
          }
LAB_0808644f:
          local_20->string = puVar9;
          if ((int)__src < 1) goto LAB_08086086;
        }
        else {
          ident = scanner->end;
          if (end < ident) {
            bVar4 = *end;
            bVar1 = *(byte *)(css_scanner_info.scan_table + bVar4);
            while ((bVar1 & 2) != 0) {
              end = end + 1;
              if (ident <= end) goto LAB_08086147;
              bVar4 = *end;
              bVar1 = *(byte *)(css_scanner_info.scan_table + bVar4);
            }
          }
          else {
LAB_08086147:
            bVar4 = *end;
          }
          if (bVar4 == 0x2e) {
            end = end + 1;
            bVar4 = *end;
            if ((*(byte *)(css_scanner_info.scan_table + bVar4) & 2) == 0) goto LAB_08086152;
            if (end < ident) {
              do {
                end = end + 1;
                if (ident <= end) {
                  bVar4 = *end;
                  puVar9 = (uchar *)0x101;
                  goto LAB_08086157;
                }
                bVar4 = *end;
              } while ((*(byte *)(css_scanner_info.scan_table + bVar4) & 2) != 0);
            }
            puVar9 = (uchar *)0x101;
          }
          else {
LAB_08086152:
            puVar9 = (uchar *)0x11c;
          }
LAB_08086157:
          if (bVar4 == 0x25) {
            if (local_3c != 0x2e) {
              puVar9 = (uchar *)0x102;
            }
            end = end + 1;
          }
          else {
            if ((css_scanner_info.scan_table[bVar4] & 0x10U) != 0) {
              pbVar8 = end;
              if ((end < ident) && ((css_scanner_info.scan_table[bVar4] & 8U) != 0)) {
                do {
                  pbVar8 = pbVar8 + 1;
                  if (ident <= pbVar8) break;
                } while ((*(byte *)(css_scanner_info.scan_table + *pbVar8) & 8) != 0);
              }
              local_50 = 0x105;
              ident = end;
              goto LAB_080861ac;
            }
            puVar9 = (uchar *)0x101;
          }
LAB_08086081:
          local_20->string = puVar9;
LAB_08086086:
          __src = (scanner_token *)(end + -(int)local_20->end);
        }
        puVar5 = (uchar *)0x400;
        local_20->current = __src;
        if ((((puVar9 != (uchar *)0x7d) && (puVar5 = (uchar *)0x200, puVar9 != (uchar *)0x7b)) &&
            (puVar5 = (uchar *)0x100, puVar9 != (uchar *)0x3b)) &&
           (puVar5 = (uchar *)0x0, puVar9 == (uchar *)0x29)) {
          puVar5 = (uchar *)0x80;
        }
        local_20->position = puVar5;
        scanner->position = end;
        if (local_20->string == (uchar *)0x0) {
          scanner->position = (uchar *)0x0;
          local_20 = (scanner *)(local_20[-1].table + 9);
          goto joined_r0x080864be;
        }
        psVar7 = (scanner *)(local_20[-1].table + 9);
        if (local_20->string != (uchar *)0x11d) {
          psVar7 = local_20;
        }
        local_20 = (scanner *)&psVar7->tokens;
        if ((psVar10 <= local_20) || (scanner->end < end || scanner->end == end))
        goto joined_r0x080864be;
      } while( true );
    }
  }
  if ((0 < local_50) && (scanner->current < scanner->table + local_50)) {
    return scanner->current;
  }
  return (scanner_token *)0x0;
}



css_stylesheet * init_css_stylesheet(css_stylesheet_importer_T *importer,void *import_data)

{
  css_stylesheet *pcVar1;
  
  pcVar1 = (css_stylesheet *)mem_calloc(1,0x14);
  if (pcVar1 != (css_stylesheet *)0x0) {
    *(css_stylesheet_importer_T **)&pcVar1->import = importer;
    pcVar1->import_data = import_data;
    *(list_head_elinks **)&(pcVar1->selectors).prev = &pcVar1->selectors;
    *(list_head_elinks **)&(pcVar1->selectors).next = &pcVar1->selectors;
  }
  return pcVar1;
}



void done_css_selector(css_selector *selector)

{
  css_selector *selector_00;
  list_head_elinks *plVar1;
  list_head_elinks *plVar2;
  list_head_elinks *plVar3;
  list_head_elinks *p;
  
  selector_00 = (css_selector *)(selector->leaves).next;
  while (selector_00 != (css_selector *)&selector->leaves) {
    done_css_selector(selector_00);
    selector_00 = (css_selector *)(selector->leaves).next;
  }
  if (selector->next != (css_selector *)0x0) {
    selector->next->prev = selector->prev;
    selector->prev->next = selector->next;
  }
  p = (list_head_elinks *)(selector->properties).next;
  plVar1 = p;
  while (plVar1 != &selector->properties) {
    plVar1 = (list_head_elinks *)plVar1->next;
  }
  plVar2 = (list_head_elinks *)(selector->properties).prev;
  while (plVar2 != plVar1) {
    plVar2 = (list_head_elinks *)plVar2->prev;
  }
  plVar2 = (list_head_elinks *)p->next;
  while (plVar3 = plVar2, p != plVar1) {
    plVar3->prev = p->prev;
    *(void **)p->prev = p->next;
    mem_free(p);
    plVar2 = (list_head_elinks *)plVar3->next;
    p = plVar3;
  }
  if (selector->name != (uchar *)0x0) {
    mem_free(selector->name);
  }
  mem_free(selector);
  return;
}



void done_css_stylesheet(css_stylesheet *css)

{
  css_selector *selector;
  
  selector = (css_selector *)(css->selectors).next;
  while (selector != (css_selector *)&css->selectors) {
    done_css_selector(selector);
    selector = (css_selector *)(css->selectors).next;
  }
  return;
}



void merge_css_selectors(css_selector *sel1,css_selector *sel2)

{
  void *pvVar1;
  list_head_elinks *p;
  void **ppvVar2;
  list_head_elinks *plVar3;
  list_head_elinks *plVar4;
  
  plVar4 = (list_head_elinks *)(sel2->properties).next;
  if (plVar4 != &sel2->properties) {
    plVar3 = &sel1->properties;
    do {
      p = (list_head_elinks *)(sel1->properties).next;
      if (p != plVar3) {
        pvVar1 = p[1].next;
        while (pvVar1 != plVar4[1].next) {
          p = (list_head_elinks *)p->next;
          if (p == plVar3) goto LAB_08086d08;
          pvVar1 = p[1].next;
        }
        *(void **)((int)p->next + 4) = p->prev;
        *(void **)p->prev = p->next;
        mem_free(p);
      }
LAB_08086d08:
      ppvVar2 = (void **)mem_alloc(0x18);
      if (ppvVar2 != (void **)0x0) {
        *ppvVar2 = plVar4->next;
        ppvVar2[1] = plVar4->prev;
        ppvVar2[2] = plVar4[1].next;
        ppvVar2[3] = plVar4[1].prev;
        ppvVar2[4] = plVar4[2].next;
        ppvVar2[5] = plVar4[2].prev;
        pvVar1 = plVar3->next;
        *(list_head_elinks **)(ppvVar2 + 1) = plVar3;
        *ppvVar2 = pvVar1;
        *(void ***)&plVar3->next = ppvVar2;
        *(void ***)((int)*ppvVar2 + 4) = ppvVar2;
      }
      plVar4 = (list_head_elinks *)plVar4->next;
    } while (plVar4 != &sel2->properties);
  }
  return;
}



void add_selector_properties(css_selector *selector,list_head_elinks *properties)

{
  void *pvVar1;
  void **ppvVar2;
  list_head_elinks *plVar3;
  list_head_elinks *plVar4;
  
  plVar3 = (list_head_elinks *)properties->next;
  if (plVar3 != properties) {
    plVar4 = &selector->properties;
    do {
      ppvVar2 = (void **)mem_alloc(0x18);
      if (ppvVar2 != (void **)0x0) {
        *ppvVar2 = plVar3->next;
        ppvVar2[1] = plVar3->prev;
        ppvVar2[2] = plVar3[1].next;
        ppvVar2[3] = plVar3[1].prev;
        ppvVar2[4] = plVar3[2].next;
        ppvVar2[5] = plVar3[2].prev;
        pvVar1 = plVar4->next;
        *(list_head_elinks **)(ppvVar2 + 1) = plVar4;
        *ppvVar2 = pvVar1;
        *(void ***)&plVar4->next = ppvVar2;
        *(void ***)((int)*ppvVar2 + 4) = ppvVar2;
      }
      plVar3 = (list_head_elinks *)plVar3->next;
    } while (plVar3 != properties);
  }
  return;
}



css_selector *
init_css_selector(list_head_elinks *sels,css_selector_type type,uchar *name,int namelen)

{
  css_selector *pcVar1;
  css_selector *p;
  uchar *puVar2;
  
  p = (css_selector *)mem_calloc(1,0x24);
  if (p != (css_selector *)0x0) {
    p->relation = CSR_ROOT;
    *(list_head_elinks **)&(p->leaves).prev = &p->leaves;
    *(list_head_elinks **)&(p->leaves).next = &p->leaves;
    p->type = type;
    *(list_head_elinks **)&(p->properties).prev = &p->properties;
    *(list_head_elinks **)&(p->properties).next = &p->properties;
    if (name != (uchar *)0x0) {
      if (namelen < 0) {
        namelen = strlen((char *)name);
      }
      puVar2 = memacpy(name,namelen);
      p->name = puVar2;
      if (puVar2 == (uchar *)0x0) {
        mem_free(p);
        return (css_selector *)0x0;
      }
    }
    if (sels != (list_head_elinks *)0x0) {
      pcVar1 = (css_selector *)sels->next;
      *(list_head_elinks **)&p->prev = sels;
      p->next = pcVar1;
      *(css_selector **)&sels->next = p;
      p->next->prev = p;
    }
  }
  return p;
}



void mirror_css_stylesheet(css_stylesheet *css1,css_stylesheet *css2)

{
  uchar *name;
  size_t namelen;
  css_selector *selector;
  list_head_elinks *plVar1;
  uint uVar2;
  
  plVar1 = (list_head_elinks *)(css1->selectors).next;
  if (plVar1 != &css1->selectors) {
    do {
      if (assert_failed == 0) {
        uVar2 = (uint)(css2 == (css_stylesheet *)0x0 || plVar1 == (list_head_elinks *)0x0);
        if (css2 == (css_stylesheet *)0x0 || plVar1 == (list_head_elinks *)0x0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/stylesheet.c";
          errline = 0x94;
          assert_failed = uVar2;
          elinks_internal((uchar *)"assertion css && orig failed!");
          if (assert_failed == 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/stylesheet.c";
            errline = 0x6f;
            assert_failed = uVar2;
            elinks_internal((uchar *)"assertion css && orig failed!");
          }
        }
        else {
          assert_failed = 0;
        }
      }
      name = (uchar *)plVar1[3].next;
      namelen = strlen((char *)name);
      selector = init_css_selector(&css2->selectors,(css_selector_type)plVar1[2].prev,name,namelen);
      if (selector != (css_selector *)0x0) {
        add_selector_properties(selector,(list_head_elinks *)&plVar1[3].prev);
      }
      plVar1 = (list_head_elinks *)plVar1->next;
    } while (plVar1 != &css1->selectors);
  }
  return;
}



css_selector *
find_css_selector(list_head_elinks *sels,css_selector_type type,css_selector_relation rel,
                 uchar *name,int namelen)

{
  css_selector *pcVar1;
  int iVar2;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(name == (uchar *)0x0 || sels == (list_head_elinks *)0x0),
     name == (uchar *)0x0 || sels == (list_head_elinks *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/stylesheet.c";
    errline = 0x24;
    elinks_internal((uchar *)"assertion sels && name failed!");
  }
  pcVar1 = (css_selector *)sels->next;
  do {
    if (pcVar1 == (css_selector *)sels) {
      return (css_selector *)0x0;
    }
    if ((pcVar1->type == type) && (pcVar1->relation == rel)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/stylesheet.c";
      errline = 0x29;
      iVar2 = elinks_strlcasecmp(name,namelen,pcVar1->name,0xffffffff,1);
      if (iVar2 == 0) {
        return pcVar1;
      }
    }
    pcVar1 = pcVar1->next;
  } while( true );
}



css_selector *
get_css_selector(list_head_elinks *sels,css_selector_type type,css_selector_relation rel,uchar *name
                ,int namelen)

{
  css_selector *pcVar1;
  
  if ((((name != (uchar *)0x0) && (sels != (list_head_elinks *)0x0)) && (namelen != 0)) &&
     (pcVar1 = find_css_selector(sels,type,rel,name,namelen), pcVar1 != (css_selector *)0x0)) {
    return pcVar1;
  }
  pcVar1 = init_css_selector(sels,type,name,namelen);
  if (pcVar1 != (css_selector *)0x0) {
    pcVar1->relation = rel;
  }
  return pcVar1;
}



// WARNING: Exceeded maximum restarts with more pending

int css_parse_value(css_property_info *propinfo,css_property_value *value,scanner *scanner)

{
  int iVar1;
  bool bVar2;
  
  if (assert_failed == 0) {
    if (((scanner == (scanner *)0x0) || (value == (css_property_value *)0x0)) ||
       (propinfo == (css_property_info *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 0x140;
      elinks_internal((uchar *)"assertion scanner && value && propinfo failed!");
      if (assert_failed != 0) goto LAB_08087160;
    }
    bVar2 = propinfo->parser == (css_property_value_parser_T *)0x0;
    assert_failed = ZEXT14(bVar2);
    if (bVar2) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 0x141;
      elinks_internal((uchar *)"assertion propinfo->parser failed!");
    }
  }
LAB_08087160:
  if (((0 < scanner->tokens) && (scanner->current < scanner->table + scanner->tokens)) &&
     (scanner->current != (scanner_token *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x08087191. Too many branches
                    // WARNING: Treating indirect jump as call
    iVar1 = (*propinfo->parser)();
    return iVar1;
  }
  return 0;
}



int css_parse_display_value(css_property_info *propinfo,css_property_value *value,scanner *scanner)

{
  int iVar1;
  scanner_token *psVar2;
  bool bVar3;
  
  if ((scanner->tokens < 1) ||
     (psVar2 = scanner->current, scanner->table + scanner->tokens <= psVar2)) {
    psVar2 = (scanner_token *)0x0;
  }
  if ((assert_failed == 0) &&
     (bVar3 = propinfo->value_type != CSS_VT_DISPLAY, assert_failed = ZEXT14(bVar3), bVar3)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0x125;
    elinks_internal((uchar *)"assertion propinfo->value_type == CSS_VT_DISPLAY failed!");
    iVar1 = psVar2->type;
  }
  else {
    iVar1 = psVar2->type;
  }
  if (iVar1 != 0x100) {
    return 0;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
  errline = 0x12a;
  iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,(uchar *)"inline",6,1);
  if (iVar1 != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 300;
    iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,(uchar *)"inline-block",0xc,1);
    if (iVar1 != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 0x12e;
      iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,"block",5,1);
      if (iVar1 != 0) {
        return 0;
      }
      *(undefined4 *)value = 1;
      goto LAB_080872b8;
    }
  }
  *(undefined4 *)value = 0;
LAB_080872b8:
  skip_scanner_tokens(scanner,0x100,0);
  return 1;
}



int css_parse_white_space_value
              (css_property_info *propinfo,css_property_value *value,scanner *scanner)

{
  int iVar1;
  scanner_token *psVar2;
  bool bVar3;
  
  if ((scanner->tokens < 1) ||
     (psVar2 = scanner->current, scanner->table + scanner->tokens <= psVar2)) {
    psVar2 = (scanner_token *)0x0;
  }
  if ((assert_failed == 0) &&
     (bVar3 = propinfo->value_type != CSS_VT_FONT_ATTRIBUTE, assert_failed = ZEXT14(bVar3), bVar3))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0x10b;
    elinks_internal((uchar *)"assertion propinfo->value_type == CSS_VT_FONT_ATTRIBUTE failed!");
    iVar1 = psVar2->type;
  }
  else {
    iVar1 = psVar2->type;
  }
  if (iVar1 == 0x100) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0x110;
    iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,"pre",3,1);
    if (iVar1 == 0) {
      *(uint *)value = *(uint *)value | 0x20;
    }
    else {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 0x113;
      iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,"normal",6,1);
      if (iVar1 != 0) goto LAB_08087406;
      *(uint *)((int)value + 4) = *(uint *)((int)value + 4) | 0x20;
    }
    skip_scanner_tokens(scanner,0x100,0);
    iVar1 = 1;
  }
  else {
LAB_08087406:
    iVar1 = 0;
  }
  return iVar1;
}



int css_parse_text_decoration_value
              (css_property_info *propinfo,css_property_value *value,scanner *scanner)

{
  int iVar1;
  scanner_token *psVar2;
  bool bVar3;
  
  if ((scanner->tokens < 1) ||
     (psVar2 = scanner->current, scanner->table + scanner->tokens <= psVar2)) {
    psVar2 = (scanner_token *)0x0;
  }
  if ((assert_failed == 0) &&
     (bVar3 = propinfo->value_type != CSS_VT_FONT_ATTRIBUTE, assert_failed = ZEXT14(bVar3), bVar3))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0xf0;
    elinks_internal((uchar *)"assertion propinfo->value_type == CSS_VT_FONT_ATTRIBUTE failed!");
    iVar1 = psVar2->type;
  }
  else {
    iVar1 = psVar2->type;
  }
  if (iVar1 == 0x100) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0xf6;
    iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,"underline",9,1);
    if (iVar1 == 0) {
      *(uint *)value = *(uint *)value | 4;
    }
    else {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 0xf9;
      iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,"none",4,1);
      if (iVar1 != 0) goto LAB_08087566;
      *(uint *)((int)value + 4) = *(uint *)((int)value + 4) | 4;
    }
    skip_scanner_tokens(scanner,0x100,0);
    iVar1 = 1;
  }
  else {
LAB_08087566:
    iVar1 = 0;
  }
  return iVar1;
}



int css_parse_text_align_value
              (css_property_info *propinfo,css_property_value *value,scanner *scanner)

{
  int iVar1;
  scanner_token *psVar2;
  bool bVar3;
  
  if ((scanner->tokens < 1) ||
     (psVar2 = scanner->current, scanner->table + scanner->tokens <= psVar2)) {
    psVar2 = (scanner_token *)0x0;
  }
  if ((assert_failed == 0) &&
     (bVar3 = propinfo->value_type != CSS_VT_TEXT_ALIGN, assert_failed = ZEXT14(bVar3), bVar3)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0xd0;
    elinks_internal((uchar *)"assertion propinfo->value_type == CSS_VT_TEXT_ALIGN failed!");
    iVar1 = psVar2->type;
  }
  else {
    iVar1 = psVar2->type;
  }
  if (iVar1 == 0x100) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0xd4;
    iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,"left",4,1);
    if (iVar1 == 0) {
      *(undefined4 *)value = 0;
    }
    else {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 0xd7;
      iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,"right",5,1);
      if (iVar1 == 0) {
        *(undefined4 *)value = 2;
      }
      else {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
        errline = 0xda;
        iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,(uchar *)"center",6,1);
        if (iVar1 == 0) {
          *(undefined4 *)value = 1;
        }
        else {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
          errline = 0xdd;
          iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,(uchar *)"justify",7,1);
          if (iVar1 != 0) goto LAB_080876c5;
          *(undefined4 *)value = 3;
        }
      }
    }
    skip_scanner_tokens(scanner,0x100,0);
    iVar1 = 1;
  }
  else {
LAB_080876c5:
    iVar1 = 0;
  }
  return iVar1;
}



int css_parse_font_style_value
              (css_property_info *propinfo,css_property_value *value,scanner *scanner)

{
  int iVar1;
  scanner_token *psVar2;
  bool bVar3;
  
  if ((scanner->tokens < 1) ||
     (psVar2 = scanner->current, scanner->table + scanner->tokens <= psVar2)) {
    psVar2 = (scanner_token *)0x0;
  }
  if ((assert_failed == 0) &&
     (bVar3 = propinfo->value_type != CSS_VT_FONT_ATTRIBUTE, assert_failed = ZEXT14(bVar3), bVar3))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0x7f;
    elinks_internal((uchar *)"assertion propinfo->value_type == CSS_VT_FONT_ATTRIBUTE failed!");
    iVar1 = psVar2->type;
  }
  else {
    iVar1 = psVar2->type;
  }
  if (iVar1 != 0x100) {
    return 0;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
  errline = 0x83;
  iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,(uchar *)"italic",6,1);
  if (iVar1 != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0x84;
    iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,(uchar *)"oblique",7,1);
    if (iVar1 != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 0x87;
      iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,"underline",9,1);
      if (iVar1 == 0) {
        *(uint *)value = *(uint *)value | 4;
      }
      else {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
        errline = 0x8a;
        iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,"normal",6,1);
        if (iVar1 != 0) {
          return 0;
        }
        *(uint *)((int)value + 4) = *(uint *)((int)value + 4) | 2;
      }
      goto LAB_08087935;
    }
  }
  *(uint *)value = *(uint *)value | 2;
LAB_08087935:
  skip_scanner_tokens(scanner,0x100,0);
  return 1;
}



int css_parse_font_weight_value
              (css_property_info *propinfo,css_property_value *value,scanner *scanner)

{
  int iVar1;
  long lVar2;
  scanner_token *psVar3;
  bool bVar4;
  uchar *local_20 [4];
  
  if ((scanner->tokens < 1) ||
     (psVar3 = scanner->current, scanner->table + scanner->tokens <= psVar3)) {
    psVar3 = (scanner_token *)0x0;
  }
  if ((assert_failed == 0) &&
     (bVar4 = propinfo->value_type != CSS_VT_FONT_ATTRIBUTE, assert_failed = ZEXT14(bVar4), bVar4))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0x9f;
    elinks_internal((uchar *)"assertion propinfo->value_type == CSS_VT_FONT_ATTRIBUTE failed!");
    iVar1 = psVar3->type;
  }
  else {
    iVar1 = psVar3->type;
  }
  if (iVar1 != 0x100) {
    if ((iVar1 != 0x101) ||
       (lVar2 = strtol((char *)psVar3->string,(char **)local_20,10), psVar3->string == local_20[0]))
    {
      return 0;
    }
    skip_scanner_tokens(scanner,0x101,0);
    if ((99 < lVar2) && ((900 < lVar2 || (699 < lVar2)))) {
      *(uint *)value = *(uint *)value | 1;
      return 1;
    }
    return 1;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
  errline = 0xa2;
  iVar1 = elinks_strlcasecmp(psVar3->string,psVar3->length,(uchar *)"bolder",6,1);
  if (iVar1 == 0) {
LAB_08087b5e:
    *(uint *)value = *(uint *)value | 1;
  }
  else {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0xa5;
    iVar1 = elinks_strlcasecmp(psVar3->string,psVar3->length,(uchar *)"lighter",7,1);
    if (iVar1 != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 0xa8;
      iVar1 = elinks_strlcasecmp(psVar3->string,psVar3->length,"bold",4,1);
      if (iVar1 == 0) goto LAB_08087b5e;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 0xab;
      iVar1 = elinks_strlcasecmp(psVar3->string,psVar3->length,"normal",6,1);
      if (iVar1 != 0) {
        return 0;
      }
    }
    *(uint *)((int)value + 4) = *(uint *)((int)value + 4) | 1;
  }
  skip_scanner_tokens(scanner,0x100,0);
  return 1;
}



int css_parse_color_value(css_property_info *propinfo,css_property_value *value,scanner *scanner)

{
  scanner_token *psVar1;
  uint skipto;
  int skipto_00;
  uint uVar2;
  scanner_token *psVar3;
  int iVar4;
  int precedence;
  byte bVar5;
  scanner_token *psVar6;
  bool bVar7;
  uchar *local_20 [4];
  
  if ((scanner->tokens < 1) ||
     (psVar6 = scanner->current, scanner->table + scanner->tokens <= psVar6)) {
    psVar6 = (scanner_token *)0x0;
  }
  if ((assert_failed == 0) &&
     (bVar7 = propinfo->value_type != CSS_VT_COLOR, assert_failed = ZEXT14(bVar7), bVar7)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0x1e;
    elinks_internal((uchar *)"assertion propinfo->value_type == CSS_VT_COLOR failed!");
  }
  skipto_00 = psVar6->type;
  if (skipto_00 != 0x10e) {
    if (((skipto_00 == 0x10c) || (skipto_00 == 0x100)) &&
       (skipto_00 = decode_color(psVar6->string,psVar6->length,(color_T *)value), -1 < skipto_00)) {
      skipto_00 = psVar6->type;
      precedence = 0x400;
      if (((skipto_00 != 0x7d) && (precedence = 0x200, skipto_00 != 0x7b)) &&
         ((precedence = 0x100, skipto_00 != 0x3b && (precedence = 0, skipto_00 == 0x29)))) {
        precedence = 0x80;
      }
      skip_scanner_tokens(scanner,skipto_00,precedence);
      return 1;
    }
    return 0;
  }
  if (0 < scanner->tokens) {
    psVar1 = scanner->current;
    psVar6 = scanner->table + scanner->tokens;
    if (psVar1 < psVar6) {
      psVar3 = psVar1 + 1;
      scanner->current = psVar3;
      if (psVar1 + 2 < psVar6) {
        if (psVar6 <= psVar3) {
          return 1;
        }
      }
      else {
        psVar3 = (*scanner->info->scan)(scanner);
      }
      if (psVar3 != (scanner_token *)0x0) {
        skipto_00 = 0x10;
        do {
          local_20[0] = psVar3->string;
          bVar5 = (-(skipto_00 == 0) & 0xfdU) + 0x2c;
          if (1 < psVar3->type - 0x101U) {
            return 0;
          }
          if (scanner->tokens < 1) {
            return 0;
          }
          psVar6 = scanner->current;
          if (scanner->table + scanner->tokens <= psVar6) {
            return 0;
          }
          if (scanner->table + scanner->tokens <= psVar6 + 1) {
            return 0;
          }
          skipto = psVar6[1].type;
          if (skipto != (uint)bVar5) {
            return 0;
          }
          precedence = strtol((char *)psVar3->string,(char **)local_20,10);
          if (psVar3->string == local_20[0]) {
            return 0;
          }
          if (psVar3->type == 0x102) {
            iVar4 = 100;
            if (precedence < 0x65) {
              iVar4 = precedence;
            }
            precedence = 0;
            if (-1 < iVar4) {
              precedence = iVar4;
            }
            precedence = (precedence * 0xff) / 100;
LAB_08087e2e:
            iVar4 = 0xff;
            if (precedence < 0x100) {
              iVar4 = precedence;
            }
            uVar2 = iVar4 << ((byte)skipto_00 & 0x1f);
          }
          else {
            uVar2 = 0;
            if (-1 < precedence) goto LAB_08087e2e;
          }
          *(uint *)value = *(uint *)value | uVar2;
          precedence = 0;
          if (bVar5 == 0x29) {
            precedence = 0x80;
          }
          psVar3 = skip_scanner_tokens(scanner,skipto,precedence);
          skipto_00 = skipto_00 + -8;
        } while ((psVar3 != (scanner_token *)0x0) && (-1 < skipto_00));
      }
    }
  }
  return 1;
}



int css_parse_background_value
              (css_property_info *propinfo,css_property_value *value,scanner *scanner)

{
  int iVar1;
  scanner_token *psVar2;
  int iVar3;
  int iVar4;
  bool bVar5;
  
  if ((assert_failed == 0) &&
     (bVar5 = propinfo->value_type != CSS_VT_COLOR, assert_failed = ZEXT14(bVar5), bVar5)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0x60;
    elinks_internal((uchar *)"assertion propinfo->value_type == CSS_VT_COLOR failed!");
  }
  iVar3 = scanner->tokens;
  iVar4 = 0;
LAB_08087fd8:
  while( true ) {
    if ((((iVar3 < 1) || (psVar2 = scanner->current, scanner->table + iVar3 <= psVar2)) ||
        (iVar1 = psVar2->type, iVar1 == 0x7d)) || ((iVar1 == 0x7b || (iVar1 == 0x3b)))) {
      return iVar4;
    }
    if (iVar1 == 0x2c) break;
    iVar3 = css_parse_color_value(propinfo,value,scanner);
    if (iVar3 == 0) goto LAB_08088050;
    iVar4 = iVar4 + 1;
    iVar3 = scanner->tokens;
  }
  goto LAB_0808800a;
LAB_08088050:
  iVar3 = scanner->tokens;
  if (iVar3 < 1) {
    return iVar4;
  }
  psVar2 = scanner->current;
  if (psVar2 < scanner->table + iVar3) {
LAB_0808800a:
    scanner->current = psVar2 + 1;
    if (scanner->table + iVar3 <= psVar2 + 2) {
      (*scanner->info->scan)(scanner);
      iVar3 = scanner->tokens;
    }
  }
  goto LAB_08087fd8;
}



screen_char * __regparm3 realloc_line(document *document,int x,int y)

{
  line *plVar1;
  screen_char *psVar2;
  int iVar3;
  uint uVar4;
  size_t size;
  uint uVar5;
  
  plVar1 = realloc_lines(document,y);
  if (plVar1 == (line *)0x0) {
LAB_080880f0:
    psVar2 = (screen_char *)0x0;
  }
  else {
    if (plVar1->length < x) {
      uVar5 = plVar1->length + 0xfU & 0xfffffff0;
      uVar4 = x + 0xfU & 0xfffffff0;
      if (uVar5 < uVar4) {
        size = uVar4 * 8;
        psVar2 = (screen_char *)mem_realloc(plVar1->chars,size);
        if (psVar2 == (screen_char *)0x0) goto LAB_080880f0;
        plVar1->chars = psVar2;
        memset(psVar2 + uVar5,0,size + uVar5 * -8);
      }
      psVar2 = plVar1->chars;
      if (psVar2 == (screen_char *)0x0) goto LAB_080880f0;
      iVar3 = plVar1->length;
      if (iVar3 < x) {
        while( true ) {
          psVar2[iVar3].data = 0x20;
          iVar3 = plVar1->length + 1;
          plVar1->length = iVar3;
          if (x <= iVar3) break;
          psVar2 = plVar1->chars;
        }
      }
      if (document->width < x) {
        document->width = x;
      }
    }
    psVar2 = plVar1->chars;
  }
  return psVar2;
}



void __regparm3
render_dom_text(dom_renderer *renderer,screen_char *template,uchar *string,int length)

{
  byte bVar1;
  byte bVar2;
  document *document;
  conv_table *convert_table;
  convert_string_mode mode;
  uchar *end;
  screen_char *psVar3;
  void **ppvVar4;
  int iVar5;
  uchar *p;
  uint uVar6;
  void *pvVar7;
  void *pvVar8;
  unicode_val_T c;
  uchar *puVar9;
  uint uVar10;
  int local_3c;
  uchar *local_38;
  int local_34;
  uchar *local_30;
  byte *local_24;
  uchar *local_20 [4];
  
  if (length < 1) {
    return;
  }
  p = string + length;
  local_30 = string;
  if (p <= string) goto LAB_08088248;
  do {
    uVar6 = (uint)(*local_30 == '\r');
    puVar9 = local_30 + uVar6;
    end = local_30;
    if (*puVar9 == '\n') {
LAB_080881f8:
      local_38 = end + -(int)local_30;
      puVar9 = end + uVar6 + 1;
LAB_08088204:
      if (local_38 != (uchar *)0x0) goto LAB_08088250;
    }
    else {
      if (*local_30 != '\r') {
        do {
          end = end + 1;
          if (p <= end) goto LAB_08088248;
          uVar6 = (uint)(*end == '\r');
          puVar9 = end + uVar6;
          if (*puVar9 == '\n') goto LAB_080881f8;
        } while (*end != '\r');
        local_38 = end + -(int)local_30;
        goto LAB_08088204;
      }
      local_38 = (uchar *)0x0;
    }
    while( true ) {
      if (puVar9 != (uchar *)0x0) {
        local_38 = puVar9 + -(int)local_30;
        renderer->canvas_y = renderer->canvas_y + 1;
        renderer->canvas_x = 0;
      }
      length = length - (int)local_38;
      if (length < 1) {
        return;
      }
      local_30 = local_30 + (int)local_38;
      p = local_30 + length;
      if (local_30 < p) break;
LAB_08088248:
      puVar9 = (uchar *)0x0;
      local_38 = (uchar *)length;
LAB_08088250:
      document = renderer->document;
      convert_table = renderer->convert_table;
      local_20[0] = local_38;
      mode = renderer->convert_mode;
      bVar1 = *(byte *)&(document->options).field_0x5c;
      if (assert_failed == 0) {
        if ((template == (screen_char *)0x0) || (local_30 == (uchar *)0x0)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 0x103;
          elinks_internal((uchar *)"assertion renderer && template && string && length failed!");
        }
        else {
          assert_failed = 0;
        }
      }
      p = convert_string_elinks
                    (convert_table,local_30,(int)local_20[0],(document->options).cp,mode,
                     (int *)local_20,(anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
      if (p != (uchar *)0x0) {
        psVar3 = realloc_line(document,(int)(local_20[0] + renderer->canvas_x),renderer->canvas_y);
        end = local_20[0];
        if (psVar3 == (screen_char *)0x0) {
          mem_free(p);
        }
        else {
          ppvVar4 = (void **)mem_alloc(0x18);
          if (ppvVar4 != (void **)0x0) {
            pvVar8 = (void *)renderer->canvas_y;
            pvVar7 = (void *)renderer->canvas_x;
            if ((int)pvVar7 < 0) {
              pvVar7 = (void *)0x0;
            }
            ppvVar4[2] = pvVar7;
            if ((int)pvVar8 < 0) {
              pvVar8 = (void *)0x0;
            }
            ppvVar4[3] = pvVar8;
            ppvVar4[5] = (void *)0x1;
            if ((int)end < 0) {
              end = (uchar *)0x0;
            }
            *(uchar **)(ppvVar4 + 4) = end;
            *ppvVar4 = (renderer->document->nodes).next;
            *(list_head_elinks **)(ppvVar4 + 1) = &renderer->document->nodes;
            *(void ***)&(renderer->document->nodes).next = ppvVar4;
            *(void ***)((int)*ppvVar4 + 4) = ppvVar4;
          }
          end = p + (int)local_20[0];
          if (0 < (int)local_20[0]) {
            local_3c = 1;
            local_34 = 0;
            do {
              local_24 = p + local_34;
              bVar2 = *local_24;
              if (bVar2 == 9) {
                uVar6 = renderer->canvas_x;
                template->data = 0x20;
                uVar10 = ~uVar6 & 7;
                psVar3 = realloc_line(document,(int)(local_20[0] + ((uVar10 + uVar6) - local_34)),
                                      renderer->canvas_y);
                if (psVar3 == (screen_char *)0x0) goto LAB_080883ed;
                if (uVar10 == 0) {
                  iVar5 = renderer->canvas_x;
                  local_3c = 1;
                }
                else {
                  iVar5 = renderer->canvas_x;
                  do {
                    uVar10 = uVar10 - 1;
                    psVar3 = renderer->document->data[renderer->canvas_y].chars + iVar5;
                    psVar3->data = template->data;
                    *(undefined4 *)&psVar3->attr = *(undefined4 *)&template->attr;
                    iVar5 = renderer->canvas_x + 1;
                    renderer->canvas_x = iVar5;
                  } while (0 < (int)uVar10);
                  local_3c = 1;
                }
              }
              else {
                if ((bVar1 >> 4 & 1) == 0) {
                  if ((bVar2 == 0x7f) || (bVar2 < 0x20)) {
                    c = 0x2e;
                  }
                  else {
                    c = (unicode_val_T)bVar2;
                  }
                  template->data = c;
                }
                else {
                  local_3c = utf8charlen(local_24);
                  c = utf8_to_unicode(&local_24,end);
                  template->data = c;
                  iVar5 = unicode_to_cell(c);
                  if (iVar5 == 2) {
                    psVar3 = renderer->document->data[renderer->canvas_y].chars + renderer->canvas_x
                    ;
                    psVar3->data = template->data;
                    *(undefined4 *)&psVar3->attr = *(undefined4 *)&template->attr;
                    renderer->canvas_x = renderer->canvas_x + 1;
                    template->data = 0xfffffffd;
                    iVar5 = renderer->canvas_x;
                    goto LAB_080883f0;
                  }
                }
LAB_080883ed:
                iVar5 = renderer->canvas_x;
              }
LAB_080883f0:
              psVar3 = renderer->document->data[renderer->canvas_y].chars + iVar5;
              psVar3->data = template->data;
              *(undefined4 *)&psVar3->attr = *(undefined4 *)&template->attr;
              local_34 = local_34 + local_3c;
              renderer->canvas_x = renderer->canvas_x + 1;
            } while (local_34 < (int)local_20[0]);
          }
          mem_free(p);
        }
      }
    }
  } while( true );
}



void __regparm3 render_dom_flush(dom_renderer *renderer,uchar *string)

{
  uchar *puVar1;
  uchar *puVar2;
  
  puVar1 = renderer->position;
  if (assert_failed == 0) {
    if ((puVar1 < renderer->source) || (renderer->end <= puVar1 && puVar1 != renderer->end)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1c9;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer->source,renderer->end,renderer->position,renderer->position);
      if (assert_failed != 0) goto LAB_08088628;
      puVar2 = renderer->source;
    }
    else {
      puVar2 = renderer->source;
    }
    if ((string < puVar2) || (renderer->end <= string && string != renderer->end)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1ca;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer->source,renderer->end,string,string);
    }
    else {
      assert_failed = 0;
    }
  }
LAB_08088628:
  if (0 < (int)(string + -(int)puVar1)) {
    render_dom_text(renderer,renderer->styles + 3,renderer->position,(int)(string + -(int)puVar1));
    renderer->position = string;
    if (assert_failed == 0) {
      if ((string < renderer->source) || (renderer->end <= string && string != renderer->end)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 0x1d0;
        elinks_internal((uchar *)
                        "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                        ,renderer->source,renderer->end,renderer->position,renderer->position);
      }
      else {
        assert_failed = 0;
      }
    }
  }
  return;
}



dom_code render_dom_element_end_source(dom_stack *stack,dom_node *node,void *data)

{
  dom_renderer *renderer;
  dom_stack_state *pdVar1;
  size_t sVar2;
  dom_stack_context *pdVar3;
  size_t sVar4;
  uchar *string;
  int length;
  uchar *puVar5;
  int iVar6;
  bool bVar7;
  
  iVar6 = assert_failed;
  renderer = (dom_renderer *)stack->current->data;
  if (assert_failed == 0) {
    assert_failed = 0;
  }
  pdVar1 = stack->states;
  sVar2 = stack->depth;
  pdVar3 = *stack->contexts;
  sVar4 = pdVar3->info->object_size;
  puVar5 = (uchar *)0x0;
  if (sVar4 != 0) {
    if ((iVar6 == 0) &&
       (bVar7 = pdVar3->state_objects == (uchar *)0x0, assert_failed = ZEXT14(bVar7), bVar7)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
      errline = 0xc6;
      elinks_internal((uchar *)"assertion context->state_objects failed!");
      iVar6 = assert_failed;
    }
    puVar5 = pdVar3->state_objects + sVar4 * (&pdVar1->depth)[sVar2 * 3 + -3];
  }
  string = *(uchar **)(puVar5 + 0x14);
  length = *(int *)(puVar5 + 0x10);
  if (iVar6 == 0) {
    if (((node == (dom_node *)0x0) || (renderer == (dom_renderer *)0x0)) ||
       (renderer->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x242;
      elinks_internal((uchar *)"assertion node && renderer && renderer->document failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  if ((length != 0) && (string != (uchar *)0x0)) {
    if ((renderer->source <= string) &&
       (puVar5 = string + length, puVar5 < renderer->end || puVar5 == renderer->end)) {
      render_dom_flush(renderer,string);
      renderer->position = puVar5;
      if (assert_failed == 0) {
        if ((puVar5 < renderer->source) || (renderer->end <= puVar5 && puVar5 != renderer->end)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 0x24a;
          elinks_internal((uchar *)
                          "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                          ,renderer->source,renderer->end,renderer->position,renderer->position);
        }
        else {
          assert_failed = 0;
        }
      }
    }
    render_dom_text(renderer,renderer->styles + node->type,string,length);
  }
  return DOM_CODE_OK;
}



dom_string * __regparm3 get_rss_text(dom_node *node,rss_element_type type)

{
  dom_node *parent;
  
  parent = get_dom_node_child(node,DOM_NODE_ELEMENT,(int16_t)type);
  if (parent != (dom_node *)0x0) {
    parent = get_dom_node_child(parent,DOM_NODE_TEXT,0);
    if (parent != (dom_node *)0x0) {
      return &parent->string;
    }
  }
  return (dom_string *)0x0;
}



dom_code dom_rss_pop_element(dom_stack *stack,dom_node *node,void *data)

{
  ushort uVar1;
  uint16_t uVar2;
  void *pvVar3;
  dom_node *parent;
  uint uVar4;
  dom_node *pdVar5;
  dom_node_list **ppdVar6;
  
  pvVar3 = stack->current->data;
  if (assert_failed == 0) {
    if (((node == (dom_node *)0x0) || (pvVar3 == (void *)0x0)) || (*(int *)((int)pvVar3 + 4) == 0))
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x338;
      elinks_internal((uchar *)"assertion node && renderer && renderer->document failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  if (8 < *(ushort *)(node->data + 10)) {
    return DOM_CODE_OK;
  }
  uVar4 = 1 << ((byte)*(undefined2 *)(node->data + 10) & 0x1f);
  if ((uVar4 & 0x1ca) == 0) {
    if ((uVar4 & 0x20) == 0) {
      return DOM_CODE_OK;
    }
    if ((*(void **)((int)pvVar3 + 0xa4) != (void *)0x0) && (*(int *)((int)pvVar3 + 0xa0) != 0)) {
      mem_free(*(void **)((int)pvVar3 + 0xa4));
      *(undefined4 *)((int)pvVar3 + 0xa4) = 0;
      *(undefined4 *)((int)pvVar3 + 0xa0) = 0;
    }
    *(undefined4 *)((int)pvVar3 + 0x98) = 0;
    return DOM_CODE_OK;
  }
  if (*(int *)((int)pvVar3 + 0xa4) == 0) {
    return DOM_CODE_OK;
  }
  if (*(int *)((int)pvVar3 + 0xa0) == 0) {
    return DOM_CODE_OK;
  }
  pdVar5 = node->parent;
  if (pdVar5 == (dom_node *)0x0) {
    return DOM_CODE_OK;
  }
  if (pdVar5 != *(dom_node **)((int)pvVar3 + 0x98)) {
    return DOM_CODE_OK;
  }
  parent = *(dom_node **)((int)pvVar3 + 0x9c);
  if (parent != node) {
    return DOM_CODE_OK;
  }
  uVar1 = pdVar5->type;
  uVar2 = node->type;
  if (uVar1 == 7) {
    ppdVar6 = (dom_node_list **)(pdVar5->data + 0xc);
    if (uVar2 == 2) goto LAB_08088a5c;
  }
  else {
    if (uVar1 < 8) {
      if (uVar1 == 1) {
        ppdVar6 = (dom_node_list **)pdVar5->data;
        if (uVar2 == 2) {
          ppdVar6 = (dom_node_list **)(pdVar5->data + 4);
        }
        goto LAB_08088a5c;
      }
    }
    else {
      if (uVar1 == 9) {
LAB_08088ab3:
        ppdVar6 = (dom_node_list **)(pdVar5->data + 4);
        goto LAB_08088a5c;
      }
      if (uVar1 == 10) {
        ppdVar6 = (dom_node_list **)pdVar5->data;
        if (uVar2 == 6) goto LAB_08088a5c;
        if (uVar2 == 0xc) goto LAB_08088ab3;
      }
    }
  }
  ppdVar6 = (dom_node_list **)0x0;
LAB_08088a5c:
  done_dom_node_list(*ppdVar6);
  if (((*(int *)((int)pvVar3 + 0xa4) != 0) && (*(int *)((int)pvVar3 + 0xa0) != 0)) &&
     (pdVar5 = init_dom_node_at(parent,DOM_NODE_TEXT,(dom_string *)((int)pvVar3 + 0xa0),-1),
     pdVar5 == (dom_node *)0x0)) {
    if (*(void **)((int)pvVar3 + 0xa4) != (void *)0x0) {
      mem_free(*(void **)((int)pvVar3 + 0xa4));
    }
    *(undefined4 *)((int)pvVar3 + 0xa4) = 0;
    *(undefined4 *)((int)pvVar3 + 0xa0) = 0;
  }
  *(undefined4 *)((int)pvVar3 + 0x9c) = 0;
  return DOM_CODE_OK;
}



dom_code dom_rss_push_element(dom_stack *stack,dom_node *node,void *data)

{
  void *pvVar1;
  uint uVar2;
  
  pvVar1 = stack->current->data;
  if (assert_failed == 0) {
    if (((node == (dom_node *)0x0) || (pvVar1 == (void *)0x0)) || (*(int *)((int)pvVar1 + 4) == 0))
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x309;
      elinks_internal((uchar *)"assertion node && renderer && renderer->document failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  if (*(ushort *)(node->data + 10) < 9) {
    uVar2 = 1 << ((byte)*(undefined2 *)(node->data + 10) & 0x1f);
    if ((uVar2 & 0x1ca) == 0) {
      if ((uVar2 & 0x20) == 0) {
        if ((((uVar2 & 4) != 0) && (stack->depth == 3)) && (*(int *)((int)pvVar1 + 0x90) == 0)) {
          *(dom_node **)((int)pvVar1 + 0x90) = node;
        }
      }
      else {
        if (*(int *)((int)pvVar1 + 0x98) == 0) {
          add_to_dom_node_list((dom_node_list **)((int)pvVar1 + 0x94),node,-1);
          *(dom_node **)((int)pvVar1 + 0x98) = node;
        }
      }
    }
    else {
      if ((node->parent != (dom_node *)0x0) && (node->parent == *(dom_node **)((int)pvVar1 + 0x9c)))
      {
        *(dom_node **)((int)pvVar1 + 0x9c) = node;
      }
    }
  }
  return DOM_CODE_OK;
}



void render_dom_document(cache_entry *cached,document *document,string *buffer)

{
  list_head_elinks *plVar1;
  byte *pbVar2;
  dom_string *pdVar3;
  uint uVar4;
  sgml_parser *parser;
  css_selector *pcVar5;
  sgml_document_type doctype;
  int iVar6;
  list_head_elinks *plVar7;
  uchar *head;
  dom_node_type type;
  dom_renderer *pdVar8;
  bool bVar9;
  byte bVar10;
  void *local_e8;
  int local_e4;
  void *local_e0;
  dom_renderer renderer;
  color_pair colors;
  dom_string uri;
  dom_config config;
  
  bVar10 = 0;
  head = cached->head;
  if (head == (uchar *)0x0) {
    head = "";
  }
  uri.string = cached->uri->string;
  uri.length = strlen((char *)uri.string);
  renderer.convert_table =
       get_convert_table(head,(document->options).cp,(document->options).assume_cp,&document->cp,
                         &document->cp_status,(document->options).hard_assume);
  iVar6 = 0x2a;
  pdVar8 = &renderer;
  while (iVar6 != 0) {
    iVar6 = iVar6 + -1;
    pdVar8->doctype = SGML_DOCTYPE_DOCBOOK;
    pdVar8 = (dom_renderer *)((int)pdVar8 + (uint)bVar10 * -8 + 4);
  }
  renderer.document = document;
  renderer.convert_mode = ~-(uint)((*(byte *)&(document->options).field_0x45 & 0x40) == 0) & 3;
  renderer.source = buffer->source;
  renderer.end = renderer.source + buffer->length;
  renderer.base_uri = document->uri;
  ((renderer.base_uri)->object).refcount = ((renderer.base_uri)->object).refcount + 1;
  local_e4 = 0;
  type = DOM_NODE_UNKNOWN;
  renderer.position = renderer.source;
  do {
    local_e8 = (void *)(document->options).default_style.bg;
    local_e0 = (void *)(document->options).default_style.fg;
    pdVar3 = get_dom_node_type_name(type);
    if (i_want_struct_module_for_dom == 0) {
      i_want_struct_module_for_dom = 1;
      css_parse_stylesheet
                (&default_stylesheet,(uri *)0x0,
                                  
                 "document\t{ color: yellow } element\t{ color: lightgreen } entity-reference { color: red } proc-instruction { color: red } attribute\t{ color: magenta } comment\t{ color: aqua } cdata-section\t{ color: orange2 } "
                 ,"");
    }
    if ((((pdVar3 == (dom_string *)0x0) || (pdVar3->string == (uchar *)0x0)) ||
        (pdVar3->length == 0)) ||
       (pcVar5 = find_css_selector(&default_stylesheet.selectors,CST_ELEMENT,CSR_ROOT,pdVar3->string
                                   ,pdVar3->length), pcVar5 == (css_selector *)0x0)) {
LAB_08088d5d:
      bVar10 = 0;
    }
    else {
      plVar7 = (list_head_elinks *)(pcVar5->properties).next;
      if (plVar7 == &pcVar5->properties) goto LAB_08088d5d;
      bVar10 = 0;
      do {
        switch(plVar7[1].next) {
        case (void *)0x1:
        case (void *)0x2:
          if (plVar7[1].prev != (void *)0x1) goto switchD_08088f11_caseD_0;
          local_e8 = plVar7[2].next;
          plVar7 = (list_head_elinks *)plVar7->next;
          break;
        case (void *)0x3:
          local_e0 = plVar7[2].next;
          plVar7 = (list_head_elinks *)plVar7->next;
          break;
        case (void *)0x5:
          if ((*(byte *)&plVar7[2].next & 4) != 0) {
            bVar10 = bVar10 | 0x20;
          }
          plVar1 = plVar7 + 2;
          plVar7 = (list_head_elinks *)plVar7->next;
          if ((*(byte *)&plVar1->next & 2) != 0) {
            bVar10 = bVar10 | 0x10;
          }
          break;
        case (void *)0x6:
          if ((*(byte *)&plVar7[2].next & 1) != 0) {
            bVar10 = bVar10 | 8;
          }
        default:
switchD_08088f11_caseD_0:
          plVar7 = (list_head_elinks *)plVar7->next;
          break;
        case (void *)0x8:
          plVar1 = plVar7 + 2;
          plVar7 = (list_head_elinks *)plVar7->next;
          if ((*(byte *)&plVar1->next & 4) != 0) {
            bVar10 = bVar10 | 0x20;
          }
        }
      } while (plVar7 != &pcVar5->properties);
    }
    colors.background = (color_T)local_e8;
    iVar6 = type + DOM_NODE_CDATA_SECTION;
    type = type + DOM_NODE_ELEMENT;
    colors.foreground = (color_T)local_e0;
    *(byte *)(&renderer.convert_mode + iVar6 * 2) = bVar10;
    (&renderer.convert_table)[iVar6 * 2] = (conv_table *)0x20;
    set_term_color((screen_char *)(&renderer.convert_table + iVar6 * 2),&colors,
                   (document->options).color_flags,(document->options).color_mode);
    local_e4 = local_e4 + 1;
  } while (local_e4 != 0xd);
  document->bgcolor = (document->options).default_style.bg;
  uVar4 = is_cp_utf8((document->options).cp);
  bVar10 = *(byte *)&(document->options).field_0x45;
  *(byte *)&(document->options).field_0x5c =
       *(byte *)&(document->options).field_0x5c & 0xef | (byte)((uVar4 & 1) << 4);
  iVar6 = c_strcasecmp("application/rss+xml",(char *)cached->content_type);
  if (iVar6 == 0) {
    renderer.doctype = SGML_DOCTYPE_RSS;
    doctype = SGML_DOCTYPE_RSS;
  }
  else {
    doctype = c_strcasecmp("application/docbook+xml",(char *)cached->content_type);
    if (doctype == SGML_DOCTYPE_DOCBOOK) {
      renderer.doctype = SGML_DOCTYPE_DOCBOOK;
    }
    else {
      iVar6 = c_strcasecmp("application/xbel+xml",(char *)cached->content_type);
      if (((iVar6 == 0) ||
          (iVar6 = c_strcasecmp("application/x-xbel",(char *)cached->content_type), iVar6 == 0)) ||
         (iVar6 = c_strcasecmp("application/xbel",(char *)cached->content_type), iVar6 == 0)) {
        renderer.doctype = SGML_DOCTYPE_XBEL;
        doctype = SGML_DOCTYPE_XBEL;
      }
      else {
        if (assert_failed == 0) {
          iVar6 = c_strcasecmp("text/html",(char *)cached->content_type);
          if ((iVar6 == 0) ||
             (iVar6 = c_strcasecmp("application/xhtml+xml",(char *)cached->content_type), iVar6 == 0
             )) {
            assert_failed = 0;
          }
          else {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
            errline = 0x3fa;
            elinks_internal((uchar *)
                            "assertion !c_strcasecmp(\"text/html\", cached->content_type) || !c_strcasecmp(\"application/xhtml+xml\", cached->content_type) failed: Couldn\'t resolve doctype \'%s\'"
                            ,cached->content_type);
          }
        }
        renderer.doctype = SGML_DOCTYPE_HTML;
        doctype = SGML_DOCTYPE_HTML;
      }
    }
  }
  parser = init_sgml_parser(((uint)(bVar10 >> 6) ^ 1) & 1,doctype,&uri,0);
  if (parser == (sgml_parser *)0x0) {
    return;
  }
  if ((*(byte *)&(document->options).field_0x45 & 0x40) == 0) {
    if (renderer.doctype == SGML_DOCTYPE_RSS) {
      add_dom_stack_context(&parser->stack,&renderer,&dom_rss_renderer_context_info);
      add_dom_config_normalizer
                (&parser->stack,&config,
                 DOM_CONFIG_NORMALIZE_CHARACTERS|DOM_CONFIG_NORMALIZE_WHITESPACE);
    }
  }
  else {
    add_dom_stack_context(&parser->stack,&renderer,&dom_source_renderer_context_info);
  }
  parse_sgml(parser,buffer->source,buffer->length,1);
  if (parser->root == (dom_node *)0x0) goto LAB_08088ea7;
  if (assert_failed == 0) {
    bVar9 = (parser->stack).depth != 1;
    assert_failed = ZEXT14(bVar9);
    if (bVar9) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x437;
      elinks_internal((uchar *)"assertion parser->stack.depth == 1 failed!");
      if (assert_failed != 0) goto LAB_08088e8d;
    }
    assert_failed = 0;
  }
LAB_08088e8d:
  pbVar2 = (byte *)(&((parser->stack).states)->field_0x8 + ((parser->stack).depth * 3 + -3) * 4);
  *pbVar2 = *pbVar2 & 0xfe;
  pop_dom_node(&parser->stack);
LAB_08088ea7:
  done_uri(renderer.base_uri);
  done_sgml_parser(parser);
  return;
}



void __regparm3 render_rss_item(dom_renderer *renderer,dom_node *item)

{
  int iVar1;
  int iVar2;
  document *pdVar3;
  dom_string *pdVar4;
  dom_string *pdVar5;
  dom_string *pdVar6;
  dom_string *pdVar7;
  uint charslen;
  uint uVar8;
  link *plVar9;
  uchar *chars;
  uchar *url;
  global_history_item *pgVar10;
  point *ppVar11;
  size_t size;
  bookmark *pbVar12;
  int iVar13;
  uint uVar14;
  uint local_38;
  color_pair colors;
  screen_char template;
  
  pdVar4 = get_rss_text(item,RSS_ELEMENT_TITLE);
  pdVar5 = get_rss_text(item,RSS_ELEMENT_LINK);
  pdVar6 = get_rss_text(item,RSS_ELEMENT_AUTHOR);
  pdVar7 = get_rss_text(item,RSS_ELEMENT_PUBDATE);
  if (((pdVar4 != (dom_string *)0x0) && (chars = pdVar4->string, chars != (uchar *)0x0)) &&
     (local_38 = pdVar4->length, local_38 != 0)) {
    if (renderer->channel == item) {
      chars = convert_string_elinks
                        (renderer->convert_table,chars,local_38,(renderer->document->options).cp,
                         CSM_DEFAULT,(int *)0x0,(anon_subr_void_void_ptr_uchar_ptr_int *)0x0,
                         (void *)0x0);
      if (chars == (uchar *)0x0) {
        local_38 = pdVar4->length;
        chars = pdVar4->string;
      }
      else {
        renderer->document->title = chars;
        local_38 = pdVar4->length;
        chars = pdVar4->string;
      }
    }
    render_dom_text(renderer,renderer->styles + 1,chars,local_38);
  }
  if (((pdVar5 != (dom_string *)0x0) && (pdVar5->string != (uchar *)0x0)) && (pdVar5->length != 0))
  {
    iVar1 = renderer->canvas_x;
    iVar13 = iVar1 + 1;
    renderer->canvas_x = iVar13;
    charslen = pdVar5->length;
    iVar2 = renderer->canvas_y;
    chars = pdVar5->string;
    pdVar3 = renderer->document;
    uVar8 = pdVar3->nlinks + 0x80U & 0xffffff80;
    uVar14 = pdVar3->nlinks + 0x7fU & 0xffffff80;
    if (uVar14 < uVar8) {
      size = uVar8 * 0x34;
      plVar9 = (link *)mem_realloc(pdVar3->links,size);
      if (plVar9 == (link *)0x0) goto LAB_08089254;
      pdVar3->links = plVar9;
      memset(plVar9 + uVar14,0,size + uVar14 * -0x34);
    }
    if (pdVar3->links != (link *)0x0) {
      plVar9 = pdVar3->links + pdVar3->nlinks;
      uVar8 = plVar9->npoints;
      if (uVar8 < 6) {
        ppVar11 = (point *)mem_realloc(plVar9->points,0x30);
        if (ppVar11 == (point *)0x0) goto LAB_08089254;
        plVar9->points = ppVar11;
        memset(ppVar11 + uVar8,0,uVar8 * -8 + 0x30);
      }
      if (plVar9->points != (point *)0x0) {
        chars = convert_string_elinks
                          (renderer->convert_table,chars,charslen,(pdVar3->options).cp,CSM_DEFAULT,
                           (int *)0x0,(anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
        if (chars != (uchar *)0x0) {
          url = join_urls(renderer->base_uri,chars);
          mem_free(chars);
          if (url != (uchar *)0x0) {
            pgVar10 = get_global_history_item(url);
            if (pgVar10 == (global_history_item *)0x0) {
              pbVar12 = get_bookmark(url);
              if (pbVar12 == (bookmark *)0x0) {
                colors.foreground = (pdVar3->options).default_link;
              }
              else {
                colors.foreground = (pdVar3->options).default_bookmark_link;
              }
            }
            else {
              colors.foreground = (pdVar3->options).default_vlink;
            }
            plVar9->npoints = 6;
            plVar9->type = LINK_HYPERTEXT;
            plVar9->where = url;
            colors.background = (pdVar3->options).default_style.bg;
            (plVar9->color).background = colors.background;
            (plVar9->color).foreground = colors.foreground;
            plVar9->number = pdVar3->nlinks;
            template.attr = '\0';
            template.data = 0x20;
            set_term_color(&template,&colors,(pdVar3->options).color_flags,
                           (pdVar3->options).color_mode);
            render_dom_text(renderer,&template,(uchar *)"[link]",6);
            ppVar11 = plVar9->points;
            do {
              ppVar11->x = iVar13;
              iVar13 = iVar13 + 1;
              ppVar11->y = iVar2;
              ppVar11 = ppVar11 + 1;
            } while (iVar13 != iVar1 + 7);
            pdVar3->nlinks = pdVar3->nlinks + 1;
            *(byte *)&pdVar3->field_0x114 = *(byte *)&pdVar3->field_0x114 & 0xfe;
          }
        }
      }
    }
  }
LAB_08089254:
  renderer->canvas_y = renderer->canvas_y + 1;
  renderer->canvas_x = 0;
  if (((pdVar6 != (dom_string *)0x0) && (pdVar6->string != (uchar *)0x0)) && (pdVar6->length != 0))
  {
    render_dom_text(renderer,renderer->styles + 8,pdVar6->string,pdVar6->length);
  }
  if (((pdVar7 != (dom_string *)0x0) && (chars = pdVar7->string, chars != (uchar *)0x0)) &&
     (charslen = pdVar7->length, charslen != 0)) {
    if (((pdVar6 != (dom_string *)0x0) && (pdVar6->string != (uchar *)0x0)) && (pdVar6->length != 0)
       ) {
      render_dom_text(renderer,renderer->styles + 8," - ",3);
      charslen = pdVar7->length;
      chars = pdVar7->string;
    }
    render_dom_text(renderer,renderer->styles + 8,chars,charslen);
  }
  if ((((pdVar6 != (dom_string *)0x0) && (pdVar6->string != (uchar *)0x0)) && (pdVar6->length != 0))
     || (((pdVar7 != (dom_string *)0x0 && (pdVar7->string != (uchar *)0x0)) && (pdVar7->length != 0)
         ))) {
    renderer->canvas_y = renderer->canvas_y + 1;
    renderer->canvas_x = 0;
  }
  return;
}



dom_code dom_rss_pop_document(dom_stack *stack,dom_node *root,void *data)

{
  dom_renderer *renderer;
  dom_node *item;
  uchar *p;
  dom_code dVar1;
  dom_node_list *p_00;
  uint uVar2;
  
  renderer = (dom_renderer *)stack->current->data;
  dVar1 = DOM_CODE_OK;
  if (renderer->channel != (dom_node *)0x0) {
    render_rss_item(renderer,renderer->channel);
    p_00 = renderer->items;
    if ((p_00 != (dom_node_list *)0x0) && (p_00->size != 0)) {
      uVar2 = 0;
      do {
        item = p_00->entries[uVar2];
        if (item != (dom_node *)0x0) {
          renderer->canvas_y = renderer->canvas_y + 1;
          renderer->canvas_x = 0;
          render_rss_item(renderer,item);
          p_00 = renderer->items;
        }
        uVar2 = uVar2 + 1;
      } while (uVar2 < p_00->size);
    }
    p = (renderer->text).string;
    if ((p != (uchar *)0x0) && ((renderer->text).length != 0)) {
      mem_free(p);
      p_00 = renderer->items;
      (renderer->text).string = (uchar *)0x0;
      (renderer->text).length = 0;
    }
    dVar1 = DOM_CODE_FREE_NODE;
    if (p_00 != (dom_node_list *)0x0) {
      mem_free(p_00);
      dVar1 = DOM_CODE_FREE_NODE;
    }
  }
  return dVar1;
}



dom_code render_dom_document_end(dom_stack *stack,dom_node *node,void *data)

{
  dom_renderer *renderer;
  uchar *puVar1;
  uchar *puVar2;
  
  renderer = (dom_renderer *)stack->current->data;
  puVar1 = renderer->position;
  if ((renderer->source < puVar1 || renderer->source == puVar1) &&
     (puVar2 = renderer->end, puVar1 <= puVar2)) {
    if (assert_failed == 0) {
      if ((puVar2 < renderer->source) || (renderer->end <= puVar2 && puVar2 != renderer->end)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 0x1ca;
        elinks_internal((uchar *)
                        "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]"
                        ,renderer->source,renderer->end,puVar2,puVar2);
      }
      else {
        assert_failed = 0;
      }
    }
    if (0 < (int)(puVar2 + -(int)puVar1)) {
      render_dom_text(renderer,renderer->styles + 3,renderer->position,(int)(puVar2 + -(int)puVar1))
      ;
      renderer->position = puVar2;
      if (assert_failed == 0) {
        if ((puVar2 < renderer->source) || (renderer->end <= puVar2 && puVar2 != renderer->end)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 0x1d0;
          elinks_internal((uchar *)
                          "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                          ,renderer->source,renderer->end,renderer->position,renderer->position);
        }
        else {
          assert_failed = 0;
        }
      }
    }
  }
  return DOM_CODE_OK;
}



dom_code render_dom_node_source(dom_stack *stack,dom_node *node,void *data)

{
  uchar *puVar1;
  ushort uVar2;
  dom_renderer *renderer;
  uchar *puVar3;
  uchar *string;
  uint length;
  
  renderer = (dom_renderer *)stack->current->data;
  if (assert_failed == 0) {
    if (((node == (dom_node *)0x0) || (renderer == (dom_renderer *)0x0)) ||
       (renderer->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x21c;
      elinks_internal((uchar *)"assertion node && renderer && renderer->document failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  uVar2 = node->type;
  string = (node->string).string;
  length = (node->string).length;
  if (uVar2 == 5) {
    string = string + -1;
    length = length + 2;
  }
  if (string < renderer->source) goto LAB_080898f4;
  puVar1 = string + length;
  if (renderer->end < puVar1) goto LAB_080898f4;
  puVar3 = renderer->position;
  if (assert_failed == 0) {
    if ((puVar3 < renderer->source) || (renderer->end < puVar3)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1c9;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer->source,renderer->end,renderer->position,renderer->position);
      if (assert_failed != 0) goto LAB_08089a04;
    }
    if ((string < renderer->source) || (renderer->end <= string && string != renderer->end)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1ca;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer->source,renderer->end,string,string);
    }
    else {
      assert_failed = 0;
    }
  }
LAB_08089a04:
  if (0 < (int)(string + -(int)puVar3)) {
    render_dom_text(renderer,renderer->styles + 3,renderer->position,(int)(string + -(int)puVar3));
    renderer->position = string;
    if (assert_failed == 0) {
      if ((string < renderer->source) || (renderer->end <= string && string != renderer->end)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 0x1d0;
        elinks_internal((uchar *)
                        "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                        ,renderer->source,renderer->end,renderer->position,renderer->position);
      }
      else {
        assert_failed = 0;
      }
    }
  }
  renderer->position = puVar1;
  if (assert_failed == 0) {
    if ((puVar1 < renderer->source) || (renderer->end <= puVar1 && puVar1 != renderer->end)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1e2;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer->source,renderer->end,renderer->position,renderer->position);
    }
    else {
      assert_failed = 0;
    }
  }
LAB_080898f4:
  render_dom_text(renderer,renderer->styles + uVar2,string,length);
  return DOM_CODE_OK;
}



dom_code render_dom_element_source(dom_stack *stack,dom_node *node,void *data)

{
  uchar *puVar1;
  ushort uVar2;
  dom_renderer *renderer;
  uchar *puVar3;
  uchar *string;
  uint length;
  
  renderer = (dom_renderer *)stack->current->data;
  if (assert_failed == 0) {
    if (((node == (dom_node *)0x0) || (renderer == (dom_renderer *)0x0)) ||
       (renderer->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x231;
      elinks_internal((uchar *)"assertion node && renderer && renderer->document failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  uVar2 = node->type;
  string = (node->string).string;
  length = (node->string).length;
  if (uVar2 == 5) {
    string = string + -1;
    length = length + 2;
  }
  if (string < renderer->source) goto LAB_08089bc4;
  puVar1 = string + length;
  if (renderer->end < puVar1) goto LAB_08089bc4;
  puVar3 = renderer->position;
  if (assert_failed == 0) {
    if ((puVar3 < renderer->source) || (renderer->end < puVar3)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1c9;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer->source,renderer->end,renderer->position,renderer->position);
      if (assert_failed != 0) goto LAB_08089cd4;
    }
    if ((string < renderer->source) || (renderer->end <= string && string != renderer->end)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1ca;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer->source,renderer->end,string,string);
    }
    else {
      assert_failed = 0;
    }
  }
LAB_08089cd4:
  if (0 < (int)(string + -(int)puVar3)) {
    render_dom_text(renderer,renderer->styles + 3,renderer->position,(int)(string + -(int)puVar3));
    renderer->position = string;
    if (assert_failed == 0) {
      if ((string < renderer->source) || (renderer->end <= string && string != renderer->end)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 0x1d0;
        elinks_internal((uchar *)
                        "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                        ,renderer->source,renderer->end,renderer->position,renderer->position);
      }
      else {
        assert_failed = 0;
      }
    }
  }
  renderer->position = puVar1;
  if (assert_failed == 0) {
    if ((puVar1 < renderer->source) || (renderer->end <= puVar1 && puVar1 != renderer->end)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1e2;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer->source,renderer->end,renderer->position,renderer->position);
    }
    else {
      assert_failed = 0;
    }
  }
LAB_08089bc4:
  render_dom_text(renderer,renderer->styles + uVar2,string,length);
  return DOM_CODE_OK;
}



dom_code render_dom_cdata_source(dom_stack *stack,dom_node *node,void *data)

{
  ushort uVar1;
  dom_renderer *renderer;
  uchar *puVar2;
  uchar *puVar3;
  uchar *string;
  uchar *string_00;
  uint length;
  
  renderer = (dom_renderer *)stack->current->data;
  string_00 = (node->string).string;
  if (assert_failed == 0) {
    if ((renderer == (dom_renderer *)0x0) || (renderer->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x2b8;
      elinks_internal((uchar *)"assertion node && renderer && renderer->document failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  puVar3 = renderer->source;
  string = string_00 + -6;
  if ((puVar3 <= string) && (string_00 <= renderer->end)) {
    puVar2 = renderer->position;
    if (assert_failed == 0) {
      if ((puVar2 < puVar3) || (renderer->end < puVar2)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 0x1c9;
        elinks_internal((uchar *)
                        "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                        ,renderer->source,renderer->end,renderer->position,renderer->position);
        if (assert_failed != 0) goto LAB_0808a0fc;
      }
      if ((string < renderer->source) || (renderer->end <= string && string != renderer->end)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 0x1ca;
        elinks_internal((uchar *)
                        "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]"
                        ,renderer->source,renderer->end,string,string);
      }
      else {
        assert_failed = 0;
      }
    }
LAB_0808a0fc:
    if (0 < (int)(string + -(int)puVar2)) {
      render_dom_text(renderer,renderer->styles + 3,renderer->position,(int)(string + -(int)puVar2))
      ;
      renderer->position = string;
      if (assert_failed == 0) {
        if ((string < renderer->source) || (renderer->end <= string && string != renderer->end)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 0x1d0;
          elinks_internal((uchar *)
                          "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                          ,renderer->source,renderer->end,renderer->position,renderer->position);
        }
        else {
          assert_failed = 0;
        }
      }
    }
    render_dom_text(renderer,renderer->styles + 2,string,5);
    string_00 = string_00 + -1;
    renderer->position = string_00;
    if (assert_failed == 0) {
      if ((renderer->source <= string_00) &&
         (string_00 < renderer->end || string_00 == renderer->end)) {
        assert_failed = 0;
        puVar3 = renderer->source;
        goto LAB_08089e6a;
      }
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x2bf;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer->source,renderer->end,renderer->position,renderer->position);
    }
    puVar3 = renderer->source;
  }
LAB_08089e6a:
  uVar1 = node->type;
  string_00 = (node->string).string;
  length = (node->string).length;
  if (uVar1 == 5) {
    string_00 = string_00 + -1;
    length = length + 2;
  }
  if (string_00 < puVar3) goto LAB_08089e92;
  string = string_00 + length;
  if (renderer->end < string) goto LAB_08089e92;
  puVar2 = renderer->position;
  if (assert_failed == 0) {
    if ((puVar2 < puVar3) || (renderer->end < puVar2)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1c9;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer->source,renderer->end,renderer->position,renderer->position);
      if (assert_failed != 0) goto LAB_08089f7c;
    }
    if ((string_00 < renderer->source) || (renderer->end <= string_00 && string_00 != renderer->end)
       ) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1ca;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer->source,renderer->end,string_00,string_00);
    }
    else {
      assert_failed = 0;
    }
  }
LAB_08089f7c:
  if (0 < (int)(string_00 + -(int)puVar2)) {
    render_dom_text(renderer,renderer->styles + 3,renderer->position,(int)(string_00 + -(int)puVar2)
                   );
    renderer->position = string_00;
    if (assert_failed == 0) {
      if ((string_00 < renderer->source) ||
         (renderer->end <= string_00 && string_00 != renderer->end)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 0x1d0;
        elinks_internal((uchar *)
                        "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                        ,renderer->source,renderer->end,renderer->position,renderer->position);
      }
      else {
        assert_failed = 0;
      }
    }
  }
  renderer->position = string;
  if (assert_failed == 0) {
    if ((string < renderer->source) || (renderer->end <= string && string != renderer->end)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1e2;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer->source,renderer->end,renderer->position,renderer->position);
    }
    else {
      assert_failed = 0;
    }
  }
LAB_08089e92:
  render_dom_text(renderer,renderer->styles + uVar1,string_00,length);
  return DOM_CODE_OK;
}



dom_code render_dom_attribute_source(dom_stack *stack,dom_node *node,void *data)

{
  screen_char *template_00;
  dom_renderer *renderer;
  document *pdVar1;
  int iVar2;
  uchar *puVar3;
  ushort uVar4;
  ushort **ppuVar5;
  uri *puVar6;
  global_history_item *pgVar7;
  point *ppVar8;
  link *plVar9;
  bookmark *pbVar10;
  uchar *string;
  int iVar11;
  size_t size;
  uchar *string_00;
  uint uVar12;
  uint uVar13;
  int length;
  bool bVar14;
  uchar *local_38;
  uint local_30;
  color_pair colors;
  screen_char template;
  
  renderer = (dom_renderer *)stack->current->data;
  uVar4 = node->type;
  template_00 = renderer->styles + uVar4;
  if (assert_failed == 0) {
    if (renderer->document == (document *)0x0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x26d;
      elinks_internal((uchar *)"assertion node && renderer->document failed!");
      uVar4 = node->type;
    }
    else {
      assert_failed = 0;
      uVar4 = node->type;
    }
  }
  local_30 = (node->string).length;
  string_00 = (node->string).string;
  if (uVar4 == 5) {
    local_30 = local_30 + 2;
    string_00 = string_00 + -1;
  }
  if (renderer->source <= string_00) {
    string = string_00 + local_30;
    if (string <= renderer->end) {
      puVar3 = renderer->position;
      if (assert_failed == 0) {
        if ((puVar3 < renderer->source) || (renderer->end < puVar3)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 0x1c9;
          elinks_internal((uchar *)
                          "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                          ,renderer->source,renderer->end,renderer->position,renderer->position);
          if (assert_failed != 0) goto LAB_0808a5bd;
        }
        if ((string_00 < renderer->source) ||
           (renderer->end <= string_00 && string_00 != renderer->end)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 0x1ca;
          elinks_internal((uchar *)
                          "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]"
                          ,renderer->source,renderer->end,string_00,string_00);
        }
        else {
          assert_failed = 0;
        }
      }
LAB_0808a5bd:
      if (0 < (int)(string_00 + -(int)puVar3)) {
        render_dom_text(renderer,renderer->styles + 3,renderer->position,
                        (int)(string_00 + -(int)puVar3));
        renderer->position = string_00;
        if (assert_failed == 0) {
          if ((string_00 < renderer->source) ||
             (renderer->end <= string_00 && string_00 != renderer->end)) {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
            errline = 0x1d0;
            elinks_internal((uchar *)
                            "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                            ,renderer->source,renderer->end,renderer->position,renderer->position);
          }
          else {
            assert_failed = 0;
          }
        }
      }
      renderer->position = string;
      if (assert_failed == 0) {
        if ((string < renderer->source) || (renderer->end <= string && string != renderer->end)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 0x1e2;
          elinks_internal((uchar *)
                          "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                          ,renderer->source,renderer->end,renderer->position,renderer->position);
        }
        else {
          assert_failed = 0;
        }
      }
    }
  }
  render_dom_text(renderer,template_00,string_00,local_30);
  if (*(int *)(node->data + 4) == 0) {
    return DOM_CODE_OK;
  }
  if (*(int *)node->data == 0) {
    return DOM_CODE_OK;
  }
  bVar14 = node->data[0xc] == 1;
  uVar13 = (uint)bVar14;
  local_38 = (uchar *)(*(int *)(node->data + 4) - uVar13);
  local_30 = *(int *)node->data + uVar13 * 2;
  if ((renderer->source <= local_38) && (local_38 < renderer->end || local_38 == renderer->end)) {
    render_dom_flush(renderer,local_38);
    string_00 = local_38 + local_30;
    renderer->position = string_00;
    if (assert_failed == 0) {
      if ((string_00 < renderer->source) ||
         (renderer->end <= string_00 && string_00 != renderer->end)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 0x279;
        elinks_internal((uchar *)
                        "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                        ,renderer->source,renderer->end,renderer->position,renderer->position);
      }
      else {
        assert_failed = 0;
      }
    }
  }
  if (((node->data[0xd] & 8) == 0) || ((int)(local_30 + uVar13 * -2) < 1)) {
    render_dom_text(renderer,template_00,local_38,local_30);
    return DOM_CODE_OK;
  }
  if ((int)local_30 < 1) {
LAB_0808aa18:
    length = 0;
    uVar13 = local_30;
  }
  else {
    length = 0;
    do {
      if ((length != 0) || (!bVar14)) {
        ppuVar5 = __ctype_b_loc();
        if (((*(byte *)((int)*ppuVar5 + (uint)local_38[length] * 2 + 1) & 0x20) == 0) &&
           (0x1f < local_38[length])) break;
      }
      length = length + 1;
    } while (length < (int)local_30);
    if (0 < length) {
      render_dom_text(renderer,template_00,local_38,length);
      local_38 = local_38 + length;
      local_30 = local_30 - length;
      if ((int)local_30 < 1) goto LAB_0808aa18;
    }
    length = 0;
    string_00 = local_38 + local_30;
    do {
      if ((length != 0) || (!bVar14)) {
        ppuVar5 = __ctype_b_loc();
        if (((*(byte *)((int)*ppuVar5 + (uint)string_00[-1] * 2 + 1) & 0x20) == 0) &&
           (uVar13 = local_30 - length, 0x1f < string_00[-1])) goto LAB_0808a489;
      }
      length = length + 1;
      string_00 = string_00 + -1;
    } while (length < (int)local_30);
    uVar13 = local_30 - length;
  }
LAB_0808a489:
  local_30 = uVar13;
  if ((((renderer->doctype == SGML_DOCTYPE_HTML) && (*(short *)(node->data + 10) == 0x2f)) &&
      (*(short *)(node->parent->data + 10) == 8)) &&
     (string_00 = memacpy(local_38,local_30), string_00 != (uchar *)0x0)) {
    string = join_urls(renderer->base_uri,string_00);
    mem_free(string_00);
    if (string != (uchar *)0x0) {
      puVar6 = get_uri(string,0);
      mem_free(string);
      if (puVar6 != (uri *)0x0) {
        done_uri(renderer->base_uri);
        renderer->base_uri = puVar6;
      }
    }
  }
  iVar11 = renderer->canvas_x;
  pdVar1 = renderer->document;
  iVar2 = renderer->canvas_y;
  uVar13 = pdVar1->nlinks + 0x80U & 0xffffff80;
  uVar12 = pdVar1->nlinks + 0x7fU & 0xffffff80;
  if (uVar12 < uVar13) {
    size = uVar13 * 0x34;
    plVar9 = (link *)mem_realloc(pdVar1->links,size);
    if (plVar9 == (link *)0x0) goto LAB_0808a4cc;
    pdVar1->links = plVar9;
    memset(plVar9 + uVar12,0,size + uVar12 * -0x34);
  }
  if (pdVar1->links != (link *)0x0) {
    plVar9 = pdVar1->links + pdVar1->nlinks;
    uVar13 = plVar9->npoints;
    if (uVar13 < local_30) {
      ppVar8 = (point *)mem_realloc(plVar9->points,local_30 * 8);
      if (ppVar8 == (point *)0x0) goto LAB_0808a4cc;
      plVar9->points = ppVar8;
      memset(ppVar8 + uVar13,0,local_30 * 8 + uVar13 * -8);
    }
    if ((plVar9->points != (point *)0x0) &&
       (string_00 = convert_string_elinks
                              (renderer->convert_table,local_38,local_30,(pdVar1->options).cp,
                               CSM_DEFAULT,(int *)0x0,(anon_subr_void_void_ptr_uchar_ptr_int *)0x0,
                               (void *)0x0), string_00 != (uchar *)0x0)) {
      string = join_urls(renderer->base_uri,string_00);
      mem_free(string_00);
      if (string != (uchar *)0x0) {
        pgVar7 = get_global_history_item(string);
        if (pgVar7 == (global_history_item *)0x0) {
          pbVar10 = get_bookmark(string);
          if (pbVar10 == (bookmark *)0x0) {
            colors.foreground = (pdVar1->options).default_link;
          }
          else {
            colors.foreground = (pdVar1->options).default_bookmark_link;
          }
        }
        else {
          colors.foreground = (pdVar1->options).default_vlink;
        }
        plVar9->npoints = local_30;
        plVar9->type = LINK_HYPERTEXT;
        plVar9->where = string;
        colors.background = (pdVar1->options).default_style.bg;
        (plVar9->color).background = colors.background;
        (plVar9->color).foreground = colors.foreground;
        plVar9->number = pdVar1->nlinks;
        template.attr = '\0';
        template.data = 0x20;
        set_term_color(&template,&colors,(pdVar1->options).color_flags,(pdVar1->options).color_mode)
        ;
        render_dom_text(renderer,&template,local_38,local_30);
        ppVar8 = plVar9->points;
        uVar13 = local_30;
        if (0 < (int)local_30) {
          do {
            ppVar8->x = iVar11;
            iVar11 = iVar11 + 1;
            ppVar8->y = iVar2;
            ppVar8 = ppVar8 + 1;
            uVar13 = uVar13 - 1;
          } while (uVar13 != 0);
        }
        pdVar1->nlinks = pdVar1->nlinks + 1;
        *(byte *)&pdVar1->field_0x114 = *(byte *)&pdVar1->field_0x114 & 0xfe;
      }
    }
  }
LAB_0808a4cc:
  if (0 < length) {
    render_dom_text(renderer,template_00,local_38 + local_30,length);
  }
  return DOM_CODE_OK;
}



int __regparm3 distribute_rows_or_cols(int *val_,int max_value,int *values,int values_count)

{
  int *piVar1;
  int iVar2;
  bool bVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int local_20;
  
  iVar4 = 0;
  local_20 = 0;
  max_value = *val_ - max_value;
  if (0 < values_count) {
    local_20 = 0;
    do {
      while (piVar1 = values + iVar4, *piVar1 < 1) {
        values[iVar4] = 1;
        iVar4 = iVar4 + 1;
        local_20 = local_20 + 1;
        if (iVar4 == values_count) goto LAB_0808ab40;
      }
      iVar4 = iVar4 + 1;
      local_20 = local_20 + *piVar1;
    } while (iVar4 != values_count);
  }
LAB_0808ab40:
  if ((assert_failed == 0) && (assert_failed = ZEXT14(local_20 == 0), local_20 == 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
    errline = 0x13a;
    elinks_internal((uchar *)"assertion divisor failed!");
  }
  if (0 < values_count) {
    iVar6 = 0;
    iVar4 = local_20 - max_value;
    do {
      iVar2 = values[iVar6];
      iVar5 = (iVar4 * iVar2) / local_20;
      values[iVar6] = iVar5;
      max_value = max_value + (iVar5 - iVar2);
      iVar6 = iVar6 + 1;
    } while (iVar6 != values_count);
  }
  if ((max_value != 0) && (0 < values_count)) {
    do {
      bVar3 = false;
      iVar4 = 0;
      do {
        if (max_value < 0) {
          max_value = max_value + 1;
          values[iVar4] = values[iVar4] + 1;
joined_r0x0808abc5:
          if (max_value == 0) {
            bVar3 = true;
LAB_0808abe8:
            max_value = 0;
            break;
          }
          bVar3 = true;
        }
        else {
          if (max_value == 0) goto LAB_0808abe8;
          if (1 < values[iVar4]) {
            max_value = max_value + -1;
            values[iVar4] = values[iVar4] + -1;
            goto joined_r0x0808abc5;
          }
        }
        iVar4 = iVar4 + 1;
      } while (iVar4 < values_count);
    } while ((bVar3) && (max_value != 0));
  }
  *val_ = max_value;
  return 1;
}



void parse_frame_widths(uchar *str,int max_value,int pixels_per_char,int **new_values,
                       int *new_values_count)

{
  bool bVar1;
  byte *__s;
  ushort **ppuVar2;
  ulong uVar3;
  char *pcVar4;
  int iVar5;
  int iVar6;
  void *__dest;
  int iVar7;
  uint uVar8;
  int iVar9;
  byte *__nptr;
  ulong uVar10;
  int *values;
  int values_count;
  int local_30;
  byte *local_24;
  int local_20 [4];
  
  values = (int *)0x0;
  *new_values_count = 0;
  ppuVar2 = __ctype_b_loc();
  local_20[0] = 0;
  do {
    __nptr = str;
    while ((*(byte *)((int)*ppuVar2 + (uint)*__nptr * 2 + 1) & 0x20) != 0) {
      __nptr = __nptr + 1;
    }
    local_24 = str;
    uVar3 = strtoul((char *)__nptr,(char **)&local_24,10);
    __s = local_24;
    if (__nptr == local_24) {
      uVar3 = 0;
LAB_0808ad0a:
      if (*local_24 == 0x25) {
        uVar10 = 100;
        if ((int)uVar3 < 100) {
          uVar10 = uVar3;
        }
        uVar8 = (int)(uVar10 * max_value) / 100;
      }
      else {
        if (*local_24 == 0x2a) {
          if (uVar3 == 0) goto LAB_0808acb8;
          uVar8 = -uVar3;
        }
        else {
          uVar8 = (uVar3 + (pixels_per_char + -1) / 2) / (uint)pixels_per_char;
        }
      }
    }
    else {
      if (uVar3 < 0x10000) goto LAB_0808ad0a;
LAB_0808acb8:
      uVar8 = 0xffffffff;
    }
    values_count = local_20[0] + 1;
    values = (int *)mem_realloc(values,values_count * 4);
    if (values == (int *)0x0) {
      return;
    }
    values[local_20[0]] = uVar8;
    pcVar4 = strchr((char *)__s,0x2c);
    if (pcVar4 == (char *)0x0) break;
    str = (uchar *)(pcVar4 + 1);
    local_20[0] = values_count;
  } while( true );
  local_20[0] = local_20[0] + values_count;
  if (0 < values_count) {
    iVar5 = 0;
    do {
      if (0 < values[iVar5]) {
        local_20[0] = local_20[0] + -1 + values[iVar5];
      }
      iVar5 = iVar5 + 1;
    } while (iVar5 != values_count);
  }
  iVar5 = local_20[0];
  if (local_20[0] < max_value) {
    bVar1 = false;
    iVar6 = 0;
    if (0 < values_count) {
      do {
        if (values[iVar6] < 0) {
          bVar1 = true;
        }
        iVar6 = iVar6 + 1;
      } while (iVar6 != values_count);
      if (bVar1) {
        __dest = mem_alloc(values_count * 4);
        if (__dest == (void *)0x0) {
          return;
        }
        memcpy(__dest,values,values_count * 4);
        iVar6 = 0;
        do {
          while (values[iVar6] < 1) {
            values[iVar6] = 1;
            iVar6 = iVar6 + 1;
            if (iVar6 == values_count) goto LAB_0808ae4b;
          }
          iVar6 = iVar6 + 1;
        } while (iVar6 != values_count);
LAB_0808ae4b:
        iVar9 = 0;
        iVar6 = 0;
        do {
          while (iVar7 = *(int *)((int)__dest + iVar6 * 4), iVar7 < 0) {
            iVar6 = iVar6 + 1;
            iVar9 = iVar9 - iVar7;
            if (iVar6 == values_count) goto LAB_0808ae77;
          }
          iVar6 = iVar6 + 1;
        } while (iVar6 != values_count);
LAB_0808ae77:
        if ((assert_failed == 0) && (assert_failed = ZEXT14(iVar9 == 0), iVar9 == 0)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
          errline = 0x16c;
          elinks_internal((uchar *)"assertion divisor failed!");
        }
        iVar6 = 0;
        local_30 = max_value - iVar5;
        do {
          while (iVar7 = *(int *)((int)__dest + iVar6 * 4), iVar7 < 0) {
            iVar7 = ((max_value - iVar5) * -iVar7) / iVar9;
            values[iVar6] = values[iVar6] + iVar7;
            iVar6 = iVar6 + 1;
            local_30 = local_30 - iVar7;
            if (iVar6 == values_count) goto LAB_0808aecd;
          }
          iVar6 = iVar6 + 1;
        } while (iVar6 != values_count);
LAB_0808aecd:
        if (assert_failed == 0) {
          assert_failed = -(local_30 >> 0x1f);
          if (assert_failed != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
            errline = 0x176;
            elinks_internal((uchar *)
                            "assertion val >= 0 failed: distribute_rows_or_cols_that_left: val < 0")
            ;
            if (assert_failed != 0) goto LAB_0808afc8;
          }
        }
        else {
LAB_0808afc8:
          assert_failed = 0;
          local_30 = 0;
        }
        iVar5 = 0;
        do {
          if ((local_30 != 0) && (*(int *)((int)__dest + iVar5 * 4) < 0)) {
            values[iVar5] = values[iVar5] + 1;
            local_30 = local_30 + -1;
          }
          iVar5 = iVar5 + 1;
        } while (iVar5 != values_count);
        if (assert_failed == 0) {
          assert_failed = ZEXT14(0 < local_30);
          if (0 < local_30) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
            errline = 0x17d;
            elinks_internal((uchar *)
                            "assertion val <= 0 failed: distribute_rows_or_cols_that_left: val > 0")
            ;
            if (assert_failed != 0) goto LAB_0808b00b;
          }
        }
        else {
LAB_0808b00b:
          assert_failed = 0;
        }
        mem_free(__dest);
        goto LAB_0808af5d;
      }
    }
  }
  iVar5 = distribute_rows_or_cols(local_20,max_value,values,values_count);
  if (iVar5 == 0) {
    return;
  }
LAB_0808af5d:
  if (0 < values_count) {
    iVar5 = 0;
    do {
      if (values[iVar5] == 0) {
        local_30 = 0;
        iVar6 = 0;
        iVar9 = 0;
        do {
          if (iVar6 < values[iVar9]) {
            iVar6 = values[iVar9];
            local_30 = iVar9;
          }
          iVar9 = iVar9 + 1;
        } while (iVar9 != values_count);
        if (iVar6 != 0) {
          values[iVar5] = 1;
          values[local_30] = values[local_30] + -1;
        }
      }
      iVar5 = iVar5 + 1;
    } while (iVar5 != values_count);
  }
  *new_values = values;
  *new_values_count = values_count;
  return;
}



// WARNING: Type propagation algorithm not settling

void format_frames(session *ses,frameset_desc *fsd,document_options *op,int depth)

{
  int *piVar1;
  object *poVar2;
  uint uVar3;
  uri *puVar4;
  document *pdVar5;
  int iVar6;
  cache_entry *pcVar7;
  uint uVar8;
  frame *pfVar9;
  int iVar10;
  uchar *src;
  int iVar11;
  document_view *pdVar12;
  document_view *pdVar13;
  document_view *doc_view;
  document_options *pdVar14;
  int *piVar15;
  document_options *pdVar16;
  bool bVar17;
  byte bVar18;
  int local_cc;
  int local_b4;
  int local_b0;
  document_options o;
  
  bVar18 = 0;
  if (assert_failed == 0) {
    if (((fsd == (frameset_desc *)0x0) || (ses == (session *)0x0)) ||
       (op == (document_options *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
      errline = 0xdc;
      elinks_internal((uchar *)"assertion ses && fsd && op failed!");
      if (assert_failed != 0) goto LAB_0808b0ac;
    }
    else {
      assert_failed = 0;
    }
    if (depth < 6) {
      iVar11 = 0x22;
      pdVar14 = op;
      pdVar16 = &o;
      while (iVar11 != 0) {
        iVar11 = iVar11 + -1;
        pdVar16->color_mode = pdVar14->color_mode;
        pdVar14 = (document_options *)((int)pdVar14 + (uint)bVar18 * -8 + 4);
        pdVar16 = (document_options *)((int)pdVar16 + (uint)bVar18 * -8 + 4);
      }
      o.margin = ZEXT14(o.margin != 0);
      if (0 < (fsd->box).height) {
        local_b0 = 0;
        pdVar12 = (document_view *)&ses->scrn_frames;
        local_cc = 0;
        while (o.box.x = (op->box).x, (fsd->box).width < 1) {
LAB_0808b358:
          local_cc = local_cc + 1;
          o.box.y = o.box.y + o.box.height + 1;
          piVar15 = &(fsd->box).height;
          if (*piVar15 == local_cc || *piVar15 < local_cc) {
            return;
          }
        }
        local_b4 = 0;
        piVar15 = &fsd->frame_desc[local_b0].width;
LAB_0808b1db:
        o.box.width = *piVar15;
        o.box.height = piVar15[1];
        o.framename = (uchar *)piVar15[-2];
        if ((frameset_desc *)piVar15[-3] == (frameset_desc *)0x0) {
          if (piVar15[-2] != 0) {
            if (assert_failed == 0) {
              if (ses == (session *)0x0) {
                assert_failed = 1;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
                errline = 0xae;
                elinks_internal((uchar *)"assertion ses && frame_desc && o failed!");
                if (assert_failed != 0) goto LAB_0808b348;
              }
              else {
                assert_failed = 0;
              }
              while (pfVar9 = ses_find_frame(ses,fsd->frame_desc[local_b0].name),
                    pfVar9 != (frame *)0x0) {
                pcVar7 = find_in_cache((pfVar9->vs).uri);
                iVar6 = o.box.y;
                iVar11 = o.box.x;
                if (pcVar7 == (cache_entry *)0x0) break;
                uVar3 = (pfVar9->vs).plain;
                uVar8 = (uint)(o._69_1_ >> 6) & 1;
                if (uVar3 != 0xffffffff) {
                  o._69_1_ = o._69_1_ & 0xbf | (byte)((uVar3 & 1) << 6);
                }
                if ((pcVar7->redirect == (uri *)0x0) || (9 < pfVar9->redirect_cnt)) {
                  src = (uchar *)piVar15[-2];
                  if (assert_failed == 0) {
                    assert_failed = ZEXT14(src == (uchar *)0x0 || ses == (session *)0x0);
                    if (src == (uchar *)0x0 || ses == (session *)0x0) {
                      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
                      errline = 0x87;
                      elinks_internal((uchar *)"assertion ses && name failed!");
                      if (assert_failed != 0) goto LAB_0808b3af;
                    }
                    doc_view = (document_view *)(ses->scrn_frames).prev;
                    goto joined_r0x0808b423;
                  }
LAB_0808b3af:
                  assert_failed = 0;
                  goto LAB_0808b3b9;
                }
                pfVar9->redirect_cnt = pfVar9->redirect_cnt + 1;
                done_uri((pfVar9->vs).uri);
                puVar4 = pcVar7->redirect;
                poVar2 = &puVar4->object;
                poVar2->refcount = poVar2->refcount + 1;
                (pfVar9->vs).uri = puVar4;
                o._69_1_ = o._69_1_ & 0xbf | (byte)(uVar8 << 6);
              }
            }
            else {
LAB_0808b348:
              assert_failed = 0;
            }
          }
        }
        else {
          format_frames(ses,(frameset_desc *)piVar15[-3],&o,depth + 1);
        }
        goto LAB_0808b1b1;
      }
    }
  }
  else {
LAB_0808b0ac:
    assert_failed = 0;
  }
  return;
joined_r0x0808b423:
  if (pdVar12 == doc_view) goto LAB_0808b54e;
  if ((doc_view->used == 0) &&
     (iVar10 = c_strcasecmp((char *)doc_view->name,(char *)src), iVar10 == 0)) {
    doc_view->used = 1;
    doc_view->depth = depth;
    goto LAB_0808b476;
  }
  doc_view = doc_view->prev;
  goto joined_r0x0808b423;
LAB_0808b54e:
  doc_view = (document_view *)mem_calloc(1,0x3c);
  if (doc_view != (document_view *)0x0) {
    doc_view->used = 1;
    src = stracpy(src);
    doc_view->name = src;
    if (src != (uchar *)0x0) {
      doc_view->depth = depth;
      doc_view->session = ses;
      if (iVar11 < 0) {
        iVar11 = 0;
      }
      (doc_view->box).x = iVar11;
      doc_view->search_word = &ses->search_word;
      iVar11 = 0;
      if (-1 < iVar6) {
        iVar11 = iVar6;
      }
      (doc_view->box).width = 0;
      (doc_view->box).height = 0;
      (doc_view->box).y = iVar11;
      if (assert_failed == 0) {
        assert_failed = 0;
        pdVar13 = (document_view *)(ses->scrn_frames).next;
        if (pdVar12 == pdVar13) {
LAB_0808b654:
          doc_view->next = *(document_view **)(ses->scrn_frames).prev;
          doc_view->prev = (document_view *)(ses->scrn_frames).prev;
          ((document_view *)(ses->scrn_frames).prev)->next = doc_view;
          doc_view->next->prev = doc_view;
        }
        else {
          iVar11 = (doc_view->box).x;
          iVar6 = (pdVar13->box).y;
          iVar10 = (doc_view->box).y;
          if ((iVar6 <= iVar10) && ((iVar6 != iVar10 || ((pdVar13->box).x <= iVar11)))) {
            do {
              pdVar13 = pdVar13->next;
              if (pdVar12 == pdVar13) goto LAB_0808b654;
              iVar6 = (pdVar13->box).y;
            } while ((iVar6 <= iVar10) && (((pdVar13->box).x <= iVar11 || (iVar10 != iVar6))));
          }
          doc_view->next = pdVar13->prev->next;
          doc_view->prev = pdVar13->prev;
          pdVar13->prev->next = doc_view;
          doc_view->next->prev = doc_view;
        }
      }
      else {
        assert_failed = 0;
      }
LAB_0808b476:
      render_document(&pfVar9->vs,doc_view,&o);
      if ((assert_failed == 0) &&
         (bVar17 = doc_view->document == (document *)0x0, assert_failed = ZEXT14(bVar17), bVar17)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
        errline = 0xcd;
        elinks_internal((uchar *)"assertion doc_view->document failed!");
      }
      doc_view->document->frame = fsd->frame_desc + local_b0;
      o._69_1_ = o._69_1_ & 0xbf | (byte)(uVar8 << 6);
      if (((doc_view != (document_view *)0x0) &&
          (pdVar5 = doc_view->document, pdVar5 != (document *)0x0)) &&
         (pdVar5->frame_desc != (frameset_desc *)0x0)) {
        (pdVar5->object).refcount = (pdVar5->object).refcount + 1;
        format_frames(ses,pdVar5->frame_desc,&o,depth + 1);
        (pdVar5->object).refcount = (pdVar5->object).refcount + -1;
      }
      goto LAB_0808b1b1;
    }
    mem_free(doc_view);
  }
LAB_0808b3b9:
  o._69_1_ = o._69_1_ & 0xbf | (byte)(uVar8 << 6);
LAB_0808b1b1:
  o.box.x = o.box.width + 1 + o.box.x;
  piVar15 = piVar15 + 5;
  local_b4 = local_b4 + 1;
  local_b0 = local_b0 + 1;
  piVar1 = &(fsd->box).width;
  if (*piVar1 == local_b4 || *piVar1 < local_b4) goto LAB_0808b358;
  goto LAB_0808b1db;
}



void add_frameset_entry(frameset_desc *frameset_desc,frameset_desc *subframe,uchar *name,uchar *url)

{
  int *piVar1;
  uchar *puVar2;
  uri *puVar3;
  int iVar4;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(frameset_desc == (frameset_desc *)0x0);
  if (frameset_desc == (frameset_desc *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
    errline = 0x24;
    elinks_internal((uchar *)"assertion frameset_desc failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  iVar4 = (frameset_desc->box).y;
  if ((frameset_desc->box).height <= iVar4) {
    return;
  }
  iVar4 = iVar4 * (frameset_desc->box).width + (frameset_desc->box).x;
  frameset_desc->frame_desc[iVar4].subframe = subframe;
  puVar2 = (uchar *)0x0;
  if (name != (uchar *)0x0) {
    puVar2 = stracpy(name);
  }
  *(uchar **)(&frameset_desc->n + iVar4 * 5 + 6) = puVar2;
  if ((url == (uchar *)0x0) || (*url == '\0')) {
    frameset_desc->frame_desc[iVar4].uri = (uri *)0x0;
  }
  else {
    puVar3 = get_uri(url,0);
    *(uri **)(&frameset_desc->n + iVar4 * 5 + 7) = puVar3;
    if (puVar3 != (uri *)0x0) goto LAB_0808b7dd;
  }
  puVar3 = get_uri((uchar *)"about:blank",0);
  frameset_desc->frame_desc[iVar4].uri = puVar3;
LAB_0808b7dd:
  iVar4 = (frameset_desc->box).x + 1;
  (frameset_desc->box).x = iVar4;
  if ((frameset_desc->box).width <= iVar4) {
    piVar1 = &(frameset_desc->box).y;
    *piVar1 = *piVar1 + 1;
    (frameset_desc->box).x = 0;
  }
  return;
}



frameset_desc * create_frameset(frameset_param *fp)

{
  uint uVar1;
  frameset_desc *subframe;
  int iVar2;
  uint uVar3;
  frameset_desc *pfVar4;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (frameset_desc *)0x0;
  }
  assert_failed = ZEXT14(fp == (frameset_param *)0x0);
  if (fp == (frameset_param *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
    errline = 0x46;
    elinks_internal((uchar *)"assertion fp failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (frameset_desc *)0x0;
    }
  }
  if ((fp->x < 1) || (fp->y < 1)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
    errline = 0x4a;
    elinks_internal((uchar *)
                    "assertion fp->x > 0 && fp->y > 0 failed: Bad size of frameset: x=%d y=%d",fp->x
                    ,fp->y);
    if (assert_failed != 0) {
      assert_failed = 0;
      if (fp->x < 1) {
        fp->x = 1;
      }
      iVar2 = fp->y;
      if (iVar2 < 1) {
        fp->y = 1;
        iVar2 = 1;
      }
      goto LAB_0808b97d;
    }
  }
  else {
    assert_failed = 0;
  }
  iVar2 = fp->y;
LAB_0808b97d:
  uVar1 = iVar2 * fp->x;
  subframe = (frameset_desc *)mem_calloc(1,(uVar1 * 5 + 5) * 4);
  if (subframe != (frameset_desc *)0x0) {
    if (uVar1 != 0) {
      iVar2 = fp->x;
      uVar3 = 0;
      pfVar4 = subframe;
      while( true ) {
        pfVar4->frame_desc[0].width = fp->width[(int)uVar3 % iVar2];
        pfVar4->frame_desc[0].height = fp->height[(int)uVar3 / fp->x];
        pfVar4 = (frameset_desc *)pfVar4->frame_desc;
        if (uVar1 <= uVar3 + 1) break;
        iVar2 = fp->x;
        uVar3 = uVar3 + 1;
      }
    }
    subframe->n = uVar1;
    (subframe->box).width = fp->x;
    (subframe->box).height = fp->y;
    if (fp->parent != (frameset_desc *)0x0) {
      add_frameset_entry(fp->parent,subframe,(uchar *)0x0,(uchar *)0x0);
      return subframe;
    }
  }
  return subframe;
}



void ln_break(html_context *html_context,int n)

{
  if ((n != 0) && (*(int *)((int)(html_context->stack).next + 0x98) == 0)) {
    while (html_context->line_breax < n) {
      html_context->line_breax = html_context->line_breax + 1;
      (*html_context->line_break_f)(html_context);
    }
    html_context->position = 0;
    html_context->putsp = HTML_SPACE_SUPPRESS;
    return;
  }
  return;
}



void add_fragment_identifier(html_context *html_context,part *part,uchar *attr)

{
  part *ppVar1;
  
  ppVar1 = html_context->part;
  html_context->part = part;
  (*html_context->special_f)(html_context,0,attr);
  html_context->part = ppVar1;
  return;
}



void html_skip(html_context *html_context,uchar *a)

{
  *(undefined4 *)((int)(html_context->stack).next + 0x98) = 1;
  *(undefined4 *)((int)(html_context->stack).next + 8) = 1;
  return;
}



void done_html_parser_state(html_context *html_context,void *state)

{
  html_element *e;
  
  e = (html_element *)(html_context->stack).next;
  html_context->line_breax = 1;
  while (e != (html_element *)state) {
    kill_html_stack_item(html_context,e);
    e = (html_element *)(html_context->stack).next;
  }
  *(undefined4 *)((int)state + 8) = 2;
  kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
  return;
}



void done_html_parser(html_context *html_context)

{
  list_head_elinks *plVar1;
  bool bVar2;
  
  if ((*(byte *)&html_context->options->field_0x44 & 1) != 0) {
    done_css_stylesheet((css_stylesheet *)html_context);
  }
  plVar1 = &html_context->stack;
  mem_free(html_context->base_target);
  done_uri(html_context->base_href);
  kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
  if (assert_failed != 0) {
LAB_0808bc00:
    assert_failed = 0;
    *(list_head_elinks **)&(html_context->stack).prev = plVar1;
    *(list_head_elinks **)&(html_context->stack).next = plVar1;
    mem_free(html_context);
    return;
  }
  bVar2 = (list_head_elinks *)(html_context->stack).next != plVar1;
  assert_failed = ZEXT14(bVar2);
  if (bVar2) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
    errline = 0x3c5;
    elinks_internal((uchar *)
                    "assertion list_empty(html_context->stack) failed: html stack not empty after operation"
                   );
    if (assert_failed != 0) goto LAB_0808bc00;
  }
  mem_free(html_context);
  return;
}



html_context *
init_html_parser(uri *uri,document_options *options,uchar *start,uchar *end,string *head,
                string *title,anon_subr_void_html_context_ptr_uchar_ptr_int *put_chars,
                anon_subr_void_html_context_ptr *line_break,
                anon_subr_void_ptr_html_context_ptr_html_special_type_conflict *special)

{
  list_head_elinks *plVar1;
  void *pvVar2;
  list_head_elinks *plVar3;
  uchar *puVar4;
  void **ppvVar5;
  html_context *css2;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(options == (document_options *)0x0 || uri == (uri *)0x0);
    if (options == (document_options *)0x0 || uri == (uri *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
      errline = 0x369;
      elinks_internal((uchar *)"assertion uri && options failed!");
      if (assert_failed != 0) goto LAB_0808bef6;
    }
    css2 = (html_context *)mem_calloc(1,100);
    if (css2 != (html_context *)0x0) {
      (css2->css_styles).import = import_css_stylesheet;
      plVar1 = &css2->stack;
      plVar3 = &(css2->css_styles).selectors;
      *(list_head_elinks **)&(css2->css_styles).selectors.prev = plVar3;
      *(list_head_elinks **)&(css2->css_styles).selectors.next = plVar3;
      *(list_head_elinks **)&(css2->stack).prev = plVar1;
      *(list_head_elinks **)&(css2->stack).next = plVar1;
      css2->startf = start;
      *(anon_subr_void_html_context_ptr_uchar_ptr_int **)
       &((list_head_elinks *)&css2->put_chars_f)->next = put_chars;
      *(anon_subr_void_html_context_ptr **)&css2->line_break_f = line_break;
      *(anon_subr_void_ptr_html_context_ptr_html_special_type_conflict **)&css2->special_f = special
      ;
      puVar4 = (uchar *)0x0;
      (uri->object).refcount = (uri->object).refcount + 1;
      css2->base_href = uri;
      if (options->framename != (uchar *)0x0) {
        puVar4 = stracpy(options->framename);
      }
      css2->base_target = puVar4;
      *(document_options **)&((list_head_elinks *)&css2->options)->next = options;
      scan_http_equiv(start,end,head,title,options);
      ppvVar5 = (void **)mem_calloc(1,0xb4);
      if (ppvVar5 == (void **)0x0) {
        css2 = (html_context *)0x0;
      }
      else {
        pvVar2 = plVar1->next;
        *(list_head_elinks **)(ppvVar5 + 1) = plVar1;
        *ppvVar5 = pvVar2;
        *(void ***)&plVar1->next = ppvVar5;
        *(void ***)((int)*ppvVar5 + 4) = ppvVar5;
        *(undefined4 *)((int)(css2->stack).next + 0xc) = 0;
        *(undefined4 *)((int)(css2->stack).next + 0x18) = 3;
        pvVar2 = (css2->stack).next;
        *(undefined4 *)((int)pvVar2 + 0x24) = 0;
        *(undefined4 *)((int)pvVar2 + 0x20) = 0;
        *(undefined4 *)((int)pvVar2 + 0x1c) = 0;
        pvVar2 = (css2->stack).next;
        *(undefined4 *)((int)pvVar2 + 0x70) = 0;
        *(undefined4 *)((int)pvVar2 + 0x6c) = 0;
        *(undefined4 *)((int)pvVar2 + 0x68) = 0;
        *(undefined4 *)((int)pvVar2 + 100) = 0;
        *(undefined4 *)((int)pvVar2 + 0x60) = 0;
        *(undefined4 *)((int)pvVar2 + 0x5c) = 0;
        *(undefined4 *)((int)pvVar2 + 0x58) = 0;
        *(undefined4 *)((int)(css2->stack).next + 0x48) = 0;
        *(undefined4 *)((int)(css2->stack).next + 0x2c) = 0;
        *(undefined4 *)((int)(css2->stack).next + 0x28) = 0;
        pvVar2 = (css2->stack).next;
        *(text_style_format *)((int)pvVar2 + 0xc) = (options->default_style).attr;
        *(color_T *)((int)pvVar2 + 0x10) = (options->default_style).fg;
        *(color_T *)((int)pvVar2 + 0x14) = (options->default_style).bg;
        *(color_T *)((int)(css2->stack).next + 0x30) = options->default_link;
        *(color_T *)((int)(css2->stack).next + 0x34) = options->default_vlink;
        *(color_T *)((int)(css2->stack).next + 0x38) = options->default_bookmark_link;
        *(color_T *)((int)(css2->stack).next + 0x3c) = options->default_image_link;
        *(undefined4 *)((int)(css2->stack).next + 0x74) = 0;
        *(int *)((int)(css2->stack).next + 0x78) = options->margin;
        *(int *)((int)(css2->stack).next + 0x7c) = options->margin;
        *(int *)((int)(css2->stack).next + 0x80) = (options->box).width;
        *(undefined4 *)((int)(css2->stack).next + 0x88) = 0;
        *(undefined4 *)((int)(css2->stack).next + 0x84) = 0;
        *(int *)((int)(css2->stack).next + 0x8c) = options->margin;
        *(undefined4 *)((int)(css2->stack).next + 0x90) = 0;
        *(color_T *)((int)(css2->stack).next + 0x94) = (options->default_style).bg;
        *(undefined4 *)((int)(css2->stack).next + 0x98) = 0;
        *(undefined4 *)((int)(css2->stack).next + 0x9c) = 0;
        *(undefined4 *)((int)(css2->stack).next + 0xa0) = 0;
        *(undefined4 *)((int)(css2->stack).next + 0xa4) = 0;
        *(undefined4 *)((int)(css2->stack).next + 0xa8) = 1;
        *(undefined4 *)((int)(css2->stack).next + 8) = 1;
        *(byte *)&((list_head_elinks *)&css2->field_0x44)->next =
             *(byte *)&((list_head_elinks *)&css2->field_0x44)->next & 0xf7;
        *(css_stylesheet_importer_T **)&css2->table_level = (css_stylesheet_importer_T *)0x0;
        *(html_context **)&(css2->css_styles).import_data = css2;
        if ((*(byte *)&options->field_0x44 & 1) != 0) {
          mirror_css_stylesheet(&default_stylesheet,(css_stylesheet *)css2);
        }
      }
    }
  }
  else {
LAB_0808bef6:
    assert_failed = 0;
    css2 = (html_context *)0x0;
  }
  return css2;
}



void * init_html_parser_state
                 (html_context *html_context,html_element_mortality_type type,int align,int margin,
                 int width)

{
  html_stack_dup(html_context,type);
  *(int *)((int)(html_context->stack).next + 0x74) = align;
  if (type == ELEMENT_IMMORTAL) {
    *(int *)((int)(html_context->stack).next + 0x78) = margin;
    *(int *)((int)(html_context->stack).next + 0x7c) = margin;
    *(int *)((int)(html_context->stack).next + 0x80) = width;
    *(undefined4 *)((int)(html_context->stack).next + 0x84) = 0;
    *(undefined4 *)((int)(html_context->stack).next + 0x88) = 0;
    *(undefined4 *)((int)(html_context->stack).next + 0x8c) = 0;
    *(undefined4 *)((int)(html_context->stack).next + 0xa0) = 0;
  }
  return (html_context->stack).next;
}



void set_fragment_identifier(html_context *html_context,uchar *attr_name,uchar *attr)

{
  uchar *p;
  
  p = get_attr_value(attr_name,attr,html_context->doc_cp,HTML_ATTR_NONE);
  if (p != (uchar *)0x0) {
    (*html_context->special_f)(html_context,0,p);
    mem_free(p);
    return;
  }
  return;
}



void put_chrs(html_context *html_context,uchar *start,int len)

{
  void *pvVar1;
  ushort **ppuVar2;
  ushort *puVar3;
  
  pvVar1 = (html_context->stack).next;
  if ((*(byte *)((int)pvVar1 + 0xc) & 0x20) != 0) {
    html_context->putsp = HTML_SPACE_NORMAL;
  }
  if (len == 0) {
    return;
  }
  if (*(int *)((int)pvVar1 + 0x98) != 0) {
    return;
  }
  if (html_context->putsp != HTML_SPACE_SUPPRESS) {
    if (html_context->putsp != HTML_SPACE_ADD) {
      ppuVar2 = __ctype_b_loc();
      puVar3 = *ppuVar2;
      goto LAB_0808c06d;
    }
    (*html_context->put_chars_f)(html_context," ",1);
    html_context->position = html_context->position + 1;
    html_context->putsp = HTML_SPACE_SUPPRESS;
  }
  html_context->putsp = HTML_SPACE_NORMAL;
  ppuVar2 = __ctype_b_loc();
  puVar3 = *ppuVar2;
  if ((*(byte *)((int)puVar3 + (uint)*start * 2 + 1) & 0x20) != 0) {
    len = len + -1;
    if (len == 0) {
      html_context->putsp = HTML_SPACE_SUPPRESS;
      return;
    }
    start = start + 1;
  }
LAB_0808c06d:
  if (((*(byte *)((int)puVar3 + (uint)start[len + -1] * 2 + 1) & 0x20) != 0) &&
     ((*(byte *)((int)(html_context->stack).next + 0xc) & 0x20) == 0)) {
    html_context->putsp = HTML_SPACE_SUPPRESS;
  }
  *(byte *)&html_context->field_0x44 = *(byte *)&html_context->field_0x44 & 0xfe;
  (*html_context->put_chars_f)(html_context,start,len);
  html_context->position = html_context->position + len;
  html_context->line_breax = 0;
  if (0 < html_context->was_li) {
    html_context->was_li = html_context->was_li + -1;
  }
  return;
}



void html_focusable(html_context *html_context,uchar *a)

{
  byte bVar1;
  int cp;
  byte *p;
  uchar *puVar2;
  ushort **ppuVar3;
  uint uVar4;
  void *pvVar5;
  
  *(undefined4 *)((int)(html_context->stack).next + 0x54) = 0;
  *(undefined4 *)((int)(html_context->stack).next + 0x50) = 0x80000000;
  if (a == (uchar *)0x0) {
    return;
  }
  cp = html_context->doc_cp;
  p = get_attr_value(a,"accesskey",cp,HTML_ATTR_NONE);
  if (p == (byte *)0x0) goto LAB_0808c191;
  pvVar5 = (html_context->stack).next;
  bVar1 = *p;
  if ((bVar1 == 0) || (p[1] != 0)) {
LAB_0808c181:
    uVar4 = 0;
  }
  else {
    ppuVar3 = __ctype_b_loc();
    uVar4 = (uint)bVar1;
    if ((*(byte *)((int)*ppuVar3 + uVar4 * 2 + 1) & 0x40) == 0) goto LAB_0808c181;
  }
  *(uint *)((int)pvVar5 + 0x54) = uVar4;
  mem_free(p);
LAB_0808c191:
  uVar4 = get_num(a,"tabindex",html_context->doc_cp);
  if (uVar4 - 1 < 0x7ffe) {
    *(int *)((int)(html_context->stack).next + 0x50) = (uVar4 & 0x7fff) << 0x10;
  }
  pvVar5 = (html_context->stack).next;
  if (*(void **)((int)pvVar5 + 0x58) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar5 + 0x58));
    pvVar5 = (html_context->stack).next;
  }
  puVar2 = get_attr_value(a,(uchar *)"onclick",cp,HTML_ATTR_NONE);
  *(uchar **)((int)pvVar5 + 0x58) = puVar2;
  pvVar5 = (html_context->stack).next;
  if (*(void **)((int)pvVar5 + 0x5c) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar5 + 0x5c));
    pvVar5 = (html_context->stack).next;
  }
  puVar2 = get_attr_value(a,(uchar *)"ondblclick",cp,HTML_ATTR_NONE);
  *(uchar **)((int)pvVar5 + 0x5c) = puVar2;
  pvVar5 = (html_context->stack).next;
  if (*(void **)((int)pvVar5 + 0x60) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar5 + 0x60));
    pvVar5 = (html_context->stack).next;
  }
  puVar2 = get_attr_value(a,(uchar *)"onmouseover",cp,HTML_ATTR_NONE);
  *(uchar **)((int)pvVar5 + 0x60) = puVar2;
  pvVar5 = (html_context->stack).next;
  if (*(void **)((int)pvVar5 + 100) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar5 + 100));
    pvVar5 = (html_context->stack).next;
  }
  puVar2 = get_attr_value(a,(uchar *)"onhover",cp,HTML_ATTR_NONE);
  *(uchar **)((int)pvVar5 + 100) = puVar2;
  pvVar5 = (html_context->stack).next;
  if (*(void **)((int)pvVar5 + 0x68) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar5 + 0x68));
    pvVar5 = (html_context->stack).next;
  }
  puVar2 = get_attr_value(a,(uchar *)"onfocus",cp,HTML_ATTR_NONE);
  *(uchar **)((int)pvVar5 + 0x68) = puVar2;
  pvVar5 = (html_context->stack).next;
  if (*(void **)((int)pvVar5 + 0x6c) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar5 + 0x6c));
    pvVar5 = (html_context->stack).next;
  }
  puVar2 = get_attr_value(a,(uchar *)"onmouseout",cp,HTML_ATTR_NONE);
  *(uchar **)((int)pvVar5 + 0x6c) = puVar2;
  pvVar5 = (html_context->stack).next;
  if (*(void **)((int)pvVar5 + 0x70) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar5 + 0x70));
    pvVar5 = (html_context->stack).next;
  }
  puVar2 = get_attr_value(a,(uchar *)"onblur",cp,HTML_ATTR_NONE);
  *(uchar **)((int)pvVar5 + 0x70) = puVar2;
  return;
}



void process_head(html_context *html_context,uchar *head)

{
  byte *pbVar1;
  uchar *puVar2;
  byte bVar3;
  uchar *p;
  uchar *rel;
  int *piVar4;
  char *pcVar5;
  int len;
  uchar *src;
  size_t len_00;
  byte *pbVar6;
  uchar uVar7;
  uchar *extraout_EDX;
  ulong uVar8;
  uchar *extraout_EDX_00;
  byte *src_00;
  long seconds;
  timeval_T now;
  timeval_T max_age;
  uchar *local_20 [4];
  
  p = parse_header(head,(uchar *)"Refresh",(uchar **)0x0);
  rel = extraout_EDX;
  if (p != (uchar *)0x0) {
    if ((assert_failed == 0) && (assert_failed = 0, *p != '\0')) {
      pcVar5 = c_strcasestr((char *)p,"url");
      if (pcVar5 != (char *)0x0) {
        src_00 = (byte *)(pcVar5 + 3);
        bVar3 = pcVar5[3];
        while (bVar3 != 0) {
          if ((bVar3 != 0x3d) && (0x20 < bVar3)) {
            len = 0;
            goto LAB_0808c56c;
          }
          src_00 = src_00 + 1;
          bVar3 = *src_00;
        }
        rel = stracpy("");
        if (rel != (uchar *)0x0) goto LAB_0808c466;
      }
      goto LAB_0808c5ce;
    }
LAB_0808c3fe:
    assert_failed = 0;
    uVar7 = *p;
    if (uVar7 != '\0') {
      rel = p;
      if ((uVar7 == ' ') || (uVar7 == '\t')) {
        do {
          rel = rel + 1;
          uVar7 = *rel;
          if (uVar7 == '\0') goto LAB_0808c433;
        } while ((uVar7 == '\t') || (uVar7 == ' '));
      }
      while ((byte)(uVar7 - 0x30) < 10) {
        uVar7 = rel[1];
        rel = rel + 1;
      }
      if ((uVar7 != '\0') && (uVar7 = *rel, uVar7 != '\0')) {
        if ((uVar7 == ' ') || (uVar7 == '\t')) {
          do {
            rel = rel + 1;
            uVar7 = *rel;
            if (uVar7 == '\0') goto LAB_0808c433;
          } while ((uVar7 == '\t') || (uVar7 == ' '));
        }
        if ((uVar7 == ',') || (uVar7 == ';')) {
          src = rel + 1;
          uVar7 = rel[1];
          if (uVar7 != '\0') {
            if ((uVar7 == ' ') || (uVar7 == '\t')) {
              do {
                src = src + 1;
                uVar7 = *src;
                if (uVar7 == '\0') goto LAB_0808c433;
              } while ((uVar7 == '\t') || (uVar7 == ' '));
            }
            len_00 = strlen((char *)src);
            if (len_00 != 0) {
              rel = src + len_00;
              if ((*rel == ' ') || (*rel == '\t')) {
                do {
                  len_00 = len_00 - 1;
                  if (len_00 == 0) goto LAB_0808c433;
                  puVar2 = rel + -1;
                  rel = rel + -1;
                } while ((*puVar2 == '\t') || (*puVar2 == ' '));
              }
              rel = memacpy(src,len_00);
              if (rel != (uchar *)0x0) goto LAB_0808c466;
            }
          }
        }
      }
    }
    goto LAB_0808c433;
  }
  goto LAB_0808c48e;
LAB_0808c56c:
  bVar3 = src_00[len];
  if (bVar3 < 0x21) {
    if ((bVar3 != 9) && (bVar3 != 0x20)) goto LAB_0808c57a;
  }
  else {
    if (bVar3 == 0x3b) goto LAB_0808c57a;
  }
  len = len + 1;
  goto LAB_0808c56c;
LAB_0808c57a:
  if (len != 0) {
    if ((src_00[len + -1] == 9) || (src_00[len + -1] == 0x20)) {
      pbVar6 = src_00 + len;
      do {
        len = len + -1;
        if (len == 0) goto LAB_0808c5b8;
        pbVar1 = pbVar6 + -2;
        pbVar6 = pbVar6 + -1;
      } while ((*pbVar1 == 9) || (*pbVar1 == 0x20));
    }
    if ((1 < len) && ((*src_00 == 0x27 && (src_00[len + -1] == 0x27)))) {
      pbVar6 = src_00 + len;
      do {
        len = len + -2;
        src_00 = src_00 + 1;
        if ((len < 2) || (*src_00 != 0x27)) break;
        pbVar1 = pbVar6 + -2;
        pbVar6 = pbVar6 + -1;
      } while (*pbVar1 == 0x27);
    }
  }
LAB_0808c5b8:
  rel = memacpy(src_00,len);
  if (rel == (uchar *)0x0) {
LAB_0808c5ce:
    if (assert_failed == 0) goto LAB_0808c3fe;
    assert_failed = 0;
LAB_0808c433:
    rel = get_uri_string(html_context->base_href,URI_ORIGINAL);
    if (rel != (uchar *)0x0) goto LAB_0808c466;
  }
  else {
LAB_0808c466:
    uVar8 = 0;
    if (*p == ';') {
LAB_0808c62f:
      src = join_urls(html_context->base_href,rel);
      html_focusable(html_context,(uchar *)0x0);
      put_link_line((uchar *)"Refresh: ",rel,src,html_context->options->framename,html_context);
      (*html_context->special_f)(html_context,10,uVar8,src);
      mem_free(src);
    }
    else {
      if ((byte)(*p - 0x30) < 10) {
        piVar4 = __errno_location();
        *piVar4 = 0;
        uVar8 = strtoul((char *)p,(char **)0x0,10);
        if ((*piVar4 == 0x22) || (0x2a300 < uVar8)) {
          uVar8 = 0x2a300;
        }
        else {
          if (*piVar4 != 0) goto LAB_0808c47e;
        }
        goto LAB_0808c62f;
      }
    }
LAB_0808c47e:
    mem_free(rel);
  }
  mem_free(p);
  rel = extraout_EDX_00;
LAB_0808c48e:
  piVar4 = get_opt_(config_options,rel);
  if (*piVar4 == 0) {
    rel = parse_header(head,(uchar *)"Pragma",(uchar **)0x0);
    local_20[0] = rel;
    if (rel != (uchar *)0x0) {
      pcVar5 = strstr((char *)rel,"no-cache");
      mem_free(rel);
      if (pcVar5 != (char *)0x0) goto LAB_0808c502;
    }
    rel = parse_header(head,(uchar *)"Cache-Control",(uchar **)0x0);
    local_20[0] = rel;
    if (rel == (uchar *)0x0) {
      seconds = 0;
    }
    else {
      pcVar5 = strstr((char *)rel,"no-cache");
      if ((pcVar5 != (char *)0x0) ||
         (pcVar5 = strstr((char *)rel,"must-revalidate"), pcVar5 != (char *)0x0)) {
        mem_free(rel);
LAB_0808c502:
        (*html_context->special_f)(html_context,8);
        return;
      }
      pcVar5 = strstr((char *)rel,"max-age=");
      if (assert_failed == 0) {
        assert_failed = 0;
      }
      seconds = 0;
      if (pcVar5 != (char *)0x0) {
        seconds = strtol(pcVar5 + 8,(char **)0x0,10);
        timeval_from_seconds(&now,seconds);
        timeval_now(&max_age);
        timeval_add_interval(&max_age,&now);
        seconds = timeval_to_seconds(&max_age);
        rel = local_20[0];
      }
      mem_free(rel);
    }
    local_20[0] = parse_header(head,(uchar *)"Expires",(uchar **)0x0);
    if (local_20[0] != (uchar *)0x0) {
      pcVar5 = strstr((char *)local_20[0],"now");
      if (pcVar5 == (char *)0x0) {
        seconds = parse_date(local_20,(uchar *)0x0,0,1);
      }
      else {
        timeval_now(&now);
        seconds = timeval_to_seconds(&now);
      }
      mem_free(local_20[0]);
    }
    if (seconds != 0) {
      (*html_context->special_f)(html_context,9,seconds);
      return;
    }
  }
  return;
}



void import_css_stylesheet(css_stylesheet *css,uri *base_uri,uchar *unterminated_url,int len)

{
  byte bVar1;
  void *pvVar2;
  uchar *rel;
  uchar *string;
  uri *uri;
  
  pvVar2 = css->import_data;
  if (assert_failed == 0) {
    assert_failed = ZEXT14(pvVar2 == (void *)0x0);
    if (pvVar2 == (void *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
      errline = 0xc0;
      elinks_internal((uchar *)"assertion html_context failed!");
      if (assert_failed != 0) goto LAB_0808ca8b;
    }
    assert_failed = ZEXT14(base_uri == (uri *)0x0);
    if (base_uri == (uri *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
      errline = 0xc1;
      elinks_internal((uchar *)"assertion base_uri failed!");
      bVar1 = *(byte *)(*(int *)((int)pvVar2 + 0x1c) + 0x44);
      goto joined_r0x0808ca97;
    }
  }
LAB_0808ca8b:
  bVar1 = *(byte *)(*(int *)((int)pvVar2 + 0x1c) + 0x44);
joined_r0x0808ca97:
  if (((bVar1 & 3) == 3) && (rel = memacpy(unterminated_url,len), rel != (uchar *)0x0)) {
    string = join_urls(base_uri,rel);
    mem_free(rel);
    if (string != (uchar *)0x0) {
      uri = get_uri(string,URI_BASE);
      mem_free(string);
      if (uri != (uri *)0x0) {
        (**(code **)((int)pvVar2 + 0x60))(pvVar2,0xb,uri);
        import_css(css,uri);
        done_uri(uri);
        return;
      }
    }
  }
  return;
}



uchar * get_target(document_options *options,uchar *a)

{
  uchar *p;
  int iVar1;
  
  p = get_attr_value(a,(uchar *)"target",options->cp,HTML_ATTR_NONE);
  if (p == (uchar *)0x0) {
    return (uchar *)0x0;
  }
  if ((*p != '\0') && (iVar1 = c_strcasecmp((char *)p,"_self"), iVar1 != 0)) {
    return p;
  }
  mem_free(p);
  p = stracpy(options->framename);
  return p;
}



int get_image_map(uchar *head,uchar *pos,uchar *eof,menu_item **menu,memory_list **ml,uri *uri,
                 document_options *options,uchar *target_base,int to,int def,int hdef)

{
  uchar **ppuVar1;
  uchar *puVar2;
  char **ppcVar3;
  uchar *n1;
  uchar *s1;
  string *psVar4;
  conv_table *convert_table;
  int iVar5;
  uchar *s1_00;
  size_t charslen;
  uchar **p;
  uchar *__src;
  menu_item *pmVar6;
  uchar *puVar7;
  uint uVar8;
  uint size;
  menu_item *pmVar9;
  uint uVar10;
  int iVar11;
  uchar **ppuVar12;
  bool bVar13;
  byte bVar14;
  uchar *local_44;
  uchar *local_40;
  string str;
  string hd;
  uchar *local_2c;
  uchar *local_28;
  uchar *local_24;
  uchar *local_20 [4];
  
  bVar14 = 0;
  psVar4 = init_string(&hd);
  if (psVar4 != (string *)0x0) {
    if (head != (uchar *)0x0) {
      add_to_string(&hd,head);
    }
    scan_http_equiv(pos,eof,&hd,(string *)0x0,options);
    convert_table = get_convert_table(hd.source,to,def,(int *)0x0,(cp_status *)0x0,hdef);
    done_string(&hd);
    pmVar6 = (menu_item *)mem_calloc(1,0x20);
    *menu = pmVar6;
    if (pmVar6 != (menu_item *)0x0) {
LAB_0808cd33:
      do {
        if (eof <= pos) {
LAB_0808cd37:
          mem_free(*menu);
          return -1;
        }
        if (*pos == '<') {
          if ((eof < pos + 2) || ((pos[1] != '?' && (pos[1] != '!')))) {
            iVar5 = parse_element(pos,eof,&local_24,(int *)local_20,&local_28,&pos);
            if (iVar5 == 0) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
              errline = 0x226;
              iVar5 = elinks_strlcasecmp(local_24,(size_t)local_20[0],"MAP",3,1);
              if (iVar5 == 0) {
                if ((uri != (uri *)0x0) && (uri->fragment != (uchar *)0x0)) {
                  s1_00 = get_attr_value(local_28,"name",options->cp,HTML_ATTR_NONE);
                  if (s1_00 == (uchar *)0x0) goto LAB_0808cd33;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
                  errline = 0x22e;
                  iVar5 = elinks_strlcasecmp(s1_00,0xffffffff,uri->fragment,
                                             (uint)*(ushort *)&uri->field_0x34,1);
                  if (iVar5 != 0) {
                    mem_free(s1_00);
                    goto LAB_0808cd33;
                  }
                  mem_free(s1_00);
                }
                if (pos < eof) {
                  *ml = (memory_list *)0x0;
                  goto joined_r0x0808ce97;
                }
                goto LAB_0808cd37;
              }
            }
            else {
              pos = pos + 1;
            }
          }
          else {
            pos = skip_comment(pos,eof);
          }
          goto LAB_0808cd33;
        }
        pos = pos + 1;
      } while( true );
    }
  }
  return -1;
joined_r0x0808ce97:
  s1_00 = pos;
  if (eof <= pos) {
LAB_0808d0b8:
    pos = s1_00;
    freeml(*ml);
    mem_free(*menu);
    return -1;
  }
  if (*pos != '<') {
    pos = pos + 1;
    goto joined_r0x0808ce97;
  }
  if ((eof < pos + 2) || ((pos[1] != '?' && (pos[1] != '!')))) {
    iVar5 = parse_element(pos,eof,&local_24,(int *)&local_28,local_20,&pos);
    if (iVar5 == 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
      errline = 0x28a;
      iVar5 = elinks_strlcasecmp(local_24,(size_t)local_28,"A",1,1);
      if (iVar5 == 0) {
LAB_0808d060:
        s1 = local_24;
        n1 = local_28;
        psVar4 = init_string(&str);
        __src = pos;
        s1_00 = eof;
        if (psVar4 == (string *)0x0) goto LAB_0808d0b8;
        local_2c = pos;
        if (eof <= pos) {
LAB_0808d0a3:
          done_string(&str);
          s1_00 = eof;
          goto LAB_0808d0b8;
        }
        if (*pos != '<') {
          do {
            local_2c = local_2c + 1;
            if (eof <= local_2c) goto LAB_0808d0a3;
          } while (*local_2c != '<');
          if (local_2c != pos) {
            if (assert_failed == 0) {
              s1_00 = local_2c + -(int)pos;
              if ((int)s1_00 < 0) {
                assert_failed = 1;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                errline = 0xff;
                elinks_internal((uchar *)
                                "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                               );
                if (assert_failed != 0) goto LAB_0808d4c4;
              }
              else {
                assert_failed = 0;
              }
              if (s1_00 != (uchar *)0x0) {
                puVar2 = s1_00 + str.length;
                uVar10 = str.length + 0xffU >> 8;
                uVar8 = str.length + 0xffU & 0xffffff00;
                size = (uint)(puVar2 + 0x100) & 0xffffff00;
                if (uVar8 <= size && size + uVar10 * -0x100 != 0) {
                  puVar7 = (uchar *)mem_realloc(str.source,size);
                  if (puVar7 == (uchar *)0x0) goto LAB_0808d4d4;
                  str.source = puVar7;
                  memset(puVar7 + uVar8,0,size + uVar10 * -0x100);
                }
                if (str.source != (uchar *)0x0) {
                  memcpy(str.source + str.length,__src,(size_t)s1_00);
                  str.source[(int)puVar2] = '\0';
                  str.length = (int)puVar2;
                }
              }
            }
            else {
LAB_0808d4c4:
              assert_failed = 0;
            }
          }
        }
LAB_0808d4d4:
        local_44 = str.source;
        pos = local_2c;
        if ((local_2c + 2 <= eof) && ((local_2c[1] == '?' || (local_2c[1] == '!')))) {
          pos = skip_comment(local_2c,eof);
          goto LAB_0808d060;
        }
        iVar5 = parse_element(local_2c,eof,(uchar **)0x0,(int *)0x0,(uchar **)0x0,&local_2c);
        if (iVar5 != 0) goto LAB_0808d060;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
        errline = 0x25d;
        iVar5 = elinks_strlcasecmp(s1,(size_t)n1,"A",1,1);
        if (iVar5 != 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
          errline = 0x25e;
          iVar5 = elinks_strlcasecmp(s1,(size_t)n1,"/A",2,1);
          if (iVar5 == 0) goto LAB_0808d56d;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
          errline = 0x25f;
          iVar5 = elinks_strlcasecmp(s1,(size_t)n1,"MAP",3,1);
          if (iVar5 == 0) goto LAB_0808d56d;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
          errline = 0x260;
          iVar5 = elinks_strlcasecmp(s1,(size_t)n1,"/MAP",4,1);
          if (iVar5 == 0) goto LAB_0808d56d;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
          errline = 0x261;
          iVar5 = elinks_strlcasecmp(s1,(size_t)n1,"AREA",4,1);
          if (iVar5 == 0) goto LAB_0808d56d;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
          errline = 0x262;
          iVar5 = elinks_strlcasecmp(s1,(size_t)n1,(uchar *)"/AREA",5,1);
          if (iVar5 == 0) goto LAB_0808d56d;
          pos = local_2c;
          goto LAB_0808d060;
        }
LAB_0808d56d:
        s1_00 = pos;
        if (eof <= pos) goto LAB_0808d0b8;
LAB_0808d1ee:
        local_40 = get_target(options,local_20[0]);
        if (local_40 == (uchar *)0x0) {
          s1_00 = "";
          if (target_base != (uchar *)0x0) {
            s1_00 = target_base;
          }
          local_40 = stracpy(s1_00);
          if (local_40 == (uchar *)0x0) {
            if (local_44 != (uchar *)0x0) {
              mem_free(local_44);
            }
            goto joined_r0x0808ce97;
          }
        }
        p = (uchar **)mem_alloc(8);
        if (p == (uchar **)0x0) {
          if (local_44 != (uchar *)0x0) {
            mem_free(local_44);
          }
          mem_free(local_40);
        }
        else {
          s1_00 = get_attr_value(local_20[0],"href",options->cp,HTML_ATTR_EAT_NL);
          if (s1_00 == (uchar *)0x0) {
            if (local_44 != (uchar *)0x0) {
              mem_free(local_44);
            }
            mem_free(local_40);
            mem_free(p);
          }
          else {
            __src = join_urls(uri,s1_00);
            *p = __src;
            mem_free(s1_00);
            if (*p == (uchar *)0x0) {
              if (local_44 != (uchar *)0x0) {
                mem_free(local_44);
              }
LAB_0808d740:
              mem_free(local_40);
              mem_free(p);
            }
            else {
              iVar11 = 0;
              p[1] = local_40;
              iVar5 = 0;
              if ((*menu)->text != (uchar *)0x0) {
                s1_00 = *p;
                pmVar6 = *menu;
                do {
                  pmVar9 = pmVar6 + 1;
                  ppcVar3 = (char **)pmVar6->data;
                  iVar5 = strcmp(*ppcVar3,(char *)s1_00);
                  if ((iVar5 == 0) && (iVar5 = strcmp(ppcVar3[1],(char *)local_40), iVar5 == 0)) {
                    mem_free(s1_00);
                    mem_free(p[1]);
                    mem_free(p);
                    if (local_44 != (uchar *)0x0) {
                      mem_free(local_44);
                    }
                    goto joined_r0x0808ce97;
                  }
                  iVar11 = iVar11 + 1;
                  iVar5 = iVar11 * 0x20;
                  pmVar6 = pmVar9;
                } while (pmVar9->text != (uchar *)0x0);
              }
              if (local_44 == (uchar *)0x0) {
LAB_0808d763:
                local_44 = stracpy(*p);
                if (local_44 == (uchar *)0x0) {
                  mem_free(local_40);
                  local_40 = *p;
                  goto LAB_0808d740;
                }
              }
              else {
                clr_spaces(local_44);
                if (*local_44 == '\0') {
                  mem_free(local_44);
                  goto LAB_0808d763;
                }
              }
              pmVar6 = (menu_item *)mem_realloc(*menu,(iVar11 + 2) * 0x20);
              if (pmVar6 != (menu_item *)0x0) {
                uVar10 = 0x40;
                *menu = pmVar6;
                ppuVar1 = (uchar **)((int)&pmVar6->text + iVar5);
                bVar13 = ((uint)ppuVar1 & 1) != 0;
                ppuVar12 = ppuVar1;
                if (bVar13) {
                  *(undefined *)ppuVar1 = 0;
                  ppuVar12 = (uchar **)((int)ppuVar1 + 1);
                  uVar10 = 0x3f;
                }
                if (((uint)ppuVar12 & 2) != 0) {
                  *(undefined2 *)ppuVar12 = 0;
                  uVar10 = uVar10 - 2;
                  ppuVar12 = (uchar **)((int)ppuVar12 + 2);
                }
                uVar8 = uVar10 >> 2;
                while (uVar8 != 0) {
                  uVar8 = uVar8 - 1;
                  *ppuVar12 = (uchar *)0x0;
                  ppuVar12 = ppuVar12 + (uint)bVar14 * 0x3ffffffe + 1;
                }
                if ((uVar10 & 2) != 0) {
                  *(undefined2 *)ppuVar12 = 0;
                  ppuVar12 = (uchar **)((int)ppuVar12 + 2);
                }
                if (bVar13) {
                  *(undefined *)ppuVar12 = 0;
                }
                *(code **)(ppuVar1 + 3) = map_selected;
                *ppuVar1 = local_44;
                ppuVar1[5] = &DAT_00000040;
                *(uchar ***)(ppuVar1 + 4) = p;
              }
              add_to_ml(ml,p,*p,p[1],local_44,0);
            }
          }
        }
        goto joined_r0x0808ce97;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
      errline = 0x28f;
      iVar5 = elinks_strlcasecmp(local_24,(size_t)local_28,"AREA",4,1);
      if (iVar5 == 0) {
        s1_00 = get_attr_value(local_20[0],"alt",options->cp,HTML_ATTR_NONE);
        local_44 = (uchar *)0x0;
        if (s1_00 != (uchar *)0x0) {
          charslen = strlen((char *)s1_00);
          local_44 = convert_string_elinks
                               (convert_table,s1_00,charslen,options->cp,CSM_DEFAULT,(int *)0x0,
                                (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
          mem_free(s1_00);
        }
        goto LAB_0808d1ee;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
      errline = 0x29d;
      iVar5 = elinks_strlcasecmp(local_24,(size_t)local_28,"/MAP",4,1);
      if (iVar5 == 0) {
        add_to_ml(ml,*menu,0);
        return 0;
      }
    }
    else {
      pos = pos + 1;
    }
    goto joined_r0x0808ce97;
  }
  pos = skip_comment(pos,eof);
  goto joined_r0x0808ce97;
}



int get_color(html_context *html_context,uchar *a,uchar *c,color_T *rgb)

{
  uchar *str;
  size_t slen;
  int iVar1;
  
  if (((html_context->options->color_mode != COLOR_MODE_MONO) &&
      (0 < html_context->options->use_document_colors)) &&
     (str = get_attr_value(a,c,html_context->doc_cp,HTML_ATTR_NONE), str != (uchar *)0x0)) {
    slen = strlen((char *)str);
    iVar1 = decode_color(str,slen,rgb);
    mem_free(str);
    return iVar1;
  }
  return -1;
}



int get_bgcolor(html_context *html_context,uchar *a,color_T *rgb)

{
  int iVar1;
  
  if ((html_context->options->color_mode != COLOR_MODE_MONO) &&
     (html_context->options->use_document_colors == 2)) {
    iVar1 = get_color(html_context,a,(uchar *)"bgcolor",rgb);
    return iVar1;
  }
  return -1;
}



void check_html_form_hierarchy(part *part)

{
  list_head_elinks *plVar1;
  document *pdVar2;
  void *pvVar3;
  bool bVar4;
  list_head_elinks *plVar5;
  list_head_elinks *plVar6;
  list_head_elinks *plVar7;
  list_head_elinks *plVar8;
  list_head_elinks *plVar9;
  list_head_elinks form_controls;
  
  plVar1 = &form_controls;
  pdVar2 = part->document;
  plVar9 = (list_head_elinks *)(pdVar2->forms).next;
  plVar7 = &pdVar2->forms;
  if (plVar9 != plVar7) {
    if (assert_failed != 0) {
      assert_failed = 0;
      plVar9 = (list_head_elinks *)(pdVar2->forms).next;
    }
    form_controls.next = plVar1;
    form_controls.prev = plVar1;
    if (plVar9 != plVar7) {
      do {
        if ((assert_failed == 0) &&
           (bVar4 = (int)plVar9[1].prev < (int)plVar9[1].next, assert_failed = ZEXT14(bVar4), bVar4)
           ) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
          errline = 0x778;
          elinks_internal((uchar *)"assertion form->form_num <= form->form_end failed: %p [%d : %d]"
                          ,plVar9,plVar9[1].next,plVar9[1].prev);
        }
        plVar6 = (list_head_elinks *)((list_head_elinks *)plVar9[4].prev)->next;
        plVar8 = (list_head_elinks *)plVar9[4].prev;
        while (plVar5 = plVar6, plVar8 != (list_head_elinks *)&plVar9[4].prev) {
          pvVar3 = plVar8[2].next;
          if (((plVar9[1].next != pvVar3 && (int)pvVar3 <= (int)plVar9[1].next) ||
              ((int)plVar9[1].prev < (int)pvVar3)) &&
             ((list_head_elinks *)form_controls.next != plVar8)) {
            *(void **)((int)plVar8->next + 4) = plVar8->prev;
            *(void **)plVar8->prev = plVar8->next;
            *(list_head_elinks **)&plVar8->prev = plVar1;
            plVar8->next = form_controls.next;
            *(list_head_elinks **)((int)plVar8->next + 4) = plVar8;
            form_controls.next = plVar8;
          }
          plVar6 = (list_head_elinks *)plVar5->next;
          plVar8 = plVar5;
        }
        plVar9 = (list_head_elinks *)plVar9->next;
      } while (plVar9 != plVar7);
      plVar8 = (list_head_elinks *)((list_head_elinks *)form_controls.next)->next;
      plVar9 = (list_head_elinks *)form_controls.next;
      while (plVar6 = plVar8, plVar9 != plVar1) {
        plVar8 = (list_head_elinks *)(pdVar2->forms).next;
        if (plVar8 == plVar7) {
LAB_0808d99a:
          plVar8 = (list_head_elinks *)plVar6->next;
          plVar9 = plVar6;
        }
        else {
          pvVar3 = plVar9[2].next;
          do {
            if ((plVar8[1].next == pvVar3 || (int)plVar8[1].next < (int)pvVar3) &&
               ((int)pvVar3 <= (int)plVar8[1].prev)) {
              *(list_head_elinks **)&plVar9[1].next = plVar8;
              if ((list_head_elinks *)plVar8[4].prev != plVar9) {
                *(void **)((int)plVar9->next + 4) = plVar9->prev;
                *(void **)plVar9->prev = plVar9->next;
                pvVar3 = plVar8[4].prev;
                *(void ***)&plVar9->prev = &plVar8[4].prev;
                plVar9->next = pvVar3;
                *(list_head_elinks **)&plVar8[4].prev = plVar9;
                *(list_head_elinks **)((int)plVar9->next + 4) = plVar9;
              }
              goto LAB_0808d99a;
            }
            plVar8 = (list_head_elinks *)plVar8->next;
          } while (plVar8 != plVar7);
          plVar8 = (list_head_elinks *)plVar6->next;
          plVar9 = plVar6;
        }
      }
    }
    if ((assert_failed == 0) &&
       (assert_failed = ZEXT14(plVar1 != (list_head_elinks *)form_controls.next),
       plVar1 != (list_head_elinks *)form_controls.next)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x792;
      elinks_internal((uchar *)"assertion list_empty(form_controls) failed!");
      return;
    }
  }
  return;
}



void * html_special(html_context *html_context,html_special_type_conflict c,...)

{
  byte *pbVar1;
  part *ppVar2;
  document *pdVar3;
  form_control *pfVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  tag *ptVar8;
  color_mode color_mode;
  color_flags flags;
  screen_char *psVar9;
  cache_entry *pcVar10;
  document_refresh *pdVar11;
  frameset_desc *pfVar12;
  list_head_elinks *plVar13;
  size_t sVar14;
  tag *ptVar15;
  line *plVar16;
  form *pfVar17;
  void *pvVar18;
  int iVar19;
  list_head_elinks *plVar20;
  bool bVar21;
  form_control *in_stack_0000000c;
  uchar *in_stack_00000010;
  uchar *in_stack_00000014;
  int local_3c;
  color_pair colors;
  
  if (assert_failed != 0) goto LAB_0808da89;
  assert_failed = ZEXT14(html_context == (html_context *)0x0);
  if (html_context == (html_context *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x7b8;
    elinks_internal((uchar *)"assertion html_context failed!");
    if (assert_failed != 0) goto LAB_0808da89;
  }
  ppVar2 = html_context->part;
  assert_failed = ZEXT14(ppVar2 == (part *)0x0);
  if (ppVar2 == (part *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x7bd;
    elinks_internal((uchar *)"assertion part failed!");
    if (assert_failed != 0) goto LAB_0808da89;
  }
  pcVar10 = renderer_context.cached;
  pdVar3 = ppVar2->document;
  switch(c) {
  case SP_TAG:
    if (pdVar3 == (document *)0x0) {
      return (void *)0x0;
    }
    iVar19 = (ppVar2->box).y;
    iVar5 = ppVar2->cy;
    iVar6 = (ppVar2->box).x;
    iVar7 = ppVar2->cx;
    if (assert_failed == 0) {
      assert_failed = 0;
      sVar14 = strlen((char *)in_stack_0000000c);
      ptVar15 = (tag *)mem_alloc(sVar14 + 0x14);
      if (ptVar15 == (tag *)0x0) {
        return (void *)0x0;
      }
      ptVar15->x = iVar7 + iVar6;
      ptVar15->y = iVar5 + iVar19;
      memcpy(ptVar15->name,in_stack_0000000c,sVar14 + 1);
      ptVar8 = (tag *)(pdVar3->tags).next;
      ptVar15->prev = (tag *)&pdVar3->tags;
      ptVar15->next = ptVar8;
      *(tag **)&(pdVar3->tags).next = ptVar15;
      ptVar15->next->prev = ptVar15;
      if ((tag *)&pdVar3->tags != renderer_context.last_tag_for_newline) {
        return (void *)0x0;
      }
      renderer_context.last_tag_for_newline = ptVar15;
      return (void *)0x0;
    }
    goto LAB_0808da89;
  case SP_FORM:
    if (assert_failed == 0) {
      assert_failed = ZEXT14(in_stack_0000000c == (form_control *)0x0);
      if (in_stack_0000000c == (form_control *)0x0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0x6d7;
        elinks_internal((uchar *)"assertion part && form failed!");
        if (assert_failed != 0) goto LAB_0808da89;
      }
      bVar21 = (int)in_stack_0000000c->form < 1;
      assert_failed = ZEXT14(bVar21);
      if (bVar21) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0x6d8;
        elinks_internal((uchar *)"assertion form->form_num > 0 failed!");
        if (assert_failed != 0) goto LAB_0808da89;
      }
      bVar21 = in_stack_0000000c->g_ctrl_num != 0x7fffffff;
      assert_failed = ZEXT14(bVar21);
      if (bVar21) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0x6d9;
        elinks_internal((uchar *)"assertion form->form_end == INT_MAX failed!");
        if (assert_failed != 0) goto LAB_0808da89;
      }
      pdVar3 = ppVar2->document;
      if (pdVar3 != (document *)0x0) {
        plVar13 = (list_head_elinks *)(pdVar3->forms).next;
        plVar20 = &pdVar3->forms;
        if (plVar13 == plVar20) {
          pfVar17 = init_form();
          if (pfVar17 == (form *)0x0) goto LAB_0808e042;
          pfVar17->form_num = 0;
          pfVar17->next = (form *)(ppVar2->document->forms).next;
          pfVar17->prev = (form *)&ppVar2->document->forms;
          *(form **)&(ppVar2->document->forms).next = pfVar17;
          pfVar17->next->prev = pfVar17;
          plVar13 = (list_head_elinks *)(ppVar2->document->forms).next;
          plVar20 = &ppVar2->document->forms;
        }
        if (plVar20 != plVar13) {
          pfVar17 = in_stack_0000000c->form;
          do {
            if (((int)(form *)plVar13[1].next <= (int)pfVar17) &&
               ((int)pfVar17 <= (int)plVar13[1].prev)) {
              if ((form *)plVar13[1].next != pfVar17) {
                pvVar18 = (void *)((int)&pfVar17[-1].items.prev + 3);
                *(void **)&in_stack_0000000c->g_ctrl_num = plVar13[1].prev;
                plVar13[1].prev = pvVar18;
                if ((assert_failed == 0) &&
                   (bVar21 = (int)pvVar18 < (int)plVar13[1].next, assert_failed = ZEXT14(bVar21),
                   bVar21)) {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
                  errline = 0x70f;
                  elinks_internal((uchar *)
                                  "assertion nform->form_num <= nform->form_end failed: [%d:%d] [%d:%d]"
                                  ,plVar13[1].next,plVar13[1].prev,in_stack_0000000c->form,
                                  in_stack_0000000c->g_ctrl_num);
                }
                in_stack_0000000c->next = (form_control *)(ppVar2->document->forms).next;
                in_stack_0000000c->prev = (form_control *)&ppVar2->document->forms;
                *(form_control **)&(ppVar2->document->forms).next = in_stack_0000000c;
                in_stack_0000000c->next->prev = in_stack_0000000c;
                return (void *)0x0;
              }
              goto LAB_0808e042;
            }
            plVar13 = (list_head_elinks *)plVar13->next;
          } while (plVar20 != plVar13);
        }
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0x714;
        elinks_error((uchar *)"hole between forms");
      }
LAB_0808e042:
      done_form((form *)in_stack_0000000c);
      return (void *)0x0;
    }
    goto LAB_0808da89;
  case SP_CONTROL:
    if (assert_failed == 0) {
      assert_failed = ZEXT14(in_stack_0000000c == (form_control *)0x0);
      if (in_stack_0000000c != (form_control *)0x0) {
LAB_0808dc94:
        if (ppVar2->document != (document *)0x0) {
          in_stack_0000000c->g_ctrl_num = renderer_context.g_ctrl_num;
          renderer_context.g_ctrl_num = renderer_context.g_ctrl_num + 1;
          pfVar17 = (form *)(ppVar2->document->forms).next;
          if (pfVar17 == (form *)&ppVar2->document->forms) {
            pfVar17 = init_form();
            pfVar17->form_num = 0;
            pfVar17->next = (form *)(ppVar2->document->forms).next;
            pfVar17->prev = (form *)&ppVar2->document->forms;
            *(form **)&(ppVar2->document->forms).next = pfVar17;
            pfVar17->next->prev = pfVar17;
            pfVar17 = (form *)(ppVar2->document->forms).next;
          }
          in_stack_0000000c->form = pfVar17;
          pfVar4 = (form_control *)(pfVar17->items).next;
          in_stack_0000000c->prev = (form_control *)&pfVar17->items;
          in_stack_0000000c->next = pfVar4;
          *(form_control **)&(pfVar17->items).next = in_stack_0000000c;
          in_stack_0000000c->next->prev = in_stack_0000000c;
          return (void *)0x0;
        }
        done_form_control(in_stack_0000000c);
        mem_free(in_stack_0000000c);
        return (void *)0x0;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x71e;
      elinks_internal((uchar *)"assertion part && fc failed!");
      if (assert_failed == 0) goto LAB_0808dc94;
    }
LAB_0808da89:
    assert_failed = 0;
    pfVar12 = (frameset_desc *)0x0;
    break;
  case SP_TABLE:
    pfVar12 = (frameset_desc *)renderer_context.convert_table;
    break;
  case SP_USED:
    pfVar12 = (frameset_desc *)(uint)(pdVar3 != (document *)0x0);
    break;
  case SP_FRAMESET:
    if ((in_stack_0000000c->next == (form_control *)0x0) &&
       (pdVar3->frame_desc != (frameset_desc *)0x0)) {
      return (void *)0x0;
    }
    pfVar12 = create_frameset((frameset_param *)in_stack_0000000c);
    if ((in_stack_0000000c->next == (form_control *)0x0) &&
       (pdVar3->frame_desc == (frameset_desc *)0x0)) {
      pdVar3->frame_desc = pfVar12;
    }
    break;
  case SP_FRAME:
    add_frameset_entry((frameset_desc *)in_stack_0000000c,(frameset_desc *)0x0,in_stack_00000010,
                       in_stack_00000014);
    pfVar12 = (frameset_desc *)0x0;
    break;
  case SP_NOWRAP:
    renderer_context._48_1_ =
         renderer_context._48_1_ & 0xf7 | (in_stack_0000000c != (form_control *)0x0) << 3;
    pfVar12 = (frameset_desc *)0x0;
    break;
  case SP_CACHE_CONTROL:
    (renderer_context.cached)->cache_mode = CACHE_MODE_NEVER;
    pbVar1 = (byte *)&pcVar10->field_0x5c;
    *pbVar1 = *pbVar1 & 0xfe;
    pfVar12 = (frameset_desc *)0x0;
    break;
  case SP_CACHE_EXPIRES:
    if (in_stack_0000000c == (form_control *)0x0) {
      return (void *)0x0;
    }
    if ((renderer_context.cached)->cache_mode == CACHE_MODE_NEVER) {
      return (void *)0x0;
    }
    timeval_from_seconds(&(renderer_context.cached)->max_age,(long)in_stack_0000000c);
    pbVar1 = (byte *)&pcVar10->field_0x5c;
    *pbVar1 = *pbVar1 | 1;
    pfVar12 = (frameset_desc *)0x0;
    break;
  case SP_REFRESH:
    if (pdVar3 == (document *)0x0) {
      return (void *)0x0;
    }
    if (pdVar3->refresh != (document_refresh *)0x0) {
      done_document_refresh(pdVar3->refresh);
    }
    pdVar11 = init_document_refresh(in_stack_00000010,(ulong)in_stack_0000000c);
    pdVar3->refresh = pdVar11;
    pfVar12 = (frameset_desc *)0x0;
    break;
  case SP_STYLESHEET:
    if (pdVar3 == (document *)0x0) {
      return (void *)0x0;
    }
    add_to_uri_list(&pdVar3->css_imports,(uri *)in_stack_0000000c);
    pfVar12 = (frameset_desc *)0x0;
    break;
  case SP_COLOR_LINK_LINES:
    if (((pdVar3 != (document *)0x0) && ((pdVar3->options).color_mode != COLOR_MODE_MONO)) &&
       ((pdVar3->options).use_document_colors == 2)) {
      pdVar3 = html_context->part->document;
      colors.background = *(color_T *)((int)(html_context->stack).next + 0x94);
      color_mode = (pdVar3->options).color_mode;
      flags = (pdVar3->options).color_flags;
      local_3c = 0;
      if (0 < pdVar3->height) {
        do {
          colors.foreground = 0;
          iVar19 = 0;
          plVar16 = pdVar3->data + local_3c;
          if (0 < plVar16->length) {
            do {
              psVar9 = plVar16->chars;
              set_term_color(psVar9 + iVar19,&colors,flags,color_mode);
              if ((psVar9[iVar19].data == 0x3a) && (colors.foreground == 0)) {
                colors.foreground = *(color_T *)((int)(html_context->stack).next + 0x30);
              }
              iVar19 = iVar19 + 1;
              plVar16 = pdVar3->data + local_3c;
            } while (iVar19 < plVar16->length);
          }
          local_3c = local_3c + 1;
        } while (local_3c < pdVar3->height);
      }
    }
  default:
    return (void *)0x0;
  }
  return pfVar12;
}



void __regparm3 move_links(html_context *html_context,int xf,int yf,int xt,int yt)

{
  int iVar1;
  part *ppVar2;
  bool bVar3;
  tag *ptVar4;
  line *plVar5;
  int *piVar6;
  tag *ptVar7;
  int iVar8;
  uchar *puVar9;
  uchar *puVar10;
  document *pdVar11;
  uint uVar12;
  int iVar13;
  tag *ptVar14;
  uchar *puVar15;
  int local_40;
  int local_38;
  int local_20;
  
  local_40 = renderer_context.last_link_to_move;
  local_38 = renderer_context.last_link_to_move;
  if (assert_failed == 0) {
    assert_failed = ZEXT14(html_context == (html_context *)0x0);
    if (html_context == (html_context *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x270;
      elinks_internal((uchar *)"assertion html_context failed!");
      if (assert_failed != 0) goto LAB_0808e3f8;
    }
    ppVar2 = html_context->part;
    if ((ppVar2 == (part *)0x0) || (ppVar2->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x275;
      elinks_internal((uchar *)"assertion part && part->document failed!");
      if (assert_failed != 0) goto LAB_0808e3f8;
    }
    else {
      assert_failed = 0;
    }
    plVar5 = realloc_lines(ppVar2->document,(int)((&ppVar2->char_width)[2] + yt));
    if (plVar5 != (line *)0x0) {
      pdVar11 = ppVar2->document;
      if (local_40 < pdVar11->nlinks) {
        local_40 = local_40 * 0x34;
        bVar3 = false;
        do {
          iVar8 = (int)&pdVar11->links->accesskey + local_40;
          local_20 = *(int *)(iVar8 + 0x1c);
          if (0 < local_20) {
            uVar12 = 0;
LAB_0808e2f3:
            do {
              if (bVar3) {
                piVar6 = (int *)(*(int *)(iVar8 + 0x18) + uVar12 * 8);
                puVar9 = (uchar *)piVar6[1];
                puVar15 = (&ppVar2->char_width)[2];
                puVar10 = puVar15 + yf;
              }
              else {
                piVar6 = (int *)(*(int *)(iVar8 + 0x18) + uVar12 * 8);
                puVar15 = (&ppVar2->char_width)[2];
                puVar9 = (uchar *)piVar6[1];
                puVar10 = puVar15 + yf;
                if ((int)puVar10 < (int)puVar9) {
                  uVar12 = uVar12 + 1;
                  bVar3 = true;
                  if (local_20 <= (int)uVar12) break;
                  goto LAB_0808e2f3;
                }
              }
              iVar13 = uVar12 * 8;
              if (puVar9 == puVar10) {
                if (*piVar6 < (int)((&ppVar2->char_width)[1] + xf)) {
                  bVar3 = true;
                }
                else {
                  if (yt < 0) {
                    local_20 = ~uVar12 + local_20;
                    if ((assert_failed == 0) &&
                       (assert_failed = -(local_20 >> 0x1f), assert_failed != 0)) {
                      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c"
                      ;
                      errline = 0x2af;
                      elinks_internal((uchar *)"assertion to_move >= 0 failed!");
                    }
                    if (0 < local_20) {
                      iVar1 = uVar12 * 8;
                      uVar12 = uVar12 - 1;
                      memmove((void *)(*(int *)(iVar8 + 0x18) + iVar13),
                              (void *)(*(int *)(iVar8 + 0x18) + 8 + iVar1),local_20 * 8);
                    }
                    local_20 = *(int *)(iVar8 + 0x1c) + -1;
                    *(int *)(iVar8 + 0x1c) = local_20;
                    bVar3 = true;
                  }
                  else {
                    *(uchar **)(piVar6 + 1) = puVar15 + yt;
                    piVar6 = (int *)(iVar13 + *(int *)(iVar8 + 0x18));
                    *piVar6 = *piVar6 + (xt - xf);
                    local_20 = *(int *)(iVar8 + 0x1c);
                    bVar3 = true;
                  }
                }
              }
              uVar12 = uVar12 + 1;
            } while ((int)uVar12 < local_20);
          }
          if (!bVar3) {
            renderer_context.last_link_to_move = local_38;
          }
          local_38 = local_38 + 1;
          pdVar11 = ppVar2->document;
          local_40 = local_40 + 0x34;
        } while (pdVar11->nlinks != local_38 && local_38 <= pdVar11->nlinks);
      }
      if (-1 < yt) {
        bVar3 = false;
        ptVar14 = (tag *)&pdVar11->tags;
        ptVar7 = renderer_context.last_tag_to_move;
        while (ptVar4 = ptVar7->next, ptVar7->next != ptVar14) {
          while( true ) {
            ptVar7 = ptVar4;
            puVar15 = (&ppVar2->char_width)[2] + yf;
            if ((uchar *)ptVar7->y == puVar15) break;
            if ((bVar3) || ((int)puVar15 < (int)(uchar *)ptVar7->y)) goto LAB_0808e488;
            ptVar14 = (tag *)&ppVar2->document->tags;
            ptVar4 = ptVar7->next;
            renderer_context.last_tag_to_move = ptVar7;
            if (ptVar7->next == ptVar14) {
              return;
            }
          }
          if ((int)((&ppVar2->char_width)[1] + xf) <= ptVar7->x) {
            *(uchar **)&ptVar7->y = (&ppVar2->char_width)[2] + yt;
            ptVar7->x = ptVar7->x + (xt - xf);
            ptVar14 = (tag *)&ppVar2->document->tags;
          }
LAB_0808e488:
          bVar3 = true;
        }
      }
    }
  }
  else {
LAB_0808e3f8:
    assert_failed = 0;
  }
  return;
}



void __regparm3 del_chars(html_context *html_context,int x,int y)

{
  part *ppVar1;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(html_context == (html_context *)0x0);
    if (html_context == (html_context *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x324;
      elinks_internal((uchar *)"assertion html_context failed!");
      if (assert_failed != 0) goto LAB_0808e628;
    }
    ppVar1 = html_context->part;
    if (((ppVar1 == (part *)0x0) || (ppVar1->document == (document *)0x0)) ||
       (ppVar1->document->data == (line *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x329;
      elinks_internal((uchar *)"assertion part && part->document && part->document->data failed!");
      if (assert_failed != 0) goto LAB_0808e628;
    }
    else {
      assert_failed = 0;
    }
    ppVar1->document->data[(ppVar1->box).y + y].length = x + (ppVar1->box).x;
    move_links(html_context,x,y,-1,-1);
  }
  else {
LAB_0808e628:
    assert_failed = 0;
  }
  return;
}



void * __regparm3 mem_align_alloc__(void **ptr,size_t old,size_t new,size_t objsize,size_t mask)

{
  void *pvVar1;
  uint uVar2;
  size_t size;
  uint uVar3;
  int iVar4;
  
  uVar2 = mask + new & ~mask;
  uVar3 = mask + old & ~mask;
  if (uVar3 < uVar2) {
    size = uVar2 * objsize;
    pvVar1 = mem_realloc(*ptr,size);
    if (pvVar1 == (void *)0x0) {
      return (void *)0x0;
    }
    iVar4 = uVar3 * objsize;
    *ptr = pvVar1;
    memset((void *)((int)pvVar1 + iVar4),0,size - iVar4);
  }
  return *ptr;
}



int __regparm3 realloc_line(html_context *html_context,document *document,int y,int length)

{
  size_t old;
  line *ptr;
  void *pvVar1;
  screen_char *schar;
  screen_char *psVar2;
  color_pair colors;
  
  ptr = realloc_lines(document,y);
  if (ptr != (line *)0x0) {
    ptr = document->data + y;
    old = ptr->length;
    if (length < (int)old) {
      return old;
    }
    pvVar1 = mem_align_alloc__((void **)ptr,old,length + 1U,8,0xf);
    if (pvVar1 != (void *)0x0) {
      schar = ptr->chars + length;
      schar->data = 0x20;
      schar->attr = '\0';
      colors.background = *(color_T *)((int)(html_context->stack).next + 0x94);
      colors.foreground = 0;
      set_term_color(schar,&colors,COLOR_ENSURE_CONTRAST,(document->options).color_mode);
      psVar2 = ptr->chars + ptr->length;
      while (psVar2 < schar) {
        psVar2->data = schar->data;
        *(undefined4 *)&psVar2->attr = *(undefined4 *)&schar->attr;
        psVar2 = psVar2 + 1;
      }
      ptr->length = length + 1U;
      return old;
    }
  }
  return -1;
}



void draw_frame_hchars(part *part,int x,int y,int width,uchar data,color_T bgcolor,color_T fgcolor,
                      html_context *html_context)

{
  int iVar1;
  int iVar2;
  screen_char *psVar3;
  screen_char *schar;
  bool bVar4;
  int local_30;
  color_pair colors;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(width < 1);
    if (width < 1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x128;
      elinks_internal((uchar *)"assertion width > 0 failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    assert_failed = ZEXT14(html_context == (html_context *)0x0);
    if (html_context == (html_context *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x10b;
      elinks_internal((uchar *)"assertion html_context failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    iVar2 = x + -1 + width;
    if ((((part == (part *)0x0) || (iVar2 < 0)) || (part->document == (document *)0x0)) || (y < 0))
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x10e;
      elinks_internal((uchar *)"assertion part && part->document && x >= 0 && y >= 0 failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    else {
      assert_failed = 0;
    }
    iVar1 = realloc_line(html_context,part->document,y + (part->box).y,(part->box).x + iVar2);
    if (iVar1 < 0) {
      return;
    }
    if (assert_failed == 0) {
      bVar4 = part->document->data == (line *)0x0;
      assert_failed = ZEXT14(bVar4);
      if (bVar4) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0x114;
        elinks_internal((uchar *)"assertion part->document->data failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
      }
      schar = part->document->data[y + (part->box).y].chars + iVar2 + (part->box).x;
      schar->attr = -0x80;
      schar->data = (uint)data;
      colors.background = bgcolor;
      colors.foreground = fgcolor;
      set_term_color(schar,&colors,(part->document->options).color_flags,
                     (part->document->options).color_mode);
      local_30 = width + -1;
      if (local_30 != 0) {
        do {
          iVar2 = (part->box).x + x;
          x = x + 1;
          psVar3 = part->document->data[y + (part->box).y].chars + iVar2;
          psVar3->data = schar->data;
          *(undefined4 *)&psVar3->attr = *(undefined4 *)&schar->attr;
          local_30 = local_30 + -1;
        } while (local_30 != 0);
        return;
      }
      return;
    }
  }
  assert_failed = 0;
  return;
}



void expand_lines(html_context *html_context,part *part,int x,int y,int lines,color_T bgcolor)

{
  int y_00;
  int iVar1;
  
  if (assert_failed == 0) {
    if ((part == (part *)0x0) || (part->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0xb9;
      elinks_internal((uchar *)"assertion part && part->document failed!");
      if (assert_failed != 0) goto LAB_0808eb28;
    }
    else {
      assert_failed = 0;
    }
    if ((((part->document->options).color_mode != COLOR_MODE_MONO) &&
        ((part->document->options).use_document_colors == 2)) &&
       (*(color_T *)((int)(html_context->stack).next + 0x94) = bgcolor, 0 < lines)) {
      iVar1 = 0;
      do {
        y_00 = (part->box).y + y + iVar1;
        iVar1 = iVar1 + 1;
        realloc_line(html_context,part->document,y_00,x + (part->box).x);
      } while (iVar1 < lines);
    }
  }
  else {
LAB_0808eb28:
    assert_failed = 0;
  }
  return;
}



void __regparm3 align_line(html_context *html_context,int y,int last)

{
  part *ppVar1;
  int iVar2;
  size_t old;
  void *__dest;
  int *p;
  int *p_00;
  int iVar3;
  screen_char *psVar4;
  int xt;
  screen_char *schar;
  int iVar5;
  line *plVar6;
  int *piVar7;
  int iVar8;
  document *document;
  int iVar9;
  uint uVar10;
  size_t sVar11;
  int iVar12;
  int iVar13;
  int xt_00;
  bool bVar14;
  uint local_4c;
  int local_44;
  document *local_40;
  int local_38;
  int local_34;
  int local_30;
  color_pair colors;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(html_context == (html_context *)0x0);
  if (html_context == (html_context *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x488;
    elinks_internal((uchar *)"assertion html_context failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  ppVar1 = html_context->part;
  if (((ppVar1 == (part *)0x0) || (ppVar1->document == (document *)0x0)) ||
     (ppVar1->document->data == (line *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x48d;
    elinks_internal((uchar *)"assertion part && part->document && part->document->data failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  iVar2 = ppVar1->document->data[(ppVar1->box).y + y].length - (ppVar1->box).x;
  if (iVar2 < 1) {
    return;
  }
  __dest = (html_context->stack).next;
  iVar3 = *(int *)((int)__dest + 0x74);
  if (iVar3 == 0) {
    return;
  }
  if (iVar3 == 3) {
    if (last != 0) {
      return;
    }
    ppVar1 = html_context->part;
    if (((ppVar1 == (part *)0x0) || (ppVar1->document == (document *)0x0)) ||
       (plVar6 = ppVar1->document->data, plVar6 == (line *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x402;
      elinks_internal((uchar *)"assertion part && part->document && part->document->data failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
      plVar6 = ppVar1->document->data;
    }
    iVar3 = plVar6[(ppVar1->box).y + y].length - (ppVar1->box).x;
    iVar2 = 0;
    if (-1 < iVar3) {
      iVar2 = iVar3;
    }
    assert_failed = ZEXT14(iVar2 < 1);
    if (iVar2 < 1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x406;
      elinks_internal((uchar *)"assertion len > 0 failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    p = (int *)mem_alloc(iVar2 * 8);
    if (p == (int *)0x0) {
      return;
    }
    p_00 = (int *)mem_alloc(iVar2 * 4 + 4);
    if (p_00 == (int *)0x0) {
      mem_free(p);
      return;
    }
    memcpy(p,ppVar1->document->data[(ppVar1->box).y + y].chars + (ppVar1->box).x,iVar2 * 8);
    local_34 = 0;
    local_30 = -1;
    if (*p == 0x20) {
      local_34 = 0;
      do {
        local_30 = local_34;
        local_34 = local_30 + 1;
      } while (p[local_34 * 2] == 0x20);
    }
    *p_00 = local_30;
    if (local_34 < iVar2) {
      iVar3 = 1;
      piVar7 = p + local_34 * 2;
      do {
        if (*piVar7 == 0x20) {
          p_00[iVar3] = local_34;
          iVar3 = iVar3 + 1;
        }
        local_34 = local_34 + 1;
        piVar7 = piVar7 + 2;
      } while (local_34 < iVar2);
      p_00[iVar3] = iVar2;
      iVar5 = *(int *)((int)(html_context->stack).next + 0x80) -
              *(int *)((int)(html_context->stack).next + 0x7c);
      xt_00 = 0;
      if (-1 < iVar5) {
        xt_00 = iVar5;
      }
      if (((0 < xt_00 - iVar2) && (1 < iVar3)) &&
         (iVar5 = realloc_line(html_context,html_context->part->document,(ppVar1->box).y + y,
                               xt_00 + (ppVar1->box).x), iVar5 != 0)) {
        local_44 = 0;
        local_40 = (document *)0x0;
        local_30 = 0;
        do {
          if (assert_failed == 0) {
            iVar5 = p_00[local_30] + 1;
            iVar12 = p_00[local_30 + 1] - iVar5;
            assert_failed = -(iVar12 >> 0x1f);
            if (assert_failed != 0) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
              errline = 0x44a;
              elinks_internal((uchar *)"assertion word_len >= 0 failed!");
              if (assert_failed != 0) goto LAB_0808f428;
            }
            xt = local_44 / (iVar3 + -1) + iVar5;
            local_4c = xt + iVar12;
            iVar9 = ppVar1->document->data[y + (ppVar1->box).y].length - (ppVar1->box).x;
            iVar8 = 0;
            if (-1 < iVar9) {
              iVar8 = iVar9;
            }
            assert_failed = ZEXT14(iVar8 < (int)local_4c);
            if (iVar8 < (int)local_4c) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
              errline = 0x453;
              elinks_internal((uchar *)"assertion LEN(y) >= new_start + word_len failed!");
              if (assert_failed != 0) {
                assert_failed = 0;
                local_4c = (uint)local_40;
                goto LAB_0808f3dd;
              }
            }
            memcpy(ppVar1->document->data[y + (ppVar1->box).y].chars + xt + (ppVar1->box).x,
                   p + iVar5 * 2,iVar12 * 8);
            if (local_30 != 0) {
              if ((int)local_40 < xt) {
                uVar10 = (uint)local_40;
                do {
                  iVar12 = (ppVar1->box).x + uVar10;
                  uVar10 = uVar10 + 1;
                  schar = ppVar1->document->data[y + (ppVar1->box).y].chars + iVar12;
                  schar->data = p[iVar5 * 2 + -2];
                  *(int *)&schar->attr = (p + iVar5 * 2 + -2)[1];
                } while ((int)uVar10 < xt);
              }
              iVar5 = ~(uint)local_40 + xt;
              if (iVar5 != 0) {
                move_links(html_context,(int)local_40 + 1,y,xt,y);
                iVar12 = ppVar1->document->nlinks;
                xt = xt + (ppVar1->box).x;
                iVar8 = y + (ppVar1->box).y;
                iVar9 = (iVar12 + -1) * 0x34;
                while (iVar12 != 0) {
                  iVar12 = iVar12 + -1;
                  iVar13 = (int)&ppVar1->document->links->accesskey + iVar9;
                  old = *(size_t *)(iVar13 + 0x1c);
                  local_38 = old * 8;
                  sVar11 = old;
                  while (local_38 = local_38 + -8, 1 < (int)sVar11) {
                    sVar11 = sVar11 - 1;
                    piVar7 = (int *)(local_38 + *(int *)(iVar13 + 0x18));
                    if ((xt == *piVar7) && (iVar8 == piVar7[1])) {
                      __dest = mem_align_alloc__((void **)(iVar13 + 0x18),old,old + iVar5,8,0);
                      if (__dest != (void *)0x0) {
                        iVar12 = iVar5 + *(int *)(iVar13 + 0x1c);
                        *(int *)(iVar13 + 0x1c) = iVar12;
                        iVar12 = iVar12 * 8 + -8 + *(int *)(iVar13 + 0x18);
                        iVar9 = 0;
                        do {
                          xt = xt + -1;
                          *(int *)(iVar12 + iVar9 * 8) = xt;
                          *(int *)(iVar12 + 4 + iVar9 * 8) = iVar8;
                          iVar9 = iVar9 + -1;
                        } while (iVar9 + iVar5 != 0);
                      }
                      goto LAB_0808f3dd;
                    }
                  }
                  iVar9 = iVar9 + -0x34;
                }
              }
            }
          }
          else {
LAB_0808f428:
            local_4c = (uint)local_40;
            assert_failed = 0;
          }
LAB_0808f3dd:
          local_30 = local_30 + 1;
          local_44 = local_44 + (xt_00 - iVar2);
          if (iVar3 <= local_30) break;
          local_40 = (document *)local_4c;
        } while( true );
      }
    }
    else {
      p_00[1] = iVar2;
    }
    mem_free(p_00);
    mem_free(p);
    return;
  }
  iVar5 = *(int *)((int)__dest + 0x80) - *(int *)((int)__dest + 0x7c);
  xt_00 = 0;
  if (-1 < iVar5) {
    xt_00 = iVar5;
  }
  xt_00 = xt_00 - iVar2;
  if (iVar3 == 1) {
    xt_00 = xt_00 / 2;
  }
  if (xt_00 < 1) {
    return;
  }
  ppVar1 = html_context->part;
  if (((ppVar1 == (part *)0x0) || (ppVar1->document == (document *)0x0)) ||
     (plVar6 = ppVar1->document->data, plVar6 == (line *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x30e;
    elinks_internal((uchar *)"assertion part && part->document && part->document->data failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
    plVar6 = ppVar1->document->data;
  }
  else {
    assert_failed = 0;
  }
  iVar2 = plVar6[(ppVar1->box).y + y].length - (ppVar1->box).x;
  if (iVar2 < 0) {
    iVar2 = 0;
  }
  old = iVar2 << 3;
  __dest = mem_alloc(old);
  if (__dest == (void *)0x0) {
    return;
  }
  memcpy(__dest,ppVar1->document->data[(ppVar1->box).y + y].chars + (ppVar1->box).x,old);
  if (assert_failed == 0) {
    ppVar1 = html_context->part;
    if ((ppVar1 == (part *)0x0) || (document = ppVar1->document, document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0xec;
      elinks_internal((uchar *)"assertion part && part->document && width > 0 failed!");
      if (assert_failed != 0) goto LAB_0808ed00;
      document = ppVar1->document;
    }
    else {
      assert_failed = 0;
    }
    iVar3 = realloc_line(html_context,document,(ppVar1->box).y + y,xt_00 + -1 + (ppVar1->box).x);
    if (-1 < iVar3) {
      if (assert_failed != 0) goto LAB_0808ed00;
      bVar14 = ppVar1->document->data == (line *)0x0;
      assert_failed = ZEXT14(bVar14);
      if (bVar14) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0xf2;
        elinks_internal((uchar *)"assertion part->document->data failed!");
        if (assert_failed != 0) goto LAB_0808ed00;
      }
      psVar4 = ppVar1->document->data[(ppVar1->box).y + y].chars + (ppVar1->box).x;
      schar = psVar4 + xt_00 + -1;
      schar->data = 0x20;
      schar->attr = '\0';
      colors.background = *(color_T *)((int)(html_context->stack).next + 0x94);
      colors.foreground = 0;
      set_term_color(schar,&colors,COLOR_ENSURE_CONTRAST,(ppVar1->document->options).color_mode);
      while (psVar4 < schar) {
        psVar4->data = schar->data;
        *(undefined4 *)&psVar4->attr = *(undefined4 *)&schar->attr;
        psVar4 = psVar4 + 1;
      }
    }
    if (assert_failed == 0) goto LAB_0808ed00;
LAB_0808ed53:
    assert_failed = 0;
  }
  else {
LAB_0808ed00:
    ppVar1 = html_context->part;
    if (((iVar2 < 1) || (ppVar1 == (part *)0x0)) ||
       ((local_40 = ppVar1->document, local_40 == (document *)0x0 || (local_40->data == (line *)0x0)
        ))) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x2e5;
      elinks_internal((uchar *)
                      "assertion width > 0 && part && part->document && part->document->data failed!"
                     );
      if (assert_failed != 0) goto LAB_0808ed53;
      local_40 = ppVar1->document;
    }
    else {
      assert_failed = 0;
    }
    iVar2 = realloc_line(html_context,local_40,y + (ppVar1->box).y,
                         iVar2 + -1 + (ppVar1->box).x + xt_00);
    if (-1 < iVar2) {
      memcpy(ppVar1->document->data[(ppVar1->box).y + y].chars + (ppVar1->box).x + xt_00,__dest,old)
      ;
    }
  }
  mem_free(__dest);
  move_links(html_context,0,y,xt_00,y);
  return;
}



void line_break(html_context *html_context)

{
  uchar *x;
  part *ppVar1;
  document *document;
  size_t __n;
  tag *ptVar2;
  line *plVar3;
  uchar *__s;
  int iVar4;
  int iVar5;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(html_context == (html_context *)0x0);
  if (html_context == (html_context *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x6a3;
    elinks_internal((uchar *)"assertion html_context failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  ppVar1 = html_context->part;
  assert_failed = ZEXT14(ppVar1 == (part *)0x0);
  if (ppVar1 == (part *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x6a8;
    elinks_internal((uchar *)"assertion part failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if ((int)(&ppVar1->char_width)[3] <
      (int)((&ppVar1->char_width)[7] + *(int *)((int)(html_context->stack).next + 0x7c))) {
    (&ppVar1->char_width)[3] =
         (&ppVar1->char_width)[7] + *(int *)((int)(html_context->stack).next + 0x7c);
  }
  if ((renderer_context._48_1_ & 2) != 0) {
    renderer_context._48_1_ = renderer_context._48_1_ & 0xfd;
    (&ppVar1->char_width)[7] = (uchar *)0xffffffff;
    (&ppVar1->char_width)[6] = (uchar *)0x0;
    return;
  }
  document = ppVar1->document;
  if ((document != (document *)0x0) && (document->data != (line *)0x0)) {
    plVar3 = realloc_lines(document,(int)(&ppVar1->char_width)[4] + (int)(&ppVar1->char_width)[8] +
                                    1);
    if (plVar3 == (line *)0x0) {
      return;
    }
    __s = (&ppVar1->char_width)[7];
    if (*(int *)((int)(html_context->stack).next + 0x78) < (int)__s) {
      x = __s + -1;
      plVar3 = ppVar1->document->data +
               (int)((&ppVar1->char_width)[2] + (int)(&ppVar1->char_width)[8]);
      iVar5 = plVar3->length - (int)(&ppVar1->char_width)[1];
      iVar4 = 0;
      if (-1 < iVar5) {
        iVar4 = iVar5;
      }
      if (((int)x < iVar4) && (plVar3->chars[(int)((&ppVar1->char_width)[1] + (int)x)].data == 0x20)
         ) {
        del_chars(html_context,(int)x,(int)(&ppVar1->char_width)[8]);
        __s = (&ppVar1->char_width)[7] + -1;
        (&ppVar1->char_width)[7] = __s;
      }
    }
    ptVar2 = renderer_context.last_tag_for_newline;
    if (0 < (int)__s) {
      align_line(html_context,(int)(&ppVar1->char_width)[8],1);
      ptVar2 = renderer_context.last_tag_for_newline;
    }
    while ((ptVar2 != (tag *)0x0 && ((tag *)&ppVar1->document->tags != ptVar2))) {
      *(uchar **)&ptVar2->x = (&ppVar1->char_width)[1];
      ptVar2->y = (int)(&ppVar1->char_width)[2] + (int)(&ppVar1->char_width)[8] + 1;
      ptVar2 = ptVar2->prev;
    }
  }
  __n = ppVar1->spaces_len;
  (&ppVar1->char_width)[8] = (&ppVar1->char_width)[8] + 1;
  __s = ppVar1->spaces;
  (&ppVar1->char_width)[7] = (uchar *)0xffffffff;
  (&ppVar1->char_width)[6] = (uchar *)0x0;
  memset(__s,0,__n);
  memset(ppVar1->char_width,0,ppVar1->spaces_len);
  return;
}



void free_table_cache(void)

{
  hash *phVar1;
  int iVar2;
  list_head_elinks *plVar3;
  
  if (table_cache != (hash *)0x0) {
    if (0 < 1 << ((byte)table_cache->width & 0x1f)) {
      iVar2 = 0;
      phVar1 = table_cache;
      do {
        plVar3 = (list_head_elinks *)phVar1->hash[iVar2].next;
        if (plVar3 != phVar1->hash + iVar2) {
          do {
            if (plVar3[2].next != (void *)0x0) {
              mem_free(plVar3[2].next);
              phVar1 = table_cache;
            }
            plVar3 = (list_head_elinks *)plVar3->next;
          } while (phVar1->hash + iVar2 != plVar3);
        }
        iVar2 = iVar2 + 1;
      } while (iVar2 < 1 << ((byte)phVar1->width & 0x1f));
    }
    free_hash(&table_cache);
    table_cache_entries = 0;
  }
  return;
}



part * format_html_part(html_context *html_context,uchar *start,uchar *end,int align,int margin,
                       int width,document *document,int x,int y,uchar *head,int link_num)

{
  int iVar1;
  int iVar2;
  int iVar3;
  tag *ptVar4;
  void **ppvVar5;
  void *state;
  hash_item *phVar6;
  uint uVar7;
  void *pvVar8;
  byte bVar9;
  part *part;
  table_cache_entry_key key;
  
  ptVar4 = renderer_context.last_tag_to_move;
  iVar3 = renderer_context.last_link_to_move;
  bVar9 = renderer_context._48_1_ & 1;
  iVar1 = html_context->margin;
  if (table_cache == (hash *)0x0) {
    table_cache = init_hash8();
  }
  else {
    if (document == (document *)0x0) {
      uVar7 = 0;
      do {
        *(undefined4 *)((int)&key.start + uVar7) = 0;
        uVar7 = uVar7 + 4;
      } while (uVar7 < 0x1c);
      key.start = start;
      key.end = end;
      key.align = align;
      key.margin = margin;
      key.width = width;
      key.x = x;
      key.link_num = link_num;
      phVar6 = get_hash_item(table_cache,(uchar *)&key,0x1c);
      if ((phVar6 != (hash_item *)0x0) && (part = (part *)mem_alloc(0x34), part != (part *)0x0)) {
        state = phVar6->value;
        part->document = *(document **)((int)state + 0x24);
        part->spaces = *(uchar **)((int)state + 0x28);
        part->spaces_len = *(int *)((int)state + 0x2c);
        part->char_width = *(uchar **)((int)state + 0x30);
        (part->box).x = *(int *)((int)state + 0x34);
        (part->box).y = *(int *)((int)state + 0x38);
        (part->box).width = *(int *)((int)state + 0x3c);
        (part->box).height = *(int *)((int)state + 0x40);
        part->max_width = *(int *)((int)state + 0x44);
        part->xa = *(int *)((int)state + 0x48);
        part->cx = *(int *)((int)state + 0x4c);
        part->cy = *(int *)((int)state + 0x50);
        part->link_num = *(int *)((int)state + 0x54);
        return part;
      }
    }
  }
  if (assert_failed == 0) {
    assert_failed = -(y >> 0x1f);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x877;
      elinks_internal((uchar *)"assertion y >= 0 failed: format_html_part: y == %d",y);
      if (assert_failed != 0) goto LAB_0808fbf8;
    }
    if (document == (document *)0x0) {
      renderer_context.last_link_to_move = 0;
      renderer_context.last_tag_for_newline = (tag *)0x0;
    }
    else {
      ppvVar5 = (void **)mem_alloc(0x18);
      if (ppvVar5 != (void **)0x0) {
        state = (void *)0x7fffffff;
        if ((html_context->table_level != 0) && (state = (void *)0x0, -1 < width)) {
          state = (void *)width;
        }
        pvVar8 = (void *)x;
        if (x < 0) {
          pvVar8 = (void *)0x0;
        }
        ppvVar5[2] = pvVar8;
        pvVar8 = (void *)0x0;
        if (-1 < y) {
          pvVar8 = (void *)y;
        }
        ppvVar5[4] = state;
        ppvVar5[5] = (void *)0x1;
        ppvVar5[3] = pvVar8;
        state = (document->nodes).next;
        *(list_head_elinks **)(ppvVar5 + 1) = &document->nodes;
        *ppvVar5 = state;
        *(void ***)&(document->nodes).next = ppvVar5;
        *(void ***)((int)*ppvVar5 + 4) = ppvVar5;
      }
      renderer_context.last_link_to_move = document->nlinks;
      renderer_context.last_tag_for_newline = (tag *)&document->tags;
    }
    renderer_context.last_tag_to_move = renderer_context.last_tag_for_newline;
    html_context->margin = margin;
    renderer_context._48_1_ = renderer_context._48_1_ & 0xfe | document == (document *)0x0;
    if (renderer_context.link_state_info.link != (uchar *)0x0) {
      mem_free(renderer_context.link_state_info.link);
    }
    if (renderer_context.link_state_info.target != (uchar *)0x0) {
      mem_free(renderer_context.link_state_info.target);
    }
    if (renderer_context.link_state_info.image != (uchar *)0x0) {
      mem_free(renderer_context.link_state_info.image);
    }
    renderer_context._48_1_ = renderer_context._48_1_ | 2;
    renderer_context.link_state_info.link = (uchar *)0x0;
    renderer_context.link_state_info.target = (uchar *)0x0;
    renderer_context.link_state_info.image = (uchar *)0x0;
    renderer_context.link_state_info.form = (form_control *)0x0;
    part = (part *)mem_calloc(1,0x34);
    if (part != (part *)0x0) {
      part->document = document;
      (part->box).x = x;
      part->cx = -1;
      part->cy = 0;
      (part->box).y = y;
      part->link_num = link_num;
      state = init_html_parser_state(html_context,ELEMENT_IMMORTAL,align,margin,width);
      parse_html(start,end,part,head,html_context);
      done_html_parser_state(html_context,state);
      iVar2 = (part->box).width;
      if (part->max_width < iVar2) {
        part->max_width = iVar2;
      }
      renderer_context._48_1_ = renderer_context._48_1_ & 0xfd;
      if (renderer_context.link_state_info.link != (uchar *)0x0) {
        mem_free(renderer_context.link_state_info.link);
      }
      if (renderer_context.link_state_info.target != (uchar *)0x0) {
        mem_free(renderer_context.link_state_info.target);
      }
      if (renderer_context.link_state_info.image != (uchar *)0x0) {
        mem_free(renderer_context.link_state_info.image);
      }
      renderer_context.link_state_info.link = (uchar *)0x0;
      renderer_context.link_state_info.target = (uchar *)0x0;
      renderer_context.link_state_info.image = (uchar *)0x0;
      renderer_context.link_state_info.form = (form_control *)0x0;
      if (part->spaces != (uchar *)0x0) {
        mem_free(part->spaces);
      }
      if (part->char_width != (uchar *)0x0) {
        mem_free(part->char_width);
      }
      if (document != (document *)0x0) {
        state = (document->nodes).next;
        *(int *)((int)state + 0x14) = (y + (part->box).height) - *(int *)((int)state + 0xc);
      }
    }
    renderer_context._48_1_ = renderer_context._48_1_ & 0xfe | bVar9;
    renderer_context.last_link_to_move = iVar3;
    renderer_context.last_tag_to_move = ptVar4;
    html_context->margin = iVar1;
    if ((((document == (document *)0x0) && (1 < html_context->table_level)) &&
        (table_cache != (hash *)0x0)) &&
       ((table_cache_entries < 0x4000 && (state = mem_calloc(1,0x58), state != (void *)0x0)))) {
      *(uchar **)((int)state + 8) = start;
      *(uchar **)((int)state + 0xc) = end;
      *(int *)((int)state + 0x10) = align;
      *(int *)((int)state + 0x14) = margin;
      *(int *)((int)state + 0x18) = width;
      *(int *)((int)state + 0x1c) = x;
      *(int *)((int)state + 0x20) = link_num;
      *(document **)((int)state + 0x24) = part->document;
      *(uchar **)((int)state + 0x28) = part->spaces;
      *(int *)((int)state + 0x2c) = part->spaces_len;
      *(uchar **)((int)state + 0x30) = part->char_width;
      *(int *)((int)state + 0x34) = (part->box).x;
      *(int *)((int)state + 0x38) = (part->box).y;
      *(int *)((int)state + 0x3c) = (part->box).width;
      *(int *)((int)state + 0x40) = (part->box).height;
      *(int *)((int)state + 0x44) = part->max_width;
      *(int *)((int)state + 0x48) = part->xa;
      *(int *)((int)state + 0x4c) = part->cx;
      *(int *)((int)state + 0x50) = part->cy;
      *(int *)((int)state + 0x54) = part->link_num;
      phVar6 = add_hash_item(table_cache,(uchar *)((int)state + 8),0x1c,state);
      if (phVar6 != (hash_item *)0x0) {
        table_cache_entries = table_cache_entries + 1;
        return part;
      }
      mem_free(state);
    }
  }
  else {
LAB_0808fbf8:
    assert_failed = 0;
    part = (part *)0x0;
  }
  return part;
}



void render_html_document(cache_entry *cached,document *document,string *buffer)

{
  byte *pbVar1;
  uchar *start;
  document_options *pdVar2;
  void *p;
  form *form;
  string *psVar3;
  html_context *html_context;
  uint uVar4;
  part *p_00;
  int iVar5;
  uchar *puVar6;
  int iVar7;
  int iVar8;
  string head;
  string title;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(document == (document *)0x0 || cached == (cache_entry *)0x0);
  if (document == (document *)0x0 || cached == (cache_entry *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x8e4;
    elinks_internal((uchar *)"assertion cached && document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  psVar3 = init_string(&head);
  if (psVar3 != (string *)0x0) {
    if (cached->head != (uchar *)0x0) {
      add_to_string(&head,cached->head);
    }
    start = buffer->source;
    iVar7 = buffer->length;
    html_context = init_html_parser(cached->uri,&document->options,start,start + iVar7,&head,&title,
                                    put_chars_conv,line_break,html_special);
    if (html_context != (html_context *)0x0) {
      renderer_context.cached = cached;
      renderer_context.g_ctrl_num = 0;
      renderer_context.convert_table =
           get_convert_table(head.source,(document->options).cp,(document->options).assume_cp,
                             &document->cp,&document->cp_status,(document->options).hard_assume);
      pdVar2 = html_context->options;
      uVar4 = is_cp_utf8((document->options).cp);
      *(byte *)&pdVar2->field_0x5c = *(byte *)&pdVar2->field_0x5c & 0xef | (byte)((uVar4 & 1) << 4);
      html_context->doc_cp = document->cp;
      if (title.length != 0) {
        puVar6 = convert_string_elinks
                           (renderer_context.convert_table,title.source,title.length,
                            (document->options).cp,CSM_DEFAULT,(int *)0x0,
                            (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
        document->title = puVar6;
      }
      done_string(&title);
      p = (html_context->stack).next;
      p_00 = format_html_part(html_context,start,start + iVar7,*(int *)((int)p + 0x74),
                              *(int *)((int)p + 0x78),(document->options).box.width,document,0,0,
                              head.source,1);
LAB_0808ff72:
      iVar5 = document->height;
      iVar7 = iVar5 * 8 + -8;
      iVar8 = iVar7;
      while ((iVar5 != 0 && (*(int *)((int)&document->data->length + iVar7) == 0))) {
        iVar5 = iVar5 + -1;
        iVar7 = iVar7 + -8;
        document->height = iVar5;
        p = *(void **)((int)&document->data->chars + iVar8);
        iVar8 = iVar8 + -8;
        if (p != (void *)0x0) goto code_r0x0808ffb8;
      }
      document->width = 0;
      if (0 < document->height) {
        iVar7 = 0;
        iVar5 = 0;
        while( true ) {
          iVar8 = document->data[iVar5].length;
          if (iVar7 < iVar8) {
            document->width = iVar8;
          }
          iVar5 = iVar5 + 1;
          if (document->height <= iVar5) break;
          iVar7 = document->width;
        }
      }
      pbVar1 = (byte *)&(document->options).field_0x5c;
      *pbVar1 = *pbVar1 | 2;
      document->bgcolor = *(color_T *)((int)(html_context->stack).next + 0x94);
      done_html_parser(html_context);
      form = (form *)(document->forms).next;
      if ((form *)&document->forms != form) {
        iVar7 = form->form_num;
        while (iVar7 != 0) {
          form = form->next;
          if ((form *)&document->forms == form) goto LAB_0808ffe8;
          iVar7 = form->form_num;
        }
        if ((list_head_elinks *)(form->items).next == &form->items) {
          done_form(form);
        }
      }
LAB_0808ffe8:
      done_string(&head);
      if (p_00 != (part *)0x0) {
        mem_free(p_00);
      }
    }
  }
  return;
code_r0x0808ffb8:
  mem_free(p);
  goto LAB_0808ff72;
}



void draw_frame_vchars(part *part,int x,int y,int height,uchar data,color_T bgcolor,color_T fgcolor,
                      html_context *html_context)

{
  int iVar1;
  screen_char *psVar2;
  screen_char *schar;
  bool bVar3;
  color_pair colors;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(html_context == (html_context *)0x0);
    if (html_context == (html_context *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x10b;
      elinks_internal((uchar *)"assertion html_context failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    if ((((part == (part *)0x0) || (x < 0)) || (part->document == (document *)0x0)) || (y < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x10e;
      elinks_internal((uchar *)"assertion part && part->document && x >= 0 && y >= 0 failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    else {
      assert_failed = 0;
    }
    iVar1 = realloc_line(html_context,part->document,(part->box).y + y,x + (part->box).x);
    if (iVar1 < 0) {
      return;
    }
    if (assert_failed == 0) {
      bVar3 = part->document->data == (line *)0x0;
      assert_failed = ZEXT14(bVar3);
      if (bVar3) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0x114;
        elinks_internal((uchar *)"assertion part->document->data failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
      }
      schar = part->document->data[(part->box).y + y].chars + x + (part->box).x;
      schar->attr = -0x80;
      schar->data = (uint)data;
      colors.background = bgcolor;
      colors.foreground = fgcolor;
      set_term_color(schar,&colors,(part->document->options).color_flags,
                     (part->document->options).color_mode);
      height = height + -1;
      while( true ) {
        if (height == 0) {
          return;
        }
        y = y + 1;
        iVar1 = realloc_line(html_context,part->document,(part->box).y + y,x + (part->box).x);
        if (iVar1 < 0) break;
        psVar2 = part->document->data[(part->box).y + y].chars + x + (part->box).x;
        psVar2->data = schar->data;
        *(undefined4 *)&psVar2->attr = *(undefined4 *)&schar->attr;
        height = height + -1;
      }
      return;
    }
  }
  assert_failed = 0;
  return;
}



int __regparm3 split_line_at(html_context *html_context,int width)

{
  byte bVar1;
  part *ppVar2;
  part *ppVar3;
  screen_char *psVar4;
  part *ppVar5;
  int iVar6;
  int yf;
  int iVar7;
  int yt;
  line *plVar8;
  int iVar9;
  size_t __n;
  int xt;
  bool bVar10;
  document *local_60;
  document *local_50;
  int local_3c;
  int local_38;
  int local_30;
  int local_28;
  line *local_20;
  
  yf = *(int *)((int)(html_context->stack).next + 0x7c);
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  ppVar2 = html_context->part;
  assert_failed = ZEXT14(ppVar2 == (part *)0x0);
  if (ppVar2 == (part *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x344;
    elinks_internal((uchar *)"assertion part failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  yf = width + yf;
  if ((ppVar2->box).width < yf) {
    (ppVar2->box).width = yf;
  }
  if (ppVar2->document == (document *)0x0) {
LAB_08090588:
    bVar1 = *(byte *)&html_context->options->field_0x5c;
joined_r0x0809058f:
    if ((bVar1 & 0x10) != 0) goto LAB_080906c8;
LAB_08090598:
    yf = ppVar2->spaces_len;
LAB_0809059b:
    width = width + 1;
  }
  else {
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
    bVar10 = ppVar2->document->data == (line *)0x0;
    assert_failed = ZEXT14(bVar10);
    if (bVar10) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x34c;
      elinks_internal((uchar *)"assertion part->document->data failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return 0;
      }
    }
    if ((((*(byte *)&html_context->options->field_0x5c & 0x10) != 0) && (width < ppVar2->spaces_len)
        ) && (ppVar2->char_width[width] == '\x02')) {
      yf = ppVar2->cy;
      xt = *(int *)((int)(html_context->stack).next + 0x78);
      ppVar3 = html_context->part;
      if (((ppVar3 == (part *)0x0) || (ppVar3->document == (document *)0x0)) ||
         (plVar8 = ppVar3->document->data, plVar8 == (line *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0x2f8;
        elinks_internal((uchar *)"assertion part && part->document && part->document->data failed!")
        ;
        if (assert_failed == 0) {
          plVar8 = ppVar3->document->data;
          goto LAB_08090455;
        }
        assert_failed = 0;
      }
      else {
        assert_failed = 0;
LAB_08090455:
        iVar7 = (ppVar3->box).x;
        iVar9 = plVar8[yf + (ppVar3->box).y].length - iVar7;
        if (iVar9 < 0) {
          iVar9 = 0;
        }
        iVar9 = iVar9 - width;
        if (0 < iVar9) {
          yt = yf + 1;
          psVar4 = plVar8[yf + (ppVar3->box).y].chars;
          ppVar5 = html_context->part;
          if (((ppVar5 == (part *)0x0) || (local_50 = ppVar5->document, local_50 == (document *)0x0)
              ) || (local_50->data == (line *)0x0)) {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
            errline = 0x2e5;
            elinks_internal((uchar *)
                            "assertion width > 0 && part && part->document && part->document->data failed!"
                           );
            if (assert_failed == 0) {
              local_50 = ppVar5->document;
              goto LAB_080904d0;
            }
            assert_failed = 0;
          }
          else {
            assert_failed = 0;
LAB_080904d0:
            iVar6 = realloc_line(html_context,local_50,yt + (ppVar5->box).y,
                                 iVar9 + -1 + xt + (ppVar5->box).x);
            if (-1 < iVar6) {
              memcpy(ppVar5->document->data[yt + (ppVar5->box).y].chars + xt + (ppVar5->box).x,
                     psVar4 + width + iVar7,iVar9 * 8);
            }
          }
          ppVar3->document->data[yf + (ppVar3->box).y].length = (ppVar3->box).x + width;
          move_links(html_context,width,yf,xt,yt);
        }
      }
      del_chars(html_context,width,ppVar2->cy);
      goto LAB_08090588;
    }
    bVar10 = ppVar2->document->data[ppVar2->cy + (ppVar2->box).y].chars[(ppVar2->box).x + width].
             data != 0x20;
    assert_failed = ZEXT14(bVar10);
    if (bVar10) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x357;
      elinks_internal((uchar *)"assertion POS(width, part->cy).data == \' \' failed: bad split: %c",
                      ppVar2->document->data[ppVar2->cy + (ppVar2->box).y].chars
                      [(ppVar2->box).x + width].data);
      local_28 = ppVar2->cy;
      local_38 = *(int *)((int)(html_context->stack).next + 0x78);
      if (assert_failed == 0) goto LAB_08090730;
LAB_08090a04:
      local_28 = ppVar2->cy;
LAB_08090a0a:
      ppVar3 = html_context->part;
      if (((ppVar3 == (part *)0x0) || (ppVar3->document == (document *)0x0)) ||
         (local_20 = ppVar3->document->data, local_20 == (line *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0x329;
        elinks_internal((uchar *)"assertion part && part->document && part->document->data failed!")
        ;
        if (assert_failed != 0) goto LAB_080908a5;
        local_20 = ppVar3->document->data;
      }
      else {
        assert_failed = 0;
      }
      local_20[local_28 + (ppVar3->box).y].length = (ppVar3->box).x + width;
      move_links(html_context,width,local_28,-1,-1);
      bVar1 = *(byte *)&html_context->options->field_0x5c;
      goto joined_r0x0809058f;
    }
    local_28 = ppVar2->cy;
    local_38 = *(int *)((int)(html_context->stack).next + 0x78);
LAB_08090730:
    local_30 = width + 1;
    local_3c = local_28 + 1;
    ppVar3 = html_context->part;
    if (((ppVar3 == (part *)0x0) || (ppVar3->document == (document *)0x0)) ||
       (plVar8 = ppVar3->document->data, plVar8 == (line *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x2f8;
      elinks_internal((uchar *)"assertion part && part->document && part->document->data failed!");
      if (assert_failed != 0) goto LAB_08090a04;
      plVar8 = ppVar3->document->data;
    }
    yf = (ppVar3->box).x;
    xt = plVar8[local_28 + (ppVar3->box).y].length - yf;
    if (xt < 0) {
      xt = 0;
    }
    xt = xt - local_30;
    if (xt < 1) goto LAB_08090a04;
    psVar4 = plVar8[local_28 + (ppVar3->box).y].chars;
    ppVar5 = html_context->part;
    if (((ppVar5 == (part *)0x0) || (local_60 = ppVar5->document, local_60 == (document *)0x0)) ||
       (local_60->data == (line *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x2e5;
      elinks_internal((uchar *)
                      "assertion width > 0 && part && part->document && part->document->data failed!"
                     );
      if (assert_failed == 0) {
        local_60 = ppVar5->document;
        goto LAB_080907e2;
      }
      assert_failed = 0;
    }
    else {
      assert_failed = 0;
LAB_080907e2:
      iVar7 = realloc_line(html_context,local_60,local_3c + (ppVar5->box).y,
                           local_38 + -1 + (ppVar5->box).x + xt);
      if (-1 < iVar7) {
        memcpy(ppVar5->document->data[local_3c + (ppVar5->box).y].chars + local_38 + (ppVar5->box).x
               ,psVar4 + local_30 + yf,xt * 8);
      }
    }
    ppVar3->document->data[local_28 + (ppVar3->box).y].length = local_30 + (ppVar3->box).x;
    move_links(html_context,local_30,local_28,local_38,local_3c);
    local_28 = ppVar2->cy;
    if (assert_failed == 0) goto LAB_08090a0a;
LAB_080908a5:
    assert_failed = 0;
    if ((*(byte *)&html_context->options->field_0x5c & 0x10) == 0) goto LAB_08090598;
LAB_080906c8:
    yf = ppVar2->spaces_len;
    if ((yf <= width) || (ppVar2->char_width[width] != '\x02')) goto LAB_0809059b;
  }
  __n = yf - width;
  if (0 < (int)__n) {
    memmove(ppVar2->spaces,ppVar2->spaces + width,__n);
    memmove(ppVar2->char_width,ppVar2->char_width + width,__n);
  }
  if (assert_failed == 0) {
    assert_failed = -((int)__n >> 0x1f);
    if (assert_failed == 0) goto LAB_080905fb;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x36e;
    elinks_internal((uchar *)"assertion tmp >= 0 failed!");
    if (assert_failed == 0) goto LAB_080905fb;
  }
  assert_failed = 0;
  __n = 0;
LAB_080905fb:
  memset(ppVar2->spaces + __n,0,width);
  memset(ppVar2->char_width + __n,0,width);
  yf = *(int *)((int)(html_context->stack).next + 0x78);
  if (0 < yf) {
    __n = ppVar2->spaces_len - yf;
    if (assert_failed == 0) {
      assert_failed = ZEXT14((int)__n < 1);
      if ((int)__n < 1) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0x377;
        elinks_internal((uchar *)
                        "assertion tmp > 0 failed: part->spaces_len - par_format.leftmargin == %d",
                        __n);
        yf = *(int *)((int)(html_context->stack).next + 0x78);
      }
      else {
        yf = *(int *)((int)(html_context->stack).next + 0x78);
      }
    }
    memmove(ppVar2->spaces + yf,ppVar2->spaces,__n);
    memmove(ppVar2->char_width + *(int *)((int)(html_context->stack).next + 0x78),ppVar2->char_width
            ,__n);
  }
  xt = ppVar2->cy;
  yf = xt + 1;
  ppVar2->cy = yf;
  if (ppVar2->cx == width) {
    xt = (ppVar2->box).height;
    iVar7 = 2;
    ppVar2->cx = -1;
    if (xt < yf) {
      (ppVar2->box).height = yf;
      return 2;
    }
  }
  else {
    xt = xt + 2;
    iVar7 = 1;
    yf = (ppVar2->box).height;
    ppVar2->cx = (ppVar2->cx + *(int *)((int)(html_context->stack).next + 0x78)) - width;
    if (yf < xt) {
      (ppVar2->box).height = xt;
      return 1;
    }
  }
  return iVar7;
}



// WARNING: Could not reconcile some variable overlaps

void put_chars(html_context *html_context,uchar *chars,int charslen)

{
  byte bVar1;
  part *ppVar2;
  part *ppVar3;
  form_control *pfVar4;
  part *ppVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  int iVar12;
  ushort **ppuVar13;
  uchar *puVar14;
  uchar *src;
  uchar *src_00;
  uint size;
  point *ppVar15;
  unicode_val_T c;
  byte *pbVar16;
  byte *pbVar17;
  uchar *puVar18;
  list_head_elinks *plVar19;
  uchar *str;
  color_T cVar20;
  void **ppvVar21;
  void *pvVar22;
  link *plVar23;
  screen_char *psVar24;
  int iVar25;
  uchar uVar26;
  document_options *options;
  int width;
  byte *end;
  size_t size_00;
  unicode_val_T c_00;
  text_style *ptVar27;
  document *pdVar28;
  char *pcVar29;
  uint uVar30;
  int in_GS_OFFSET;
  bool bVar31;
  byte bVar32;
  int local_9c;
  byte *local_98;
  uchar *local_94;
  byte *local_90;
  int local_8c;
  link *local_84;
  text_style final_style;
  uchar *local_68;
  byte *local_64;
  uchar s [64];
  int local_20;
  
  bVar32 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_90 = chars;
  if (assert_failed != 0) {
LAB_08091010:
    assert_failed = 0;
    goto LAB_0809101a;
  }
  assert_failed = ZEXT14(html_context == (html_context *)0x0);
  if (html_context == (html_context *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x62a;
    elinks_internal((uchar *)"assertion html_context failed!");
    if (assert_failed != 0) goto LAB_08091010;
  }
  ppVar2 = html_context->part;
  assert_failed = ZEXT14(ppVar2 == (part *)0x0);
  if (ppVar2 == (part *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x62f;
    elinks_internal((uchar *)"assertion part failed!");
    if (assert_failed != 0) goto LAB_08091010;
  }
  assert_failed = ZEXT14(charslen == 0 || chars == (uchar *)0x0);
  if (charslen == 0 || chars == (uchar *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x632;
    elinks_internal((uchar *)"assertion chars && charslen failed!");
    if (assert_failed != 0) goto LAB_08091010;
  }
  if (ppVar2->cx == -1) {
    pvVar22 = (html_context->stack).next;
    if ((*(byte *)((int)pvVar22 + 0xc) & 0x20) == 0) {
      if (charslen == 0) goto LAB_0809101a;
      bVar1 = *chars;
      while (bVar1 == 0x20) {
        charslen = charslen + -1;
        if (charslen == 0) goto LAB_0809101a;
        local_90 = local_90 + 1;
        bVar1 = *local_90;
      }
      if (charslen < 1) goto LAB_0809101a;
    }
    ppVar2->cx = *(int *)((int)pvVar22 + 0x78);
    if ((*(byte *)((int)(html_context->stack).next + 0xc) & 0x20) == 0) goto LAB_08091038;
LAB_08090d0f:
    renderer_context.last_tag_for_newline = (tag *)&ppVar2->document->tags;
  }
  else {
    if ((*(byte *)((int)(html_context->stack).next + 0xc) & 0x20) != 0) goto LAB_08090d0f;
LAB_08091038:
    if (0 < charslen) {
      ppuVar13 = __ctype_b_loc();
      iVar12 = 0;
      do {
        if ((*(byte *)((int)*ppuVar13 + (uint)local_90[iVar12] * 2 + 1) & 0x20) == 0)
        goto LAB_08090d0f;
        iVar12 = iVar12 + 1;
      } while (iVar12 < charslen);
    }
  }
  iVar12 = ppVar2->cy + 1;
  if ((ppVar2->box).height < iVar12) {
    (ppVar2->box).height = iVar12;
  }
  pvVar22 = (html_context->stack).next;
  if (((*(uchar **)((int)pvVar22 + 0x1c) == (uchar *)0x0) && (*(int *)((int)pvVar22 + 0x24) == 0))
     && (local_8c = 0, *(int *)((int)pvVar22 + 0x2c) == 0)) {
LAB_08090d69:
    if (renderer_context.link_state_info.link != (uchar *)0x0) {
      mem_free(renderer_context.link_state_info.link);
    }
LAB_08090d7a:
    if (renderer_context.link_state_info.target != (uchar *)0x0) {
      mem_free(renderer_context.link_state_info.target);
    }
    if (renderer_context.link_state_info.image != (uchar *)0x0) {
      mem_free(renderer_context.link_state_info.image);
    }
    bVar31 = local_8c == 1;
    renderer_context.link_state_info.link = (uchar *)0x0;
    renderer_context.link_state_info.target = (uchar *)0x0;
    renderer_context.link_state_info.image = (uchar *)0x0;
    renderer_context.link_state_info.form = (form_control *)0x0;
    if (bVar31) {
      iVar12 = 0;
      if (charslen < 1) {
LAB_080918d5:
        bVar31 = iVar12 == charslen;
        if (bVar31) goto LAB_08090dd1;
      }
      else {
        if (*local_90 < 0x21) {
          do {
            iVar12 = iVar12 + 1;
            if (charslen <= iVar12) break;
          } while (local_90[iVar12] < 0x21);
          goto LAB_080918d5;
        }
      }
      bVar31 = (*(byte *)&html_context->options->field_0x45 & 0x10) == 0;
      if (!bVar31) {
        pvVar22 = (html_context->stack).next;
        ppVar3 = html_context->part;
        uVar9 = *(undefined4 *)((int)pvVar22 + 0x1c);
        uVar10 = *(undefined4 *)((int)pvVar22 + 0x20);
        uVar11 = *(undefined4 *)((int)pvVar22 + 0x24);
        iVar12 = *(int *)((int)pvVar22 + 0x2c);
        *(undefined4 *)((int)pvVar22 + 0x24) = 0;
        *(undefined4 *)((int)pvVar22 + 0x20) = 0;
        *(undefined4 *)((int)pvVar22 + 0x1c) = 0;
        *(undefined4 *)((int)(html_context->stack).next + 0x2c) = 0;
        s[0] = '[';
        local_64 = (byte *)0x1;
        elinks_ulongcat(s,(uint *)&local_64,ppVar3->link_num,'=',0,10);
        renderer_context._48_1_ = renderer_context._48_1_ | 4;
        s[(int)local_64] = ']';
        local_64 = local_64 + 1;
        s[(int)local_64] = '\0';
        put_chars(html_context,s,(int)local_64);
        renderer_context._48_1_ = renderer_context._48_1_ & 0xfb;
        if ((iVar12 != 0) && (*(int *)(iVar12 + 0x14) == 3)) {
          line_break(html_context);
        }
        bVar31 = ppVar3->cx == -1;
        if (bVar31) {
          ppVar3->cx = *(int *)((int)(html_context->stack).next + 0x78);
        }
        *(undefined4 *)((int)(html_context->stack).next + 0x1c) = uVar9;
        *(undefined4 *)((int)(html_context->stack).next + 0x20) = uVar10;
        *(undefined4 *)((int)(html_context->stack).next + 0x24) = uVar11;
        *(int *)((int)(html_context->stack).next + 0x2c) = iVar12;
        pvVar22 = (html_context->stack).next;
        goto LAB_08090dde;
      }
    }
    else {
LAB_08090dd1:
      local_8c = 0;
    }
    pvVar22 = (html_context->stack).next;
  }
  else {
    if (((renderer_context.link_state_info.link == (uchar *)0x0) &&
        (renderer_context.link_state_info.image == (uchar *)0x0)) &&
       (local_8c = 1, renderer_context.link_state_info.form == (form_control *)0x0))
    goto LAB_08090d7a;
    iVar12 = xstrcmp(*(uchar **)((int)pvVar22 + 0x1c),renderer_context.link_state_info.link);
    if (((iVar12 != 0) ||
        (iVar12 = xstrcmp(*(uchar **)((int)(html_context->stack).next + 0x20),
                          renderer_context.link_state_info.target), iVar12 != 0)) ||
       (iVar12 = xstrcmp(*(uchar **)((int)(html_context->stack).next + 0x24),
                         renderer_context.link_state_info.image), iVar12 != 0)) {
LAB_08090d5f:
      local_8c = 1;
      goto LAB_08090d69;
    }
    pvVar22 = (html_context->stack).next;
    bVar31 = *(form_control **)((int)pvVar22 + 0x2c) == renderer_context.link_state_info.form;
    local_8c = 2;
    if (!bVar31) goto LAB_08090d5f;
  }
LAB_08090dde:
  local_64 = local_90;
  ppVar3 = html_context->part;
  iVar12 = 0xc;
  ptVar27 = &ta_cache;
  pcVar29 = (char *)((int)pvVar22 + 0xc);
  do {
    if (iVar12 == 0) break;
    iVar12 = iVar12 + -1;
    bVar31 = *(char *)&ptVar27->attr == *pcVar29;
    ptVar27 = (text_style *)((int)ptVar27 + (uint)bVar32 * -2 + 1);
    pcVar29 = pcVar29 + (uint)bVar32 * -2 + 1;
  } while (bVar31);
  if (!bVar31) {
    ta_cache.attr = *(text_style_format *)((int)pvVar22 + 0xc);
    ta_cache.fg = *(color_T *)((int)pvVar22 + 0x10);
    ta_cache.bg = *(color_T *)((int)pvVar22 + 0x14);
    pvVar22 = (html_context->stack).next;
    size = *(uint *)((int)pvVar22 + 0xc);
    if (local_8c == 0) {
      options = html_context->options;
    }
    else {
      options = html_context->options;
      if ((*(byte *)&options->field_0x45 & 1) != 0) {
        size = size | 4;
      }
    }
    get_screen_char_template
              (&schar_cache,options,
               (text_style)
               CONCAT48(*(undefined4 *)((int)pvVar22 + 0x14),
                        CONCAT44(*(undefined4 *)((int)pvVar22 + 0x10),size)));
  }
  if ((renderer_context._48_1_ >> 2 & 1) != ((byte)schar_cache._4_4_ & 1)) {
    schar_cache._4_4_ = schar_cache._4_4_ ^ 1;
  }
  puVar18 = (&ppVar3->char_width)[7];
  str = (&ppVar3->char_width)[8];
  bVar32 = *(byte *)&html_context->options->field_0x5c;
  if (assert_failed == 0) {
    assert_failed = -(charslen >> 0x1f);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x177;
      elinks_internal((uchar *)"assertion charslen >= 0 failed!");
    }
    bVar32 = bVar32 >> 4 & 1;
    local_98 = puVar18 + charslen;
    if ((int)local_98 < ppVar3->spaces_len) {
LAB_08090eec:
      if (ppVar3->document == (document *)0x0) {
        if (bVar32 == 0) {
          iVar12 = charslen;
          if (0 < charslen) {
            while( true ) {
              ppVar3->char_width[(int)puVar18] = '\x01';
              if (*local_64 == 1) {
                ppVar3->spaces[(int)puVar18] = *(byte *)&html_context->options->field_0x45 >> 1 & 1;
              }
              else {
                *(bool *)(ppVar3->spaces + (int)puVar18) = *local_64 == 0x20;
              }
              local_64 = local_64 + 1;
              if (iVar12 + -1 == 0) break;
              puVar18 = puVar18 + 1;
              iVar12 = iVar12 + -1;
            }
          }
          local_94 = (uchar *)charslen;
        }
        else {
          end = local_64 + charslen;
          local_94 = puVar18;
          while (local_64 < end) {
            c = utf8_to_unicode(&local_64,end);
            if (c != 0xad) {
              if (c == 0xa0) {
                bVar32 = *(byte *)&html_context->options->field_0x45 & 2;
                bVar31 = (bool)('\x01' - (bVar32 == 0));
                c_00 = 0x20;
                if (bVar32 == 0) {
                  c_00 = c;
                }
              }
              else {
                bVar31 = c == 0x20;
                c_00 = c;
              }
              *(bool *)(ppVar3->spaces + (int)local_94) = bVar31;
              str = ppVar3->char_width;
              iVar12 = unicode_to_cell(c_00);
              str[(int)local_94] = (uchar)iVar12;
              if (ppVar3->char_width[(int)local_94] == '\x02') {
                local_94 = local_94 + 1;
                ppVar3->spaces[(int)local_94] = '\0';
                ppVar3->char_width[(int)local_94] = '\0';
              }
              if (c_00 == 0xfffffffd) break;
              local_94 = local_94 + 1;
            }
          }
          local_94 = local_94 + -(int)puVar18;
        }
      }
      else {
        src_00 = (uchar *)realloc_line(html_context,ppVar3->document,
                                       (int)((&ppVar3->char_width)[2] + (int)str),
                                       (int)puVar18 + (int)(&ppVar3->char_width)[1] + charslen);
        if ((int)src_00 < 0) goto LAB_08091e30;
        if (bVar32 == 0) {
          src = puVar18;
          iVar12 = charslen;
          if (0 < charslen) {
            do {
              ppVar3->char_width[(int)src] = '\x01';
              if (*local_64 == 1) {
                schar_cache.data = 0x20;
                ppVar3->spaces[(int)src] = *(byte *)&html_context->options->field_0x45 >> 1 & 1;
              }
              else {
                *(bool *)(ppVar3->spaces + (int)src) = *local_64 == 0x20;
                schar_cache.data = (unicode_val_T)*local_64;
              }
              iVar12 = iVar12 + -1;
              psVar24 = ppVar3->document->data[(int)((&ppVar3->char_width)[2] + (int)str)].chars +
                        (int)(src + (int)(&ppVar3->char_width)[1]);
              psVar24->data = schar_cache.data;
              *(uint *)&psVar24->attr = schar_cache._4_4_;
              local_64 = local_64 + 1;
              src = src + 1;
            } while (0 < iVar12);
            goto LAB_08091d43;
          }
          local_94 = (uchar *)0x0;
          local_98 = puVar18;
        }
        else {
          end = local_64 + charslen;
          local_98 = puVar18;
          if (ppVar3->document->buf_length != '\0') {
            iVar12 = utf8charlen(ppVar3->document->buf);
            local_68 = ppVar3->document->buf;
            pdVar28 = ppVar3->document;
            bVar32 = pdVar28->buf_length;
            size = (uint)bVar32;
            if (((int)size < iVar12) && (local_64 < end)) {
              while( true ) {
                bVar1 = *local_64;
                bVar32 = bVar32 + 1;
                local_64 = local_64 + 1;
                pdVar28->buf[size] = bVar1;
                size = (uint)bVar32;
                if ((iVar12 <= (int)size) || (end <= local_64)) break;
                pdVar28 = ppVar3->document;
              }
              pdVar28 = ppVar3->document;
            }
            pdVar28->buf_length = bVar32;
            ppVar3->document->buf[size] = '\0';
            c = utf8_to_unicode(&local_68,local_68 + bVar32);
            if (c != 0xfffffffd) {
              ppVar3->document->buf_length = '\0';
              goto good_char;
            }
            *(uchar **)&ppVar3->document->data[(int)((&ppVar3->char_width)[2] + (int)str)].length =
                 src_00;
            local_94 = (uchar *)0x0;
            goto LAB_0809108b;
          }
          while (local_64 < end) {
LAB_08091c26:
            c = utf8_to_unicode(&local_64,end);
            if (c == 0xfffffffd) {
              ppVar3->spaces[(int)local_98] = '\0';
              if (charslen == 1) goto LAB_0809256f;
              uVar26 = '\0';
              pbVar16 = local_64;
              if (local_64 < end) {
                do {
                  pbVar17 = pbVar16 + 1;
                  ppVar3->document->buf[(byte)((char)pbVar16 - (char)local_64)] = *pbVar16;
                  pbVar16 = pbVar17;
                } while (pbVar17 < end);
                local_9c._0_1_ = (char)end;
                uVar26 = (char)local_9c - (char)local_64;
                local_64 = pbVar17;
              }
              ppVar3->document->buf_length = uVar26;
              local_94 = local_98 + -(int)puVar18;
              goto LAB_08091cc9;
            }
good_char:
            if (c != 0xad) {
              if (c == 0xa0) {
                bVar32 = *(byte *)&html_context->options->field_0x45 & 2;
                bVar31 = (bool)('\x01' - (bVar32 == 0));
                if (bVar32 != 0) {
                  c = 0x20;
                }
              }
              else {
                bVar31 = c == 0x20;
              }
              *(bool *)(ppVar3->spaces + (int)local_98) = bVar31;
              iVar12 = unicode_to_cell(c);
              if (iVar12 == 2) {
                schar_cache.data = c;
                ppVar3->char_width[(int)local_98] = '\x02';
                src = local_98 + (int)(&ppVar3->char_width)[1];
                local_98 = local_98 + 1;
                psVar24 = ppVar3->document->data[(int)((&ppVar3->char_width)[2] + (int)str)].chars +
                          (int)src;
                psVar24->data = schar_cache.data;
                *(uint *)&psVar24->attr = schar_cache._4_4_;
                schar_cache.data = 0xfffffffd;
                ppVar3->spaces[(int)local_98] = '\0';
                ppVar3->char_width[(int)local_98] = '\0';
              }
              else {
                src = ppVar3->char_width;
                iVar12 = unicode_to_cell(c);
                src[(int)local_98] = (uchar)iVar12;
                schar_cache.data = c;
              }
              psVar24 = ppVar3->document->data[(int)((&ppVar3->char_width)[2] + (int)str)].chars +
                        (int)((&ppVar3->char_width)[1] + (int)local_98);
              local_98 = local_98 + 1;
              psVar24->data = schar_cache.data;
              *(uint *)&psVar24->attr = schar_cache._4_4_;
            }
          }
LAB_08091d43:
          local_94 = local_98 + -(int)puVar18;
        }
LAB_08091cc9:
        if ((assert_failed == 0) &&
           (bVar31 = ppVar3->document->data[(int)((&ppVar3->char_width)[2] + (int)str)].length <
                     (int)((&ppVar3->char_width)[1] + (int)local_98), assert_failed = ZEXT14(bVar31)
           , bVar31)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
          errline = 0x206;
          elinks_internal((uchar *)"assertion X(x) <= LINE(y).length failed!");
        }
        puVar18 = (&ppVar3->char_width)[1] + (int)local_98;
        if ((int)((&ppVar3->char_width)[1] + (int)local_98) < (int)src_00) {
          puVar18 = src_00;
        }
        *(uchar **)&ppVar3->document->data[(int)((&ppVar3->char_width)[2] + (int)str)].length =
             puVar18;
      }
    }
    else {
      size = (uint)(local_98 + 0x7f) & 0xffffff80;
      uVar30 = ppVar3->spaces_len + 0x7fU & 0xffffff80;
      if (uVar30 < size) {
        src_00 = (uchar *)mem_realloc(ppVar3->spaces,size);
        if (src_00 != (uchar *)0x0) {
          ppVar3->spaces = src_00;
          memset(src_00 + uVar30,0,size - uVar30);
          goto LAB_08091a66;
        }
      }
      else {
LAB_08091a66:
        if (ppVar3->spaces != (uchar *)0x0) {
          uVar30 = ppVar3->spaces_len + 0x7fU & 0xffffff80;
          if (uVar30 < size) {
            src_00 = (uchar *)mem_realloc(ppVar3->char_width,size);
            if (src_00 == (uchar *)0x0) goto LAB_08091e30;
            ppVar3->char_width = src_00;
            memset(src_00 + uVar30,0,size - uVar30);
          }
          if (ppVar3->char_width != (uchar *)0x0) {
            *(byte **)&ppVar3->spaces_len = local_98;
            goto LAB_08090eec;
          }
        }
      }
LAB_08091e30:
      local_94 = (uchar *)0x0;
    }
  }
  else {
    assert_failed = 0;
    local_94 = (uchar *)charslen;
  }
LAB_0809108b:
  if (local_8c != 0) {
    ppVar3 = html_context->part;
    puVar18 = local_94;
    if (local_8c == 2) {
      if (ppVar3->document != (document *)0x0) {
        if (assert_failed != 0) goto LAB_08091318;
        bVar31 = ppVar3->document->nlinks < 1;
        assert_failed = ZEXT14(bVar31);
        if (bVar31) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
          errline = 0x5a6;
          elinks_internal((uchar *)"assertion part->document->nlinks > 0 failed: no link");
          if (assert_failed != 0) goto LAB_08091318;
        }
        local_84 = ppVar3->document->links + ppVar3->document->nlinks + -1;
        if (((local_84->type < LINK_BUTTON) && (str = (uchar *)local_84->data, str != (uchar *)0x0))
           && (src_00 = straconcat(str,local_90,0), src_00 != (uchar *)0x0)) {
          mem_free(str);
          *(uchar **)&local_84->data = src_00;
          iVar12 = 0;
        }
        else {
          iVar12 = 0;
        }
LAB_08091673:
        str = (uchar *)local_84->npoints;
        if (str < puVar18 + (int)str) {
          size_00 = (int)(puVar18 + (int)str) * 8;
          ppVar15 = (point *)mem_realloc(local_84->points,size_00);
          if (ppVar15 == (point *)0x0) goto LAB_08091322;
          local_84->points = ppVar15;
          memset(ppVar15 + (int)str,0,size_00 + (int)str * -8);
        }
        if (local_84->points != (point *)0x0) {
          width = local_84->npoints;
          iVar25 = (ppVar3->box).x;
          iVar6 = ppVar3->cx;
          iVar7 = ppVar3->cy;
          iVar8 = (ppVar3->box).y;
          *(uchar **)&local_84->npoints = puVar18 + width;
          if (0 < (int)puVar18) {
            ppVar15 = local_84->points + width;
            iVar12 = iVar6 + iVar25 + iVar12;
            do {
              ppVar15->x = iVar12;
              iVar12 = iVar12 + 1;
              ppVar15->y = iVar7 + iVar8;
              ppVar15 = ppVar15 + 1;
              puVar18 = puVar18 + -1;
            } while (puVar18 != (uchar *)0x0);
          }
        }
      }
    }
    else {
      ppVar3->link_num = ppVar3->link_num + 1;
      pvVar22 = (html_context->stack).next;
      pfVar4 = *(form_control **)((int)pvVar22 + 0x2c);
      str = *(uchar **)((int)pvVar22 + 0x24);
      src_00 = *(uchar **)((int)pvVar22 + 0x20);
      src = *(uchar **)((int)pvVar22 + 0x1c);
      if (assert_failed == 0) {
        assert_failed = ZEXT14(renderer_context.link_state_info.image != (uchar *)0x0);
        if (renderer_context.link_state_info.image != (uchar *)0x0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
          errline = 0x57e;
          elinks_internal((uchar *)
                          "assertion !(renderer_context.link_state_info.image) failed: Old link value [%s]. New value [%s]"
                          ,renderer_context.link_state_info.image,str);
          if (assert_failed != 0) goto LAB_080910df;
        }
        assert_failed = ZEXT14(renderer_context.link_state_info.target != (uchar *)0x0);
        if (renderer_context.link_state_info.target != (uchar *)0x0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
          errline = 0x57f;
          elinks_internal((uchar *)
                          "assertion !(renderer_context.link_state_info.target) failed: Old link value [%s]. New value [%s]"
                          ,renderer_context.link_state_info.target,src_00);
          if (assert_failed != 0) goto LAB_080910df;
        }
        assert_failed = ZEXT14(renderer_context.link_state_info.link != (uchar *)0x0);
        if (renderer_context.link_state_info.link != (uchar *)0x0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
          errline = 0x580;
          elinks_internal((uchar *)
                          "assertion !(renderer_context.link_state_info.link) failed: Old link value [%s]. New value [%s]"
                          ,renderer_context.link_state_info.link,src);
        }
      }
LAB_080910df:
      puVar14 = (uchar *)0x0;
      if (src != (uchar *)0x0) {
        puVar14 = stracpy(src);
      }
      src = (uchar *)0x0;
      renderer_context.link_state_info.link = puVar14;
      if (src_00 != (uchar *)0x0) {
        src = stracpy(src_00);
      }
      src_00 = (uchar *)0x0;
      renderer_context.link_state_info.target = src;
      if (str != (uchar *)0x0) {
        src_00 = stracpy(str);
      }
      renderer_context.link_state_info.image = src_00;
      renderer_context.link_state_info.form = pfVar4;
      if (ppVar3->document != (document *)0x0) {
        if ((charslen < 1) || (0x20 < *local_90)) {
          iVar12 = 0;
          local_9c = charslen;
          local_98 = local_90;
        }
        else {
          iVar12 = 0;
          do {
            iVar12 = iVar12 + 1;
            if (charslen <= iVar12) break;
          } while (local_90[iVar12] < 0x21);
          if (iVar12 == 0) {
            local_9c = charslen;
            local_98 = local_90;
          }
          else {
            local_9c = charslen - iVar12;
            local_98 = local_90 + iVar12;
            puVar18 = local_94 + -iVar12;
          }
        }
        if (assert_failed == 0) {
          ppVar5 = html_context->part;
          assert_failed = ZEXT14(ppVar5 == (part *)0x0);
          if (ppVar5 == (part *)0x0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
            errline = 0x4cf;
            elinks_internal((uchar *)"assertion part failed!");
            if (assert_failed != 0) goto LAB_08091318;
          }
          pdVar28 = ppVar5->document;
          assert_failed = ZEXT14(pdVar28 == (document *)0x0);
          if (pdVar28 == (document *)0x0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
            errline = 0x4d4;
            elinks_internal((uchar *)"assertion document failed!");
            if (assert_failed != 0) goto LAB_08091318;
          }
          width = ppVar5->link_num;
          size = pdVar28->nlinks + 0x80U & 0xffffff80;
          uVar30 = pdVar28->nlinks + 0x7fU & 0xffffff80;
          if (uVar30 < size) {
            size_00 = size * 0x34;
            plVar23 = (link *)mem_realloc(pdVar28->links,size_00);
            if (plVar23 == (link *)0x0) goto LAB_08091322;
            pdVar28->links = plVar23;
            memset(plVar23 + uVar30,0,size_00 + uVar30 * -0x34);
          }
          if (pdVar28->links != (link *)0x0) {
            local_84 = pdVar28->links + pdVar28->nlinks;
            pdVar28->nlinks = pdVar28->nlinks + 1;
            width = width + -1;
            local_84->number = width;
            if ((*(byte *)&(pdVar28->options).field_0x45 & 0x20) != 0) {
              local_84->number = width + *(int *)((int)(html_context->stack).next + 0x50);
            }
            local_84->accesskey = *(unicode_val_T *)((int)(html_context->stack).next + 0x54);
            str = *(uchar **)((int)(html_context->stack).next + 0x28);
            src_00 = (uchar *)0x0;
            if (str != (uchar *)0x0) {
              src_00 = stracpy(str);
            }
            local_84->title = src_00;
            str = *(uchar **)((int)(html_context->stack).next + 0x24);
            src_00 = (uchar *)0x0;
            if (str != (uchar *)0x0) {
              src_00 = stracpy(str);
            }
            local_84->where_img = src_00;
            pvVar22 = (html_context->stack).next;
            width = *(int *)((int)pvVar22 + 0x2c);
            if (width == 0) {
              str = *(uchar **)((int)pvVar22 + 0x20);
              src_00 = (uchar *)0x0;
              if (str != (uchar *)0x0) {
                src_00 = stracpy(str);
              }
              local_84->target = src_00;
              str = memacpy(local_98,local_9c);
              *(uchar **)&local_84->data = str;
              end = *(byte **)((int)(html_context->stack).next + 0x1c);
              if (((end == (byte *)0x0) || ((*end | 0x20) != 0x6d)) ||
                 (((end[1] | 0x20) != 0x61 ||
                  ((((end[2] | 0x20) != 0x70 || (end[3] != 0x40)) || (end[4] == 0)))))) {
                local_84->type = LINK_HYPERTEXT;
                str = *(uchar **)((int)(html_context->stack).next + 0x1c);
                src_00 = (uchar *)0x0;
                if (str != (uchar *)0x0) {
                  src_00 = stracpy(str);
                }
                local_84->where = src_00;
              }
              else {
                local_84->type = LINK_MAP;
                str = stracpy((uchar *)(*(int *)((int)(html_context->stack).next + 0x1c) + 4));
                local_84->where = str;
              }
            }
            else {
              if (*(uint *)(width + 0x14) < 0xc) {
                switch(*(undefined4 *)(width + 0x14)) {
                case 0:
                case 1:
                case 2:
                  local_84->type = LINK_FIELD;
                  break;
                case 3:
                  local_84->type = LINK_AREA;
                  break;
                case 4:
                case 5:
                  local_84->type = LINK_CHECKBOX;
                  break;
                case 6:
                  local_84->type = LINK_SELECT;
                  break;
                default:
                  local_84->type = LINK_BUTTON;
                }
              }
              local_84->data = width;
              plVar19 = *(list_head_elinks **)(width + 8);
              if (((plVar19 == (list_head_elinks *)0x0) &&
                  ((plVar19 = (list_head_elinks *)(pdVar28->forms).next, plVar19 == &pdVar28->forms
                   || (plVar19 == (list_head_elinks *)0x0)))) ||
                 ((uchar *)plVar19[3].prev == (uchar *)0x0)) {
                str = (uchar *)0x0;
              }
              else {
                str = stracpy((uchar *)plVar19[3].prev);
              }
              local_84->target = str;
            }
            (local_84->color).background = *(color_T *)((int)(html_context->stack).next + 0x14);
            if (local_84->type + ~LINK_SELECT < 2) {
              cVar20 = *(color_T *)((int)(html_context->stack).next + 0x10);
            }
            else {
              cVar20 = *(color_T *)((int)(html_context->stack).next + 0x30);
            }
            (local_84->color).foreground = cVar20;
            plVar19 = (list_head_elinks *)mem_calloc(1,8);
            local_84->event_hooks = plVar19;
            if (plVar19 != (list_head_elinks *)0x0) {
              *(list_head_elinks **)&plVar19->prev = plVar19;
              *(list_head_elinks **)&plVar19->next = plVar19;
              pvVar22 = (html_context->stack).next;
              if (*(int *)((int)pvVar22 + 0x58) != 0) {
                ppvVar21 = (void **)mem_calloc(1,0x10);
                if (ppvVar21 == (void **)0x0) {
                  pvVar22 = (html_context->stack).next;
                }
                else {
                  ppvVar21[2] = (void *)0x0;
                  str = stracpy(*(uchar **)((int)(html_context->stack).next + 0x58));
                  *(uchar **)(ppvVar21 + 3) = str;
                  *ppvVar21 = local_84->event_hooks->next;
                  *(list_head_elinks **)(ppvVar21 + 1) = local_84->event_hooks;
                  *(void ***)&local_84->event_hooks->next = ppvVar21;
                  *(void ***)((int)*ppvVar21 + 4) = ppvVar21;
                  pvVar22 = (html_context->stack).next;
                }
              }
              if (*(int *)((int)pvVar22 + 0x5c) != 0) {
                ppvVar21 = (void **)mem_calloc(1,0x10);
                if (ppvVar21 == (void **)0x0) {
                  pvVar22 = (html_context->stack).next;
                }
                else {
                  ppvVar21[2] = (void *)0x1;
                  str = stracpy(*(uchar **)((int)(html_context->stack).next + 0x5c));
                  *(uchar **)(ppvVar21 + 3) = str;
                  *ppvVar21 = local_84->event_hooks->next;
                  *(list_head_elinks **)(ppvVar21 + 1) = local_84->event_hooks;
                  *(void ***)&local_84->event_hooks->next = ppvVar21;
                  *(void ***)((int)*ppvVar21 + 4) = ppvVar21;
                  pvVar22 = (html_context->stack).next;
                }
              }
              if (*(int *)((int)pvVar22 + 0x60) != 0) {
                ppvVar21 = (void **)mem_calloc(1,0x10);
                if (ppvVar21 == (void **)0x0) {
                  pvVar22 = (html_context->stack).next;
                }
                else {
                  ppvVar21[2] = (void *)0x2;
                  str = stracpy(*(uchar **)((int)(html_context->stack).next + 0x60));
                  *(uchar **)(ppvVar21 + 3) = str;
                  *ppvVar21 = local_84->event_hooks->next;
                  *(list_head_elinks **)(ppvVar21 + 1) = local_84->event_hooks;
                  *(void ***)&local_84->event_hooks->next = ppvVar21;
                  *(void ***)((int)*ppvVar21 + 4) = ppvVar21;
                  pvVar22 = (html_context->stack).next;
                }
              }
              if (*(int *)((int)pvVar22 + 100) != 0) {
                ppvVar21 = (void **)mem_calloc(1,0x10);
                if (ppvVar21 == (void **)0x0) {
                  pvVar22 = (html_context->stack).next;
                }
                else {
                  ppvVar21[2] = (void *)0x3;
                  str = stracpy(*(uchar **)((int)(html_context->stack).next + 100));
                  *(uchar **)(ppvVar21 + 3) = str;
                  *ppvVar21 = local_84->event_hooks->next;
                  *(list_head_elinks **)(ppvVar21 + 1) = local_84->event_hooks;
                  *(void ***)&local_84->event_hooks->next = ppvVar21;
                  *(void ***)((int)*ppvVar21 + 4) = ppvVar21;
                  pvVar22 = (html_context->stack).next;
                }
              }
              if (*(int *)((int)pvVar22 + 0x68) != 0) {
                ppvVar21 = (void **)mem_calloc(1,0x10);
                if (ppvVar21 == (void **)0x0) {
                  pvVar22 = (html_context->stack).next;
                }
                else {
                  ppvVar21[2] = (void *)0x4;
                  str = stracpy(*(uchar **)((int)(html_context->stack).next + 0x68));
                  *(uchar **)(ppvVar21 + 3) = str;
                  *ppvVar21 = local_84->event_hooks->next;
                  *(list_head_elinks **)(ppvVar21 + 1) = local_84->event_hooks;
                  *(void ***)&local_84->event_hooks->next = ppvVar21;
                  *(void ***)((int)*ppvVar21 + 4) = ppvVar21;
                  pvVar22 = (html_context->stack).next;
                }
              }
              if (*(int *)((int)pvVar22 + 0x6c) != 0) {
                ppvVar21 = (void **)mem_calloc(1,0x10);
                if (ppvVar21 == (void **)0x0) {
                  pvVar22 = (html_context->stack).next;
                }
                else {
                  ppvVar21[2] = (void *)0x5;
                  str = stracpy(*(uchar **)((int)(html_context->stack).next + 0x6c));
                  *(uchar **)(ppvVar21 + 3) = str;
                  *ppvVar21 = local_84->event_hooks->next;
                  *(list_head_elinks **)(ppvVar21 + 1) = local_84->event_hooks;
                  *(void ***)&local_84->event_hooks->next = ppvVar21;
                  *(void ***)((int)*ppvVar21 + 4) = ppvVar21;
                  pvVar22 = (html_context->stack).next;
                }
              }
              if ((*(int *)((int)pvVar22 + 0x70) != 0) &&
                 (ppvVar21 = (void **)mem_calloc(1,0x10), ppvVar21 != (void **)0x0)) {
                ppvVar21[2] = (void *)0x6;
                str = stracpy(*(uchar **)((int)(html_context->stack).next + 0x70));
                *(uchar **)(ppvVar21 + 3) = str;
                *ppvVar21 = local_84->event_hooks->next;
                *(list_head_elinks **)(ppvVar21 + 1) = local_84->event_hooks;
                *(void ***)&local_84->event_hooks->next = ppvVar21;
                *(void ***)((int)*ppvVar21 + 4) = ppvVar21;
              }
            }
            *(byte *)&pdVar28->field_0x114 = *(byte *)&pdVar28->field_0x114 & 0xfe;
            goto LAB_08091673;
          }
        }
        else {
LAB_08091318:
          assert_failed = 0;
        }
      }
    }
  }
LAB_08091322:
  if ((renderer_context._48_1_ & 8) == 0) {
    puVar18 = local_94 + ppVar2->cx;
  }
  else {
    puVar18 = local_94 + ppVar2->cx;
    pvVar22 = (html_context->stack).next;
    width = *(int *)((int)pvVar22 + 0x80) - *(int *)((int)pvVar22 + 0x7c);
    iVar12 = 0;
    if (-1 < width) {
      iVar12 = width;
    }
    if (iVar12 < (int)puVar18) goto LAB_0809101a;
  }
  *(uchar **)&ppVar2->cx = puVar18;
  renderer_context._48_1_ = renderer_context._48_1_ & 0xfd;
  if (-1 < *(char *)&html_context->options->field_0x45) {
    pvVar22 = (html_context->stack).next;
    size = *(uint *)((int)pvVar22 + 0xc) & 0x20;
    if (size == 0) {
      uVar30 = *(int *)((int)pvVar22 + 0x80) - *(int *)((int)pvVar22 + 0x7c);
      if (-1 < (int)uVar30) {
        size = uVar30;
      }
      if (((int)size < ppVar2->cx) && (*(int *)((int)pvVar22 + 0x78) < ppVar2->cx)) {
        do {
          if (assert_failed != 0) goto LAB_08091489;
          ppVar3 = html_context->part;
          assert_failed = ZEXT14(ppVar3 == (part *)0x0);
          if (ppVar3 == (part *)0x0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
            errline = 0x39f;
            elinks_internal((uchar *)"assertion part failed!");
            if (assert_failed != 0) goto LAB_08091489;
          }
          if ((*(byte *)&html_context->options->field_0x5c & 0x10) == 0) {
            pvVar22 = (html_context->stack).next;
            local_84 = *(link **)((int)pvVar22 + 0x7c);
            iVar25 = *(int *)((int)pvVar22 + 0x80) - (int)local_84;
            iVar12 = *(int *)((int)pvVar22 + 0x78);
            width = 0;
            if (-1 < iVar25) {
              width = iVar25;
            }
            if (iVar12 <= width) {
              do {
                if ((width < ppVar3->spaces_len) && (ppVar3->spaces[width] != '\0'))
                goto LAB_08091418;
                width = width + -1;
              } while (iVar12 <= width);
            }
            iVar25 = ppVar3->cx;
            if (iVar25 <= iVar12) goto LAB_080917b0;
            while ((ppVar3->spaces_len <= iVar12 || (width = iVar12, ppVar3->spaces[iVar12] == '\0')
                   )) {
              iVar12 = iVar12 + 1;
              if (iVar25 <= iVar12) goto LAB_080917b0;
            }
          }
          else {
            pvVar22 = (html_context->stack).next;
            local_84 = *(link **)((int)pvVar22 + 0x7c);
            iVar12 = *(int *)((int)pvVar22 + 0x78);
            iVar25 = *(int *)((int)pvVar22 + 0x80) - (int)local_84;
            width = 0;
            if (-1 < iVar25) {
              width = iVar25;
            }
            if (iVar12 <= width) {
              do {
                if ((width < ppVar3->spaces_len) &&
                   ((ppVar3->spaces[width] != '\0' ||
                    ((ppVar3->char_width[width] == '\x02' && (width != iVar12))))))
                goto LAB_08091418;
                width = width + -1;
              } while (iVar12 <= width);
            }
            iVar25 = ppVar3->cx;
            if (iVar25 <= iVar12) {
LAB_080917b0:
              if ((ppVar3->box).width < iVar25 + (int)local_84) {
                (ppVar3->box).width = iVar25 + (int)local_84;
              }
              break;
            }
            width = iVar12;
            while ((ppVar3->spaces_len <= width ||
                   ((ppVar3->spaces[width] == '\0' &&
                    ((ppVar3->char_width[width] != '\x02' || (width <= iVar12))))))) {
              width = width + 1;
              if (iVar25 <= width) goto LAB_080917b0;
            }
          }
LAB_08091418:
          iVar12 = split_line_at(html_context,width);
          if (iVar12 == 0) break;
          if (ppVar2->document != (document *)0x0) {
            align_line(html_context,ppVar2->cy + -1,0);
          }
          renderer_context._48_1_ = renderer_context._48_1_ & 0xfd | (iVar12 != 1) * '\x02';
          pvVar22 = (html_context->stack).next;
          width = *(int *)((int)pvVar22 + 0x80) - *(int *)((int)pvVar22 + 0x7c);
          iVar12 = 0;
          if (-1 < width) {
            iVar12 = width;
          }
          if ((ppVar2->cx <= iVar12) || (ppVar2->cx <= *(int *)((int)pvVar22 + 0x78))) break;
        } while( true );
      }
    }
  }
  if (assert_failed == 0) {
LAB_08091489:
    assert_failed = ZEXT14(charslen < 1);
    if (charslen < 1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x68d;
      elinks_internal((uchar *)"assertion charslen > 0 failed!");
    }
  }
  size = 0;
  local_94 = local_94 + ppVar2->xa;
  *(uchar **)&ppVar2->xa = local_94;
  pvVar22 = (html_context->stack).next;
  if (local_90[charslen + -1] == 0x20) {
    size = (*(uint *)((int)pvVar22 + 0xc) >> 5 ^ 1) & 1;
  }
  if (ppVar2->max_width <
      (int)(local_94 + ((*(int *)((int)pvVar22 + 0x7c) + *(int *)((int)pvVar22 + 0x78)) - size))) {
    *(uchar **)&ppVar2->max_width =
         local_94 + ((*(int *)((int)pvVar22 + 0x7c) + *(int *)((int)pvVar22 + 0x78)) - size);
  }
LAB_0809101a:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_0809256f:
  size = schar_cache._4_4_ & 0xff;
  schar_cache.data = (unicode_val_T)*local_64;
  local_64 = local_64 + 1;
  schar_cache._4_4_ = CONCAT31(schar_cache._5_3_,0x80);
  psVar24 = ppVar3->document->data[(int)((&ppVar3->char_width)[2] + (int)str)].chars +
            (int)((&ppVar3->char_width)[1] + (int)local_98);
  psVar24->data = schar_cache.data;
  *(uint *)&psVar24->attr = schar_cache._4_4_;
  schar_cache._4_4_ = schar_cache._4_4_ & 0xffffff00 | size;
  ppVar3->char_width[(int)local_98] = '\0';
  local_98 = local_98 + 1;
  if (end <= local_64) {
    local_94 = local_98 + -(int)puVar18;
    goto LAB_08091cc9;
  }
  goto LAB_08091c26;
}



void put_chars_conv(html_context *html_context,uchar *chars,int charslen)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(html_context == (html_context *)0x0);
  if (html_context == (html_context *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x542;
    elinks_internal((uchar *)"assertion html_context failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (((chars == (uchar *)0x0) || (html_context->part == (part *)0x0)) || (charslen == 0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x547;
    elinks_internal((uchar *)"assertion part && chars && charslen failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  if ((*(byte *)((int)(html_context->stack).next + 0xc) & 0x10) != 0) {
    put_chars(html_context,chars,charslen);
    return;
  }
  convert_string_elinks
            (renderer_context.convert_table,chars,charslen,html_context->options->cp,CSM_DEFAULT,
             (int *)0x0,put_chars,html_context);
  return;
}



int __regparm3 get_hline_width(table_elinks *table_elinks,int row)

{
  byte *pbVar1;
  table_cell *ptVar2;
  int iVar3;
  
  if (row == 0) {
    return -1;
  }
  iVar3 = table_elinks->rules;
  if ((iVar3 != 3) && (iVar3 != 1)) {
    if ((iVar3 != 4) || (table_elinks->cols < 1)) {
LAB_08092baa:
      iVar3 = 0;
      goto LAB_08092bac;
    }
    row = row * table_elinks->real_cols;
    if ((*(byte *)&table_elinks->cells[row].field_0x3c & 8) == 0) {
      ptVar2 = table_elinks->cells + row + 1;
      iVar3 = 0;
      do {
        iVar3 = iVar3 + 1;
        if (table_elinks->cols <= iVar3) goto LAB_08092baa;
        pbVar1 = (byte *)&ptVar2->field_0x3c;
        ptVar2 = ptVar2 + 1;
      } while ((*pbVar1 & 8) == 0);
    }
  }
  iVar3 = table_elinks->cellspacing;
  if (iVar3 != 0) {
    return iVar3;
  }
LAB_08092bac:
  if (table_elinks->vcellpadding == 0) {
    return -1;
  }
  return iVar3;
}



void __regparm3 get_table_frames(table_elinks *table_elinks,table_frames *result)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(result == (table_frames *)0x0 || table_elinks == (table_elinks *)0x0),
     result == (table_frames *)0x0 || table_elinks == (table_elinks *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
    errline = 0x27;
    elinks_internal((uchar *)"assertion table && result failed!");
  }
  if (table_elinks->border != 0) {
    bVar1 = *(byte *)result;
    bVar2 = (byte)table_elinks->frame & 1;
    *(byte *)result = bVar1 & 0xfe | bVar2;
    bVar3 = ((byte)((uint)table_elinks->frame >> 1) & 1) * '\x02';
    *(byte *)result = bVar1 & 0xfc | bVar2 | bVar3;
    bVar4 = (byte)(((uint)table_elinks->frame >> 2 & 1) << 2);
    *(byte *)result = bVar1 & 0xf8 | bVar2 | bVar3 | bVar4;
    *(byte *)result =
         bVar1 & 0xf0 | bVar2 | bVar3 | bVar4 | (byte)(((uint)table_elinks->frame >> 3 & 1) << 3);
    return;
  }
  *result = (table_frames)0x0;
  return;
}



// WARNING: Could not reconcile some variable overlaps

void __regparm3
draw_table_frames(table_elinks *table_elinks,int indent,int y,html_context *html_context)

{
  byte *pbVar1;
  char cVar2;
  char cVar3;
  char cVar4;
  char cVar5;
  void *__s;
  uint local_c8;
  uint uVar6;
  int iVar7;
  int __c;
  size_t __n;
  int iVar8;
  size_t __n_00;
  table_cell *ptVar9;
  int height;
  void *pvVar10;
  int iVar11;
  size_t size;
  uint x;
  bool bVar12;
  int local_a0;
  int local_60;
  int local_5c;
  int local_58;
  int local_50;
  int local_48;
  uint local_44;
  int local_40;
  uint local_3c;
  int local_38;
  int local_34;
  int local_30;
  table_frames table_frames;
  
  height = (table_elinks->rows + 1) * (table_elinks->cols + 2);
  size = (table_elinks->rows + 2) * (table_elinks->cols + 1) + height;
  __s = mem_alloc(size);
  if (__s != (void *)0x0) {
    memset(__s,-1,size);
    local_3c = table_elinks->rules;
    pvVar10 = (void *)(height + (int)__s);
    if (local_3c != 0) {
      local_48 = table_elinks->rows;
      if (0 < local_48) {
        local_30 = table_elinks->cols;
        local_40 = 1;
        local_38 = 0;
        local_34 = local_48;
        do {
          if (0 < local_30) {
            iVar11 = 1;
            height = 0;
            do {
              ptVar9 = table_elinks->cells + local_38 * table_elinks->real_cols + height;
              __c = local_34;
              if ((*(byte *)&ptVar9->field_0x3c & 3) == 1) {
                __n_00 = local_30 - height;
                if (ptVar9->colspan != 0) {
                  __n_00 = ptVar9->colspan;
                }
                __n = ptVar9->rowspan;
                if (ptVar9->rowspan == 0) {
                  __n = local_34 - local_38;
                }
                if (local_3c != 2) {
                  __c = table_elinks->cellspacing;
                  if (assert_failed == 0) {
                    if ((((height < -1) && (local_30 + 2 <= height)) && (local_38 < 0)) &&
                       (local_34 < local_38)) {
                      assert_failed = 1;
                      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                      errline = 0x3cb;
                      elinks_internal((uchar *)
                                      "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                                     );
                      if (assert_failed != 0) goto LAB_08093ff8;
                    }
                    else {
                      assert_failed = 0;
                    }
                    iVar8 = (local_30 + 2) * local_38 + iVar11;
                  }
                  else {
LAB_08093ff8:
                    assert_failed = 0;
                    iVar8 = 0;
                  }
                  memset((void *)(iVar8 + (int)__s),__c,__n_00);
                  __c = table_elinks->cellspacing;
                  iVar8 = table_elinks->cols;
                  if (assert_failed == 0) {
                    iVar7 = local_38 + __n;
                    if (((height < -1) && (iVar7 < 0)) &&
                       ((iVar8 + 2 <= height && (table_elinks->rows < iVar7)))) {
                      assert_failed = 1;
                      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                      errline = 0x3cb;
                      elinks_internal((uchar *)
                                      "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                                     );
                      if (assert_failed != 0) goto LAB_08093f70;
                    }
                    else {
                      assert_failed = 0;
                    }
                    local_3c = iVar8 + 2;
                    iVar8 = local_3c * iVar7 + iVar11;
                  }
                  else {
LAB_08093f70:
                    assert_failed = 0;
                    iVar8 = 0;
                  }
                  memset((void *)(iVar8 + (int)__s),__c,__n_00);
                  if (table_elinks->rules == 1) {
                    local_30 = table_elinks->cols;
                    local_3c = 1;
                    __c = table_elinks->rows;
                    goto joined_r0x08093c59;
                  }
                  local_48 = table_elinks->rows;
                  local_30 = table_elinks->cols;
                }
                __c = table_elinks->cellspacing;
                if (assert_failed == 0) {
                  if (((local_38 < -1) && (local_48 + 2 <= local_38)) &&
                     ((height < 0 && (local_30 < height)))) {
                    assert_failed = 1;
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                    errline = 0x3cb;
                    elinks_internal((uchar *)
                                    "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                                   );
                    if (assert_failed != 0) goto LAB_08094100;
                  }
                  else {
                    assert_failed = 0;
                  }
                  iVar8 = (local_48 + 2) * height + local_40;
                }
                else {
LAB_08094100:
                  assert_failed = 0;
                  iVar8 = 0;
                }
                memset((void *)(iVar8 + (int)pvVar10),__c,__n);
                __c = table_elinks->cellspacing;
                iVar8 = table_elinks->rows;
                if (assert_failed == 0) {
                  iVar7 = __n_00 + height;
                  if ((((local_38 < -1) && (iVar7 < 0)) && (iVar8 + 2 <= local_38)) &&
                     (table_elinks->cols < iVar7)) {
                    assert_failed = 1;
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                    errline = 0x3cb;
                    elinks_internal((uchar *)
                                    "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                                   );
                    if (assert_failed != 0) goto LAB_08094078;
                  }
                  else {
                    assert_failed = 0;
                  }
                  local_3c = iVar8 + 2;
                  iVar8 = local_3c * iVar7 + local_40;
                }
                else {
LAB_08094078:
                  assert_failed = 0;
                  iVar8 = 0;
                }
                memset((void *)(iVar8 + (int)pvVar10),__c,__n);
                local_30 = table_elinks->cols;
                local_3c = table_elinks->rules;
                __c = table_elinks->rows;
              }
joined_r0x08093c59:
              local_48 = __c;
              local_34 = local_48;
              if (local_30 <= iVar11) break;
              iVar11 = iVar11 + 1;
              height = height + 1;
            } while( true );
          }
          local_38 = local_38 + 1;
          bVar12 = local_40 < local_34;
          local_40 = local_40 + 1;
        } while (bVar12);
      }
      if (local_3c == 4) {
        if (1 < table_elinks->cols) {
          height = 1;
          do {
            if (table_elinks->cols_x[height] == 0) {
              if (assert_failed == 0) {
                iVar11 = (table_elinks->rows + 2U) * height + 1;
              }
              else {
                iVar11 = 0;
              }
              assert_failed = 0;
              memset((void *)((int)pvVar10 + iVar11),0,table_elinks->rows);
            }
            height = height + 1;
          } while (height < table_elinks->cols);
        }
        height = 1;
        if (1 < table_elinks->rows) {
          do {
            __n_00 = table_elinks->cols;
            if ((int)__n_00 < 1) {
LAB_08094303:
              if (assert_failed == 0) {
                iVar11 = (__n_00 + 2) * height + 1;
              }
              else {
                iVar11 = 0;
              }
              assert_failed = 0;
              memset((void *)(iVar11 + (int)__s),0,__n_00);
            }
            else {
              iVar11 = table_elinks->real_cols * height;
              if ((*(byte *)&table_elinks->cells[iVar11].field_0x3c & 8) == 0) {
                ptVar9 = table_elinks->cells + iVar11 + 1;
                iVar11 = 0;
                do {
                  iVar11 = iVar11 + 1;
                  if ((int)__n_00 <= iVar11) goto LAB_08094303;
                  pbVar1 = (byte *)&ptVar9->field_0x3c;
                  ptVar9 = ptVar9 + 1;
                } while ((*pbVar1 & 8) == 0);
              }
            }
            height = height + 1;
          } while (height < table_elinks->rows);
        }
      }
    }
    get_table_frames(table_elinks,&table_frames);
    bVar12 = assert_failed == 0;
    assert_failed = 0;
    memset((void *)((uint)bVar12 + (int)__s),(uint)(table_frames._0_1_ & 1),table_elinks->cols);
    if (assert_failed == 0) {
      height = (table_elinks->cols + 2U) * table_elinks->rows + 1;
    }
    else {
      height = 0;
    }
    assert_failed = 0;
    memset((void *)(height + (int)__s),(uint)(table_frames._0_1_ >> 1 & 1),table_elinks->cols);
    bVar12 = assert_failed == 0;
    assert_failed = 0;
    memset((void *)((uint)bVar12 + (int)pvVar10),(uint)(table_frames._0_1_ >> 2 & 1),
           table_elinks->rows);
    if (assert_failed == 0) {
      height = (table_elinks->rows + 2U) * table_elinks->cols + 1;
    }
    else {
      height = 0;
    }
    assert_failed = 0;
    local_c8 = (uint)(table_frames._0_1_ >> 3 & 1);
    memset((void *)(height + (int)pvVar10),local_c8,table_elinks->rows);
    local_40 = table_elinks->rows;
    if (-1 < local_40) {
      local_5c = -1;
      local_58 = 0;
      local_48 = 1;
      local_38 = 0;
      local_50 = y;
LAB_08092e88:
      if (local_38 < 1) {
        if ((local_38 != 0) || ((table_frames._0_1_ & 1) == 0)) goto LAB_08092e9b;
LAB_080930af:
        local_44 = 0xffffffff;
        if ((table_frames._0_1_ & 4) != 0) {
          local_44 = table_elinks->border;
        }
        height = table_elinks->cols;
        if (0 < height) {
          local_a0 = 0;
          iVar11 = 0;
          x = indent;
          do {
            if ((int)local_44 < 0) {
              if (assert_failed == 0) goto LAB_08093112;
LAB_080933b2:
              height = 0;
            }
            else {
              if (assert_failed == 0) {
                if ((((iVar11 + -1 < -1) && (height + 2 <= iVar11 + -1)) && (local_38 < 0)) &&
                   (local_40 < local_38)) {
                  assert_failed = 1;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                  errline = 0x3cb;
                  elinks_internal((uchar *)
                                  "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                                  ,local_c8);
                  if (assert_failed != 0) goto LAB_08093428;
                }
                height = (height + 2) * local_38 + iVar11;
              }
              else {
LAB_08093428:
                height = 0;
              }
              cVar2 = *(char *)((int)__s + height);
              height = table_elinks->cols;
              if (((iVar11 < -1) && (height + 2 <= iVar11)) &&
                 ((local_38 < 0 && (table_elinks->rows < local_38)))) {
                assert_failed = 1;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                errline = 0x3cb;
                elinks_internal((uchar *)
                                "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                               );
                if (assert_failed == 0) goto LAB_08093252;
                local_3c = 0;
              }
              else {
LAB_08093252:
                local_3c = (height + 2) * local_38 + iVar11 + 1;
              }
              cVar3 = *(char *)((int)__s + local_3c);
              height = table_elinks->rows;
              if (((local_5c < -1) && (iVar11 < 0)) &&
                 ((height + 2 <= local_5c && (table_elinks->cols < iVar11)))) {
                assert_failed = 1;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                errline = 0x3cb;
                elinks_internal((uchar *)
                                "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                               );
                if (assert_failed == 0) goto LAB_0809328b;
                height = 0;
              }
              else {
LAB_0809328b:
                height = (height + 2) * iVar11 + local_38;
              }
              __c = table_elinks->rows;
              cVar4 = *(char *)((int)pvVar10 + height);
              if ((((local_38 < -1) && (iVar11 < 0)) && (__c + 2 <= local_38)) &&
                 (table_elinks->cols < iVar11)) {
                assert_failed = 1;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                errline = 0x3cb;
                elinks_internal((uchar *)
                                "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                               );
                if (assert_failed == 0) goto LAB_080932bb;
                assert_failed = 0;
                height = 0;
              }
              else {
                assert_failed = 0;
LAB_080932bb:
                height = (__c + 2) * iVar11 + local_48;
              }
              cVar5 = *(char *)((int)pvVar10 + height);
              if (((-1 < cVar3) || (-1 < cVar2)) || ((-1 < cVar5 || (-1 < cVar4)))) {
                __c = (int)cVar2;
                iVar8 = (int)cVar4;
                height = (int)cVar3;
                if (height < 0) {
                  height = 0;
                }
                if (__c < 0) {
                  __c = 0;
                }
                if (iVar8 < 0) {
                  iVar8 = 0;
                }
                iVar7 = 0;
                if (-1 < (int)cVar5) {
                  iVar7 = (int)cVar5;
                }
                local_c8 = x;
                draw_frame_hchars(table_elinks->part,x,local_50,1,
                                  *(uchar *)(border_chars +
                                            __c * 9 + height * 3 + iVar7 * 0x1b + iVar8),
                                  *(color_T *)((int)(html_context->stack).next + 0x94),
                                  table_elinks->bordercolor,html_context);
              }
              local_40 = table_elinks->rows;
              if (local_38 < local_40) {
                if (assert_failed == 0) {
                  if (((local_38 < -1) && (iVar11 < 0)) &&
                     ((local_40 + 2 <= local_38 && (table_elinks->cols < iVar11)))) {
                    assert_failed = 1;
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                    errline = 0x3cb;
                    elinks_internal((uchar *)
                                    "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                                   );
                    if (assert_failed != 0) goto LAB_08093648;
                  }
                  height = (local_40 + 2) * iVar11 + local_48;
                }
                else {
LAB_08093648:
                  height = 0;
                }
                uVar6 = SEXT14(*(char *)((int)pvVar10 + height));
                assert_failed = ZEXT14(2 < (int)uVar6);
                if (2 < (int)uVar6) {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                  errline = 0x426;
                  local_c8 = uVar6;
                  elinks_internal((uchar *)
                                  "assertion pos < 3 failed: Vertical table position out of bound [%d]"
                                  ,uVar6);
                  if (assert_failed != 0) {
                    local_40 = table_elinks->rows;
                    local_34 = 0;
                    goto LAB_080933a1;
                  }
                }
                local_60 = local_50 + 1;
                if ((int)uVar6 < 0) {
                  local_40 = table_elinks->rows;
                  local_34 = assert_failed;
                }
                else {
                  height = *(int *)((int)table_elinks->rows_heights + local_58);
                  if (0 < height) {
                    local_c8 = x;
                    draw_frame_vchars(table_elinks->part,x,local_60,height,vltable[uVar6],
                                      *(color_T *)((int)(html_context->stack).next + 0x94),
                                      table_elinks->bordercolor,html_context);
                  }
                  local_40 = table_elinks->rows;
                  local_34 = assert_failed;
                }
              }
              else {
                local_34 = assert_failed;
              }
LAB_080933a1:
              x = x + 1;
              height = table_elinks->cols;
              if (local_34 != 0) goto LAB_080933b2;
LAB_08093112:
              local_30 = iVar11 + 1;
              if ((((iVar11 < -1) && (height + 2 <= iVar11)) && (local_38 < 0)) &&
                 (local_40 < local_38)) {
                assert_failed = 1;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                errline = 0x3cb;
                elinks_internal((uchar *)
                                "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                                ,local_c8);
                if (assert_failed != 0) goto LAB_080933b2;
              }
              height = (height + 2) * local_38 + local_30;
            }
            local_30 = iVar11 + 1;
            uVar6 = SEXT14(*(char *)((int)__s + height));
            assert_failed = ZEXT14(2 < (int)uVar6);
            if (2 < (int)uVar6) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
              errline = 0x416;
              local_c8 = uVar6;
              elinks_internal((uchar *)
                              "assertion pos < 3 failed: Horizontal table position out of bound [%d]"
                              ,uVar6);
              if (assert_failed == 0) goto LAB_0809314b;
              assert_failed = 0;
              height = *(int *)((int)table_elinks->cols_widths + local_a0);
            }
            else {
LAB_0809314b:
              if (-1 < (int)uVar6) {
                height = *(int *)((int)table_elinks->cols_widths + local_a0);
                if (height < 1) goto LAB_080931ad;
                local_c8 = x;
                draw_frame_hchars(table_elinks->part,x,local_50,height,hltable[uVar6],
                                  *(color_T *)((int)(html_context->stack).next + 0x94),
                                  table_elinks->bordercolor,html_context);
              }
              height = *(int *)((int)table_elinks->cols_widths + local_a0);
            }
LAB_080931ad:
            x = x + height;
            height = table_elinks->cols;
            if (height <= local_30) goto LAB_08092fa0;
            if (0 < local_30) {
              if (table_elinks->rules - 2U < 2) {
                local_44 = table_elinks->cellspacing;
                uVar6 = local_44;
joined_r0x080935d8:
                if (uVar6 != 0) goto LAB_080931e4;
              }
              else {
                if ((table_elinks->rules == 4) && (local_30 < table_elinks->columns_count)) {
                  local_44 = 1;
                  uVar6 = table_elinks->columns[local_30].group;
                  goto joined_r0x080935d8;
                }
              }
              local_44 = ~-(uint)(table_elinks->cellpadding == 0);
            }
LAB_080931e4:
            local_40 = table_elinks->rows;
            local_a0 = local_a0 + 4;
            iVar11 = local_30;
          } while( true );
        }
        local_30 = 0;
        local_3c = indent;
        goto LAB_08092faf;
      }
      if (local_38 < local_40) {
        height = get_hline_width(table_elinks,local_38);
        if (-1 < height) {
          local_40 = table_elinks->rows;
          goto LAB_080930af;
        }
        local_40 = table_elinks->rows;
      }
LAB_08092e9b:
      if (local_40 != local_38) {
        if (local_40 <= local_38) goto LAB_08092fdc;
        height = table_elinks->cols;
        if (-1 < height) {
          iVar11 = 0;
          x = indent;
          do {
            if (iVar11 == 0) {
              if ((table_frames._0_1_ & 4) != 0) goto LAB_08092eff;
LAB_08092ed8:
              if ((iVar11 == height) && ((table_frames._0_1_ & 8) != 0)) goto LAB_08092eff;
            }
            else {
              if (height <= iVar11) goto LAB_08092ed8;
              if (table_elinks->rules - 2U < 2) {
                if (table_elinks->cellspacing == 0) goto LAB_08093070;
                if (table_elinks->cellspacing < 0) goto LAB_08092ed8;
              }
              else {
                if (((table_elinks->rules != 4) || (table_elinks->columns_count <= iVar11)) ||
                   (table_elinks->columns[iVar11].group == 0)) {
LAB_08093070:
                  if (table_elinks->cellpadding != 0) goto LAB_08092ed8;
                }
              }
LAB_08092eff:
              if (assert_failed == 0) {
                height = (local_40 + 2) * iVar11 + local_48;
              }
              else {
                height = 0;
              }
              uVar6 = SEXT14(*(char *)((int)pvVar10 + height));
              assert_failed = ZEXT14(2 < (int)uVar6);
              if (2 < (int)uVar6) {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                errline = 0x426;
                local_c8 = uVar6;
                elinks_internal((uchar *)
                                "assertion pos < 3 failed: Vertical table position out of bound [%d]"
                                ,uVar6);
                if (assert_failed == 0) goto LAB_08092f36;
                assert_failed = 0;
              }
              else {
LAB_08092f36:
                if ((-1 < (int)uVar6) &&
                   (height = *(int *)((int)table_elinks->rows_heights + local_58), 0 < height)) {
                  local_c8 = x;
                  draw_frame_vchars(table_elinks->part,x,local_50,height,vltable[uVar6],
                                    *(color_T *)((int)(html_context->stack).next + 0x94),
                                    table_elinks->bordercolor,html_context);
                }
              }
              local_40 = table_elinks->rows;
              x = x + 1;
              height = table_elinks->cols;
            }
            if (iVar11 < height) {
              x = x + table_elinks->cols_widths[iVar11];
            }
            iVar11 = iVar11 + 1;
          } while (iVar11 <= height);
          goto LAB_08092fc5;
        }
        goto LAB_08092fca;
      }
      if ((table_frames._0_1_ & 2) != 0) goto LAB_080930af;
      goto LAB_08092fdc;
    }
LAB_08092ff5:
    mem_free(__s);
  }
  return;
LAB_08092fa0:
  local_40 = table_elinks->rows;
  local_3c = x;
LAB_08092faf:
  local_60 = local_50 + 1;
  if ((table_frames._0_1_ & 8) == 0) goto LAB_08092fbf;
  if (assert_failed == 0) {
    if (((local_30 + -1 < -1) && (height + 2 <= local_30 + -1)) &&
       ((local_38 < 0 && (local_40 < local_38)))) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
      errline = 0x3cb;
      elinks_internal((uchar *)
                      "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!",
                      local_c8);
      if (assert_failed != 0) goto LAB_08093b90;
    }
    height = (height + 2) * local_38 + local_30;
  }
  else {
LAB_08093b90:
    height = 0;
  }
  cVar2 = *(char *)((int)__s + height);
  height = table_elinks->cols;
  if ((((local_30 < -1) && (height + 2 <= local_30)) && (local_38 < 0)) &&
     (table_elinks->rows < local_38)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
    errline = 0x3cb;
    elinks_internal((uchar *)"assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!")
    ;
    if (assert_failed == 0) goto LAB_080938cb;
    height = 0;
  }
  else {
LAB_080938cb:
    height = local_30 + 1 + (height + 2) * local_38;
  }
  cVar3 = *(char *)((int)__s + height);
  height = table_elinks->rows;
  if (((local_5c < -1) && (local_30 < 0)) &&
     ((height + 2 <= local_5c && (table_elinks->cols < local_30)))) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
    errline = 0x3cb;
    elinks_internal((uchar *)"assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!")
    ;
    if (assert_failed == 0) goto LAB_080938f7;
    height = 0;
  }
  else {
LAB_080938f7:
    height = (height + 2) * local_30 + local_38;
  }
  cVar4 = *(char *)((int)pvVar10 + height);
  height = table_elinks->rows;
  if (((local_38 < -1) && (local_30 < 0)) &&
     ((height + 2 <= local_38 && (table_elinks->cols < local_30)))) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
    errline = 0x3cb;
    elinks_internal((uchar *)"assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!")
    ;
    if (assert_failed == 0) goto LAB_08093921;
    assert_failed = 0;
    height = 0;
  }
  else {
    assert_failed = 0;
LAB_08093921:
    height = (height + 2) * local_30 + local_48;
  }
  cVar5 = *(char *)((int)pvVar10 + height);
  if ((((-1 < cVar3) || (-1 < cVar2)) || (-1 < cVar5)) || (-1 < cVar4)) {
    height = (int)cVar4;
    iVar11 = (int)cVar2;
    __c = (int)cVar3;
    if (__c < 0) {
      __c = 0;
    }
    if (iVar11 < 0) {
      iVar11 = 0;
    }
    if (height < 0) {
      height = 0;
    }
    iVar8 = 0;
    if (-1 < (int)cVar5) {
      iVar8 = (int)cVar5;
    }
    local_c8 = local_3c;
    draw_frame_hchars(table_elinks->part,local_3c,local_50,1,
                      *(uchar *)(border_chars + __c * 3 + iVar8 * 0x1b + iVar11 * 9 + height),
                      *(color_T *)((int)(html_context->stack).next + 0x94),table_elinks->bordercolor
                      ,html_context);
  }
  local_40 = table_elinks->rows;
  if (local_40 <= local_38) goto LAB_08092fbf;
  if (assert_failed == 0) {
    if (((local_38 < -1) && (local_30 < 0)) &&
       ((local_40 + 2 <= local_38 && (table_elinks->cols < local_30)))) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
      errline = 0x3cb;
      elinks_internal((uchar *)
                      "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!");
      if (assert_failed != 0) goto LAB_080939f2;
    }
    height = (local_40 + 2) * local_30 + local_48;
  }
  else {
LAB_080939f2:
    height = 0;
  }
  x = SEXT14(*(char *)((int)pvVar10 + height));
  assert_failed = ZEXT14(2 < (int)x);
  if (2 < (int)x) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
    errline = 0x426;
    local_c8 = x;
    elinks_internal((uchar *)"assertion pos < 3 failed: Vertical table position out of bound [%d]",x
                   );
    if (assert_failed != 0) {
      assert_failed = 0;
      local_40 = table_elinks->rows;
      goto LAB_08092fbf;
    }
  }
  if ((-1 < (int)x) && (height = *(int *)((int)table_elinks->rows_heights + local_58), 0 < height))
  {
    draw_frame_vchars(table_elinks->part,local_3c,local_60,height,vltable[x],
                      *(color_T *)((int)(html_context->stack).next + 0x94),table_elinks->bordercolor
                      ,html_context);
    local_c8 = local_3c;
  }
  local_40 = table_elinks->rows;
LAB_08092fbf:
  local_50 = local_60;
LAB_08092fc5:
  if (local_38 < local_40) {
LAB_08092fca:
    local_50 = local_50 + *(int *)((int)table_elinks->rows_heights + local_58);
  }
LAB_08092fdc:
  local_38 = local_38 + 1;
  local_58 = local_58 + 4;
  local_5c = local_5c + 1;
  bVar12 = local_40 < local_48;
  local_48 = local_48 + 1;
  if (bVar12) goto LAB_08092ff5;
  goto LAB_08092e88;
}



// WARNING: Could not reconcile some variable overlaps

void format_table(uchar *attr,uchar *html,uchar *eof,uchar **end,html_context *html_context)

{
  uint *puVar1;
  part *ppVar2;
  int iVar3;
  color_T bgcolor;
  document *document;
  uint uVar4;
  bool bVar5;
  uint sh;
  table_elinks *table_elinks;
  ushort **ppuVar6;
  void *state;
  part *p;
  size_t count;
  void *__s;
  int iVar7;
  part *part;
  int *__s_00;
  void **ppvVar8;
  int *piVar9;
  void *state_00;
  int *piVar10;
  int row;
  void *pvVar11;
  int iVar12;
  size_t sVar13;
  int iVar14;
  void *pvVar15;
  int iVar16;
  byte *end_00;
  int width;
  int margin;
  byte *html_00;
  table_cell *ptVar17;
  int margin_00;
  int align;
  byte *start;
  int local_78;
  int local_74;
  int local_70;
  int local_60;
  int *local_5c;
  int local_58;
  int local_54;
  int local_50;
  int local_4c;
  int local_48;
  int local_44;
  int local_40;
  int local_3c;
  int local_38;
  int local_34;
  int local_30;
  table_frames table_frames;
  
  ppVar2 = html_context->part;
  sh = 1;
  html_context->table_level = html_context->table_level + 1;
  if (ppVar2->document == (document *)0x0) {
    sh = (uint)((ppVar2->box).x != 0);
  }
  table_elinks = parse_table(html,eof,end,attr,sh,html_context);
  if (table_elinks != (table_elinks *)0x0) {
    table_elinks->part = ppVar2;
    local_34 = table_elinks->bad_html_size;
    width = 0;
LAB_0809447d:
    if (width < local_34) {
      html_00 = table_elinks->bad_html[width].start;
      start = table_elinks->bad_html[width].end;
      if (html_00 < start) {
        ppuVar6 = __ctype_b_loc();
        do {
          if ((*(byte *)((int)*ppuVar6 + (uint)*html_00 * 2 + 1) & 0x20) == 0)
          goto joined_r0x080944c8;
          html_00 = html_00 + 1;
        } while (html_00 < start);
      }
      goto LAB_08094528;
    }
    state = init_html_parser_state(html_context,ELEMENT_DONT_KILL,0,0,0);
    __s = (html_context->stack).next;
    align = *(int *)((int)__s + 0x7c) + *(int *)((int)__s + 0x78);
    part = table_elinks->part;
    width = table_elinks->cellpadding;
    local_78 = 0;
    local_74 = 0;
    p = part;
LAB_08094589:
    local_30 = p->link_num;
    if ((*(byte *)&html_context->options->field_0x44 & 8) == 0) {
      local_34 = 0;
      if (0 < table_elinks->rows) {
        do {
          margin_00 = 0;
          if (0 < table_elinks->cols) {
            do {
              ptVar17 = table_elinks->cells + margin_00 + local_34 * table_elinks->real_cols;
              if (ptVar17->start != (uchar *)0x0) {
                ptVar17->link_num = local_30;
                margin = table_elinks->cellpadding;
                ptVar17->min_width = -1;
                ptVar17->max_width = -1;
                p = format_html_part(html_context,ptVar17->start,ptVar17->end,0,margin,0,
                                     (document *)0x0,0,0,(uchar *)0x0,local_30);
                if (p != (part *)0x0) {
                  margin = (p->box).width;
                  ptVar17->min_width = margin;
                  row = p->max_width;
                  ptVar17->max_width = row;
                  local_30 = p->link_num;
                  if ((assert_failed == 0) && (assert_failed = ZEXT14(row < margin), row < margin))
                  {
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                    errline = 0x77;
                    elinks_internal((uchar *)
                                    "assertion *min <= *max failed: get_cell_width: %d > %d",
                                    ptVar17->min_width,ptVar17->max_width);
                  }
                  mem_free(p);
                }
              }
              margin_00 = margin_00 + 1;
            } while (margin_00 < table_elinks->cols);
          }
          local_34 = local_34 + 1;
        } while (local_34 < table_elinks->rows);
      }
    }
    else {
      local_34 = 0;
      if (0 < table_elinks->cols) {
        do {
          if (0 < table_elinks->rows) {
            margin_00 = table_elinks->real_cols;
            margin = 0;
            while( true ) {
              ptVar17 = table_elinks->cells + margin_00 * margin + local_34;
              if (ptVar17->start != (uchar *)0x0) {
                ptVar17->link_num = local_30;
                margin_00 = table_elinks->cellpadding;
                ptVar17->min_width = -1;
                ptVar17->max_width = -1;
                p = format_html_part(html_context,ptVar17->start,ptVar17->end,0,margin_00,0,
                                     (document *)0x0,0,0,(uchar *)0x0,local_30);
                if (p != (part *)0x0) {
                  margin_00 = (p->box).width;
                  ptVar17->min_width = margin_00;
                  row = p->max_width;
                  ptVar17->max_width = row;
                  local_30 = p->link_num;
                  if ((assert_failed == 0) &&
                     (assert_failed = ZEXT14(row < margin_00), row < margin_00)) {
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                    errline = 0x77;
                    elinks_internal((uchar *)
                                    "assertion *min <= *max failed: get_cell_width: %d > %d",
                                    ptVar17->min_width,ptVar17->max_width);
                  }
                  mem_free(p);
                }
              }
              margin = margin + 1;
              if (table_elinks->rows <= margin) break;
              margin_00 = table_elinks->real_cols;
            }
          }
          local_34 = local_34 + 1;
        } while (local_34 < table_elinks->cols);
      }
    }
    count = table_elinks->cols;
    table_elinks->link_num = local_30;
    if (count == 0) goto ret2;
    if (table_elinks->min_cols_widths == (int *)0x0) {
      __s_00 = (int *)mem_calloc(count,4);
      table_elinks->min_cols_widths = __s_00;
      if (__s_00 == (int *)0x0) goto LAB_08095bce;
      count = table_elinks->cols;
    }
    if (table_elinks->max_cols_widths == (int *)0x0) {
      __s_00 = (int *)mem_calloc(count,4);
      table_elinks->max_cols_widths = __s_00;
      if (__s_00 == (int *)0x0) {
        if (table_elinks->min_cols_widths != (int *)0x0) {
          mem_free(table_elinks->min_cols_widths);
        }
        table_elinks->min_cols_widths = (int *)0x0;
        local_30 = table_elinks->link_num;
        goto ret2;
      }
      count = table_elinks->cols;
    }
    if (table_elinks->cols_widths == (int *)0x0) {
      __s_00 = (int *)mem_calloc(count,4);
      table_elinks->cols_widths = __s_00;
      if (__s_00 == (int *)0x0) {
        if (table_elinks->min_cols_widths != (int *)0x0) {
          mem_free(table_elinks->min_cols_widths);
        }
        table_elinks->min_cols_widths = (int *)0x0;
        if (table_elinks->max_cols_widths != (int *)0x0) {
          mem_free(table_elinks->max_cols_widths);
        }
        table_elinks->max_cols_widths = (int *)0x0;
        local_30 = table_elinks->link_num;
        goto ret2;
      }
      count = table_elinks->cols;
    }
    local_30 = 1;
LAB_080946f0:
    if (0 < (int)count) {
      local_58 = 0;
      local_60 = 1;
      local_4c = 0x7fffffff;
LAB_08094710:
      local_48 = local_4c;
      if (0 < table_elinks->rows) {
        margin_00 = table_elinks->real_cols;
        local_44 = 0;
        do {
          ptVar17 = table_elinks->cells + margin_00 * local_44 + local_60 + -1;
          if ((*(byte *)&ptVar17->field_0x3c & 3) == 1) {
            if (assert_failed != 0) {
LAB_08094799:
              assert_failed = 0;
              local_30 = table_elinks->link_num;
              goto ret2;
            }
            bVar5 = table_elinks->cols < local_60 + -1 + ptVar17->colspan;
            assert_failed = ZEXT14(bVar5);
            if (bVar5) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
              errline = 0x124;
              elinks_internal((uchar *)
                              "assertion cell->colspan + col <= table->cols failed: colspan out of table"
                             );
              if (assert_failed != 0) goto LAB_08094799;
            }
            local_48 = ptVar17->colspan;
            if (local_48 == local_30) {
              local_54 = 0;
              if (1 < local_30) {
                margin = 1;
                local_54 = 0;
                margin_00 = local_60;
                local_38 = local_60 << 4;
                do {
                  sh = 0;
                  if (margin_00 != 0) {
                    if (table_elinks->rules - 2U < 2) {
                      if (table_elinks->cellspacing == 0) {
LAB_080948a5:
                        sh = (uint)(table_elinks->cellpadding == 0);
                      }
                      else {
                        sh = (uint)~table_elinks->cellspacing >> 0x1f;
                      }
                    }
                    else {
                      if (((table_elinks->rules != 4) ||
                          (table_elinks->columns_count == margin_00 ||
                           table_elinks->columns_count < margin_00)) ||
                         (sh = 1, *(int *)((int)&table_elinks->columns->group + local_38) == 0))
                      goto LAB_080948a5;
                    }
                  }
                  local_54 = local_54 + sh;
                  margin = margin + 1;
                  margin_00 = margin_00 + 1;
                  local_38 = local_38 + 0x10;
                } while (margin < local_30);
              }
              local_5c = table_elinks->max_cols_widths;
              margin_00 = local_58 + (int)local_5c;
              margin = 0;
              iVar14 = ptVar17->min_width - local_54;
              row = local_58 + (int)table_elinks->min_cols_widths;
              iVar16 = 0;
              if (0 < local_48) {
                iVar16 = 0;
                do {
                  iVar16 = iVar16 + *(int *)(row + margin * 4);
                  margin = margin + 1;
                } while (margin != local_30);
              }
              if (iVar16 < iVar14) {
                iVar14 = iVar14 - iVar16;
                margin = iVar14 / local_48;
                iVar14 = iVar14 % local_48;
                if (margin_00 == 0) {
                  if (0 < local_48) {
LAB_080949c6:
                    margin_00 = 0;
                    do {
                      *(int *)(row + margin_00 * 4) =
                           *(int *)(row + margin_00 * 4) + margin + (uint)(margin_00 < iVar14);
                      margin_00 = margin_00 + 1;
                    } while (margin_00 != local_30);
                    local_5c = table_elinks->max_cols_widths;
                  }
                  margin_00 = (int)local_5c + local_58;
                  goto LAB_080949fc;
                }
                if (local_48 < 1) {
                  local_54 = ptVar17->max_width - local_54;
                  goto LAB_08094aa1;
                }
                iVar7 = 0;
                iVar16 = 0;
                do {
                  iVar12 = margin + *(int *)(row + iVar16 * 4) + (uint)(iVar16 < iVar14);
                  *(int *)(row + iVar16 * 4) = iVar12;
                  iVar3 = *(int *)(margin_00 + iVar16 * 4);
                  iVar12 = iVar12 - iVar3;
                  if (0 < iVar12) {
                    iVar7 = iVar7 + iVar12;
                    *(int *)(row + iVar16 * 4) = iVar3;
                  }
                  iVar16 = iVar16 + 1;
                } while (iVar16 != local_30);
                if (iVar7 != 0) {
                  margin = iVar7 / local_30;
                  iVar14 = iVar7 % local_30;
                  goto LAB_080949c6;
                }
                local_5c = table_elinks->max_cols_widths;
                local_54 = ptVar17->max_width - local_54;
                margin_00 = (int)local_5c + local_58;
LAB_08094a10:
                margin = 0;
                row = 0;
                do {
                  margin = margin + *(int *)(margin_00 + row * 4);
                  row = row + 1;
                } while (row != local_30);
                if (margin < local_54) goto LAB_08094a2a;
LAB_08094aab:
                if (local_48 < 1) goto LAB_08094748;
              }
              else {
LAB_080949fc:
                local_54 = ptVar17->max_width - local_54;
                if (0 < local_48) goto LAB_08094a10;
LAB_08094aa1:
                margin = 0;
                if (local_54 < 1) goto LAB_08094aab;
LAB_08094a2a:
                if (local_48 < 1) goto LAB_08094748;
                row = 0;
                do {
                  *(int *)(margin_00 + row * 4) =
                       *(int *)(margin_00 + row * 4) + (local_54 - margin) / local_48 +
                       (uint)(row < (local_54 - margin) % local_48);
                  row = row + 1;
                } while (row != local_30);
                local_5c = table_elinks->max_cols_widths;
              }
              margin = 0;
              margin_00 = local_58;
              while( true ) {
                row = *(int *)((int)table_elinks->min_cols_widths + margin_00);
                if (*(int *)((int)local_5c + margin_00) < row) {
                  *(int *)((int)local_5c + margin_00) = row;
                }
                margin = margin + 1;
                margin_00 = margin_00 + 4;
                if (local_48 <= margin) break;
                local_5c = table_elinks->max_cols_widths;
              }
              goto LAB_08094748;
            }
            if ((local_48 <= local_30) || (local_4c <= local_48)) goto LAB_08094748;
            if (table_elinks->rows <= local_44 + 1) goto LAB_08094854;
          }
          else {
LAB_08094748:
            local_48 = local_4c;
            if (table_elinks->rows <= local_44 + 1) goto LAB_08094854;
          }
          local_44 = local_44 + 1;
          margin_00 = table_elinks->real_cols;
          local_4c = local_48;
        } while( true );
      }
      goto LAB_08094857;
    }
LAB_08094f85:
    margin_00 = 0;
    local_44 = 0;
    goto LAB_08094d3c;
  }
  goto ret0;
  while (start = end_00 + -1, (*(byte *)((int)*ppuVar6 + (uint)end_00[-1] * 2 + 1) & 0x20) != 0) {
joined_r0x080944c8:
    end_00 = start;
    if (end_00 <= html_00) goto LAB_08094528;
  }
  if (html_00 < end_00) {
    parse_html(html_00,end_00,table_elinks->part,(uchar *)0x0,html_context);
    local_34 = table_elinks->bad_html_size;
  }
LAB_08094528:
  width = width + 1;
  goto LAB_0809447d;
LAB_08094854:
  count = table_elinks->cols;
LAB_08094857:
  local_58 = local_58 + 4;
  if ((int)count <= local_60) goto LAB_08094b29;
  local_4c = local_48;
  local_60 = local_60 + 1;
  goto LAB_08094710;
LAB_08094b29:
  if (local_48 == 0x7fffffff) {
    if (0 < (int)count) {
      sVar13 = 0;
      sh = 0xffffffff;
      margin_00 = 0;
      local_44 = 0;
      goto LAB_08094cb9;
    }
    goto LAB_08094f85;
  }
  local_30 = local_48;
  goto LAB_080946f0;
LAB_08094cb9:
  local_44 = local_44 + table_elinks->min_cols_widths[sVar13] + -((int)~sh >> 0x1f);
  margin_00 = margin_00 + table_elinks->max_cols_widths[sVar13] + -((int)~sh >> 0x1f);
  if (table_elinks->max_cols_widths[sVar13] < table_elinks->cols_x[sVar13]) {
    margin_00 = margin_00 + table_elinks->cols_x[sVar13];
  }
  sVar13 = sVar13 + 1;
  if (sVar13 != count) {
    if (sVar13 == 0) goto LAB_08094d0f;
    if (1 < table_elinks->rules - 2U) {
      if ((table_elinks->rules == 4) && ((int)sVar13 < table_elinks->columns_count)) {
        sh = 1;
        uVar4 = table_elinks->columns[sVar13].group;
        goto joined_r0x08094d1b;
      }
      goto LAB_08094d07;
    }
    sh = table_elinks->cellspacing;
    uVar4 = sh;
joined_r0x08094d1b:
    if (uVar4 == 0) {
LAB_08094d07:
      sh = 0;
      if (table_elinks->cellpadding != 0) {
LAB_08094d0f:
        sh = 0xffffffff;
      }
    }
    goto LAB_08094cb9;
  }
LAB_08094d3c:
  get_table_frames(table_elinks,&table_frames);
  table_elinks->min_width =
       ((uint)(table_frames._0_1_ >> 3) & 1) + ((uint)(table_frames._0_1_ >> 2) & 1) + local_44;
  table_elinks->max_width =
       ((uint)(table_frames._0_1_ >> 3) & 1) + ((uint)(table_frames._0_1_ >> 2) & 1) + margin_00;
  if ((assert_failed == 0) && (assert_failed = ZEXT14(margin_00 < local_44), margin_00 < local_44))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
    errline = 0x15f;
    elinks_internal((uchar *)"assertion min <= max failed: min(%d) > max(%d)",local_44,margin_00);
  }
  if ((part->document == (document *)0x0) && ((part->box).x == 0)) {
    if ((*(byte *)&table_elinks->field_0x7c & 1) == 0) {
      width = table_elinks->width;
      margin_00 = table_elinks->max_width;
      if (width < margin_00) {
        table_elinks->max_width = width;
        margin_00 = width;
      }
    }
    else {
      margin_00 = table_elinks->max_width;
    }
    width = table_elinks->min_width;
    if (margin_00 < width) {
      table_elinks->max_width = width;
      margin_00 = width;
    }
    if (part->max_width < margin_00 + align) {
      part->max_width = margin_00 + align;
    }
    align = align + table_elinks->min_width;
    if (align <= (part->box).width) goto LAB_08095bce;
    (part->box).width = align;
    local_30 = table_elinks->link_num;
    goto ret2;
  }
  if (local_74 == 0) {
    margin_00 = table_elinks->min_width;
    margin = table_elinks->width;
    if (margin < margin_00) {
      row = margin_00;
      if (table_elinks->cellpadding == 0) goto LAB_08094dc7;
      table_elinks->cellpadding = 0;
      local_74 = 1;
      p = table_elinks->part;
      local_78 = margin_00;
      goto LAB_08094589;
    }
  }
  else {
    if (local_74 == 1) {
      margin_00 = table_elinks->min_width;
      if (local_78 < margin_00) {
        table_elinks->cellpadding = width;
        local_74 = 2;
        p = table_elinks->part;
        goto LAB_08094589;
      }
      margin = table_elinks->width;
    }
    else {
      margin = table_elinks->width;
      margin_00 = table_elinks->min_width;
    }
  }
  row = margin_00;
  if ((margin_00 < margin) &&
     ((margin <= table_elinks->max_width ||
      (row = table_elinks->max_width, (*(byte *)&table_elinks->field_0x7c & 1) == 0)))) {
    row = margin;
  }
LAB_08094dc7:
  width = table_elinks->cols;
  if (width != 0) {
    if (assert_failed == 0) {
      assert_failed = -(row - margin_00 >> 0x1f);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
        errline = 0x1ed;
        elinks_internal((uchar *)
                        "assertion spare_width >= 0 failed: too small width %d, required %d",row,
                        table_elinks->min_width);
      }
      width = table_elinks->cols;
    }
    iVar14 = 0;
    margin = 0;
    while (iVar14 < width) {
      if (margin < table_elinks->max_cols_widths[iVar14]) {
        margin = table_elinks->max_cols_widths[iVar14];
      }
      iVar14 = iVar14 + 1;
    }
    count = width << 2;
    memcpy(table_elinks->cols_widths,table_elinks->min_cols_widths,count);
    table_elinks->real_width = row;
    __s_00 = (int *)mem_alloc(count);
    if (__s_00 != (int *)0x0) {
      __s = mem_alloc(count);
      if (__s != (void *)0x0) {
        local_3c = 0;
        width = row - margin_00;
LAB_08094e8e:
        local_30 = width;
        if (local_30 != 0) {
          margin_00 = 0;
          memset(__s_00,0,count);
          memset(__s,0,count);
          width = table_elinks->cols;
          local_38 = 0;
          local_48 = 0;
          piVar10 = __s_00;
          while (local_48 < width) {
            switch(local_3c) {
            case 0:
              if (*(int *)((int)table_elinks->cols_x + margin_00) <=
                  *(int *)((int)table_elinks->cols_widths + margin_00)) break;
              *piVar10 = 1;
              width = *(int *)((int)table_elinks->max_cols_widths + margin_00);
              row = *(int *)((int)table_elinks->cols_x + margin_00);
              if (row <= width) {
                width = row;
              }
              width = width - *(int *)((int)table_elinks->cols_widths + margin_00);
              *(int *)((int)__s + margin_00) = width;
              if (0 < width) goto LAB_08095c21;
LAB_08095cb5:
              *piVar10 = 0;
              row = 0;
              width = table_elinks->cols;
              goto LAB_08095c26;
            case 1:
              row = *(int *)((int)table_elinks->cols_x + margin_00);
              if (-2 < row) break;
              *piVar10 = -2 - row;
              piVar9 = table_elinks->max_cols_widths;
LAB_08095c0a:
              width = *(int *)((int)piVar9 + margin_00) -
                      *(int *)((int)table_elinks->cols_widths + margin_00);
              *(int *)((int)__s + margin_00) = width;
              if (width < 1) goto LAB_08095cb5;
              goto LAB_08095c21;
            case 2:
              if (*(int *)((int)table_elinks->cols_x + margin_00) == -1)
              goto switchD_08094f99_caseD_3;
              break;
            case 3:
switchD_08094f99_caseD_3:
              row = *(int *)((int)table_elinks->cols_widths + margin_00);
              iVar14 = *(int *)((int)table_elinks->max_cols_widths + margin_00);
              if (row < iVar14) {
                *(int *)((int)__s + margin_00) = iVar14 - row;
                if (margin == 0) {
                  *piVar10 = 1;
                  row = 1;
                  width = table_elinks->cols;
                }
                else {
                  row = (*(int *)((int)table_elinks->max_cols_widths + margin_00) * 10) / margin + 5
                  ;
                  *piVar10 = row;
                  width = table_elinks->cols;
                }
                goto LAB_08095c26;
              }
              break;
            case 4:
              if (-1 < *(int *)((int)table_elinks->cols_x + margin_00)) {
                *piVar10 = 1;
                piVar9 = table_elinks->cols_x;
                goto LAB_08095c0a;
              }
              break;
            case 5:
              row = *(int *)((int)table_elinks->cols_x + margin_00);
              if (row < 0) {
                if (row == -1) {
                  *piVar10 = 1;
                }
                else {
                  *piVar10 = -2 - row;
                }
                *(undefined4 *)((int)__s + margin_00) = 0x7fffffff;
                row = *piVar10;
                width = table_elinks->cols;
                goto LAB_08095c26;
              }
              break;
            case 6:
              *piVar10 = 1;
              *(undefined4 *)((int)__s + margin_00) = 0x7fffffff;
LAB_08095c21:
              row = *piVar10;
              width = table_elinks->cols;
              goto LAB_08095c26;
            default:
              local_38 = -1;
              goto LAB_08094eff;
            }
            row = *piVar10;
LAB_08095c26:
            local_38 = local_38 + row;
            piVar10 = piVar10 + 1;
            local_48 = local_48 + 1;
            margin_00 = margin_00 + 4;
          }
LAB_08094eff:
          if (assert_failed != 0) {
LAB_080950d4:
            assert_failed = 0;
            goto LAB_080950de;
          }
          assert_failed = ZEXT14(local_38 == -1);
          if (local_38 == -1) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
            errline = 0x203;
            elinks_internal((uchar *)"assertion total_width != -1 failed: Could not expand table");
            if (assert_failed != 0) goto LAB_080950d4;
          }
          width = local_30;
          if (local_38 != 0) {
LAB_08094fa3:
            if (0 < table_elinks->cols) {
              local_48 = -1;
              margin_00 = 0;
              row = 0;
              do {
                if (__s_00[row] == 0) {
LAB_08095000:
                  iVar14 = local_48;
                  iVar16 = margin_00;
                }
                else {
                  iVar7 = (__s_00[row] * local_30) / local_38;
                  iVar14 = *(int *)((int)__s + row * 4);
                  iVar16 = 1;
                  if ((0 < iVar7) && (iVar16 = iVar14, iVar7 <= iVar14)) {
                    iVar16 = iVar7;
                  }
                  iVar14 = row;
                  if (iVar16 <= margin_00) goto LAB_08095000;
                }
                margin_00 = iVar16;
                local_48 = iVar14;
                if (row + 1 == table_elinks->cols) goto LAB_0809500a;
                row = row + 1;
              } while( true );
            }
            goto LAB_08095054;
          }
LAB_08094f2b:
          local_3c = local_3c + 1;
          width = local_30;
          goto LAB_08094e8e;
        }
LAB_080950de:
        mem_free(__s);
      }
      mem_free(__s_00);
    }
  }
  if ((ppVar2->document != (document *)0x0) || ((ppVar2->box).x != 1)) {
    __s_00 = (int *)mem_calloc(table_elinks->cols,4);
    if (__s_00 != (int *)0x0) {
      width = table_elinks->cols;
      local_44 = 0;
      local_34 = width;
      while (local_44 < table_elinks->rows) {
        local_30 = 0;
        while (local_30 < width) {
          ptVar17 = table_elinks->cells + local_44 * table_elinks->real_cols + local_30;
          if (ptVar17->start != (uchar *)0x0) {
            width = ptVar17->colspan;
            if (width < 1) {
              local_38 = table_elinks->cellpadding;
              margin_00 = 0;
            }
            else {
              local_38 = table_elinks->cellpadding;
              margin_00 = 0;
              margin = 0;
              piVar10 = table_elinks->cols_widths + local_30;
              do {
                while( true ) {
                  iVar14 = *piVar10;
                  row = margin + local_30;
                  if ((margin != 0) && (row != 0)) break;
LAB_0809518a:
                  margin = margin + 1;
                  piVar10 = piVar10 + 1;
                  margin_00 = margin_00 + iVar14;
                  if (margin == width) goto LAB_080951f8;
                }
                if (table_elinks->rules - 2U < 2) {
                  if (table_elinks->cellspacing == 0) goto LAB_080951d1;
                  if (-1 < table_elinks->cellspacing) goto LAB_080951d7;
                  goto LAB_0809518a;
                }
                if (((table_elinks->rules != 4) || (table_elinks->columns_count <= row)) ||
                   (table_elinks->columns[row].group == 0)) {
LAB_080951d1:
                  if (local_38 != 0) goto LAB_0809518a;
                }
LAB_080951d7:
                margin = margin + 1;
                piVar10 = piVar10 + 1;
                margin_00 = margin_00 + iVar14 + 1;
              } while (margin != width);
            }
LAB_080951f8:
            ptVar17->width = -1;
            part = format_html_part(html_context,ptVar17->start,ptVar17->end,0,local_38,margin_00,
                                    (document *)0x0,1,1,(uchar *)0x0,ptVar17->link_num);
            if (part != (part *)0x0) {
              ptVar17->width = (part->box).width;
              mem_free(part);
            }
            if (margin_00 < ptVar17->width) {
              ptVar17->width = margin_00;
            }
            width = table_elinks->cols;
          }
          local_30 = local_30 + 1;
          local_34 = width;
        }
        local_44 = local_44 + 1;
      }
      width = 1;
      do {
        local_48 = 0;
        local_4c = 1;
        local_30 = 0x7fffffff;
        while (margin_00 = local_4c + -1, margin_00 < local_34) {
          margin = table_elinks->rows;
          row = local_48 + (int)__s_00;
          local_50 = 0;
          while (local_50 < margin) {
            ptVar17 = table_elinks->cells + local_50 * table_elinks->real_cols + margin_00;
            if (ptVar17->start != (uchar *)0x0) {
              if (assert_failed != 0) {
LAB_080953ca:
                assert_failed = 0;
                goto end;
              }
              bVar5 = table_elinks->cols < margin_00 + ptVar17->colspan;
              assert_failed = ZEXT14(bVar5);
              if (bVar5) {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                errline = 0x26d;
                elinks_internal((uchar *)
                                "assertion cell->colspan + col <= table->cols failed: colspan out of table"
                               );
                if (assert_failed != 0) goto LAB_080953ca;
              }
              iVar14 = ptVar17->colspan;
              if (iVar14 == width) {
                local_3c = 0;
                if (1 < width) {
                  local_44 = 1;
                  local_34 = local_4c;
                  local_38 = local_4c << 4;
                  do {
                    sh = 0;
                    if (local_34 != 0) {
                      if (table_elinks->rules - 2U < 2) {
                        if (table_elinks->cellspacing == 0) {
LAB_080955a9:
                          sh = (uint)(table_elinks->cellpadding == 0);
                        }
                        else {
                          sh = (uint)~table_elinks->cellspacing >> 0x1f;
                        }
                      }
                      else {
                        if (((table_elinks->rules != 4) || (table_elinks->columns_count <= local_34)
                            ) || (sh = 1, *(int *)((int)&table_elinks->columns->group + local_38) ==
                                          0)) goto LAB_080955a9;
                      }
                    }
                    local_44 = local_44 + 1;
                    local_3c = local_3c + sh;
                    local_34 = local_34 + 1;
                    local_38 = local_38 + 0x10;
                  } while (local_44 < width);
                }
                local_3c = ptVar17->width - local_3c;
                margin = 0;
                if (0 < iVar14) {
                  iVar16 = 0;
                  do {
                    margin = margin + *(int *)(row + iVar16 * 4);
                    iVar16 = iVar16 + 1;
                  } while (iVar16 != width);
                }
                if (margin < local_3c) {
                  local_3c = local_3c - margin;
                  margin = local_3c / iVar14;
                  local_3c = local_3c % iVar14;
                  iVar16 = (int)table_elinks->max_cols_widths + local_48;
                  if (iVar16 == 0) {
                    local_34 = local_3c;
                    if (0 < iVar14) {
LAB_08095699:
                      iVar14 = 0;
                      do {
                        *(int *)(row + iVar14 * 4) =
                             (uint)(iVar14 < local_34) + *(int *)(row + iVar14 * 4) + margin;
                        iVar14 = iVar14 + 1;
                      } while (iVar14 != width);
                    }
                  }
                  else {
                    if (0 < iVar14) {
                      local_34 = 0;
                      iVar14 = 0;
                      do {
                        iVar7 = margin + *(int *)(row + iVar14 * 4) + (uint)(iVar14 < local_3c);
                        *(int *)(row + iVar14 * 4) = iVar7;
                        iVar12 = *(int *)(iVar16 + iVar14 * 4);
                        iVar7 = iVar7 - iVar12;
                        if (0 < iVar7) {
                          local_34 = local_34 + iVar7;
                          *(int *)(row + iVar14 * 4) = iVar12;
                        }
                        iVar14 = iVar14 + 1;
                      } while (iVar14 != width);
                      if (local_34 != 0) {
                        margin = local_34 / width;
                        local_34 = local_34 % width;
                        goto LAB_08095699;
                      }
                    }
                  }
                }
              }
              else {
                if ((width < iVar14) && (iVar14 < local_30)) {
                  margin = table_elinks->rows;
                  local_30 = iVar14;
                  goto LAB_08095399;
                }
              }
              margin = table_elinks->rows;
            }
LAB_08095399:
            local_50 = local_50 + 1;
          }
          local_34 = table_elinks->cols;
          local_4c = local_4c + 1;
          local_48 = local_48 + 4;
        }
        width = local_30;
      } while (local_30 != 0x7fffffff);
      margin = 0;
      margin_00 = 0;
      width = 0;
      while (width < local_34) {
        margin_00 = margin_00 + table_elinks->cols_widths[width];
        margin = margin + __s_00[width];
        width = width + 1;
      }
      if (margin <= margin_00) {
        local_30 = 0;
        row = -1;
        width = 0;
        while (width < local_34) {
          iVar14 = table_elinks->max_cols_widths[width];
          iVar16 = width;
          if (table_elinks->max_cols_widths[width] <= row) {
            iVar14 = row;
            iVar16 = local_30;
          }
          local_30 = iVar16;
          row = iVar14;
          width = width + 1;
        }
        if ((row != -1) &&
           (width = __s_00[local_30] + (margin_00 - margin), __s_00[local_30] = width,
           width <= table_elinks->max_cols_widths[local_30])) {
          mem_free(table_elinks->cols_widths);
          table_elinks->cols_widths = __s_00;
          goto LAB_080953df;
        }
      }
end:
      mem_free(__s_00);
    }
LAB_080953df:
    html_00 = (table_elinks->caption).end;
    start = (table_elinks->caption).start;
    if ((html_00 != (byte *)0x0) && (start != (byte *)0x0)) {
      while (start < html_00) {
        ppuVar6 = __ctype_b_loc();
        if ((*(byte *)((int)*ppuVar6 + (uint)*start * 2 + 1) & 0x20) == 0) goto LAB_08096485;
        start = start + 1;
      }
    }
    goto LAB_080953f7;
  }
  width = table_elinks->real_width;
  align = align + width;
  margin_00 = *(int *)((int)(html_context->stack).next + 0x80);
  if ((width <= align) && (width = margin_00, align <= margin_00)) {
    width = align;
  }
  if ((ppVar2->box).width < width) {
LAB_08095302:
    (ppVar2->box).width = width;
  }
LAB_08095305:
  ppVar2->cy = ppVar2->cy + table_elinks->real_height;
  local_30 = table_elinks->link_num;
  goto ret2;
LAB_0809500a:
  if (local_48 == -1) {
LAB_08095054:
    if (local_30 - width == 0) goto LAB_08094f2b;
    width = local_30 - (local_30 - width);
    goto LAB_08094e8e;
  }
  if (width < margin_00) {
    margin_00 = width;
  }
  __s_00[local_48] = 0;
  if ((assert_failed == 0) && (assert_failed = -(margin_00 >> 0x1f), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
    errline = 0x1d4;
    elinks_internal((uchar *)"assertion stretch_width >= 0 failed: shrinking cell");
  }
  table_elinks->cols_widths[local_48] = table_elinks->cols_widths[local_48] + margin_00;
  width = width - margin_00;
  if (width == 0) goto LAB_08094e8e;
  goto LAB_08094fa3;
  while( true ) {
    ppuVar6 = __ctype_b_loc();
    html_00 = end_00 + -1;
    if ((*(byte *)((int)*ppuVar6 + (uint)end_00[-1] * 2 + 1) & 0x20) == 0) break;
LAB_08096485:
    end_00 = html_00;
    if (end_00 <= start) goto LAB_080953f7;
  }
  part = format_html_part(html_context,start,end_00,table_elinks->align,0,table_elinks->real_width,
                          (document *)0x0,0,0,(uchar *)0x0,table_elinks->link_num);
  if (part == (part *)0x0) {
LAB_080953f7:
    width = 0;
  }
  else {
    width = (part->box).height;
    mem_free(part);
  }
  table_elinks->caption_height = width;
  local_34 = 0;
  while (width = table_elinks->rows, local_34 < width) {
    width = table_elinks->cols;
    margin_00 = 0;
    local_30 = 1;
    while (margin_00 < width) {
      ptVar17 = table_elinks->cells + margin_00 + local_34 * table_elinks->real_cols;
      if ((*(byte *)&ptVar17->field_0x3c & 3) == 1) {
        width = ptVar17->colspan;
        if (width < 1) {
          margin = table_elinks->cellpadding;
          local_38 = 0;
        }
        else {
          margin = table_elinks->cellpadding;
          local_44 = local_30 << 4;
          __s_00 = table_elinks->cols_widths + margin_00;
          local_38 = 0;
          local_3c = 0;
          row = local_30;
          do {
            iVar14 = *__s_00;
            if ((local_3c < width + -1) && (row != 0)) {
              if (table_elinks->rules - 2U < 2) {
                if (table_elinks->cellspacing == 0) goto LAB_080954e2;
                if (table_elinks->cellspacing < 0) goto LAB_08095490;
              }
              else {
                if (((table_elinks->rules != 4) || (table_elinks->columns_count <= row)) ||
                   (*(int *)((int)&table_elinks->columns->group + local_44) == 0)) {
LAB_080954e2:
                  if (margin != 0) goto LAB_08095490;
                }
              }
              local_4c = 1;
            }
            else {
LAB_08095490:
              local_4c = 0;
            }
            __s_00 = __s_00 + 1;
            row = row + 1;
            local_3c = local_3c + 1;
            local_38 = local_38 + local_4c + iVar14;
            local_44 = local_44 + 0x10;
          } while (local_3c != width);
        }
        part = format_html_part(html_context,ptVar17->start,ptVar17->end,ptVar17->align,margin,
                                local_38,(document *)0x0,2,2,(uchar *)0x0,ptVar17->link_num);
        if (part == (part *)0x0) goto LAB_0809572f;
        ptVar17->height = (part->box).height;
        mem_free(part);
        width = table_elinks->cols;
      }
      local_30 = local_30 + 1;
      margin_00 = margin_00 + 1;
    }
    local_34 = local_34 + 1;
  }
  margin_00 = 1;
  do {
    local_30 = 0x7fffffff;
    margin = 0;
    while (margin < width) {
      if (0 < table_elinks->cols) {
        local_34 = 0;
        do {
          ptVar17 = table_elinks->cells + table_elinks->real_cols * margin + local_34;
          if ((*(byte *)&ptVar17->field_0x3c & 3) == 1) {
            width = ptVar17->rowspan;
            if (width == margin_00) {
              local_3c = 0;
              if (1 < margin_00) {
                local_38 = 1;
                do {
                  sh = get_hline_width(table_elinks,local_38 + margin);
                  local_38 = local_38 + 1;
                  local_3c = local_3c - ((int)~sh >> 0x1f);
                } while (local_38 < margin_00);
              }
              width = 0;
              __s_00 = table_elinks->rows_heights + margin;
              local_3c = ptVar17->height - local_3c;
              if (0 < margin_00) {
                row = 0;
                do {
                  width = width + __s_00[row];
                  row = row + 1;
                } while (row != margin_00);
              }
              if (width < local_3c) {
                local_3c = local_3c - width;
                if (0 < margin_00) {
                  width = 0;
                  do {
                    __s_00[width] =
                         (uint)(width < local_3c % margin_00) + __s_00[width] + local_3c / margin_00
                    ;
                    width = width + 1;
                  } while (width != margin_00);
                }
              }
              goto LAB_08095833;
            }
            if ((width <= margin_00) || (local_30 <= width)) goto LAB_08095833;
          }
          else {
LAB_08095833:
            width = local_30;
          }
          local_34 = local_34 + 1;
          local_30 = width;
        } while (local_34 < table_elinks->cols);
        width = table_elinks->rows;
      }
      margin = margin + 1;
    }
    margin_00 = local_30;
  } while (local_30 != 0x7fffffff);
  margin = 0;
  get_table_frames(table_elinks,&table_frames);
  width = table_elinks->rows;
  margin_00 = ((uint)table_frames._0_1_ & 1) + ((uint)(table_frames._0_1_ >> 1) & 1) +
              table_elinks->caption_height;
  while (margin < width) {
    margin_00 = margin_00 + table_elinks->rows_heights[margin];
    if (margin != 0) {
      width = get_hline_width(table_elinks,margin);
      if (-1 < width) {
        margin_00 = margin_00 + 1;
      }
      width = table_elinks->rows;
    }
    margin = margin + 1;
  }
  table_elinks->real_height = margin_00;
LAB_0809572f:
  if (ppVar2->document == (document *)0x0) {
    width = align + table_elinks->real_width;
    if ((ppVar2->box).width < width) goto LAB_08095302;
    goto LAB_08095305;
  }
  __s = (ppVar2->document->nodes).next;
  *(int *)((int)__s + 0x14) = (ppVar2->cy + (ppVar2->box).y) - *(int *)((int)__s + 0xc);
  width = table_elinks->real_width;
  state_00 = (html_context->stack).next;
  align = table_elinks->align;
  margin_00 = *(int *)((int)state_00 + 0x80) - width;
  if (align == 1) {
    margin = ((margin_00 - *(int *)((int)state_00 + 0x7c)) + *(int *)((int)state_00 + 0x78)) / 2;
  }
  else {
    if (align == 2) {
      margin = margin_00 - *(int *)((int)state_00 + 0x7c);
    }
    else {
      margin = *(int *)((int)state_00 + 0x78);
    }
  }
  if (margin <= margin_00) {
    margin_00 = margin;
  }
  if (margin_00 < 0) {
    margin_00 = 0;
  }
  margin = (ppVar2->box).y;
  local_40 = ppVar2->cy;
  row = (ppVar2->box).x;
  html_00 = (table_elinks->caption).end;
  start = (table_elinks->caption).start;
  if ((html_00 != (byte *)0x0) && (start != (byte *)0x0)) {
    while ((start < html_00 &&
           (ppuVar6 = __ctype_b_loc(), (*(byte *)((int)*ppuVar6 + (uint)*start * 2 + 1) & 0x20) != 0
           ))) {
      start = start + 1;
    }
    do {
      end_00 = html_00;
      if (end_00 <= start) goto LAB_08095f47;
      ppuVar6 = __ctype_b_loc();
      html_00 = end_00 + -1;
    } while ((*(byte *)((int)*ppuVar6 + (uint)end_00[-1] * 2 + 1) & 0x20) != 0);
    part = format_html_part(html_context,start,end_00,align,0,width,table_elinks->part->document,
                            margin_00 + row,local_40 + margin,(uchar *)0x0,table_elinks->link_num);
    if (part == (part *)0x0) {
      local_40 = ppVar2->cy;
      state_00 = (html_context->stack).next;
    }
    else {
      __s_00 = &table_elinks->part->cy;
      *__s_00 = *__s_00 + (part->box).height;
      table_elinks->part->cx = -1;
      table_elinks->part->link_num = part->link_num;
      mem_free(part);
      local_40 = ppVar2->cy;
      state_00 = (html_context->stack).next;
    }
  }
LAB_08095f47:
  bgcolor = *(color_T *)((int)state_00 + 0x94);
  get_table_frames(table_elinks,&table_frames);
  if (table_elinks->fragment_id != (uchar *)0x0) {
    add_fragment_identifier(html_context,table_elinks->part,table_elinks->fragment_id);
  }
  expand_lines(html_context,table_elinks->part,margin_00 + -1,local_40,table_elinks->real_height,
               bgcolor);
  local_54 = ((uint)(table_frames._0_1_ >> 2) & 1) + margin_00;
  width = table_elinks->cols;
  local_4c = 1;
  local_3c = 0;
  while (local_3c < width) {
    local_58 = 0;
    local_44 = ((uint)table_frames._0_1_ & 1) + local_40;
    local_48 = 1;
    while( true ) {
      width = local_48 + -1;
      if (table_elinks->rows <= width) break;
      align = *(int *)((int)table_elinks->rows_heights + local_58);
      if (width < table_elinks->rows + -1) {
        margin = get_hline_width(table_elinks,local_48);
        local_70 = 1;
        if (margin < 0) goto LAB_08096028;
      }
      else {
LAB_08096028:
        local_70 = 0;
      }
      document = table_elinks->part->document;
      ptVar17 = table_elinks->cells + width * table_elinks->real_cols + local_3c;
      if (ptVar17->start != (uchar *)0x0) {
        width = ptVar17->colspan;
        local_50 = 0;
        if (0 < width) {
          margin = 0;
          __s_00 = table_elinks->cols_widths + local_3c;
          local_50 = 0;
          do {
            row = *__s_00;
            if ((margin < width + -1) && (iVar14 = margin + local_3c + 1, iVar14 != 0)) {
              if (table_elinks->rules - 2U < 2) {
                if (table_elinks->cellspacing == 0) goto LAB_080962a8;
                sh = (uint)~table_elinks->cellspacing >> 0x1f;
              }
              else {
                if (((table_elinks->rules != 4) || (table_elinks->columns_count <= iVar14)) ||
                   (sh = 1, table_elinks->columns[iVar14].group == 0)) {
LAB_080962a8:
                  sh = (uint)(table_elinks->cellpadding == 0);
                }
              }
            }
            else {
              sh = 0;
            }
            margin = margin + 1;
            __s_00 = __s_00 + 1;
            local_50 = local_50 + sh + row;
          } while (margin != width);
        }
        width = ptVar17->rowspan;
        local_30 = 0;
        if (0 < width) {
          local_34 = local_48;
          row = 0;
          margin = local_58;
          do {
            iVar14 = *(int *)((int)table_elinks->rows_heights + margin);
            if (row < width + -1) {
              width = get_hline_width(table_elinks,local_34);
              if (width < 0) {
                width = ptVar17->rowspan;
                goto LAB_080960de;
              }
              iVar16 = 1;
              width = ptVar17->rowspan;
            }
            else {
LAB_080960de:
              iVar16 = 0;
            }
            row = row + 1;
            margin = margin + 4;
            local_34 = local_34 + 1;
            local_30 = local_30 + iVar16 + iVar14;
          } while (row < width);
        }
        state_00 = init_html_parser_state(html_context,ELEMENT_DONT_KILL,ptVar17->align,0,0);
        if ((*(byte *)&ptVar17->field_0x3c & 4) != 0) {
          puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
          *puVar1 = *puVar1 | 1;
        }
        *(color_T *)((int)(html_context->stack).next + 0x14) = ptVar17->bgcolor;
        *(color_T *)((int)(html_context->stack).next + 0x94) = ptVar17->bgcolor;
        if (ptVar17->valign == 1) {
          width = (local_30 - ptVar17->height) / 2 + local_44;
        }
        else {
          width = local_44;
          if (ptVar17->valign == 2) {
            width = (local_44 - ptVar17->height) + local_30;
          }
        }
        margin = local_54;
        if (document != (document *)0x0) {
          margin = local_54 + (table_elinks->part->box).x;
          width = width + (table_elinks->part->box).y;
        }
        part = format_html_part(html_context,ptVar17->start,ptVar17->end,ptVar17->align,
                                table_elinks->cellpadding,local_50,document,margin,width,
                                (uchar *)0x0,ptVar17->link_num);
        if (part == (part *)0x0) {
          done_html_parser_state(html_context,state_00);
        }
        else {
          if ((assert_failed == 0) &&
             (bVar5 = local_30 < ptVar17->height, assert_failed = ZEXT14(bVar5), bVar5)) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
            errline = 0x378;
            elinks_internal((uchar *)"assertion height >= cell->height failed!");
          }
          expand_lines(html_context,table_elinks->part,local_54 + -1 + local_50,local_44,local_30,
                       ptVar17->bgcolor);
          if (ptVar17->fragment_id != (uchar *)0x0) {
            add_fragment_identifier(html_context,part,ptVar17->fragment_id);
          }
          done_html_parser_state(html_context,state_00);
          mem_free(part);
        }
      }
      local_48 = local_48 + 1;
      local_44 = local_44 + align + local_70;
      local_58 = local_58 + 4;
    }
    width = table_elinks->cols;
    if (local_3c < width + -1) {
      sh = 0;
      if (local_4c != 0) {
        if (table_elinks->rules - 2U < 2) {
          if (table_elinks->cellspacing == 0) goto LAB_080963c2;
          sh = (uint)~table_elinks->cellspacing >> 0x1f;
        }
        else {
          if (((table_elinks->rules != 4) || (table_elinks->columns_count <= local_4c)) ||
             (sh = 1, table_elinks->columns[local_4c].group == 0)) {
LAB_080963c2:
            sh = (uint)(table_elinks->cellpadding == 0);
          }
        }
      }
      local_54 = table_elinks->cols_widths[local_3c] + local_54 + sh;
    }
    local_4c = local_4c + 1;
    local_3c = local_3c + 1;
  }
  expand_lines(html_context,table_elinks->part,margin_00 + -1 + table_elinks->real_width,local_40,
               table_elinks->real_height,table_elinks->bgcolor);
  check_html_form_hierarchy(table_elinks->part);
  width = table_elinks->real_height;
  row = 1;
  align = table_elinks->part->cy;
  margin = table_elinks->rows;
  local_40 = ((uint)table_frames._0_1_ & 1) + ((uint)(table_frames._0_1_ >> 1) & 1) +
             table_elinks->caption_height + local_40;
  iVar14 = 0;
  while (iVar14 < margin) {
    iVar16 = table_elinks->rows_heights[iVar14];
    iVar7 = 0;
    if (iVar14 < margin + -1) {
      margin = get_hline_width(table_elinks,row);
      if (margin < 0) {
        margin = table_elinks->rows;
        iVar7 = 0;
      }
      else {
        margin = table_elinks->rows;
        iVar7 = 1;
      }
    }
    iVar14 = iVar14 + 1;
    row = row + 1;
    local_40 = local_40 + iVar7 + iVar16;
  }
  if (assert_failed == 0) {
    align = align + width;
    assert_failed = ZEXT14(align != local_40);
    if (align != local_40) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
      errline = 0x2c0;
      elinks_internal((uchar *)
                      "assertion old_height == our_height failed: size not matching! %d vs %d",align
                      ,local_40);
    }
  }
  draw_table_frames(table_elinks,margin_00,ppVar2->cy,html_context);
  ppVar2->cy = ppVar2->cy + table_elinks->real_height;
  ppVar2->cx = -1;
  ppvVar8 = (void **)mem_alloc(0x18);
  if (ppvVar8 != (void **)0x0) {
    state_00 = *(void **)((int)__s + 0x10);
    pvVar15 = (void *)(ppVar2->cy + (ppVar2->box).y);
    __s = *(void **)((int)__s + 8);
    ppvVar8[5] = (void *)0x0;
    if ((int)__s < 0) {
      __s = (void *)0x0;
    }
    if ((int)pvVar15 < 0) {
      pvVar15 = (void *)0x0;
    }
    pvVar11 = (void *)0x0;
    if (-1 < (int)state_00) {
      pvVar11 = state_00;
    }
    ppvVar8[2] = __s;
    ppvVar8[3] = pvVar15;
    ppvVar8[4] = pvVar11;
    *ppvVar8 = (ppVar2->document->nodes).next;
    *(list_head_elinks **)(ppvVar8 + 1) = &ppVar2->document->nodes;
    *(void ***)&(ppVar2->document->nodes).next = ppvVar8;
    *(void ***)((int)*ppvVar8 + 4) = ppvVar8;
  }
LAB_08095bce:
  local_30 = table_elinks->link_num;
ret2:
  ppVar2->link_num = local_30;
  if ((ppVar2->box).height < ppVar2->cy) {
    (ppVar2->box).height = ppVar2->cy;
  }
  html_context->part = ppVar2;
  done_html_parser_state(html_context,state);
  free_table(table_elinks);
ret0:
  width = html_context->table_level + -1;
  html_context->table_level = width;
  if (width == 0) {
    free_table_cache();
  }
  return;
}



form_control * __regparm3 init_form_control(form_type type,uchar *attr,html_context *html_context)

{
  form_control *pfVar1;
  uchar *puVar2;
  form_mode fVar3;
  
  pfVar1 = (form_control *)mem_calloc(1,0x54);
  if (pfVar1 != (form_control *)0x0) {
    pfVar1->type = type;
    *(uchar **)&pfVar1->position = attr + -(int)html_context->startf;
    puVar2 = get_attr_value(attr,(uchar *)"disabled",html_context->doc_cp,HTML_ATTR_TEST);
    fVar3 = FORM_MODE_DISABLED;
    if (puVar2 == (uchar *)0x0) {
      puVar2 = get_attr_value(attr,(uchar *)"readonly",html_context->doc_cp,HTML_ATTR_TEST);
      fVar3 = (form_mode)(puVar2 != (uchar *)0x0);
    }
    pfVar1->mode = fVar3;
  }
  return pfVar1;
}



void html_textarea(html_context *html_context,uchar *attr,uchar *html,uchar *eof,uchar **end)

{
  byte *pbVar1;
  uint *puVar2;
  uchar uVar3;
  int iVar4;
  form_control *pfVar5;
  uchar *puVar6;
  uchar *chars;
  int iVar7;
  size_t __n;
  document_options *pdVar8;
  int iVar9;
  int iVar10;
  int local_30;
  size_t local_24;
  uchar *local_20 [4];
  
  html_focusable(html_context,attr);
  chars = html;
  if (html < eof) {
    do {
      if ((*html != '\r') && (chars = html, *html != '\n')) break;
      html = html + 1;
      chars = html;
    } while (html < eof);
  }
  do {
    if (eof <= html) {
      *end = eof;
      return;
    }
    if ((*html == '<') &&
       (iVar4 = parse_element(html,eof,local_20,(int *)&local_24,(uchar **)0x0,end), iVar4 == 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
      errline = 0x286;
      iVar4 = elinks_strlcasecmp(local_20[0],local_24,(uchar *)"/TEXTAREA",9,1);
      if (iVar4 == 0) {
        pfVar5 = init_form_control(FC_TEXTAREA,attr,html_context);
        if (pfVar5 == (form_control *)0x0) {
          return;
        }
        puVar6 = get_attr_value(attr,"id",html_context->doc_cp,HTML_ATTR_NONE);
        pfVar5->id = puVar6;
        puVar6 = get_attr_value(attr,"name",html_context->doc_cp,HTML_ATTR_NONE);
        pfVar5->name = puVar6;
        chars = convert_string_elinks
                          ((conv_table *)0x0,chars,(int)(html + -(int)chars),html_context->doc_cp,
                           CSM_DEFAULT,(int *)0x0,(anon_subr_void_void_ptr_uchar_ptr_int *)0x0,
                           (void *)0x0);
        pfVar5->default_value = chars;
        if (chars == (uchar *)0x0) goto LAB_08096848;
        uVar3 = *chars;
        break;
      }
    }
    html = html + 1;
  } while( true );
joined_r0x080967ff:
  if (uVar3 == '\0') goto LAB_08096848;
  puVar6 = chars + 1;
  if (uVar3 == '\r') {
    if ((chars[1] == '\n') || ((pfVar5->default_value < chars && (chars[-1] == '\n')))) {
      __n = strlen((char *)chars);
      memmove(chars,chars + 1,__n);
      puVar6 = chars;
    }
    else {
      *chars = '\n';
      puVar6 = chars + 1;
    }
  }
  if (puVar6 == (uchar *)0x0) goto LAB_08096848;
  uVar3 = *puVar6;
  chars = puVar6;
  goto joined_r0x080967ff;
LAB_08096848:
  iVar4 = get_num(attr,"cols",html_context->doc_cp);
  if (iVar4 < 1) {
    pdVar8 = html_context->options;
    iVar4 = pdVar8->default_form_input_size;
  }
  else {
    pdVar8 = html_context->options;
  }
  iVar9 = (pdVar8->box).width;
  if (iVar4 + 1 <= iVar9) {
    iVar9 = iVar4 + 1;
  }
  pfVar5->cols = iVar9;
  iVar4 = get_num(attr,"rows",html_context->doc_cp);
  if (iVar4 < 1) {
    iVar4 = 1;
  }
  iVar10 = (html_context->options->box).height;
  if (iVar4 <= iVar10) {
    iVar10 = iVar4;
  }
  pfVar5->rows = iVar10;
  pbVar1 = (byte *)&html_context->options->field_0x5c;
  *pbVar1 = *pbVar1 | 1;
  chars = get_attr_value(attr,"wrap",html_context->doc_cp,HTML_ATTR_NONE);
  if (chars == (uchar *)0x0) {
    chars = get_attr_value(attr,(uchar *)"nowrap",html_context->doc_cp,HTML_ATTR_TEST);
    pfVar5->wrap = (uint)(chars == (uchar *)0x0);
  }
  else {
    iVar4 = c_strcasecmp((char *)chars,"hard");
    if ((iVar4 == 0) || (iVar4 = c_strcasecmp((char *)chars,"physical"), iVar4 == 0)) {
      pfVar5->wrap = FORM_WRAP_HARD;
    }
    else {
      iVar4 = c_strcasecmp((char *)chars,"soft");
      if ((iVar4 == 0) || (iVar4 = c_strcasecmp((char *)chars,"virtual"), iVar4 == 0)) {
        pfVar5->wrap = FORM_WRAP_SOFT;
      }
      else {
        iVar4 = c_strcasecmp((char *)chars,"none");
        if ((iVar4 == 0) || (iVar4 = c_strcasecmp((char *)chars,"off"), iVar4 == 0)) {
          pfVar5->wrap = FORM_WRAP_NONE;
        }
      }
    }
    mem_free(chars);
  }
  iVar7 = get_num(attr,(uchar *)"maxlength",html_context->doc_cp);
  iVar4 = 0x7fffffff;
  if (iVar7 != -1) {
    iVar4 = iVar7;
  }
  pfVar5->maxlength = iVar4;
  if (iVar10 < 2) {
    put_chrs(html_context," ",1);
    html_stack_dup(html_context,ELEMENT_KILLABLE);
    *(form_control **)((int)(html_context->stack).next + 0x2c) = pfVar5;
    puVar2 = (uint *)((int)(html_context->stack).next + 0xc);
    *puVar2 = *puVar2 | 1;
    if (0 < iVar10) goto LAB_0809697a;
    kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
  }
  else {
    ln_break(html_context,1);
    html_stack_dup(html_context,ELEMENT_KILLABLE);
    *(form_control **)((int)(html_context->stack).next + 0x2c) = pfVar5;
    puVar2 = (uint *)((int)(html_context->stack).next + 0xc);
    *puVar2 = *puVar2 | 1;
LAB_0809697a:
    local_30 = 0;
    do {
      iVar4 = 0;
      if (0 < iVar9) {
        do {
          iVar4 = iVar4 + 1;
          put_chrs(html_context,"_",1);
        } while (iVar4 < iVar9);
      }
      if (local_30 < iVar10 + -1) {
        ln_break(html_context,1);
      }
      local_30 = local_30 + 1;
    } while (local_30 < iVar10);
    kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
    if (1 < iVar10) {
      ln_break(html_context,1);
      goto LAB_080969f6;
    }
  }
  put_chrs(html_context," ",1);
LAB_080969f6:
  (*html_context->special_f)(html_context,2,pfVar5);
  return;
}



void html_option(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  ushort uVar2;
  uchar *p;
  form_control *pfVar3;
  uchar *src;
  uchar *puVar4;
  string *psVar5;
  int iVar6;
  ushort **ppuVar7;
  byte character;
  form_mode fVar8;
  byte *eof;
  byte *html;
  string str;
  size_t local_28;
  uchar *local_24;
  byte *local_20 [4];
  
  if (*(int *)((int)(html_context->stack).next + 0x48) != 0) {
    p = get_attr_value(a,(uchar *)"value",html_context->doc_cp,HTML_ATTR_NONE);
    if (p == (uchar *)0x0) {
      local_20[0] = a + -1;
      if (a[-1] != '<') {
        eof = a + -2;
        do {
          local_20[0] = eof;
          eof = local_20[0] + -1;
        } while (*local_20[0] != 0x3c);
      }
      psVar5 = init_string(&str);
      if (psVar5 != (string *)0x0) {
        iVar6 = parse_element(local_20[0],html_context->eoff,(uchar **)0x0,(int *)0x0,(uchar **)0x0,
                              local_20);
        if (iVar6 == 0) {
          eof = html_context->eoff;
          html = local_20[0];
joined_r0x08096dce:
          while ((local_20[0] = html, html < eof &&
                 (ppuVar7 = __ctype_b_loc(),
                 (*(byte *)((int)*ppuVar7 + (uint)*html * 2 + 1) & 0x20) != 0))) {
            html = html + 1;
          }
          do {
            p = str.source;
            if (eof <= html) goto end_parse;
            ppuVar7 = __ctype_b_loc();
            p = str.source;
            character = *html;
            uVar2 = (*ppuVar7)[character];
            if (((uVar2 & 0x2000) != 0) || (character == 0x3c)) {
              while ((uVar2 & 0x2000) != 0) {
                html = html + 1;
                if (eof <= html) goto end_parse;
                uVar2 = (*ppuVar7)[*html];
              }
              if (eof <= html) goto end_parse;
              if ((html + -2 <= eof) && ((html[1] == 0x3f || (html[1] == 0x21)))) {
                html = skip_comment(html,eof);
                eof = html_context->eoff;
                goto joined_r0x08096dce;
              }
              iVar6 = parse_element(html,eof,&local_24,(int *)&local_28,(uchar **)0x0,local_20);
              if (iVar6 == 0) goto LAB_08096eca;
              character = *local_20[0];
            }
            if (character == 0) {
              character = 0x20;
            }
            add_char_to_string(&str,character);
            html = local_20[0] + 1;
            eof = html_context->eoff;
            local_20[0] = html;
          } while( true );
        }
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
        errline = 0x235;
        elinks_internal((uchar *)"parse element failed");
        p = str.source;
      }
    }
end_parse:
    pfVar3 = init_form_control(FC_CHECKBOX,a,html_context);
    if (pfVar3 == (form_control *)0x0) {
      if (p != (uchar *)0x0) {
        mem_free(p);
        return;
      }
    }
    else {
      src = get_attr_value(a,"id",html_context->doc_cp,HTML_ATTR_NONE);
      pfVar3->id = src;
      src = *(uchar **)((int)(html_context->stack).next + 0x48);
      puVar4 = (uchar *)0x0;
      if (src != (uchar *)0x0) {
        puVar4 = stracpy(src);
      }
      pfVar3->name = puVar4;
      pfVar3->default_value = p;
      p = get_attr_value(a,"selected",html_context->doc_cp,HTML_ATTR_TEST);
      pfVar3->default_state = (uint)(p != (uchar *)0x0);
      p = get_attr_value(a,(uchar *)"disabled",html_context->doc_cp,HTML_ATTR_TEST);
      fVar8 = FORM_MODE_DISABLED;
      if (p == (uchar *)0x0) {
        fVar8 = *(form_mode *)((int)(html_context->stack).next + 0x4c);
      }
      pfVar3->mode = fVar8;
      put_chrs(html_context," ",1);
      html_stack_dup(html_context,ELEMENT_KILLABLE);
      *(form_control **)((int)(html_context->stack).next + 0x2c) = pfVar3;
      puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
      *puVar1 = *puVar1 | 1;
      put_chrs(html_context,"[ ]",3);
      kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
      put_chrs(html_context," ",1);
      (*html_context->special_f)(html_context,2,pfVar3);
    }
  }
  return;
LAB_08096eca:
  if (5 < (int)local_28) {
    if (*local_24 == '/') {
      local_24 = local_24 + 1;
      local_28 = local_28 - 1;
    }
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
    errline = 0x250;
    iVar6 = elinks_strlcasecmp(local_24,local_28,(uchar *)"OPTION",6,1);
    if (iVar6 == 0) goto end_parse;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
    errline = 0x251;
    iVar6 = elinks_strlcasecmp(local_24,local_28,"SELECT",6,1);
    if (iVar6 == 0) goto end_parse;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
    errline = 0x252;
    iVar6 = elinks_strlcasecmp(local_24,local_28,(uchar *)"OPTGROUP",8,1);
    if (iVar6 == 0) goto end_parse;
  }
  eof = html_context->eoff;
  html = local_20[0];
  goto joined_r0x08096dce;
}



void html_button(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  int cp;
  uchar *p;
  form_type type;
  int iVar2;
  form_control *pfVar3;
  
  cp = html_context->doc_cp;
  html_focusable(html_context,a);
  p = get_attr_value(a,"type",cp,HTML_ATTR_NONE);
  type = FC_SUBMIT;
  if (p != (uchar *)0x0) {
    iVar2 = c_strcasecmp((char *)p,"button");
    type = FC_BUTTON;
    if (iVar2 != 0) {
      iVar2 = c_strcasecmp((char *)p,"reset");
      type = FC_RESET;
      if (iVar2 != 0) {
        iVar2 = c_strcasecmp((char *)p,"submit");
        type = FC_SUBMIT;
        if (iVar2 != 0) {
          mem_free(p);
          return;
        }
      }
    }
    mem_free(p);
  }
  pfVar3 = init_form_control(type,a,html_context);
  if (pfVar3 == (form_control *)0x0) {
    return;
  }
  p = get_attr_value(a,"id",cp,HTML_ATTR_NONE);
  pfVar3->id = p;
  p = get_attr_value(a,"name",cp,HTML_ATTR_NONE);
  pfVar3->name = p;
  p = get_attr_value(a,(uchar *)"value",cp,HTML_ATTR_NONE);
  pfVar3->default_value = p;
  if (p != (uchar *)0x0) goto LAB_0809710a;
  type = pfVar3->type;
  if (type == FC_SUBMIT) {
    p = stracpy((uchar *)"Submit");
    pfVar3->default_value = p;
LAB_080971d2:
    if (p != (uchar *)0x0) goto LAB_0809710a;
  }
  else {
    if (type == FC_RESET) {
      p = stracpy((uchar *)"Reset");
      pfVar3->default_value = p;
      goto LAB_080971d2;
    }
    if (type == FC_BUTTON) {
      p = stracpy((uchar *)"Button");
      pfVar3->default_value = p;
      goto LAB_080971d2;
    }
  }
  p = stracpy("");
  pfVar3->default_value = p;
LAB_0809710a:
  (*html_context->special_f)(html_context,2,pfVar3);
  *(form_control **)((int)(html_context->stack).next + 0x2c) = pfVar3;
  puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
  *puVar1 = *puVar1 | 1;
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void html_input(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  form_control *pfVar2;
  uchar *rel;
  int iVar3;
  int iVar4;
  form_type fVar5;
  size_t len;
  void *pvVar6;
  uchar *puVar7;
  int cp;
  html_attr_flags local_30;
  
  cp = html_context->doc_cp;
  pfVar2 = init_form_control(FC_TEXT,a,html_context);
  if (pfVar2 == (form_control *)0x0) {
    return;
  }
  rel = get_attr_value(a,"type",cp,HTML_ATTR_NONE);
  if (rel != (uchar *)0x0) {
    iVar3 = c_strcasecmp((char *)rel,"text");
    if (iVar3 == 0) {
      pfVar2->type = FC_TEXT;
    }
    else {
      iVar3 = c_strcasecmp((char *)rel,"hidden");
      if (iVar3 == 0) {
        pfVar2->type = FC_HIDDEN;
      }
      else {
        iVar3 = c_strcasecmp((char *)rel,"button");
        if (iVar3 == 0) {
          pfVar2->type = FC_BUTTON;
        }
        else {
          iVar3 = c_strcasecmp((char *)rel,"checkbox");
          if (iVar3 == 0) {
            pfVar2->type = FC_CHECKBOX;
          }
          else {
            iVar3 = c_strcasecmp((char *)rel,"radio");
            if (iVar3 == 0) {
              pfVar2->type = FC_RADIO;
            }
            else {
              iVar3 = c_strcasecmp((char *)rel,"password");
              if (iVar3 == 0) {
                pfVar2->type = FC_PASSWORD;
              }
              else {
                iVar3 = c_strcasecmp((char *)rel,"submit");
                if (iVar3 == 0) {
                  pfVar2->type = FC_SUBMIT;
                }
                else {
                  iVar3 = c_strcasecmp((char *)rel,"reset");
                  if (iVar3 == 0) {
                    pfVar2->type = FC_RESET;
                  }
                  else {
                    iVar3 = c_strcasecmp((char *)rel,"file");
                    if (iVar3 == 0) {
                      pfVar2->type = FC_FILE;
                    }
                    else {
                      iVar3 = c_strcasecmp((char *)rel,"image");
                      if (iVar3 == 0) {
                        pfVar2->type = FC_IMAGE;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mem_free(rel);
  }
  if (pfVar2->type == FC_HIDDEN) {
    local_30 = HTML_ATTR_LITERAL_NL;
LAB_080972a8:
    rel = get_attr_value(a,(uchar *)"value",cp,local_30);
    pfVar2->default_value = rel;
  }
  else {
    if (pfVar2->type != FC_FILE) {
      local_30 = HTML_ATTR_NONE;
      goto LAB_080972a8;
    }
    rel = pfVar2->default_value;
  }
  if (rel == (uchar *)0x0) {
    fVar5 = pfVar2->type;
    if (fVar5 == FC_CHECKBOX) {
      rel = stracpy("on");
      pfVar2->default_value = rel;
LAB_0809778a:
      if (rel != (uchar *)0x0) goto LAB_080972ca;
    }
    else {
      if (fVar5 == FC_SUBMIT) {
        rel = stracpy((uchar *)"Submit");
        pfVar2->default_value = rel;
        goto LAB_0809778a;
      }
      if (fVar5 == FC_RESET) {
        rel = stracpy((uchar *)"Reset");
        pfVar2->default_value = rel;
        goto LAB_0809778a;
      }
      if (fVar5 == FC_BUTTON) {
        rel = stracpy((uchar *)"Button");
        pfVar2->default_value = rel;
        goto LAB_0809778a;
      }
    }
    rel = stracpy("");
    pfVar2->default_value = rel;
  }
LAB_080972ca:
  rel = get_attr_value(a,"id",cp,HTML_ATTR_NONE);
  pfVar2->id = rel;
  rel = get_attr_value(a,"name",cp,HTML_ATTR_NONE);
  pfVar2->name = rel;
  iVar3 = get_num(a,"size",cp);
  pfVar2->size = iVar3;
  if (iVar3 == -1) {
    iVar3 = html_context->options->default_form_input_size;
    pfVar2->size = iVar3;
  }
  pfVar2->size = iVar3 + 1;
  iVar4 = (html_context->options->box).width;
  if (iVar4 < iVar3 + 1) {
    pfVar2->size = iVar4;
  }
  iVar4 = get_num(a,(uchar *)"maxlength",cp);
  iVar3 = 0x7fffffff;
  if (iVar4 != -1) {
    iVar3 = iVar4;
  }
  pfVar2->maxlength = iVar3;
  fVar5 = pfVar2->type;
  if (fVar5 + ~FC_TEXTAREA < 2) {
    rel = get_attr_value(a,(uchar *)"checked",cp,HTML_ATTR_TEST);
    pfVar2->default_state = (uint)(rel != (uchar *)0x0);
    fVar5 = pfVar2->type;
  }
  if (fVar5 == FC_IMAGE) {
    rel = get_attr_value(a,"alt",cp,HTML_ATTR_NONE);
    pfVar2->alt = rel;
    fVar5 = pfVar2->type;
  }
  if (fVar5 == FC_HIDDEN) goto LAB_080974f0;
  put_chrs(html_context," ",1);
  html_stack_dup(html_context,ELEMENT_KILLABLE);
  html_focusable(html_context,a);
  *(form_control **)((int)(html_context->stack).next + 0x2c) = pfVar2;
  pvVar6 = (html_context->stack).next;
  if (*(void **)((int)pvVar6 + 0x28) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar6 + 0x28));
    pvVar6 = (html_context->stack).next;
  }
  rel = get_attr_value(a,"title",html_context->doc_cp,HTML_ATTR_NONE);
  *(uchar **)((int)pvVar6 + 0x28) = rel;
  if (FC_HIDDEN < pfVar2->type) goto LAB_080974c9;
  switch(pfVar2->type) {
  default:
    puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
    *puVar1 = *puVar1 | 1;
    if (0 < pfVar2->size) {
      cp = 0;
      do {
        cp = cp + 1;
        put_chrs(html_context,"_",1);
      } while (cp < pfVar2->size);
    }
    break;
  case FC_TEXTAREA:
  case FC_SELECT:
  case FC_HIDDEN:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
    errline = 0x101;
    elinks_internal((uchar *)"bad control type");
    break;
  case FC_CHECKBOX:
    puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
    *puVar1 = *puVar1 | 1;
    put_chrs(html_context,"[&nbsp;]",8);
    break;
  case FC_RADIO:
    puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
    *puVar1 = *puVar1 | 1;
    put_chrs(html_context,(uchar *)"(&nbsp;)",8);
    break;
  case FC_SUBMIT:
  case FC_RESET:
  case FC_BUTTON:
    puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
    *puVar1 = *puVar1 | 1;
    put_chrs(html_context,(uchar *)"[&nbsp;",7);
    rel = pfVar2->default_value;
    if (rel != (uchar *)0x0) {
LAB_08097499:
      len = strlen((char *)rel);
      put_chrs(html_context,rel,len);
    }
    goto LAB_080974b1;
  case FC_IMAGE:
    pvVar6 = (html_context->stack).next;
    if (*(void **)((int)pvVar6 + 0x24) != (void *)0x0) {
      mem_free(*(void **)((int)pvVar6 + 0x24));
      pvVar6 = (html_context->stack).next;
    }
    *(undefined4 *)((int)pvVar6 + 0x24) = 0;
    rel = get_attr_value(a,"src",html_context->doc_cp,HTML_ATTR_EAT_NL);
    if ((rel != (uchar *)0x0) ||
       (rel = get_attr_value(a,"dynsrc",html_context->doc_cp,HTML_ATTR_EAT_NL), rel != (uchar *)0x0)
       ) {
      pvVar6 = (html_context->stack).next;
      puVar7 = join_urls(html_context->base_href,rel);
      *(uchar **)((int)pvVar6 + 0x24) = puVar7;
      mem_free(rel);
    }
    puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
    *puVar1 = *puVar1 | 1;
    put_chrs(html_context,(uchar *)"[&nbsp;",7);
    rel = pfVar2->alt;
    if ((rel != (uchar *)0x0) || (rel = pfVar2->name, rel != (uchar *)0x0)) goto LAB_08097499;
    put_chrs(html_context,(uchar *)"Submit",6);
LAB_080974b1:
    put_chrs(html_context,(uchar *)"&nbsp;]",7);
  }
LAB_080974c9:
  kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
  put_chrs(html_context," ",1);
LAB_080974f0:
                    // WARNING: Could not recover jumptable at 0x0809750a. Too many branches
                    // WARNING: Treating indirect jump as call
  (*html_context->special_f)();
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void html_form(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uchar uVar1;
  form *pfVar2;
  uchar *rel;
  int iVar3;
  char *pcVar4;
  size_t __n;
  uchar *p;
  uchar *puVar5;
  
  *(byte *)&html_context->field_0x44 = *(byte *)&html_context->field_0x44 | 1;
  pfVar2 = init_form();
  if (pfVar2 == (form *)0x0) {
    return;
  }
  pfVar2->method = FORM_METHOD_GET;
  *(uchar **)&pfVar2->form_num = a + -(int)html_context->startf;
  rel = get_attr_value(a,(uchar *)"method",html_context->doc_cp,HTML_ATTR_NONE);
  if (rel != (uchar *)0x0) {
    iVar3 = c_strcasecmp((char *)rel,"post");
    if (iVar3 == 0) {
      p = get_attr_value(a,(uchar *)"enctype",html_context->doc_cp,HTML_ATTR_NONE);
      pfVar2->method = FORM_METHOD_POST;
      if (p != (uchar *)0x0) {
        iVar3 = c_strcasecmp((char *)p,"multipart/form-data");
        if (iVar3 == 0) {
          pfVar2->method = FORM_METHOD_POST_MP;
        }
        else {
          iVar3 = c_strcasecmp((char *)p,"text/plain");
          if (iVar3 == 0) {
            pfVar2->method = FORM_METHOD_POST_TEXT_PLAIN;
          }
        }
        mem_free(p);
      }
    }
    mem_free(rel);
  }
  rel = get_attr_value(a,(uchar *)"onsubmit",html_context->doc_cp,HTML_ATTR_NONE);
  pfVar2->onsubmit = rel;
  rel = get_attr_value(a,"name",html_context->doc_cp,HTML_ATTR_NONE);
  if (rel != (uchar *)0x0) {
    pfVar2->name = rel;
  }
  rel = get_attr_value(a,"action",html_context->doc_cp,HTML_ATTR_NONE);
  if (rel != (uchar *)0x0) {
    uVar1 = *rel;
    if (uVar1 != '\0') {
      __n = strlen((char *)rel);
      p = rel;
      while (uVar1 == ' ') {
        p = p + 1;
        __n = __n - 1;
        uVar1 = *p;
      }
      if (__n == 0) {
LAB_08097bb3:
        __n = 1;
      }
      else {
        uVar1 = p[__n - 1];
        puVar5 = p + __n;
        while (uVar1 == ' ') {
          __n = __n - 1;
          puVar5[-1] = '\0';
          if (__n == 0) goto LAB_08097bb3;
          uVar1 = puVar5[-2];
          puVar5 = puVar5 + -1;
        }
        __n = __n + 1;
      }
      memmove(rel,p,__n);
      p = join_urls(html_context->base_href,rel);
      pfVar2->action = p;
      mem_free(rel);
      goto LAB_08097b28;
    }
    mem_free(rel);
  }
  rel = get_uri_string(html_context->base_href,
                       (-(uint)(pfVar2->method == FORM_METHOD_GET) & 0xe80) - 0x7e41);
  pfVar2->action = rel;
  if (assert_failed == 0) {
    if ((rel == (uchar *)0x0) || (pcVar4 = strchr((char *)rel,1), pcVar4 == (char *)0x0)) {
      assert_failed = 0;
    }
    else {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
      errline = 99;
      elinks_internal((uchar *)"assertion !form->action || !strchr(form->action, POST_CHAR) failed!"
                     );
      if (assert_failed != 0) goto LAB_08097b28;
    }
    if (((pfVar2->action == (uchar *)0x0) || (pfVar2->method != FORM_METHOD_GET)) ||
       (pcVar4 = strchr((char *)pfVar2->action,0x3f), pcVar4 == (char *)0x0)) {
      assert_failed = 0;
    }
    else {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
      errline = 0x68;
      elinks_internal((uchar *)
                      "assertion !form->action || form->method != FORM_METHOD_GET || !strchr(form->action, \'?\') failed!"
                     );
    }
  }
LAB_08097b28:
  rel = get_target(html_context->options,a);
  if (rel == (uchar *)0x0) {
    rel = stracpy(html_context->base_target);
  }
  pfVar2->target = rel;
                    // WARNING: Could not recover jumptable at 0x08097b5c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*html_context->special_f)();
  return;
}



void html_select(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  uint *puVar1;
  size_t size;
  uchar uVar2;
  byte bVar3;
  bool bVar4;
  bool bVar5;
  uchar *source;
  conv_table *convert_table;
  ushort **ppuVar6;
  uchar *name;
  form_control *pfVar7;
  menu_item *items;
  int iVar8;
  byte *pbVar9;
  uint size_00;
  uint uVar10;
  byte bVar11;
  void *pvVar12;
  uchar **lbls;
  uint uVar13;
  byte *html_00;
  int iVar14;
  byte *charslen;
  size_t sVar15;
  int iVar16;
  byte *chars;
  byte bVar17;
  size_t local_64;
  uint local_60;
  size_t local_5c;
  string orig_lbl;
  string lbl;
  size_t local_30;
  byte *local_2c;
  uchar *local_28;
  uchar *local_24;
  uchar **local_20;
  
  bVar17 = 0;
  source = get_attr_value(a,(uchar *)"multiple",html_context->doc_cp,HTML_ATTR_TEST);
  if (source != (uchar *)0x0) {
    source = get_attr_value(a,"name",html_context->doc_cp,HTML_ATTR_NONE);
    if (source != (uchar *)0x0) {
      html_focusable(html_context,a);
      *(undefined4 *)((int)(html_context->stack).next + 8) = 1;
      pvVar12 = (html_context->stack).next;
      if (*(void **)((int)pvVar12 + 0x48) != (void *)0x0) {
        mem_free(*(void **)((int)pvVar12 + 0x48));
        pvVar12 = (html_context->stack).next;
      }
      *(uchar **)((int)pvVar12 + 0x48) = source;
      pvVar12 = (html_context->stack).next;
      source = get_attr_value(a,(uchar *)"disabled",html_context->doc_cp,HTML_ATTR_TEST);
      *(uint *)((int)pvVar12 + 0x4c) = ~-(uint)(source == (uchar *)0x0) & 2;
    }
    return;
  }
  convert_table = (conv_table *)(*html_context->special_f)(html_context,3,0);
  lbl.source = (uchar *)0x0;
  lbl.length = 0;
  orig_lbl.source = (uchar *)0x0;
  orig_lbl.length = 0;
  local_20 = (uchar **)0x0;
  html_focusable(html_context,a);
  init_menu(&lnk_menu);
  bVar5 = false;
  local_64 = 0xffffffff;
  local_5c = 0;
  local_60 = 0;
  local_2c = html;
LAB_08097e20:
  do {
    chars = local_2c;
    html_00 = local_2c;
    if (eof <= local_2c) {
abort:
      *end = html_00;
      if (lbl.source != (uchar *)0x0) {
        done_string(&lbl);
      }
      if (orig_lbl.source != (uchar *)0x0) {
        done_string(&orig_lbl);
      }
      if (local_20 != (uchar **)0x0) {
        lbls = local_20;
        if (local_5c != 0) {
          iVar14 = 0;
          do {
            if (lbls[iVar14] != (uchar *)0x0) {
              mem_free(lbls[iVar14]);
              lbls = local_20;
            }
            iVar14 = iVar14 + 1;
          } while (iVar14 < (int)local_5c);
        }
        mem_free(lbls);
      }
      destroy_menu(&lnk_menu);
      *end = local_2c;
      return;
    }
    bVar11 = *local_2c;
    bVar3 = bVar11;
    while (bVar3 != 0x3c) {
      html_00 = html_00 + 1;
      if (eof <= html_00) goto abort;
      bVar3 = *html_00;
    }
    if (lbl.source != (uchar *)0x0) {
      charslen = html_00 + -(int)local_2c;
      if (charslen == (byte *)0x0) {
LAB_08098030:
        charslen = (byte *)0x0;
      }
      else {
        ppuVar6 = __ctype_b_loc();
        while ((*(byte *)((int)*ppuVar6 + (uint)bVar11 * 2 + 1) & 0x20) != 0) {
          chars = chars + 1;
          charslen = charslen + -1;
          if (charslen == (byte *)0x0) goto LAB_08098030;
          bVar11 = *chars;
        }
        if (charslen != (byte *)0x0) {
          pbVar9 = chars + (int)charslen;
          do {
            if ((*(byte *)((int)*ppuVar6 + (uint)pbVar9[-1] * 2 + 1) & 0x20) == 0) break;
            pbVar9 = pbVar9 + -1;
            charslen = charslen + -1;
          } while (charslen != (byte *)0x0);
        }
      }
      source = convert_string_elinks
                         (convert_table,chars,(int)charslen,html_context->options->cp,CSM_DEFAULT,
                          (int *)0x0,(anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
      if (source != (uchar *)0x0) {
        add_to_string(&lbl,source);
        mem_free(source);
      }
      if (assert_failed == 0) {
        if ((chars == (byte *)0x0) || ((int)charslen < 0)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_08098078;
        }
        else {
          assert_failed = 0;
        }
        if (charslen != (byte *)0x0) {
          pbVar9 = charslen + orig_lbl.length;
          uVar10 = orig_lbl.length + 0xffU >> 8;
          uVar13 = orig_lbl.length + 0xffU & 0xffffff00;
          size_00 = (uint)(pbVar9 + 0x100) & 0xffffff00;
          if (uVar13 <= size_00 && size_00 + uVar10 * -0x100 != 0) {
            source = (uchar *)mem_realloc(orig_lbl.source,size_00);
            if (source == (uchar *)0x0) goto LAB_08097fca;
            orig_lbl.source = source;
            memset(source + uVar13,0,size_00 + uVar10 * -0x100);
          }
          if (orig_lbl.source != (uchar *)0x0) {
            memcpy(orig_lbl.source + orig_lbl.length,chars,(size_t)charslen);
            orig_lbl.source[(int)pbVar9] = '\0';
            orig_lbl.length = (int)pbVar9;
          }
        }
      }
      else {
LAB_08098078:
        assert_failed = 0;
      }
    }
LAB_08097fca:
    if ((eof < html_00 + 2) || ((html_00[1] != 0x3f && (html_00[1] != 0x21)))) {
      iVar14 = parse_element(html_00,eof,&local_24,(int *)&local_30,&local_28,&local_2c);
      if (iVar14 != 0) {
        local_2c = html_00 + 1;
        goto LAB_08097e20;
      }
      if (local_30 != 0) {
        bVar4 = false;
        if (*local_24 == '/') {
          local_30 = local_30 - 1;
          if (local_30 == 0) goto LAB_08097e20;
          local_24 = local_24 + 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
          errline = 0x19d;
          sVar15 = elinks_strlcasecmp(local_24,local_30,"SELECT",6,1);
          if (sVar15 == 0) {
            add_select_item(&lnk_menu,&lbl,&orig_lbl,local_20,local_5c,local_60);
            *end = local_2c;
            if ((local_5c != 0) && (lbls = (uchar **)mem_calloc(local_5c,4), lbls != (uchar **)0x0))
            {
              pfVar7 = init_form_control(FC_SELECT,a,html_context);
              if (pfVar7 != (form_control *)0x0) {
                source = get_attr_value(a,"id",html_context->doc_cp,HTML_ATTR_NONE);
                pfVar7->id = source;
                source = get_attr_value(a,"name",html_context->doc_cp,HTML_ATTR_NONE);
                pfVar7->name = source;
                if (-1 < (int)local_64) {
                  sVar15 = local_64;
                }
                pfVar7->default_state = sVar15;
                source = stracpy(local_20[sVar15]);
                pfVar7->default_value = source;
                pfVar7->nvalues = local_5c;
                pfVar7->values = local_20;
                items = detach_menu(&lnk_menu);
                pfVar7->menu = items;
                pfVar7->labels = lbls;
                menu_labels(items,"",lbls);
                put_chrs(html_context,"[",1);
                html_stack_dup(html_context,ELEMENT_KILLABLE);
                *(form_control **)((int)(html_context->stack).next + 0x2c) = pfVar7;
                puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
                *puVar1 = *puVar1 | 1;
                iVar16 = 0;
                iVar14 = 0;
                break;
              }
              mem_free(lbls);
            }
            goto abort;
          }
          bVar4 = true;
        }
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
        errline = 0x1a2;
        iVar14 = elinks_strlcasecmp(local_24,local_30,(uchar *)"OPTION",6,1);
        if (iVar14 == 0) {
          add_select_item(&lnk_menu,&lbl,&orig_lbl,local_20,local_5c,local_60);
          if ((!bVar4) &&
             (source = get_attr_value(local_28,(uchar *)"disabled",html_context->doc_cp,
                                      HTML_ATTR_TEST), source == (uchar *)0x0)) {
            sVar15 = local_64;
            if ((local_64 == 0xffffffff) &&
               (source = get_attr_value(local_28,"selected",html_context->doc_cp,HTML_ATTR_TEST),
               sVar15 = local_5c, source == (uchar *)0x0)) {
              sVar15 = local_64;
            }
            local_64 = sVar15;
            source = get_attr_value(local_28,(uchar *)"value",html_context->doc_cp,HTML_ATTR_NONE);
            uVar13 = local_5c + 0xff;
            sVar15 = local_5c + 1;
            uVar10 = local_5c + 0x100 & 0xffffff00;
            if ((uVar13 & 0xffffff00) <= uVar10 && uVar10 + (uVar13 >> 8) * -0x100 != 0) {
              size = (local_5c + 0x100 >> 8) * 0x400;
              lbls = (uchar **)mem_realloc(local_20,size);
              if (lbls == (uchar **)0x0) goto abort;
              local_20 = lbls;
              memset(lbls + (uVar13 & 0xffffff00),0,size + (uVar13 >> 8) * -0x400);
            }
            if (local_20 == (uchar **)0x0) goto abort;
            local_20[local_5c] = source;
            name = get_attr_value(local_28,"label",html_context->doc_cp,HTML_ATTR_NONE);
            if ((name == (uchar *)0x0) ||
               (new_menu_item(&lnk_menu,name,local_5c,0), local_5c = sVar15, source == (uchar *)0x0)
               ) {
              init_string(&lbl);
              init_string(&orig_lbl);
              local_60 = (uint)(name != (uchar *)0x0);
              local_5c = sVar15;
            }
          }
        }
        else {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
          errline = 0x1bf;
          iVar14 = elinks_strlcasecmp(local_24,local_30,(uchar *)"OPTGROUP",8,1);
          if (iVar14 == 0) {
            add_select_item(&lnk_menu,&lbl,&orig_lbl,local_20,local_5c,local_60);
            if (bVar5) {
              new_menu_item(&lnk_menu,(uchar *)0x0,-1,0);
            }
            if ((bVar4) ||
               ((source = get_attr_value(local_28,"label",html_context->doc_cp,HTML_ATTR_NONE),
                source == (uchar *)0x0 && (source = stracpy(""), source == (uchar *)0x0)))) {
              bVar5 = false;
            }
            else {
              new_menu_item(&lnk_menu,source,-1,0);
              bVar5 = true;
            }
          }
        }
      }
      goto LAB_08097e20;
    }
    local_2c = skip_comment(html_00,eof);
  } while( true );
LAB_08098648:
  if ((int)local_5c <= iVar16) {
    iVar16 = 0;
    while (iVar16 < iVar14) {
      iVar16 = iVar16 + 1;
      put_chrs(html_context,"_",1);
    }
    kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
    put_chrs(html_context,"]",1);
    (*html_context->special_f)(html_context,2,pfVar7);
    return;
  }
  source = lbls[iVar16];
  if (source == (uchar *)0x0) {
LAB_0809868e:
    iVar8 = iVar14;
  }
  else {
    if ((*(byte *)&html_context->options->field_0x5c & 0x10) == 0) {
      uVar10 = 0xffffffff;
      do {
        if (uVar10 == 0) break;
        uVar10 = uVar10 - 1;
        uVar2 = *source;
        source = source + (uint)bVar17 * -2 + 1;
      } while (uVar2 != '\0');
      iVar8 = ~uVar10 - 1;
    }
    else {
      iVar8 = utf8_ptr2cells(source,(uchar *)0x0);
    }
    if (iVar8 <= iVar14) goto LAB_0809868e;
  }
  iVar16 = iVar16 + 1;
  iVar14 = iVar8;
  goto LAB_08098648;
}



void html_span(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  return;
}



void html_bold(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  
  puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
  *puVar1 = *puVar1 | 1;
  return;
}



void html_italic(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  
  puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
  *puVar1 = *puVar1 | 2;
  return;
}



void html_underline(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  
  puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
  *puVar1 = *puVar1 | 4;
  return;
}



void html_fixed(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  
  puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
  *puVar1 = *puVar1 | 8;
  return;
}



void html_style_close(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  *(byte *)&html_context->field_0x44 = *(byte *)&html_context->field_0x44 & 0xfb;
  return;
}



void html_html(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  void *pvVar1;
  void *pvVar2;
  int iVar3;
  
  pvVar1 = (html_context->stack).next;
  pvVar2 = (html_context->stack).prev;
  iVar3 = *(int *)((int)pvVar1 + 0x14);
  if (*(int *)((int)pvVar1 + 0x94) != iVar3) {
    *(int *)((int)pvVar1 + 0x94) = iVar3;
    *(int *)((int)pvVar2 + 0x14) = iVar3;
    *(int *)((int)pvVar2 + 0x94) = iVar3;
  }
  return;
}



void html_head(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  return;
}



void html_meta(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  return;
}



void html_title(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  *(undefined4 *)((int)(html_context->stack).next + 0x98) = 1;
  *(undefined4 *)((int)(html_context->stack).next + 8) = 3;
  return;
}



void html_center(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  void *pvVar1;
  
  *(undefined4 *)((int)(html_context->stack).next + 0x74) = 1;
  if (html_context->table_level == 0) {
    pvVar1 = (html_context->stack).next;
    *(undefined4 *)((int)pvVar1 + 0x7c) = 0;
    *(undefined4 *)((int)pvVar1 + 0x78) = 0;
  }
  return;
}



void html_address(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  int *piVar1;
  
  piVar1 = (int *)((int)(html_context->stack).next + 0x78);
  *piVar1 = *piVar1 + 1;
  *(undefined4 *)((int)(html_context->stack).next + 0x74) = 0;
  return;
}



void html_blockquote(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  int *piVar1;
  
  piVar1 = (int *)((int)(html_context->stack).next + 0x78);
  *piVar1 = *piVar1 + 2;
  *(undefined4 *)((int)(html_context->stack).next + 0x74) = 0;
  return;
}



void html_pre(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  void *pvVar2;
  
  puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
  *puVar1 = *puVar1 | 0x20;
  pvVar2 = (html_context->stack).next;
  *(uint *)((int)pvVar2 + 0x78) = (uint)(1 < *(int *)((int)pvVar2 + 0x78));
  *(undefined4 *)((int)(html_context->stack).next + 0x7c) = 0;
  return;
}



void html_xmp(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  uint *puVar1;
  void *pvVar2;
  
  pvVar2 = (html_context->stack).next;
  *(byte *)&html_context->field_0x44 = *(byte *)&html_context->field_0x44 | 2;
  puVar1 = (uint *)((int)pvVar2 + 0xc);
  *puVar1 = *puVar1 | 0x20;
  pvVar2 = (html_context->stack).next;
  *(uint *)((int)pvVar2 + 0x78) = (uint)(1 < *(int *)((int)pvVar2 + 0x78));
  *(undefined4 *)((int)(html_context->stack).next + 0x7c) = 0;
  return;
}



void html_xmp_close(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  *(byte *)&html_context->field_0x44 = *(byte *)&html_context->field_0x44 & 0xfd;
  return;
}



void html_tt(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  return;
}



void html_noscript(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  return;
}



void html_frameset(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  int iVar1;
  document_options *pdVar2;
  html_element *phVar3;
  void *pvVar4;
  uchar *str;
  uchar *str_00;
  void *pvVar5;
  int max_value;
  int local_40;
  frameset_param fp;
  
  phVar3 = search_html_stack(html_context,"BODY");
  if (phVar3 != (html_element *)0x0) {
    return;
  }
  if ((*(byte *)&html_context->options->field_0x44 & 0x10) == 0) {
    return;
  }
  pvVar4 = (*html_context->special_f)(html_context,4,0);
  if (pvVar4 == (void *)0x0) {
    return;
  }
  str = get_attr_value(a,"cols",html_context->doc_cp,HTML_ATTR_NONE);
  if ((str == (uchar *)0x0) && (str = stracpy("100%"), str == (uchar *)0x0)) {
    return;
  }
  str_00 = get_attr_value(a,"rows",html_context->doc_cp,HTML_ATTR_NONE);
  if ((str_00 == (uchar *)0x0) && (str_00 = stracpy("100%"), str_00 == (uchar *)0x0)) {
    mem_free(str);
    return;
  }
  iVar1 = *(int *)((int)(html_context->stack).next + 0xac);
  if (iVar1 == 0) {
    pdVar2 = html_context->options;
    local_40 = (pdVar2->box).height;
    max_value = (pdVar2->box).width;
    *(byte *)&pdVar2->field_0x5c = *(byte *)&pdVar2->field_0x5c | 1;
  }
  else {
    if (*(int *)(iVar1 + 0x10) <= *(int *)(iVar1 + 8)) goto free_and_return;
    iVar1 = iVar1 + (*(int *)(iVar1 + 8) * *(int *)(iVar1 + 0xc) + *(int *)(iVar1 + 4)) * 0x14;
    max_value = *(int *)(iVar1 + 0x20);
    local_40 = *(int *)(iVar1 + 0x24);
  }
  fp.height = (int *)0x0;
  fp.width = (int *)0x0;
  parse_frame_widths(str,max_value,10,&fp.width,&fp.x);
  parse_frame_widths(str_00,local_40,0x10,&fp.height,&fp.y);
  pvVar4 = (html_context->stack).next;
  fp.parent = *(frameset_desc **)((int)pvVar4 + 0xac);
  if ((fp.x != 0) && (fp.y != 0)) {
    pvVar5 = (*html_context->special_f)(html_context,5,&fp);
    *(void **)((int)pvVar4 + 0xac) = pvVar5;
  }
  if (fp.width != (int *)0x0) {
    mem_free(fp.width);
  }
  if (fp.height != (int *)0x0) {
    mem_free(fp.height);
  }
free_and_return:
  mem_free(str);
  mem_free(str_00);
  return;
}



void html_frame(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uchar *rel;
  uchar *src;
  void *pvVar1;
  
  rel = get_attr_value(a,"src",html_context->doc_cp,HTML_ATTR_EAT_NL);
  if (rel == (uchar *)0x0) {
    src = stracpy((uchar *)"about:blank");
  }
  else {
    src = join_urls(html_context->base_href,rel);
    mem_free(rel);
  }
  if (src != (uchar *)0x0) {
    rel = get_attr_value(a,"name",html_context->doc_cp,HTML_ATTR_NONE);
    if (rel != (uchar *)0x0) {
      if (*rel != '\0') goto LAB_08098b84;
      mem_free(rel);
    }
    rel = stracpy(src);
    if (rel != (uchar *)0x0) {
LAB_08098b84:
      if (((*(byte *)&html_context->options->field_0x44 & 0x10) == 0) ||
         (*(int *)((int)(html_context->stack).next + 0xac) == 0)) {
        html_focusable(html_context,a);
        put_link_line("Frame: ",rel,src,"",html_context);
      }
      else {
        pvVar1 = (*html_context->special_f)(html_context,4,0);
        if (pvVar1 != (void *)0x0) {
          (*html_context->special_f)
                    (html_context,6,*(undefined4 *)((int)(html_context->stack).next + 0xac),rel,src)
          ;
        }
      }
      mem_free(rel);
      mem_free(src);
      return;
    }
  }
  return;
}



void html_noframes(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  html_element *phVar1;
  
  if ((*(byte *)&html_context->options->field_0x44 & 0x10) != 0) {
    phVar1 = search_html_stack(html_context,(uchar *)"frameset");
    if ((phVar1 == (html_element *)0x0) || (phVar1->frameset != (frameset_desc *)0x0)) {
      html_skip(html_context,a);
      return;
    }
  }
  return;
}



void html_style(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  *(byte *)&html_context->field_0x44 = *(byte *)&html_context->field_0x44 | 4;
  html_skip(html_context,a);
  return;
}



void html_script(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  html_skip(html_context,a);
  return;
}



void html_dd(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  int *piVar1;
  void *pvVar2;
  int iVar3;
  
  kill_html_stack_until(html_context,0,&DAT_0812e3d8,&DAT_0812f308,0);
  pvVar2 = (html_context->stack).next;
  *(int *)((int)pvVar2 + 0x78) = *(int *)((int)pvVar2 + 0x8c) + 3;
  if (html_context->table_level == 0) {
    piVar1 = (int *)((int)(html_context->stack).next + 0x78);
    *piVar1 = *piVar1 + 5;
    pvVar2 = (html_context->stack).next;
    iVar3 = *(int *)((int)pvVar2 + 0x80) / 2;
    if (*(int *)((int)pvVar2 + 0x78) <= iVar3) goto LAB_08098d6d;
    *(int *)((int)pvVar2 + 0x78) = iVar3;
  }
  pvVar2 = (html_context->stack).next;
LAB_08098d6d:
  *(undefined4 *)((int)pvVar2 + 0x74) = 0;
  return;
}



void html_dt(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  void *pvVar1;
  uchar *puVar2;
  
  kill_html_stack_until(html_context,0,&DAT_0812e3d8,&DAT_0812f308,0);
  *(undefined4 *)((int)(html_context->stack).next + 0x74) = 0;
  pvVar1 = (html_context->stack).next;
  *(undefined4 *)((int)pvVar1 + 0x78) = *(undefined4 *)((int)pvVar1 + 0x8c);
  if ((*(byte *)((int)(html_context->stack).next + 0x90) & 8) == 0) {
    puVar2 = get_attr_value(a,(uchar *)"compact",html_context->doc_cp,HTML_ATTR_TEST);
    if (puVar2 == (uchar *)0x0) {
      ln_break(html_context,2);
      return;
    }
  }
  return;
}



void html_dl(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  uchar *puVar2;
  void *pvVar3;
  int iVar4;
  
  puVar1 = (uint *)((int)(html_context->stack).next + 0x90);
  *puVar1 = *puVar1 & 0xfffffff7;
  puVar2 = get_attr_value(a,(uchar *)"compact",html_context->doc_cp,HTML_ATTR_TEST);
  if (puVar2 != (uchar *)0x0) {
    puVar1 = (uint *)((int)(html_context->stack).next + 0x90);
    *puVar1 = *puVar1 | 8;
  }
  pvVar3 = (html_context->stack).next;
  iVar4 = 0;
  if (*(int *)((int)pvVar3 + 0x84) != 0) {
    *(int *)((int)pvVar3 + 0x78) = *(int *)((int)pvVar3 + 0x78) + 5;
    pvVar3 = (html_context->stack).next;
    iVar4 = *(int *)((int)pvVar3 + 0x84);
  }
  *(int *)((int)pvVar3 + 0x84) = iVar4 + 1;
  *(undefined4 *)((int)(html_context->stack).next + 0x88) = 0;
  *(undefined4 *)((int)(html_context->stack).next + 0x74) = 0;
  pvVar3 = (html_context->stack).next;
  *(undefined4 *)((int)pvVar3 + 0x8c) = *(undefined4 *)((int)pvVar3 + 0x78);
  *(undefined4 *)((int)(html_context->stack).next + 8) = 1;
  if ((*(byte *)((int)(html_context->stack).next + 0x90) & 8) == 0) {
    ln_break(html_context,2);
    *(undefined4 *)((int)(html_context->stack).next + 0xa8) = 2;
  }
  return;
}



void html_td(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  
  kill_html_stack_until
            (html_context,1,&DAT_0812c5c4,&DAT_0812cf4a,&DAT_0812e3d8,0x812d05c,0x812d63e,0);
  puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
  *puVar1 = *puVar1 & 0xfffffffe;
  put_chrs(html_context," ",1);
  return;
}



void html_th(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  
  kill_html_stack_until
            (html_context,1,&DAT_0812c5c4,&DAT_0812cf4a,&DAT_0812e3d8,0x812d05c,0x812d63e,0);
  puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
  *puVar1 = *puVar1 | 1;
  put_chrs(html_context," ",1);
  return;
}



void html_quote_close(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint uVar1;
  
  uVar1 = 0;
  if (html_context->quote_level != 0) {
    uVar1 = html_context->quote_level - 1;
    html_context->quote_level = uVar1;
  }
  put_chrs(html_context,quote_char[uVar1 & 1],1);
  return;
}



void html_quote(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uchar *start;
  
  start = quote_char[html_context->quote_level & 1];
  html_context->quote_level = html_context->quote_level + 1;
  put_chrs(html_context,start,1);
  return;
}



void html_superscript(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  put_chrs(html_context,"^",1);
  return;
}



void html_subscript_close(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  put_chrs(html_context,"]",1);
  return;
}



void html_subscript(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  put_chrs(html_context,"[",1);
  return;
}



void html_ol(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  int *piVar1;
  uchar uVar2;
  int iVar3;
  uchar *p;
  void *pvVar4;
  int iVar5;
  
  piVar1 = (int *)((int)(html_context->stack).next + 0x84);
  *piVar1 = *piVar1 + 1;
  iVar3 = get_num(a,"start",html_context->doc_cp);
  iVar5 = 1;
  if (iVar3 != -1) {
    iVar5 = iVar3;
  }
  *(int *)((int)(html_context->stack).next + 0x88) = iVar5;
  *(undefined4 *)((int)(html_context->stack).next + 0x90) = 1;
  p = get_attr_value(a,"type",html_context->doc_cp,HTML_ATTR_NONE);
  if (p != (uchar *)0x0) {
    uVar2 = *p;
    if ((uVar2 != '\0') && (p[1] == '\0')) {
      if (uVar2 == '1') {
        *(undefined4 *)((int)(html_context->stack).next + 0x90) = 1;
      }
      else {
        if (uVar2 == 'a') {
          *(undefined4 *)((int)(html_context->stack).next + 0x90) = 2;
        }
        else {
          if (uVar2 == 'A') {
            *(undefined4 *)((int)(html_context->stack).next + 0x90) = 3;
          }
          else {
            if (uVar2 == 'r') {
LAB_08099210:
              *(undefined4 *)((int)(html_context->stack).next + 0x90) = 4;
            }
            else {
              if (uVar2 != 'R') {
                if (uVar2 == 'i') goto LAB_08099210;
                if (uVar2 != 'I') goto LAB_0809913a;
              }
              *(undefined4 *)((int)(html_context->stack).next + 0x90) = 5;
            }
          }
        }
      }
    }
LAB_0809913a:
    mem_free(p);
  }
  pvVar4 = (html_context->stack).next;
  piVar1 = (int *)((int)pvVar4 + 0x78);
  *piVar1 = *piVar1 + (uint)(1 < *(int *)((int)pvVar4 + 0x84));
  if (html_context->table_level == 0) {
    pvVar4 = (html_context->stack).next;
    iVar5 = *(int *)((int)pvVar4 + 0x80) / 2;
    if (*(int *)((int)pvVar4 + 0x78) <= iVar5) goto LAB_08099179;
    *(int *)((int)pvVar4 + 0x78) = iVar5;
  }
  pvVar4 = (html_context->stack).next;
LAB_08099179:
  *(undefined4 *)((int)pvVar4 + 0x74) = 0;
  *(undefined4 *)((int)(html_context->stack).next + 8) = 1;
  return;
}



// WARNING: Could not reconcile some variable overlaps

void html_li(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  int *piVar1;
  void *pvVar2;
  uchar *puVar3;
  uint uVar4;
  uint width;
  int len;
  uint uVar5;
  uint uVar6;
  html_element *phVar7;
  char cVar8;
  byte bVar9;
  uint *puVar10;
  uint *puVar11;
  byte *pbVar12;
  int in_GS_OFFSET;
  bool bVar13;
  int local_5c;
  uchar x [7];
  uchar n [32];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if (html_context->was_li != 0) {
    html_context->line_breax = 0;
    ln_break(html_context,1);
  }
  pvVar2 = (html_context->stack).next;
  if (*(int *)((int)pvVar2 + 0x88) == 0) {
    x._0_4_ = 0x626e262a;
    x._4_2_ = 0x7073;
    x[6] = ';';
    width = *(uint *)((int)pvVar2 + 0x90) & 7;
    if (width == 2) {
      x._0_4_ = 0x626e266f;
    }
    else {
      if (width == 3) {
        x._0_4_ = 0x626e262b;
      }
    }
    put_chrs(html_context,x,7);
    piVar1 = (int *)((int)(html_context->stack).next + 0x78);
    *piVar1 = *piVar1 + 2;
    *(undefined4 *)((int)(html_context->stack).next + 0x74) = 0;
  }
  else {
    width = *(uint *)((int)pvVar2 + 0x90) & 7;
    len = get_num(a,(uchar *)"value",html_context->doc_cp);
    if (len != -1) {
      *(int *)((int)(html_context->stack).next + 0x88) = len;
    }
    if (width - 2 < 2) {
      put_chrs(html_context,(uchar *)"&nbsp;",6);
      bVar9 = 0;
      len = *(int *)((int)(html_context->stack).next + 0x88);
      if (len != 0) {
        cVar8 = 'a';
        if (width == 3) {
          cVar8 = 'A';
        }
        width = len - 1;
        bVar9 = cVar8 + (char)width + (char)(width / 0x1a) * -0x1a;
      }
      width = 1;
      n._0_4_ = n._0_4_ & 0xffff0000 | (uint)bVar9;
    }
    else {
      if (width - 4 < 2) {
        uVar5 = *(uint *)((int)(html_context->stack).next + 0x88);
        if (uVar5 < 4000) {
          if (uVar5 == 0) {
            n._0_4_ = CONCAT22(n._2_2_,0x6f);
          }
          else {
            n._0_4_ = n._0_4_ & 0xffffff00;
            local_5c = 0;
            do {
              while( true ) {
                uVar6 = roman_tbl[local_5c].n;
                if (uVar6 <= uVar5) {
                  puVar3 = roman_tbl[local_5c].s;
                  uVar4 = uVar5 - uVar6;
                  do {
                    uVar5 = uVar4;
                    __strcat_chk(n,puVar3,0x20);
                    uVar4 = uVar5 - uVar6;
                  } while (!CARRY4(uVar6,uVar5 - uVar6));
                }
                if (assert_failed != 0) goto LAB_08099600;
                local_5c = local_5c + 1;
                if ((uVar5 != 0) && (roman_tbl[local_5c].n == 0)) break;
                assert_failed = 0;
                if (uVar5 == 0) goto LAB_08099610;
              }
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/general.c";
              errline = 0x34c;
              elinks_internal((uchar *)
                              "assertion !(n && !roman_tbl[i].n) failed: BUG in roman number converter"
                             );
            } while (assert_failed == 0);
LAB_08099600:
            assert_failed = 0;
          }
        }
        else {
          n._0_4_ = 0x2d2d2d;
        }
LAB_08099610:
        pbVar12 = n;
        if ((width == 5) && (n[0] != 0)) {
          do {
            len = c_toupper((uint)n[0]);
            *pbVar12 = (byte)len;
            pbVar12 = pbVar12 + 1;
            n[0] = *pbVar12;
          } while (n[0] != 0);
          width = 0;
        }
        else {
          width = 0;
        }
      }
      else {
        width = *(uint *)((int)(html_context->stack).next + 0x88);
        bVar13 = width < 10;
        if (bVar13) {
          put_chrs(html_context,(uchar *)"&nbsp;",6);
          width = *(uint *)((int)(html_context->stack).next + 0x88);
        }
        elinks_ulongcat(n,(uint *)0x0,width,'\x1f',0,10);
        width = (uint)bVar13;
      }
    }
    puVar11 = (uint *)n;
    do {
      puVar10 = puVar11;
      uVar5 = *puVar10 + 0xfefefeff & ~*puVar10;
      uVar6 = uVar5 & 0x80808080;
      puVar11 = puVar10 + 1;
    } while (uVar6 == 0);
    bVar13 = (uVar5 & 0x8080) == 0;
    bVar9 = (byte)uVar6;
    if (bVar13) {
      bVar9 = (byte)(uVar6 >> 0x10);
    }
    if (bVar13) {
      puVar11 = (uint *)((int)puVar10 + 6);
    }
    len = (int)puVar11 + ((-3 - (uint)CARRY1(bVar9,bVar9)) - (int)n);
    put_chrs(html_context,n,len);
    put_chrs(html_context,".&nbsp;",7);
    pvVar2 = (html_context->stack).next;
    *(int *)((int)pvVar2 + 0x78) = width + 2 + *(int *)((int)pvVar2 + 0x78) + len;
    *(undefined4 *)((int)(html_context->stack).next + 0x74) = 0;
    phVar7 = search_html_stack(html_context,"ol");
    if (phVar7 != (html_element *)0x0) {
      (phVar7->parattr).list_number = *(int *)((int)(html_context->stack).next + 0x88) + 1;
    }
    *(undefined4 *)((int)(html_context->stack).next + 0x88) = 0;
  }
  html_context->putsp = HTML_SPACE_SUPPRESS;
  html_context->line_breax = 2;
  html_context->was_li = 1;
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void html_ul(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  int *piVar1;
  uchar *p;
  int iVar2;
  void *pvVar3;
  
  piVar1 = (int *)((int)(html_context->stack).next + 0x84);
  *piVar1 = *piVar1 + 1;
  *(undefined4 *)((int)(html_context->stack).next + 0x88) = 0;
  *(undefined4 *)((int)(html_context->stack).next + 0x90) = 1;
  p = get_attr_value(a,"type",html_context->doc_cp,HTML_ATTR_NONE);
  if (p != (uchar *)0x0) {
    iVar2 = c_strcasecmp((char *)p,"disc");
    if (iVar2 == 0) {
LAB_080996eb:
      *(undefined4 *)((int)(html_context->stack).next + 0x90) = 2;
    }
    else {
      iVar2 = c_strcasecmp((char *)p,"circle");
      if (iVar2 == 0) goto LAB_080996eb;
      iVar2 = c_strcasecmp((char *)p,"square");
      if (iVar2 == 0) {
        *(undefined4 *)((int)(html_context->stack).next + 0x90) = 3;
      }
    }
    mem_free(p);
  }
  pvVar3 = (html_context->stack).next;
  piVar1 = (int *)((int)pvVar3 + 0x78);
  *piVar1 = *piVar1 + (uint)(1 < *(int *)((int)pvVar3 + 0x84)) + 2;
  if (html_context->table_level == 0) {
    pvVar3 = (html_context->stack).next;
    iVar2 = *(int *)((int)pvVar3 + 0x80) / 2;
    if (*(int *)((int)pvVar3 + 0x78) <= iVar2) goto LAB_0809973a;
    *(int *)((int)pvVar3 + 0x78) = iVar2;
  }
  pvVar3 = (html_context->stack).next;
LAB_0809973a:
  *(undefined4 *)((int)pvVar3 + 0x74) = 0;
  *(undefined4 *)((int)(html_context->stack).next + 8) = 1;
  return;
}



void html_linebrk(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  void *pvVar1;
  uchar *p;
  int iVar2;
  
  p = get_attr_value(a,"align",html_context->doc_cp,HTML_ATTR_NONE);
  if (p == (uchar *)0x0) {
    return;
  }
  iVar2 = c_strcasecmp((char *)p,"left");
  if (iVar2 == 0) {
    *(undefined4 *)((int)(html_context->stack).next + 0x74) = 0;
  }
  else {
    iVar2 = c_strcasecmp((char *)p,"right");
    if (iVar2 == 0) {
      *(undefined4 *)((int)(html_context->stack).next + 0x74) = 2;
      mem_free(p);
      return;
    }
    iVar2 = c_strcasecmp((char *)p,"center");
    if (iVar2 == 0) {
      *(undefined4 *)((int)(html_context->stack).next + 0x74) = 1;
      if (html_context->table_level == 0) {
        pvVar1 = (html_context->stack).next;
        *(undefined4 *)((int)pvVar1 + 0x7c) = 0;
        *(undefined4 *)((int)pvVar1 + 0x78) = 0;
      }
    }
    else {
      iVar2 = c_strcasecmp((char *)p,"justify");
      if (iVar2 == 0) {
        *(undefined4 *)((int)(html_context->stack).next + 0x74) = 3;
      }
    }
  }
  mem_free(p);
  return;
}



void html_tr(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  html_linebrk(html_context,a,html,eof,end);
  return;
}



void html_h(int h,uchar *a,format_align default_align,html_context *html_context,uchar *html,
           uchar *eof,uchar **end)

{
  void *pvVar1;
  int iVar2;
  int iVar3;
  
  pvVar1 = (html_context->stack).next;
  if (*(int *)((int)pvVar1 + 0x74) == 0) {
    *(format_align *)((int)pvVar1 + 0x74) = default_align;
  }
  html_linebrk(html_context,a,html,eof,end);
  pvVar1 = (html_context->stack).next;
  iVar3 = 0;
  if (-1 < h + -2) {
    iVar3 = h + -2;
  }
  iVar2 = *(int *)((int)pvVar1 + 0x74);
  if (iVar2 == 1) {
    *(undefined4 *)((int)pvVar1 + 0x7c) = 0;
    *(undefined4 *)((int)pvVar1 + 0x78) = 0;
    return;
  }
  if (iVar2 == 0) {
    *(int *)((int)pvVar1 + 0x78) = iVar3 * 2;
    *(undefined4 *)((int)(html_context->stack).next + 0x7c) = 0;
  }
  else {
    if (iVar2 == 2) {
      *(undefined4 *)((int)pvVar1 + 0x78) = 0;
      *(int *)((int)(html_context->stack).next + 0x7c) = iVar3 * 2;
      return;
    }
    if (iVar2 == 3) {
      *(int *)((int)pvVar1 + 0x7c) = iVar3 * 2;
      *(int *)((int)pvVar1 + 0x78) = iVar3 * 2;
      return;
    }
  }
  return;
}



void html_h6(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  html_h(6,a,ALIGN_LEFT,html_context,html,eof,end);
  return;
}



void html_h5(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  html_h(5,a,ALIGN_LEFT,html_context,html,eof,end);
  return;
}



void html_h4(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  html_h(4,a,ALIGN_LEFT,html_context,html,eof,end);
  return;
}



void html_h3(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  html_h(3,a,ALIGN_LEFT,html_context,html,eof,end);
  return;
}



void html_h2(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  html_h(2,a,ALIGN_LEFT,html_context,html,eof,end);
  return;
}



void html_h1(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  uint *puVar1;
  
  puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
  *puVar1 = *puVar1 | 1;
  html_h(1,a,ALIGN_CENTER,html_context,html,eof,end);
  return;
}



void html_p(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  int iVar1;
  void *pvVar2;
  
  pvVar2 = (html_context->stack).next;
  iVar1 = html_context->margin;
  if (*(int *)((int)pvVar2 + 0x78) < iVar1) {
    *(int *)((int)pvVar2 + 0x78) = iVar1;
    iVar1 = html_context->margin;
    pvVar2 = (html_context->stack).next;
  }
  if (*(int *)((int)pvVar2 + 0x7c) < iVar1) {
    *(int *)((int)pvVar2 + 0x7c) = iVar1;
  }
  html_linebrk(html_context,a,html,eof,end);
  return;
}



void html_br(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  html_linebrk(html_context,a,html,eof,end);
  if ((*(byte *)&html_context->field_0x44 & 1) == 0) {
    *(byte *)&html_context->field_0x44 = *(byte *)&html_context->field_0x44 | 1;
    return;
  }
  ln_break(html_context,2);
  return;
}



void html_base(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uchar *rel;
  uchar *string;
  uri *puVar1;
  
  rel = get_attr_value(a,"href",html_context->doc_cp,HTML_ATTR_EAT_NL);
  if (rel != (uchar *)0x0) {
    string = join_urls(html_context->base_href,rel);
    if (string == (uchar *)0x0) {
      mem_free(rel);
    }
    else {
      puVar1 = get_uri(string,0);
      mem_free(rel);
      mem_free(string);
      if (puVar1 != (uri *)0x0) {
        done_uri(html_context->base_href);
        html_context->base_href = puVar1;
      }
    }
  }
  rel = get_target(html_context->options,a);
  if (rel != (uchar *)0x0) {
    if (html_context->base_target != (uchar *)0x0) {
      mem_free(html_context->base_target);
    }
    html_context->base_target = rel;
  }
  return;
}



void html_table(html_context *html_context,uchar *attr,uchar *html,uchar *eof,uchar **end)

{
  void *pvVar1;
  int iVar2;
  
  if (((*(byte *)&html_context->options->field_0x44 & 4) != 0) && (html_context->table_level < 10))
  {
    format_table(attr,html,eof,end,html_context);
    ln_break(html_context,2);
    return;
  }
  pvVar1 = (html_context->stack).next;
  iVar2 = html_context->margin;
  *(int *)((int)pvVar1 + 0x78) = iVar2;
  *(int *)((int)pvVar1 + 0x7c) = iVar2;
  *(undefined4 *)((int)(html_context->stack).next + 0x74) = 0;
  html_linebrk(html_context,attr,html,eof,end);
  *(undefined4 *)((int)(html_context->stack).next + 0xc) = 0;
  return;
}



void html_hr(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  uint uVar1;
  int iVar2;
  void *pvVar3;
  int iVar4;
  uchar local_1d [13];
  
  local_1d[0] = -0x33;
  uVar1 = get_num(a,"size",html_context->doc_cp);
  if (uVar1 < 2) {
    local_1d[0] = -0x3c;
  }
  html_stack_dup(html_context,ELEMENT_KILLABLE);
  *(undefined4 *)((int)(html_context->stack).next + 0x74) = 1;
  pvVar3 = (html_context->stack).next;
  if (*(void **)((int)pvVar3 + 0x1c) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar3 + 0x1c));
    pvVar3 = (html_context->stack).next;
  }
  *(undefined4 *)((int)pvVar3 + 0x1c) = 0;
  *(undefined4 *)((int)(html_context->stack).next + 0x2c) = 0;
  html_linebrk(html_context,a,html,eof,end);
  pvVar3 = (html_context->stack).next;
  if (*(int *)((int)pvVar3 + 0x74) == 3) {
    *(undefined4 *)((int)pvVar3 + 0x74) = 1;
    pvVar3 = (html_context->stack).next;
  }
  iVar2 = html_context->margin;
  *(int *)((int)pvVar3 + 0x7c) = iVar2;
  *(int *)((int)pvVar3 + 0x78) = iVar2;
  iVar2 = get_width(a,"width",1,html_context);
  if (iVar2 == -1) {
    pvVar3 = (html_context->stack).next;
    iVar4 = (-*(int *)((int)pvVar3 + 0x78) - *(int *)((int)pvVar3 + 0x7c)) +
            *(int *)((int)pvVar3 + 0x80);
    iVar2 = 0;
    if (-1 < iVar4) {
      iVar2 = iVar4;
    }
  }
  else {
    pvVar3 = (html_context->stack).next;
  }
  *(undefined4 *)((int)pvVar3 + 0xc) = 0x10;
  (*html_context->special_f)(html_context,7,1);
  if (0 < iVar2) {
    do {
      iVar2 = iVar2 + -1;
      put_chrs(html_context,local_1d,1);
    } while (0 < iVar2);
  }
  (*html_context->special_f)(html_context,7,0);
  ln_break(html_context,2);
  kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
  return;
}



void html_handle_body_meta(html_context *html_context,uchar *meta,uchar *eof)

{
  string *psVar1;
  string head;
  
  psVar1 = init_string(&head);
  if (psVar1 != (string *)0x0) {
    scan_http_equiv(meta,eof,&head,(string *)0x0,html_context->options);
    process_head(html_context,head.source);
    done_string(&head);
  }
  return;
}



void html_apply_canvas_bgcolor(html_context *html_context)

{
  void *pvVar1;
  void *pvVar2;
  undefined4 uVar3;
  html_element *phVar4;
  
  if ((*(byte *)&html_context->options->field_0x44 & 1) != 0) {
    css_apply(html_context,(html_element *)(html_context->stack).next,(css_stylesheet *)html_context
              ,&html_context->stack);
  }
  pvVar1 = (html_context->stack).next;
  if (*(int *)((int)pvVar1 + 0x94) != *(int *)((int)pvVar1 + 0x14)) {
    *(byte *)&html_context->field_0x44 = *(byte *)&html_context->field_0x44 | 0x20;
    pvVar2 = (html_context->stack).prev;
    uVar3 = *(undefined4 *)((int)pvVar1 + 0x14);
    *(undefined4 *)((int)pvVar1 + 0x94) = uVar3;
    *(undefined4 *)((int)pvVar2 + 0x14) = uVar3;
    *(undefined4 *)((int)pvVar2 + 0x94) = uVar3;
  }
  if (((*(byte *)&html_context->field_0x44 & 8) != 0) &&
     (*(color_T *)((int)(html_context->stack).next + 0x94) !=
      (html_context->options->default_style).bg)) {
    phVar4 = search_html_stack(html_context,"BODY");
    if (phVar4 == (html_element *)0x0) {
      (*html_context->special_f)(html_context,0xc);
    }
  }
  return;
}



void html_html_close(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  if ((1 < *(uint *)((int)(html_context->stack).next + 8)) &&
     ((*(byte *)&html_context->field_0x44 & 0x20) == 0)) {
    html_apply_canvas_bgcolor(html_context);
    return;
  }
  return;
}



void html_body(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  byte bVar1;
  int iVar2;
  
  get_color(html_context,a,"text",(color_T *)((int)(html_context->stack).next + 0x10));
  get_color(html_context,a,"link",(color_T *)((int)(html_context->stack).next + 0x30));
  get_color(html_context,a,"vlink",(color_T *)((int)(html_context->stack).next + 0x34));
  iVar2 = get_bgcolor(html_context,a,(color_T *)((int)(html_context->stack).next + 0x14));
  if (iVar2 == -1) {
    bVar1 = *(byte *)&html_context->field_0x44;
  }
  else {
    bVar1 = *(byte *)&html_context->field_0x44 | 0x20;
    *(byte *)&html_context->field_0x44 = bVar1;
  }
  *(byte *)&html_context->field_0x44 = bVar1 | 0x10;
  html_apply_canvas_bgcolor(html_context);
  return;
}



void html_font(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  void *pvVar1;
  uchar *p;
  int *piVar2;
  ulong uVar3;
  ulong uVar4;
  int local_34;
  uchar *local_30;
  char *local_20 [4];
  
  p = get_attr_value(a,"size",html_context->doc_cp,HTML_ATTR_NONE);
  if (p != (uchar *)0x0) {
    if (*p == '+') {
      local_30 = p + 1;
      local_34 = 1;
    }
    else {
      local_34 = 0;
      local_30 = p;
      if (*p == '-') {
        local_30 = p + 1;
        local_34 = -1;
      }
    }
    piVar2 = __errno_location();
    *piVar2 = 0;
    uVar3 = strtoul((char *)local_30,local_20,10);
    if (((*piVar2 == 0) && (*local_30 != '\0')) && (*local_20[0] == '\0')) {
      uVar4 = 7;
      if (uVar3 < 8) {
        uVar4 = uVar3;
      }
      if (local_34 == 0) {
        *(ulong *)((int)(html_context->stack).next + 0x18) = uVar4;
      }
      else {
        piVar2 = (int *)((int)(html_context->stack).next + 0x18);
        *piVar2 = *piVar2 + uVar4 * local_34;
      }
      pvVar1 = (html_context->stack).next;
      if (*(int *)((int)pvVar1 + 0x18) < 1) {
        *(undefined4 *)((int)pvVar1 + 0x18) = 1;
      }
      else {
        if (7 < *(int *)((int)pvVar1 + 0x18)) {
          *(undefined4 *)((int)pvVar1 + 0x18) = 7;
        }
      }
    }
    mem_free(p);
  }
  get_color(html_context,a,"color",(color_T *)((int)(html_context->stack).next + 0x10));
  return;
}



uchar * __regparm3 truncate_label(uchar *label,int max_len)

{
  size_t sVar1;
  size_t __n;
  size_t __n_00;
  size_t sVar2;
  uchar *__dest;
  
  __dest = (uchar *)0x0;
  sVar1 = strlen((char *)label);
  if (-1 < max_len) {
    if ((max_len < (int)sVar1) && (max_len != 0)) {
      __n = max_len / 2;
      __n_00 = __n - 1;
      if ((int)(__n * 2 + 1) <= max_len) {
        __n_00 = __n;
      }
      __dest = (uchar *)mem_alloc(max_len + 1);
      if (__dest != (uchar *)0x0) {
        sVar2 = 0;
        if (__n != 0) {
          memcpy(__dest,label,__n);
          sVar2 = __n;
        }
        __dest[sVar2] = '*';
        if (__n_00 != 0) {
          memcpy(__dest + sVar2 + 1,label + (sVar1 - __n_00),__n_00);
        }
        __dest[max_len] = '\0';
      }
    }
    else {
      __dest = stracpy(label);
    }
  }
  return __dest;
}



uchar * __regparm3 get_image_filename_from_src(int max_len,uchar *src)

{
  uchar *puVar1;
  int iVar2;
  uchar *src_00;
  uchar *puVar3;
  
  if (src != (uchar *)0x0) {
    if ((*src == '\0') || (*src == '?')) {
      iVar2 = 0;
      src_00 = src;
    }
    else {
      iVar2 = 0;
      do {
        iVar2 = iVar2 + 1;
        if (src[iVar2] == '\0') break;
      } while (src[iVar2] != '?');
      puVar3 = src + iVar2;
      do {
        src_00 = puVar3;
        if (puVar3 <= src) break;
        puVar1 = puVar3 + -1;
        puVar3 = puVar3 + -1;
      } while (*puVar1 != '/');
    }
    src_00 = memacpy(src_00,(int)(src + (iVar2 - (int)src_00)));
    if (src_00 != (uchar *)0x0) {
      puVar3 = truncate_label(src_00,max_len);
      mem_free(src_00);
      return puVar3;
    }
  }
  return (uchar *)0x0;
}



void __regparm3 put_image_label(uchar *a,uchar *label,html_context *html_context)

{
  void *pvVar1;
  undefined4 uVar2;
  size_t len;
  
  html_focusable(html_context,a);
  pvVar1 = (html_context->stack).next;
  uVar2 = *(undefined4 *)((int)pvVar1 + 0x10);
  *(undefined4 *)((int)pvVar1 + 0x10) = *(undefined4 *)((int)pvVar1 + 0x3c);
  len = strlen((char *)label);
  put_chrs(html_context,label,len);
  *(undefined4 *)((int)(html_context->stack).next + 0x10) = uVar2;
  return;
}



void __regparm3 html_img_do(uchar *a,uchar *object_src,html_context *html_context)

{
  uint *puVar1;
  document_options *pdVar2;
  int iVar3;
  bool bVar4;
  bool bVar5;
  bool bVar6;
  uchar *rel;
  uchar *label;
  void *pvVar7;
  size_t sVar8;
  uchar *local_20;
  
  pdVar2 = html_context->options;
  iVar3 = (pdVar2->image_link).display_style;
  rel = get_attr_value(a,"usemap",html_context->doc_cp,HTML_ATTR_NONE);
  bVar5 = false;
  if (rel != (uchar *)0x0) {
    label = join_urls(html_context->base_href,rel);
    mem_free(rel);
    if (label == (uchar *)0x0) {
      return;
    }
    rel = straconcat("MAP@",label,0);
    mem_free(label);
    if (rel == (uchar *)0x0) {
      return;
    }
    html_stack_dup(html_context,ELEMENT_KILLABLE);
    pvVar7 = (html_context->stack).next;
    if (*(void **)((int)pvVar7 + 0x1c) != (void *)0x0) {
      mem_free(*(void **)((int)pvVar7 + 0x1c));
      pvVar7 = (html_context->stack).next;
    }
    *(uchar **)((int)pvVar7 + 0x1c) = rel;
    *(undefined4 *)((int)(html_context->stack).next + 0x2c) = 0;
    puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
    *puVar1 = *puVar1 | 1;
    bVar5 = true;
  }
  if (((*(int *)((int)(html_context->stack).next + 0x1c) == 0) ||
      (rel = get_attr_value(a,(uchar *)"ismap",html_context->doc_cp,HTML_ATTR_TEST),
      rel == (uchar *)0x0)) || (bVar4 = true, bVar5)) {
    bVar4 = false;
  }
  rel = (uchar *)0x0;
  if (((iVar3 - 2U < 2) &&
      ((rel = get_attr_value(a,"alt",html_context->doc_cp,HTML_ATTR_NONE), rel != (uchar *)0x0 ||
       (rel = get_attr_value(a,"title",html_context->doc_cp,HTML_ATTR_NONE), rel != (uchar *)0x0))))
     && (sVar8 = strlen((char *)rel), 5 < sVar8)) {
    clr_spaces(rel);
  }
  if (((object_src == (uchar *)0x0) || (local_20 = stracpy(object_src), local_20 == (uchar *)0x0))
     && (local_20 = get_attr_value(a,"src",html_context->doc_cp,HTML_ATTR_EAT_NL),
        local_20 == (uchar *)0x0)) {
    local_20 = get_attr_value(a,"dynsrc",html_context->doc_cp,HTML_ATTR_EAT_NL);
  }
  if (rel != (uchar *)0x0) {
    if (*rel == '\0') {
      mem_free(rel);
      goto LAB_0809a720;
    }
    label = truncate_label(rel,(pdVar2->image_link).label_maxlen);
    mem_free(rel);
    bVar6 = false;
    goto LAB_0809a5ae;
  }
LAB_0809a720:
  if (((*(byte *)&pdVar2->field_0x44 & 0x20) == 0) &&
     (*(int *)((int)(html_context->stack).next + 0x1c) == 0)) goto LAB_0809a6e7;
  if (bVar5) {
    label = stracpy((uchar *)"USEMAP");
    bVar6 = true;
LAB_0809a5ae:
    if (label == (uchar *)0x0) goto LAB_0809a5bf;
    if (*label == '\0') {
      mem_free(label);
      goto LAB_0809a5bf;
    }
  }
  else {
    if (bVar4) {
      label = stracpy((uchar *)"ISMAP");
      bVar6 = true;
      goto LAB_0809a5ae;
    }
    if (iVar3 == 3) {
      label = get_image_filename_from_src((pdVar2->image_link).filename_maxlen,local_20);
      bVar6 = true;
      goto LAB_0809a5ae;
    }
LAB_0809a5bf:
    if ((iVar3 == 1) &&
       (label = get_image_filename_from_src((pdVar2->image_link).filename_maxlen,local_20),
       label != (uchar *)0x0)) {
      bVar6 = true;
      if (*label != '\0') goto LAB_0809a5de;
      mem_free(label);
    }
    label = stracpy("IMG");
    bVar6 = true;
  }
LAB_0809a5de:
  pvVar7 = (html_context->stack).next;
  if (*(void **)((int)pvVar7 + 0x24) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar7 + 0x24));
    pvVar7 = (html_context->stack).next;
  }
  *(undefined4 *)((int)pvVar7 + 0x24) = 0;
  pvVar7 = (html_context->stack).next;
  if (*(void **)((int)pvVar7 + 0x28) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar7 + 0x28));
    pvVar7 = (html_context->stack).next;
  }
  *(undefined4 *)((int)pvVar7 + 0x28) = 0;
  if (label != (uchar *)0x0) {
    iVar3 = (pdVar2->image_link).tagging;
    if ((iVar3 != 0) &&
       (((bVar6 || (iVar3 == 2)) &&
        (rel = straconcat((pdVar2->image_link).prefix,label,(pdVar2->image_link).suffix,0),
        rel != (uchar *)0x0)))) {
      mem_free(label);
      label = rel;
    }
    if ((*(byte *)&(pdVar2->image_link).field_0x18 & 1) == 0) {
      put_image_label(a,label,html_context);
    }
    else {
      if (local_20 != (uchar *)0x0) {
        pvVar7 = (html_context->stack).next;
        rel = join_urls(html_context->base_href,local_20);
        *(uchar **)((int)pvVar7 + 0x24) = rel;
      }
      pvVar7 = (html_context->stack).next;
      rel = get_attr_value(a,"title",html_context->doc_cp,HTML_ATTR_NONE);
      *(uchar **)((int)pvVar7 + 0x28) = rel;
      if (bVar4) {
        html_stack_dup(html_context,ELEMENT_KILLABLE);
        rel = straconcat(*(uchar **)((int)(html_context->stack).next + 0x1c),&DAT_0812c60d,0);
        if (rel != (uchar *)0x0) {
          pvVar7 = (html_context->stack).next;
          if (*(void **)((int)pvVar7 + 0x1c) != (void *)0x0) {
            mem_free(*(void **)((int)pvVar7 + 0x1c));
            pvVar7 = (html_context->stack).next;
          }
          *(uchar **)((int)pvVar7 + 0x1c) = rel;
        }
        put_image_label(a,label,html_context);
        kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
      }
      else {
        put_image_label(a,label,html_context);
      }
      pvVar7 = (html_context->stack).next;
      if (*(void **)((int)pvVar7 + 0x24) != (void *)0x0) {
        mem_free(*(void **)((int)pvVar7 + 0x24));
        pvVar7 = (html_context->stack).next;
      }
      *(undefined4 *)((int)pvVar7 + 0x24) = 0;
      pvVar7 = (html_context->stack).next;
      if (*(void **)((int)pvVar7 + 0x28) != (void *)0x0) {
        mem_free(*(void **)((int)pvVar7 + 0x28));
        pvVar7 = (html_context->stack).next;
      }
      *(undefined4 *)((int)pvVar7 + 0x28) = 0;
    }
    mem_free(label);
  }
LAB_0809a6e7:
  if (local_20 != (uchar *)0x0) {
    mem_free(local_20);
  }
  if (bVar5) {
    kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
  }
  return;
}



void html_img(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  html_img_do(a,(uchar *)0x0,html_context);
  return;
}



void put_link_line(uchar *prefix,uchar *linkname,uchar *link,uchar *target,
                  html_context *html_context)

{
  void *pvVar1;
  size_t len;
  uchar *puVar2;
  
  *(byte *)&html_context->field_0x44 = *(byte *)&html_context->field_0x44 | 8;
  html_stack_dup(html_context,ELEMENT_KILLABLE);
  ln_break(html_context,1);
  pvVar1 = (html_context->stack).next;
  if (*(void **)((int)pvVar1 + 0x1c) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar1 + 0x1c));
    pvVar1 = (html_context->stack).next;
  }
  *(undefined4 *)((int)pvVar1 + 0x1c) = 0;
  pvVar1 = (html_context->stack).next;
  if (*(void **)((int)pvVar1 + 0x20) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar1 + 0x20));
    pvVar1 = (html_context->stack).next;
  }
  *(undefined4 *)((int)pvVar1 + 0x20) = 0;
  pvVar1 = (html_context->stack).next;
  if (*(void **)((int)pvVar1 + 0x28) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar1 + 0x28));
    pvVar1 = (html_context->stack).next;
  }
  *(undefined4 *)((int)pvVar1 + 0x28) = 0;
  *(undefined4 *)((int)(html_context->stack).next + 0x2c) = 0;
  len = strlen((char *)prefix);
  put_chrs(html_context,prefix,len);
  pvVar1 = (html_context->stack).next;
  puVar2 = join_urls(html_context->base_href,link);
  *(uchar **)((int)pvVar1 + 0x1c) = puVar2;
  pvVar1 = (html_context->stack).next;
  puVar2 = stracpy(target);
  *(uchar **)((int)pvVar1 + 0x20) = puVar2;
  pvVar1 = (html_context->stack).next;
  *(undefined4 *)((int)pvVar1 + 0x10) = *(undefined4 *)((int)pvVar1 + 0x30);
  len = strlen((char *)linkname);
  put_chrs(html_context,linkname,len);
  ln_break(html_context,1);
  kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
  return;
}



void html_link(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  hlink_type hVar1;
  bool bVar2;
  lt_default_name *plVar3;
  int iVar4;
  lt_default_name *plVar5;
  string *psVar6;
  uchar *source;
  char *prefix;
  size_t len;
  int iVar7;
  int iVar8;
  uchar *unterminated_url;
  hlink *phVar9;
  byte bVar10;
  hlink link;
  string text;
  
  bVar10 = 0;
  iVar7 = html_context->options->meta_link_display;
  if ((assert_failed == 0) && (assert_failed = ZEXT14(a == (uchar *)0x0), a == (uchar *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/link.c";
    errline = 0x2e0;
    elinks_internal((uchar *)"assertion a && link failed!");
  }
  iVar8 = 9;
  phVar9 = &link;
  while (iVar8 != 0) {
    iVar8 = iVar8 + -1;
    phVar9->type = LT_UNKNOWN;
    phVar9 = (hlink *)((int)phVar9 + (uint)bVar10 * -8 + 4);
  }
  link.href = get_attr_value(a,"href",html_context->doc_cp,HTML_ATTR_EAT_NL);
  if (link.href == (uchar *)0x0) {
    return;
  }
  link.lang = get_attr_value(a,"lang",html_context->doc_cp,HTML_ATTR_NONE);
  link.hreflang = get_attr_value(a,(uchar *)"hreflang",html_context->doc_cp,HTML_ATTR_NONE);
  link.title = get_attr_value(a,"title",html_context->doc_cp,HTML_ATTR_NONE);
  link.content_type = get_attr_value(a,"type",html_context->doc_cp,HTML_ATTR_NONE);
  link.media = get_attr_value(a,"media",html_context->doc_cp,HTML_ATTR_NONE);
  link.name = get_attr_value(a,"rel",html_context->doc_cp,HTML_ATTR_NONE);
  if (link.name == (uchar *)0x0) {
    link.name = get_attr_value(a,"rev",html_context->doc_cp,HTML_ATTR_NONE);
    hVar1 = link.type;
    if (link.name != (uchar *)0x0) {
      link.direction = LD_REV;
      goto LAB_0809ac39;
    }
  }
  else {
    link.direction = LD_REL;
LAB_0809ac39:
    if (lt_names[0].str != (uchar *)0x0) {
      iVar8 = 0;
      unterminated_url = lt_names[0].str;
      do {
        iVar4 = c_strcasecmp((char *)link.name,(char *)unterminated_url);
        if (iVar4 == 0) {
          hVar1 = lt_names[iVar8].type;
          goto LAB_0809ac7f;
        }
        iVar8 = iVar8 + 1;
        unterminated_url = lt_names[iVar8].str;
      } while (unterminated_url != (uchar *)0x0);
    }
    prefix = c_strcasestr((char *)link.name,"icon");
    if ((prefix == (char *)0x0) &&
       ((link.content_type == (uchar *)0x0 ||
        (prefix = c_strcasestr((char *)link.content_type,"icon"), prefix == (char *)0x0)))) {
      prefix = c_strcasestr((char *)link.name,"alternate");
      if (prefix == (char *)0x0) {
        hVar1 = link.type;
        if (link.content_type != (uchar *)0x0) {
          prefix = c_strcasestr((char *)link.content_type,"css");
          hVar1 = LT_STYLESHEET;
          if (prefix == (char *)0x0) {
            hVar1 = link.type;
          }
        }
      }
      else {
        link.type = LT_ALTERNATE;
        if (link.lang == (uchar *)0x0) {
          prefix = c_strcasestr((char *)link.name,"stylesheet");
          if ((prefix == (char *)0x0) &&
             ((link.content_type == (uchar *)0x0 ||
              (prefix = c_strcasestr((char *)link.content_type,"css"), prefix == (char *)0x0)))) {
            hVar1 = LT_ALTERNATE_MEDIA;
            if (link.media == (uchar *)0x0) {
              hVar1 = link.type;
            }
          }
          else {
            link.type = LT_ALTERNATE_STYLESHEET;
            hVar1 = link.type;
          }
        }
        else {
          link.type = LT_ALTERNATE_LANG;
          hVar1 = link.type;
        }
      }
    }
    else {
      link.type = LT_ICON;
      hVar1 = link.type;
    }
  }
LAB_0809ac7f:
  link.type = hVar1;
  unterminated_url = link.href;
  if (link.href == (uchar *)0x0) goto LAB_0809ae88;
  if (link.type == LT_STYLESHEET) {
    len = strlen((char *)link.href);
    import_css_stylesheet
              ((css_stylesheet *)html_context,html_context->base_href,unterminated_url,len);
  }
  if ((iVar7 == 0) ||
     ((iVar7 < 5 &&
      (((link.type + ~LT_COPYRIGHT < 2 || (link.type == LT_STYLESHEET)) ||
       (link.type == LT_ALTERNATE_STYLESHEET)))))) goto LAB_0809ae88;
  if ((link.name == (uchar *)0x0) || (unterminated_url = link.name, link.type != LT_UNKNOWN)) {
    if (assert_failed == 0) {
      assert_failed = 0;
    }
    if (lt_names[0].str == (uchar *)0x0) {
LAB_0809acf8:
      unterminated_url = (uchar *)"unknown";
    }
    else {
      plVar3 = lt_names;
      unterminated_url = lt_names[0].str;
      hVar1 = lt_names[0].type;
      while (hVar1 != link.type) {
        plVar5 = plVar3 + 1;
        if ((plVar5 == (lt_default_name *)0x0) ||
           (unterminated_url = plVar3[1].str, unterminated_url == (uchar *)0x0)) goto LAB_0809acf8;
        hVar1 = plVar5->type;
        plVar3 = plVar5;
      }
    }
  }
  psVar6 = init_string(&text);
  if (psVar6 == (string *)0x0) goto LAB_0809ae88;
  html_focusable(html_context,a);
  if (link.title == (uchar *)0x0) {
    add_to_string(&text,unterminated_url);
    iVar8 = 0;
  }
  else {
    add_to_string(&text,link.title);
    iVar8 = strcmp((char *)link.title,(char *)unterminated_url);
  }
  if (iVar7 != 1) {
    if (iVar8 != 0) {
      add_to_string(&text," (");
      add_to_string(&text,unterminated_url);
    }
    bVar2 = iVar8 == 0;
    if (2 < iVar7) {
      if (link.hreflang != (uchar *)0x0) {
        source = ", ";
        if (bVar2) {
          source = " (";
        }
        bVar2 = false;
        add_to_string(&text,source);
        add_to_string(&text,link.hreflang);
      }
      if ((iVar7 != 3) && (link.content_type != (uchar *)0x0)) {
        source = ", ";
        if (bVar2) {
          source = " (";
        }
        bVar2 = false;
        add_to_string(&text,source);
        add_to_string(&text,link.content_type);
      }
    }
    if (((link.lang != (uchar *)0x0) && (link.type == LT_ALTERNATE_LANG)) &&
       ((iVar7 < 3 ||
        ((link.hreflang != (uchar *)0x0 &&
         (iVar7 = c_strcasecmp((char *)link.hreflang,(char *)link.lang), iVar7 != 0)))))) {
      source = ", ";
      if (bVar2) {
        source = " (";
      }
      bVar2 = false;
      add_to_string(&text,source);
      add_to_string(&text,link.lang);
    }
    if (link.media == (uchar *)0x0) {
      if (bVar2) goto put_link_line;
    }
    else {
      source = " (";
      if (!bVar2) {
        source = ", ";
      }
      add_to_string(&text,source);
      add_to_string(&text,link.media);
    }
    add_char_to_string(&text,')');
  }
put_link_line:
  prefix = "Link: ";
  if (link.direction != LD_REL) {
    prefix = "Reverse link: ";
  }
  if (text.length != 0) {
    unterminated_url = text.source;
  }
  put_link_line((uchar *)prefix,unterminated_url,link.href,html_context->base_target,html_context);
  if (text.source != (uchar *)0x0) {
    done_string(&text);
  }
LAB_0809ae88:
  if (assert_failed == 0) {
    assert_failed = 0;
  }
  if (link.content_type != (uchar *)0x0) {
    mem_free(link.content_type);
  }
  if (link.media != (uchar *)0x0) {
    mem_free(link.media);
  }
  if (link.href != (uchar *)0x0) {
    mem_free(link.href);
  }
  if (link.hreflang != (uchar *)0x0) {
    mem_free(link.hreflang);
  }
  if (link.title != (uchar *)0x0) {
    mem_free(link.title);
  }
  if (link.lang != (uchar *)0x0) {
    mem_free(link.lang);
  }
  if (link.name != (uchar *)0x0) {
    mem_free(link.name);
  }
  return;
}



void __regparm3 html_iframe_do(uchar *a,uchar *object_src,html_context *html_context)

{
  uchar *link;
  uchar *linkname;
  
  if (((object_src != (uchar *)0x0) && (link = stracpy(object_src), link != (uchar *)0x0)) ||
     (link = get_attr_value(a,"src",html_context->doc_cp,HTML_ATTR_EAT_NL), link != (uchar *)0x0)) {
    linkname = get_attr_value(a,"name",html_context->doc_cp,HTML_ATTR_NONE);
    if (((linkname != (uchar *)0x0) ||
        (linkname = get_attr_value(a,"id",html_context->doc_cp,HTML_ATTR_NONE),
        linkname != (uchar *)0x0)) || (linkname = stracpy(""), linkname != (uchar *)0x0)) {
      html_focusable(html_context,a);
      if (*linkname == '\0') {
        put_link_line("",(uchar *)"IFrame",link,html_context->options->framename,html_context);
      }
      else {
        put_link_line((uchar *)"IFrame: ",linkname,link,html_context->options->framename,
                      html_context);
      }
      mem_free(linkname);
    }
    mem_free(link);
  }
  return;
}



void html_embed(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uchar *object_src;
  uchar *extension;
  int iVar1;
  
  object_src = get_attr_value(a,"src",html_context->doc_cp,HTML_ATTR_EAT_NL);
  if (object_src != (uchar *)0x0) {
    if (*object_src != '\0') {
      extension = (uchar *)strrchr((char *)object_src,0x2e);
      if (extension == (uchar *)0x0) {
        extension = object_src;
      }
      extension = get_extension_content_type(extension);
      if (extension == (uchar *)0x0) {
        html_iframe_do(a,object_src,html_context);
      }
      else {
        iVar1 = c_strncasecmp((char *)extension,"image/",6);
        if (iVar1 == 0) {
          html_img_do(a,object_src,html_context);
        }
        else {
          html_iframe_do(a,object_src,html_context);
        }
        mem_free(extension);
      }
    }
    mem_free(object_src);
    return;
  }
  return;
}



void html_iframe(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  html_iframe_do(a,(uchar *)0x0,html_context);
  return;
}



void html_object(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uchar *object_src;
  uchar *linkname;
  int iVar1;
  uchar *linkname_00;
  
  object_src = get_attr_value(a,"data",html_context->doc_cp,HTML_ATTR_EAT_NL);
  if (object_src == (uchar *)0x0) {
    object_src = get_attr_value(a,(uchar *)"codebase",html_context->doc_cp,HTML_ATTR_EAT_NL);
    if (object_src == (uchar *)0x0) {
      return;
    }
  }
  linkname = get_attr_value(a,"type",html_context->doc_cp,HTML_ATTR_NONE);
  if (linkname != (uchar *)0x0) {
    iVar1 = c_strncasecmp((char *)linkname,"text/",5);
    if (iVar1 == 0) {
      html_iframe_do(a,object_src,html_context);
      html_skip(html_context,a);
    }
    else {
      iVar1 = c_strncasecmp((char *)linkname,"image/",6);
      if (iVar1 == 0) {
        html_img_do(a,object_src,html_context);
      }
      else {
        linkname_00 = get_attr_value(a,(uchar *)"standby",html_context->doc_cp,HTML_ATTR_NONE);
        html_focusable(html_context,a);
        if (linkname_00 == (uchar *)0x0) {
          put_link_line((uchar *)"Object: ",linkname,object_src,html_context->options->framename,
                        html_context);
        }
        else {
          if (*linkname_00 == '\0') {
            put_link_line((uchar *)"Object: ",linkname,object_src,html_context->options->framename,
                          html_context);
          }
          else {
            put_link_line((uchar *)"Object: ",linkname_00,object_src,
                          html_context->options->framename,html_context);
          }
          mem_free(linkname_00);
        }
      }
    }
    mem_free(linkname);
  }
  mem_free(object_src);
  return;
}



void html_applet(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uchar *link;
  uchar *linkname;
  
  link = get_attr_value(a,"code",html_context->doc_cp,HTML_ATTR_EAT_NL);
  if (link != (uchar *)0x0) {
    linkname = get_attr_value(a,"alt",html_context->doc_cp,HTML_ATTR_NONE);
    html_focusable(html_context,a);
    if (linkname == (uchar *)0x0) {
      put_link_line("",(uchar *)"Applet",link,html_context->options->framename,html_context);
    }
    else {
      if (*linkname == '\0') {
        put_link_line("",(uchar *)"Applet",link,html_context->options->framename,html_context);
      }
      else {
        put_link_line((uchar *)"Applet: ",linkname,link,html_context->options->framename,
                      html_context);
      }
      mem_free(linkname);
    }
    mem_free(link);
    return;
  }
  return;
}



void html_a(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  uchar uVar2;
  uchar *rel;
  size_t __n;
  global_history_item *pgVar3;
  bookmark *pbVar4;
  void *pvVar5;
  uchar *__src;
  uchar *puVar6;
  undefined4 uVar7;
  void *local_24;
  
  rel = get_attr_value(a,"href",html_context->doc_cp,HTML_ATTR_EAT_NL);
  if (rel == (uchar *)0x0) {
    kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
  }
  else {
    local_24 = (html_context->stack).next;
    if (*(void **)((int)local_24 + 0x1c) != (void *)0x0) {
      mem_free(*(void **)((int)local_24 + 0x1c));
      local_24 = (html_context->stack).next;
    }
    __n = strlen((char *)rel);
    uVar2 = *rel;
    __src = rel;
    while (uVar2 == ' ') {
      __src = __src + 1;
      __n = __n - 1;
      uVar2 = *__src;
    }
    if (__n == 0) {
LAB_0809b7b3:
      __n = 1;
    }
    else {
      uVar2 = __src[__n - 1];
      puVar6 = __src + __n;
      while (uVar2 == ' ') {
        __n = __n - 1;
        puVar6[-1] = '\0';
        if (__n == 0) goto LAB_0809b7b3;
        uVar2 = puVar6[-2];
        puVar6 = puVar6 + -1;
      }
      __n = __n + 1;
    }
    memmove(rel,__src,__n);
    __src = join_urls(html_context->base_href,rel);
    *(uchar **)((int)local_24 + 0x1c) = __src;
    mem_free(rel);
    rel = get_target(html_context->options,a);
    if (rel == (uchar *)0x0) {
      pvVar5 = (html_context->stack).next;
      if (*(void **)((int)pvVar5 + 0x20) != (void *)0x0) {
        mem_free(*(void **)((int)pvVar5 + 0x20));
        pvVar5 = (html_context->stack).next;
      }
      rel = stracpy(html_context->base_target);
      *(uchar **)((int)pvVar5 + 0x20) = rel;
    }
    else {
      pvVar5 = (html_context->stack).next;
      if (*(void **)((int)pvVar5 + 0x20) != (void *)0x0) {
        mem_free(*(void **)((int)pvVar5 + 0x20));
        pvVar5 = (html_context->stack).next;
      }
      *(uchar **)((int)pvVar5 + 0x20) = rel;
    }
    pgVar3 = get_global_history_item(*(uchar **)((int)(html_context->stack).next + 0x1c));
    if (pgVar3 == (global_history_item *)0x0) {
      pbVar4 = get_bookmark(*(uchar **)((int)(html_context->stack).next + 0x1c));
      if (pbVar4 == (bookmark *)0x0) {
        pvVar5 = (html_context->stack).next;
        uVar7 = *(undefined4 *)((int)pvVar5 + 0x30);
      }
      else {
        pvVar5 = (html_context->stack).next;
        uVar7 = *(undefined4 *)((int)pvVar5 + 0x38);
      }
      *(undefined4 *)((int)pvVar5 + 0x10) = uVar7;
      puVar1 = (uint *)((int)(html_context->stack).next + 0xb0);
      *puVar1 = *puVar1 & 0xfffffffd;
      puVar1 = (uint *)((int)(html_context->stack).next + 0xb0);
      *puVar1 = *puVar1 | 1;
    }
    else {
      pvVar5 = (html_context->stack).next;
      *(undefined4 *)((int)pvVar5 + 0x10) = *(undefined4 *)((int)pvVar5 + 0x34);
      puVar1 = (uint *)((int)(html_context->stack).next + 0xb0);
      *puVar1 = *puVar1 & 0xfffffffe;
      puVar1 = (uint *)((int)(html_context->stack).next + 0xb0);
      *puVar1 = *puVar1 | 2;
    }
    pvVar5 = (html_context->stack).next;
    if (*(void **)((int)pvVar5 + 0x28) != (void *)0x0) {
      mem_free(*(void **)((int)pvVar5 + 0x28));
      pvVar5 = (html_context->stack).next;
    }
    rel = get_attr_value(a,"title",html_context->doc_cp,HTML_ATTR_NONE);
    *(uchar **)((int)pvVar5 + 0x28) = rel;
    html_focusable(html_context,a);
  }
  set_fragment_identifier(html_context,a,"name");
  return;
}



void tags_list_reset(void)

{
  internal_pointer = elements;
  return;
}



fastfind_key_value * tags_list_next(void)

{
  fastfind_key_value kv;
  fastfind_key_value *pfVar1;
  
  pfVar1 = (fastfind_key_value *)0x0;
  if (internal_pointer->name != (uchar *)0x0) {
    internal_pointer = internal_pointer + 1;
    pfVar1 = (fastfind_key_value *)0x814943c;
  }
  return pfVar1;
}



uchar * skip_comment(uchar *html,uchar *eof)

{
  byte *pbVar1;
  byte *pbVar2;
  uchar *puVar3;
  ushort **ppuVar4;
  byte bVar5;
  
  pbVar2 = html + 4;
  puVar3 = html + 2;
  if (((eof < pbVar2) || (puVar3 = html + 2, html[2] != '-')) || (html[3] != '-')) {
    while (puVar3 < eof) {
      if (*puVar3 == '>') {
        return puVar3 + 1;
      }
      puVar3 = puVar3 + 1;
    }
  }
  else {
    while (pbVar2 < eof) {
      while (((pbVar2 + 2 <= eof && (*pbVar2 == 0x2d)) && (pbVar1 = pbVar2 + 2, pbVar2[1] == 0x2d)))
      {
        while( true ) {
          pbVar2 = pbVar1;
          if (eof <= pbVar2) {
            return eof;
          }
          bVar5 = *pbVar2;
          if (bVar5 != 0x2d) break;
          pbVar1 = pbVar2 + 1;
        }
        ppuVar4 = __ctype_b_loc();
        while ((*(byte *)((int)*ppuVar4 + (uint)bVar5 * 2 + 1) & 0x20) != 0) {
          pbVar2 = pbVar2 + 1;
          if (eof <= pbVar2) {
            return eof;
          }
          bVar5 = *pbVar2;
        }
        if (eof <= pbVar2) {
          return eof;
        }
        if (bVar5 == 0x3e) {
          return pbVar2 + 1;
        }
      }
      pbVar2 = pbVar2 + 1;
    }
  }
  return eof;
}



int parse_element(uchar *e,uchar *eof,uchar **name,int *namelen,uchar **attr,uchar **end)

{
  ushort uVar1;
  ushort **ppuVar2;
  byte *pbVar3;
  ushort *puVar4;
  byte bVar5;
  byte *pbVar6;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(eof == (uchar *)0x0 || e == (uchar *)0x0),
     eof == (uchar *)0x0 || e == (uchar *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
    errline = 0x3c;
    elinks_internal((uchar *)"assertion e && eof failed!");
  }
  if (((e < eof) && (*e == '<')) && (pbVar6 = e + 1, pbVar6 != eof)) {
    if (name != (uchar **)0x0) {
      *name = pbVar6;
    }
    bVar5 = e[1];
    if (bVar5 == 0x2f) {
      pbVar6 = e + 2;
      if (pbVar6 == eof) {
        return -1;
      }
      bVar5 = *pbVar6;
    }
    if ((((byte)(bVar5 + 0x9f) < 0x1a) || ((byte)(bVar5 + 0xbf) < 0x1a)) ||
       (((byte)(bVar5 - 0x30) < 10 || ((bVar5 == 0x5f || (bVar5 == 0x2d)))))) {
      while (((byte)(bVar5 + 0x9f) < 0x1a ||
             (((((byte)(bVar5 + 0xbf) < 0x1a || ((byte)(bVar5 - 0x30) < 10)) || (bVar5 == 0x5f)) ||
              (bVar5 == 0x2d))))) {
        pbVar6 = pbVar6 + 1;
        if (pbVar6 == eof) {
          return -1;
        }
        bVar5 = *pbVar6;
      }
      ppuVar2 = __ctype_b_loc();
      puVar4 = *ppuVar2;
      uVar1 = puVar4[bVar5];
      if (((((uVar1 & 0x2000) != 0) || (bVar5 == 0x3c)) ||
          ((bVar5 == 0x3e || ((bVar5 == 0x2f || (bVar5 == 0x3a)))))) || (bVar5 == 0x3d)) {
        if ((namelen != (int *)0x0) && (name != (uchar **)0x0)) {
          *(byte **)namelen = pbVar6 + -(int)*name;
          bVar5 = *pbVar6;
          puVar4 = *ppuVar2;
          uVar1 = puVar4[bVar5];
        }
        while ((((uVar1 & 0x2000) != 0 || (bVar5 == 0x2f)) || (bVar5 == 0x3a))) {
          pbVar6 = pbVar6 + 1;
          if (pbVar6 == eof) {
            return -1;
          }
          bVar5 = *pbVar6;
          uVar1 = puVar4[bVar5];
        }
        while ((((0x7e < bVar5 || ((bVar5 < 0x3f && ((bVar5 == 0x3d || (bVar5 < 0x21)))))) &&
                (bVar5 != 0x3c)) &&
               ((bVar5 != 0x3e && ((*(byte *)((int)puVar4 + (uint)bVar5 * 2 + 1) & 0x20) == 0))))) {
          pbVar6 = pbVar6 + 1;
          if (pbVar6 == eof) {
            return -1;
          }
          bVar5 = *pbVar6;
        }
        if (attr != (uchar **)0x0) {
          *attr = pbVar6;
          puVar4 = *ppuVar2;
          bVar5 = *pbVar6;
        }
        uVar1 = puVar4[bVar5];
        while( true ) {
          while ((uVar1 & 0x2000) != 0) {
            pbVar6 = pbVar6 + 1;
            if (pbVar6 == eof) {
              return -1;
            }
            bVar5 = *pbVar6;
            uVar1 = puVar4[*pbVar6];
          }
          while (((0x7e < bVar5 || ((bVar5 < 0x3f && ((bVar5 == 0x3d || (bVar5 < 0x21)))))) &&
                 ((bVar5 != 0x3c &&
                  ((bVar5 != 0x3e && ((*(byte *)((int)puVar4 + (uint)bVar5 * 2 + 1) & 0x20) == 0))))
                 ))) {
            pbVar6 = pbVar6 + 1;
            if (pbVar6 == eof) {
              return -1;
            }
            bVar5 = *pbVar6;
          }
          if ((bVar5 == 0x3c) || (bVar5 == 0x3e)) break;
          while ((bVar5 < 0x7f &&
                 ((0x3e < bVar5 ||
                  ((((bVar5 != 0x3d && (0x20 < bVar5)) && (bVar5 != 0x3c)) && (bVar5 != 0x3e)))))))
          {
            pbVar6 = pbVar6 + 1;
            if (pbVar6 == eof) {
              return -1;
            }
            bVar5 = *pbVar6;
          }
          while (uVar1 = puVar4[bVar5], (uVar1 & 0x2000) != 0) {
            pbVar6 = pbVar6 + 1;
            if (pbVar6 == eof) {
              return -1;
            }
            bVar5 = *pbVar6;
          }
          if (bVar5 == 0x3d) {
            do {
              pbVar3 = pbVar6;
              pbVar6 = pbVar3 + 1;
              if (pbVar6 == eof) {
                return -1;
              }
              bVar5 = *pbVar6;
            } while ((*(byte *)((int)puVar4 + (uint)bVar5 * 2 + 1) & 0x20) != 0);
            if ((bVar5 == 0x27) || (bVar5 == 0x22)) {
              pbVar3 = pbVar3 + 2;
              while( true ) {
                if (pbVar3 == eof) {
                  return -1;
                }
                if (bVar5 == *pbVar3) break;
                pbVar3 = pbVar3 + 1;
              }
              pbVar6 = pbVar3 + 1;
              if (pbVar6 == eof) {
                return -1;
              }
              bVar5 = pbVar3[1];
LAB_0809be4b:
              uVar1 = puVar4[bVar5];
            }
            else {
              do {
                if ((bVar5 == 0x3c) || (bVar5 == 0x3e)) goto LAB_0809be4b;
                pbVar6 = pbVar6 + 1;
                if (pbVar6 == eof) {
                  return -1;
                }
                bVar5 = *pbVar6;
                uVar1 = puVar4[bVar5];
              } while ((uVar1 & 0x2000) == 0);
            }
            while ((uVar1 & 0x2000) != 0) {
              pbVar6 = pbVar6 + 1;
              if (pbVar6 == eof) {
                return -1;
              }
              bVar5 = *pbVar6;
              uVar1 = puVar4[bVar5];
            }
            if ((bVar5 == 0x3c) || (bVar5 == 0x3e)) break;
          }
          else {
            if ((bVar5 == 0x3c) || (bVar5 == 0x3e)) break;
            bVar5 = *pbVar6;
          }
        }
        if (end != (uchar **)0x0) {
          *end = pbVar6 + (*pbVar6 == 0x3e);
          return 0;
        }
        return 0;
      }
    }
  }
  return -1;
}



void free_tags_lookup(void)

{
  fastfind_done(&ff_tags_index);
  return;
}



void init_tags_lookup(void)

{
  fastfind_index(&ff_tags_index,FF_COMPRESS|FF_LOCALE_INDEP);
  return;
}



void * __regparm3 mem_align_alloc__(void **ptr,size_t old,size_t new)

{
  void *pvVar1;
  uint size;
  uint uVar2;
  
  size = new + 0xff & 0xffffff00;
  uVar2 = old + 0xff & 0xffffff00;
  if (uVar2 < size) {
    pvVar1 = mem_realloc(*ptr,size);
    if (pvVar1 == (void *)0x0) {
      return (void *)0x0;
    }
    *ptr = pvVar1;
    memset((void *)((int)pvVar1 + uVar2),0,size - uVar2);
  }
  return *ptr;
}



uchar * get_attr_value(uchar *e,uchar *name,int cp,html_attr_flags flags)

{
  byte bVar1;
  ushort uVar2;
  bool bVar3;
  byte bVar4;
  ushort **ppuVar5;
  int iVar6;
  int iVar7;
  void *pvVar8;
  ushort *puVar9;
  size_t new;
  byte *chars;
  uint size;
  byte *pbVar10;
  uint uVar11;
  size_t local_34;
  byte *local_20 [4];
  
  local_20[0] = (byte *)0x0;
  ppuVar5 = __ctype_b_loc();
  puVar9 = *ppuVar5;
  bVar4 = *e;
  uVar2 = puVar9[bVar4];
LAB_0809bf58:
  while ((uVar2 & 0x2000) != 0) {
    bVar4 = e[1];
    e = e + 1;
    uVar2 = puVar9[bVar4];
  }
  if ((((bVar4 != 0x3c) && (bVar4 != 0x3e)) && (bVar4 < 0x7f)) &&
     ((0x3e < bVar4 || ((bVar4 != 0x3d && (0x20 < bVar4)))))) {
    bVar1 = *name;
    chars = e;
    pbVar10 = name;
    if (bVar1 < 0x7f) {
      do {
        if ((bVar1 < 0x3f) &&
           (((bVar1 == 0x3d || (bVar1 < 0x21)) || ((bVar1 == 0x3c || (bVar1 == 0x3e)))))) {
LAB_0809bff0:
          bVar1 = *pbVar10;
          bVar4 = *chars;
LAB_0809bff8:
          if (bVar1 != 0) {
            bVar3 = false;
            puVar9 = *ppuVar5;
            goto LAB_0809c0a6;
          }
          if ((bVar4 < 0x7f) &&
             ((0x3e < bVar4 ||
              (((bVar4 != 0x3d && (0x20 < bVar4)) && ((bVar4 != 0x3c && (bVar4 != 0x3e)))))))) {
            bVar3 = false;
            puVar9 = *ppuVar5;
            goto LAB_0809c0b0;
          }
          if ((flags & HTML_ATTR_TEST) != HTML_ATTR_NONE) {
            return e;
          }
          bVar3 = true;
          puVar9 = *ppuVar5;
          goto LAB_0809c0a6;
        }
        if ((0x7e < bVar4) ||
           ((bVar4 < 0x3f &&
            ((((bVar4 == 0x3d || (bVar4 < 0x21)) || (bVar4 == 0x3c)) || (bVar4 == 0x3e)))))) {
          bVar1 = *pbVar10;
          goto LAB_0809bff8;
        }
        iVar6 = c_toupper((uint)bVar4);
        iVar7 = c_toupper((uint)*pbVar10);
        if (iVar6 != iVar7) goto LAB_0809bff0;
        chars = chars + 1;
        bVar1 = pbVar10[1];
        if (0x7e < bVar1) goto code_r0x0809c098;
        bVar4 = *chars;
        pbVar10 = pbVar10 + 1;
      } while( true );
    }
    goto LAB_0809c0a2;
  }
  goto parse_error;
code_r0x0809c098:
  bVar4 = *chars;
  puVar9 = *ppuVar5;
LAB_0809c0a2:
  bVar3 = false;
LAB_0809c0a6:
  if (0x7e < bVar4) goto LAB_0809c0e6;
LAB_0809c0b0:
  do {
    if (bVar4 < 0x3f) {
      if (bVar4 == 0x3d) goto LAB_0809c0e3;
      if (bVar4 < 0x21) goto LAB_0809c0e3;
      if (bVar4 == 0x3c) goto LAB_0809c0e3;
      if (bVar4 == 0x3e) goto LAB_0809c0e3;
    }
    chars = chars + 1;
    bVar4 = *chars;
  } while (bVar4 < 0x7f);
  bVar1 = *(byte *)((int)puVar9 + (uint)bVar4 * 2 + 1);
  e = chars;
  while ((bVar1 & 0x20) != 0) {
    chars = e + 1;
LAB_0809c0e3:
    bVar4 = *chars;
LAB_0809c0e6:
    bVar1 = *(byte *)((int)puVar9 + (uint)bVar4 * 2 + 1);
    e = chars;
  }
  if (bVar4 == 0x3d) {
    e = e + 1;
    bVar4 = *e;
    bVar1 = *(byte *)((int)puVar9 + (uint)bVar4 * 2 + 1);
    while ((bVar1 & 0x20) != 0) {
      e = e + 1;
      bVar4 = *e;
      bVar1 = *(byte *)((int)puVar9 + (uint)bVar4 * 2 + 1);
    }
    if (!bVar3) {
      if ((bVar4 != 0x27) && (bVar4 != 0x22)) {
        uVar2 = puVar9[bVar4];
        if (((uVar2 & 0x2000) == 0) && (bVar4 != 0x3c)) {
          while (bVar4 != 0x3e) {
            if (bVar4 == 0) goto parse_error;
            e = e + 1;
            bVar4 = *e;
            uVar2 = puVar9[bVar4];
            if (((uVar2 & 0x2000) != 0) || (bVar4 == 0x3c)) break;
          }
        }
        goto LAB_0809bf58;
      }
      while( true ) {
        bVar1 = e[1];
        if (bVar4 == bVar1) break;
        e = e + 1;
        if (bVar1 == 0) goto parse_error;
      }
      e = e + 2;
LAB_0809c0fc:
      bVar4 = *e;
      uVar2 = puVar9[bVar4];
      goto LAB_0809bf58;
    }
    if ((bVar4 == 0x27) || (bVar4 == 0x22)) {
      local_34 = 0;
      goto LAB_0809c2f6;
    }
    if ((((*(byte *)((int)puVar9 + (uint)bVar4 * 2 + 1) & 0x20) == 0) && (bVar4 != 0x3e)) &&
       (bVar4 != 0x3c)) {
      local_34 = 0;
      goto joined_r0x0809c398;
    }
  }
  else {
    if (!bVar3) goto LAB_0809c0fc;
  }
  local_34 = 0;
  new = 1;
  goto LAB_0809c23c;
LAB_0809c2f6:
  e = e + 1;
  bVar1 = *e;
  if (bVar1 != bVar4) {
    if (bVar1 != 0) {
      if ((flags & HTML_ATTR_LITERAL_NL) == HTML_ATTR_NONE) goto code_r0x0809c314;
      goto LAB_0809c34e;
    }
    goto parse_error;
  }
  new = local_34 + 1;
  goto LAB_0809c23c;
code_r0x0809c314:
  if (bVar1 != 0xd) {
    if ((byte)(bVar1 - 9) < 2) {
      if ((flags & HTML_ATTR_EAT_NL) == HTML_ATTR_NONE) {
        pvVar8 = mem_align_alloc__(local_20,local_34,local_34 + 1);
        if (pvVar8 == (void *)0x0) goto LAB_0809bf7d;
        local_20[0][local_34] = 0x20;
        local_34 = local_34 + 1;
      }
    }
    else {
LAB_0809c34e:
      pvVar8 = mem_align_alloc__(local_20,local_34,local_34 + 1);
      if (pvVar8 == (void *)0x0) goto LAB_0809bf7d;
      local_20[0][local_34] = *e;
      local_34 = local_34 + 1;
    }
  }
  goto LAB_0809c2f6;
parse_error:
  if (local_20[0] != (byte *)0x0) {
    mem_free(local_20[0]);
    return (uchar *)0x0;
  }
  goto LAB_0809bf7d;
  while( true ) {
    local_34 = new + 1;
    size = new + 0x100 & 0xffffff00;
    uVar11 = new + 0xff & 0xffffff00;
    if (uVar11 < size) {
      local_20[0] = (byte *)mem_realloc(local_20[0],size);
      if (local_20[0] == (byte *)0x0) goto LAB_0809bf7d;
      memset(local_20[0] + uVar11,0,size - uVar11);
    }
    if (local_20[0] == (byte *)0x0) goto LAB_0809bf7d;
    local_20[0][new] = e[new];
    bVar4 = e[local_34];
    if ((((*(byte *)((int)*ppuVar5 + (uint)bVar4 * 2 + 1) & 0x20) != 0) || (bVar4 == 0x3c)) ||
       (bVar4 == 0x3e)) break;
joined_r0x0809c398:
    new = local_34;
    if (bVar4 == 0) goto parse_error;
  }
  new = new + 2;
LAB_0809c23c:
  pvVar8 = mem_align_alloc__(local_20,local_34,new);
  chars = local_20[0];
  if (pvVar8 == (void *)0x0) {
LAB_0809bf7d:
    chars = (byte *)0x0;
  }
  else {
    local_20[0][local_34] = 0;
    pvVar8 = memchr(local_20[0],0x26,local_34);
    if (pvVar8 != (void *)0x0) {
      local_20[0] = convert_string_elinks
                              ((conv_table *)0x0,chars,local_34,cp,CSM_QUERY,(int *)0x0,
                               (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
      mem_free(chars);
      chars = local_20[0];
    }
  }
  return chars;
}



void scan_http_equiv(uchar *s,uchar *eof,string *head,string *title,document_options *options)

{
  uchar *puVar1;
  uint uVar2;
  string *psVar3;
  int iVar4;
  uint uVar5;
  uchar *puVar6;
  uchar *source;
  uint size;
  uchar *html;
  uchar *__n;
  size_t local_28;
  uchar *local_24;
  uchar *local_20 [4];
  
  if ((title == (string *)0x0) || (psVar3 = init_string(title), psVar3 != (string *)0x0)) {
    add_char_to_string(head,'\n');
LAB_0809c498:
    if (s < eof) {
      do {
        if (*s == '<') {
          if ((s + 2 <= eof) && ((s[1] == '?' || (s[1] == '!')))) {
            s = skip_comment(s,eof);
            goto LAB_0809c498;
          }
          iVar4 = parse_element(s,eof,local_20,(int *)&local_28,&local_24,&s);
          if (iVar4 == 0) goto LAB_0809c515;
        }
        s = s + 1;
        if (eof <= s) {
          return;
        }
      } while( true );
    }
  }
  return;
LAB_0809c515:
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
  errline = 0x433;
  iVar4 = elinks_strlcasecmp(local_20[0],local_28,"HEAD",4,1);
  if (iVar4 == 0) goto LAB_0809c498;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
  errline = 0x434;
  iVar4 = elinks_strlcasecmp(local_20[0],local_28,(uchar *)"/HEAD",5,1);
  if (iVar4 == 0) {
    return;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
  errline = 0x435;
  iVar4 = elinks_strlcasecmp(local_20[0],local_28,"BODY",4,1);
  if (iVar4 == 0) {
    return;
  }
  if ((title == (string *)0x0) || (title->length != 0)) {
LAB_0809c821:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
    errline = 0x44d;
    iVar4 = elinks_strlcasecmp(local_20[0],local_28,"META",4,1);
    if (iVar4 == 0) {
      source = get_attr_value(local_24,"charset",options->cp,HTML_ATTR_NONE);
      if (source != (uchar *)0x0) {
        add_to_string(head,"Charset: ");
        add_to_string(head,source);
        mem_free(source);
      }
      source = get_attr_value(local_24,(uchar *)"http-equiv",options->cp,HTML_ATTR_NONE);
      if (source != (uchar *)0x0) {
        add_to_string(head,source);
        mem_free(source);
        source = get_attr_value(local_24,"content",options->cp,HTML_ATTR_NONE);
        if (source != (uchar *)0x0) {
          add_to_string(head,": ");
          add_to_string(head,source);
          mem_free(source);
        }
        add_crlf_to_string(head);
      }
    }
    goto LAB_0809c498;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
  errline = 0x436;
  iVar4 = elinks_strlcasecmp(local_20[0],local_28,"TITLE",5,1);
  source = s;
  if (iVar4 != 0) goto LAB_0809c821;
LAB_0809c65b:
  while ((s < eof && (*s != '<'))) {
xsp:
    s = s + 1;
  }
  html = source;
  if (source != s) {
    if (assert_failed == 0) {
      __n = s + -(int)source;
      if ((source == (uchar *)0x0) || ((int)__n < 0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) goto LAB_0809c728;
      }
      else {
        assert_failed = 0;
      }
      html = s;
      if (__n != (uchar *)0x0) {
        puVar1 = __n + title->length;
        uVar5 = title->length + 0xff;
        uVar2 = uVar5 >> 8;
        uVar5 = uVar5 & 0xffffff00;
        size = (uint)(puVar1 + 0x100) & 0xffffff00;
        if (uVar5 <= size && size + uVar2 * -0x100 != 0) {
          puVar6 = (uchar *)mem_realloc(title->source,size);
          html = s;
          if (puVar6 == (uchar *)0x0) goto LAB_0809c690;
          title->source = puVar6;
          memset(puVar6 + uVar5,0,size + uVar2 * -0x100);
        }
        html = s;
        if (title->source != (uchar *)0x0) {
          memcpy(title->source + title->length,source,(size_t)__n);
          title->source[(int)puVar1] = '\0';
          *(uchar **)&title->length = puVar1;
          html = s;
        }
      }
    }
    else {
LAB_0809c728:
      assert_failed = 0;
      html = s;
    }
  }
LAB_0809c690:
  if (eof <= html) {
    return;
  }
  if ((html + 2 <= eof) && ((html[1] == '?' || (html[1] == '!')))) {
    s = skip_comment(html,eof);
    source = s;
    goto LAB_0809c65b;
  }
  iVar4 = parse_element(html,eof,local_20,(int *)&local_28,&local_24,&s);
  source = s;
  if (iVar4 != 0) goto xsp;
  clr_spaces(title->source);
  goto LAB_0809c515;
}



void parse_html(uchar *html,uchar *eof,part *part,uchar *head,html_context *html_context)

{
  int *piVar1;
  byte bVar2;
  uchar uVar3;
  text_style_format tVar4;
  color_T cVar5;
  format_list_flag fVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  format_align fVar11;
  bool bVar12;
  size_t n2;
  ushort **ppuVar13;
  uint uVar14;
  void *pvVar15;
  int n;
  html_element *e;
  uchar *start;
  int iVar16;
  uchar *s2;
  bool bVar17;
  html_element *html_stack;
  byte *e_00;
  code *pcVar18;
  byte *html_00;
  byte *len;
  html_element *e_01;
  css_selector *selector;
  void *pvVar19;
  size_t local_40;
  byte *local_34;
  byte *local_30;
  size_t local_2c;
  byte *local_28;
  uchar *local_24;
  uchar *local_20 [4];
  
  html_context->putsp = HTML_SPACE_SUPPRESS;
  html_context->line_breax = 2 - (uint)(html_context->table_level == 0);
  html_context->position = 0;
  html_context->was_li = 0;
  *(byte *)&html_context->field_0x44 = *(byte *)&html_context->field_0x44 & 0xee;
  html_context->eoff = eof;
  html_context->part = part;
  if (head != (uchar *)0x0) {
    process_head(html_context,head);
  }
  if (html < eof) {
    ppuVar13 = __ctype_b_loc();
    html_stack = (html_element *)&html_context->stack;
    bVar17 = false;
    len = html;
LAB_0809ca00:
    do {
      if (!bVar17) {
        html_context->part = part;
        html_context->eoff = eof;
        html = len;
      }
      bVar2 = *len;
      html_00 = len;
      if ((*(byte *)((int)*ppuVar13 + (uint)bVar2 * 2 + 1) & 0x20) == 0) {
        if ((*(byte *)((int)(html_context->stack).next + 0xc) & 0x20) != 0) goto LAB_0809cc10;
        goto LAB_0809cb00;
      }
      if ((*(byte *)((int)(html_context->stack).next + 0xc) & 0x20) == 0) {
        e_00 = len;
        if (len < eof) {
          do {
            e_00 = e_00 + 1;
            if (eof <= e_00) break;
          } while ((*(byte *)((int)*ppuVar13 + (uint)*e_00 * 2 + 1) & 0x20) != 0);
        }
        if (((eof <= e_00 + 1) || (*e_00 != 0x3c)) ||
           ((e_00[1] != 0x2f ||
            (n = parse_element(e_00,eof,local_20,(int *)&local_2c,&local_24,&local_28), n != 0)))) {
          html_00 = len + 1;
          e_00 = html_00 + -(int)html;
          if (e_00 + -1 + html_context->position != (byte *)0x0) {
            if (*len == 0x20) {
              if ((html_00 < eof) &&
                 (bVar17 = true, len = html_00,
                 (*(byte *)((int)*ppuVar13 + (uint)*html_00 * 2 + 1) & 0x20) == 0))
              goto LAB_0809ca00;
              put_chrs(html_context,html,(int)e_00);
            }
            else {
              put_chrs(html_context,html,(int)(e_00 + -1));
              put_chrs(html_context," ",1);
            }
          }
          if (eof <= html_00) goto LAB_0809cbd6;
          while ((*(byte *)((int)*ppuVar13 + (uint)*html_00 * 2 + 1) & 0x20) != 0) {
            html_00 = html_00 + 1;
            if (eof <= html_00) goto LAB_0809cbd6;
          }
          bVar17 = false;
          len = html_00;
          goto LAB_0809ca00;
        }
        len = (byte *)0x0;
        put_chrs(html_context,html,(int)(len + -(int)html));
        html_context->putsp = HTML_SPACE_ADD;
        html = e_00;
element:
        uVar3 = *local_20[0];
        uVar14 = (uint)(uVar3 == '/');
        local_20[0] = local_20[0] + uVar14;
        local_2c = local_2c - uVar14;
        if (uVar3 == '/') {
          put_chrs(html_context,html,(int)len);
          bVar17 = false;
        }
        else {
          if ((html_context->putsp == HTML_SPACE_ADD) &&
             (*(int *)((int)(html_context->stack).next + 0x98) == 0)) {
            put_chrs(html_context," ",1);
          }
          put_chrs(html_context,html,(int)len);
          if (((*(byte *)((int)(html_context->stack).next + 0xc) & 0x20) == 0) &&
             (html_context->putsp == HTML_SPACE_NORMAL)) {
            local_30 = local_28;
            do {
              n = parse_element(local_30,eof,&local_34,(int *)0x0,(uchar **)0x0,&local_30);
              if (n != 0) {
                if ((local_30 < eof) &&
                   ((*(byte *)((int)*ppuVar13 + (uint)*local_30 * 2 + 1) & 0x20) != 0)) {
                  put_chrs(html_context," ",1);
                  bVar17 = true;
                  goto LAB_0809cef6;
                }
                break;
              }
            } while (*local_34 != 0x2f);
          }
          bVar17 = true;
        }
LAB_0809cef6:
        s2 = local_20[0];
        start = local_24;
        html_00 = local_28;
        n2 = local_2c;
        len = local_28;
        pvVar15 = fastfind_search(&ff_tags_index,local_20[0],local_2c);
        if ((*(byte *)&html_context->field_0x44 & 6) == 0) {
          if (pvVar15 == (void *)0x0) {
LAB_0809cda2:
            bVar17 = false;
            goto LAB_0809cbb5;
          }
          if (!bVar17) goto LAB_0809d22f;
          local_34 = html_00;
          e = (html_element *)(html_context->stack).next;
          if (e->type == ELEMENT_WEAK) {
            kill_html_stack_item(html_context,e);
            e = (html_element *)(html_context->stack).next;
          }
          if (e->invisible == 0) {
            pcVar18 = *(code **)((int)pvVar15 + 4);
          }
          else {
            if ((*(code **)((int)pvVar15 + 4) != html_script) ||
               (pcVar18 = html_script, e->invisible < 2)) {
              ln_break(html_context,*(int *)((int)pvVar15 + 0xc));
              start = get_attr_value(start,"id",html_context->doc_cp,HTML_ATTR_NONE);
              if (start != (uchar *)0x0) {
                (*html_context->special_f)(html_context,0,start);
                mem_free(start);
              }
              goto LAB_0809d21d;
            }
          }
          tVar4 = (e->attr).style.attr;
          cVar5 = (e->parattr).bgcolor;
          fVar6 = (e->parattr).flags;
          n = (e->parattr).dd_margin;
          uVar14 = (e->parattr).list_number;
          iVar7 = (e->parattr).list_level;
          iVar8 = (e->parattr).width;
          iVar9 = (e->parattr).rightmargin;
          iVar10 = (e->parattr).leftmargin;
          fVar11 = (e->parattr).align;
          if ((pcVar18 == html_meta) && ((*(byte *)&html_context->field_0x44 & 0x10) != 0)) {
            html_handle_body_meta(html_context,s2 + -1,eof);
            *(byte *)&html_context->field_0x44 = *(byte *)&html_context->field_0x44 & 0xef;
            pcVar18 = *(code **)((int)pvVar15 + 4);
          }
          if ((pcVar18 == html_style) && ((*(byte *)&html_context->options->field_0x44 & 1) != 0)) {
            css_parse_stylesheet
                      ((css_stylesheet *)html_context,html_context->base_href,local_34,eof);
          }
          iVar16 = *(int *)((int)pvVar15 + 0x10);
          if (iVar16 == 3) {
            e_01 = (html_element *)(html_context->stack).next;
            e = html_stack;
            if (html_stack != e_01) {
              while (((e = e_01, e_01->linebreak < 1 || (*(int *)((int)pvVar15 + 0xc) != 0)) &&
                     (ELEMENT_DONT_KILL < e_01->type))) {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
                errline = 0x364;
                iVar16 = elinks_strlcasecmp(e_01->name,e_01->namelen,s2,n2,1);
                if ((iVar16 == 0) || (e_01 = e_01->next, e = html_stack, html_stack == e_01)) break;
              }
            }
LAB_0809d40d:
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
            errline = 0x368;
            iVar16 = elinks_strlcasecmp(e->name,e->namelen,s2,n2,1);
            if (iVar16 == 0) {
              e_01 = e->prev;
              while (html_stack != e_01) {
                kill_html_stack_item(html_context,e_01);
                e_01 = e->prev;
              }
              if (e->type != ELEMENT_IMMORTAL) {
                kill_html_stack_item(html_context,e);
                iVar16 = *(int *)((int)pvVar15 + 0x10);
                goto LAB_0809d48c;
              }
            }
            iVar16 = *(int *)((int)pvVar15 + 0x10);
          }
          else {
            if (iVar16 == 1) {
              e = (html_element *)(html_context->stack).next;
              while ((((e != html_stack && (ELEMENT_DONT_KILL < e->type)) && (e->linebreak < 1)) &&
                     (*(int *)((int)pvVar15 + 0xc) != 0))) {
                e = e->next;
              }
              goto LAB_0809d40d;
            }
          }
LAB_0809d48c:
          if (iVar16 != 2) {
            html_stack_dup(html_context,ELEMENT_KILLABLE);
            *(uchar **)((int)(html_context->stack).next + 0x9c) = s2;
            *(size_t *)((int)(html_context->stack).next + 0xa0) = n2;
            *(uchar **)((int)(html_context->stack).next + 0xa4) = start;
            *(undefined4 *)((int)(html_context->stack).next + 0xa8) =
                 *(undefined4 *)((int)pvVar15 + 0xc);
          }
          selector = (css_selector *)0x0;
          pvVar19 = (html_context->stack).next;
          if ((*(int *)((int)pvVar19 + 0xa4) != 0) &&
             ((*(byte *)&html_context->options->field_0x44 & 1) != 0)) {
            if (*(void **)((int)pvVar19 + 0x40) != (void *)0x0) {
              mem_free(*(void **)((int)pvVar19 + 0x40));
              pvVar19 = (html_context->stack).next;
            }
            s2 = get_attr_value(start,"id",html_context->doc_cp,HTML_ATTR_NONE);
            *(uchar **)((int)pvVar19 + 0x40) = s2;
            pvVar19 = (html_context->stack).next;
            if (*(void **)((int)pvVar19 + 0x44) != (void *)0x0) {
              mem_free(*(void **)((int)pvVar19 + 0x44));
              pvVar19 = (html_context->stack).next;
            }
            s2 = get_attr_value(start,(uchar *)"class",html_context->doc_cp,HTML_ATTR_NONE);
            *(uchar **)((int)pvVar19 + 0x44) = s2;
            selector = get_css_selector_for_element
                                 (html_context,(html_element *)(html_context->stack).next,
                                  (css_stylesheet *)html_context,(list_head_elinks *)html_stack);
            if (selector != (css_selector *)0x0) {
              apply_css_selector_style
                        (html_context,(html_element *)(html_context->stack).next,selector);
              done_css_selector(selector);
            }
          }
          ln_break(html_context,*(int *)((int)pvVar15 + 0xc));
          s2 = get_attr_value(start,"id",html_context->doc_cp,HTML_ATTR_NONE);
          if (s2 != (uchar *)0x0) {
            (*html_context->special_f)(html_context,0,s2);
            mem_free(s2);
          }
          if (*(code **)((int)pvVar15 + 4) != (code *)0x0) {
            (**(code **)((int)pvVar15 + 4))(html_context,start,local_34,eof,&local_34);
          }
          if (((selector != (css_selector *)0x0) &&
              (e = (html_element *)(html_context->stack).next, e->options != (uchar *)0x0)) &&
             (selector = get_css_selector_for_element
                                   (html_context,e,(css_stylesheet *)html_context,
                                    (list_head_elinks *)html_stack), selector != (css_selector *)0x0
             )) {
            apply_css_selector_style
                      (html_context,(html_element *)(html_context->stack).next,selector);
            done_css_selector(selector);
          }
          if (*(code **)((int)pvVar15 + 4) != html_br) {
            *(byte *)&html_context->field_0x44 = *(byte *)&html_context->field_0x44 & 0xfe;
          }
          if ((tVar4 & AT_PREFORMATTED) != 0) {
            pvVar15 = (html_context->stack).next;
            *(color_T *)((int)pvVar15 + 0x94) = cVar5;
            *(format_list_flag *)((int)pvVar15 + 0x90) = fVar6;
            *(int *)((int)pvVar15 + 0x8c) = n;
            *(uint *)((int)pvVar15 + 0x88) = uVar14;
            *(int *)((int)pvVar15 + 0x84) = iVar7;
            *(int *)((int)pvVar15 + 0x80) = iVar8;
            *(int *)((int)pvVar15 + 0x7c) = iVar9;
            *(int *)((int)pvVar15 + 0x78) = iVar10;
            *(format_align *)((int)pvVar15 + 0x74) = fVar11;
          }
        }
        else {
          if (((pvVar15 == (void *)0x0) ||
              ((*(code **)((int)pvVar15 + 4) != html_xmp &&
               (*(code **)((int)pvVar15 + 4) != html_style)))) || (bVar17)) {
            put_chrs(html_context,"<",1);
            bVar17 = false;
            html_00 = e_00 + 1;
            goto LAB_0809cbb5;
          }
LAB_0809d22f:
          local_34 = html_00;
          *(byte *)&html_context->field_0x44 = *(byte *)&html_context->field_0x44 & 0xfe;
          if (*(int *)((int)pvVar15 + 0x10) - 2U < 2) goto LAB_0809cda2;
          if (*(code **)((int)pvVar15 + 8) != (code *)0x0) {
            (**(code **)((int)pvVar15 + 8))(html_context,start,html_00,eof,&local_34);
          }
          e = (html_element *)(html_context->stack).next;
          if (html_stack != e) {
            bVar17 = false;
            while( true ) {
              if ((0 < e->linebreak) && (*(int *)((int)pvVar15 + 0xc) == 0)) {
                bVar17 = true;
              }
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
              errline = 0x3d1;
              n = elinks_strlcasecmp(e->name,e->namelen,s2,n2,1);
              if (n == 0) break;
              if ((e->type < ELEMENT_KILLABLE) || (e = e->next, html_stack == e)) goto LAB_0809d21d;
            }
            n = 0;
            e_01 = e;
            if (bVar17) {
              kill_html_stack_item(html_context,e);
            }
            else {
              while (html_stack != e_01) {
                piVar1 = &e_01->linebreak;
                e_01 = e_01->prev;
                if (n < *piVar1) {
                  n = *piVar1;
                }
              }
              if (html_context->was_li != 0) {
                html_context->line_breax = 0;
              }
              ln_break(html_context,n);
              while (html_stack != e->prev) {
                kill_html_stack_item(html_context,e->prev);
              }
              kill_html_stack_item(html_context,e);
            }
          }
        }
LAB_0809d21d:
        bVar17 = false;
        html_00 = local_34;
      }
      else {
LAB_0809cc10:
        html_context->putsp = HTML_SPACE_NORMAL;
        bVar2 = *len;
        if (bVar2 == 9) {
          put_chrs(html_context,html,(int)(len + -(int)html));
          html_00 = len + 1;
          uVar14 = (uint)(html_context->position >> 0x1f) >> 0x1d;
          put_chrs(html_context,"        ",(uVar14 - (html_context->position + uVar14 & 7)) + 8);
          bVar17 = false;
        }
        else {
          if ((bVar2 == 10) || (bVar2 == 0xd)) {
            put_chrs(html_context,html,(int)(len + -(int)html));
            if ((len == html) && (0 < html_context->line_breax)) {
              html_context->line_breax = html_context->line_breax + -1;
            }
            while( true ) {
              if ((*len == 0xd) && (len < eof + -1)) {
                html_00 = len + 1;
                if (len[1] == 10) {
                  html_00 = len + 2;
                }
              }
              else {
                html_00 = len + 1;
              }
              ln_break(html_context,1);
              if ((*html_00 != 10) && (*html_00 != 0xd)) break;
              html_context->line_breax = 0;
              len = html_00;
            }
            goto LAB_0809cda2;
          }
          if ((len + 5 < eof) && (bVar2 == 0x26)) {
            local_40 = 0;
            bVar17 = false;
            while (html_00[1] == 0x23) {
              bVar2 = html_00[2];
              e_00 = html_00 + 2;
              if ((bVar2 == 0x58) || (bVar2 == 0x78)) {
                e_00 = html_00 + 3;
                if (e_00 < eof) {
                  bVar2 = html_00[3];
                  while ((bVar2 == 0x30 && (e_00 = e_00 + 1, e_00 < eof))) {
                    bVar2 = *e_00;
                  }
                }
                if (eof == e_00) break;
                bVar2 = *e_00;
                if ((bVar2 == 0x41) || (bVar2 == 0x61)) {
                  bVar12 = false;
                }
                else {
                  if ((bVar2 != 0x44) && (bVar2 != 100)) break;
                  bVar12 = true;
                }
                e_00 = e_00 + 1;
              }
              else {
                if (e_00 < eof) {
                  while ((bVar2 == 0x30 && (e_00 = e_00 + 1, e_00 < eof))) {
                    bVar2 = *e_00;
                  }
                }
                if (((int)(eof + -(int)e_00) < 2) || (*e_00 != 0x31)) break;
                bVar12 = false;
                if (e_00[1] != 0x30) {
                  if (e_00[1] != 0x33) break;
                  bVar12 = true;
                }
                e_00 = e_00 + 2;
              }
              if ((eof == e_00) || (*e_00 != 0x3b)) break;
              html_00 = e_00 + 1;
              if ((bVar12) || (!bVar17)) {
                local_40 = local_40 + 1;
              }
              if ((eof <= e_00 + 6) || (bVar17 = bVar12, *html_00 != 0x26)) break;
            }
            if (local_40 != 0) {
              put_chrs(html_context,html,(int)(len + -(int)html));
              ln_break(html_context,local_40);
              bVar17 = false;
              goto LAB_0809cbb5;
            }
            bVar2 = *html_00;
          }
LAB_0809cb00:
          local_40 = 0;
          if (bVar2 < 0x20) {
            do {
              if (html_00 != html) {
                put_chrs(html_context,html,(int)(html_00 + -(int)html));
              }
              local_40 = local_40 + 1;
              len = html_00 + 1;
              html_00 = html_00 + 1;
              html = html_00;
            } while (((*len < 0x20) && (html_00 < eof)) &&
                    ((*(byte *)((int)*ppuVar13 + (uint)*len * 2 + 1) & 0x20) == 0));
            start = (uchar *)mem_alloc(local_40);
            bVar17 = false;
            if (start != (uchar *)0x0) {
              memset(start,0x2e,local_40);
              put_chrs(html_context,start,local_40);
              mem_free(start);
              bVar17 = false;
            }
          }
          else {
            if (eof < html_00 + 2) {
              if (bVar2 == 0x3c) {
LAB_0809ce86:
                n = parse_element(html_00,eof,local_20,(int *)&local_2c,&local_24,&local_28);
                if (n == 0) {
                  len = html_00 + -(int)html;
                  e_00 = html_00;
                  goto element;
                }
              }
            }
            else {
              if (bVar2 == 0x3c) {
                if (((html_00[1] != 0x3f) && (html_00[1] != 0x21)) ||
                   ((*(byte *)&html_context->field_0x44 & 6) != 0)) goto LAB_0809ce86;
                put_chrs(html_context,html,(int)(html_00 + -(int)html));
                html_00 = skip_comment(html_00,eof);
                bVar17 = false;
                goto LAB_0809cbb5;
              }
            }
            html_00 = html_00 + 1;
            bVar17 = true;
          }
        }
      }
LAB_0809cbb5:
      len = html_00;
    } while (html_00 < eof);
    if (bVar17) {
      put_chrs(html_context,html,(int)(html_00 + -(int)html));
    }
  }
LAB_0809cbd6:
  ln_break(html_context,1);
  *(byte *)&html_context->field_0x44 = *(byte *)&html_context->field_0x44 & 0xfe;
  html_context->part = part;
  html_context->putsp = HTML_SPACE_SUPPRESS;
  html_context->position = 0;
  return;
}



int get_width(uchar *a,uchar *name,int limited,html_context *html_context)

{
  byte *pbVar1;
  ushort *puVar2;
  void *pvVar3;
  bool bVar4;
  byte *p;
  ushort **ppuVar5;
  int iVar6;
  int iVar7;
  int *piVar8;
  ulong uVar9;
  byte *pbVar10;
  byte *__nptr;
  byte bVar11;
  char *local_20 [4];
  
  p = get_attr_value(a,name,html_context->doc_cp,HTML_ATTR_NONE);
  if (p == (byte *)0x0) {
    return -1;
  }
  ppuVar5 = __ctype_b_loc();
  puVar2 = *ppuVar5;
  __nptr = p;
  while (bVar11 = *__nptr, (*(byte *)((int)puVar2 + (uint)bVar11 * 2 + 1) & 0x20) != 0) {
    __nptr = __nptr + 1;
  }
  if ((bVar11 != 0x2c) && (bVar11 != 0)) {
    iVar6 = 0;
    do {
      iVar7 = iVar6;
      iVar6 = iVar7 + 1;
      if (__nptr[iVar6] == 0x2c) break;
    } while (__nptr[iVar6] != 0);
    if (iVar6 != 0) {
      bVar11 = __nptr[iVar7];
      if ((*(byte *)((int)puVar2 + (uint)bVar11 * 2 + 1) & 0x20) != 0) {
        pbVar10 = __nptr + iVar6;
        do {
          iVar6 = iVar6 + -1;
          if (iVar6 == 0) goto LAB_0809da5e;
          bVar11 = pbVar10[-2];
          pbVar10 = pbVar10 + -1;
        } while ((*(byte *)((int)puVar2 + (uint)bVar11 * 2 + 1) & 0x20) != 0);
      }
      bVar4 = false;
      iVar7 = iVar6;
      if (bVar11 == 0x25) {
        iVar7 = iVar6 + -1;
        if (iVar7 == 0) {
LAB_0809dab3:
          mem_free(p);
          return -1;
        }
        bVar11 = __nptr[iVar6 + -2];
        bVar4 = true;
      }
      if ((*(byte *)((int)puVar2 + (uint)bVar11 * 2 + 1) & 0x20) != 0) {
        pbVar10 = __nptr + iVar7;
        do {
          iVar7 = iVar7 + -1;
          if (iVar7 == 0) goto LAB_0809dab3;
          pbVar1 = pbVar10 + -2;
          pbVar10 = pbVar10 + -1;
        } while ((*(byte *)((int)puVar2 + (uint)*pbVar1 * 2 + 1) & 0x20) != 0);
      }
      __nptr[iVar7] = 0;
      piVar8 = __errno_location();
      *piVar8 = 0;
      uVar9 = strtoul((char *)__nptr,local_20,10);
      if ((*piVar8 != 0) ||
         (((*local_20[0] != '.' && (*local_20[0] != '\0')) || (uVar9 == 0x7fffffff)))) {
        mem_free(p);
        return -1;
      }
      mem_free(p);
      if (limited == 0) {
        if (bVar4) {
          return -1;
        }
        iVar6 = (int)(uVar9 + 3) / 7;
      }
      else {
        pvVar3 = (html_context->stack).next;
        iVar6 = (-*(int *)((int)pvVar3 + 0x78) - *(int *)((int)pvVar3 + 0x7c)) +
                *(int *)((int)pvVar3 + 0x80);
        iVar7 = 0;
        if (-1 < iVar6) {
          iVar7 = iVar6;
        }
        if (bVar4) {
          iVar6 = (int)(uVar9 * iVar7) / 100;
        }
        else {
          iVar6 = (int)(uVar9 + 3) / 7;
        }
        if (iVar7 < iVar6) {
          return iVar7;
        }
      }
      if (iVar6 < 0) {
        iVar6 = 0;
      }
      return iVar6;
    }
  }
LAB_0809da5e:
  mem_free(p);
  return -1;
}



int get_num(uchar *a,uchar *name,int cp)

{
  uchar *p;
  int *piVar1;
  long lVar2;
  char *local_10;
  
  lVar2 = -1;
  p = get_attr_value(a,name,cp,HTML_ATTR_NONE);
  if (p != (uchar *)0x0) {
    piVar1 = __errno_location();
    *piVar1 = 0;
    lVar2 = strtol((char *)p,&local_10,10);
    if ((((*piVar1 != 0) || (*p == '\0')) || (lVar2 < 0)) || (*local_10 != '\0')) {
      lVar2 = -1;
    }
    mem_free(p);
  }
  return lVar2;
}



html_element * search_html_stack(html_context *html_context,uchar *name)

{
  size_t n2;
  int iVar1;
  html_element *phVar2;
  
  if (assert_failed == 0) {
    if ((name == (uchar *)0x0) || (*name == '\0')) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
      errline = 0x37;
      elinks_internal((uchar *)"assertion name && *name failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  n2 = strlen((char *)name);
  phVar2 = (html_element *)(html_context->stack).next;
  if (phVar2 == (html_element *)&html_context->stack) {
LAB_0809dd70:
    phVar2 = (html_element *)0x0;
  }
  else {
    do {
      do {
        phVar2 = phVar2->next;
        if (phVar2 == (html_element *)&html_context->stack) goto LAB_0809dd70;
      } while ((html_element *)(html_context->stack).next == phVar2);
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
      errline = 0x41;
      iVar1 = elinks_strlcasecmp(phVar2->name,phVar2->namelen,name,n2,1);
    } while (iVar1 != 0);
  }
  return phVar2;
}



void html_stack_dup(html_context *html_context,html_element_mortality_type type)

{
  list_head_elinks *plVar1;
  void *pvVar2;
  void **ppvVar3;
  uchar *puVar4;
  int iVar5;
  list_head_elinks *plVar6;
  void **ppvVar7;
  byte bVar8;
  
  bVar8 = 0;
  plVar1 = (list_head_elinks *)(html_context->stack).next;
  if (assert_failed == 0) {
    if ((plVar1 == (list_head_elinks *)0x0) || (&html_context->stack == plVar1)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
      errline = 0x8c;
      elinks_internal((uchar *)
                      "assertion ep && (void *) ep != &html_context->stack failed: html stack empty"
                     );
      if (assert_failed != 0) goto LAB_0809df18;
    }
    else {
      assert_failed = 0;
    }
    ppvVar3 = (void **)mem_alloc(0xb4);
    if (ppvVar3 != (void **)0x0) {
      iVar5 = 0x2d;
      plVar6 = plVar1;
      ppvVar7 = ppvVar3;
      while (iVar5 != 0) {
        iVar5 = iVar5 + -1;
        *ppvVar7 = plVar6->next;
        plVar6 = (list_head_elinks *)&plVar6[(uint)bVar8 * 0x1fffffff].prev;
        ppvVar7 = ppvVar7 + (uint)bVar8 * 0x3ffffffe + 1;
      }
      if ((uchar *)plVar1[3].prev != (uchar *)0x0) {
        puVar4 = stracpy((uchar *)plVar1[3].prev);
        *(uchar **)(ppvVar3 + 7) = puVar4;
      }
      if ((uchar *)plVar1[4].next != (uchar *)0x0) {
        puVar4 = stracpy((uchar *)plVar1[4].next);
        *(uchar **)(ppvVar3 + 8) = puVar4;
      }
      if ((uchar *)plVar1[4].prev != (uchar *)0x0) {
        puVar4 = stracpy((uchar *)plVar1[4].prev);
        *(uchar **)(ppvVar3 + 9) = puVar4;
      }
      if ((uchar *)plVar1[5].next != (uchar *)0x0) {
        puVar4 = stracpy((uchar *)plVar1[5].next);
        *(uchar **)(ppvVar3 + 10) = puVar4;
      }
      if ((uchar *)plVar1[9].next != (uchar *)0x0) {
        puVar4 = stracpy((uchar *)plVar1[9].next);
        *(uchar **)(ppvVar3 + 0x12) = puVar4;
      }
      ppvVar3[0x11] = (void *)0x0;
      ppvVar3[0x10] = (void *)0x0;
      ppvVar3[0x1c] = (void *)0x0;
      ppvVar3[0x1b] = (void *)0x0;
      ppvVar3[0x1a] = (void *)0x0;
      ppvVar3[0x19] = (void *)0x0;
      ppvVar3[0x18] = (void *)0x0;
      ppvVar3[0x17] = (void *)0x0;
      ppvVar3[0x16] = (void *)0x0;
      ppvVar3[0x29] = (void *)0x0;
      ppvVar3[0x27] = (void *)0x0;
      ppvVar3[0x28] = (void *)0x0;
      *(html_element_mortality_type *)(ppvVar3 + 2) = type;
      pvVar2 = (html_context->stack).next;
      *(list_head_elinks **)(ppvVar3 + 1) = &html_context->stack;
      *ppvVar3 = pvVar2;
      *(void ***)&(html_context->stack).next = ppvVar3;
      *(void ***)((int)*ppvVar3 + 4) = ppvVar3;
      return;
    }
  }
  else {
LAB_0809df18:
    assert_failed = 0;
  }
  return;
}



void kill_html_stack_item(html_context *html_context,html_element *e)

{
  uchar *p;
  bool bVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(e == (html_element *)0x0);
  if (e == (html_element *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
    errline = 0x51;
    elinks_internal((uchar *)"assertion e failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  bVar1 = (html_element *)&html_context->stack == e;
  assert_failed = ZEXT14(bVar1);
  if (bVar1) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
    errline = 0x53;
    elinks_internal((uchar *)
                    "assertion (void *) e != &html_context->stack failed: trying to free bad html element"
                   );
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  bVar1 = e->type == ELEMENT_IMMORTAL;
  assert_failed = ZEXT14(bVar1);
  if (bVar1) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
    errline = 0x55;
    elinks_internal((uchar *)
                    "assertion e->type != ELEMENT_IMMORTAL failed: trying to kill unkillable element"
                   );
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  p = (e->attr).link;
  if (p != (uchar *)0x0) {
    mem_free(p);
  }
  p = (e->attr).target;
  if (p != (uchar *)0x0) {
    mem_free(p);
  }
  p = (e->attr).image;
  if (p != (uchar *)0x0) {
    mem_free(p);
  }
  p = (e->attr).title;
  if (p != (uchar *)0x0) {
    mem_free(p);
  }
  p = (e->attr).select;
  if (p != (uchar *)0x0) {
    mem_free(p);
  }
  p = (e->attr).id;
  if (p != (uchar *)0x0) {
    mem_free(p);
  }
  p = (e->attr).class;
  if (p != (uchar *)0x0) {
    mem_free(p);
  }
  p = (e->attr).onclick;
  if (p != (uchar *)0x0) {
    mem_free(p);
  }
  p = (e->attr).ondblclick;
  if (p != (uchar *)0x0) {
    mem_free(p);
  }
  p = (e->attr).onmouseover;
  if (p != (uchar *)0x0) {
    mem_free(p);
  }
  p = (e->attr).onhover;
  if (p != (uchar *)0x0) {
    mem_free(p);
  }
  p = (e->attr).onfocus;
  if (p != (uchar *)0x0) {
    mem_free(p);
  }
  p = (e->attr).onmouseout;
  if (p != (uchar *)0x0) {
    mem_free(p);
  }
  p = (e->attr).onblur;
  if (p != (uchar *)0x0) {
    mem_free(p);
  }
  e->next->prev = e->prev;
  e->prev->next = e->next;
  mem_free(e);
  return;
}



void __regparm3 kill_element(html_context *html_context,int ls,html_element *e)

{
  void **ppvVar1;
  void *n;
  
  n = (void *)0x0;
  if (e != (html_element *)&html_context->stack) {
    do {
      if ((ls != 0) && ((html_element *)(html_context->stack).next == e)) break;
      ppvVar1 = (void **)&e->linebreak;
      e = e->prev;
      if ((int)n < (int)*ppvVar1) {
        n = *ppvVar1;
      }
      kill_html_stack_item(html_context,e->next);
    } while (e != (html_element *)&html_context->stack);
  }
  ln_break(html_context,(int)n);
  return;
}



void kill_html_stack_until(html_context *html_context,int ls,...)

{
  uchar *s2;
  char cVar1;
  size_t n2;
  int iVar2;
  uchar **ppuVar3;
  int iVar4;
  html_element *local_20;
  
  local_20 = (html_element *)(html_context->stack).next;
  if (ls != 0) {
    local_20 = local_20->next;
  }
  if (local_20 != (html_element *)&html_context->stack) {
    while( true ) {
      ppuVar3 = (uchar **)&stack0x0000000c;
      iVar4 = 0;
      do {
        s2 = *ppuVar3;
        while( true ) {
          if (s2 == (uchar *)0x0) goto LAB_0809e1fc;
          ppuVar3 = ppuVar3 + 1;
          n2 = strlen((char *)s2);
          if (n2 != 0) break;
          iVar4 = iVar4 + 1;
          s2 = *ppuVar3;
        }
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
        errline = 0xdd;
        iVar2 = elinks_strlcasecmp(local_20->name,local_20->namelen,s2,n2,1);
      } while (iVar2 != 0);
      if (iVar4 == 0) break;
      if (iVar4 == 1) {
        kill_element(html_context,ls,local_20->prev);
        return;
      }
LAB_0809e1fc:
      if (local_20->type < ELEMENT_KILLABLE) {
        return;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
      errline = 0xf3;
      iVar4 = elinks_strlcasecmp(local_20->name,local_20->namelen,"TABLE",5,1);
      if (iVar4 == 0) {
        return;
      }
      if ((local_20->namelen == 2) && (iVar4 = c_toupper((uint)*local_20->name), iVar4 == 0x54)) {
        iVar4 = c_toupper((uint)local_20->name[1]);
        cVar1 = (char)iVar4;
        if (cVar1 == 'H') {
          return;
        }
        if (cVar1 == 'D') {
          return;
        }
        if (cVar1 == 'R') {
          return;
        }
      }
      local_20 = local_20->next;
      if (local_20 == (html_element *)&html_context->stack) {
        return;
      }
    }
    if (ELEMENT_DONT_KILL < local_20->type) {
      kill_element(html_context,ls,local_20);
      return;
    }
  }
  return;
}



void __regparm3 add_table_bad_html_end(table_elinks *table_elinks,uchar *end)

{
  if (((table_elinks->caption).start != (uchar *)0x0) &&
     ((table_elinks->caption).end == (uchar *)0x0)) {
    (table_elinks->caption).end = end;
    return;
  }
  if ((table_elinks->bad_html_size != 0) &&
     (table_elinks->bad_html[table_elinks->bad_html_size + -1].end == (uchar *)0x0)) {
    table_elinks->bad_html[table_elinks->bad_html_size + -1].end = end;
    return;
  }
  return;
}



void free_table(table_elinks *table_elinks)

{
  int iVar1;
  table_cell *ptVar2;
  table_cell *p;
  table_cell *ptVar3;
  int iVar4;
  int iVar5;
  
  if (table_elinks->min_cols_widths != (int *)0x0) {
    mem_free(table_elinks->min_cols_widths);
  }
  if (table_elinks->max_cols_widths != (int *)0x0) {
    mem_free(table_elinks->max_cols_widths);
  }
  if (table_elinks->cols_widths != (int *)0x0) {
    mem_free(table_elinks->cols_widths);
  }
  if (table_elinks->rows_heights != (int *)0x0) {
    mem_free(table_elinks->rows_heights);
  }
  if (table_elinks->fragment_id != (uchar *)0x0) {
    mem_free(table_elinks->fragment_id);
  }
  if (table_elinks->cols_x != (int *)0x0) {
    mem_free(table_elinks->cols_x);
  }
  if (table_elinks->bad_html != (html_start_end *)0x0) {
    mem_free(table_elinks->bad_html);
  }
  if (table_elinks->cols < 1) {
    p = table_elinks->cells;
  }
  else {
    iVar5 = 0;
    ptVar2 = table_elinks->cells;
    ptVar3 = table_elinks->cells;
    do {
      while (p = ptVar3, ptVar3 = p, table_elinks->rows < 1) {
        iVar5 = iVar5 + 1;
        ptVar2 = p;
        if (table_elinks->cols == iVar5 || table_elinks->cols < iVar5) goto LAB_0809e488;
      }
      iVar1 = table_elinks->real_cols;
      iVar4 = 0;
      while( true ) {
        if (ptVar3[iVar1 * iVar4 + iVar5].fragment_id != (uchar *)0x0) {
          mem_free(ptVar3[iVar1 * iVar4 + iVar5].fragment_id);
          ptVar2 = table_elinks->cells;
          ptVar3 = ptVar2;
        }
        iVar4 = iVar4 + 1;
        if (table_elinks->rows == iVar4 || table_elinks->rows < iVar4) break;
        iVar1 = table_elinks->real_cols;
      }
      iVar5 = iVar5 + 1;
      p = ptVar2;
    } while (table_elinks->cols != iVar5 && iVar5 <= table_elinks->cols);
  }
LAB_0809e488:
  mem_free(p);
  mem_free(table_elinks->columns);
  mem_free(table_elinks);
  return;
}



void __regparm3 get_align(html_context *html_context,uchar *attr,int *a)

{
  uchar *p;
  int iVar1;
  
  p = get_attr_value(attr,"align",html_context->doc_cp,HTML_ATTR_NONE);
  if (p == (uchar *)0x0) {
    return;
  }
  iVar1 = c_strcasecmp((char *)p,"left");
  if (iVar1 == 0) {
    *a = 0;
    goto LAB_0809e509;
  }
  iVar1 = c_strcasecmp((char *)p,"right");
  if (iVar1 != 0) {
    iVar1 = c_strcasecmp((char *)p,"center");
    if (iVar1 == 0) {
      *a = 1;
      goto LAB_0809e509;
    }
    iVar1 = c_strcasecmp((char *)p,"justify");
    if (iVar1 == 0) {
      *a = 3;
      goto LAB_0809e509;
    }
    iVar1 = c_strcasecmp((char *)p,"char");
    if (iVar1 != 0) goto LAB_0809e509;
  }
  *a = 2;
LAB_0809e509:
  mem_free(p);
  return;
}



void __regparm3 get_valign(html_context *html_context,uchar *attr,int *a)

{
  uchar *p;
  int iVar1;
  
  p = get_attr_value(attr,(uchar *)"valign",html_context->doc_cp,HTML_ATTR_NONE);
  if (p == (uchar *)0x0) {
    return;
  }
  iVar1 = c_strcasecmp((char *)p,"top");
  if (iVar1 != 0) {
    iVar1 = c_strcasecmp((char *)p,"middle");
    if (iVar1 == 0) {
      *a = 1;
      goto LAB_0809e5d9;
    }
    iVar1 = c_strcasecmp((char *)p,"bottom");
    if (iVar1 == 0) {
      *a = 2;
      goto LAB_0809e5d9;
    }
    iVar1 = c_strcasecmp((char *)p,"baseline");
    if (iVar1 != 0) goto LAB_0809e5d9;
  }
  *a = 0;
LAB_0809e5d9:
  mem_free(p);
  return;
}



void __regparm3 set_td_width(table_elinks *table_elinks,int col,int width,int force)

{
  bool bVar1;
  int *piVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int *piVar6;
  
  iVar3 = table_elinks->cols_x_count;
  if (col < iVar3) {
    piVar2 = table_elinks->cols_x;
  }
  else {
    iVar5 = iVar3;
    do {
      if (col + 1 <= iVar5) {
        if (iVar5 != 0) goto LAB_0809e6e3;
        break;
      }
      iVar4 = iVar5 * 2;
      if (0xffff < iVar5) {
        iVar4 = iVar5 + 0x10000;
      }
      bVar1 = iVar5 < iVar4;
      iVar5 = iVar4;
    } while (bVar1);
    iVar5 = col + 1;
    if (iVar3 != 0) {
      return;
    }
LAB_0809e6e3:
    piVar2 = (int *)mem_realloc(table_elinks->cols_x,iVar5 * 4);
    if (piVar2 == (int *)0x0) {
      return;
    }
    iVar3 = table_elinks->cols_x_count;
    if (iVar3 < iVar5) {
      piVar6 = piVar2 + iVar3;
      do {
        iVar3 = iVar3 + 1;
        *piVar6 = -1;
        piVar6 = piVar6 + 1;
      } while (iVar3 < iVar5);
    }
    table_elinks->cols_x_count = iVar5;
    table_elinks->cols_x = piVar2;
  }
  if (force == 0) {
    piVar2 = piVar2 + col;
    iVar3 = *piVar2;
    if (iVar3 != -1) {
      if (width == -1) {
        return;
      }
      if (width < 0) {
        if (-1 < iVar3) goto LAB_0809e696;
      }
      else {
        if (iVar3 < 0) {
          return;
        }
      }
      *piVar2 = iVar3 + width >> 1;
      return;
    }
  }
  else {
    piVar2 = table_elinks->cols_x + col;
  }
LAB_0809e696:
  *piVar2 = width;
  return;
}



void __regparm3 get_column_width(uchar *attr,int *width,int sh,html_context *html_context)

{
  uchar *p;
  size_t sVar1;
  int iVar2;
  int *piVar3;
  ulong uVar4;
  char *local_20 [4];
  
  p = get_attr_value(attr,"width",html_context->doc_cp,HTML_ATTR_NONE);
  if (p != (uchar *)0x0) {
    sVar1 = strlen((char *)p);
    if ((sVar1 == 0) || (p[sVar1 - 1] != '*')) {
      iVar2 = get_width(attr,"width",sh,html_context);
      if (-1 < iVar2) {
        *width = iVar2;
      }
    }
    else {
      p[sVar1 - 1] = '\0';
      piVar3 = __errno_location();
      *piVar3 = 0;
      uVar4 = strtoul((char *)p,local_20,10);
      if (((-1 < (int)uVar4) && (*piVar3 == 0)) && ((*local_20[0] == '.' || (*local_20[0] == '\0')))
         ) {
        *width = -2 - uVar4;
      }
    }
    mem_free(p);
  }
  return;
}



table_cell * __regparm3 new_cell(table_elinks *table_elinks,int dest_col,int dest_row)

{
  bool bVar1;
  table_cell *ptVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  size_t __n;
  table_cell *__dest;
  int iVar6;
  
  if ((table_elinks->cols != dest_col && dest_col <= table_elinks->cols) &&
     (table_elinks->rows != dest_row && dest_row <= table_elinks->rows)) {
    return table_elinks->cells + table_elinks->real_cols * dest_row + dest_col;
  }
  iVar4 = table_elinks->real_cols;
  while( true ) {
    if ((dest_col < iVar4) && (dest_row < table_elinks->real_rows)) {
      iVar6 = table_elinks->cols;
      if (iVar6 <= dest_col) {
        if ((iVar6 != 0) && (0 < table_elinks->rows)) {
          iVar3 = 0;
          while( true ) {
            __dest = table_elinks->cells;
            ptVar2 = __dest + iVar4 * iVar3 + iVar6 + -1;
            if ((ptVar2->colspan == -1) && (iVar5 = table_elinks->cols, iVar5 <= dest_col)) {
              while( true ) {
                iVar4 = iVar4 * iVar3 + iVar5;
                iVar5 = iVar5 + 1;
                __dest = __dest + iVar4;
                *(byte *)&__dest->field_0x3c = *(byte *)&__dest->field_0x3c | 3;
                iVar4 = ptVar2->rowspan;
                __dest->colspan = -1;
                __dest->rowspan = iVar4;
                __dest->col = ptVar2->col;
                __dest->row = ptVar2->row;
                if (dest_col < iVar5) break;
                __dest = table_elinks->cells;
                iVar4 = table_elinks->real_cols;
              }
            }
            iVar3 = iVar3 + 1;
            if (table_elinks->rows <= iVar3) break;
            iVar4 = table_elinks->real_cols;
          }
        }
        table_elinks->cols = dest_col + 1;
      }
      iVar4 = table_elinks->rows;
      if (iVar4 <= dest_row) {
        if ((iVar4 != 0) && (0 < table_elinks->cols)) {
          iVar6 = 0;
          do {
            iVar3 = table_elinks->real_cols;
            __dest = table_elinks->cells;
            ptVar2 = __dest + iVar6 + (iVar4 + -1) * iVar3;
            if ((ptVar2->rowspan == -1) && (iVar5 = table_elinks->rows, iVar5 <= dest_row)) {
              while( true ) {
                iVar3 = iVar3 * iVar5;
                iVar5 = iVar5 + 1;
                __dest = __dest + iVar3 + iVar6;
                *(byte *)&__dest->field_0x3c = *(byte *)&__dest->field_0x3c | 3;
                __dest->rowspan = -1;
                __dest->colspan = ptVar2->colspan;
                __dest->col = ptVar2->col;
                __dest->row = ptVar2->row;
                if (dest_row < iVar5) break;
                __dest = table_elinks->cells;
                iVar3 = table_elinks->real_cols;
              }
            }
            iVar6 = iVar6 + 1;
          } while (iVar6 < table_elinks->cols);
        }
        table_elinks->rows = dest_row + 1;
      }
      return table_elinks->cells + dest_row * table_elinks->real_cols + dest_col;
    }
    while (iVar4 < dest_col + 1) {
      iVar6 = iVar4 * 2;
      if (0x7ff < iVar4) {
        iVar6 = iVar4 + 0x800;
      }
      bVar1 = iVar6 <= iVar4;
      iVar4 = iVar6;
      if (bVar1) {
        return (table_cell *)0x0;
      }
    }
    if (iVar4 == 0) {
      return (table_cell *)0x0;
    }
    iVar6 = table_elinks->real_rows;
    if (iVar6 < dest_row + 1) {
      iVar5 = (0x1000 - iVar4) * 0x40;
      iVar3 = 0x20000;
      if (0x1ffff < iVar5) {
        iVar3 = iVar5;
      }
      iVar5 = iVar6;
      do {
        iVar6 = iVar5 * 2;
        if (iVar3 >> 6 <= iVar5) {
          iVar6 = iVar5 + (iVar3 >> 6);
        }
        if (iVar6 <= iVar5) {
          return (table_cell *)0x0;
        }
        iVar5 = iVar6;
      } while (iVar6 < dest_row + 1);
    }
    if (iVar6 == 0) {
      return (table_cell *)0x0;
    }
    ptVar2 = (table_cell *)mem_calloc(iVar6 * iVar4,0x40);
    if (ptVar2 == (table_cell *)0x0) break;
    __n = table_elinks->cols << 6;
    if ((__n != 0) && (0 < table_elinks->rows)) {
      iVar3 = table_elinks->real_cols;
      iVar5 = 0;
      __dest = ptVar2;
      while( true ) {
        iVar3 = iVar3 * iVar5;
        iVar5 = iVar5 + 1;
        memcpy(__dest,table_elinks->cells + iVar3,__n);
        __dest = __dest + iVar4;
        if (table_elinks->rows <= iVar5) break;
        iVar3 = table_elinks->real_cols;
      }
    }
    mem_free(table_elinks->cells);
    table_elinks->real_cols = iVar4;
    table_elinks->real_rows = iVar6;
    table_elinks->cells = ptVar2;
  }
  return (table_cell *)0x0;
}



void __regparm3
new_columns(table_elinks *table_elinks,int span,int width,int align,int valign,int group)

{
  int iVar1;
  table_column *ptVar2;
  int iVar3;
  int iVar4;
  
  iVar1 = table_elinks->columns_count + span;
  iVar3 = table_elinks->real_columns_count;
  if (table_elinks->real_columns_count < iVar1) {
    do {
      iVar4 = iVar3 * 2;
      if (0x3fff < iVar3) {
        iVar4 = iVar3 + 0x4000;
      }
      if (iVar4 <= iVar3) {
        return;
      }
      iVar3 = iVar4;
    } while (iVar4 < iVar1);
    if (iVar4 == 0) {
      return;
    }
    ptVar2 = (table_column *)mem_realloc(table_elinks->columns,iVar4 << 4);
    if (ptVar2 == (table_column *)0x0) {
      return;
    }
    table_elinks->real_columns_count = iVar4;
    table_elinks->columns = ptVar2;
  }
  if (span != 0) {
    do {
      iVar3 = table_elinks->columns_count;
      table_elinks->columns_count = iVar3 + 1;
      ptVar2 = table_elinks->columns + iVar3;
      ptVar2->align = align;
      ptVar2->group = group;
      group = 0;
      span = span + -1;
      ptVar2->width = width;
      ptVar2->valign = valign;
    } while (span != 0);
  }
  return;
}



table_elinks *
parse_table(uchar *html,uchar *eof,uchar **end,uchar *attr,int sh,html_context *html_context)

{
  byte *pbVar1;
  int iVar2;
  uchar uVar3;
  void *pvVar4;
  char cVar5;
  byte bVar6;
  table_elinks *table_elinks;
  uchar *str;
  int span;
  html_start_end *p;
  size_t count;
  int *piVar7;
  table_cell *ptVar8;
  table_column *ptVar9;
  int width;
  uint uVar10;
  size_t sVar11;
  int iVar12;
  uchar *html_00;
  uint uVar13;
  table_cell *ptVar14;
  bool bVar15;
  bool bVar16;
  byte bVar17;
  int local_80;
  int local_7c;
  uchar *local_78;
  int local_74;
  int local_70;
  int local_6c;
  int local_68;
  int local_64;
  size_t local_50;
  uchar *local_4c;
  uchar *local_48;
  size_t local_44;
  uchar *local_40;
  uchar *local_3c;
  int local_38;
  int local_34;
  size_t local_30;
  color_T local_2c;
  byte *local_28;
  uchar *local_24;
  uchar *local_20 [4];
  
  bVar17 = 0;
  local_34 = 0;
  local_38 = 1;
  local_3c = (uchar *)0xffffffff;
  local_40 = (uchar *)0xffffffff;
  local_44 = 0xffffffff;
  *end = html;
  table_elinks = (table_elinks *)mem_calloc(1,0x94);
  if (table_elinks == (table_elinks *)0x0) {
    return (table_elinks *)0x0;
  }
  ptVar8 = (table_cell *)mem_calloc(4,0x40);
  table_elinks->cells = ptVar8;
  if (ptVar8 == (table_cell *)0x0) {
    mem_free(table_elinks);
    return (table_elinks *)0x0;
  }
  table_elinks->real_cols = 2;
  table_elinks->real_rows = 2;
  ptVar9 = (table_column *)mem_calloc(2,0x10);
  table_elinks->columns = ptVar9;
  if (ptVar9 == (table_column *)0x0) {
    mem_free(table_elinks->cells);
    mem_free(table_elinks);
    return (table_elinks *)0x0;
  }
  table_elinks->real_columns_count = 2;
  str = get_attr_value(attr,"id",html_context->doc_cp,HTML_ATTR_NONE);
  table_elinks->fragment_id = str;
  if (((html_context->options->color_mode != COLOR_MODE_MONO) &&
      (0 < html_context->options->use_document_colors)) &&
     ((str = get_attr_value(attr,(uchar *)"bordercolor",html_context->doc_cp,HTML_ATTR_NONE),
      str != (uchar *)0x0 ||
      ((str = get_attr_value(attr,(uchar *)"bordercolorlight",html_context->doc_cp,HTML_ATTR_NONE),
       str != (uchar *)0x0 ||
       (str = get_attr_value(attr,(uchar *)"bordercolordark",html_context->doc_cp,HTML_ATTR_NONE),
       str != (uchar *)0x0)))))) {
    uVar10 = 0xffffffff;
    html_00 = str;
    do {
      if (uVar10 == 0) break;
      uVar10 = uVar10 - 1;
      uVar3 = *html_00;
      html_00 = html_00 + (uint)bVar17 * -2 + 1;
    } while (uVar3 != '\0');
    decode_color(str,~uVar10 - 1,&table_elinks->bordercolor);
    mem_free(str);
  }
  span = get_width(attr,"width",sh,html_context);
  table_elinks->width = span;
  if (span == -1) {
    pvVar4 = (html_context->stack).next;
    width = (-*(int *)((int)pvVar4 + 0x78) - *(int *)((int)pvVar4 + 0x7c)) +
            *(int *)((int)pvVar4 + 0x80);
    span = 0;
    if (-1 < width) {
      span = width;
    }
    table_elinks->width = span;
    *(byte *)&table_elinks->field_0x7c = *(byte *)&table_elinks->field_0x7c | 1;
  }
  span = get_num(attr,(uchar *)"border",html_context->doc_cp);
  table_elinks->border = span;
  if (span == -1) {
    str = get_attr_value(attr,(uchar *)"border",html_context->doc_cp,HTML_ATTR_TEST);
    span = 1;
    if (str == (uchar *)0x0) {
      str = get_attr_value(attr,(uchar *)"rules",html_context->doc_cp,HTML_ATTR_TEST);
      if (str == (uchar *)0x0) {
        str = get_attr_value(attr,"frame",html_context->doc_cp,HTML_ATTR_TEST);
        span = 0;
        if (str == (uchar *)0x0) goto LAB_0809f76a;
      }
      span = 1;
    }
LAB_0809f76a:
    table_elinks->border = span;
  }
  if (span != 0) {
    if (2 < span) {
      table_elinks->border = 2;
    }
    span = get_num(attr,(uchar *)"cellspacing",html_context->doc_cp);
    table_elinks->cellspacing = span;
    if (span < 1) {
      table_elinks->cellspacing = 1;
    }
    else {
      if (2 < span) {
        table_elinks->cellspacing = 2;
      }
    }
    if (table_elinks->border != 0) {
      table_elinks->frame = 0xf;
      str = get_attr_value(attr,"frame",html_context->doc_cp,HTML_ATTR_NONE);
      if (str != (uchar *)0x0) {
        span = c_strcasecmp((char *)str,"void");
        if (span == 0) {
          table_elinks->frame = 0;
        }
        else {
          span = c_strcasecmp((char *)str,"above");
          if (span == 0) {
            table_elinks->frame = 1;
          }
          else {
            span = c_strcasecmp((char *)str,"below");
            if (span == 0) {
              table_elinks->frame = 2;
            }
            else {
              span = c_strcasecmp((char *)str,"hsides");
              if (span == 0) {
                table_elinks->frame = 3;
              }
              else {
                span = c_strcasecmp((char *)str,"vsides");
                if (span == 0) {
                  table_elinks->frame = 0xc;
                }
                else {
                  span = c_strcasecmp((char *)str,"lhs");
                  if (span == 0) {
                    table_elinks->frame = 4;
                  }
                  else {
                    span = c_strcasecmp((char *)str,"rhs");
                    if (span == 0) {
                      table_elinks->frame = 8;
                    }
                  }
                }
              }
            }
          }
        }
        mem_free(str);
      }
      goto LAB_0809ee60;
    }
  }
  table_elinks->frame = 0;
LAB_0809ee60:
  span = get_num(attr,(uchar *)"cellpadding",html_context->doc_cp);
  table_elinks->cellpadding = span;
  if (span == -1) {
    table_elinks->vcellpadding = 0;
    table_elinks->cellpadding = (uint)(table_elinks->border != 0);
  }
  else {
    table_elinks->vcellpadding = (uint)(6 < span);
    table_elinks->cellpadding = (uint)(3 < span);
  }
  table_elinks->rules = ~-(uint)(table_elinks->border == 0) & 3;
  str = get_attr_value(attr,(uchar *)"rules",html_context->doc_cp,HTML_ATTR_NONE);
  if (str != (uchar *)0x0) {
    span = c_strcasecmp((char *)str,"none");
    if (span == 0) {
      table_elinks->rules = 0;
    }
    else {
      span = c_strcasecmp((char *)str,"groups");
      if (span == 0) {
        table_elinks->rules = 4;
      }
      else {
        span = c_strcasecmp((char *)str,"rows");
        if (span == 0) {
          table_elinks->rules = 1;
        }
        else {
          span = c_strcasecmp((char *)str,"cols");
          if (span == 0) {
            table_elinks->rules = 2;
          }
          else {
            span = c_strcasecmp((char *)str,"all");
            if (span == 0) {
              table_elinks->rules = 3;
            }
          }
        }
      }
    }
    mem_free(str);
  }
  table_elinks->align = *(int *)((int)(html_context->stack).next + 0x74);
  get_align(html_context,attr,&table_elinks->align);
  table_elinks->bgcolor = *(color_T *)((int)(html_context->stack).next + 0x94);
  get_bgcolor(html_context,attr,&table_elinks->bgcolor);
  local_2c = table_elinks->bgcolor;
  local_78 = (uchar *)0x0;
  bVar16 = false;
  local_74 = 0xffffffff;
  local_6c = 0;
  local_70 = 0;
  local_80 = 0;
  pbVar1 = local_28;
  str = html;
LAB_0809ef90:
  do {
    local_24 = str;
    local_28 = pbVar1;
    html_00 = local_24;
    if ((!bVar16) &&
       (((table_elinks->caption).start == (uchar *)0x0 ||
        ((table_elinks->caption).end != (uchar *)0x0)))) {
      span = table_elinks->bad_html_size;
      if (span == 0) {
        uVar13 = 0;
        p = table_elinks->bad_html;
        uVar10 = 0x100;
LAB_0809f1a0:
        p = (html_start_end *)mem_realloc(p,uVar10 * 8);
        if (p != (html_start_end *)0x0) {
          table_elinks->bad_html = p;
          memset(p + uVar13,0,uVar10 * 8 + uVar13 * -8);
          p = table_elinks->bad_html;
LAB_0809efe9:
          if (p != (html_start_end *)0x0) {
            span = table_elinks->bad_html_size;
            p[span].start = html_00;
            table_elinks->bad_html_size = span + 1;
          }
        }
      }
      else {
        p = table_elinks->bad_html;
        if (p[span + -1].end != (uchar *)0x0) {
          uVar10 = span + 0x100U & 0xffffff00;
          uVar13 = span + 0xffU & 0xffffff00;
          if (uVar13 < uVar10) goto LAB_0809f1a0;
          goto LAB_0809efe9;
        }
      }
    }
    while( true ) {
      if (eof <= html_00) {
        if (bVar16) {
          table_elinks->cells[local_74 * table_elinks->real_cols + local_6c].end = html_00;
        }
        goto scan_done;
      }
      if (*html_00 == '<') break;
      html_00 = html_00 + 1;
    }
    if ((eof < html_00 + 2) || ((html_00[1] != '?' && (html_00[1] != '!')))) {
      span = parse_element(html_00,eof,&local_28,(int *)&local_30,local_20,&local_24);
      pbVar1 = local_28;
      if (span == 0) {
        str = local_24;
        if (local_30 != 0) {
          bVar15 = false;
          if (*local_28 == 0x2f) {
            local_30 = local_30 - 1;
            if (local_30 == 0) goto LAB_0809ef90;
            local_28 = local_28 + 1;
            bVar15 = true;
          }
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
          errline = 0x263;
          span = elinks_strlcasecmp(local_28,local_30,"TABLE",5,1);
          if (span == 0) {
            if (bVar15) {
              if (local_70 != 0) {
                new_columns(table_elinks,local_70,local_44,(int)local_3c,(int)local_40,1);
              }
              if (bVar16) {
                table_elinks->cells[local_74 * table_elinks->real_cols + local_6c].end = html_00;
              }
scan_done:
              add_table_bad_html_end(table_elinks,html_00);
              *end = html_00;
              if (local_78 != (uchar *)0x0) {
                mem_free(local_78);
              }
              if (table_elinks->cols < 1) {
                count = table_elinks->rows;
              }
              else {
                count = table_elinks->rows;
                span = 0;
                sVar11 = count;
                do {
                  if (0 < (int)sVar11) {
                    width = table_elinks->real_cols;
                    iVar12 = 0;
                    count = sVar11;
                    do {
                      ptVar8 = table_elinks->cells + width * iVar12 + span;
                      if ((*(byte *)&ptVar8->field_0x3c & 2) == 0) {
                        if (ptVar8->colspan == -1) {
                          width = ptVar8->rowspan;
                          ptVar8->colspan = table_elinks->cols - span;
                          count = table_elinks->rows;
                        }
                        else {
                          width = ptVar8->rowspan;
                        }
                        if (width != -1) goto LAB_0809f0de;
                        ptVar8->rowspan = count - iVar12;
                        count = table_elinks->rows;
                        sVar11 = count;
                        if ((int)count <= iVar12 + 1) break;
                      }
                      else {
LAB_0809f0de:
                        sVar11 = count;
                        if ((int)count <= iVar12 + 1) break;
                      }
                      iVar12 = iVar12 + 1;
                      width = table_elinks->real_cols;
                    } while( true );
                  }
                  span = span + 1;
                } while (table_elinks->cols != span && span <= table_elinks->cols);
              }
              if (count == 0) {
                table_elinks->rows_heights = (int *)0x0;
              }
              else {
                piVar7 = (int *)mem_calloc(count,4);
                table_elinks->rows_heights = piVar7;
                if (piVar7 == (int *)0x0) {
abort:
                  *end = eof;
                  free_table(table_elinks);
                  return (table_elinks *)0x0;
                }
              }
              if (0 < table_elinks->columns_count) {
                span = 0;
                do {
                  width = table_elinks->columns[span].width;
                  if (width != -1) {
                    set_td_width(table_elinks,span,width,1);
                  }
                  span = span + 1;
                } while (table_elinks->columns_count != span && span <= table_elinks->columns_count)
                ;
              }
              set_td_width(table_elinks,table_elinks->cols,-1,0);
              return table_elinks;
            }
            local_68 = 1;
            local_48 = local_24;
            while (pbVar1 = local_28, str = eof, local_48 < eof) {
              while ((*local_48 == '<' &&
                     (span = parse_element(local_48,eof,&local_4c,(int *)&local_50,(uchar **)0x0,
                                           &local_48), span == 0))) {
                pbVar1 = local_28;
                str = eof;
                if (eof <= local_48) goto LAB_0809ef90;
                if (local_50 != 0) {
                  bVar15 = false;
                  if (*local_4c == '/') {
                    local_4c = local_4c + 1;
                    local_50 = local_50 - 1;
                    if (local_50 != 0) {
                      bVar15 = true;
                      goto LAB_0809f2eb;
                    }
                  }
                  else {
LAB_0809f2eb:
                    errfile = 
                    "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
                    errline = 0x212;
                    span = elinks_strlcasecmp(local_4c,local_50,"TABLE",5,1);
                    if (span == 0) {
                      if (bVar15) {
                        local_68 = local_68 + -1;
                        pbVar1 = local_28;
                        str = local_48;
                        if (local_68 == 0) goto LAB_0809ef90;
                      }
                      else {
                        local_68 = local_68 + 1;
                      }
                    }
                  }
                  pbVar1 = local_28;
                  str = eof;
                  if (eof <= local_48) goto LAB_0809ef90;
                }
              }
              local_48 = local_48 + 1;
            }
            goto LAB_0809ef90;
          }
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
          errline = 0x272;
          span = elinks_strlcasecmp(local_28,local_30,(uchar *)"CAPTION",7,1);
          if (span == 0) {
            if (bVar15) {
              pbVar1 = local_28;
              str = local_24;
              if (((table_elinks->caption).start != (uchar *)0x0) &&
                 ((table_elinks->caption).end == (uchar *)0x0)) {
                (table_elinks->caption).end = html_00;
              }
            }
            else {
              add_table_bad_html_end(table_elinks,html_00);
              pbVar1 = local_28;
              str = local_24;
              if ((table_elinks->caption).start == (uchar *)0x0) {
                (table_elinks->caption).start = html_00;
              }
            }
            goto LAB_0809ef90;
          }
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
          errline = 0x280;
          span = elinks_strlcasecmp(local_28,local_30,(uchar *)"COLGROUP",8,1);
          if (span != 0) {
            if (!bVar15) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
              errline = 0x29a;
              span = elinks_strlcasecmp(local_28,local_30,"COL",3,1);
              if (span == 0) {
                add_table_bad_html_end(table_elinks,html_00);
                width = get_num(local_20[0],"span",html_context->doc_cp);
                span = 1;
                if ((width != -1) && (span = 0x8000, width < 0x8001)) {
                  span = width;
                }
                local_50 = local_44;
                local_4c = local_3c;
                local_48 = local_40;
                get_align(html_context,local_20[0],(int *)&local_4c);
                get_valign(html_context,local_20[0],(int *)&local_48);
                get_column_width(local_20[0],(int *)&local_50,sh,html_context);
                new_columns(table_elinks,span,local_50,(int)local_4c,(int)local_48,
                            (uint)(local_70 != 0));
                local_70 = 0;
                pbVar1 = local_28;
                str = local_24;
                goto LAB_0809ef90;
              }
            }
            span = c_toupper((uint)*local_28);
            pbVar1 = local_28;
            str = local_24;
            if (span == 0x54) {
              local_30 = local_30 - 1;
              pbVar1 = local_28 + 1;
              if (local_30 != 0) {
                pbVar1 = local_28 + 1;
                local_28 = local_28 + 1;
                span = c_toupper((uint)*pbVar1);
                cVar5 = (char)span;
                if (bVar15) {
                  pbVar1 = local_28;
                  str = local_24;
                  if ((local_30 == 1) && (((cVar5 == 'D' || (cVar5 == 'R')) || (cVar5 == 'H')))) {
                    if (local_70 != 0) {
                      new_columns(table_elinks,local_70,local_44,(int)local_3c,(int)local_40,1);
                    }
                    if (bVar16) {
                      table_elinks->cells[local_74 * table_elinks->real_cols + local_6c].end =
                           html_00;
                    }
                    add_table_bad_html_end(table_elinks,html_00);
                    bVar16 = false;
                    pbVar1 = local_28;
                    str = local_24;
                  }
                }
                else {
                  if (local_30 == 4) {
                    errfile = 
                    "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
                    errline = 0x2cb;
                    span = elinks_strlcasecmp(local_28,4,"HEAD",4,1);
                    if (span != 0) {
                      errfile = 
                      "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
                      errline = 0x2cc;
                      span = elinks_strlcasecmp(local_28,local_30,"BODY",4,1);
                      if (span != 0) {
                        errfile = 
                        "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
                        errline = 0x2cd;
                        span = elinks_strlcasecmp(local_28,local_30,"FOOT",4,1);
                        if (span != 0) goto LAB_0809f877;
                      }
                    }
                    if (local_70 != 0) {
                      new_columns(table_elinks,local_70,local_44,(int)local_3c,(int)local_40,1);
                    }
                    add_table_bad_html_end(table_elinks,html_00);
                    local_80 = 2;
                    pbVar1 = local_28;
                    str = local_24;
                  }
                  else {
LAB_0809f877:
                    pbVar1 = local_28;
                    str = local_24;
                    if (local_30 == 1) {
                      if (cVar5 == 'R') {
                        if (local_70 != 0) {
                          new_columns(table_elinks,local_70,local_44,(int)local_3c,(int)local_40,1);
                        }
                        if (bVar16) {
                          table_elinks->cells[local_74 * table_elinks->real_cols + local_6c].end =
                               html_00;
                        }
                        add_table_bad_html_end(table_elinks,html_00);
                        local_80 = local_80 + -1 + (uint)(local_80 == 0);
                        local_34 = 0;
                        local_38 = 1;
                        local_2c = table_elinks->bgcolor;
                        get_align(html_context,local_20[0],&local_34);
                        get_valign(html_context,local_20[0],&local_38);
                        get_bgcolor(html_context,local_20[0],&local_2c);
                        if (local_78 != (uchar *)0x0) {
                          mem_free(local_78);
                        }
                        local_78 = get_attr_value(local_20[0],"id",html_context->doc_cp,
                                                  HTML_ATTR_NONE);
                        local_74 = local_74 + 1;
                        bVar16 = false;
                        local_6c = 0;
                        pbVar1 = local_28;
                        str = local_24;
                      }
                      else {
                        bVar15 = cVar5 == 'H';
                        if ((bVar15) || (cVar5 == 'D')) {
                          if (local_70 != 0) {
                            new_columns(table_elinks,local_70,local_44,(int)local_3c,(int)local_40,1
                                       );
                          }
                          add_table_bad_html_end(table_elinks,html_00);
                          if (bVar16) {
                            table_elinks->cells[local_74 * table_elinks->real_cols + local_6c].end =
                                 html_00;
                          }
                          if (local_74 == -1) {
                            local_74 = 0;
                            local_6c = 0;
                          }
                          while (ptVar8 = new_cell(table_elinks,local_6c,local_74),
                                ptVar8 != (table_cell *)0x0) {
                            if ((*(byte *)&ptVar8->field_0x3c & 1) == 0) {
                              ptVar8->col = local_6c;
                              *(byte *)&ptVar8->field_0x3c = *(byte *)&ptVar8->field_0x3c | 1;
                              ptVar8->row = local_74;
                              ptVar8->start = local_24;
                              ptVar8->align = local_34;
                              ptVar8->valign = local_38;
                              str = get_attr_value(local_20[0],"id",html_context->doc_cp,
                                                   HTML_ATTR_NONE);
                              ptVar8->fragment_id = str;
                              if ((str == (uchar *)0x0) && (local_78 != (uchar *)0x0)) {
                                ptVar8->fragment_id = local_78;
                                local_78 = (uchar *)0x0;
                              }
                              bVar6 = *(byte *)&ptVar8->field_0x3c & 0xfb | bVar15 << 2;
                              *(byte *)&ptVar8->field_0x3c = bVar6;
                              if (bVar15) {
                                ptVar8->align = 1;
                              }
                              if (local_80 == 1) {
                                *(byte *)&ptVar8->field_0x3c = bVar6 | 8;
                              }
                              if (table_elinks->columns_count != local_6c &&
                                  local_6c <= table_elinks->columns_count) {
                                ptVar9 = table_elinks->columns + local_6c;
                                if (ptVar9->align != -1) {
                                  ptVar8->align = ptVar9->align;
                                  ptVar9 = table_elinks->columns + local_6c;
                                }
                                if (ptVar9->valign != -1) {
                                  ptVar8->valign = ptVar9->valign;
                                }
                              }
                              ptVar8->bgcolor = local_2c;
                              get_align(html_context,local_20[0],&ptVar8->align);
                              get_valign(html_context,local_20[0],&ptVar8->valign);
                              get_bgcolor(html_context,local_20[0],&ptVar8->bgcolor);
                              width = get_num(local_20[0],(uchar *)"colspan",html_context->doc_cp);
                              span = 1;
                              if (((width != -1) && (span = -1, width != 0)) &&
                                 (span = 0x8000, width < 0x8001)) {
                                span = width;
                              }
                              width = get_num(local_20[0],(uchar *)"rowspan",html_context->doc_cp);
                              local_64 = 1;
                              if (((width != -1) && (local_64 = -1, width != 0)) &&
                                 (local_64 = width, 0x8000 < width)) {
                                local_64 = 0x8000;
                              }
                              ptVar8->colspan = span;
                              ptVar8->rowspan = local_64;
                              if (span == 1) {
                                local_48 = (uchar *)0xffffffff;
                                get_column_width(local_20[0],(int *)&local_48,sh,html_context);
                                if (local_48 != (uchar *)0xffffffff) {
                                  set_td_width(table_elinks,local_6c,(int)local_48,0);
                                }
                              }
                              iVar12 = 1;
                              width = table_elinks->cols;
                              goto LAB_0809fbb6;
                            }
                            if (ptVar8->colspan == -1) break;
                            local_6c = local_6c + 1;
                          }
                          bVar16 = false;
                          pbVar1 = local_28;
                          str = local_24;
                        }
                      }
                    }
                  }
                }
              }
            }
            goto LAB_0809ef90;
          }
          if (local_70 != 0) {
            new_columns(table_elinks,local_70,local_44,(int)local_3c,(int)local_40,1);
          }
          add_table_bad_html_end(table_elinks,html_00);
          local_3c = (uchar *)0xffffffff;
          local_40 = (uchar *)0xffffffff;
          local_44 = 0xffffffff;
          local_70 = 0;
          pbVar1 = local_28;
          str = local_24;
          if (!bVar15) {
            get_align(html_context,local_20[0],(int *)&local_3c);
            get_valign(html_context,local_20[0],(int *)&local_40);
            get_column_width(local_20[0],(int *)&local_44,sh,html_context);
            span = get_num(local_20[0],"span",html_context->doc_cp);
            pbVar1 = local_28;
            str = local_24;
            if (span == -1) {
              local_70 = 1;
            }
            else {
              local_70 = 0x8000;
              if (span < 0x8001) {
                local_70 = span;
              }
            }
          }
        }
      }
      else {
        str = html_00 + 1;
      }
      goto LAB_0809ef90;
    }
    str = skip_comment(html_00,eof);
    pbVar1 = local_28;
  } while( true );
LAB_0809fbb6:
  iVar2 = width;
  if (span != -1) {
    iVar2 = span;
  }
  if (iVar2 <= iVar12) goto LAB_0809fc5c;
  ptVar8 = new_cell(table_elinks,iVar12 + local_6c,local_74);
  if (ptVar8 == (table_cell *)0x0) goto abort;
  if ((*(byte *)&ptVar8->field_0x3c & 1) != 0) goto LAB_0809fc36;
  iVar12 = iVar12 + 1;
  *(byte *)&ptVar8->field_0x3c = *(byte *)&ptVar8->field_0x3c | 3;
  ptVar8->colspan = span;
  ptVar8->rowspan = local_64;
  ptVar8->col = local_6c;
  ptVar8->row = local_74;
  goto LAB_0809fbb6;
LAB_0809fc36:
  width = 0;
  while (span = iVar12, width < iVar12) {
    span = local_74 * table_elinks->real_cols + local_6c + width;
    width = width + 1;
    table_elinks->cells[span].colspan = iVar12;
  }
LAB_0809fc5c:
  width = local_64;
  if (local_64 == -1) {
    width = table_elinks->rows;
  }
  if (0x80000 < (uint)(width * iVar12)) goto abort;
  local_68 = 1;
  while (local_68 < width) {
    local_7c = 0;
    while (local_7c < iVar12) {
      ptVar8 = new_cell(table_elinks,local_7c + local_6c,local_68 + local_74);
      if (ptVar8 == (table_cell *)0x0) goto abort;
      if ((*(byte *)&ptVar8->field_0x3c & 1) != 0) {
        if ((ptVar8->col == local_6c) && (local_74 == ptVar8->row)) goto LAB_0809fdba;
        local_64 = 0;
        while (local_64 < local_7c) {
          uVar10 = 0x40;
          ptVar14 = table_elinks->cells +
                    (local_68 + local_74) * table_elinks->real_cols + local_6c + local_64;
          bVar16 = ((uint)ptVar14 & 1) != 0;
          ptVar8 = ptVar14;
          if (bVar16) {
            ptVar8 = (table_cell *)((int)ptVar14 + (uint)bVar17 * -2 + 1);
            *(undefined *)&ptVar14->start = 0;
            uVar10 = 0x3f;
          }
          ptVar14 = ptVar8;
          if (((uint)ptVar8 & 2) != 0) {
            ptVar14 = (table_cell *)((int)ptVar8 + (uint)bVar17 * -4 + 2);
            *(undefined2 *)&ptVar8->start = 0;
            uVar10 = uVar10 - 2;
          }
          uVar13 = uVar10 >> 2;
          while (uVar13 != 0) {
            uVar13 = uVar13 - 1;
            ptVar14->start = (uchar *)0x0;
            ptVar14 = (table_cell *)((int)ptVar14 + (uint)bVar17 * -8 + 4);
          }
          ptVar8 = ptVar14;
          if ((uVar10 & 2) != 0) {
            ptVar8 = (table_cell *)((int)ptVar14 + (uint)bVar17 * -4 + 2);
            *(undefined2 *)&ptVar14->start = 0;
          }
          if (bVar16) {
            *(undefined *)&ptVar8->start = 0;
          }
          local_64 = local_64 + 1;
        }
        span = 0;
        while (span < iVar12) {
          width = 0;
          while (width < local_68) {
            iVar2 = width + local_74;
            width = width + 1;
            table_elinks->cells[iVar2 * table_elinks->real_cols + local_6c + span].rowspan =
                 local_68;
          }
          span = span + 1;
        }
        goto LAB_0809fd50;
      }
      *(byte *)&ptVar8->field_0x3c = *(byte *)&ptVar8->field_0x3c | 3;
      ptVar8->colspan = span;
      ptVar8->rowspan = local_64;
      ptVar8->col = local_6c;
      ptVar8->row = local_74;
LAB_0809fdba:
      local_7c = local_7c + 1;
    }
    local_68 = local_68 + 1;
  }
LAB_0809fd50:
  bVar16 = true;
  pbVar1 = local_28;
  str = local_24;
  goto LAB_0809ef90;
}



screen_char * __regparm3 realloc_line(document *document,int x,int y)

{
  line *plVar1;
  screen_char *psVar2;
  uint uVar3;
  size_t size;
  uint uVar4;
  
  plVar1 = realloc_lines(document,y);
  if (plVar1 == (line *)0x0) {
LAB_080a01b0:
    psVar2 = (screen_char *)0x0;
  }
  else {
    if (plVar1->length != x) {
      uVar4 = plVar1->length + 0xfU & 0xfffffff0;
      uVar3 = x + 0xfU & 0xfffffff0;
      if (uVar4 < uVar3) {
        size = uVar3 * 8;
        psVar2 = (screen_char *)mem_realloc(plVar1->chars,size);
        if (psVar2 == (screen_char *)0x0) goto LAB_080a01b0;
        plVar1->chars = psVar2;
        memset(psVar2 + uVar4,0,size + uVar4 * -8);
      }
      if (plVar1->chars == (screen_char *)0x0) goto LAB_080a01b0;
      plVar1->length = x;
    }
    psVar2 = plVar1->chars;
  }
  return psVar2;
}



// WARNING: Could not reconcile some variable overlaps

void render_plain_document(cache_entry *cached,document *document,string *buffer)

{
  uchar uVar1;
  byte bVar2;
  color_T cVar3;
  bool bVar4;
  bool bVar5;
  document *document_00;
  document *pdVar6;
  byte bVar7;
  uchar *head;
  uint uVar8;
  int iVar9;
  ushort **ppuVar10;
  unicode_val_T c;
  int iVar11;
  uchar *p;
  int iVar12;
  int iVar13;
  screen_char *psVar14;
  screen_char *psVar15;
  unicode_val_T c_00;
  void **ppvVar16;
  byte *pbVar17;
  byte *pbVar18;
  uri_errno uVar19;
  link *plVar20;
  point *ppVar21;
  global_history_item *pgVar22;
  bookmark *pbVar23;
  size_t size;
  byte *p_00;
  uint uVar24;
  void *pvVar25;
  int len;
  int iVar26;
  int y;
  void *pvVar27;
  uchar *puVar28;
  uint uVar29;
  bool bVar30;
  uint local_124;
  int local_120;
  int local_108;
  uchar *local_fc;
  unicode_val_T local_d0;
  int local_cc;
  int local_c8;
  uint local_c4;
  int local_b8;
  int local_b4;
  int local_b0;
  screen_char *local_ac;
  uchar *local_a8;
  int local_a4;
  uri test;
  plain_renderer renderer;
  screen_char template;
  byte *local_28;
  int local_24;
  undefined4 local_20;
  
  head = cached->head;
  if (head == (uchar *)0x0) {
    head = "";
  }
  renderer.convert_table =
       get_convert_table(head,(document->options).cp,(document->options).assume_cp,&document->cp,
                         &document->cp_status,(document->options).hard_assume);
  renderer.source = buffer->source;
  renderer.length = buffer->length;
  renderer.document = document;
  renderer.lineno = 0;
  bVar7 = *(byte *)&(document->options).field_0x45;
  renderer._32_1_ = renderer._32_1_ & 0xfe | bVar7 >> 3 & 1;
  renderer.max_width = 0x7fffffff;
  if ((char)bVar7 < '\0') {
    renderer.max_width = (document->options).box.width;
  }
  cVar3 = (document->options).default_style.bg;
  document->width = 0;
  document->bgcolor = cVar3;
  uVar8 = is_cp_utf8((document->options).cp);
  *(byte *)&(document->options).field_0x5c =
       *(byte *)&(document->options).field_0x5c & 0xef | (byte)((uVar8 & 1) << 4);
  get_screen_char_template(&renderer.template,&document->options,(document->options).default_style);
  len = renderer.length;
  local_a8 = renderer.source;
  local_b8 = renderer.length;
  iVar9 = is_cp_utf8((renderer.document)->cp);
  if (0 < len) {
    bVar30 = false;
    bVar5 = false;
    do {
      y = 0;
      len = 0;
      local_ac = (screen_char *)0x0;
      local_b0 = 0;
      local_b4 = 0;
      bVar4 = true;
LAB_080a039c:
      do {
        if (renderer.max_width <= y) break;
        p_00 = local_a8 + len;
        bVar7 = *p_00;
        local_c4 = (uint)(bVar7 == 0xd);
        if (local_a8[local_c4 + len] == '\n') {
          local_c4 = local_c4 + 1;
LAB_080a04b9:
          if (!bVar4) {
            if (local_b0 == 0) {
              bVar30 = false;
              bVar5 = false;
              goto LAB_080a0508;
            }
            len = len - local_b0;
            local_c4 = local_c4 + local_b0;
            bVar30 = local_c4 == 0;
            bVar5 = false;
            goto LAB_080a0491;
          }
          if ((bVar5) || ((bVar30 && ((renderer._32_1_ & 1) != 0)))) {
            local_b8 = local_b8 - (local_b4 + local_c4);
            local_a8 = local_a8 + local_b4 + local_c4;
            renderer.lineno = renderer.lineno + -1;
            if ((assert_failed == 0) &&
               (assert_failed = -(renderer.lineno >> 0x1f), assert_failed != 0)) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/plain/renderer.c";
              errline = 0x237;
              elinks_internal((uchar *)"assertion renderer->lineno >= 0 failed!");
            }
            goto joined_r0x080a08e4;
          }
          local_a8 = local_a8 + local_b4;
          local_b8 = local_b8 - local_b4;
          len = len - local_b4;
          bVar30 = true;
          goto LAB_080a0508;
        }
        if (bVar7 == 0xd) {
          local_c4 = 1;
          goto LAB_080a04b9;
        }
        ppuVar10 = __ctype_b_loc();
        if ((*(byte *)((int)*ppuVar10 + (uint)bVar7 * 2 + 1) & 0x20) != 0) {
          local_ac = (screen_char *)len;
          if (!bVar4) {
            local_b0 = local_b0 + 1;
            goto LAB_080a037c;
          }
          local_b4 = local_b4 + 1;
          bVar4 = true;
          if (iVar9 != 0) goto LAB_080a0426;
LAB_080a038a:
          y = y + 1;
          len = len + 1;
          if (local_b8 <= len) break;
          goto LAB_080a039c;
        }
        local_b0 = 0;
        bVar4 = false;
LAB_080a037c:
        if (iVar9 == 0) goto LAB_080a038a;
LAB_080a0426:
        local_20 = p_00;
        c = utf8_to_unicode((uchar **)&local_20,local_a8 + local_b8);
        if (c == 0xfffffffd) {
          return;
        }
        iVar11 = unicode_to_cell(c);
        y = y + iVar11;
        iVar11 = utf8charlen(p_00);
        len = len + iVar11;
      } while (len < local_b8);
      bVar30 = true;
      bVar5 = true;
      local_c4 = 0;
LAB_080a0491:
      if ((len < local_b8) && (bVar30)) {
        bVar30 = false;
        if (local_ac != (screen_char *)0x0) {
          len = (int)local_ac;
        }
        local_c4 = (uint)(local_ac != (screen_char *)0x0);
      }
      else {
        bVar30 = false;
      }
LAB_080a0508:
      if ((assert_failed == 0) && (assert_failed = -(len >> 0x1f), assert_failed != 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/plain/renderer.c";
        errline = 0x251;
        elinks_internal((uchar *)"assertion width >= 0 failed!");
      }
      head = memacpy(local_a8,len);
      y = renderer.lineno;
      uVar8 = renderer.template._4_4_;
      c = renderer.template.data;
      document_00 = renderer.document;
      if (head != (uchar *)0x0) {
        bVar7 = *(byte *)&((renderer.document)->options).field_0x5c >> 4;
        local_24 = len;
        p = convert_string_elinks
                      (renderer.convert_table,head,len,((renderer.document)->options).cp,CSM_NONE,
                       &local_24,(anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
        if (p != (uchar *)0x0) {
          iVar11 = 0;
          local_b4 = 0;
          local_ac = (screen_char *)0x0;
LAB_080a0605:
          iVar13 = local_24;
          if (iVar11 < local_24) {
            do {
              iVar12 = 1;
              local_20._0_1_ = p[iVar11];
              local_a4 = 1;
              local_20 = (byte *)((uint)local_20 & 0xffffff00 | (uint)(byte)local_20);
              if ((bVar7 & 1) != 0) {
                local_28 = p + iVar11;
                local_a4 = utf8charlen((uchar *)&local_20);
                c_00 = utf8_to_unicode(&local_28,p + local_24);
                if (c_00 == 0xfffffffd) goto code_r0x080a09c5;
                iVar12 = unicode_to_cell(c_00);
                iVar13 = local_24;
              }
              if (((byte)local_20 == 9) &&
                 ((iVar11 + local_a4 == iVar13 || (p[iVar11 + local_a4] != '\b')))) {
                local_b4 = local_b4 + (~(local_b4 + (int)local_ac) & 7U);
              }
              iVar11 = iVar11 + local_a4;
              local_ac = (screen_char *)((int)local_ac + iVar12);
              if (iVar13 <= iVar11) break;
            } while( true );
          }
          if ((assert_failed == 0) && (assert_failed = -(local_b4 >> 0x1f), assert_failed != 0)) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/plain/renderer.c";
            errline = 0x12e;
            elinks_internal((uchar *)"assertion expanded >= 0 failed!");
            iVar13 = local_24;
          }
          psVar14 = realloc_line(document_00,iVar13 + local_b4,y);
          if (psVar14 == (screen_char *)0x0) {
            mem_free(p);
            goto LAB_080a0ebd;
          }
          local_c8 = 0;
          local_a4 = 0;
          iVar11 = local_24;
          iVar13 = 0;
          local_ac = psVar14;
          if (0 < local_24) {
            do {
              p_00 = p + iVar13;
              local_20._0_1_ = *p_00;
              local_20 = (byte *)((uint)local_20 & 0xffffff00 | (uint)(byte)local_20);
              if ((bVar7 & 1) == 0) {
                local_d0 = 0xfffffffd;
                local_cc = 1;
                local_b4 = 1;
LAB_080a0702:
                uVar1 = '\0';
                if (0 < iVar13) {
                  uVar1 = p[iVar13 + -1];
                }
                bVar2 = 0;
                iVar12 = local_b4 + iVar13;
                if (((iVar12 < iVar11) && (bVar2 = p[iVar12], bVar2 == 8)) || ((byte)local_20 != 9))
                {
                  if ((byte)local_20 == 8) {
                    if (local_c8 + local_a4 != 0) {
                      psVar15 = local_ac + -1;
                      if (local_ac <= psVar14) {
                        psVar15 = local_ac;
                      }
                      local_ac = psVar15;
                      if ((bVar2 == 0x5f) && (uVar1 != '_')) {
                        if (-1 < iVar13 + -1) {
                          p[iVar13 + -1] = '_';
                          iVar11 = local_24;
                        }
                        if (iVar12 < iVar11) {
                          p[iVar12] = uVar1;
                          iVar11 = local_24;
                        }
                        iVar12 = iVar13;
                        if (-1 < iVar13 + -2) {
                          local_a4 = local_a4 + -1;
                          iVar12 = iVar13 + -1;
                        }
                        goto LAB_080a07df;
                      }
                      iVar26 = local_c8 + -2;
                      if (iVar13 + -2 + local_c8 < 0) {
                        iVar26 = local_c8;
                      }
                      c_00 = psVar15->data;
                      if (bVar2 != 0x5f) {
                        if (c_00 != 0x5f) goto LAB_080a0b6a;
                        renderer.template.attr = renderer.template.attr | 0x20;
                        renderer.template._4_4_ = renderer.template._4_4_ | 0x20;
                      }
                      else {
                        if (c_00 == 0x5f) {
                          if (((-1 < iVar13 + iVar26) && (psVar14 <= psVar15 + -1)) &&
                             (psVar15[-1].attr != 0)) {
                            renderer.template.attr = psVar15[-1].attr | renderer.template.attr;
                            renderer.template._4_4_ =
                                 renderer.template._4_4_ & 0xffffff00 | (uint)renderer.template.attr
                            ;
                            goto LAB_080a0b7d;
                          }
                        }
                        else {
LAB_080a0b6a:
                          if (c_00 != (uint)bVar2) goto LAB_080a0b7d;
                        }
                        renderer.template.attr = renderer.template.attr | 8;
                        renderer.template._4_4_ = renderer.template._4_4_ | 8;
                      }
LAB_080a0b7d:
                      local_c8 = iVar26;
                      if (renderer.template.attr != 0) {
                        renderer.template._4_4_ =
                             renderer.template._4_4_ & 0xffffff00 |
                             (uint)(renderer.template.attr | psVar15->attr);
                      }
                    }
                  }
                  else {
                    if ((*(byte *)&(document_00->options).field_0x45 & 4) == 0) {
LAB_080a0968:
                      if ((bVar7 & 1) == 0) {
                        if (((byte)local_20 == 0x7f) || ((byte)local_20 < 0x20)) {
                          local_20 = (byte *)CONCAT31(local_20._1_3_,0x2e);
                          renderer.template.data = 0x2e;
                        }
                        else {
                          renderer.template.data = (uint)local_20 & 0xff;
                        }
                        local_ac->data = renderer.template.data;
                        *(uint *)&local_ac->attr = renderer.template._4_4_;
                        psVar15 = local_ac + 1;
                        if (assert_failed == 0) {
                          assert_failed = ZEXT14((byte)local_20 == '\0');
                          if ((byte)local_20 == '\0') {
                            errfile = 
                            "/home/naftali/source/elinks-0.12~pre5/src/document/plain/renderer.c";
                            errline = 0x1ce;
                            elinks_internal((uchar *)"assertion line_char failed!");
                          }
                        }
                      }
                      else {
                        iVar11 = local_24;
                        if (local_d0 == 0xfffffffd) goto LAB_080a07df;
                        psVar15 = local_ac + 1;
                        *(uint *)&local_ac->attr = renderer.template._4_4_;
                        local_ac->data = local_d0;
                        if (local_cc == 2) {
                          psVar15 = local_ac + 2;
                          local_ac[1].data = 0xfffffffd;
                          *(uint *)&local_ac[1].attr = renderer.template._4_4_;
                        }
                      }
                    }
                    else {
                      ppuVar10 = __ctype_b_loc();
                      pdVar6 = renderer.document;
                      if (((*(byte *)((int)*ppuVar10 + (uint)(byte)local_20 * 2 + 1) & 4) == 0) ||
                         ((*(byte *)((int)*ppuVar10 + (uint)bVar2 * 2 + 1) & 4) == 0))
                      goto LAB_080a0968;
                      if (((iVar11 - iVar13 < 1) ||
                          (((((bVar2 = *p_00, bVar2 == 0x3c || (bVar2 < 0x21)) || (bVar2 == 0x3e))
                            || ((bVar2 == 0x28 || (bVar2 == 0x29)))) || (bVar2 == 0x22)))) ||
                         (bVar2 == 0x27)) {
LAB_080a0e3d:
                        template.data = renderer.template.data;
                        template._4_4_ = renderer.template._4_4_;
                        goto LAB_080a0968;
                      }
                      local_124 = 0;
                      do {
                        uVar24 = local_124;
                        local_124 = uVar24 + 1;
                        if (iVar11 - iVar13 <= (int)local_124) goto LAB_080a0dfd;
                        bVar2 = p_00[local_124];
                      } while ((((bVar2 != 0x3c) && (0x20 < bVar2)) &&
                               ((bVar2 != 0x3e &&
                                (((bVar2 != 0x28 && (bVar2 != 0x29)) && (bVar2 != 0x27)))))) &&
                              (bVar2 != 0x22));
                      if ((int)local_124 < 1) {
                        template.data = renderer.template.data;
                        template._4_4_ = renderer.template._4_4_;
                        if (local_124 == 0) goto LAB_080a0968;
                      }
                      else {
LAB_080a0dfd:
                        if ((p_00[uVar24] == 0x2e) || (p_00[uVar24] == 0x2c)) {
                          pbVar17 = p_00 + local_124;
                          do {
                            local_124 = local_124 - 1;
                            if (local_124 == 0) goto LAB_080a0e3d;
                            pbVar18 = pbVar17 + -2;
                            pbVar17 = pbVar17 + -1;
                          } while ((*pbVar18 == 0x2c) || (*pbVar18 == 0x2e));
                        }
                      }
                      local_108 = local_124 + iVar13;
                      local_120 = local_c8 + local_a4;
                      template._4_4_ = renderer.template._4_4_;
                      template.data = renderer.template.data;
                      pbVar18 = (byte *)memchr(p_00,0x40,local_124);
                      pbVar17 = p_00 + local_124;
                      bVar2 = *pbVar17;
                      if (assert_failed != 0) {
LAB_080a135a:
                        assert_failed = 0;
                        goto LAB_080a0968;
                      }
                      assert_failed = ZEXT14(pdVar6 == (document *)0x0);
                      if (pdVar6 == (document *)0x0) {
                        errfile = 
                        "/home/naftali/source/elinks-0.12~pre5/src/document/plain/renderer.c";
                        errline = 0x79;
                        elinks_internal((uchar *)"assertion document failed!");
                        if (assert_failed != 0) goto LAB_080a135a;
                      }
                      *pbVar17 = 0;
                      if (((p_00 < pbVar18) && (pbVar18 != (byte *)0x0)) &&
                         ((int)(pbVar18 + -(int)p_00) < (int)(local_124 - 1))) {
                        local_fc = straconcat((uchar *)"mailto:",p_00,0);
                      }
                      else {
                        uVar19 = parse_uri(&test,p_00);
                        if (((uVar19 != URI_ERRNO_OK) || (test.protocol == 0x12)) ||
                           (((test._48_4_ & 0xffff00) == 0 && (test._46_2_ == 0)))) {
                          *pbVar17 = bVar2;
                          goto LAB_080a0968;
                        }
                        local_fc = memacpy(p_00,local_124);
                      }
                      *pbVar17 = bVar2;
                      if (local_fc == (uchar *)0x0) goto LAB_080a0968;
                      normalize_uri((uri *)0x0,local_fc);
                      uVar24 = pdVar6->nlinks + 0x80U & 0xffffff80;
                      uVar29 = pdVar6->nlinks + 0x7fU & 0xffffff80;
                      if (uVar29 < uVar24) {
                        size = uVar24 * 0x34;
                        plVar20 = (link *)mem_realloc(pdVar6->links,size);
                        if (plVar20 != (link *)0x0) {
                          pdVar6->links = plVar20;
                          memset(plVar20 + uVar29,0,size + uVar29 * -0x34);
                          goto LAB_080a112f;
                        }
LAB_080a1377:
                        mem_free(local_fc);
                        goto LAB_080a0968;
                      }
LAB_080a112f:
                      if (pdVar6->links == (link *)0x0) goto LAB_080a1377;
                      plVar20 = pdVar6->links + pdVar6->nlinks;
                      uVar24 = plVar20->npoints;
                      if (uVar24 < local_124) {
                        ppVar21 = (point *)mem_realloc(plVar20->points,local_124 * 8);
                        if (ppVar21 == (point *)0x0) goto LAB_080a1377;
                        plVar20->points = ppVar21;
                        memset(ppVar21 + uVar24,0,local_124 * 8 + uVar24 * -8);
                      }
                      if (plVar20->points == (point *)0x0) goto LAB_080a1377;
                      plVar20->type = LINK_HYPERTEXT;
                      plVar20->npoints = local_124;
                      plVar20->where = local_fc;
                      (plVar20->color).background = (pdVar6->options).default_style.bg;
                      (plVar20->color).foreground = (pdVar6->options).default_link;
                      plVar20->number = pdVar6->nlinks;
                      ppVar21 = plVar20->points;
                      uVar24 = local_124;
                      if (0 < (int)local_124) {
                        do {
                          ppVar21->x = local_120;
                          local_120 = local_120 + 1;
                          ppVar21->y = y;
                          ppVar21 = ppVar21 + 1;
                          uVar24 = uVar24 - 1;
                        } while (uVar24 != 0);
                      }
                      pdVar6->nlinks = pdVar6->nlinks + 1;
                      *(byte *)&pdVar6->field_0x114 = *(byte *)&pdVar6->field_0x114 & 0xfe;
                      puVar28 = p + local_108;
                      uVar1 = *puVar28;
                      *puVar28 = '\0';
                      pgVar22 = get_global_history_item(p_00);
                      if (pgVar22 == (global_history_item *)0x0) {
                        pbVar23 = get_bookmark(p_00);
                        if (pbVar23 == (bookmark *)0x0) {
                          (plVar20->color).foreground = (pdVar6->options).default_link;
                        }
                        else {
                          (plVar20->color).foreground = (pdVar6->options).default_bookmark_link;
                        }
                      }
                      else {
                        (plVar20->color).foreground = (pdVar6->options).default_vlink;
                      }
                      *puVar28 = uVar1;
                      (plVar20->color).background = (pdVar6->options).default_style.bg;
                      set_term_color(&template,&plVar20->color,(pdVar6->options).color_flags,
                                     (pdVar6->options).color_mode);
                      uVar24 = 0;
                      do {
                        uVar29 = uVar24;
                        template.data = (unicode_val_T)*p_00;
                        p_00 = p_00 + 1;
                        *(uint *)&local_ac[uVar29].attr = template._4_4_;
                        local_ac[uVar29].data = template.data;
                        uVar24 = uVar29 + 1;
                      } while (uVar24 != local_124);
                      local_a4 = local_a4 + uVar29;
                      psVar15 = local_ac + uVar24;
                      iVar12 = local_b4 + iVar13 + uVar29;
                    }
                    renderer.template._4_4_ =
                         uVar8 & 0xff |
                         (uint)CONCAT21(CONCAT11(renderer.template._7_1_,renderer.template.color[1])
                                        ,renderer.template.color[0]) << 8;
                    iVar11 = local_24;
                    local_ac = psVar15;
                    renderer.template.data = c;
                  }
                }
                else {
                  uVar29 = ~(local_c8 + local_a4) & 7;
                  psVar15 = local_ac;
                  uVar24 = uVar29;
                  do {
                    uVar24 = uVar24 - 1;
                    psVar15->data = 0x20;
                    *(uint *)&psVar15->attr = renderer.template._4_4_;
                    psVar15 = psVar15 + 1;
                  } while (uVar24 != 0xffffffff);
                  renderer.template._4_4_ =
                       uVar8 & 0xff |
                       (uint)CONCAT21(CONCAT11(renderer.template._7_1_,renderer.template.color[1]),
                                      renderer.template.color[0]) << 8;
                  iVar11 = local_24;
                  local_c8 = local_c8 + uVar29;
                  local_ac = local_ac + uVar29 + 1;
                  renderer.template.data = c;
                }
                local_a4 = local_a4 + local_cc;
              }
              else {
                local_28 = p_00;
                local_b4 = utf8charlen((uchar *)&local_20);
                local_d0 = utf8_to_unicode(&local_28,p + local_24);
                if (local_d0 != 0xfffffffd) {
                  local_cc = unicode_to_cell(local_d0);
                  iVar11 = local_24;
                  goto LAB_080a0702;
                }
                iVar11 = local_24;
                iVar12 = local_b4 + iVar13;
              }
LAB_080a07df:
              iVar13 = iVar12;
            } while (iVar12 < iVar11);
          }
          mem_free(p);
          realloc_line(document_00,(int)((int)local_ac - (int)psVar14) >> 3,y);
          pvVar27 = (void *)(local_c8 + local_24);
          mem_free(head);
          if ((pvVar27 != (void *)0x0) &&
             (ppvVar16 = (void **)mem_alloc(0x18), ppvVar16 != (void **)0x0)) {
            ppvVar16[2] = (void *)0x0;
            ppvVar16[5] = (void *)0x1;
            pvVar25 = (void *)renderer.lineno;
            if (renderer.lineno < 0) {
              pvVar25 = (void *)0x0;
            }
            ppvVar16[3] = pvVar25;
            pvVar25 = (void *)0x0;
            if (-1 < (int)pvVar27) {
              pvVar25 = pvVar27;
            }
            ppvVar16[4] = pvVar25;
            if ((renderer.document)->width < (int)pvVar27) {
              *(void **)&(renderer.document)->width = pvVar27;
              y = (renderer.document)->height;
            }
            else {
              y = (renderer.document)->height;
            }
            if (y < 1) {
              (renderer.document)->height = 1;
            }
            pvVar27 = ((renderer.document)->nodes).next;
            *(list_head_elinks **)(ppvVar16 + 1) = &(renderer.document)->nodes;
            *ppvVar16 = pvVar27;
            *(void ***)&((renderer.document)->nodes).next = ppvVar16;
            *(void ***)((int)*ppvVar16 + 4) = ppvVar16;
          }
          goto LAB_080a083a;
        }
LAB_080a0ebd:
        mem_free(head);
LAB_080a083a:
        local_b8 = local_b8 - (len + local_c4);
        local_a8 = local_a8 + len + local_c4;
      }
joined_r0x080a08e4:
      renderer.lineno = renderer.lineno + 1;
    } while (0 < local_b8);
  }
  if ((assert_failed == 0) && (assert_failed = ZEXT14(local_b8 != 0), local_b8 != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/plain/renderer.c";
    errline = 0x265;
    elinks_internal((uchar *)"assertion !length failed!");
  }
  return;
code_r0x080a09c5:
  iVar11 = iVar11 + local_a4;
  goto LAB_080a0605;
}



dom_config_flag parse_dom_config(uchar *flaglist,uchar separator)

{
  char *pcVar1;
  char *n;
  int iVar2;
  dom_config_flag dVar3;
  char *pcVar4;
  dom_config_info *pdVar5;
  int iVar6;
  dom_config_flag local_24;
  char *local_20;
  
  local_24 = 0;
  if (flaglist != (uchar *)0x0) {
    do {
      if (separator == '\0') {
LAB_080a1602:
        pcVar4 = (char *)strlen((char *)flaglist);
        local_20 = (char *)0x0;
      }
      else {
        local_20 = strchr((char *)flaglist,(uint)separator);
        if (local_20 == (char *)0x0) goto LAB_080a1602;
        pcVar4 = local_20 + -(int)flaglist;
      }
      pdVar5 = dom_config_info;
      iVar6 = 0;
      do {
        pcVar1 = (char *)(pdVar5->name).length;
        n = pcVar1;
        if ((int)pcVar4 <= (int)pcVar1) {
          n = pcVar4;
        }
        iVar2 = c_strncasecmp((char *)(pdVar5->name).string,(char *)flaglist,(size_t)n);
        if ((iVar2 == 0) && (pcVar4 == pcVar1)) {
          dVar3 = dom_config_info[iVar6].flag;
          goto LAB_080a165a;
        }
        iVar6 = iVar6 + 1;
        pdVar5 = pdVar5 + 1;
      } while (iVar6 != 7);
      dVar3 = 0;
LAB_080a165a:
      local_24 = local_24 | dVar3;
    } while ((local_20 != (char *)0x0) &&
            (flaglist = (uchar *)(local_20 + 1), flaglist != (uchar *)0x0));
  }
  return local_24;
}



dom_config * add_dom_config_normalizer(dom_stack *stack,dom_config *config,dom_config_flag flags)

{
  dom_stack_context *pdVar1;
  
  config->error_handler = (anon_subr_void_dom_config_ptr_dom_error_ptr_for_error_handler *)0x0;
  config->flags = flags;
  pdVar1 = add_dom_stack_context(stack,config,&dom_config_normalizer_context);
  if (pdVar1 == (dom_stack_context *)0x0) {
    config = (dom_config *)0x0;
  }
  return config;
}



dom_code __regparm3 normalize_text_node_whitespace(dom_node *node)

{
  int iVar1;
  uchar *p;
  ushort **ppuVar2;
  uchar *puVar3;
  dom_code dVar4;
  byte bVar5;
  uint uVar6;
  uint __n;
  int in_GS_OFFSET;
  bool bVar7;
  uchar *local_140;
  uint local_13c;
  uchar buf [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  p = (node->string).string;
  if ((assert_failed == 0) && (bVar7 = node->type != 3, assert_failed = ZEXT14(bVar7), bVar7)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/configuration.c";
    errline = 0x17;
    elinks_internal((uchar *)"assertion node->type == DOM_NODE_TEXT failed!");
  }
  uVar6 = 0;
  local_13c = 0;
  local_140 = (uchar *)0x0;
  bVar7 = false;
  if ((node->string).length != 0) {
    do {
      ppuVar2 = __ctype_b_loc();
      __n = 0;
      do {
        bVar5 = p[uVar6];
        if ((*(byte *)((int)*ppuVar2 + (uint)bVar5 * 2 + 1) & 0x20) == 0) {
          bVar7 = false;
LAB_080a17a2:
          buf[__n] = bVar5;
          __n = __n + 1;
        }
        else {
          if (!bVar7) {
            bVar5 = 0x20;
            bVar7 = true;
            goto LAB_080a17a2;
          }
        }
        uVar6 = uVar6 + 1;
      } while ((__n < 0x100) && (uVar6 <= (node->string).length && (node->string).length != uVar6));
      puVar3 = (uchar *)mem_realloc(local_140,local_13c + 1 + __n);
      if (puVar3 == (uchar *)0x0) {
        dVar4 = DOM_CODE_ALLOC_ERR;
        if (local_140 != (uchar *)0x0) {
          mem_free(local_140);
          dVar4 = DOM_CODE_ALLOC_ERR;
        }
        goto LAB_080a18f2;
      }
      memcpy(puVar3 + local_13c,buf,__n);
      local_13c = local_13c + __n;
      puVar3[local_13c] = '\0';
      local_140 = puVar3;
    } while (uVar6 < (node->string).length);
  }
  bVar5 = *(byte *)&node->field_0x2;
  if ((bVar5 & 1) != 0) {
    p = (node->string).string;
    if (p != (uchar *)0x0) {
      mem_free(p);
      bVar5 = *(byte *)&node->field_0x2;
    }
    (node->string).string = (uchar *)0x0;
    (node->string).length = 0;
  }
  (node->string).string = local_140;
  if (local_13c == 0xffffffff) {
    local_13c = strlen((char *)local_140);
  }
  (node->string).length = local_13c;
  dVar4 = DOM_CODE_OK;
  *(byte *)&node->field_0x2 = bVar5 | 1;
LAB_080a18f2:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return dVar4;
}



dom_code dom_normalize_text(dom_stack *stack,dom_node *node,void *data)

{
  dom_code dVar1;
  
  if ((*(byte *)stack->current->data & 0x40) == 0) {
    return DOM_CODE_OK;
  }
  dVar1 = normalize_text_node_whitespace(node);
  return dVar1;
}



dom_code __regparm3 append_node_text(dom_config *config,dom_node *node)

{
  int iVar1;
  ushort uVar2;
  uint16_t uVar3;
  uchar *__src;
  size_t __n;
  dom_node *node_00;
  uchar *__src_00;
  uchar *p;
  size_t sVar4;
  int iVar5;
  uchar *__dest;
  size_t local_20;
  
  node_00 = get_dom_node_prev(node);
  __src = (node->string).string;
  __n = (node->string).length;
  if ((node_00 == (dom_node *)0x0) || (node_00->type != 3)) {
    if (node->type == 3) {
      return DOM_CODE_OK;
    }
    __dest = (uchar *)0x0;
    local_20 = 0;
    node_00 = (dom_node *)0x0;
  }
  else {
    if ((*(byte *)&node_00->field_0x2 & 1) == 0) {
      local_20 = (node_00->string).length;
      __src_00 = (node_00->string).string;
      __dest = (uchar *)mem_realloc((void *)0x0,local_20 + 1);
      if (__dest == (uchar *)0x0) {
        return DOM_CODE_ALLOC_ERR;
      }
      memcpy(__dest,__src_00,local_20);
      __dest[local_20] = '\0';
      (node_00->string).string = __dest;
      sVar4 = local_20;
      if (local_20 == 0xffffffff) {
        sVar4 = strlen((char *)__dest);
      }
      (node_00->string).length = sVar4;
      *(byte *)&node_00->field_0x2 = *(byte *)&node_00->field_0x2 | 1;
    }
    else {
      local_20 = (node_00->string).length;
      __dest = (node_00->string).string;
    }
  }
  uVar2 = node->type;
  if (2 < uVar2) {
    if (uVar2 < 5) {
      __src_00 = (uchar *)mem_realloc(__dest,local_20 + 1 + __n);
      if (__src_00 == (uchar *)0x0) {
LAB_080a1bb0:
        if (node_00 != (dom_node *)0x0) {
          (node_00->string).length = local_20;
          return DOM_CODE_ALLOC_ERR;
        }
        if (__dest == (uchar *)0x0) {
          return DOM_CODE_ALLOC_ERR;
        }
        mem_free(__dest);
        return DOM_CODE_ALLOC_ERR;
      }
      memcpy(__src_00 + local_20,__src,__n);
      local_20 = __n + local_20;
      __src_00[local_20] = '\0';
      goto joined_r0x080a1aff;
    }
    if (uVar2 == 5) {
      __src_00 = (uchar *)mem_realloc(__dest,local_20 + 2);
      if (__src_00 != (uchar *)0x0) {
        __src_00[local_20] = '&';
        iVar5 = local_20 + 1;
        __src_00[iVar5] = '\0';
        iVar1 = __n + iVar5;
        p = (uchar *)mem_realloc(__src_00,iVar1 + 1U);
        __dest = __src_00;
        if (p != (uchar *)0x0) {
          memcpy(p + iVar5,__src,__n);
          p[iVar1] = '\0';
          __src_00 = (uchar *)mem_realloc(p,iVar1 + 2);
          __dest = p;
          if (__src_00 != (uchar *)0x0) {
            __src_00[iVar1] = ';';
            __src_00[iVar1 + 1] = '\0';
            local_20 = iVar1 + 1U;
            goto joined_r0x080a1aff;
          }
        }
      }
      goto LAB_080a1bb0;
    }
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/configuration.c";
  errline = 0x72;
  elinks_internal((uchar *)"Cannot append from node %d",(uint)node->type);
  __src_00 = __dest;
joined_r0x080a1aff:
  if (node_00 != (dom_node *)0x0) {
    (node_00->string).length = local_20;
    (node_00->string).string = __src_00;
    if (((*(byte *)&config->flags & 0x40) != 0) && (node->type != 5)) {
      normalize_text_node_whitespace(node_00);
      return DOM_CODE_FREE_NODE;
    }
    return DOM_CODE_FREE_NODE;
  }
  uVar3 = node->type;
  *(undefined4 *)node->data = 0;
  node->type = 3;
  *(undefined4 *)(node->data + 4) = 0;
  *(undefined4 *)(node->data + 8) = 0;
  *(undefined4 *)(node->data + 0xc) = 0;
  *(byte *)&node->field_0x2 = *(byte *)&node->field_0x2 | 1;
  (node->string).length = local_20;
  (node->string).string = __src_00;
  if (((*(byte *)&config->flags & 0x40) != 0) && (uVar3 == 4)) {
    normalize_text_node_whitespace(node);
    return DOM_CODE_OK;
  }
  return DOM_CODE_OK;
}



dom_code dom_normalize_node_end(dom_stack *stack,dom_node *node,void *data)

{
  short sVar1;
  dom_config *config;
  byte bVar2;
  dom_code dVar3;
  
  config = (dom_config *)stack->current->data;
  switch(node->type) {
  default:
    goto LAB_080a1cba;
  case 1:
  case 2:
    if ((*(byte *)&config->flags & 0x20) == 0) {
      return DOM_CODE_OK;
    }
    sVar1 = *(short *)(node->data + 10);
    break;
  case 3:
    if (((*(byte *)&config->flags & 4) == 0) && ((node->data[4] & 1) != 0)) {
      return DOM_CODE_FREE_NODE;
    }
    goto LAB_080a1ce2;
  case 4:
    bVar2 = *(byte *)&config->flags & 1;
    goto joined_r0x080a1d00;
  case 5:
    bVar2 = *(byte *)&config->flags & 8;
joined_r0x080a1d00:
    if (bVar2 != 0) {
      return DOM_CODE_OK;
    }
LAB_080a1ce2:
    dVar3 = append_node_text(config,node);
    return dVar3;
  case 7:
    if ((*(byte *)&config->flags & 0x20) == 0) {
      return DOM_CODE_OK;
    }
    sVar1 = *(short *)(node->data + 8);
    break;
  case 8:
    if ((*(byte *)&config->flags & 2) == 0) {
      return DOM_CODE_FREE_NODE;
    }
    goto LAB_080a1cba;
  }
  if (sVar1 == 0) {
    return DOM_CODE_FREE_NODE;
  }
LAB_080a1cba:
  return DOM_CODE_OK;
}



dom_string * get_dom_node_type_name(dom_node_type type)

{
  dom_string dom_node_type_names [13];
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(DOM_NODE_NOTATION < type), DOM_NODE_NOTATION < type)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x24b;
    elinks_internal((uchar *)"assertion type < DOM_NODES failed!");
    return (dom_string *)(type * 8 + 0x8141900);
  }
  return (dom_string *)&ram0x08141900 + type;
}



dom_string * get_dom_node_value(dom_node *node)

{
  ushort uVar1;
  dom_string *pdVar2;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(node == (dom_node *)0x0), node == (dom_node *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x21e;
    elinks_internal((uchar *)"assertion node failed!");
    uVar1 = uRam00000000;
  }
  else {
    uVar1 = node->type;
  }
  if (8 < uVar1) {
    return (dom_string *)0x0;
  }
                    // WARNING: Could not recover jumptable at 0x080a1ddb. Too many branches
                    // WARNING: Treating indirect jump as call
  pdVar2 = (dom_string *)(**(code **)(&DAT_081020b4 + (uint)node->type * 4))();
  return pdVar2;
}



dom_string * get_dom_node_name(dom_node *node)

{
  dom_string text_str;
  dom_string document_fragment_str;
  dom_string document_str;
  dom_string comment_str;
  dom_string cdata_section_str;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(node == (dom_node *)0x0), node == (dom_node *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x1fd;
    elinks_internal((uchar *)"assertion node failed!");
  }
  switch(node->type) {
  case 3:
    return (dom_string *)&ram0x08141968;
  case 4:
    return (dom_string *)&ram0x08141988;
  default:
    return &node->string;
  case 8:
    return (dom_string *)&ram0x08141980;
  case 9:
    return (dom_string *)&ram0x08141978;
  case 0xb:
    return (dom_string *)&ram0x08141970;
  }
}



int __regparm3 get_dom_node_list_pos(dom_node_list *list,dom_node *node)

{
  uint uVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return -1;
  }
  assert_failed = ZEXT14(list == (dom_node_list *)0x0);
  if (list == (dom_node_list *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0xeb;
    elinks_internal((uchar *)"assertion list failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return -1;
    }
  }
  if (list->size != 0) {
    uVar1 = 0;
    do {
      if ((list->entries[uVar1] != (dom_node *)0x0) && (list->entries[uVar1] == node)) {
        return uVar1;
      }
      uVar1 = uVar1 + 1;
    } while (uVar1 < list->size);
  }
  return -1;
}



dom_node * get_dom_node_prev(dom_node *node)

{
  uint16_t uVar1;
  ushort uVar2;
  dom_node *pdVar3;
  int iVar4;
  dom_node_list **ppdVar5;
  bool bVar6;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (dom_node *)0x0;
  }
  bVar6 = node->parent == (dom_node *)0x0;
  assert_failed = ZEXT14(bVar6);
  if (bVar6) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x104;
    elinks_internal((uchar *)"assertion node->parent failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (dom_node *)0x0;
    }
  }
  pdVar3 = node->parent;
  uVar1 = node->type;
  uVar2 = pdVar3->type;
  if (uVar2 == 7) {
    if (uVar1 != 2) {
      return (dom_node *)0x0;
    }
    ppdVar5 = (dom_node_list **)(pdVar3->data + 0xc);
  }
  else {
    if (uVar2 < 8) {
      if (uVar2 != 1) {
        return (dom_node *)0x0;
      }
      ppdVar5 = (dom_node_list **)pdVar3->data;
      if (uVar1 == 2) {
        ppdVar5 = (dom_node_list **)(pdVar3->data + 4);
      }
    }
    else {
      if (uVar2 != 9) {
        if (uVar2 != 10) {
          return (dom_node *)0x0;
        }
        if (uVar1 == 6) {
          ppdVar5 = (dom_node_list **)pdVar3->data;
          goto LAB_080a2019;
        }
        if (uVar1 != 0xc) {
          return (dom_node *)0x0;
        }
      }
      ppdVar5 = (dom_node_list **)(pdVar3->data + 4);
    }
  }
LAB_080a2019:
  if (ppdVar5 == (dom_node_list **)0x0) {
    return (dom_node *)0x0;
  }
  assert_failed = ZEXT14(*ppdVar5 == (dom_node_list *)0x0);
  if (*ppdVar5 == (dom_node_list *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x10c;
    elinks_internal((uchar *)"assertion *list failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (dom_node *)0x0;
    }
  }
  iVar4 = get_dom_node_list_pos(*ppdVar5,node);
  if (assert_failed != 0) {
    assert_failed = 0;
    return (dom_node *)0x0;
  }
  assert_failed = -(iVar4 >> 0x1f);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x110;
    elinks_internal((uchar *)"assertion index >= 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (dom_node *)0x0;
    }
  }
  if (0 < iVar4) {
    return (dom_node *)(&(*ppdVar5)->size)[iVar4];
  }
  return (dom_node *)0x0;
}



void __regparm3 del_from_dom_node_list(dom_node_list *list,dom_node *node)

{
  dom_node_list *pdVar1;
  uint uVar2;
  uint uVar3;
  
  if ((list != (dom_node_list *)0x0) && (uVar3 = list->size, uVar3 != 0)) {
    uVar2 = 1;
    pdVar1 = list;
    while( true ) {
      if (((dom_node *)(&list->size)[uVar2] != (dom_node *)0x0) &&
         ((dom_node *)(&list->size)[uVar2] == node)) {
        if (uVar3 - uVar2 != 0) {
          memmove((dom_node_list *)pdVar1->entries,pdVar1 + 1,(uVar3 - uVar2) * 4);
          uVar3 = list->size;
        }
        uVar3 = uVar3 - 1;
        list->size = uVar3;
      }
      if (uVar3 <= uVar2) break;
      uVar2 = uVar2 + 1;
      pdVar1 = (dom_node_list *)pdVar1->entries;
    }
  }
  return;
}



void __regparm3 done_dom_node_data(dom_node *node)

{
  ushort uVar1;
  uchar *p;
  bool bVar2;
  byte bVar3;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(node == (dom_node *)0x0);
    if (node == (dom_node *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 0x19e;
      elinks_internal((uchar *)"assertion node failed!");
      if (assert_failed != 0) goto LAB_080a223d;
    }
    bVar2 = 0xc < node->type;
    assert_failed = ZEXT14(bVar2);
    if (bVar2) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 0x19f;
      elinks_internal((uchar *)"assertion node->type < DOM_NODES failed!");
    }
  }
LAB_080a223d:
  uVar1 = node->type;
  if (uVar1 == 2) {
LAB_080a22cf:
    bVar3 = *(byte *)&node->field_0x2;
    if ((bVar3 & 1) == 0) goto LAB_080a227f;
    if (*(void **)(node->data + 4) != (void *)0x0) {
      mem_free(*(void **)(node->data + 4));
      bVar3 = *(byte *)&node->field_0x2;
    }
    *(undefined4 *)(node->data + 4) = 0;
    *(undefined4 *)node->data = 0;
  }
  else {
    if (uVar1 < 3) {
      if (uVar1 == 1) {
        if (*(dom_node_list **)node->data != (dom_node_list *)0x0) {
          done_dom_node_list(*(dom_node_list **)node->data);
        }
        if (*(dom_node_list **)(node->data + 4) != (dom_node_list *)0x0) {
          done_dom_node_list(*(dom_node_list **)(node->data + 4));
        }
      }
LAB_080a2256:
      bVar3 = *(byte *)&node->field_0x2;
    }
    else {
      if (uVar1 == 7) {
        if (*(dom_node_list **)(node->data + 0xc) != (dom_node_list *)0x0) {
          done_dom_node_list(*(dom_node_list **)(node->data + 0xc));
        }
        goto LAB_080a22cf;
      }
      if ((uVar1 != 9) || (*(dom_node_list **)(node->data + 4) == (dom_node_list *)0x0))
      goto LAB_080a2256;
      done_dom_node_list(*(dom_node_list **)(node->data + 4));
      bVar3 = *(byte *)&node->field_0x2;
    }
  }
  if ((bVar3 & 1) != 0) {
    p = (node->string).string;
    if (p != (uchar *)0x0) {
      mem_free(p);
    }
    (node->string).string = (uchar *)0x0;
    (node->string).length = 0;
  }
LAB_080a227f:
  node->type = 0xffff;
  mem_free(node);
  return;
}



void done_dom_node_list(dom_node_list *list)

{
  uint uVar1;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(list == (dom_node_list *)0x0), list == (dom_node_list *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x71;
    elinks_internal((uchar *)"assertion list failed!");
  }
  if (list->size != 0) {
    uVar1 = 0;
    do {
      if (list->entries[uVar1] != (dom_node *)0x0) {
        done_dom_node_data(list->entries[uVar1]);
      }
      uVar1 = uVar1 + 1;
    } while (uVar1 <= list->size && list->size != uVar1);
  }
  mem_free(list);
  return;
}



void done_dom_node(dom_node *node)

{
  uint16_t uVar1;
  dom_node *pdVar2;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(node == (dom_node *)0x0), node == (dom_node *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x1d5;
    elinks_internal((uchar *)"assertion node failed!");
  }
  pdVar2 = node->parent;
  if (pdVar2 != (dom_node *)0x0) {
    uVar1 = pdVar2->type;
    if (uVar1 == 7) {
      del_from_dom_node_list(*(dom_node_list **)(pdVar2->data + 0xc),node);
      done_dom_node_data(node);
      return;
    }
    if (uVar1 != 9) {
      if (uVar1 != 1) goto LAB_080a2452;
      del_from_dom_node_list(*(dom_node_list **)pdVar2->data,node);
    }
    del_from_dom_node_list(*(dom_node_list **)(pdVar2->data + 4),node);
    done_dom_node_data(node);
    return;
  }
LAB_080a2452:
  done_dom_node_data(node);
  return;
}



int dom_node_casecmp(dom_node *node1,dom_node *node2)

{
  uint16_t uVar1;
  size_t sVar2;
  size_t n;
  int iVar3;
  
  uVar1 = node1->type;
  if (((uVar1 == node2->type) &&
      (((uVar1 == 1 || (uVar1 == 2)) && (*(ushort *)(node1->data + 10) != 0)))) &&
     (*(ushort *)(node2->data + 10) != 0)) {
    iVar3 = (uint)*(ushort *)(node1->data + 10) - (uint)*(ushort *)(node2->data + 10);
  }
  else {
    n = (node2->string).length;
    sVar2 = (node1->string).length;
    if ((int)sVar2 <= (int)n) {
      n = sVar2;
    }
    iVar3 = c_strncasecmp((char *)(node1->string).string,(char *)(node2->string).string,n);
    if (iVar3 == 0) {
      iVar3 = (node1->string).length - (node2->string).length;
    }
  }
  return iVar3;
}



dom_node *
get_dom_node_map_entry(dom_node_list *list,dom_node_type type,uint16_t subtype,dom_string *name)

{
  dom_node *node2;
  uint16_t uVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  dom_node node;
  
  node.string.length = name->length;
  node.string.string = name->string;
  uVar2 = 0;
  do {
    *(undefined4 *)((int)&node.type + uVar2) = 0;
    uVar2 = uVar2 + 4;
  } while (uVar2 < 0x20);
  node.type = (uint16_t)type;
  uVar2 = list->size;
  uVar1 = node.data._8_2_;
  if ((subtype != 0) &&
     ((type == DOM_NODE_ATTRIBUTE ||
      ((uVar1 = subtype, type != DOM_NODE_PROCESSING_INSTRUCTION &&
       (uVar1 = node.data._8_2_, type == DOM_NODE_ELEMENT)))))) {
    uVar1 = node.data._8_2_;
    node.data._10_2_ = subtype;
  }
  node.data._8_2_ = uVar1;
  iVar3 = assert_failed;
  if ((assert_failed == 0) && (uVar4 = (uint)(uVar2 == 0), assert_failed = uVar4, uVar2 == 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0xab;
    elinks_internal((uchar *)"assertion has_bsearch_node(search->from, search->to) failed!");
    iVar3 = assert_failed;
  }
  uVar4 = 0xffffffff;
  while( true ) {
    uVar5 = (int)(uVar2 - uVar4) / 2 + uVar4;
    if (iVar3 == 0) {
      if (((int)uVar5 < 0) || (list->size <= uVar5)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
        errline = 0xa2;
        elinks_internal((uchar *)"assertion 0 <= pos && pos < list->size failed: pos %d",uVar5);
      }
      else {
        assert_failed = 0;
      }
    }
    node2 = list->entries[uVar5];
    iVar3 = dom_node_casecmp(&node,node2);
    if (iVar3 == 0) break;
    if (iVar3 < 0) {
      uVar2 = uVar5;
      uVar5 = uVar4;
    }
    uVar4 = uVar5;
    iVar3 = assert_failed;
    if (uVar2 <= uVar4 + 1) {
      return (dom_node *)0x0;
    }
  }
  return node2;
}



dom_node_list * add_to_dom_node_list(dom_node_list **list_ptr,dom_node *node,int position)

{
  uint uVar1;
  size_t size;
  size_t sVar2;
  dom_node **ppdVar3;
  undefined2 *puVar4;
  dom_node_list *p;
  uint uVar5;
  bool bVar6;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(node == (dom_node *)0x0 || list_ptr == (dom_node_list **)0x0),
     node == (dom_node *)0x0 || list_ptr == (dom_node_list **)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x3d;
    elinks_internal((uchar *)"assertion list_ptr && node failed!");
    p = *list_ptr;
    if (p != (dom_node_list *)0x0) goto LAB_080a2702;
LAB_080a27f0:
    size = 0x24;
    uVar5 = 0;
    sVar2 = 0;
LAB_080a27f9:
    p = (dom_node_list *)mem_realloc(p,size);
    if (p == (dom_node_list *)0x0) {
      return (dom_node_list *)0x0;
    }
    if (sVar2 == 0) {
      p->size = 0;
    }
    ppdVar3 = p->entries + uVar5;
    uVar5 = 0x20;
    bVar6 = ((uint)ppdVar3 & 1) != 0;
    if (bVar6) {
      *(undefined *)ppdVar3 = 0;
      uVar5 = 0x1f;
      ppdVar3 = (dom_node **)((int)ppdVar3 + 1);
    }
    if (((uint)ppdVar3 & 2) != 0) {
      *(undefined2 *)ppdVar3 = 0;
      uVar5 = uVar5 - 2;
      ppdVar3 = (dom_node **)((int)ppdVar3 + 2);
    }
    uVar1 = 0;
    do {
      *(undefined4 *)((int)ppdVar3 + uVar1) = 0;
      uVar1 = uVar1 + 4;
    } while (uVar1 < (uVar5 & 0xfffffffc));
    puVar4 = (undefined2 *)((int)ppdVar3 + uVar1);
    if ((uVar5 & 2) != 0) {
      *puVar4 = 0;
      puVar4 = puVar4 + 1;
    }
    if (bVar6) {
      *(undefined *)puVar4 = 0;
    }
    *list_ptr = p;
  }
  else {
    p = *list_ptr;
    if (p == (dom_node_list *)0x0) goto LAB_080a27f0;
LAB_080a2702:
    sVar2 = p->size;
    uVar5 = sVar2 + 7 & 0xfffffff8;
    uVar1 = sVar2 + 8 & 0xfffffff8;
    if (uVar5 < uVar1) {
      size = uVar1 * 4 + 4;
      goto LAB_080a27f9;
    }
  }
  if (assert_failed == 0) {
    if ((position < 0) || ((uint)position < p->size || position == p->size)) {
      assert_failed = 0;
      goto LAB_080a278a;
    }
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x43;
    elinks_internal((uchar *)
                    "assertion position < 0 || position <= list->size failed: position out of bound %d > %zu"
                    ,position,p->size);
  }
  else {
LAB_080a278a:
    if (position < 0) {
      uVar5 = p->size;
      position = uVar5;
      goto LAB_080a2764;
    }
  }
  uVar5 = p->size;
  if ((uint)position < uVar5) {
    memmove(&p->size + position + 2,&p->size + position + 1,(uVar5 - position) * 4);
    uVar5 = p->size;
  }
LAB_080a2764:
  p->size = uVar5 + 1;
  p->entries[position] = node;
  return p;
}



dom_node * get_dom_node_child(dom_node *parent,dom_node_type type,int16_t subtype)

{
  ushort uVar1;
  uint *puVar2;
  dom_node *pdVar3;
  uint **ppuVar4;
  uint uVar5;
  
  uVar1 = parent->type;
  if (uVar1 == 7) {
    if (type != DOM_NODE_ATTRIBUTE) {
      return (dom_node *)0x0;
    }
    ppuVar4 = (uint **)(parent->data + 0xc);
  }
  else {
    if (uVar1 < 8) {
      if (uVar1 != 1) {
        return (dom_node *)0x0;
      }
      ppuVar4 = (uint **)parent->data;
      if (type == DOM_NODE_ATTRIBUTE) {
        ppuVar4 = (uint **)(parent->data + 4);
      }
    }
    else {
      if (uVar1 != 9) {
        if (uVar1 != 10) {
          return (dom_node *)0x0;
        }
        if (type == DOM_NODE_ENTITY) {
          ppuVar4 = (uint **)parent->data;
          goto LAB_080a2912;
        }
        if (type != DOM_NODE_NOTATION) {
          return (dom_node *)0x0;
        }
      }
      ppuVar4 = (uint **)(parent->data + 4);
    }
  }
LAB_080a2912:
  if (((ppuVar4 != (uint **)0x0) && (puVar2 = *ppuVar4, puVar2 != (uint *)0x0)) && (*puVar2 != 0)) {
    uVar5 = 0;
    do {
      pdVar3 = (dom_node *)puVar2[uVar5 + 1];
      if ((pdVar3 != (dom_node *)0x0) && ((uint)pdVar3->type == type)) {
        if (subtype == 0) {
          return pdVar3;
        }
        if (((type != DOM_NODE_ATTRIBUTE) && (type != DOM_NODE_PROCESSING_INSTRUCTION)) &&
           (type != DOM_NODE_ELEMENT)) {
          return pdVar3;
        }
        if ((uint)*(ushort *)(pdVar3->data + 10) == (int)subtype) {
          return pdVar3;
        }
      }
      uVar5 = uVar5 + 1;
    } while (uVar5 < *puVar2);
  }
  return (dom_node *)0x0;
}



int get_dom_node_list_index(dom_node *parent,dom_node *node)

{
  ushort uVar1;
  uint16_t uVar2;
  dom_node_list **ppdVar3;
  int iVar4;
  
  uVar1 = parent->type;
  uVar2 = node->type;
  if (uVar1 == 7) {
    if (uVar2 != 2) {
      return -1;
    }
    ppdVar3 = (dom_node_list **)(parent->data + 0xc);
  }
  else {
    if (uVar1 < 8) {
      if (uVar1 != 1) {
        return -1;
      }
      ppdVar3 = (dom_node_list **)parent->data;
      if (uVar2 == 2) {
        ppdVar3 = (dom_node_list **)(parent->data + 4);
      }
    }
    else {
      if (uVar1 != 9) {
        if (uVar1 != 10) {
          return -1;
        }
        if (uVar2 == 6) {
          ppdVar3 = (dom_node_list **)parent->data;
          goto LAB_080a29eb;
        }
        if (uVar2 != 0xc) {
          return -1;
        }
      }
      ppdVar3 = (dom_node_list **)(parent->data + 4);
    }
  }
LAB_080a29eb:
  if ((ppdVar3 != (dom_node_list **)0x0) && (*ppdVar3 != (dom_node_list *)0x0)) {
    iVar4 = get_dom_node_list_pos(*ppdVar3,node);
    return iVar4;
  }
  return -1;
}



dom_node * get_dom_node_next(dom_node *node)

{
  uint16_t uVar1;
  ushort uVar2;
  dom_node *pdVar3;
  int iVar4;
  dom_node_list **ppdVar5;
  bool bVar6;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (dom_node *)0x0;
  }
  bVar6 = node->parent == (dom_node *)0x0;
  assert_failed = ZEXT14(bVar6);
  if (bVar6) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x11f;
    elinks_internal((uchar *)"assertion node->parent failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (dom_node *)0x0;
    }
  }
  pdVar3 = node->parent;
  uVar1 = node->type;
  uVar2 = pdVar3->type;
  if (uVar2 == 7) {
    if (uVar1 != 2) {
      return (dom_node *)0x0;
    }
    ppdVar5 = (dom_node_list **)(pdVar3->data + 0xc);
  }
  else {
    if (uVar2 < 8) {
      if (uVar2 != 1) {
        return (dom_node *)0x0;
      }
      ppdVar5 = (dom_node_list **)pdVar3->data;
      if (uVar1 == 2) {
        ppdVar5 = (dom_node_list **)(pdVar3->data + 4);
      }
    }
    else {
      if (uVar2 != 9) {
        if (uVar2 != 10) {
          return (dom_node *)0x0;
        }
        if (uVar1 == 6) {
          ppdVar5 = (dom_node_list **)pdVar3->data;
          goto LAB_080a2ac9;
        }
        if (uVar1 != 0xc) {
          return (dom_node *)0x0;
        }
      }
      ppdVar5 = (dom_node_list **)(pdVar3->data + 4);
    }
  }
LAB_080a2ac9:
  if (ppdVar5 != (dom_node_list **)0x0) {
    assert_failed = ZEXT14(*ppdVar5 == (dom_node_list *)0x0);
    if (*ppdVar5 == (dom_node_list *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 0x127;
      elinks_internal((uchar *)"assertion *list failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return (dom_node *)0x0;
      }
    }
    iVar4 = get_dom_node_list_pos(*ppdVar5,node);
    if (assert_failed != 0) {
      assert_failed = 0;
      return (dom_node *)0x0;
    }
    assert_failed = -(iVar4 >> 0x1f);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 299;
      elinks_internal((uchar *)"assertion index >= 0 failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return (dom_node *)0x0;
      }
    }
    if (iVar4 + 1U < (*ppdVar5)->size) {
      return (*ppdVar5)->entries[iVar4 + 1U];
    }
  }
  return (dom_node *)0x0;
}



int get_dom_node_map_index(dom_node_list *list,dom_node *node)

{
  dom_node *node2;
  int iVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  
  uVar4 = list->size;
  iVar1 = assert_failed;
  if ((assert_failed == 0) && (uVar2 = (uint)(uVar4 == 0), assert_failed = uVar2, uVar4 == 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0xab;
    elinks_internal((uchar *)"assertion has_bsearch_node(search->from, search->to) failed!");
    iVar1 = assert_failed;
  }
  uVar2 = 0xffffffff;
  while( true ) {
    uVar3 = (int)(uVar4 - uVar2) / 2 + uVar2;
    if (iVar1 == 0) {
      if (((int)uVar3 < 0) || (list->size <= uVar3)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
        errline = 0xa2;
        elinks_internal((uchar *)"assertion 0 <= pos && pos < list->size failed: pos %d",uVar3);
      }
      else {
        assert_failed = 0;
      }
    }
    node2 = list->entries[uVar3];
    iVar1 = dom_node_casecmp(node,node2);
    if (iVar1 == 0) break;
    if (iVar1 < 0) {
      uVar4 = uVar3;
      uVar3 = uVar2;
    }
    uVar2 = uVar3;
    iVar1 = assert_failed;
    if (uVar4 <= uVar2 + 1) {
      return uVar4;
    }
  }
  if (node2 == (dom_node *)0x0) {
    uVar3 = uVar4;
  }
  return uVar3;
}



dom_node * init_dom_node_at(dom_node *parent,dom_node_type type,dom_string *string,int allocated)

{
  ushort uVar1;
  uint16_t uVar2;
  uchar *__src;
  size_t __n;
  byte bVar3;
  dom_node *node;
  int position;
  dom_node_list *list;
  uchar *puVar4;
  uint uVar5;
  dom_node_list **list_ptr;
  
  node = (dom_node *)mem_calloc(1,0x20);
  if (node == (dom_node *)0x0) {
    return (dom_node *)0x0;
  }
  node->parent = parent;
  node->type = (uint16_t)type;
  if (allocated < 0) {
    if (parent == (dom_node *)0x0) {
      bVar3 = *(byte *)&node->field_0x2;
    }
    else {
      bVar3 = *(byte *)&node->field_0x2 & 0xfe | *(byte *)&parent->field_0x2 & 1;
      *(byte *)&node->field_0x2 = bVar3;
    }
  }
  else {
    bVar3 = *(byte *)&node->field_0x2 & 0xfe | allocated != 0;
    *(byte *)&node->field_0x2 = bVar3;
  }
  if ((bVar3 & 1) == 0) {
    uVar5 = string->length;
    __src = string->string;
    (node->string).string = __src;
    if (uVar5 == 0xffffffff) {
      uVar5 = strlen((char *)__src);
    }
    (node->string).length = uVar5;
  }
  else {
    __n = string->length;
    __src = string->string;
    puVar4 = (uchar *)mem_realloc((node->string).string,(node->string).length + __n + 1);
    if (puVar4 == (uchar *)0x0) goto LAB_080a2f70;
    (node->string).string = puVar4;
    memcpy(puVar4 + (node->string).length,__src,__n);
    uVar5 = __n + (node->string).length;
    (node->string).length = uVar5;
    (node->string).string[uVar5] = '\0';
  }
  if (parent == (dom_node *)0x0) {
    return node;
  }
  uVar1 = parent->type;
  uVar2 = node->type;
  if (uVar1 == 7) {
    list_ptr = (dom_node_list **)(parent->data + 0xc);
    if (uVar2 != 2) goto LAB_080a2dd0;
  }
  else {
    if (uVar1 < 8) {
      if (uVar1 == 1) {
        list_ptr = (dom_node_list **)parent->data;
        if (uVar2 == 2) {
          list_ptr = (dom_node_list **)(parent->data + 4);
        }
      }
      else {
LAB_080a2dd0:
        list_ptr = (dom_node_list **)0x0;
      }
    }
    else {
      if (uVar1 != 9) {
        if (uVar1 == 10) {
          list_ptr = (dom_node_list **)parent->data;
          if (uVar2 == 6) goto LAB_080a2dd2;
          if (uVar2 == 0xc) goto LAB_080a2ea7;
        }
        goto LAB_080a2dd0;
      }
LAB_080a2ea7:
      list_ptr = (dom_node_list **)(parent->data + 4);
    }
  }
LAB_080a2dd2:
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(list_ptr == (dom_node_list **)0x0), list_ptr == (dom_node_list **)0x0))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x18b;
    elinks_internal((uchar *)"assertion list != NULL failed: Adding node %d to bad parent %d",
                    (uint)node->type,(uint)parent->type);
  }
  list = *list_ptr;
  if (((list == (dom_node_list *)0x0) || (type != DOM_NODE_ATTRIBUTE)) || (list->size == 0)) {
    position = -1;
  }
  else {
    position = get_dom_node_map_index(list,node);
  }
  list = add_to_dom_node_list(list_ptr,node,position);
  if (list != (dom_node_list *)0x0) {
    return node;
  }
LAB_080a2f70:
  done_dom_node(node);
  return (dom_node *)0x0;
}



// WARNING: Exceeded maximum restarts with more pending

dom_scanner_token * skip_dom_scanner_tokens(dom_scanner *scanner,int skipto,int precedence)

{
  dom_scanner_token *pdVar1;
  dom_scanner_token *pdVar2;
  dom_scanner_token *pdVar3;
  int iVar4;
  
  iVar4 = scanner->tokens;
  if (((0 < iVar4) && (pdVar3 = scanner->current, pdVar3 < scanner->table + iVar4)) &&
     (pdVar3 != (dom_scanner_token *)0x0)) {
    if (pdVar3->type == skipto) {
LAB_080a302b:
      if (0 < iVar4) {
        pdVar1 = scanner->current;
        pdVar3 = scanner->table + iVar4;
        if (pdVar1 < pdVar3) {
          pdVar2 = pdVar1 + 1;
          scanner->current = pdVar2;
          if (pdVar3 <= pdVar1 + 2) {
                    // WARNING: Could not recover jumptable at 0x080a3068. Too many branches
                    // WARNING: Treating indirect jump as call
            pdVar3 = (*scanner->info->scan)();
            return pdVar3;
          }
          if (pdVar2 < pdVar3) {
            return pdVar2;
          }
        }
      }
    }
    else {
      if (pdVar3->precedence <= precedence) {
        while (pdVar1 = scanner->table + iVar4, pdVar3 < pdVar1) {
          pdVar2 = pdVar3 + 1;
          scanner->current = pdVar2;
          if (pdVar3 + 2 < pdVar1) {
            if (iVar4 < 1) {
              return (dom_scanner_token *)0x0;
            }
            if (pdVar1 <= pdVar2) {
              return (dom_scanner_token *)0x0;
            }
          }
          else {
            pdVar2 = (*scanner->info->scan)(scanner);
          }
          if (pdVar2 == (dom_scanner_token *)0x0) {
            return (dom_scanner_token *)0x0;
          }
          if (pdVar2->type == skipto) {
LAB_080a3028:
            iVar4 = scanner->tokens;
            goto LAB_080a302b;
          }
          if (pdVar2->precedence != precedence && precedence <= pdVar2->precedence) {
            if (skipto != pdVar2->type) {
              return (dom_scanner_token *)0x0;
            }
            goto LAB_080a3028;
          }
          iVar4 = scanner->tokens;
          if (iVar4 < 1) {
            return (dom_scanner_token *)0x0;
          }
          pdVar3 = scanner->current;
        }
      }
    }
  }
  return (dom_scanner_token *)0x0;
}



// WARNING: Exceeded maximum restarts with more pending

void init_dom_scanner(dom_scanner *scanner,dom_scanner_info *scanner_info,dom_string *string,
                     int state,int count_lines,int complete,int check_complete,int detect_errors)

{
  byte *pbVar1;
  uint uVar2;
  bool bVar3;
  byte bVar4;
  uchar *puVar5;
  int iVar6;
  anon_enum_32_for_type aVar7;
  dom_scan_table_info *pdVar8;
  uint uVar9;
  dom_scanner *pdVar10;
  byte bVar11;
  dom_scan_table_info *local_20;
  
  bVar11 = 0;
  bVar4 = *(byte *)&scanner_info->field_0x40c;
  if ((bVar4 & 1) == 0) {
    pdVar8 = scanner_info->scan_table_info;
    if ((pdVar8 != (dom_scan_table_info *)0x0) && (aVar7 = pdVar8->type, aVar7 != _IScntrl)) {
      local_20 = pdVar8 + 1;
      do {
        while (aVar7 != SCAN_RANGE) {
          puVar5 = (pdVar8->data).string;
          uVar2 = (pdVar8->data).length;
          uVar9 = uVar2 - 1;
          if (assert_failed == 0) {
            assert_failed = (uint)(aVar7 != _ISblank) | uVar9 >> 0x1f;
            if (assert_failed != 0) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.c";
              errline = 0x93;
              elinks_internal((uchar *)
                              "assertion info[i].type == DOM_SCAN_STRING && pos >= 0 failed!");
              goto LAB_080a3288;
            }
          }
          else {
LAB_080a3288:
            if ((int)uVar9 < 0) goto LAB_080a3147;
          }
          puVar5 = puVar5 + uVar2;
          do {
            pbVar1 = puVar5 + -1;
            puVar5 = puVar5 + -1;
            scanner_info->scan_table[*pbVar1] = scanner_info->scan_table[*pbVar1] | pdVar8->bits;
            uVar9 = uVar9 - 1;
          } while (-1 < (int)uVar9);
          aVar7 = local_20->type;
          pdVar8 = local_20;
          local_20 = local_20 + 1;
          if (aVar7 == _IScntrl) goto LAB_080a3155;
        }
        bVar4 = *(pdVar8->data).string;
        uVar9 = (uint)bVar4;
        if (assert_failed == 0) {
          assert_failed = ZEXT14(bVar4 == 0);
          if (bVar4 == 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.c";
            errline = 0x88;
            elinks_internal((uchar *)"assertion index > 0 failed!");
            if (assert_failed != 0) goto LAB_080a3132;
          }
          bVar3 = 0xff < (pdVar8->data).length;
          assert_failed = ZEXT14(bVar3);
          if (bVar3) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.c";
            errline = 0x89;
            elinks_internal((uchar *)"assertion data->length < DOM_SCAN_TABLE_SIZE failed!");
            if (assert_failed != 0) goto LAB_080a3132;
          }
          bVar3 = (pdVar8->data).length <= uVar9 && uVar9 != (pdVar8->data).length;
          assert_failed = ZEXT14(bVar3);
          if (bVar3) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.c";
            errline = 0x8a;
            elinks_internal((uchar *)"assertion index <= data->length failed!");
          }
        }
LAB_080a3132:
        if (uVar9 <= (pdVar8->data).length) {
          do {
            scanner_info->scan_table[uVar9] = scanner_info->scan_table[uVar9] | pdVar8->bits;
            uVar9 = uVar9 + 1;
          } while (uVar9 < (pdVar8->data).length || uVar9 == (pdVar8->data).length);
        }
LAB_080a3147:
        aVar7 = local_20->type;
        pdVar8 = local_20;
        local_20 = local_20 + 1;
      } while (aVar7 != _IScntrl);
LAB_080a3155:
      bVar4 = *(byte *)&scanner_info->field_0x40c;
    }
    *(byte *)&scanner_info->field_0x40c = bVar4 | 1;
  }
  iVar6 = 0x3d;
  pdVar10 = scanner;
  while (iVar6 != 0) {
    iVar6 = iVar6 + -1;
    pdVar10->string = (uchar *)0x0;
    pdVar10 = (dom_scanner *)((int)pdVar10 + (uint)bVar11 * -8 + 4);
  }
  scanner->string = string->string;
  scanner->position = string->string;
  puVar5 = string->string;
  uVar9 = string->length;
  scanner->info = scanner_info;
  scanner->end = puVar5 + uVar9;
  scanner->current = scanner->table;
  scanner->state = state;
  *(byte *)&scanner->field_0x20 = *(byte *)&scanner->field_0x20 & 0xfe | count_lines != 0;
  *(byte *)&scanner->field_0x18 =
       (*(byte *)&scanner->field_0x18 & 0xfc | (complete == 0) * '\x02') & 0xfb |
       check_complete != 0 | (detect_errors != 0) << 2;
  scanner->lineno = (uint)(count_lines != 0);
                    // WARNING: Could not recover jumptable at 0x080a31fb. Too many branches
                    // WARNING: Treating indirect jump as call
  (*scanner_info->scan)();
  return;
}



int map_dom_scanner_string(dom_scanner *scanner,uchar *ident,uchar *end,int base_type)

{
  dom_scanner_string_mapping *pdVar1;
  uchar *s1;
  uchar *n;
  int iVar2;
  
  end = end + -(int)ident;
  pdVar1 = scanner->info->mappings;
  s1 = (pdVar1->name).string;
  while( true ) {
    if (s1 == (uchar *)0x0) {
      return base_type;
    }
    n = (uchar *)(pdVar1->name).length;
    if (n == (uchar *)0x0) break;
    if (pdVar1->base_type == base_type) {
      if ((int)end < (int)n) {
        n = end;
      }
      iVar2 = c_strncasecmp((char *)s1,(char *)ident,(size_t)n);
      if ((iVar2 == 0) && (end == (uchar *)(pdVar1->name).length)) {
        return pdVar1->type;
      }
    }
    s1 = pdVar1[1].name.string;
    pdVar1 = pdVar1 + 1;
  }
  return base_type;
}



dom_scanner_token * __regparm3 get_next_dom_scanner_token(dom_scanner *scanner)

{
  dom_scanner_token *pdVar1;
  dom_scanner_token *pdVar2;
  dom_scanner_token *pdVar3;
  
  if (0 < scanner->tokens) {
    pdVar2 = scanner->current;
    pdVar3 = scanner->table + scanner->tokens;
    if (pdVar2 < pdVar3) {
      pdVar1 = pdVar2 + 1;
      scanner->current = pdVar1;
      if (pdVar3 <= pdVar2 + 2) {
        pdVar3 = (*scanner->info->scan)(scanner);
        return pdVar3;
      }
      if (pdVar1 < pdVar3) {
        return pdVar1;
      }
    }
  }
  return (dom_scanner_token *)0x0;
}



dom_code dom_select_pop_element(dom_stack *stack,dom_node *node,void *data)

{
  dom_stack *stack_00;
  dom_stack_context *pdVar1;
  size_t sVar2;
  int iVar3;
  dom_stack_state *target;
  dom_node **ppdVar4;
  bool bVar5;
  int local_30;
  
  stack_00 = (dom_stack *)stack->current->data;
  local_30 = stack_00->depth - 1;
  if (-1 < local_30) {
    iVar3 = stack_00->depth * 0xc;
    do {
      target = (dom_stack_state *)((int)&stack_00->states[-1].node + iVar3);
      if (target != (dom_stack_state *)0x0) {
        pdVar1 = *stack_00->contexts;
        sVar2 = pdVar1->info->object_size;
        ppdVar4 = (dom_node **)0x0;
        if (sVar2 != 0) {
          if ((assert_failed == 0) &&
             (bVar5 = pdVar1->state_objects == (uchar *)0x0, assert_failed = ZEXT14(bVar5), bVar5))
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
            errline = 0xc6;
            elinks_internal((uchar *)"assertion context->state_objects failed!");
          }
          ppdVar4 = (dom_node **)(pdVar1->state_objects + target->depth * sVar2);
        }
        if (*ppdVar4 == node) {
          pop_dom_state(stack_00,target);
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
          errline = 0x3b2;
          elinks_wdebug((uchar *)"Remove element.");
        }
      }
      local_30 = local_30 + -1;
      iVar3 = iVar3 + -0xc;
    } while (-1 < local_30);
  }
  return DOM_CODE_OK;
}



void done_dom_select(dom_select *select)

{
  if (select->selector != (dom_select_node *)0x0) {
    done_dom_node((dom_node *)select->selector);
  }
  mem_free(select);
  return;
}



dom_code dom_select_push_text(dom_stack *stack,dom_node *node,void *data)

{
  int *piVar1;
  uint *puVar2;
  uint uVar3;
  
  piVar1 = (int *)stack->current->data;
  if (assert_failed == 0) {
    assert_failed = 0;
  }
  puVar2 = *(uint **)(*(int *)(*piVar1 + (piVar1[1] * 3 + -3) * 4) + 0x10);
  if ((puVar2 != (uint *)0x0) && (*puVar2 != 0)) {
    uVar3 = 0;
    do {
      if (((short *)puVar2[uVar3 + 1] != (short *)0x0) && (*(short *)puVar2[uVar3 + 1] == 3)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
        errline = 0x3c6;
        elinks_wdebug((uchar *)"Text node: %d chars",(node->string).length);
        if ((ushort)(node->type - 3) < 3) {
          return DOM_CODE_OK;
        }
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
        errline = 0x3d3;
        elinks_error((uchar *)"Unhandled type");
        return DOM_CODE_OK;
      }
      uVar3 = uVar3 + 1;
    } while (uVar3 < *puVar2);
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
  errline = 0x3c6;
  elinks_wdebug((uchar *)"Text node: %d chars",(node->string).length);
  return DOM_CODE_OK;
}



dom_node_list * select_dom_nodes(dom_select *select,dom_node *root)

{
  byte *pbVar1;
  uint uVar2;
  dom_code dVar3;
  dom_select_data select_data;
  dom_stack stack;
  
  uVar2 = 0;
  do {
    *(undefined4 *)((int)&select_data.stack.states + uVar2) = 0;
    uVar2 = uVar2 + 4;
  } while (uVar2 < 0x20);
  select_data.select = select;
  init_dom_stack(&stack,DOM_STACK_FLAG_NONE);
  add_dom_stack_context(&stack,&select_data,&dom_select_context_info);
  init_dom_stack((dom_stack *)&select_data,DOM_STACK_FLAG_NONE);
  add_dom_stack_context((dom_stack *)&select_data,&select_data,&dom_select_data_context_info);
  dVar3 = push_dom_node((dom_stack *)&select_data,(dom_node *)select->selector);
  if (dVar3 == DOM_CODE_OK) {
    pbVar1 = (byte *)(&(select_data.stack.states)->field_0x8 +
                     (select_data.stack.depth * 3 + -3) * 4);
    *pbVar1 = *pbVar1 | 1;
    walk_dom_nodes(&stack,root);
  }
  done_dom_stack((dom_stack *)&select_data);
  done_dom_stack(&stack);
  return select_data.list;
}



dom_code dom_select_push_element(dom_stack *stack,dom_node *node,void *data)

{
  byte bVar1;
  dom_stack *stack_00;
  dom_node *node1;
  uint *puVar2;
  dom_node_list *list;
  uint uVar3;
  char *__s;
  dom_stack_context *pdVar4;
  int iVar5;
  ushort uVar6;
  size_t sVar7;
  uint uVar8;
  ushort *puVar9;
  ushort **ppuVar10;
  int iVar11;
  dom_node *node_00;
  dom_node **ppdVar12;
  int iVar13;
  uint n;
  dom_node **ppdVar14;
  uint uVar15;
  byte *__s_00;
  bool bVar16;
  int local_30;
  uint local_2c;
  uint local_28;
  uint local_24;
  
  stack_00 = (dom_stack *)stack->current->data;
  if (stack_00->depth != 0) {
    local_24 = 0;
LAB_080a3722:
    do {
      if (stack_00->states + local_24 == (dom_stack_state *)0x0) {
LAB_080a3710:
        sVar7 = stack_00->depth;
      }
      else {
        node1 = stack_00->states[local_24].node;
        if (assert_failed == 0) {
          if ((node == (dom_node *)0x0) || (node->type != 1)) {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
            errline = 0x357;
            elinks_internal((uchar *)"assertion node && node->type == DOM_NODE_ELEMENT failed!");
          }
          else {
            assert_failed = 0;
          }
        }
        uVar15 = *(uint *)node1[1].data;
        if ((uVar15 & 8) == 0) {
          iVar11 = dom_node_casecmp(node1,node);
          if (iVar11 == 0) {
            uVar15 = *(uint *)node1[1].data;
            local_2c = uVar15 & 7;
            if (local_2c != 0) goto LAB_080a3ac8;
            goto LAB_080a3799;
          }
          goto LAB_080a3710;
        }
        local_2c = uVar15 & 7;
        if (local_2c == 0) {
LAB_080a3799:
          if (((((uVar15 & 0x10) == 0) || (node_00 = node->parent, node_00 == (dom_node *)0x0)) ||
              ((node_00->type == 9 && (**(uint **)(node_00->data + 4) < 2)))) &&
             (((((uVar15 & 0x20) == 0 || (*(int **)node->data == (int *)0x0)) ||
               (**(int **)node->data == 0)) && ((uVar15 & 0xc0) == 0)))) {
            puVar2 = *(uint **)(node1->data + 4);
            if (puVar2 != (uint *)0x0) {
              list = *(dom_node_list **)(node->data + 4);
              if (assert_failed == 0) {
                if ((node1->type == 1) && (node->type == 1)) {
                  assert_failed = 0;
                }
                else {
                  assert_failed = 1;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
                  errline = 0x2d8;
                  elinks_internal((uchar *)
                                  "assertion base->node.type == DOM_NODE_ELEMENT && node->type == DOM_NODE_ELEMENT failed!"
                                 );
                }
              }
              if (list == (dom_node_list *)0x0) goto LAB_080a3710;
              if (*puVar2 != 0) {
                uVar15 = 0;
                do {
                  while (uVar3 = puVar2[uVar15 + 1], uVar3 == 0) {
LAB_080a38f0:
                    uVar15 = uVar15 + 1;
                    if (*puVar2 <= uVar15) goto LAB_080a3904;
                  }
                  if (*(char *)(uVar3 + 0x30) < '\0') {
                    n = list->size;
                    if (n == 0) goto LAB_080a3710;
                    uVar8 = 0;
                    while ((node_00 = list->entries[uVar8], node_00 == (dom_node *)0x0 ||
                           ((node_00->data[0xd] & 4) == 0))) {
                      uVar8 = uVar8 + 1;
                      if (n <= uVar8) goto LAB_080a3710;
                    }
                    if (n <= uVar8) goto LAB_080a3710;
                  }
                  else {
                    node_00 = get_dom_node_map_entry
                                        (list,DOM_NODE_ATTRIBUTE,*(uint16_t *)(uVar3 + 0x1a),
                                         (dom_string *)(uVar3 + 4));
                    if (node_00 == (dom_node *)0x0) goto LAB_080a3710;
                  }
                  if ((*(byte *)(uVar3 + 0x30) & 1) != 0) goto LAB_080a38f0;
                  if ((assert_failed == 0) &&
                     (bVar16 = *(int *)(uVar3 + 0x10) == 0, assert_failed = ZEXT14(bVar16), bVar16))
                  {
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
                    errline = 0x26f;
                    elinks_internal((uchar *)"assertion selvalue->length failed!");
                  }
                  local_28 = *(uint *)node_00->data;
                  n = *(uint *)(uVar3 + 0x10);
                  if (local_28 < n) goto LAB_080a3710;
                  uVar8 = *(uint *)(uVar3 + 0x30);
                  if ((uVar8 & 2) == 0) {
                    if ((uVar8 & 0x10) == 0) {
                      if ((uVar8 & 0x20) == 0) {
                        __s_00 = *(byte **)(node_00->data + 4);
                        if (local_28 == 0xffffffff) {
                          local_28 = strlen((char *)__s_00);
                        }
                        if ((uVar8 & 4) != 0) {
                          uVar6 = 1;
                          do {
                            if ((uVar6 == 0) ||
                               (iVar11 = c_strncasecmp((char *)__s_00,*(char **)(uVar3 + 0x14),n),
                               iVar11 != 0)) {
                              ppuVar10 = __ctype_b_loc();
                              n = *(uint *)(uVar3 + 0x10);
                              puVar9 = *ppuVar10;
                            }
                            else {
                              n = *(uint *)(uVar3 + 0x10);
                              if (n == local_28) goto LAB_080a38f0;
                              ppuVar10 = __ctype_b_loc();
                              puVar9 = *ppuVar10;
                              if ((*(byte *)((int)puVar9 + (uint)__s_00[local_28] * 2 + 1) & 0x20)
                                  != 0) goto LAB_080a38f0;
                            }
                            bVar1 = *__s_00;
                            local_28 = local_28 - 1;
                            __s_00 = __s_00 + 1;
                            if (local_28 < n) goto LAB_080a3710;
                            uVar6 = puVar9[bVar1] & 0x2000;
                          } while( true );
                        }
                        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
                        errline = 0x29c;
                        elinks_internal((uchar *)"No attribute selector matching method defined");
                        goto LAB_080a3710;
                      }
                      __s = (char *)((local_28 - n) + *(int *)(node_00->data + 4));
                    }
                    else {
                      __s = *(char **)(node_00->data + 4);
                    }
                    uVar8 = n;
                    if (n == 0xffffffff) {
                      uVar8 = strlen(__s);
                    }
                    if ((int)uVar8 <= (int)n) {
                      n = uVar8;
                    }
                    iVar11 = c_strncasecmp(__s,*(char **)(uVar3 + 0x14),n);
                    if (iVar11 == 0) {
                      iVar11 = uVar8 - *(int *)(uVar3 + 0x10);
                    }
LAB_080a3a38:
                    if (iVar11 != 0) goto LAB_080a3710;
                  }
                  else {
                    if ((int)local_28 <= (int)n) {
                      n = local_28;
                    }
                    iVar11 = c_strncasecmp(*(char **)(node_00->data + 4),*(char **)(uVar3 + 0x14),n)
                    ;
                    if (iVar11 != 0) goto LAB_080a3a38;
                    if (*(int *)node_00->data != *(int *)(uVar3 + 0x10)) goto LAB_080a3710;
                  }
                  uVar15 = uVar15 + 1;
                } while (uVar15 < *puVar2);
              }
            }
LAB_080a3904:
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
            errline = 0x396;
            elinks_wdebug((uchar *)"Matched element: %.*s.",(node->string).length,
                          (node->string).string);
            puVar2 = *(uint **)node1->data;
            if (puVar2 != (uint *)0x0) {
              uVar15 = 0;
              if (*puVar2 != 0) {
                do {
                  node1 = (dom_node *)puVar2[uVar15 + 1];
                  if ((node1 != (dom_node *)0x0) && (node1->type == 1)) {
                    push_dom_node(stack_00,node1);
                    local_24 = local_24 + 1;
                    if (stack_00->depth <= local_24) {
                      return DOM_CODE_OK;
                    }
                    goto LAB_080a3722;
                  }
                  uVar15 = uVar15 + 1;
                } while (uVar15 < *puVar2);
              }
            }
          }
          goto LAB_080a3710;
        }
LAB_080a3ac8:
        if (assert_failed == 0) {
          assert_failed = 0;
        }
        if (node->parent == (dom_node *)0x0) goto LAB_080a3710;
        if (local_2c == 1) {
          local_30 = -1;
        }
        else {
          local_30 = get_dom_node_list_index(node->parent,node);
          if (local_30 < 1) goto LAB_080a3710;
        }
        sVar7 = stack_00->depth;
        iVar11 = sVar7 - 1;
        if (-1 < iVar11) {
          iVar5 = sVar7 * 0xc;
          do {
            ppdVar12 = (dom_node **)((int)&stack_00->states[-1].node + iVar5);
            if ((ppdVar12 != (dom_node **)0x0) && (*ppdVar12 == node1->parent)) {
              pdVar4 = *stack_00->contexts;
              sVar7 = pdVar4->info->object_size;
              ppdVar14 = (dom_node **)0x0;
              if (sVar7 != 0) {
                if ((assert_failed == 0) &&
                   (bVar16 = pdVar4->state_objects == (uchar *)0x0, assert_failed = ZEXT14(bVar16),
                   bVar16)) {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
                  errline = 0xc6;
                  elinks_internal((uchar *)"assertion context->state_objects failed!");
                }
                ppdVar14 = (dom_node **)(pdVar4->state_objects + sVar7 * (int)ppdVar12[1]);
              }
              node_00 = *ppdVar14;
              if (local_2c == 1) {
                if (node_00 == node->parent) goto LAB_080a3bdb;
              }
              else {
                if (node_00->parent == node->parent) {
                  iVar13 = get_dom_node_list_index(node_00->parent,node_00);
                  if (local_2c == 2) {
                    if (iVar13 + 1 == local_30) goto LAB_080a3bdb;
                  }
                  else {
                    if (iVar13 < local_30) {
LAB_080a3bdb:
                      uVar15 = *(uint *)node1[1].data;
                      goto LAB_080a3799;
                    }
                  }
                }
              }
            }
            iVar11 = iVar11 + -1;
            iVar5 = iVar5 + -0xc;
          } while (-1 < iVar11);
          goto LAB_080a3710;
        }
      }
      local_24 = local_24 + 1;
    } while (local_24 < sVar7);
  }
  return DOM_CODE_OK;
}



dom_code __regparm3 parse_dom_select_nth_arg(dom_select_nth_match *nth,dom_scanner *scanner)

{
  byte bVar1;
  dom_scanner_token *pdVar2;
  dom_scanner_token *pdVar3;
  dom_scanner_token *pdVar4;
  byte *pbVar5;
  int iVar6;
  uint uVar7;
  uint uVar8;
  int iVar9;
  
  if (scanner->tokens < 1) {
    return DOM_CODE_SYNTAX_ERR;
  }
  pdVar2 = scanner->current;
  pdVar4 = scanner->table + scanner->tokens;
  if (pdVar4 <= pdVar2) {
    return DOM_CODE_SYNTAX_ERR;
  }
  pdVar3 = pdVar2 + 1;
  scanner->current = pdVar3;
  if (pdVar2 + 2 < pdVar4) {
    if (pdVar4 <= pdVar3) {
      return DOM_CODE_SYNTAX_ERR;
    }
  }
  else {
    pdVar3 = (*scanner->info->scan)(scanner);
  }
  if (pdVar3 == (dom_scanner_token *)0x0) {
    return DOM_CODE_SYNTAX_ERR;
  }
  if (pdVar3->type != 0x28) {
    return DOM_CODE_SYNTAX_ERR;
  }
  if (scanner->tokens < 1) {
    return DOM_CODE_SYNTAX_ERR;
  }
  pdVar2 = scanner->current;
  pdVar4 = scanner->table + scanner->tokens;
  if (pdVar4 <= pdVar2) {
    return DOM_CODE_SYNTAX_ERR;
  }
  pdVar3 = pdVar2 + 1;
  scanner->current = pdVar3;
  if (pdVar2 + 2 < pdVar4) {
    if (pdVar4 <= pdVar3) {
      return DOM_CODE_SYNTAX_ERR;
    }
  }
  else {
    pdVar3 = (*scanner->info->scan)(scanner);
  }
  if (pdVar3 == (dom_scanner_token *)0x0) {
    return DOM_CODE_SYNTAX_ERR;
  }
  iVar6 = pdVar3->type;
  if (iVar6 == 0x100) {
    uVar8 = (pdVar3->string).length;
    if (uVar8 == 4) {
      iVar6 = c_strncasecmp((char *)(pdVar3->string).string,"even",4);
      if (iVar6 == 0) {
        nth->step = 2;
        nth->index = 0;
        goto LAB_080a3eb0;
      }
      uVar8 = (pdVar3->string).length;
    }
    if ((uVar8 == 3) && (iVar6 = c_strncasecmp((char *)(pdVar3->string).string,"odd",3), iVar6 == 0)
       ) {
      nth->step = 2;
      nth->index = 1;
      goto LAB_080a3eb0;
    }
    iVar6 = pdVar3->type;
    uVar8 = 0xffffffff;
    iVar9 = 1;
  }
  else {
    if (iVar6 == 0x101) {
      if ((pdVar3->string).length == 0) {
LAB_080a3fd0:
        uVar8 = 0;
      }
      else {
        pbVar5 = (pdVar3->string).string;
        uVar7 = 0;
        bVar1 = *pbVar5;
        if (9 < (byte)(bVar1 - 0x30)) goto LAB_080a3fd0;
        while( true ) {
          pbVar5 = pbVar5 + 1;
          (pdVar3->string).string = pbVar5;
          uVar8 = (uVar7 - 0x30) + (uint)bVar1;
          uVar7 = (pdVar3->string).length - 1;
          (pdVar3->string).length = uVar7;
          if ((uVar7 == 0) || (bVar1 = *pbVar5, 9 < (byte)(bVar1 - 0x30))) break;
          uVar7 = uVar8 * 10;
          if (uVar7 < uVar8) {
            return DOM_CODE_VALUE_ERR;
          }
        }
        if ((int)uVar8 < 0) {
          return DOM_CODE_VALUE_ERR;
        }
      }
      pdVar3 = get_next_dom_scanner_token(scanner);
      if (pdVar3 == (dom_scanner_token *)0x0) {
        return DOM_CODE_SYNTAX_ERR;
      }
      iVar6 = pdVar3->type;
      iVar9 = 1;
    }
    else {
      if (iVar6 != 0x2d) {
        return DOM_CODE_SYNTAX_ERR;
      }
      pdVar3 = get_next_dom_scanner_token(scanner);
      if (pdVar3 == (dom_scanner_token *)0x0) {
        return DOM_CODE_SYNTAX_ERR;
      }
      iVar6 = pdVar3->type;
      uVar8 = 0xffffffff;
      iVar9 = -1;
      if (iVar6 == 0x100) {
        return DOM_CODE_SYNTAX_ERR;
      }
    }
  }
  if (iVar6 == 0x100) {
    if ((pdVar3->string).length != 1) {
      return DOM_CODE_SYNTAX_ERR;
    }
    iVar6 = c_strncasecmp((char *)(pdVar3->string).string,"n",1);
    if (iVar6 != 0) {
      return DOM_CODE_SYNTAX_ERR;
    }
    nth->step = uVar8 * iVar9;
    pdVar4 = get_next_dom_scanner_token(scanner);
    if (pdVar4 == (dom_scanner_token *)0x0) {
      return DOM_CODE_SYNTAX_ERR;
    }
    if (pdVar4->type == 0x2b) {
      pdVar4 = get_next_dom_scanner_token(scanner);
      if (pdVar4 == (dom_scanner_token *)0x0) {
        return DOM_CODE_SYNTAX_ERR;
      }
      if (pdVar4->type == 0x101) {
        uVar8 = (pdVar4->string).length;
        uVar7 = 0;
        while (uVar8 != 0) {
          pbVar5 = (pdVar4->string).string;
          bVar1 = *pbVar5;
          if (9 < (byte)(bVar1 - 0x30)) break;
          if (uVar7 * 10 < uVar7) {
            return DOM_CODE_VALUE_ERR;
          }
          uVar7 = (uVar7 * 10 - 0x30) + (uint)bVar1;
          (pdVar4->string).string = pbVar5 + 1;
          uVar8 = uVar8 - 1;
          (pdVar4->string).length = uVar8;
        }
        if ((int)uVar7 < 0) {
          return DOM_CODE_VALUE_ERR;
        }
        nth->index = uVar7 * iVar9;
      }
    }
  }
  else {
    nth->step = 0;
    nth->index = uVar8 * iVar9;
  }
LAB_080a3eb0:
  pdVar4 = skip_dom_scanner_tokens(scanner,0x29,0x80);
  if (pdVar4 == (dom_scanner_token *)0x0) {
    return DOM_CODE_SYNTAX_ERR;
  }
  return DOM_CODE_OK;
}



// WARNING: Could not reconcile some variable overlaps

dom_code __regparm3 parse_dom_select(dom_select *select,dom_stack *stack,dom_string *string)

{
  uchar **ppuVar1;
  uint16_t uVar2;
  ushort uVar3;
  dom_select_pseudo dVar4;
  dom_node *pdVar5;
  dom_code dVar6;
  size_t n;
  int iVar7;
  dom_node_list *list;
  dom_scanner_token *pdVar8;
  size_t sVar9;
  uint uVar10;
  int position;
  dom_node_list **list_ptr;
  dom_stack_state *pdVar11;
  dom_scanner_token *pdVar12;
  dom_select_node *node;
  anon_struct *paVar13;
  bool bVar14;
  byte bVar15;
  dom_scanner scanner;
  dom_select_node sel;
  
  bVar15 = 0;
  init_dom_scanner(&scanner,&dom_css_scanner_info,string,0,0,1,0,0);
  position = 0xd;
  node = &sel;
  while (position != 0) {
    position = position + -1;
    *(undefined4 *)&node->node = 0;
    node = (dom_select_node *)((int)node + (uint)bVar15 * -8 + 4);
  }
  while ((0 < scanner.tokens && (scanner.current < scanner.table + scanner.tokens))) {
    pdVar12 = scanner.current;
    if (scanner.table + scanner.tokens <= scanner.current) {
      pdVar12 = (dom_scanner_token *)0x0;
    }
    if ((assert_failed == 0) &&
       (assert_failed = ZEXT14(pdVar12 == (dom_scanner_token *)0x0),
       pdVar12 == (dom_scanner_token *)0x0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
      errline = 0x193;
      elinks_internal((uchar *)"assertion token failed!");
    }
    position = pdVar12->type;
    if ((((position == 0x7d) || (position == 0x7b)) || (position == 0x3b)) || (position == 0x2c))
    break;
    if (position == 0x5b) {
      sel.node._0_4_ = CONCAT22(sel.node._2_2_,2);
      position = iRam00000000;
      if ((0 < scanner.tokens) && (scanner.current < scanner.table + scanner.tokens)) {
        position = (scanner.current)->type;
      }
      if (position != 0x5b) {
        return DOM_CODE_SYNTAX_ERR;
      }
      if (scanner.tokens < 1) {
        return DOM_CODE_SYNTAX_ERR;
      }
      pdVar12 = scanner.table + scanner.tokens;
      if (pdVar12 <= scanner.current) {
        return DOM_CODE_SYNTAX_ERR;
      }
      pdVar8 = scanner.current + 1;
      if (scanner.current + 2 < pdVar12) {
        scanner.current = pdVar8;
        if (pdVar12 <= pdVar8) {
          return DOM_CODE_SYNTAX_ERR;
        }
      }
      else {
        scanner.current = pdVar8;
        pdVar8 = (*(scanner.info)->scan)(&scanner);
      }
      if (pdVar8 == (dom_scanner_token *)0x0) {
        return DOM_CODE_SYNTAX_ERR;
      }
      if (pdVar8->type != 0x100) {
        return DOM_CODE_SYNTAX_ERR;
      }
      sVar9 = (pdVar8->string).length;
      sel.node.string.string = (pdVar8->string).string;
      if (sVar9 == 0xffffffff) {
        sVar9 = strlen((char *)sel.node.string.string);
      }
      sel.node.string.length = sVar9;
      pdVar12 = get_next_dom_scanner_token(&scanner);
      if (pdVar12 == (dom_scanner_token *)0x0) {
        return DOM_CODE_SYNTAX_ERR;
      }
      position = pdVar12->type;
      if (position == 0x118) {
        sel.match = sel.match | 8;
      }
      else {
        if (position < 0x119) {
          if (position == 0x5d) {
            sel.match = sel.match | 1;
            uVar10 = sel.node.data._0_4_;
            goto LAB_080a4348;
          }
          if (position != 0x117) {
            return DOM_CODE_SYNTAX_ERR;
          }
          sel.match = sel.match | 4;
        }
        else {
          if (position == 0x11a) {
            sel.match = sel.match | 0x20;
          }
          else {
            if (position < 0x11a) {
              sel.match = sel.match | 0x10;
            }
            else {
              if (position != 0x11b) {
                return DOM_CODE_SYNTAX_ERR;
              }
              sel.match = sel.match | 0x40;
            }
          }
        }
      }
      pdVar12 = get_next_dom_scanner_token(&scanner);
      if ((pdVar12 == (dom_scanner_token *)0x0) ||
         ((pdVar12->type != 0x100 && (pdVar12->type != 0x103)))) {
        return DOM_CODE_SYNTAX_ERR;
      }
      uVar10 = (pdVar12->string).length;
      sel.node.data._4_4_ = (pdVar12->string).string;
      if (uVar10 == 0xffffffff) {
        uVar10 = strlen((char *)sel.node.data._4_4_);
      }
      sel.node.data._0_4_ = uVar10;
      pdVar12 = get_next_dom_scanner_token(&scanner);
      if (pdVar12 == (dom_scanner_token *)0x0) {
        return DOM_CODE_SYNTAX_ERR;
      }
      uVar10 = sel.node.data._0_4_;
      if (pdVar12->type != 0x5d) {
        return DOM_CODE_SYNTAX_ERR;
      }
    }
    else {
      uVar10 = sel.node.data._0_4_;
      if (position < 0x5c) {
        if (position == 0x2e) {
          if (scanner.tokens < 1) {
            return DOM_CODE_SYNTAX_ERR;
          }
          if (scanner.table + scanner.tokens <= scanner.current) {
            return DOM_CODE_SYNTAX_ERR;
          }
          pdVar12 = scanner.current + 1;
          if (scanner.current + 2 < scanner.table + scanner.tokens) {
            if (scanner.tokens < 1) {
              return DOM_CODE_SYNTAX_ERR;
            }
            scanner.current = pdVar12;
            if (scanner.table + scanner.tokens <= pdVar12) {
              return DOM_CODE_SYNTAX_ERR;
            }
          }
          else {
            scanner.current = pdVar12;
            pdVar12 = (*(scanner.info)->scan)(&scanner);
          }
          if (pdVar12 == (dom_scanner_token *)0x0) {
            return DOM_CODE_SYNTAX_ERR;
          }
          if (pdVar12->type != 0x100) {
            return DOM_CODE_SYNTAX_ERR;
          }
          sel.match = sel.match | 4;
          sel.node._0_4_ = CONCAT22(sel.node._2_2_,2);
          sel.node.string.string = "class";
          sel.node.string.length = 5;
          uVar10 = (pdVar12->string).length;
          sel.node.data._4_4_ = (pdVar12->string).string;
          if (uVar10 == 0xffffffff) {
            uVar10 = strlen((char *)sel.node.data._4_4_);
          }
        }
        else {
          if (position < 0x2f) {
            if (position != 0x2b) {
              return DOM_CODE_SYNTAX_ERR;
            }
            if ((sel.match & 7) != 0) {
              return DOM_CODE_SYNTAX_ERR;
            }
            sel.match = sel.match | 2;
          }
          else {
            if (position == 0x3a) {
              do {
                if (scanner.tokens < 1) {
                  return DOM_CODE_SYNTAX_ERR;
                }
                pdVar12 = scanner.table + scanner.tokens;
                if (pdVar12 <= scanner.current) {
                  return DOM_CODE_SYNTAX_ERR;
                }
                pdVar8 = scanner.current + 1;
                if (scanner.current + 2 < pdVar12) {
                  scanner.current = pdVar8;
                  if (pdVar12 <= pdVar8) {
                    return DOM_CODE_SYNTAX_ERR;
                  }
                }
                else {
                  scanner.current = pdVar8;
                  pdVar8 = (*(scanner.info)->scan)(&scanner);
                }
                if (pdVar8 == (dom_scanner_token *)0x0) {
                  return DOM_CODE_SYNTAX_ERR;
                }
              } while (pdVar8->type == 0x3a);
              if (pdVar8->type != 0x100) {
                return DOM_CODE_SYNTAX_ERR;
              }
              position = 0;
              paVar13 = pseudo_info;
              while( true ) {
                n = (paVar13->string).length;
                if ((int)(pdVar8->string).length < (int)n) {
                  n = (pdVar8->string).length;
                }
                iVar7 = c_strncasecmp((char *)(paVar13->string).string,
                                      (char *)(pdVar8->string).string,n);
                if ((iVar7 == 0) && ((paVar13->string).length == (pdVar8->string).length)) break;
                position = position + 1;
                paVar13 = paVar13 + 1;
                if (position == 0x1c) {
                  return DOM_CODE_ERR;
                }
              }
              dVar4 = pseudo_info[position].pseudo;
              uVar10 = sel.node.data._0_4_;
              if (dVar4 == DOM_SELECT_PSEUDO_ONLY_CHILD) {
                sel.match = sel.match | 0x40;
                sel.nth_child.step = 0;
                sel.nth_child.index = 0;
              }
              else {
                if (dVar4 < DOM_SELECT_PSEUDO_NTH_TYPE) {
                  if (dVar4 < DOM_SELECT_PSEUDO_FIRST_CHILD) {
                    if (dVar4 < DOM_SELECT_PSEUDO_NTH_CHILD) {
                      if (dVar4 == DOM_SELECT_PSEUDO_UNKNOWN) {
                        return DOM_CODE_ERR;
                      }
                      if (dVar4 != DOM_SELECT_PSEUDO_CONTAINS) {
LAB_080a4799:
                        select->pseudo = select->pseudo | dVar4;
                      }
                    }
                    else {
                      dVar6 = parse_dom_select_nth_arg(&sel.nth_child,&scanner);
                      if (dVar6 != DOM_CODE_OK) {
                        return dVar6;
                      }
                      sel.match = sel.match | 0x40;
                      uVar10 = sel.node.data._0_4_;
                    }
                  }
                  else {
                    if (dVar4 == DOM_SELECT_PSEUDO_FIRST_CHILD) {
                      sel.match = sel.match | 0x40;
                      sel.nth_child.step = 0;
                      sel.nth_child.index = 1;
                    }
                    else {
                      if (dVar4 != DOM_SELECT_PSEUDO_LAST_CHILD) goto LAB_080a4799;
                      sel.match = sel.match | 0x40;
                      sel.nth_child.step = 0;
                      sel.nth_child.index = 0xffffffff;
                    }
                  }
                }
                else {
                  if (dVar4 == DOM_SELECT_PSEUDO_LAST_TYPE) {
                    sel.match = sel.match | 0x80;
                    sel.nth_type.step = 0;
                    sel.nth_type.index = 0xffffffff;
                  }
                  else {
                    if (dVar4 < DOM_SELECT_PSEUDO_ONLY_TYPE) {
                      if (dVar4 < DOM_SELECT_PSEUDO_FIRST_TYPE) {
                        dVar6 = parse_dom_select_nth_arg(&sel.nth_type,&scanner);
                        if (dVar6 != DOM_CODE_OK) {
                          return dVar6;
                        }
                        sel.match = sel.match | 0x80;
                        uVar10 = sel.node.data._0_4_;
                      }
                      else {
                        sel.match = sel.match | 0x80;
                        sel.nth_type.step = 0;
                        sel.nth_type.index = 1;
                      }
                    }
                    else {
                      if (dVar4 == DOM_SELECT_PSEUDO_ROOT) {
                        sel.match = sel.match | 0x10;
                      }
                      else {
                        if (dVar4 < DOM_SELECT_PSEUDO_ROOT) {
                          sel.match = sel.match | 0x80;
                          sel.nth_type.step = 0;
                          sel.nth_type.index = 0;
                        }
                        else {
                          if (dVar4 != DOM_SELECT_PSEUDO_EMPTY) goto LAB_080a4799;
                          sel.match = sel.match | 0x20;
                        }
                      }
                    }
                  }
                }
              }
            }
            else {
              if (position != 0x3e) {
                return DOM_CODE_SYNTAX_ERR;
              }
              if ((sel.match & 7) != 0) {
                return DOM_CODE_SYNTAX_ERR;
              }
              sel.match = sel.match | 1;
            }
          }
        }
      }
      else {
        if (position == 0x100) {
          sel.node._0_4_ = CONCAT22(sel.node._2_2_,1);
          sVar9 = (pdVar12->string).length;
          sel.node.string.string = (pdVar12->string).string;
          if (sVar9 == 0xffffffff) {
            sVar9 = strlen((char *)sel.node.string.string);
          }
          sel.node.string.length = sVar9;
          uVar10 = sel.node.data._0_4_;
          if (((pdVar12->string).length == 1) &&
             (position = c_strncasecmp((char *)(pdVar12->string).string,"*",1),
             uVar10 = sel.node.data._0_4_, position == 0)) {
            sel.match = sel.match | 8;
          }
        }
        else {
          if (position < 0x101) {
            if (position != 0x7e) {
              return DOM_CODE_SYNTAX_ERR;
            }
            if ((sel.match & 7) != 0) {
              return DOM_CODE_SYNTAX_ERR;
            }
            sel.match = sel.match | 4;
          }
          else {
            if (1 < position - 0x10bU) {
              return DOM_CODE_SYNTAX_ERR;
            }
            sel.match = sel.match | 0x80;
            sel.node._0_4_ = CONCAT22(sel.node._2_2_,2);
            ppuVar1 = &(pdVar12->string).string;
            *ppuVar1 = *ppuVar1 + 1;
            (pdVar12->string).length = (pdVar12->string).length - 1;
          }
        }
      }
    }
LAB_080a4348:
    sel.node.data._0_4_ = uVar10;
    if (((0 < scanner.tokens) && (scanner.current < scanner.table + scanner.tokens)) &&
       (pdVar12 = scanner.current + 1, pdVar8 = scanner.current + 2, scanner.current = pdVar12,
       scanner.table + scanner.tokens <= pdVar8)) {
      (*(scanner.info)->scan)(&scanner);
    }
    if (sel.node.type != 0) {
      node = (dom_select_node *)mem_calloc(1,0x34);
      *(undefined4 *)&node->node = sel.node._0_4_;
      ((dom_string *)&node->node)->length = sel.node.string.length;
      ((dom_string *)&node->node)->string = sel.node.string.string;
      *(dom_node **)&node->node = sel.node.parent;
      *(uint *)&node->node = sel.node.data._0_4_;
      *(uchar **)((byte *)&node->node + 4) = sel.node.data._4_4_;
      *(undefined4 *)((byte *)&node->node + 8) = sel.node.data._8_4_;
      *(undefined4 *)((byte *)&node->node + 0xc) = sel.node.data._12_4_;
      (node->nth_child).step = sel.nth_child.step;
      (node->nth_child).index = sel.nth_child.index;
      (&(node->nth_child).index)[1] = sel.nth_type.step;
      (node->nth_type).index = sel.nth_type.index;
      node->match = sel.match;
      position = assert_failed;
      pdVar11 = stack->states;
      if ((pdVar11 == (dom_stack_state *)0x0) || (n = stack->depth, n == 0)) {
        if ((assert_failed == 0) &&
           (bVar14 = select->selector != (dom_select_node *)0x0, assert_failed = ZEXT14(bVar14),
           bVar14)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
          errline = 0x1f9;
          elinks_internal((uchar *)"assertion !select->selector failed!");
        }
        select->selector = node;
      }
      else {
        if (assert_failed == 0) {
          assert_failed = 0;
          pdVar11 = stack->states;
          n = stack->depth;
        }
        pdVar5 = (&pdVar11->node)[n * 3 + -3];
        uVar2 = (node->node).type;
        uVar3 = pdVar5->type;
        if (uVar3 == 7) {
          list_ptr = (dom_node_list **)(pdVar5->data + 0xc);
          if (uVar2 != 2) goto LAB_080a480a;
        }
        else {
          if (uVar3 < 8) {
            if (uVar3 == 1) {
              list_ptr = (dom_node_list **)pdVar5->data;
              if (uVar2 == 2) {
                list_ptr = (dom_node_list **)(pdVar5->data + 4);
              }
            }
            else {
LAB_080a480a:
              list_ptr = (dom_node_list **)0x0;
            }
          }
          else {
            if (uVar3 != 9) {
              if (uVar3 == 10) {
                list_ptr = (dom_node_list **)pdVar5->data;
                if (uVar2 == 6) goto LAB_080a480c;
                if (uVar2 == 0xc) goto LAB_080a492d;
              }
              goto LAB_080a480a;
            }
LAB_080a492d:
            list_ptr = (dom_node_list **)(pdVar5->data + 4);
          }
        }
LAB_080a480c:
        if ((position == 0) &&
           (assert_failed = ZEXT14(list_ptr == (dom_node_list **)0x0),
           list_ptr == (dom_node_list **)0x0)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
          errline = 0x1ec;
          elinks_internal((uchar *)
                          "assertion list != NULL failed: Adding node to bad parent [%d -> %d]",
                          (uint)(node->node).type,(uint)pdVar5->type);
        }
        list = *list_ptr;
        if (((list == (dom_node_list *)0x0) || (uVar2 != 2)) || (list->size == 0)) {
          position = -1;
        }
        else {
          position = get_dom_node_map_index(list,(dom_node *)node);
        }
        list = add_to_dom_node_list(list_ptr,(dom_node *)node,position);
        if (list == (dom_node_list *)0x0) {
          done_dom_node((dom_node *)node);
          return DOM_CODE_ALLOC_ERR;
        }
        *(dom_node **)&node->node = pdVar5;
      }
      dVar6 = push_dom_node(stack,(dom_node *)node);
      if (dVar6 != DOM_CODE_OK) {
        return dVar6;
      }
      if ((node->node).type != 1) {
        pop_dom_node(stack);
      }
      position = 0xd;
      node = &sel;
      while (position != 0) {
        position = position + -1;
        *(undefined4 *)&node->node = 0;
        node = (dom_select_node *)((int)node + (uint)bVar15 * -8 + 4);
      }
    }
  }
  return -(uint)(select->selector == (dom_select_node *)0x0) & 0xfffffc18;
}



dom_select * init_dom_select(dom_select_syntax syntax,dom_string *string)

{
  dom_select *select;
  dom_code dVar1;
  dom_select *pdVar2;
  dom_stack stack;
  
  select = (dom_select *)mem_calloc(1,4);
  init_dom_stack(&stack,DOM_STACK_FLAG_NONE);
  dVar1 = parse_dom_select(select,&stack,string);
  done_dom_stack(&stack);
  pdVar2 = select;
  if (dVar1 != DOM_CODE_OK) {
    pdVar2 = (dom_select *)0x0;
    done_dom_select(select);
  }
  return pdVar2;
}



dom_stack_state * search_dom_stack(dom_stack *stack,dom_node_type type,dom_string *string)

{
  dom_node *pdVar1;
  size_t sVar2;
  int iVar3;
  size_t n;
  int iVar4;
  dom_stack_state *pdVar5;
  int local_20;
  
  local_20 = stack->depth - 1;
  if (-1 < local_20) {
    iVar3 = stack->depth * 0xc;
    do {
      pdVar5 = (dom_stack_state *)((int)&stack->states[-1].node + iVar3);
      if ((pdVar5 != (dom_stack_state *)0x0) && (pdVar1 = pdVar5->node, (uint)pdVar1->type == type))
      {
        sVar2 = (pdVar1->string).length;
        n = string->length;
        if ((int)sVar2 <= (int)string->length) {
          n = sVar2;
        }
        iVar4 = c_strncasecmp((char *)(pdVar1->string).string,(char *)string->string,n);
        if ((iVar4 == 0) && ((pdVar1->string).length == string->length)) {
          return pdVar5;
        }
      }
      local_20 = local_20 + -1;
      iVar3 = iVar3 + -0xc;
    } while (-1 < local_20);
  }
  return (dom_stack_state *)0x0;
}



void init_dom_stack(dom_stack *stack,dom_stack_flag flags)

{
  uint uVar1;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(stack == (dom_stack *)0x0), stack == (dom_stack *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
    errline = 0x38;
    elinks_internal((uchar *)"assertion stack failed!");
  }
  uVar1 = 0;
  do {
    *(undefined4 *)((int)&stack->states + uVar1) = 0;
    uVar1 = uVar1 + 4;
  } while (uVar1 < 0x18);
  stack->flags = flags;
  return;
}



void done_dom_stack(dom_stack *stack)

{
  dom_stack_context *p;
  uint uVar1;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(stack == (dom_stack *)0x0), stack == (dom_stack *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
    errline = 0x44;
    elinks_internal((uchar *)"assertion stack failed!");
  }
  if (stack->contexts_size != 0) {
    uVar1 = 0;
    do {
      p = stack->contexts[uVar1];
      if (p->state_objects != (uchar *)0x0) {
        mem_free(p->state_objects);
        p = stack->contexts[uVar1];
      }
      uVar1 = uVar1 + 1;
      mem_free(p);
    } while (uVar1 <= stack->contexts_size && stack->contexts_size != uVar1);
  }
  if (stack->contexts != (dom_stack_context **)0x0) {
    mem_free(stack->contexts);
  }
  if (stack->states != (dom_stack_state *)0x0) {
    mem_free(stack->states);
  }
  uVar1 = 0;
  do {
    *(undefined4 *)((int)&stack->states + uVar1) = 0;
    uVar1 = uVar1 + 4;
  } while (uVar1 < 0x18);
  return;
}



void done_dom_stack_context(dom_stack *stack,dom_stack_context *context)

{
  uint uVar1;
  size_t sVar2;
  dom_stack_context *pdVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  dom_stack_context **ppdVar7;
  void *__dest;
  
  if (context->state_objects != (uchar *)0x0) {
    mem_free(context->state_objects);
  }
  mem_free(context);
  sVar2 = stack->contexts_size;
  uVar1 = sVar2 - 1;
  if (stack->contexts[uVar1] == context) {
    stack->contexts_size = uVar1;
    return;
  }
  ppdVar7 = stack->contexts + (sVar2 - 2);
  iVar4 = sVar2 * 4 + -8;
  uVar6 = uVar1;
  do {
    iVar5 = iVar4;
    pdVar3 = *ppdVar7;
    uVar6 = uVar6 - 1;
    ppdVar7 = ppdVar7 + -1;
    iVar4 = iVar5 + -4;
  } while (pdVar3 != context);
  stack->contexts_size = uVar1;
  if (uVar1 <= uVar6) {
    return;
  }
  __dest = (void *)(iVar5 + (int)stack->contexts);
  memmove(__dest,(void *)((int)__dest + 4),(uVar1 - uVar6) * 4);
  return;
}



int __regparm3
call_dom_stack_callbacks(dom_stack *stack,dom_stack_state *state,dom_stack_action action)

{
  size_t sVar1;
  dom_stack_context *pdVar2;
  int iVar3;
  dom_code dVar4;
  dom_stack_context_info *pdVar5;
  uchar *puVar6;
  dom_stack_callback_T *pdVar7;
  uint uVar8;
  bool bVar9;
  int local_20;
  
  local_20 = 0;
  if (stack->contexts_size != 0) {
    uVar8 = 0;
    do {
      pdVar2 = stack->contexts[uVar8];
      if (assert_failed != 0) {
        assert_failed = 0;
        return 0;
      }
      bVar9 = 0xc < state->node->type;
      assert_failed = ZEXT14(bVar9);
      if (bVar9) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
        errline = 0x8e;
        elinks_internal((uchar *)"assertion state->node->type < DOM_NODES failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return 0;
        }
      }
      if (action == DOM_STACK_PUSH) {
        pdVar5 = pdVar2->info;
        pdVar7 = pdVar5->push[state->node->type];
      }
      else {
        pdVar5 = pdVar2->info;
        pdVar7 = pdVar5->pop[state->node->type];
      }
      iVar3 = local_20;
      if (pdVar7 != (dom_stack_callback_T *)0x0) {
        sVar1 = pdVar5->object_size;
        puVar6 = (uchar *)0x0;
        if (sVar1 != 0) {
          bVar9 = pdVar2->state_objects == (uchar *)0x0;
          assert_failed = ZEXT14(bVar9);
          if (bVar9) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
            errline = 0xc6;
            elinks_internal((uchar *)"assertion context->state_objects failed!");
          }
          puVar6 = pdVar2->state_objects + sVar1 * state->depth;
        }
        stack->current = pdVar2;
        dVar4 = (*pdVar7)(stack,state->node,puVar6);
        stack->current = (dom_stack_context *)0x0;
        iVar3 = 1;
        if (dVar4 != DOM_CODE_FREE_NODE) {
          iVar3 = local_20;
        }
      }
      local_20 = iVar3;
      uVar8 = uVar8 + 1;
    } while (uVar8 <= stack->contexts_size && stack->contexts_size != uVar8);
  }
  return local_20;
}



void pop_dom_node(dom_stack *stack)

{
  dom_stack_context *pdVar1;
  size_t sVar2;
  size_t sVar3;
  int iVar4;
  size_t __n;
  dom_stack_state *state;
  uint uVar5;
  bool bVar6;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(stack == (dom_stack *)0x0), stack == (dom_stack *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
    errline = 0xe0;
    elinks_internal((uchar *)"assertion stack failed!");
  }
  state = stack->states;
  if ((state != (dom_stack_state *)0x0) && (sVar3 = stack->depth, sVar3 != 0)) {
    if (assert_failed == 0) {
      assert_failed = 0;
      state = stack->states;
      sVar3 = stack->depth;
    }
    state = (dom_stack_state *)(&state->node + sVar3 * 3 + -3);
    if ((*(byte *)&state->field_0x8 & 1) == 0) {
      iVar4 = call_dom_stack_callbacks(stack,state,DOM_STACK_POP);
      if ((iVar4 != 0) || ((*(byte *)&stack->flags & 1) != 0)) {
        done_dom_node(state->node);
      }
      stack->depth = stack->depth - 1;
      if (stack->contexts_size != 0) {
        uVar5 = 0;
        do {
          while( true ) {
            pdVar1 = stack->contexts[uVar5];
            sVar2 = pdVar1->info->object_size;
            if (sVar2 == 0) break;
            __n = sVar2;
            if (assert_failed == 0) {
              bVar6 = pdVar1->state_objects == (uchar *)0x0;
              assert_failed = ZEXT14(bVar6);
              if (bVar6) {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
                errline = 0xc6;
                elinks_internal((uchar *)"assertion context->state_objects failed!");
                __n = pdVar1->info->object_size;
              }
              else {
                __n = pdVar1->info->object_size;
              }
            }
            uVar5 = uVar5 + 1;
            memset(pdVar1->state_objects + sVar2 * state->depth,0,__n);
            if (stack->contexts_size < uVar5 || stack->contexts_size == uVar5) goto LAB_080a5128;
          }
          uVar5 = uVar5 + 1;
        } while (uVar5 <= stack->contexts_size && stack->contexts_size != uVar5);
      }
LAB_080a5128:
      state->node = (dom_node *)0x0;
      state->depth = 0;
      *(undefined4 *)&state->field_0x8 = 0;
      return;
    }
  }
  return;
}



void pop_dom_state(dom_stack *stack,dom_stack_state *target)

{
  int iVar1;
  dom_stack_state *pdVar2;
  int iVar3;
  dom_stack_state *pdVar4;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(stack == (dom_stack *)0x0), stack == (dom_stack *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
    errline = 0x112;
    elinks_internal((uchar *)"assertion stack failed!");
  }
  if (((target != (dom_stack_state *)0x0) &&
      (pdVar2 = stack->states, pdVar2 != (dom_stack_state *)0x0)) && (stack->depth != 0)) {
    iVar1 = stack->depth * 0xc;
    while( true ) {
      do {
        iVar3 = iVar1 + -0xc;
        pdVar4 = (dom_stack_state *)((int)&pdVar2[-1].node + iVar1);
        iVar1 = iVar3;
      } while (pdVar4 == (dom_stack_state *)0x0);
      if (((*(byte *)&pdVar4->field_0x8 & 1) != 0) || (pop_dom_node(stack), pdVar4 == target))
      break;
      pdVar2 = stack->states;
    }
  }
  return;
}



void pop_dom_nodes(dom_stack *stack,dom_node_type type,dom_string *string)

{
  dom_stack_state *target;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(stack == (dom_stack *)0x0), stack == (dom_stack *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
    errline = 0x103;
    elinks_internal((uchar *)"assertion stack failed!");
  }
  if ((stack->states != (dom_stack_state *)0x0) && (stack->depth != 0)) {
    target = search_dom_stack(stack,type,string);
    if (target != (dom_stack_state *)0x0) {
      pop_dom_state(stack,target);
      return;
    }
  }
  return;
}



dom_code push_dom_node(dom_stack *stack,dom_node *node)

{
  dom_stack_context *pdVar1;
  bool bVar2;
  uint uVar3;
  uint uVar4;
  size_t size;
  uchar *puVar5;
  dom_stack_state *state;
  int iVar6;
  uint uVar7;
  uint uVar8;
  size_t size_00;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(node == (dom_node *)0x0 || stack == (dom_stack *)0x0);
    if (node == (dom_node *)0x0 || stack == (dom_stack *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
      errline = 0xb6;
      elinks_internal((uchar *)"assertion stack && node failed!");
      if (assert_failed != 0) goto LAB_080a5355;
    }
    bVar2 = 0xb < (ushort)(node->type - 1);
    assert_failed = ZEXT14(bVar2);
    if (bVar2) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
      errline = 0xb7;
      elinks_internal((uchar *)"assertion 0 < node->type && node->type < DOM_NODES failed!");
    }
  }
LAB_080a5355:
  uVar7 = stack->depth;
  if (0x1000 < uVar7) {
    return DOM_CODE_MAX_DEPTH_ERR;
  }
  uVar3 = uVar7 + 8 & 0xfffffff8;
  uVar7 = uVar7 + 7 & 0xfffffff8;
  if (uVar7 < uVar3) {
    size_00 = uVar3 * 0xc;
    state = (dom_stack_state *)mem_realloc(stack->states,size_00);
    if (state == (dom_stack_state *)0x0) goto LAB_080a5518;
    stack->states = state;
    memset(state + uVar7,0,size_00 + uVar7 * -0xc);
  }
  state = stack->states;
  if (state != (dom_stack_state *)0x0) {
    uVar7 = stack->depth;
    uVar3 = uVar7;
    if (stack->contexts_size != 0) {
      uVar8 = 0;
      do {
        while( true ) {
          pdVar1 = stack->contexts[uVar8];
          size_00 = pdVar1->info->object_size;
          if (size_00 != 0) break;
          uVar8 = uVar8 + 1;
          if (stack->contexts_size < uVar8 || stack->contexts_size == uVar8) goto LAB_080a53ed;
        }
        uVar4 = uVar3 + 8 & 0xfffffff8;
        uVar3 = uVar3 + 7 & 0xfffffff8;
        if (uVar3 < uVar4) {
          size = uVar4 * size_00;
          puVar5 = (uchar *)mem_realloc(pdVar1->state_objects,size);
          if (puVar5 == (uchar *)0x0) goto LAB_080a5478;
          pdVar1->state_objects = puVar5;
          iVar6 = size_00 * uVar3;
          memset(puVar5 + iVar6,0,size - iVar6);
        }
        if (pdVar1->state_objects == (uchar *)0x0) {
LAB_080a5478:
          done_dom_node(node);
          return DOM_CODE_ALLOC_ERR;
        }
        uVar8 = uVar8 + 1;
        uVar3 = stack->depth;
      } while (uVar8 <= stack->contexts_size && stack->contexts_size != uVar8);
    }
LAB_080a53ed:
    state = state + uVar7;
    state->depth = uVar3;
    state->node = node;
    stack->depth = stack->depth + 1;
    call_dom_stack_callbacks(stack,state,DOM_STACK_PUSH);
    return DOM_CODE_OK;
  }
LAB_080a5518:
  done_dom_node(node);
  return DOM_CODE_ALLOC_ERR;
}



dom_stack_context *
add_dom_stack_context(dom_stack *stack,void *data,dom_stack_context_info *context_info)

{
  dom_stack_context *pdVar1;
  dom_stack_context **ppdVar2;
  uint uVar3;
  uint uVar4;
  size_t size;
  
  uVar4 = stack->contexts_size + 8 & 0xfffffff8;
  uVar3 = stack->contexts_size + 7 & 0xfffffff8;
  if (uVar3 < uVar4) {
    size = uVar4 * 4;
    ppdVar2 = (dom_stack_context **)mem_realloc(stack->contexts,size);
    if (ppdVar2 == (dom_stack_context **)0x0) {
      return (dom_stack_context *)0x0;
    }
    stack->contexts = ppdVar2;
    memset(ppdVar2 + uVar3,0,size + uVar3 * -4);
  }
  if (stack->contexts == (dom_stack_context **)0x0) {
    return (dom_stack_context *)0x0;
  }
  pdVar1 = (dom_stack_context *)mem_calloc(1,0xc);
  if (pdVar1 != (dom_stack_context *)0x0) {
    size = stack->contexts_size;
    stack->contexts[size] = pdVar1;
    stack->contexts_size = size + 1;
    pdVar1->info = context_info;
    pdVar1->data = data;
    return pdVar1;
  }
  return (dom_stack_context *)0x0;
}



void walk_dom_nodes(dom_stack *stack,dom_node *root)

{
  ushort uVar1;
  size_t sVar2;
  dom_node *node;
  uint **ppuVar3;
  uint *puVar4;
  dom_stack_context *context;
  dom_code dVar5;
  size_t sVar6;
  uint **ppuVar7;
  uint **ppuVar8;
  dom_stack_state *pdVar9;
  bool bVar10;
  uint **local_30;
  uint **local_20;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(root == (dom_node *)0x0 || stack == (dom_stack *)0x0),
     root == (dom_node *)0x0 || stack == (dom_stack *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
    errline = 0x16c;
    elinks_internal((uchar *)"assertion root && stack failed!");
  }
  context = add_dom_stack_context(stack,(void *)0x0,&dom_stack_walk_context_info);
  if ((context == (dom_stack_context *)0x0) ||
     (dVar5 = push_dom_node(stack,root), dVar5 != DOM_CODE_OK)) {
    return;
  }
LAB_080a565b:
  pdVar9 = stack->states;
  do {
    if ((pdVar9 == (dom_stack_state *)0x0) || (sVar6 = stack->depth, sVar6 == 0)) {
      done_dom_stack_context(stack,context);
      return;
    }
    if (assert_failed == 0) {
      assert_failed = 0;
      pdVar9 = stack->states;
      sVar6 = stack->depth;
    }
    sVar2 = context->info->object_size;
    ppuVar7 = (uint **)0x0;
    if (sVar2 != 0) {
      if ((assert_failed == 0) &&
         (bVar10 = context->state_objects == (uchar *)0x0, assert_failed = ZEXT14(bVar10), bVar10))
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
        errline = 0xc6;
        elinks_internal((uchar *)"assertion context->state_objects failed!");
      }
      ppuVar7 = (uint **)(context->state_objects + (int)(&pdVar9->node + sVar6 * 3 + -3)[1] * sVar2)
      ;
    }
    node = (&pdVar9->node)[sVar6 * 3 + -3];
    ppuVar3 = (uint **)*ppuVar7;
    uVar1 = node->type;
    ppuVar8 = ppuVar3;
    if (uVar1 == 7) {
      if (ppuVar3 == (uint **)0x0) {
        ppuVar8 = *(uint ***)(node->data + 0xc);
        goto LAB_080a56e6;
      }
LAB_080a56f9:
      puVar4 = ppuVar7[1];
      if (puVar4 < *ppuVar8) {
        node = (dom_node *)ppuVar8[(int)puVar4 + 1];
        ppuVar7[1] = (uint *)((int)puVar4 + 1);
        dVar5 = push_dom_node(stack,node);
        if (dVar5 == DOM_CODE_OK) goto LAB_080a565b;
      }
    }
    else {
      local_30 = ppuVar3;
      if (uVar1 < 8) {
        if (uVar1 == 1) {
          if (ppuVar3 == (uint **)0x0) {
            local_30 = *(uint ***)(node->data + 4);
          }
          local_20 = *(uint ***)node->data;
          if (((local_20 == local_30) || (local_30 == (uint **)0x0)) ||
             ((*local_30 <= ppuVar7[1] ||
              (ppuVar8 = *(uint ***)(node->data + 4), *(uint ***)(node->data + 4) != local_30)))) {
LAB_080a5760:
            ppuVar8 = local_20;
          }
        }
      }
      else {
        if (uVar1 == 9) {
          if (ppuVar3 != (uint **)0x0) goto LAB_080a56f9;
          ppuVar8 = *(uint ***)(node->data + 4);
        }
        else {
          if (uVar1 == 10) {
            if (ppuVar3 == (uint **)0x0) {
              local_30 = *(uint ***)node->data;
            }
            local_20 = *(uint ***)(node->data + 4);
            if (((local_20 == local_30) || (local_30 == (uint **)0x0)) || (*local_30 <= ppuVar7[1]))
            goto LAB_080a5760;
            ppuVar8 = *(uint ***)node->data;
            if (*(uint ***)node->data != local_30) {
              ppuVar8 = local_20;
            }
          }
        }
      }
LAB_080a56e6:
      if (ppuVar8 != ppuVar3) {
        *(uint ***)ppuVar7 = ppuVar8;
        ppuVar7[1] = (uint *)0x0;
      }
      if (ppuVar8 != (uint **)0x0) goto LAB_080a56f9;
    }
    pop_dom_node(stack);
    pdVar9 = stack->states;
  } while( true );
}



// WARNING: Type propagation algorithm not settling

dom_scanner_token * scan_css_tokens(dom_scanner *scanner)

{
  dom_scanner_token *__dest;
  byte *__s;
  byte bVar1;
  dom_scanner_token *pdVar2;
  uint uVar3;
  byte bVar4;
  size_t __n;
  uint __c;
  int iVar5;
  uchar *puVar6;
  void *pvVar7;
  dom_scanner *pdVar8;
  dom_scanner_token *__src;
  byte *pbVar9;
  int local_50;
  byte *ident;
  uchar *puVar10;
  dom_scanner *pdVar11;
  byte *end;
  byte *end_00;
  byte local_3c;
  byte *local_30;
  dom_scanner *local_20;
  
  __dest = scanner->table;
  pdVar2 = scanner->current;
  local_50 = ((int)scanner + ((scanner->tokens * 0x14 + 0x2c) - (int)pdVar2) >> 2) * -0x33333333;
  __src = pdVar2;
  if (local_50 < 1) {
    local_50 = 0;
    __src = __dest;
  }
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(pdVar2 == (dom_scanner_token *)0x0), pdVar2 == (dom_scanner_token *)0x0
     )) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
    errline = 0xfb;
    elinks_internal((uchar *)"assertion scanner->current failed!");
  }
  __n = 200;
  if (local_50 != 0) {
    memmove(__dest,__src,local_50 * 0x14);
    __src = scanner->table + local_50;
    __n = local_50 * -0x14 + 200;
  }
  memset(__src,0,__n);
  if (scanner->position == (uchar *)0x0) {
    if (local_50 == 0) {
      local_50 = -1;
    }
    scanner->tokens = local_50;
    scanner->current = __dest;
    if (assert_failed == 0) {
      if ((local_50 < 10) || (scanner->table + 1 < scanner->table + local_50)) {
        assert_failed = 0;
      }
      else {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
        errline = 0x10a;
        elinks_internal((uchar *)"assertion check_dom_scanner(scanner) failed!");
      }
    }
    local_50 = scanner->tokens;
  }
  else {
    scanner->tokens = local_50;
    if (__dest != (dom_scanner_token *)0x0) {
      local_20 = (dom_scanner *)(scanner->table + local_50);
      pdVar11 = scanner + 1;
      if ((pdVar11 <= local_20) ||
         (end = scanner->position, scanner->end < end || scanner->end == end)) {
joined_r0x080a5f2f:
        if ((assert_failed == 0) && (assert_failed = ZEXT14(pdVar11 < local_20), pdVar11 < local_20)
           ) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
          errline = 0x11a;
          elinks_internal((uchar *)"assertion end <= scanner->table + DOM_SCANNER_TOKENS failed!");
        }
        local_50 = (int)((int)local_20 - (int)__dest) >> 2;
        iVar5 = local_50 * -0x33333333;
        scanner->tokens = iVar5;
        scanner->current = __dest;
        if (scanner->end <= scanner->position) {
          scanner->position = (uchar *)0x0;
        }
        if (assert_failed == 0) {
          if ((iVar5 < 10) ||
             (scanner->current + 1 < (dom_scanner_token *)(&scanner->table[0].type + local_50))) {
            assert_failed = 0;
          }
          else {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
            errline = 0x121;
            elinks_internal((uchar *)"assertion check_dom_scanner(scanner) failed!");
          }
        }
        if (0 < scanner->tokens) {
          if (scanner->current < scanner->table + scanner->tokens) {
            return scanner->current;
          }
          return (dom_scanner_token *)0x0;
        }
        return (dom_scanner_token *)0x0;
      }
      do {
        local_3c = *end;
        __c = (uint)local_3c;
        ident = end;
        if ((*(byte *)((int)dom_css_scanner_info.scan_table + __c * 4 + 1) & 4) != 0) {
          do {
            ident = ident + 1;
            scanner->position = ident;
            if (scanner->end <= ident) goto joined_r0x080a5f2f;
            local_3c = *ident;
            __c = (uint)local_3c;
          } while ((*(byte *)((int)dom_css_scanner_info.scan_table + __c * 4 + 1) & 4) != 0);
        }
        if ((assert_failed == 0) && (assert_failed = ZEXT14(local_3c == 0), local_3c == 0)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/css/scanner.c";
          errline = 0x87;
          elinks_internal((uchar *)"assertion first_char failed!");
          local_3c = 0;
        }
        end = ident + 1;
        *(byte **)&local_20->tokens = ident;
        uVar3 = dom_css_scanner_info.scan_table[__c];
        if ((uVar3 & 0x100) != 0) {
          puVar10 = (uchar *)(uint)local_3c;
          goto LAB_080a5ae9;
        }
        if (((uVar3 & 2) == 0) && (local_3c != 0x2e)) {
          if ((uVar3 & 0x10) == 0) {
            if ((uVar3 & 0x200) == 0) {
LAB_080a5da7:
              puVar10 = (uchar *)0x11c;
            }
            else {
              if (local_3c == 0x23) {
                if ((dom_css_scanner_info.scan_table[*end] & 4U) == 0) {
                  if ((dom_css_scanner_info.scan_table[*end] & 8U) == 0) goto LAB_080a5da7;
                  ident = end;
                  if (end < scanner->end) {
                    do {
                      end = ident + 1;
                      if (scanner->end <= end) break;
                      pbVar9 = ident + 1;
                      ident = end;
                    } while ((*(byte *)(dom_css_scanner_info.scan_table + *pbVar9) & 8) != 0);
                    goto LAB_080a5fb7;
                  }
                  puVar10 = (uchar *)0x10b;
                }
                else {
                  pbVar9 = scanner->end;
                  if (end < pbVar9) {
                    do {
                      end = end + 1;
                      if (pbVar9 <= end) break;
                    } while ((*(byte *)(dom_css_scanner_info.scan_table + *end) & 4) != 0);
                  }
                  if (((end + ~(uint)ident == (byte *)0x6) || (end + ~(uint)ident == (byte *)0x3))
                     && ((*(byte *)(dom_css_scanner_info.scan_table + *end) & 8) == 0)) {
                    puVar10 = (uchar *)0x10c;
                  }
                  else {
                    if ((end < pbVar9) &&
                       (ident = end, (*(byte *)(dom_css_scanner_info.scan_table + *end) & 8) != 0))
                    {
                      do {
                        end = ident + 1;
                        if (pbVar9 <= end) break;
                        end_00 = ident + 1;
                        ident = end;
                      } while ((*(byte *)(dom_css_scanner_info.scan_table + *end_00) & 8) != 0);
LAB_080a5fb7:
                      puVar10 = (uchar *)0x10b;
                    }
                    else {
                      puVar10 = (uchar *)0x10b;
                    }
                  }
                }
                goto LAB_080a5ae9;
              }
              if (local_3c != 0x40) {
                if (local_3c == 0x2a) {
                  if (*end != 0x3d) goto LAB_080a5c7e;
                  end = ident + 2;
                  puVar10 = (uchar *)0x11b;
                  goto LAB_080a5ae9;
                }
                if (local_3c == 0x5e) {
                  if (*end != 0x3d) goto LAB_080a5da7;
                  end = ident + 2;
                  puVar10 = (uchar *)0x119;
                  goto LAB_080a5ae9;
                }
                if (local_3c == 0x24) {
                  if (*end != 0x3d) goto LAB_080a5da7;
                  end = ident + 2;
                  puVar10 = (uchar *)0x11a;
                  goto LAB_080a5ae9;
                }
                if (local_3c == 0x7c) {
                  if (*end != 0x3d) goto LAB_080a5da7;
                  end = ident + 2;
                  puVar10 = (uchar *)0x118;
                  goto LAB_080a5ae9;
                }
                if (local_3c == 0x21) {
                  if (end < scanner->end) {
                    bVar1 = *(byte *)((int)dom_css_scanner_info.scan_table + (uint)*end * 4 + 1);
                    ident = end;
                    while ((end = ident, (bVar1 & 4) != 0 && (end = ident + 1, end < scanner->end)))
                    {
                      bVar1 = *(byte *)((int)dom_css_scanner_info.scan_table +
                                       (uint)ident[1] * 4 + 1);
                      ident = end;
                    }
                  }
                  local_50 = c_strncasecmp((char *)end,"important",9);
                  if (local_50 == 0) {
                    end = end + 9;
                    puVar10 = (uchar *)0x116;
                  }
                  else {
                    puVar10 = (uchar *)0x11c;
                  }
                  goto LAB_080a5ae9;
                }
                if ((local_3c != 0x27) && (local_3c != 0x22)) {
                  if ((local_3c != 0x2d) && (local_3c != 0x3c)) {
                    if (local_3c == 0x2f) {
                      if (*end == 0x2a) {
                        pbVar9 = ident + 2;
                        ident = ident + 3;
                        while (pbVar9 < scanner->end) {
                          if ((*pbVar9 == 0x2a) && (*ident == 0x2f)) {
                            end = pbVar9 + 2;
                            puVar10 = (uchar *)0x11d;
                            goto LAB_080a5ae9;
                          }
                          pbVar9 = pbVar9 + 1;
                          ident = ident + 1;
                        }
                        goto LAB_080a65be;
                      }
                    }
                    else {
                      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/css/scanner.c";
                      errline = 0x15a;
                      elinks_internal((uchar *)
                                      "Someone forgot to put code for recognizing tokens which start with \'%c\'."
                                      ,__c);
                    }
                    goto LAB_080a5da7;
                  }
                  bVar1 = *end;
                  if (bVar1 == 0x2f) {
                    puVar10 = (uchar *)0x0;
                    goto LAB_080a5ae9;
                  }
                  if ((end < scanner->end) &&
                     (pbVar9 = end, *(char *)(dom_css_scanner_info.scan_table + bVar1) < '\0')) {
                    do {
                      ident = pbVar9;
                      pbVar9 = ident + 1;
                      if (scanner->end <= pbVar9) break;
                    } while (*(char *)(dom_css_scanner_info.scan_table + *pbVar9) < '\0');
                    if (1 < (int)(pbVar9 + -(int)end)) {
                      if (local_3c == 0x3c) {
                        if (bVar1 == 0x21) goto LAB_080a65be;
                      }
                      else {
                        if ((local_3c == 0x2d) && (*ident == 0x3e)) {
LAB_080a65be:
                          end = pbVar9;
                          puVar10 = (uchar *)0x11d;
                          goto LAB_080a5ae9;
                        }
                      }
                    }
                  }
LAB_080a631a:
                  puVar10 = (uchar *)0x11c;
                  goto LAB_080a5ae9;
                }
                pvVar7 = memchr(end,__c,(size_t)(scanner->end + -(int)end));
                if (pvVar7 == (void *)0x0) goto LAB_080a631a;
                puVar10 = (uchar *)0x103;
                ident = (byte *)((int)pvVar7 - (int)end);
                *(byte **)&local_20->tokens = end;
                end = (byte *)((int)pvVar7 + 1);
                goto LAB_080a5ebf;
              }
              if ((dom_css_scanner_info.scan_table[*end] & 0x10U) == 0) goto LAB_080a5da7;
              pbVar9 = end;
              if ((end < scanner->end) && ((dom_css_scanner_info.scan_table[*end] & 8U) != 0)) {
                do {
                  pbVar9 = pbVar9 + 1;
                  if (scanner->end <= pbVar9) break;
                } while ((*(byte *)(dom_css_scanner_info.scan_table + *pbVar9) & 8) != 0);
              }
              local_50 = 0x110;
              ident = end;
LAB_080a5c1c:
              end = pbVar9;
              puVar10 = (uchar *)map_dom_scanner_string(scanner,ident,end,local_50);
            }
            goto LAB_080a5ae9;
          }
          pbVar9 = scanner->end;
          end_00 = end;
          while (end_00 < pbVar9) {
            bVar1 = *end_00;
            if ((*(byte *)(dom_css_scanner_info.scan_table + bVar1) & 8) == 0)
            goto joined_r0x080a5c78;
            end_00 = end_00 + 1;
          }
          bVar1 = *end_00;
joined_r0x080a5c78:
          end = end_00;
          if (bVar1 != 0x28) {
LAB_080a5c7e:
            puVar10 = (uchar *)0x100;
            goto LAB_080a5ae9;
          }
          end = end_00 + 1;
          local_30 = end;
          if (end < pbVar9) {
            bVar1 = end_00[1];
            if (bVar1 == 0x29) goto LAB_080a6102;
            if ((bVar1 != 0x7d) && (bVar1 != 0x7b)) {
              while (bVar1 != 0x3b) {
                if ((bVar1 == 0x27) || (bVar1 == 0x22)) {
                  __s = local_30 + 1;
                  pvVar7 = memchr(__s,(uint)bVar1,(size_t)(pbVar9 + -(int)local_30));
                  local_30 = (byte *)((int)pvVar7 + 1);
                  if (pvVar7 == (void *)0x0) {
                    local_30 = __s;
                  }
                }
                else {
                  local_30 = local_30 + 1;
                }
                if (pbVar9 <= local_30) goto LAB_080a608d;
                bVar1 = *local_30;
                if (bVar1 == 0x29) goto LAB_080a6102;
                if ((bVar1 == 0x7d) || (bVar1 == 0x7b)) break;
              }
            }
LAB_080a5eb3:
            ident = (byte *)0xffffffff;
            puVar10 = (uchar *)0x11c;
          }
          else {
LAB_080a608d:
            if (*local_30 != 0x29) goto LAB_080a5eb3;
LAB_080a6102:
            puVar10 = (uchar *)map_dom_scanner_string(scanner,ident,end_00,0x10d);
            if (puVar10 == (uchar *)0x10d) {
              ident = (byte *)0xffffffff;
              end_00 = local_30;
LAB_080a613b:
              local_30 = end_00;
              if (assert_failed == 0) {
                if ((puVar10 != (uchar *)0x10e) || (*local_30 == 0x28)) {
LAB_080a6157:
                  if ((puVar10 == (uchar *)0x10f) && (*local_30 != 0x29)) {
                    assert_failed = 1;
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/css/scanner.c";
                    errline = 0xd7;
                    elinks_internal((uchar *)
                                    "assertion type != CSS_TOKEN_URL || *string == \')\' failed!");
                    if (assert_failed != 0) {
                      end = local_30 + 1;
                      goto LAB_080a5ebf;
                    }
                  }
                  else {
LAB_080a6490:
                    if ((puVar10 == (uchar *)0x10d) && (*local_30 != 0x29)) {
                      assert_failed = 1;
                      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/css/scanner.c";
                      errline = 0xd8;
                      elinks_internal((uchar *)
                                      "assertion type != CSS_TOKEN_FUNCTION || *string == \')\' failed!"
                                     );
                      end = local_30 + 1;
                      goto LAB_080a5ebf;
                    }
                  }
                  assert_failed = 0;
                  end = local_30 + 1;
                  goto LAB_080a5ebf;
                }
                assert_failed = 1;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/css/scanner.c";
                errline = 0xd6;
                elinks_internal((uchar *)
                                "assertion type != CSS_TOKEN_RGB || *string == \'(\' failed!");
                if (assert_failed == 0) goto LAB_080a6490;
              }
            }
            else {
              ident = (byte *)0xffffffff;
              if (puVar10 != (uchar *)0x10f) goto LAB_080a613b;
              while (end < scanner->end) {
                bVar1 = *end;
                if ((*(byte *)((int)dom_css_scanner_info.scan_table + (uint)bVar1 * 4 + 1) & 4) == 0
                   ) goto LAB_080a64fc;
                end = end + 1;
              }
              bVar1 = *end;
LAB_080a64fc:
              ident = local_30;
              do {
                pbVar9 = ident;
                ident = pbVar9 + -1;
                if (ident < scanner->string) {
                  bVar4 = *ident;
                  break;
                }
                bVar4 = *ident;
              } while ((*(byte *)((int)dom_css_scanner_info.scan_table + (uint)bVar4 * 4 + 1) & 4)
                       != 0);
              if ((bVar1 == 0x27) || (bVar1 == 0x22)) {
                end = end + 1;
              }
              if ((bVar4 == 0x27) || (bVar4 == 0x22)) {
                ident = pbVar9 + -2;
              }
              ident = ident + (1 - (int)end);
              *(byte **)&local_20->tokens = end;
              if (assert_failed == 0) {
                assert_failed = -((int)ident >> 0x1f);
                if (assert_failed != 0) {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/css/scanner.c";
                  errline = 0xd2;
                  elinks_internal((uchar *)"assertion real_length >= 0 failed!");
                  end_00 = local_30;
                  goto LAB_080a613b;
                }
                goto LAB_080a6157;
              }
            }
            end = local_30 + 1;
          }
LAB_080a5ebf:
          local_20->string = puVar10;
          if ((int)ident < 1) goto LAB_080a5aee;
        }
        else {
          ident = scanner->end;
          if (end < ident) {
            bVar4 = *end;
            bVar1 = *(byte *)(dom_css_scanner_info.scan_table + bVar4);
            while ((bVar1 & 2) != 0) {
              end = end + 1;
              if (ident <= end) goto LAB_080a5bb7;
              bVar4 = *end;
              bVar1 = *(byte *)(dom_css_scanner_info.scan_table + bVar4);
            }
          }
          else {
LAB_080a5bb7:
            bVar4 = *end;
          }
          if (bVar4 == 0x2e) {
            end = end + 1;
            bVar4 = *end;
            if ((*(byte *)(dom_css_scanner_info.scan_table + bVar4) & 2) == 0) goto LAB_080a5bc2;
            if (end < ident) {
              do {
                end = end + 1;
                if (ident <= end) {
                  bVar4 = *end;
                  puVar10 = (uchar *)0x101;
                  goto LAB_080a5bc7;
                }
                bVar4 = *end;
              } while ((*(byte *)(dom_css_scanner_info.scan_table + bVar4) & 2) != 0);
            }
            puVar10 = (uchar *)0x101;
          }
          else {
LAB_080a5bc2:
            puVar10 = (uchar *)0x11c;
          }
LAB_080a5bc7:
          if (bVar4 == 0x25) {
            if (local_3c != 0x2e) {
              puVar10 = (uchar *)0x102;
            }
            end = end + 1;
          }
          else {
            if ((dom_css_scanner_info.scan_table[bVar4] & 0x10U) != 0) {
              pbVar9 = end;
              if ((end < ident) && ((dom_css_scanner_info.scan_table[bVar4] & 8U) != 0)) {
                do {
                  pbVar9 = pbVar9 + 1;
                  if (ident <= pbVar9) break;
                } while ((*(byte *)(dom_css_scanner_info.scan_table + *pbVar9) & 8) != 0);
              }
              local_50 = 0x105;
              ident = end;
              goto LAB_080a5c1c;
            }
            puVar10 = (uchar *)0x101;
          }
LAB_080a5ae9:
          local_20->string = puVar10;
LAB_080a5aee:
          ident = end + -(int)local_20->tokens;
        }
        puVar6 = (uchar *)0x400;
        *(byte **)&((dom_string *)&local_20->current)->length = ident;
        if ((((puVar10 != (uchar *)0x7d) && (puVar6 = (uchar *)0x200, puVar10 != (uchar *)0x7b)) &&
            (puVar6 = (uchar *)0x100, puVar10 != (uchar *)0x3b)) &&
           (puVar6 = (uchar *)0x0, puVar10 == (uchar *)0x29)) {
          puVar6 = (uchar *)0x80;
        }
        local_20->end = puVar6;
        scanner->position = end;
        if (local_20->string == (uchar *)0x0) {
          scanner->position = (uchar *)0x0;
          local_20 = (dom_scanner *)(local_20[-1].table + 9);
          goto joined_r0x080a5f2f;
        }
        pdVar8 = (dom_scanner *)(local_20[-1].table + 9);
        if (local_20->string != (uchar *)0x11d) {
          pdVar8 = local_20;
        }
        local_20 = (dom_scanner *)&pdVar8->info;
        if ((pdVar11 <= local_20) || (scanner->end < end || scanner->end == end))
        goto joined_r0x080a5f2f;
      } while( true );
    }
  }
  if ((0 < local_50) && (scanner->current < scanner->table + local_50)) {
    return scanner->current;
  }
  return (dom_scanner_token *)0x0;
}



dom_code sgml_file_dumper_element_pop(dom_stack *stack,dom_node *node,void *data)

{
  __fprintf_chk(stack->current->data,1,"</%.*s>",(node->string).length,(node->string).string);
  return DOM_CODE_OK;
}



dom_code sgml_file_dumper_comment_push(dom_stack *stack,dom_node *node,void *data)

{
  __fprintf_chk(stack->current->data,1,&DAT_0812cbf4,(node->string).length,(node->string).string);
  return DOM_CODE_OK;
}



dom_code sgml_file_dumper_proc_instruction_push(dom_stack *stack,dom_node *node,void *data)

{
  __fprintf_chk(stack->current->data,1,"<?%.*s %.*s?>",(node->string).length,(node->string).string,
                *(undefined4 *)node->data,*(undefined4 *)(node->data + 4));
  return DOM_CODE_OK;
}



dom_code sgml_file_dumper_entity_ref_push(dom_stack *stack,dom_node *node,void *data)

{
  __fprintf_chk(stack->current->data,1,"&%.*s;",(node->string).length,(node->string).string);
  return DOM_CODE_OK;
}



dom_code sgml_file_dumper_cdata_section_push(dom_stack *stack,dom_node *node,void *data)

{
  __fprintf_chk(stack->current->data,1,"<![CDATA[%.*s]]>",(node->string).length,
                (node->string).string);
  return DOM_CODE_OK;
}



dom_code sgml_file_dumper_text_push(dom_stack *stack,dom_node *node,void *data)

{
  __fprintf_chk(stack->current->data,1,&DAT_0812cc2d,(node->string).length,(node->string).string);
  return DOM_CODE_OK;
}



dom_code sgml_file_dumper_element_push(dom_stack *stack,dom_node *node,void *data)

{
  void *pvVar1;
  uint local_20;
  uchar *local_1c;
  
  pvVar1 = stack->current->data;
  local_1c = (node->string).string;
  local_20 = (node->string).length;
  __fprintf_chk(pvVar1,1,"<%.*s",local_20,local_1c);
  if ((*(int **)(node->data + 4) == (int *)0x0) || (**(int **)(node->data + 4) == 0)) {
    __fprintf_chk(pvVar1,1,&DAT_08130b5c,local_20,local_1c);
  }
  return DOM_CODE_OK;
}



dom_code sgml_file_dumper_attribute_push(dom_stack *stack,dom_node *node,void *data)

{
  void *pvVar1;
  dom_node *pdVar2;
  uint local_20;
  uchar *local_1c;
  uchar *puVar3;
  
  pvVar1 = stack->current->data;
  if (node->parent->type == 7) {
    return DOM_CODE_OK;
  }
  local_1c = (node->string).string;
  local_20 = (node->string).length;
  __fprintf_chk(pvVar1,1,&DAT_0812cc2c,local_20,local_1c);
  puVar3 = *(uchar **)(node->data + 4);
  if (puVar3 != (uchar *)0x0) {
    if (node->data[0xc] == 0) {
      local_20 = *(uint *)node->data;
      __fprintf_chk(pvVar1,1,"=\"%.*s\"",local_20,puVar3);
      pdVar2 = get_dom_node_next(node);
      local_1c = puVar3;
      goto joined_r0x080a68d5;
    }
    local_20 = (uint)node->data[0xc];
    local_1c = *(uchar **)node->data;
    __fprintf_chk(pvVar1,1,&DAT_0812cc32,local_20,local_1c,puVar3,local_20);
  }
  pdVar2 = get_dom_node_next(node);
joined_r0x080a68d5:
  if (pdVar2 == (dom_node *)0x0) {
    __fprintf_chk(pvVar1,1,&DAT_08130b5c,local_20,local_1c);
  }
  return DOM_CODE_OK;
}



dom_stack_context * add_sgml_file_dumper(dom_stack *stack,FILE *file)

{
  dom_stack_context *pdVar1;
  
  pdVar1 = add_dom_stack_context(stack,file,&sgml_file_dumper);
  return pdVar1;
}



void done_sgml_parser(sgml_parser *parser)

{
  dom_stack_state *pdVar1;
  uchar *p;
  
  pdVar1 = (parser->parsing).states;
  while ((pdVar1 != (dom_stack_state *)0x0 && ((parser->parsing).depth != 0))) {
    pop_dom_node(&parser->parsing);
    pdVar1 = (parser->parsing).states;
  }
  done_dom_stack(&parser->parsing);
  done_dom_stack(&parser->stack);
  p = (parser->uri).string;
  if (p != (uchar *)0x0) {
    mem_free(p);
  }
  (parser->uri).string = (uchar *)0x0;
  (parser->uri).length = 0;
  mem_free(parser);
  return;
}



dom_string * __regparm3 add_to_dom_string(dom_string *string,uchar *str,size_t len)

{
  uchar *puVar1;
  uint uVar2;
  
  puVar1 = (uchar *)mem_realloc(string->string,len + 1 + string->length);
  if (puVar1 == (uchar *)0x0) {
    string = (dom_string *)0x0;
  }
  else {
    string->string = puVar1;
    memcpy(puVar1 + string->length,str,len);
    uVar2 = len + string->length;
    string->length = uVar2;
    string->string[uVar2] = '\0';
  }
  return string;
}



dom_code __regparm3
check_sgml_incomplete(dom_scanner *scanner,dom_scanner_token *start,dom_scanner_token *token)

{
  uchar *__s;
  uchar *puVar1;
  
  if (token == (dom_scanner_token *)0x0) {
    if ((*(byte *)&scanner->field_0x18 & 3) == 3) {
      puVar1 = scanner->end + -(int)(start->string).string;
      if ((assert_failed == 0) &&
         (assert_failed = ZEXT14(puVar1 == (uchar *)0x0), puVar1 == (uchar *)0x0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
        errline = 0xbd;
        elinks_internal((uchar *)"assertion left > 0 failed!");
      }
      scanner->current = scanner->table;
      scanner->tokens = 1;
      scanner->table[0].type = 0x117;
      __s = (start->string).string;
      scanner->table[0].string.string = __s;
      if (puVar1 == (uchar *)0xffffffff) {
        puVar1 = (uchar *)strlen((char *)__s);
      }
      *(uchar **)&scanner->table[0].string.length = puVar1;
      return DOM_CODE_INDEX_SIZE_ERR;
    }
  }
  else {
    if (token->type == 0x117) {
      *(uchar **)&(token->string).length =
           (token->string).string + ((token->string).length - (int)(start->string).string);
      (token->string).string = (start->string).string;
      return DOM_CODE_INDEX_SIZE_ERR;
    }
  }
  return DOM_CODE_OK;
}



dom_code parse_sgml(sgml_parser *parser,uchar *buf,size_t bufsize,int complete)

{
  byte *pbVar1;
  size_t sVar2;
  dom_stack_state *pdVar3;
  dom_node *node;
  dom_code dVar4;
  dom_string source;
  
  source.length = bufsize;
  source.string = buf;
  if (complete != 0) {
    parser->flags = parser->flags | SGML_PARSER_COMPLETE;
  }
  if (parser->root == (dom_node *)0x0) {
    node = init_dom_node_at((dom_node *)0x0,DOM_NODE_DOCUMENT,&parser->uri,
                            parser->flags & SGML_PARSER_INCREMENTAL);
    if ((node == (dom_node *)0x0) ||
       (dVar4 = push_dom_node(&parser->stack,node), dVar4 != DOM_CODE_OK)) {
      parser->root = (dom_node *)0x0;
      return DOM_CODE_ALLOC_ERR;
    }
    sVar2 = (parser->stack).depth;
    pdVar3 = (parser->stack).states;
    parser->root = node;
    pbVar1 = (byte *)(&pdVar3->field_0x8 + (sVar2 * 3 + -3) * 4);
    *pbVar1 = *pbVar1 | 1;
  }
  node = init_dom_node_at((dom_node *)0x0,DOM_NODE_TEXT,&source,0);
  if ((node != (dom_node *)0x0) &&
     (dVar4 = push_dom_node(&parser->parsing,node), dVar4 == DOM_CODE_OK)) {
    return parser->code;
  }
  return DOM_CODE_ALLOC_ERR;
}



dom_code sgml_parsing_pop(dom_stack *stack,dom_node *node,void *data)

{
  byte *pbVar1;
  void *pvVar2;
  
  pvVar2 = (*stack->contexts)->data;
  if (((*(byte *)((int)pvVar2 + 4) & 2) != 0) &&
     (*(uint *)((int)data + 0x100) < *(uint *)((int)pvVar2 + 0x24))) {
    do {
      pbVar1 = (byte *)(*(int *)((int)pvVar2 + 0x20) + 8 +
                       (*(int *)((int)pvVar2 + 0x24) * 3 + -3) * 4);
      *pbVar1 = *pbVar1 & 0xfe;
      pop_dom_node((dom_stack *)((int)pvVar2 + 0x20));
    } while (*(uint *)((int)data + 0x100) < *(uint *)((int)pvVar2 + 0x24));
  }
  if (*(void **)((int)data + 0xfc) != (void *)0x0) {
    mem_free(*(void **)((int)data + 0xfc));
  }
  *(undefined4 *)((int)data + 0xfc) = 0;
  *(undefined4 *)((int)data + 0xf8) = 0;
  return DOM_CODE_OK;
}



uint get_sgml_parser_line_number(sgml_parser *parser)

{
  dom_stack_context *pdVar1;
  size_t sVar2;
  int *piVar3;
  uint uVar4;
  int iVar5;
  uchar *puVar6;
  size_t sVar7;
  dom_stack_state *pdVar8;
  bool bVar9;
  
  if ((assert_failed == 0) &&
     (assert_failed = parser->flags & SGML_PARSER_COUNT_LINES ^ SGML_PARSER_COUNT_LINES,
     assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
    errline = 0x26f;
    elinks_internal((uchar *)"assertion parser->flags & SGML_PARSER_COUNT_LINES failed!");
  }
  iVar5 = assert_failed;
  pdVar8 = (parser->parsing).states;
  if ((pdVar8 == (dom_stack_state *)0x0) || (sVar7 = (parser->parsing).depth, sVar7 == 0)) {
    uVar4 = 0;
  }
  else {
    if (assert_failed == 0) {
      assert_failed = 0;
      pdVar8 = (parser->parsing).states;
      sVar7 = (parser->parsing).depth;
    }
    puVar6 = (uchar *)0x0;
    pdVar1 = *(parser->parsing).contexts;
    sVar2 = pdVar1->info->object_size;
    if (sVar2 != 0) {
      if ((iVar5 == 0) &&
         (bVar9 = pdVar1->state_objects == (uchar *)0x0, assert_failed = ZEXT14(bVar9), bVar9)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
        errline = 0xc6;
        elinks_internal((uchar *)"assertion context->state_objects failed!");
        iVar5 = assert_failed;
      }
      puVar6 = pdVar1->state_objects + sVar2 * (&pdVar8->depth)[sVar7 * 3 + -3];
    }
    if (iVar5 == 0) {
      if (((puVar6[0x20] & 1) == 0) || (*(int *)(puVar6 + 0x24) == 0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
        errline = 0x277;
        elinks_internal((uchar *)
                        "assertion pstate->scanner.count_lines && pstate->scanner.lineno failed!");
      }
      else {
        assert_failed = 0;
      }
    }
    piVar3 = *(int **)(puVar6 + 0xc);
    if (((piVar3 == (int *)0x0) || (puVar6 + 0xf4 <= piVar3)) || (*piVar3 != 0x118)) {
      uVar4 = *(uint *)(puVar6 + 0x24);
    }
    else {
      uVar4 = piVar3[2];
    }
  }
  return uVar4;
}



// WARNING: Type propagation algorithm not settling

dom_code __regparm3 call_sgml_error_function(dom_stack *stack,dom_scanner_token *token)

{
  sgml_parser *parser;
  uint uVar1;
  dom_code dVar2;
  bool bVar3;
  
  parser = (sgml_parser *)((sgml_parser *)((sgml_parser *)stack->contexts)->type)->type;
  uVar1 = get_sgml_parser_line_number(parser);
  if ((assert_failed == 0) &&
     (bVar3 = parser->error_func == (sgml_error_T *)0x0, assert_failed = ZEXT14(bVar3), bVar3)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
    errline = 0xa5;
    elinks_internal((uchar *)"assertion parser->error_func failed!");
  }
  dVar2 = (*parser->error_func)(parser,&token->string,uVar1);
  return dVar2;
}



sgml_parser *
init_sgml_parser(sgml_parser_type type,sgml_document_type doctype,dom_string *uri,
                sgml_parser_flag flags)

{
  uchar *__src;
  size_t __n;
  sgml_parser *p;
  uchar *puVar1;
  sgml_info *psVar2;
  sgml_parser *psVar3;
  uint uVar4;
  
  p = (sgml_parser *)mem_calloc(1,0x50);
  psVar3 = p;
  if (p != (sgml_parser *)0x0) {
    __src = uri->string;
    __n = uri->length;
    puVar1 = (uchar *)mem_realloc((p->uri).string,(p->uri).length + __n + 1);
    if (puVar1 == (uchar *)0x0) {
      psVar3 = (sgml_parser *)0x0;
      mem_free(p);
    }
    else {
      (p->uri).string = puVar1;
      memcpy(puVar1 + (p->uri).length,__src,__n);
      uVar4 = __n + (p->uri).length;
      (p->uri).length = uVar4;
      (p->uri).string[uVar4] = '\0';
      if ((flags & SGML_PARSER_DETECT_ERRORS) != 0) {
        flags = flags | SGML_PARSER_COUNT_LINES;
      }
      p->flags = flags;
      p->type = type;
      psVar2 = get_sgml_info(doctype);
      p->info = psVar2;
      init_dom_stack(&p->stack,(uint)(type == SGML_PARSER_STREAM));
      add_dom_stack_context(&p->stack,p,&sgml_parser_context_info);
      init_dom_stack(&p->parsing,DOM_STACK_FLAG_FREE_NODES);
      add_dom_stack_context(&p->parsing,p,&sgml_parsing_context_info);
    }
  }
  return psVar3;
}



dom_code __regparm3 parse_sgml_plain(dom_stack *stack,dom_scanner *scanner)

{
  byte bVar1;
  uchar uVar2;
  byte bVar3;
  dom_stack_context *pdVar4;
  void *pvVar5;
  dom_node *node;
  dom_code dVar6;
  dom_stack_state *target_00;
  size_t *psVar7;
  size_t sVar8;
  size_t **ppsVar9;
  uint uVar10;
  dom_node *node_00;
  dom_string *pdVar11;
  dom_node **ppdVar12;
  dom_scanner_token *token;
  int iVar13;
  uchar *puVar14;
  dom_scanner_token *token_00;
  dom_scanner_token *token_01;
  byte *pbVar15;
  size_t *psVar16;
  bool bVar17;
  byte bVar18;
  dom_node_type local_188;
  dom_scanner_token *local_144;
  dom_scanner attr_scanner;
  dom_scanner_token name;
  dom_scanner_token target;
  
  bVar18 = 0;
  iVar13 = scanner->tokens;
LAB_080a6fa0:
  if ((iVar13 < 1) || (token_01 = scanner->current, scanner->table + iVar13 <= token_01)) {
    return DOM_CODE_OK;
  }
  switch(token_01->type) {
  case 0x103:
  case 0x105:
  case 0x106:
  case 0x107:
  case 0x108:
    scanner->current = token_01 + 1;
    if (scanner->table + iVar13 <= token_01 + 2) goto LAB_080a715b;
    goto LAB_080a6fa0;
  case 0x104:
    if (assert_failed == 0) {
      assert_failed = 0;
    }
    local_188 = DOM_NODE_COMMENT;
    sVar8 = stack->depth;
    break;
  case 0x109:
    if (assert_failed == 0) {
      assert_failed = 0;
    }
    local_188 = DOM_NODE_CDATA_SECTION;
    sVar8 = stack->depth;
    break;
  case 0x10a:
  case 0x10b:
  case 0x10c:
    target.type = token_01->type;
    target.precedence = token_01->precedence;
    target.lineno = token_01->lineno;
    target.string.length = (token_01->string).length;
    target.string.string = (token_01->string).string;
    if (iVar13 < 1) {
      return DOM_CODE_INCOMPLETE;
    }
    token_00 = scanner->table + iVar13;
    if (token_00 <= token_01) {
      return DOM_CODE_INCOMPLETE;
    }
    local_144 = token_01 + 1;
    scanner->current = local_144;
    if (token_01 + 2 < token_00) {
      if (token_00 <= local_144) {
        return DOM_CODE_INCOMPLETE;
      }
    }
    else {
      local_144 = (*scanner->info->scan)(scanner);
    }
    if (local_144 == (dom_scanner_token *)0x0) {
      return DOM_CODE_INCOMPLETE;
    }
    iVar13 = local_144->type;
    if (iVar13 == 0x117) {
      return DOM_CODE_INCOMPLETE;
    }
    if (iVar13 != 0x118) {
      if (assert_failed == 0) {
        assert_failed = ZEXT14(iVar13 != 0x10d);
        if (iVar13 != 0x10d) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
          errline = 0x16e;
          elinks_internal((uchar *)"assertion token->type == SGML_TOKEN_PROCESS_DATA failed!");
          if (assert_failed != 0) goto LAB_080a7879;
        }
        assert_failed = 0;
      }
LAB_080a7879:
      node = init_dom_node_at((&stack->states->node)[stack->depth * 3 + -3],
                              DOM_NODE_PROCESSING_INSTRUCTION,&target.string,-1);
      if (node == (dom_node *)0x0) {
        return DOM_CODE_ALLOC_ERR;
      }
      bVar3 = *(byte *)&node->field_0x2;
      if ((bVar3 & 1) == 0) {
        uVar10 = (local_144->string).length;
        pbVar15 = (local_144->string).string;
        *(byte **)(node->data + 4) = pbVar15;
        if (uVar10 == 0xffffffff) {
          do {
            if (uVar10 == 0) break;
            uVar10 = uVar10 - 1;
            bVar1 = *pbVar15;
            pbVar15 = pbVar15 + (uint)bVar18 * -2 + 1;
          } while ((bVar3 & 1) != bVar1);
          uVar10 = ~uVar10 - 1;
        }
        *(uint *)node->data = uVar10;
      }
      else {
        pdVar11 = add_to_dom_string((dom_string *)node->data,(local_144->string).string,
                                    (local_144->string).length);
        if (pdVar11 == (dom_string *)0x0) {
          done_dom_node(node);
          return DOM_CODE_ALLOC_ERR;
        }
      }
      if (target.type == 0x10b) {
        *(undefined2 *)(node->data + 8) = 1;
      }
      else {
        *(ushort *)(node->data + 8) = (ushort)(target.type == 0x10c) * 2;
      }
      dVar6 = push_dom_node(stack,node);
      if (dVar6 != DOM_CODE_OK) {
        return DOM_CODE_ALLOC_ERR;
      }
      if ((((target.type - 0x10bU < 2) && ((local_144->string).length != 0)) &&
          (init_dom_scanner(&attr_scanner,&sgml_scanner_info,&local_144->string,1,
                            (uint)*(byte *)&scanner->field_0x20 & 1,1,0,0), 0 < attr_scanner.tokens)
          ) && (attr_scanner.current < attr_scanner.table + attr_scanner.tokens)) {
        while (token_01 = attr_scanner.current,
              attr_scanner.current < attr_scanner.table + attr_scanner.tokens) {
          if ((assert_failed == 0) &&
             (assert_failed = ZEXT14(attr_scanner.current == (dom_scanner_token *)0x0),
             attr_scanner.current == (dom_scanner_token *)0x0)) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
            errline = 0xd1;
            elinks_internal((uchar *)"assertion token failed!");
          }
          iVar13 = token_01->type;
          if (iVar13 < 0x112) {
            if (0x10d < iVar13) break;
            if (iVar13 == 0x100) {
              iVar13 = 5;
              token_00 = &name;
              while (iVar13 != 0) {
                iVar13 = iVar13 + -1;
                token_00->type = token_01->type;
                token_01 = (dom_scanner_token *)((int)token_01 + (uint)bVar18 * -8 + 4);
                token_00 = (dom_scanner_token *)((int)token_00 + (uint)bVar18 * -8 + 4);
              }
              if ((attr_scanner.tokens < 1) ||
                 (token_01 = attr_scanner.table + attr_scanner.tokens,
                 token_01 <= attr_scanner.current)) {
LAB_080a8170:
                token_00 = (dom_scanner_token *)0x0;
LAB_080a7e36:
                dVar6 = check_sgml_incomplete(&attr_scanner,&name,token_00);
                if (dVar6 != DOM_CODE_OK) break;
LAB_080a7e4a:
                token_00 = (dom_scanner_token *)0x0;
              }
              else {
                token_00 = attr_scanner.current + 1;
                if (attr_scanner.current + 2 < token_01) {
                  attr_scanner.current = token_00;
                  if (token_01 <= token_00) goto LAB_080a8170;
                }
                else {
                  attr_scanner.current = token_00;
                  token_00 = (*(attr_scanner.info)->scan)(&attr_scanner);
                }
                if ((token_00 == (dom_scanner_token *)0x0) || (token_00->type != 0x3d))
                goto LAB_080a7e36;
                if ((attr_scanner.tokens < 1) ||
                   (token_01 = attr_scanner.table + attr_scanner.tokens,
                   token_01 <= attr_scanner.current)) {
LAB_080a80cc:
                  token_00 = (dom_scanner_token *)0x0;
                }
                else {
                  token_00 = attr_scanner.current + 1;
                  if (attr_scanner.current + 2 < token_01) {
                    attr_scanner.current = token_00;
                    if (token_01 <= token_00) goto LAB_080a80cc;
                  }
                  else {
                    attr_scanner.current = token_00;
                    token_00 = (*(attr_scanner.info)->scan)(&attr_scanner);
                  }
                }
                dVar6 = check_sgml_incomplete(&attr_scanner,&name,token_00);
                if (dVar6 != DOM_CODE_OK) break;
                if ((((token_00 != (dom_scanner_token *)0x0) &&
                     (iVar13 = token_00->type, iVar13 != 0x100)) && (iVar13 != 0x112)) &&
                   (iVar13 != 0x102)) goto LAB_080a7e4a;
              }
              pvVar5 = (*stack->contexts)->data;
              if (assert_failed == 0) {
                assert_failed = 0;
              }
              node = stack->states[stack->depth - 1].node;
              if (token_00 == (dom_scanner_token *)0x0) {
                node = init_dom_node_at(node,DOM_NODE_ATTRIBUTE,&name.string,-1);
              }
              else {
                node_00 = init_dom_node_at(node,DOM_NODE_ATTRIBUTE,&name.string,-1);
                node = node_00;
                if (node_00 != (dom_node *)0x0) {
                  if ((*(byte *)&node_00->field_0x2 & 1) == 0) {
                    uVar10 = (token_00->string).length;
                    puVar14 = (token_00->string).string;
                    *(uchar **)(node_00->data + 4) = puVar14;
                    if (uVar10 == 0xffffffff) {
                      do {
                        if (uVar10 == 0) break;
                        uVar10 = uVar10 - 1;
                        uVar2 = *puVar14;
                        puVar14 = puVar14 + (uint)bVar18 * -2 + 1;
                      } while (uVar2 != '\0');
                      uVar10 = ~uVar10 - 1;
                    }
                    *(uint *)node_00->data = uVar10;
                  }
                  else {
                    pdVar11 = add_to_dom_string((dom_string *)node_00->data,
                                                (token_00->string).string,(token_00->string).length)
                    ;
                    if (pdVar11 == (dom_string *)0x0) {
                      node = (dom_node *)0x0;
                      done_dom_node(node_00);
                    }
                  }
                }
              }
              psVar16 = *(size_t **)(*(int *)((int)pvVar5 + 8) + 4);
              psVar7 = (size_t *)bsearch(node,psVar16 + 3,*psVar16,0xc,sgml_info_strcmp);
              if (psVar7 != (size_t *)0x0) {
                psVar16 = psVar7;
              }
              *(undefined2 *)(node->data + 10) = *(undefined2 *)(psVar16 + 2);
              bVar3 = node->data[0xd];
              bVar1 = (byte)(((uint)*(ushort *)((int)psVar16 + 10) & 1) << 2);
              node->data[0xd] = bVar3 & 0xfb | bVar1;
              node->data[0xd] =
                   bVar3 & 0xf3 | bVar1 |
                   (byte)(((uint)(*(ushort *)((int)psVar16 + 10) >> 1) & 1) << 3);
              if ((token_00 != (dom_scanner_token *)0x0) && (token_00->type == 0x102)) {
                node->data[0xc] = (token_00->string).string[-1];
              }
              dVar6 = push_dom_node(stack,node);
              if (dVar6 != DOM_CODE_OK) break;
              pop_dom_node(stack);
              if (token_00 != (dom_scanner_token *)0x0) {
                if (attr_scanner.tokens < 1) break;
                if ((attr_scanner.current < attr_scanner.table + attr_scanner.tokens) &&
                   (token_01 = attr_scanner.current + 1, token_00 = attr_scanner.current + 2,
                   attr_scanner.current = token_01,
                   attr_scanner.table + attr_scanner.tokens <= token_00)) {
                  (*(attr_scanner.info)->scan)(&attr_scanner);
                }
              }
            }
            else {
              if (iVar13 == 0x101) {
                if (((0 < attr_scanner.tokens) &&
                    (attr_scanner.current < attr_scanner.table + attr_scanner.tokens)) &&
                   (token_01 = attr_scanner.current + 1, token_00 = attr_scanner.current + 2,
                   attr_scanner.current = token_01,
                   attr_scanner.table + attr_scanner.tokens <= token_00)) {
                  (*(attr_scanner.info)->scan)(&attr_scanner);
                }
                break;
              }
LAB_080a7b5d:
              if (attr_scanner.tokens < 1) break;
              if ((attr_scanner.current < attr_scanner.table + attr_scanner.tokens) &&
                 (token_01 = attr_scanner.current + 1, token_00 = attr_scanner.current + 2,
                 attr_scanner.current = token_01,
                 attr_scanner.table + attr_scanner.tokens <= token_00)) {
                (*(attr_scanner.info)->scan)(&attr_scanner);
              }
            }
          }
          else {
            if (iVar13 == 0x117) break;
            if (iVar13 != 0x118) goto LAB_080a7b5d;
            dVar6 = call_sgml_error_function(stack,token_01);
            if ((dVar6 != DOM_CODE_OK) || (attr_scanner.tokens < 1)) break;
            if ((attr_scanner.current < attr_scanner.table + attr_scanner.tokens) &&
               (token_01 = attr_scanner.current + 1, token_00 = attr_scanner.current + 2,
               attr_scanner.current = token_01, attr_scanner.table + attr_scanner.tokens <= token_00
               )) {
              (*(attr_scanner.info)->scan)(&attr_scanner);
            }
          }
          if (attr_scanner.tokens < 1) break;
        }
      }
      pop_dom_node(stack);
      iVar13 = scanner->tokens;
      goto joined_r0x080a7183;
    }
    goto switchD_080a7600_caseD_10e;
  default:
    if (assert_failed == 0) {
      assert_failed = 0;
    }
    node = init_dom_node_at((&stack->states->node)[stack->depth * 3 + -3],DOM_NODE_TEXT,
                            &token_01->string,-1);
    if (node != (dom_node *)0x0) {
      if (token_01->type == 0x115) {
        node->data[4] = node->data[4] | 1;
      }
      dVar6 = push_dom_node(stack,node);
      if (dVar6 == DOM_CODE_OK) {
        pop_dom_node(stack);
      }
    }
    goto LAB_080a7039;
  case 0x10e:
  case 0x10f:
    pvVar5 = (*stack->contexts)->data;
    if (assert_failed == 0) {
      assert_failed = 0;
    }
    node = init_dom_node_at((&stack->states->node)[stack->depth * 3 + -3],DOM_NODE_ELEMENT,
                            &token_01->string,-1);
    if (node == (dom_node *)0x0) {
      return DOM_CODE_ALLOC_ERR;
    }
    psVar16 = *(size_t **)(*(int *)((int)pvVar5 + 8) + 8);
    psVar7 = (size_t *)bsearch(node,psVar16 + 3,*psVar16,0xc,sgml_info_strcmp);
    if (psVar7 != (size_t *)0x0) {
      psVar16 = psVar7;
    }
    *(undefined2 *)(node->data + 10) = *(undefined2 *)(psVar16 + 2);
    dVar6 = push_dom_node(stack,node);
    if (dVar6 != DOM_CODE_OK) {
      return DOM_CODE_ALLOC_ERR;
    }
    if (assert_failed == 0) {
      ppdVar12 = &stack->states->node + stack->depth * 3 + -3;
      assert_failed = ZEXT14(node != *ppdVar12);
      if (node != *ppdVar12) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
        errline = 0x46;
        elinks_internal((uchar *)"assertion node == state->node failed!");
      }
    }
    else {
      ppdVar12 = &stack->states->node + stack->depth * 3 + -3;
    }
    pdVar4 = *stack->contexts;
    sVar8 = pdVar4->info->object_size;
    ppsVar9 = (size_t **)0x0;
    if (sVar8 != 0) {
      if ((assert_failed == 0) &&
         (bVar17 = pdVar4->state_objects == (uchar *)0x0, assert_failed = ZEXT14(bVar17), bVar17)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
        errline = 0xc6;
        elinks_internal((uchar *)"assertion context->state_objects failed!");
      }
      ppsVar9 = (size_t **)(pdVar4->state_objects + sVar8 * (int)ppdVar12[1]);
    }
    *ppsVar9 = psVar16;
    if (token_01->type == 0x10f) {
      iVar13 = scanner->tokens;
      if (0 < iVar13) {
        token_01 = scanner->current;
        if ((token_01 < scanner->table + iVar13) &&
           (scanner->current = token_01 + 1, scanner->table + iVar13 <= token_01 + 2))
        goto LAB_080a75ee;
        do {
          if ((iVar13 < 1) || (token_01 = scanner->current, scanner->table + iVar13 <= token_01))
          break;
          if ((assert_failed == 0) &&
             (assert_failed = ZEXT14(token_01 == (dom_scanner_token *)0x0),
             token_01 == (dom_scanner_token *)0x0)) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
            errline = 0xd1;
            elinks_internal((uchar *)"assertion token failed!");
          }
          switch(token_01->type) {
          case 0x100:
            name.type = token_01->type;
            name.precedence = token_01->precedence;
            name.lineno = token_01->lineno;
            name.string.length = (token_01->string).length;
            name.string.string = (token_01->string).string;
            if (scanner->tokens < 1) {
LAB_080a79d3:
              token = (dom_scanner_token *)0x0;
LAB_080a7696:
              dVar6 = check_sgml_incomplete(scanner,&name,token);
              if (dVar6 != DOM_CODE_OK) {
                return DOM_CODE_INCOMPLETE;
              }
LAB_080a76a8:
              local_144 = (dom_scanner_token *)0x0;
            }
            else {
              token_00 = scanner->current;
              token_01 = scanner->table + scanner->tokens;
              if (token_01 <= token_00) goto LAB_080a79d3;
              token = token_00 + 1;
              scanner->current = token;
              if (token_00 + 2 < token_01) {
                if (token_01 <= token) goto LAB_080a79d3;
              }
              else {
                token = (*scanner->info->scan)(scanner);
              }
              if ((token == (dom_scanner_token *)0x0) || (token->type != 0x3d)) goto LAB_080a7696;
              if (scanner->tokens < 1) {
LAB_080a7d30:
                local_144 = (dom_scanner_token *)0x0;
              }
              else {
                token_00 = scanner->current;
                token_01 = scanner->table + scanner->tokens;
                if (token_01 <= token_00) goto LAB_080a7d30;
                local_144 = token_00 + 1;
                scanner->current = local_144;
                if (token_00 + 2 < token_01) {
                  if (token_01 <= local_144) goto LAB_080a7d30;
                }
                else {
                  local_144 = (*scanner->info->scan)(scanner);
                }
              }
              dVar6 = check_sgml_incomplete(scanner,&name,local_144);
              if (dVar6 != DOM_CODE_OK) {
                return DOM_CODE_INCOMPLETE;
              }
              if ((((local_144 != (dom_scanner_token *)0x0) &&
                   (iVar13 = local_144->type, iVar13 != 0x100)) && (iVar13 != 0x112)) &&
                 (iVar13 != 0x102)) goto LAB_080a76a8;
            }
            pvVar5 = (*stack->contexts)->data;
            if (assert_failed == 0) {
              assert_failed = 0;
            }
            node = (&stack->states->node)[stack->depth * 3 + -3];
            if (local_144 == (dom_scanner_token *)0x0) {
              node = init_dom_node_at(node,DOM_NODE_ATTRIBUTE,&name.string,-1);
            }
            else {
              node_00 = init_dom_node_at(node,DOM_NODE_ATTRIBUTE,&name.string,-1);
              node = node_00;
              if (node_00 != (dom_node *)0x0) {
                bVar3 = *(byte *)&node_00->field_0x2;
                if ((bVar3 & 1) == 0) {
                  uVar10 = (local_144->string).length;
                  pbVar15 = (local_144->string).string;
                  *(byte **)(node_00->data + 4) = pbVar15;
                  if (uVar10 == 0xffffffff) {
                    do {
                      if (uVar10 == 0) break;
                      uVar10 = uVar10 - 1;
                      bVar1 = *pbVar15;
                      pbVar15 = pbVar15 + (uint)bVar18 * -2 + 1;
                    } while ((bVar3 & 1) != bVar1);
                    uVar10 = ~uVar10 - 1;
                  }
                  *(uint *)node_00->data = uVar10;
                }
                else {
                  pdVar11 = add_to_dom_string((dom_string *)node_00->data,(local_144->string).string
                                              ,(local_144->string).length);
                  if (pdVar11 == (dom_string *)0x0) {
                    node = (dom_node *)0x0;
                    done_dom_node(node_00);
                  }
                }
              }
            }
            psVar16 = *(size_t **)(*(int *)((int)pvVar5 + 8) + 4);
            psVar7 = (size_t *)bsearch(node,psVar16 + 3,*psVar16,0xc,sgml_info_strcmp);
            if (psVar7 != (size_t *)0x0) {
              psVar16 = psVar7;
            }
            *(undefined2 *)(node->data + 10) = *(undefined2 *)(psVar16 + 2);
            bVar3 = node->data[0xd];
            bVar1 = (byte)(((uint)*(ushort *)((int)psVar16 + 10) & 1) << 2);
            node->data[0xd] = bVar3 & 0xfb | bVar1;
            node->data[0xd] =
                 bVar3 & 0xf3 | bVar1 |
                 (byte)(((uint)(*(ushort *)((int)psVar16 + 10) >> 1) & 1) << 3);
            if ((local_144 != (dom_scanner_token *)0x0) && (local_144->type == 0x102)) {
              node->data[0xc] = (local_144->string).string[-1];
            }
            dVar6 = push_dom_node(stack,node);
            if (dVar6 != DOM_CODE_OK) {
              return DOM_CODE_ALLOC_ERR;
            }
            pop_dom_node(stack);
            if (local_144 == (dom_scanner_token *)0x0) goto LAB_080a75f7;
            iVar13 = scanner->tokens;
            if (0 < iVar13) {
              token_01 = scanner->current;
              if ((token_01 < scanner->table + iVar13) &&
                 (scanner->current = token_01 + 1, scanner->table + iVar13 <= token_01 + 2)) {
                (*scanner->info->scan)(scanner);
                iVar13 = scanner->tokens;
              }
            }
            break;
          case 0x101:
            iVar13 = scanner->tokens;
            if (0 < iVar13) goto LAB_080a7138;
            goto LAB_080a6fa0;
          default:
switchD_080a7600_caseD_102:
            iVar13 = scanner->tokens;
            if (0 < iVar13) {
              token_01 = scanner->current;
              if ((token_01 < scanner->table + iVar13) &&
                 (scanner->current = token_01 + 1, scanner->table + iVar13 <= token_01 + 2)) {
LAB_080a75ee:
                (*scanner->info->scan)(scanner);
LAB_080a75f7:
                iVar13 = scanner->tokens;
              }
            }
            break;
          case 0x118:
            dVar6 = call_sgml_error_function(stack,token_01);
            if (dVar6 != DOM_CODE_OK) {
              return dVar6;
            }
            goto switchD_080a7600_caseD_102;
          case 0x10e:
          case 0x10f:
          case 0x110:
          case 0x111:
            goto switchD_080a7600_caseD_10e;
          case 0x117:
            goto switchD_080a7078_caseD_117;
          }
        } while( true );
      }
    }
    else {
      iVar13 = scanner->tokens;
      if (iVar13 < 1) {
        return DOM_CODE_OK;
      }
      token_01 = scanner->current;
      if ((token_01 < scanner->table + iVar13) &&
         (scanner->current = token_01 + 1, scanner->table + iVar13 <= token_01 + 2))
      goto LAB_080a715b;
    }
    goto LAB_080a6fa0;
  case 0x110:
    uVar10 = (token_01->string).length;
    if (uVar10 == 0) {
      pop_dom_node(stack);
    }
    else {
      name.precedence = (int)(token_01->string).string;
      if (uVar10 == 0xffffffff) {
        uVar10 = strlen((char *)name.precedence);
      }
      name.type = uVar10;
      target_00 = search_dom_stack(stack,DOM_NODE_ELEMENT,(dom_string *)&name);
      if (target_00 != (dom_stack_state *)0x0) {
        pdVar4 = *stack->contexts;
        sVar8 = pdVar4->info->object_size;
        puVar14 = (uchar *)0x0;
        if (sVar8 != 0) {
          if ((assert_failed == 0) &&
             (bVar17 = pdVar4->state_objects == (uchar *)0x0, assert_failed = ZEXT14(bVar17), bVar17
             )) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
            errline = 0xc6;
            elinks_internal((uchar *)"assertion context->state_objects failed!");
          }
          puVar14 = pdVar4->state_objects + target_00->depth * sVar8;
        }
        *(int *)(puVar14 + 4) = token_01->type;
        *(int *)(puVar14 + 8) = token_01->precedence;
        *(uint *)(puVar14 + 0xc) = token_01->lineno;
        *(uint *)(puVar14 + 0x10) = (token_01->string).length;
        *(uchar **)(puVar14 + 0x14) = (token_01->string).string;
        pop_dom_state(stack,target_00);
      }
    }
    goto LAB_080a7131;
  case 0x111:
    pop_dom_node(stack);
    iVar13 = scanner->tokens;
joined_r0x080a7183:
    if (iVar13 < 1) {
      return DOM_CODE_OK;
    }
    goto LAB_080a7138;
  case 0x113:
    if (assert_failed == 0) {
      assert_failed = 0;
    }
    node = init_dom_node_at((&stack->states->node)[stack->depth * 3 + -3],DOM_NODE_ENTITY_REFERENCE,
                            &token_01->string,-1);
    if (node == (dom_node *)0x0) goto LAB_080a7131;
    iVar13 = token_01->type;
    goto joined_r0x080a7107;
  case 0x117:
switchD_080a7078_caseD_117:
    return DOM_CODE_INCOMPLETE;
  case 0x118:
    dVar6 = call_sgml_error_function(stack,token_01);
    if (dVar6 != DOM_CODE_OK) {
      return dVar6;
    }
LAB_080a7039:
    iVar13 = scanner->tokens;
    if (iVar13 < 1) {
      return DOM_CODE_OK;
    }
    token_01 = scanner->current;
    if ((token_01 < scanner->table + iVar13) &&
       (scanner->current = token_01 + 1, scanner->table + iVar13 <= token_01 + 2)) {
      (*scanner->info->scan)(scanner);
switchD_080a7600_caseD_10e:
      iVar13 = scanner->tokens;
    }
    goto LAB_080a6fa0;
  }
  node = init_dom_node_at((&stack->states->node)[sVar8 * 3 + -3],local_188,&token_01->string,-1);
  if (node == (dom_node *)0x0) {
    return DOM_CODE_ALLOC_ERR;
  }
  iVar13 = token_01->type;
joined_r0x080a7107:
  if (iVar13 == 0x115) {
    node->data[4] = node->data[4] | 1;
  }
  dVar6 = push_dom_node(stack,node);
  if (dVar6 == DOM_CODE_OK) {
    pop_dom_node(stack);
  }
LAB_080a7131:
  iVar13 = scanner->tokens;
  if (iVar13 < 1) {
    return DOM_CODE_OK;
  }
LAB_080a7138:
  token_01 = scanner->current;
  if ((token_01 < scanner->table + iVar13) &&
     (scanner->current = token_01 + 1, scanner->table + iVar13 <= token_01 + 2)) {
LAB_080a715b:
    (*scanner->info->scan)(scanner);
    iVar13 = scanner->tokens;
  }
  goto LAB_080a6fa0;
}



dom_code sgml_parsing_push(dom_stack *stack,dom_node *node,void *data)

{
  dom_stack *stack_00;
  void *pvVar1;
  uint uVar2;
  uchar *__src;
  dom_scanner_token *pdVar3;
  byte bVar4;
  byte bVar5;
  uint check_complete;
  uchar *__dest;
  dom_scanner_token *token;
  dom_code dVar6;
  dom_node *node_00;
  size_t *psVar7;
  void *pvVar8;
  dom_string *pdVar9;
  size_t __n;
  uint detect_errors;
  dom_scanner_token *token_00;
  size_t *psVar10;
  uchar *__src_00;
  uint complete;
  dom_scanner *scanner;
  int state;
  dom_node *parent;
  dom_string *local_50;
  dom_scanner_token *local_48;
  dom_scanner_token name;
  
  pvVar1 = (*stack->contexts)->data;
  uVar2 = *(uint *)((int)pvVar1 + 4);
  complete = uVar2 >> 1 & 1;
  check_complete = uVar2 >> 2 & 1;
  local_50 = &node->string;
  detect_errors = uVar2 >> 3 & 1;
  *(undefined4 *)((int)data + 0x100) = *(undefined4 *)((int)pvVar1 + 0x24);
  if (1 < stack->depth) {
    scanner = (dom_scanner *)((int)data + -0x108);
    bVar5 = *(byte *)((int)data + -4);
    if ((bVar5 & 1) == 0) goto LAB_080a82e0;
    if ((*(void **)((int)data + -0xc) != (void *)0x0) && (*(int *)((int)data + -0x10) != 0)) {
      __n = (node->string).length;
      __src_00 = (node->string).string;
      pvVar8 = mem_realloc(*(void **)((int)data + -0xc),__n + 1 + *(int *)((int)data + -0x10));
      if (pvVar8 == (void *)0x0) goto LAB_080a8850;
      local_50 = (dom_string *)((int)data + -0x10);
      *(void **)((int)data + -0xc) = pvVar8;
      memcpy((void *)((int)pvVar8 + *(int *)((int)data + -0x10)),__src_00,__n);
      state = __n + *(int *)((int)data + -0x10);
      *(int *)((int)data + -0x10) = state;
      *(undefined *)(*(int *)((int)data + -0xc) + state) = 0;
      bVar5 = *(byte *)((int)data + -4);
    }
    state = *(int *)((int)data + -0xe0);
    *(byte *)((int)data + -4) = bVar5 & 0xfe;
    pop_dom_node(stack);
    init_dom_scanner(scanner,&sgml_scanner_info,local_50,state,uVar2 & 1,complete,check_complete,
                     detect_errors);
    if (state != 1) goto LAB_080a8321;
    stack_00 = (dom_stack *)((int)pvVar1 + 0x20);
    state = *(int *)((int)data + -0xf8);
LAB_080a8271:
    if ((state < 1) ||
       (token = *(dom_scanner_token **)((int)data + -0xfc),
       (dom_scanner_token *)((int)data + state * 0x14 + -0xdc) <= token))
    goto switchD_080a83e0_caseD_10e;
    if ((assert_failed == 0) &&
       (assert_failed = ZEXT14(token == (dom_scanner_token *)0x0), token == (dom_scanner_token *)0x0
       )) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
      errline = 0xd1;
      elinks_internal((uchar *)"assertion token failed!");
    }
    switch(token->type) {
    case 0x100:
      name.type = token->type;
      name.precedence = token->precedence;
      name.lineno = token->lineno;
      name.string.length = (token->string).length;
      name.string.string = (token->string).string;
      if (*(int *)((int)data + -0xf8) < 1) {
LAB_080a8668:
        token_00 = (dom_scanner_token *)0x0;
LAB_080a866a:
        dVar6 = check_sgml_incomplete(scanner,&name,token_00);
        if (dVar6 != DOM_CODE_OK) goto switchD_080a83e0_caseD_117;
LAB_080a867c:
        local_48 = (dom_scanner_token *)0x0;
      }
      else {
        pdVar3 = *(dom_scanner_token **)((int)data + -0xfc);
        token = (dom_scanner_token *)((int)data + *(int *)((int)data + -0xf8) * 0x14 + -0xdc);
        if (token <= pdVar3) goto LAB_080a8668;
        token_00 = pdVar3 + 1;
        *(dom_scanner_token **)((int)data + -0xfc) = token_00;
        if (pdVar3 + 2 < token) {
          if (token <= token_00) goto LAB_080a8668;
        }
        else {
          token_00 = (dom_scanner_token *)(**(code **)(*(int *)((int)data + -0xf4) + 8))(scanner);
        }
        if ((token_00 == (dom_scanner_token *)0x0) || (token_00->type != 0x3d)) goto LAB_080a866a;
        if (*(int *)((int)data + -0xf8) < 1) {
LAB_080a891d:
          local_48 = (dom_scanner_token *)0x0;
        }
        else {
          pdVar3 = *(dom_scanner_token **)((int)data + -0xfc);
          token = (dom_scanner_token *)((int)data + *(int *)((int)data + -0xf8) * 0x14 + -0xdc);
          if (token <= pdVar3) goto LAB_080a891d;
          local_48 = pdVar3 + 1;
          *(dom_scanner_token **)((int)data + -0xfc) = local_48;
          if (pdVar3 + 2 < token) {
            if (token <= local_48) goto LAB_080a891d;
          }
          else {
            local_48 = (dom_scanner_token *)(**(code **)(*(int *)((int)data + -0xf4) + 8))(scanner);
          }
        }
        dVar6 = check_sgml_incomplete(scanner,&name,local_48);
        if (dVar6 != DOM_CODE_OK) goto switchD_080a83e0_caseD_117;
        if ((((local_48 != (dom_scanner_token *)0x0) && (state = local_48->type, state != 0x100)) &&
            (state != 0x112)) && (state != 0x102)) goto LAB_080a867c;
      }
      state = ***(int ***)((int)pvVar1 + 0x2c);
      if (assert_failed == 0) {
        assert_failed = 0;
      }
      parent = (&stack_00->states->node)[*(int *)((int)pvVar1 + 0x24) * 3 + -3];
      if (local_48 == (dom_scanner_token *)0x0) {
        parent = init_dom_node_at(parent,DOM_NODE_ATTRIBUTE,&name.string,-1);
      }
      else {
        node_00 = init_dom_node_at(parent,DOM_NODE_ATTRIBUTE,&name.string,-1);
        parent = node_00;
        if (node_00 != (dom_node *)0x0) {
          if ((*(byte *)&node_00->field_0x2 & 1) == 0) {
            __n = (local_48->string).length;
            __src_00 = (local_48->string).string;
            *(uchar **)(node_00->data + 4) = __src_00;
            if (__n == 0xffffffff) {
              __n = strlen((char *)__src_00);
            }
            *(size_t *)node_00->data = __n;
          }
          else {
            pdVar9 = add_to_dom_string((dom_string *)node_00->data,(local_48->string).string,
                                       (local_48->string).length);
            if (pdVar9 == (dom_string *)0x0) {
              parent = (dom_node *)0x0;
              done_dom_node(node_00);
            }
          }
        }
      }
      psVar10 = *(size_t **)(*(int *)(state + 8) + 4);
      psVar7 = (size_t *)bsearch(parent,psVar10 + 3,*psVar10,0xc,sgml_info_strcmp);
      if (psVar7 != (size_t *)0x0) {
        psVar10 = psVar7;
      }
      *(undefined2 *)(parent->data + 10) = *(undefined2 *)(psVar10 + 2);
      bVar5 = parent->data[0xd];
      bVar4 = (byte)(((uint)*(ushort *)((int)psVar10 + 10) & 1) << 2);
      parent->data[0xd] = bVar5 & 0xfb | bVar4;
      parent->data[0xd] =
           bVar5 & 0xf3 | bVar4 | (byte)(((uint)(*(ushort *)((int)psVar10 + 10) >> 1) & 1) << 3);
      if ((local_48 != (dom_scanner_token *)0x0) && (local_48->type == 0x102)) {
        parent->data[0xc] = (local_48->string).string[-1];
      }
      dVar6 = push_dom_node(stack_00,parent);
      if (dVar6 != DOM_CODE_OK) {
        dVar6 = DOM_CODE_ALLOC_ERR;
        break;
      }
      pop_dom_node(stack_00);
      if (local_48 != (dom_scanner_token *)0x0) goto LAB_080a84fa;
      goto LAB_080a82d7;
    case 0x101:
      if (0 < *(int *)((int)data + -0xf8)) {
        check_complete = *(uint *)((int)data + -0xfc);
        uVar2 = (int)data + *(int *)((int)data + -0xf8) * 0x14 + -0xdc;
        if ((check_complete < uVar2) &&
           (*(int *)((int)data + -0xfc) = check_complete + 0x14, uVar2 <= check_complete + 0x28)) {
          (**(code **)(*(int *)((int)data + -0xf4) + 8))(scanner);
        }
      }
switchD_080a83e0_caseD_10e:
      *(undefined4 *)((int)pvVar1 + 0x18) = 0;
      dVar6 = parse_sgml_plain(stack_00,scanner);
      *(dom_code *)((int)pvVar1 + 0x18) = dVar6;
      goto LAB_080a832c;
    default:
      state = *(int *)((int)data + -0xf8);
      if (0 < state) goto code_r0x080a82b3;
    case 0x10e:
    case 0x10f:
    case 0x110:
    case 0x111:
      goto switchD_080a83e0_caseD_10e;
    case 0x117:
switchD_080a83e0_caseD_117:
      dVar6 = DOM_CODE_INCOMPLETE;
      break;
    case 0x118:
      dVar6 = call_sgml_error_function(stack_00,token);
      if (dVar6 == DOM_CODE_OK) {
LAB_080a84fa:
        state = *(int *)((int)data + -0xf8);
        if (state < 1) goto switchD_080a83e0_caseD_10e;
        check_complete = *(uint *)((int)data + -0xfc);
        uVar2 = (int)data + state * 0x14 + -0xdc;
        if ((check_complete < uVar2) &&
           (*(int *)((int)data + -0xfc) = check_complete + 0x14, uVar2 <= check_complete + 0x28)) {
          (**(code **)(*(int *)((int)data + -0xf4) + 8))(scanner);
          state = *(int *)((int)data + -0xf8);
        }
        goto LAB_080a8271;
      }
    }
    *(dom_code *)((int)pvVar1 + 0x18) = dVar6;
    goto LAB_080a832c;
  }
LAB_080a82e0:
  init_dom_scanner((dom_scanner *)data,&sgml_scanner_info,local_50,0,uVar2 & 1,complete,
                   check_complete,detect_errors);
  scanner = (dom_scanner *)data;
LAB_080a8321:
  dVar6 = parse_sgml_plain((dom_stack *)((int)pvVar1 + 0x20),scanner);
  *(dom_code *)((int)pvVar1 + 0x18) = dVar6;
LAB_080a832c:
  if (complete == 0) {
    if (*(int *)((int)pvVar1 + 0x18) == -999) {
      if ((scanner->tokens < 1) ||
         (token = scanner->current, scanner->table + scanner->tokens <= token)) {
        token = (dom_scanner_token *)0x0;
      }
      if (assert_failed == 0) {
        if ((token == (dom_scanner_token *)0x0) || (token->type != 0x117)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
          errline = 0x21b;
          elinks_internal((uchar *)"assertion token && token->type == SGML_TOKEN_INCOMPLETE failed!"
                         );
        }
        else {
          assert_failed = 0;
        }
      }
      __src_00 = (uchar *)(token->string).length;
      __src = (token->string).string;
      __dest = (uchar *)mem_realloc((void *)0x0,(size_t)(__src_00 + 1));
      if (__dest != (uchar *)0x0) {
        memcpy(__dest,__src,(size_t)__src_00);
        __dest[(int)__src_00] = '\0';
        if (scanner[1].position != (uchar *)0x0) {
          mem_free(scanner[1].position);
        }
        scanner[1].end = (uchar *)0x0;
        scanner[1].position = __dest;
        if (__src_00 == (uchar *)0xffffffff) {
          __src_00 = (uchar *)strlen((char *)__dest);
        }
        *(byte *)&scanner[1].tokens = *(byte *)&scanner[1].tokens | 1;
        scanner[1].end = __src_00;
        return DOM_CODE_OK;
      }
LAB_080a8850:
      *(undefined4 *)((int)pvVar1 + 0x18) = 0xfffffc1b;
      return DOM_CODE_OK;
    }
    if (scanner->state != 0) {
      if (scanner[1].position != (uchar *)0x0) {
        mem_free(scanner[1].position);
      }
      *(byte *)&scanner[1].tokens = *(byte *)&scanner[1].tokens | 1;
      scanner[1].position = (uchar *)0x0;
      scanner[1].end = (uchar *)0x0;
      return DOM_CODE_OK;
    }
  }
  pop_dom_node((dom_stack *)((int)pvVar1 + 0x38));
  return DOM_CODE_OK;
code_r0x080a82b3:
  check_complete = *(uint *)((int)data + -0xfc);
  uVar2 = (int)data + state * 0x14 + -0xdc;
  if ((check_complete < uVar2) &&
     (*(int *)((int)data + -0xfc) = check_complete + 0x14, uVar2 <= check_complete + 0x28)) {
    (**(code **)(*(int *)((int)data + -0xf4) + 8))(scanner);
LAB_080a82d7:
    state = *(int *)((int)data + -0xf8);
  }
  goto LAB_080a8271;
}



void __regparm3 skip_sgml_space(dom_scanner *scanner,uchar **string)

{
  byte *pbVar1;
  
  pbVar1 = *string;
  if ((*(byte *)&scanner->field_0x20 & 1) == 0) {
    if ((pbVar1 < scanner->end) && ((*(byte *)(sgml_scanner_info.scan_table + *pbVar1) & 0x10) != 0)
       ) {
      while (pbVar1 = pbVar1 + 1, pbVar1 < scanner->end) {
        if ((*(byte *)(sgml_scanner_info.scan_table + *pbVar1) & 0x10) == 0) {
          *string = pbVar1;
          return;
        }
      }
    }
  }
  else {
    while (pbVar1 < scanner->end) {
      if ((sgml_scanner_info.scan_table[*pbVar1] & 0x10U) == 0) {
        *string = pbVar1;
        return;
      }
      if ((sgml_scanner_info.scan_table[*pbVar1] & 8U) != 0) {
        scanner->lineno = scanner->lineno + 1;
      }
      pbVar1 = pbVar1 + 1;
    }
  }
  *string = pbVar1;
  return;
}



uchar * __regparm3 skip_sgml_chars(dom_scanner *scanner,uchar *string,uchar skipto)

{
  byte bVar1;
  uchar *puVar2;
  int iVar3;
  
  if (assert_failed == 0) {
    if ((scanner->position < string || scanner->position == string) &&
       (string < scanner->end || string == scanner->end)) {
      assert_failed = 0;
      bVar1 = *(byte *)&scanner->field_0x20;
      goto joined_r0x080a8a28;
    }
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
    errline = 0x131;
    elinks_internal((uchar *)
                    "assertion string >= scanner->position && string <= scanner->end failed!");
  }
  bVar1 = *(byte *)&scanner->field_0x20;
joined_r0x080a8a28:
  if ((bVar1 & 1) == 0) {
    puVar2 = (uchar *)memchr(string,(uint)skipto,(size_t)(scanner->end + -(int)string));
  }
  else {
    iVar3 = 0;
    if (string < scanner->end) {
      do {
        iVar3 = (iVar3 + 1) - (uint)((sgml_scanner_info.scan_table[*string] & 8U) == 0);
        if (skipto == *string) {
          scanner->lineno = scanner->lineno + iVar3;
          return string;
        }
        string = string + 1;
      } while (string < scanner->end);
    }
    puVar2 = (uchar *)0x0;
  }
  return puVar2;
}



void __regparm3 set_sgml_incomplete(dom_scanner *scanner,dom_scanner_token *token)

{
  uchar *__s;
  uchar *puVar1;
  
  puVar1 = scanner->end + -(int)scanner->position;
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(puVar1 == (uchar *)0x0), puVar1 == (uchar *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
    errline = 0x6f;
    elinks_internal((uchar *)"assertion left > 0 failed!");
  }
  token->type = 0x117;
  __s = scanner->position;
  (token->string).string = __s;
  if (puVar1 == (uchar *)0xffffffff) {
    puVar1 = (uchar *)strlen((char *)__s);
  }
  *(uchar **)&(token->string).length = puVar1;
  scanner->position = scanner->end;
  return;
}



dom_scanner_token * __regparm3 set_sgml_error(dom_scanner *scanner,uchar *end)

{
  dom_scanner *pdVar1;
  uchar *__s;
  dom_scanner *pdVar2;
  dom_scanner_info *pdVar3;
  bool bVar4;
  
  pdVar1 = (dom_scanner *)scanner->current;
  pdVar2 = pdVar1;
  if (assert_failed == 0) {
    bVar4 = scanner->found_error != 0;
    assert_failed = ZEXT14(bVar4);
    if (!bVar4) {
      pdVar2 = (dom_scanner *)scanner->current;
      goto LAB_080a8b86;
    }
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
    errline = 0xb4;
    elinks_internal((uchar *)"assertion !scanner->found_error failed!");
    pdVar2 = (dom_scanner *)scanner->current;
    if (scanner + 1 <= pdVar2) goto LAB_080a8c28;
  }
  else {
LAB_080a8b86:
    if (scanner + 1 <= pdVar2) {
LAB_080a8c28:
      scanner->found_error = 1;
      pdVar3 = (dom_scanner_info *)0x0;
      goto LAB_080a8bb7;
    }
  }
  pdVar3 = (dom_scanner_info *)&pdVar2->info;
  *(dom_scanner_info **)&scanner->current = pdVar3;
  pdVar2->info = (dom_scanner_info *)pdVar1->string;
  *(uchar **)&pdVar2->field_0x18 = pdVar1->end;
  *(uchar **)&pdVar2->found_error = pdVar1->position;
  ((dom_string *)&pdVar2->field_0x20)->length = ((dom_string *)&pdVar1->current)->length;
  *(uchar **)&pdVar2->lineno = (uchar *)pdVar1->tokens;
LAB_080a8bb7:
  pdVar1->string = (uchar *)0x118;
  pdVar1->position = (uchar *)scanner->lineno;
  __s = scanner->position;
  end = end + -(int)__s;
  *(uchar **)&pdVar1->tokens = __s;
  if (end == (uchar *)0xffffffff) {
    end = (uchar *)strlen((char *)__s);
  }
  *(uchar **)&((dom_string *)&pdVar1->current)->length = end;
  return (dom_scanner_token *)pdVar3;
}



uchar * __regparm3 skip_sgml(dom_scanner *scanner,uchar **string,int check_quoting)

{
  byte bVar1;
  byte *pbVar2;
  byte *__s;
  int iVar3;
  byte *pbVar4;
  
  __s = *string;
  pbVar4 = scanner->end;
LAB_080a8c58:
  do {
    if (pbVar4 <= __s) {
LAB_080a8d10:
      *string = __s;
      return (uchar *)0x0;
    }
    while( true ) {
      bVar1 = *__s;
      if (bVar1 == 0x3e) {
        *string = __s + 1;
        return __s;
      }
      if (bVar1 == 0x3c) goto LAB_080a8d10;
      if ((check_quoting == 0) || ((bVar1 != 0x27 && (bVar1 != 0x22)))) break;
      __s = __s + 1;
      if (assert_failed == 0) {
        if ((__s < scanner->position) || (pbVar4 < __s)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
          errline = 0x131;
          elinks_internal((uchar *)
                          "assertion string >= scanner->position && string <= scanner->end failed!")
          ;
          pbVar4 = scanner->end;
          goto LAB_080a8cdc;
        }
        assert_failed = 0;
        pbVar4 = scanner->end;
        if ((*(byte *)&scanner->field_0x20 & 1) != 0) goto LAB_080a8d70;
LAB_080a8ce6:
        pbVar2 = (byte *)memchr(__s,(uint)bVar1,(size_t)(pbVar4 + -(int)__s));
      }
      else {
LAB_080a8cdc:
        if ((*(byte *)&scanner->field_0x20 & 1) == 0) goto LAB_080a8ce6;
LAB_080a8d70:
        if (pbVar4 <= __s) goto LAB_080a8d10;
        iVar3 = 0;
        pbVar2 = __s;
        while (iVar3 = (iVar3 + 1) - (uint)((sgml_scanner_info.scan_table[*pbVar2] & 8U) == 0),
              bVar1 != *pbVar2) {
          pbVar2 = pbVar2 + 1;
          if (pbVar4 <= pbVar2) goto LAB_080a8c58;
        }
        scanner->lineno = scanner->lineno + iVar3;
      }
      if (pbVar2 != (byte *)0x0) {
        __s = pbVar2 + 1;
      }
      if (pbVar4 <= __s) goto LAB_080a8d10;
    }
    if (((*(byte *)&scanner->field_0x20 & 1) != 0) &&
       ((*(byte *)(sgml_scanner_info.scan_table + (uint)bVar1) & 8) != 0)) {
      scanner->lineno = scanner->lineno + 1;
    }
    __s = __s + 1;
  } while( true );
}



dom_scanner_token * scan_sgml_tokens(dom_scanner *scanner)

{
  dom_scanner_token *__dest;
  uchar **ppuVar1;
  dom_scanner_token *pdVar2;
  uint uVar3;
  size_t __n;
  dom_scanner *pdVar4;
  int iVar5;
  uint uVar6;
  dom_scanner_token *token;
  byte bVar7;
  byte *end;
  byte skipto;
  byte *ident;
  uchar *puVar8;
  int iVar9;
  byte *end_00;
  uchar *puVar10;
  byte *string;
  bool bVar11;
  bool bVar12;
  int local_3c;
  byte *local_34;
  dom_scanner *local_30;
  byte *local_20 [4];
  
  __dest = scanner->table;
  pdVar2 = scanner->current;
  iVar9 = ((int)scanner + ((scanner->tokens * 0x14 + 0x2c) - (int)pdVar2) >> 2) * -0x33333333;
  token = pdVar2;
  if (iVar9 < 1) {
    iVar9 = 0;
    token = __dest;
  }
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(pdVar2 == (dom_scanner_token *)0x0), pdVar2 == (dom_scanner_token *)0x0
     )) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
    errline = 0xfb;
    elinks_internal((uchar *)"assertion scanner->current failed!");
  }
  __n = 200;
  if (iVar9 != 0) {
    memmove(__dest,token,iVar9 * 0x14);
    token = scanner->table + iVar9;
    __n = iVar9 * -0x14 + 200;
  }
  memset(token,0,__n);
  if (scanner->position == (uchar *)0x0) {
    if (iVar9 == 0) {
      iVar9 = -1;
    }
    scanner->tokens = iVar9;
    scanner->current = __dest;
    if (assert_failed == 0) {
      if ((iVar9 < 10) || (scanner->table + 1 < scanner->table + iVar9)) {
        assert_failed = 0;
      }
      else {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
        errline = 0x10a;
        elinks_internal((uchar *)"assertion check_dom_scanner(scanner) failed!");
      }
    }
    iVar9 = scanner->tokens;
  }
  else {
    scanner->tokens = iVar9;
    if (__dest != (dom_scanner_token *)0x0) {
      pdVar4 = scanner + 1;
      local_30 = (dom_scanner *)(scanner->table + iVar9);
      *(dom_scanner **)&scanner->current = local_30;
joined_r0x080a8e88:
      if (pdVar4 <= local_30) {
joined_r0x080a92e5:
        if ((assert_failed == 0) && (assert_failed = ZEXT14(pdVar4 < local_30), pdVar4 < local_30))
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
          errline = 0x11a;
          elinks_internal((uchar *)"assertion end <= scanner->table + DOM_SCANNER_TOKENS failed!");
        }
        iVar9 = (int)((int)local_30 - (int)__dest) >> 2;
        iVar5 = iVar9 * -0x33333333;
        scanner->tokens = iVar5;
        scanner->current = __dest;
        if (scanner->end <= scanner->position) {
          scanner->position = (uchar *)0x0;
        }
        if (assert_failed == 0) {
          if ((iVar5 < 10) ||
             (scanner->current + 1 < (dom_scanner_token *)(&scanner->table[0].type + iVar9))) {
            assert_failed = 0;
          }
          else {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
            errline = 0x121;
            elinks_internal((uchar *)"assertion check_dom_scanner(scanner) failed!");
          }
        }
        if (scanner->tokens < 1) {
          return (dom_scanner_token *)0x0;
        }
        if (scanner->table + scanner->tokens <= scanner->current) {
          return (dom_scanner_token *)0x0;
        }
        return scanner->current;
      }
      string = scanner->position;
      ident = scanner->end;
      if (ident <= string) goto joined_r0x080a92e5;
      local_3c = scanner->state;
      if (local_3c != 1) {
        skipto = *string;
        if (skipto == 0x3c) {
          if (local_3c == 2) goto LAB_080a9080;
          goto LAB_080a9160;
        }
        if (local_3c != 0) {
LAB_080a9080:
          *(byte **)&local_30->tokens = string;
          do {
            string = string + 1;
            if (assert_failed != 0) {
LAB_080a909f:
              if ((*(byte *)&scanner->field_0x20 & 1) == 0) goto LAB_080a90a5;
LAB_080a911a:
              local_34 = scanner->end;
              if (string < local_34) {
                iVar9 = 0;
                while (iVar9 = (iVar9 + 1) -
                               (uint)((sgml_scanner_info.scan_table[*string] & 8U) == 0),
                      *string != 0x3e) {
                  string = string + 1;
                  if (local_34 <= string) goto LAB_080a92f8;
                }
                scanner->lineno = scanner->lineno + iVar9;
                goto LAB_080a90c0;
              }
LAB_080a92f8:
              ident = (byte *)0xffffffff;
              goto LAB_080a92fd;
            }
            if ((scanner->position <= string) && (string < scanner->end || string == scanner->end))
            {
              assert_failed = 0;
              goto LAB_080a909f;
            }
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
            errline = 0x131;
            elinks_internal((uchar *)
                            "assertion string >= scanner->position && string <= scanner->end failed!"
                           );
            if ((*(byte *)&scanner->field_0x20 & 1) != 0) goto LAB_080a911a;
LAB_080a90a5:
            local_34 = scanner->end;
            string = (byte *)memchr(string,0x3e,(size_t)(local_34 + -(int)string));
LAB_080a90c0:
            if (string == (byte *)0x0) goto LAB_080a92f8;
          } while (string[-1] != 0x3f);
          string = string + 1;
          ident = string + (-2 - (int)local_30->tokens);
          if (string == (byte *)0x0) {
LAB_080a92fd:
            if ((*(byte *)&scanner->field_0x18 & 3) == 3) goto LAB_080a93e1;
            uVar6 = scanner->found_error;
            scanner->found_error = 0;
            string = local_34;
            if (((uVar6 == 0 & *(byte *)&scanner->field_0x18 >> 2) == 0) ||
               (local_30 = (dom_scanner *)set_sgml_error(scanner,local_34),
               local_30 != (dom_scanner *)0x0)) goto LAB_080a9330;
          }
          else {
LAB_080a9330:
            local_34 = string;
            local_30->string = (uchar *)0x10d;
            if ((int)ident < 0) {
              ident = local_34 + -(int)local_30->tokens;
            }
            *(byte **)&((dom_string *)&local_30->current)->length = ident;
            local_30->end = (uchar *)0x0;
            scanner->state = 0;
            scanner->position = local_34;
          }
LAB_080a935b:
          token = scanner->current;
          goto LAB_080a8f4a;
        }
        *(byte **)&local_30->tokens = string;
        ident = string + 1;
        if (skipto != 0x26) {
          if ((sgml_scanner_info.scan_table[skipto] & 0x10U) != 0) {
            bVar7 = *(byte *)&scanner->field_0x20;
            if ((bVar7 & 1) == 0) {
              string = scanner->end;
              while (ident < string) {
                uVar6 = sgml_scanner_info.scan_table[*ident];
                if ((uVar6 & 0x10) == 0) goto joined_r0x080a9570;
                ident = ident + 1;
              }
            }
            else {
              if ((sgml_scanner_info.scan_table[skipto] & 8U) != 0) {
                scanner->lineno = scanner->lineno + 1;
              }
              string = scanner->end;
              while (ident < string) {
                uVar6 = sgml_scanner_info.scan_table[*ident];
                if ((uVar6 & 0x10) == 0) goto joined_r0x080a9570;
                if ((uVar6 & 8) != 0) {
                  scanner->lineno = scanner->lineno + 1;
                }
                ident = ident + 1;
              }
            }
            goto LAB_080a9448;
          }
          string = scanner->end;
          puVar10 = (uchar *)0x114;
          bVar7 = *(byte *)&scanner->field_0x20;
          goto LAB_080a8eee;
        }
        end_00 = ident;
        if ((*(byte *)(sgml_scanner_info.scan_table + string[1]) & 2) == 0) {
          string = (byte *)0xffffffff;
          puVar10 = (uchar *)0x116;
        }
        else {
          if (ident < scanner->end) {
            do {
              end_00 = end_00 + 1;
              if (scanner->end <= end_00) break;
            } while ((*(byte *)(sgml_scanner_info.scan_table + *end_00) & 2) != 0);
            string = end_00 + -(int)ident;
          }
          else {
            string = (byte *)0x0;
          }
          *(byte **)&local_30->tokens = ident;
          puVar10 = (uchar *)0x113;
        }
        ident = scanner->end;
        if ((end_00 < ident) && (skipto = *end_00, skipto != 0x3c)) {
          while (skipto != 0x26) {
            if (skipto == 0x3b) {
              local_30->string = puVar10;
              ident = end_00 + 1;
              goto joined_r0x080a94fc;
            }
            end_00 = end_00 + 1;
            if ((ident <= end_00) || (skipto = *end_00, skipto == 0x3c)) break;
          }
        }
        if (((*(byte *)&scanner->field_0x18 & 3) == 3) && (end_00 == ident)) goto LAB_080a93e1;
        uVar6 = scanner->found_error;
        scanner->found_error = 0;
        ident = end_00;
        if ((uVar6 == 0 & *(byte *)&scanner->field_0x18 >> 2) == 0) {
          local_30->string = puVar10;
        }
        else {
          local_30 = (dom_scanner *)set_sgml_error(scanner,end_00);
          if (local_30 == (dom_scanner *)0x0) goto LAB_080a935b;
          local_30->string = puVar10;
        }
joined_r0x080a94fc:
        if ((int)string < 0) goto LAB_080a8f2f;
        goto LAB_080a8f37;
      }
LAB_080a9160:
      if ((*(byte *)&scanner->field_0x20 & 1) == 0) {
        while ((string < ident && ((*(byte *)(sgml_scanner_info.scan_table + *string) & 0x10) != 0))
              ) {
          string = string + 1;
        }
LAB_080a9194:
        scanner->position = string;
        if (scanner->end < string || scanner->end == string) {
LAB_080a92d7:
          local_30 = (dom_scanner *)scanner->current;
          goto joined_r0x080a92e5;
        }
      }
      else {
        while (string < ident) {
          if ((sgml_scanner_info.scan_table[*string] & 0x10U) == 0) goto LAB_080a9194;
          if ((sgml_scanner_info.scan_table[*string] & 8U) != 0) {
            scanner->lineno = scanner->lineno + 1;
          }
          string = string + 1;
        }
        scanner->position = string;
        if (scanner->end < string || scanner->end == string) goto LAB_080a92d7;
      }
      token = scanner->current;
      local_20[0] = string + 1;
      skipto = *string;
      (token->string).string = string;
      if (skipto == 0x3c) {
        local_34 = local_20[0];
        if ((*(byte *)&scanner->field_0x20 & 1) == 0) {
          if (local_20[0] < scanner->end) {
            skipto = *(byte *)(sgml_scanner_info.scan_table + *local_20[0]);
            while (((skipto & 0x10) != 0 && (local_34 = local_34 + 1, local_34 < scanner->end))) {
              skipto = *(byte *)(sgml_scanner_info.scan_table + *local_34);
            }
          }
        }
        else {
          if (local_20[0] < scanner->end) {
            uVar6 = sgml_scanner_info.scan_table[*local_20[0]];
            while (local_34 = local_20[0], (uVar6 & 0x10) != 0) {
              if ((uVar6 & 8) != 0) {
                scanner->lineno = scanner->lineno + 1;
              }
              local_34 = local_20[0] + 1;
              if (scanner->end <= local_34) break;
              uVar6 = sgml_scanner_info.scan_table[*local_34];
              local_20[0] = local_34;
            }
          }
        }
        local_20[0] = local_34;
        if (scanner->state == 1) {
          local_20[0] = (token->string).string;
          local_3c = 0;
          local_34 = (byte *)0x0;
          local_30 = (dom_scanner *)0x101;
          goto LAB_080a9258;
        }
        if (scanner->end == local_34) goto LAB_080a9209;
        skipto = *local_34;
        if ((*(byte *)(sgml_scanner_info.scan_table + skipto) & 4) == 0) {
          if (skipto == 0x21) {
            local_20[0] = local_34 + 1;
            skip_sgml_space(scanner,local_20);
            ident = local_20[0];
            (token->string).string = local_20[0];
            end_00 = scanner->end;
            string = local_20[0] + 1;
            if (((string < end_00) && (*local_20[0] == 0x2d)) && (*string == 0x2d)) {
              string = local_20[0] + 2;
              (token->string).string = string;
              local_20[0] = string;
              while (puVar10 = skip_sgml_chars(scanner,string,'>'), puVar10 != (uchar *)0x0) {
                if (puVar10[-2] == '-') {
                  if (puVar10[-1] == '-') {
                    if (local_20[0] <= puVar10 + -2) {
                      local_34 = puVar10 + -2 + -(int)local_20[0];
                      goto LAB_080aa112;
                    }
                  }
                  else {
                    if (((puVar10[-1] == '!') && (puVar10[-3] == '-')) &&
                       (local_20[0] <= puVar10 + -3)) {
                      local_34 = puVar10 + -3 + -(int)local_20[0];
LAB_080aa112:
                      string = puVar10 + 1;
                      bVar12 = false;
                      if (string != (byte *)0x0) goto LAB_080aa11c;
                      break;
                    }
                  }
                }
                string = puVar10 + 1;
              }
              string = scanner->end;
              bVar12 = true;
              local_34 = string + -(int)local_20[0];
LAB_080aa11c:
              local_20[0] = string;
              if ((assert_failed == 0) &&
                 (assert_failed = -((int)local_34 >> 0x1f), assert_failed != 0)) {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
                errline = 0x1f7;
                elinks_internal((uchar *)"assertion real_length >= 0 failed!");
                local_30 = (dom_scanner *)0x104;
              }
              else {
                local_30 = (dom_scanner *)0x104;
              }
            }
            else {
              if ((end_00 <= local_20[0] + 6) ||
                 (iVar9 = memcmp(local_20[0],&DAT_0812cc5f,7), iVar9 != 0)) {
                end = ident;
                if ((ident < end_00) &&
                   ((*(byte *)(sgml_scanner_info.scan_table + *ident) & 4) != 0)) {
                  while ((end = string, local_20[0] = string, string < scanner->end &&
                         ((*(byte *)(sgml_scanner_info.scan_table + *string) & 4) != 0))) {
                    string = string + 1;
                  }
                }
                local_30 = (dom_scanner *)map_dom_scanner_string(scanner,ident,end,0x103);
                puVar10 = skip_sgml(scanner,local_20,0);
                if (puVar10 != (uchar *)0x0) {
                  local_34 = (byte *)0xffffffff;
                  goto LAB_080a9258;
                }
                goto LAB_080a9926;
              }
              ident = ident + 7;
              (token->string).string = ident;
              local_20[0] = ident;
              while (puVar10 = skip_sgml_chars(scanner,ident,'>'), puVar10 != (uchar *)0x0) {
                if ((puVar10[-2] == ']') && (puVar10[-1] == ']')) {
                  string = puVar10 + 1;
                  if (string != (byte *)0x0) {
                    bVar12 = false;
                    local_34 = puVar10 + (-2 - (int)local_20[0]);
                    goto LAB_080a9ee3;
                  }
                  break;
                }
                ident = puVar10 + 1;
              }
              string = scanner->end;
              bVar12 = true;
              local_34 = string + -(int)local_20[0];
LAB_080a9ee3:
              local_20[0] = string;
              if ((assert_failed == 0) &&
                 (assert_failed = -((int)local_34 >> 0x1f), assert_failed != 0)) {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
                errline = 0x201;
                elinks_internal((uchar *)"assertion real_length >= 0 failed!");
                local_30 = (dom_scanner *)0x109;
              }
              else {
                local_30 = (dom_scanner *)0x109;
              }
            }
            goto LAB_080a95cd;
          }
          if (skipto != 0x3f) {
            if (skipto == 0x2f) {
              local_20[0] = local_34 + 1;
              skip_sgml_space(scanner,local_20);
              if (scanner->end != local_20[0]) {
                if ((*(byte *)(sgml_scanner_info.scan_table + *local_20[0]) & 4) == 0) {
                  if (*local_20[0] != 0x3e) goto LAB_080a9209;
                  local_20[0] = local_20[0] + 1;
                  bVar12 = false;
                  local_34 = (byte *)0x0;
                }
                else {
                  (token->string).string = local_20[0];
                  string = local_20[0];
                  if ((local_20[0] < scanner->end) &&
                     ((*(byte *)(sgml_scanner_info.scan_table + *local_20[0]) & 4) != 0)) {
                    do {
                      local_20[0] = local_20[0] + 1;
                      if (scanner->end <= local_20[0]) break;
                    } while ((*(byte *)(sgml_scanner_info.scan_table + *local_20[0]) & 4) != 0);
                    string = (token->string).string;
                  }
                  local_34 = local_20[0] + -(int)string;
                  puVar10 = skip_sgml(scanner,local_20,1);
                  bVar12 = puVar10 == (uchar *)0x0;
                }
                local_3c = 0;
                local_30 = (dom_scanner *)0x110;
                goto LAB_080a95cd;
              }
            }
            else {
              puVar10 = skip_sgml(scanner,local_20,0);
              if (puVar10 != (uchar *)0x0) {
                local_34 = (byte *)0xffffffff;
                local_30 = (dom_scanner *)0x116;
                goto LAB_080a9258;
              }
            }
            goto LAB_080a9209;
          }
          local_20[0] = local_34 + 1;
          skip_sgml_space(scanner,local_20);
          string = local_20[0];
          (token->string).string = local_20[0];
          if (local_20[0] < scanner->end) {
            do {
              if ((*(byte *)(sgml_scanner_info.scan_table + *local_20[0]) & 4) == 0) break;
              local_20[0] = local_20[0] + 1;
            } while (local_20[0] < scanner->end);
          }
          bVar12 = true;
          local_30 = (dom_scanner *)map_dom_scanner_string(scanner,string,local_20[0],0x10a);
          local_34 = local_20[0] + -(int)(token->string).string;
          skip_sgml_space(scanner,local_20);
          if ((*(byte *)(sgml_scanner_info.scan_table + local_20[0][-1]) & 0x10) != 0) {
            bVar12 = scanner->end <= local_20[0];
          }
          uVar6 = (uint)*(byte *)&scanner->field_0x18;
          local_3c = 2;
          if ((*(byte *)&scanner->field_0x18 & 3) != 3) goto LAB_080a95cd;
          if ((pdVar4 <= (dom_scanner *)(token + 1)) || (string = local_20[0], bVar12)) {
LAB_080aa0d5:
            local_20[0] = scanner->end;
            local_3c = 2;
            skipto = (byte)uVar6 & 3;
            goto joined_r0x080a95e1;
          }
          do {
            string = skip_sgml_chars(scanner,string + 1,'>');
            if (string == (byte *)0x0) {
              uVar6 = (uint)*(byte *)&scanner->field_0x18;
              goto LAB_080aa0d5;
            }
          } while (string[-1] != 0x3f);
          local_3c = 2;
        }
        else {
          (token->string).string = local_34;
          if ((local_34 <= scanner->end && scanner->end != local_34) &&
             ((*(byte *)(sgml_scanner_info.scan_table + *local_34) & 4) != 0)) {
            do {
              local_34 = local_34 + 1;
              local_20[0] = local_34;
              if (scanner->end <= local_34) {
                local_34 = (token->string).string;
                goto LAB_080a99c2;
              }
            } while ((*(byte *)(sgml_scanner_info.scan_table + *local_34) & 4) != 0);
            local_34 = (token->string).string;
          }
LAB_080a99c2:
          local_34 = local_20[0] + -(int)local_34;
          skip_sgml_space(scanner,local_20);
          if ((scanner->end < local_20[0] || scanner->end == local_20[0]) || (*local_20[0] != 0x3e))
          {
            if ((*(byte *)(sgml_scanner_info.scan_table + local_20[0][-1]) & 0x10) == 0) {
              uVar6 = (uint)*(byte *)&scanner->field_0x18;
              local_3c = 1;
              local_30 = (dom_scanner *)0x10f;
              skipto = *(byte *)&scanner->field_0x18 & 3;
              goto joined_r0x080a95e1;
            }
            local_3c = 1;
            local_30 = (dom_scanner *)0x10f;
          }
          else {
            local_20[0] = local_20[0] + 1;
            local_30 = (dom_scanner *)0x10e;
          }
        }
LAB_080a9258:
        scanner->state = local_3c;
        *(dom_scanner **)&token->type = local_30;
        if ((int)local_34 < 0) {
          local_34 = local_20[0] + -(int)(token->string).string;
        }
        *(byte **)&(token->string).length = local_34;
        iVar9 = 0x800;
        if ((local_30 != (dom_scanner *)0x3c) && (iVar9 = 0, local_30 == (dom_scanner *)0x3e)) {
          iVar9 = 0x400;
        }
        token->precedence = iVar9;
        scanner->position = local_20[0];
      }
      else {
        if (skipto == 0x3d) {
          local_34 = (byte *)0xffffffff;
          local_30 = (dom_scanner *)0x3d;
          goto LAB_080a9258;
        }
        if ((byte)(skipto - 0x3e) < 2) {
          if (skipto == 0x3f) {
            puVar10 = skip_sgml(scanner,local_20,0);
            bVar12 = puVar10 == (uchar *)0x0;
            if (assert_failed == 0) goto LAB_080a95a2;
LAB_080a95b8:
            local_3c = 0;
            local_34 = (byte *)0xffffffff;
            local_30 = (dom_scanner *)0x101;
          }
          else {
            if (assert_failed != 0) {
              local_34 = (byte *)0xffffffff;
              local_3c = 0;
              local_30 = (dom_scanner *)0x101;
              goto LAB_080a9258;
            }
            bVar12 = false;
LAB_080a95a2:
            bVar11 = scanner->state != 1;
            assert_failed = ZEXT14(bVar11);
            if (!bVar11) goto LAB_080a95b8;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
            errline = 0x274;
            elinks_internal((uchar *)"assertion scanner->state == SGML_STATE_ELEMENT failed!");
            local_3c = 0;
            local_34 = (byte *)0xffffffff;
            local_30 = (dom_scanner *)0x101;
          }
LAB_080a95cd:
          if (!bVar12) goto LAB_080a9258;
          uVar6 = (uint)*(byte *)&scanner->field_0x18;
          skipto = *(byte *)&scanner->field_0x18 & 3;
joined_r0x080a95e1:
          if (skipto == 3) goto LAB_080a95e7;
LAB_080a9229:
          uVar3 = scanner->found_error;
          scanner->found_error = 0;
          if (((uVar6 >> 2 & (uint)(uVar3 == 0)) == 0) ||
             (string = scanner->end, string != local_20[0])) goto LAB_080a9258;
          switch(local_30) {
          case (dom_scanner *)0x104:
            ident = scanner->position + 4;
            break;
          case (dom_scanner *)0x105:
          case (dom_scanner *)0x106:
          case (dom_scanner *)0x108:
          case (dom_scanner *)0x109:
            ident = scanner->position + 9;
            if (string <= scanner->position + 9) {
              ident = string;
            }
            goto LAB_080a9b15;
          case (dom_scanner *)0x107:
            ident = scanner->position + 6;
            break;
          default:
            goto switchD_080a9b02_caseD_10a;
          case (dom_scanner *)0x10b:
            ident = scanner->position + 5;
            break;
          case (dom_scanner *)0x10c:
            ident = scanner->position + 0x10;
          }
          if (local_20[0] <= ident) {
switchD_080a9b02_caseD_10a:
            ident = string;
          }
LAB_080a9b15:
          token = set_sgml_error(scanner,ident);
          if (token != (dom_scanner_token *)0x0) goto LAB_080a9258;
        }
        else {
          if (skipto == 0x2f) {
            if (local_20[0] != scanner->end) {
              if (*local_20[0] == 0x3e) {
                local_20[0] = string + 2;
                if ((assert_failed == 0) &&
                   (bVar12 = scanner->state != 1, assert_failed = ZEXT14(bVar12), bVar12)) {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
                  local_3c = 0;
                  errline = 0x288;
                  elinks_internal((uchar *)"assertion scanner->state == SGML_STATE_ELEMENT failed!")
                  ;
                  local_34 = (byte *)0x0;
                  local_30 = (dom_scanner *)0x111;
                }
                else {
                  local_3c = 0;
                  local_34 = (byte *)0x0;
                  local_30 = (dom_scanner *)0x111;
                }
              }
              else {
                if ((*(byte *)(sgml_scanner_info.scan_table + *local_20[0]) & 0x50) != 0)
                goto LAB_080a9209;
                if (local_20[0] < scanner->end) {
                  string = string + 2;
                  do {
                    local_20[0] = string;
                    if (scanner->end <= local_20[0]) break;
                    string = local_20[0] + 1;
                  } while ((*(byte *)(sgml_scanner_info.scan_table + *local_20[0]) & 0x50) == 0);
                }
                if ((local_20[0][-1] != 0x2f) || (*local_20[0] != 0x3e)) goto LAB_080a9810;
                local_34 = (byte *)0xffffffff;
                local_30 = (dom_scanner *)0x112;
                local_20[0] = local_20[0] + -1;
              }
              goto LAB_080a9258;
            }
LAB_080a9209:
            uVar6 = (uint)*(byte *)&scanner->field_0x18;
            local_34 = (byte *)0xffffffff;
            local_30 = (dom_scanner *)0x116;
            skipto = *(byte *)&scanner->field_0x18 & 3;
            goto joined_r0x080a95e1;
          }
          if ((skipto != 0x27) && (skipto != 0x22)) {
            if ((sgml_scanner_info.scan_table[skipto] & 0x50U) != 0) goto LAB_080a9209;
            if ((sgml_scanner_info.scan_table[skipto] & 4U) == 0) {
              if (scanner->end <= local_20[0]) goto LAB_080a9209;
              local_30 = (dom_scanner *)0x116;
              uVar6 = sgml_scanner_info.scan_table[*local_20[0]];
            }
            else {
              if (scanner->end <= local_20[0]) {
LAB_080a9690:
                uVar6 = (uint)*(byte *)&scanner->field_0x18;
                local_34 = (byte *)0xffffffff;
                local_30 = (dom_scanner *)0x100;
                skipto = *(byte *)&scanner->field_0x18 & 3;
                goto joined_r0x080a95e1;
              }
              uVar6 = sgml_scanner_info.scan_table[*local_20[0]];
              if ((uVar6 & 4) != 0) {
                string = string + 2;
                do {
                  local_20[0] = string;
                  if (scanner->end <= local_20[0]) goto LAB_080a9690;
                  uVar6 = sgml_scanner_info.scan_table[*local_20[0]];
                  string = local_20[0] + 1;
                } while ((uVar6 & 4) != 0);
              }
              local_30 = (dom_scanner *)0x100;
            }
            if ((uVar6 & 0x50) == 0) {
              do {
                string = local_20[0];
                local_20[0] = string + 1;
                if (scanner->end <= local_20[0]) break;
              } while ((*(byte *)(sgml_scanner_info.scan_table + string[1]) & 0x50) == 0);
              if ((*string != 0x2f) || (*local_20[0] != 0x3e)) goto LAB_080a9810;
              local_34 = (byte *)0xffffffff;
              local_30 = (dom_scanner *)0x112;
              local_20[0] = string;
              goto LAB_080a9258;
            }
LAB_080a9926:
            uVar6 = (uint)*(byte *)&scanner->field_0x18;
            local_34 = (byte *)0xffffffff;
            skipto = *(byte *)&scanner->field_0x18 & 3;
            goto joined_r0x080a95e1;
          }
          puVar10 = skip_sgml_chars(scanner,local_20[0],skipto);
          if (puVar10 != (uchar *)0x0) {
            puVar8 = (token->string).string + 1;
            local_34 = puVar10 + -(int)puVar8;
            (token->string).string = puVar8;
            local_30 = (dom_scanner *)0x102;
            local_20[0] = puVar10 + 1;
            goto LAB_080a9258;
          }
          uVar6 = (uint)*(byte *)&scanner->field_0x18;
          skipto = *(byte *)&scanner->field_0x18 & 3;
          if (skipto != 3) {
            if ((scanner->end < local_20[0] || scanner->end == local_20[0]) ||
               ((*(byte *)(sgml_scanner_info.scan_table + *local_20[0]) & 0x50) != 0)) {
              local_34 = (byte *)0xffffffff;
              local_30 = (dom_scanner *)0x116;
            }
            else {
              ppuVar1 = &(token->string).string;
              *ppuVar1 = *ppuVar1 + 1;
              if (local_20[0] < scanner->end) {
                do {
                  if ((*(byte *)(sgml_scanner_info.scan_table + *local_20[0]) & 0x50) != 0) break;
                  local_20[0] = local_20[0] + 1;
                } while (local_20[0] < scanner->end);
              }
LAB_080a9810:
              uVar6 = (uint)*(byte *)&scanner->field_0x18;
              local_34 = (byte *)0xffffffff;
              local_30 = (dom_scanner *)0x112;
              skipto = *(byte *)&scanner->field_0x18 & 3;
            }
            goto joined_r0x080a95e1;
          }
          local_20[0] = scanner->end;
          local_34 = (byte *)0xffffffff;
          local_30 = (dom_scanner *)0x116;
LAB_080a95e7:
          if (scanner->end != local_20[0]) goto LAB_080a9229;
          set_sgml_incomplete(scanner,token);
        }
      }
      token = scanner->current;
      if (token->type == 0x119) {
        token = token + -1;
        scanner->current = token;
      }
      goto LAB_080a8f4a;
    }
  }
  if ((0 < iVar9) && (scanner->current < scanner->table + iVar9)) {
    return scanner->current;
  }
  return (dom_scanner_token *)0x0;
joined_r0x080a9570:
  puVar10 = (uchar *)0x114;
  if ((uVar6 & 0x20) != 0) {
LAB_080a9448:
    puVar10 = (uchar *)0x115;
  }
LAB_080a8eee:
  if ((bVar7 & 1) == 0) {
    while (((ident < string && (*ident != 0x3c)) && (*ident != 0x26))) {
      ident = ident + 1;
    }
  }
  else {
    while (ident < string) {
      skipto = *ident;
      if (skipto == 0x3c) {
        skipto = *(byte *)&scanner->field_0x18;
        goto joined_r0x080a93d2;
      }
      if (skipto == 0x26) break;
      if ((*(byte *)(sgml_scanner_info.scan_table + skipto) & 8) != 0) {
        scanner->lineno = scanner->lineno + 1;
      }
      ident = ident + 1;
    }
  }
  skipto = *(byte *)&scanner->field_0x18;
joined_r0x080a93d2:
  if (((skipto & 3) == 3) && (scanner->end == ident)) {
LAB_080a93e1:
    set_sgml_incomplete(scanner,(dom_scanner_token *)local_30);
    token = scanner->current;
  }
  else {
    local_30->string = puVar10;
LAB_080a8f2f:
    string = ident + -(int)local_30->tokens;
LAB_080a8f37:
    *(byte **)&((dom_string *)&local_30->current)->length = string;
    local_30->end = (uchar *)0x0;
    token = scanner->current;
    scanner->position = ident;
  }
LAB_080a8f4a:
  local_30 = (dom_scanner *)(token + 1);
  *(dom_scanner **)&scanner->current = local_30;
  goto joined_r0x080a8e88;
}



sgml_info * get_sgml_info(sgml_document_type doctype)

{
  sgml_info *psVar1;
  
  psVar1 = (sgml_info *)0x0;
  if (doctype < SGML_DOCTYPES) {
    psVar1 = sgml_info[doctype];
  }
  return psVar1;
}



int sgml_info_strcmp(void *key_,void *node_)

{
  size_t n;
  int iVar1;
  
  n = *(size_t *)node_;
  if ((int)*(size_t *)((int)key_ + 4) <= (int)*(size_t *)node_) {
    n = *(size_t *)((int)key_ + 4);
  }
  iVar1 = c_strncasecmp(*(char **)((int)key_ + 8),*(char **)((int)node_ + 4),n);
  if (iVar1 == 0) {
    iVar1 = *(int *)((int)key_ + 4) - *(int *)node_;
  }
  return iVar1;
}



void bzip2_close(stream_encoded *stream)

{
  void *p;
  
  p = stream->data;
  if (p != (void *)0x0) {
    BZ2_bzDecompressEnd(p);
    close(*(int *)((int)p + 0x30));
    mem_free(p);
    stream->data = (void *)0x0;
  }
  return;
}



int bzip2_read(stream_encoded *stream,uchar *buf,int len)

{
  void **ppvVar1;
  void *__fd;
  int iVar2;
  void *pvVar3;
  int *piVar4;
  undefined *puVar5;
  bool bVar6;
  
  ppvVar1 = (void **)stream->data;
  if (ppvVar1 == (void **)0x0) {
LAB_080aa314:
    iVar2 = -1;
  }
  else {
    if ((assert_failed == 0) && (assert_failed = ZEXT14(len < 1), len < 1)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/encoding/bzip2.c";
      errline = 0x59;
      elinks_internal((uchar *)"assertion len > 0 failed!");
    }
    iVar2 = 0;
    if (ppvVar1[0xd] == (void *)0x0) {
      *(int *)(ppvVar1 + 5) = len;
      *(uchar **)(ppvVar1 + 4) = buf;
      while( true ) {
        if (ppvVar1[1] == (void *)0x0) {
          __fd = ppvVar1[0xc];
          while (pvVar3 = (void *)read((int)__fd,ppvVar1 + 0xe,5000), pvVar3 == (void *)0xffffffff)
          {
            piVar4 = __errno_location();
            if (*piVar4 != 4) {
              if (*piVar4 != 0xb) goto LAB_080aa314;
              puVar5 = (undefined *)ppvVar1[5];
              goto joined_r0x080aa393;
            }
          }
          if (pvVar3 == (void *)0x0) goto LAB_080aa314;
          *(void ***)ppvVar1 = ppvVar1 + 0xe;
          ppvVar1[1] = pvVar3;
        }
        puVar5 = (undefined *)BZ2_bzDecompress(ppvVar1);
        if (puVar5 == &DAT_00000004) break;
        if (puVar5 != (undefined *)0x0) goto LAB_080aa314;
        if (ppvVar1[5] == (void *)0x0) {
joined_r0x080aa393:
          if (assert_failed == 0) {
            bVar6 = (void *)(len - (int)puVar5) != (void *)((int)ppvVar1[4] - (int)buf);
            assert_failed = ZEXT14(bVar6);
            if (bVar6) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/encoding/bzip2.c";
              errline = 0x7c;
              elinks_internal((uchar *)
                              "assertion len - data->fbz_stream.avail_out == data->fbz_stream.next_out - (char *) buf failed!"
                             );
            }
            puVar5 = (undefined *)ppvVar1[5];
          }
          return len - (int)puVar5;
        }
      }
      ppvVar1[0xd] = (void *)0x1;
      puVar5 = (undefined *)ppvVar1[5];
      goto joined_r0x080aa393;
    }
  }
  return iVar2;
}



int bzip2_open(stream_encoded *stream,int fd)

{
  undefined4 *p;
  int iVar1;
  undefined4 *puVar2;
  byte bVar3;
  
  bVar3 = 0;
  p = (undefined4 *)mem_alloc(0x13c0);
  stream->data = (void *)0x0;
  iVar1 = -1;
  if (p != (undefined4 *)0x0) {
    iVar1 = 0xc;
    puVar2 = p;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *puVar2 = 0;
      puVar2 = puVar2 + (uint)bVar3 * 0x3ffffffe + 1;
    }
    p[0xd] = 0;
    p[0xc] = fd;
    iVar1 = BZ2_bzDecompressInit(p,0,0);
    if (iVar1 == 0) {
      *(undefined4 **)&stream->data = p;
      iVar1 = 0;
    }
    else {
      mem_free(p);
      iVar1 = -1;
    }
  }
  return iVar1;
}



uchar * bzip2_decode_buffer(uchar *data,int len,int *new_len)

{
  uint uVar1;
  uchar *puVar2;
  int iVar3;
  bz_stream *pbVar4;
  uchar *local_50;
  bz_stream stream;
  
  iVar3 = 0xc;
  *new_len = 0;
  pbVar4 = &stream;
  while (iVar3 != 0) {
    iVar3 = iVar3 + -1;
    pbVar4->next_in = (char *)0x0;
    pbVar4 = (bz_stream *)&pbVar4->avail_in;
  }
  stream.next_in = (char *)data;
  stream.avail_in = len;
  iVar3 = BZ2_bzDecompressInit(&stream,0,0);
  local_50 = (uchar *)0x0;
  if (iVar3 != 0) {
    return (uchar *)0x0;
  }
  do {
    uVar1 = stream.total_out_lo32;
    if ((assert_failed == 0) &&
       (assert_failed = ZEXT14(stream.total_out_hi32 != 0), stream.total_out_hi32 != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/encoding/bzip2.c";
      errline = 0x9f;
      elinks_internal((uchar *)
                      "assertion !stream.total_out_hi32 failed: 64 bzip2 decoding not supported");
    }
    puVar2 = (uchar *)mem_realloc(local_50,uVar1 + 0x400);
    if (puVar2 == (uchar *)0x0) {
      BZ2_bzDecompressEnd(&stream);
      if (local_50 == (uchar *)0x0) {
        return (uchar *)0x0;
      }
LAB_080aa593:
      mem_free(local_50);
      return (uchar *)0x0;
    }
    stream.avail_out = 0x400;
    stream.next_out = (char *)(puVar2 + stream.total_out_lo32);
    iVar3 = BZ2_bzDecompress(&stream);
    if (iVar3 == 4) break;
    local_50 = puVar2;
    if (iVar3 != 0) {
      BZ2_bzDecompressEnd(&stream);
      goto LAB_080aa593;
    }
  } while (stream.avail_in != 0);
  BZ2_bzDecompressEnd(&stream);
  *new_len = stream.total_out_lo32;
  return puVar2;
}



void deflate_close(stream_encoded *stream)

{
  void *p;
  
  p = stream->data;
  if (p != (void *)0x0) {
    inflateEnd(p);
    close(*(int *)((int)p + 0x38));
    mem_free(p);
    stream->data = (void *)0x0;
  }
  return;
}



int deflate_read(stream_encoded *stream,uchar *buf,int len)

{
  byte bVar1;
  void **ppvVar2;
  void *__fd;
  int iVar3;
  int *piVar4;
  void *__buf;
  byte bVar5;
  void *pvVar6;
  bool bVar7;
  
  ppvVar2 = (void **)stream->data;
  if (ppvVar2 == (void **)0x0) {
LAB_080aa6ab:
    iVar3 = -1;
  }
  else {
    if ((assert_failed == 0) && (assert_failed = ZEXT14(len < 1), len < 1)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/encoding/deflate.c";
      errline = 100;
      elinks_internal((uchar *)"assertion len > 0 failed!");
    }
    iVar3 = 0;
    if ((*(byte *)(ppvVar2 + 0xf) & 1) == 0) {
      __buf = (void *)((int)ppvVar2 + 0x3d);
      pvVar6 = (void *)0x0;
      *(uchar **)(ppvVar2 + 3) = buf;
      *(int *)(ppvVar2 + 4) = len;
      do {
        if (ppvVar2[1] == (void *)0x0) {
          __fd = ppvVar2[0xe];
          while (pvVar6 = (void *)read((int)__fd,__buf,5000), pvVar6 == (void *)0xffffffff) {
            piVar4 = __errno_location();
            if (*piVar4 != 4) {
              if (*piVar4 != 0xb) goto LAB_080aa6ab;
              __buf = ppvVar2[4];
              goto joined_r0x080aa7c3;
            }
          }
          if (pvVar6 == (void *)0x0) goto LAB_080aa6ab;
          ppvVar2[1] = pvVar6;
          *ppvVar2 = __buf;
        }
        do {
          iVar3 = inflate(ppvVar2,2);
          if (iVar3 != -3) break;
          bVar5 = *(byte *)(ppvVar2 + 0xf);
          if (((bVar5 & 2) != 0) || ((uchar *)ppvVar2[3] != buf)) {
            bVar5 = bVar5 | 2;
            *(byte *)(ppvVar2 + 0xf) = bVar5;
            goto LAB_080aa7a6;
          }
          *(byte *)(ppvVar2 + 0xf) = bVar5 | 2;
          inflateEnd(ppvVar2);
          *(uchar **)(ppvVar2 + 3) = buf;
          *(int *)(ppvVar2 + 4) = len;
          ppvVar2[1] = pvVar6;
          *ppvVar2 = __buf;
          iVar3 = inflateInit2_(ppvVar2,0xfffffff1,"1.2.3.4",0x38);
        } while (iVar3 == 0);
        bVar1 = *(byte *)(ppvVar2 + 0xf);
        bVar5 = bVar1 | 2;
        *(byte *)(ppvVar2 + 0xf) = bVar5;
        if (iVar3 == 1) {
          __buf = ppvVar2[4];
          *(byte *)(ppvVar2 + 0xf) = bVar1 | 3;
          goto joined_r0x080aa7c3;
        }
        if (iVar3 != 0) {
LAB_080aa7a6:
          __buf = ppvVar2[4];
          *(byte *)(ppvVar2 + 0xf) = bVar5 | 1;
          goto joined_r0x080aa7c3;
        }
        if (ppvVar2[4] == (void *)0x0) {
          __buf = (void *)0x0;
joined_r0x080aa7c3:
          if (assert_failed == 0) {
            bVar7 = (void *)(len - (int)__buf) != (void *)((int)ppvVar2[3] - (int)buf);
            assert_failed = ZEXT14(bVar7);
            if (bVar7) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/encoding/deflate.c";
              errline = 0xa8;
              elinks_internal((uchar *)
                              "assertion len - data->deflate_stream.avail_out == data->deflate_stream.next_out - buf failed!"
                             );
            }
            __buf = ppvVar2[4];
          }
          return len - (int)__buf;
        }
      } while( true );
    }
  }
  return iVar3;
}



int deflate_gzip_open(stream_encoded *stream,int fd)

{
  undefined4 *p;
  int iVar1;
  undefined4 *puVar2;
  byte bVar3;
  
  bVar3 = 0;
  p = (undefined4 *)mem_alloc(0x13c8);
  stream->data = (void *)0x0;
  iVar1 = -1;
  if (p != (undefined4 *)0x0) {
    iVar1 = 0xe;
    puVar2 = p;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *puVar2 = 0;
      puVar2 = puVar2 + (uint)bVar3 * 0x3ffffffe + 1;
    }
    *(byte *)(p + 0xf) = *(byte *)(p + 0xf) & 0xfc;
    p[0xe] = fd;
    iVar1 = inflateInit2_(p,0x2f,"1.2.3.4",0x38);
    if (iVar1 == 0) {
      *(undefined4 **)&stream->data = p;
      iVar1 = 0;
    }
    else {
      mem_free(p);
      iVar1 = -1;
    }
  }
  return iVar1;
}



uchar * __regparm3 deflate_decode_buffer(int window_size,uchar *data,int len,int *new_len)

{
  uchar *puVar1;
  int iVar2;
  uchar *p;
  z_stream *pzVar3;
  z_stream stream;
  
  *new_len = 0;
  if (len != 0) {
    iVar2 = 0xe;
    pzVar3 = &stream;
    while (iVar2 != 0) {
      iVar2 = iVar2 + -1;
      pzVar3->next_in = (Bytef *)0x0;
      pzVar3 = (z_stream *)&pzVar3->avail_in;
    }
    stream.next_in = data;
    stream.avail_in = len;
    iVar2 = inflateInit2_(&stream,window_size,"1.2.3.4",0x38);
    if (iVar2 == 0) {
      p = (uchar *)0x0;
      do {
        puVar1 = (uchar *)mem_realloc(p,stream.total_out + 0x400);
        if (puVar1 == (uchar *)0x0) {
          inflateEnd(&stream);
          if (p == (uchar *)0x0) {
            return (uchar *)0x0;
          }
LAB_080aa9c3:
          mem_free(p);
          return (uchar *)0x0;
        }
        stream.avail_out = 0x400;
        stream.next_out = puVar1 + stream.total_out;
        iVar2 = inflate(&stream,2);
        if (iVar2 == 1) break;
        p = puVar1;
        if (iVar2 != 0) {
          inflateEnd(&stream);
          goto LAB_080aa9c3;
        }
      } while (stream.avail_in != 0);
      inflateEnd(&stream);
      *new_len = stream.total_out;
      return puVar1;
    }
  }
  return (uchar *)0x0;
}



uchar * deflate_gzip_decode_buffer(uchar *data,int len,int *new_len)

{
  uchar *puVar1;
  
  puVar1 = deflate_decode_buffer(0x2f,data,len,new_len);
  return puVar1;
}



uchar * deflate_raw_decode_buffer(uchar *data,int len,int *new_len)

{
  uchar *puVar1;
  
  puVar1 = deflate_decode_buffer(-0xf,data,len,new_len);
  return puVar1;
}



// WARNING: Exceeded maximum restarts with more pending

int read_encoded(stream_encoded *stream,uchar *data,int len)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x080aaa46. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*decoding_backends[stream->encoding]->read)();
  return iVar1;
}



// WARNING: Exceeded maximum restarts with more pending

uchar * decode_encoded_buffer(stream_encoding encoding,uchar *data,int len,int *new_len)

{
  uchar *puVar1;
  
                    // WARNING: Could not recover jumptable at 0x080aaa7b. Too many branches
                    // WARNING: Treating indirect jump as call
  puVar1 = (*decoding_backends[encoding]->decode_buffer)();
  return puVar1;
}



uchar ** listext_encoded(stream_encoding encoding)

{
  return decoding_backends[encoding]->extensions;
}



uchar * get_encoding_name(stream_encoding encoding)

{
  return decoding_backends[encoding]->name;
}



connection_state connection_state(void)

{
  int *in_EAX;
  int in_EDX;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(in_EDX == -1);
    if (in_EDX == -1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
      errline = 0x84;
      elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
      if (assert_failed != 0) goto LAB_080aab28;
    }
    in_EAX[1] = 0;
    *in_EAX = in_EDX;
    return (connection_state)CONCAT44(in_EDX,in_EAX);
  }
LAB_080aab28:
  assert_failed = 0;
  in_EAX[1] = 0;
  *in_EAX = -0x186a3;
  return (connection_state)CONCAT44(0xfffe795d,in_EAX);
}



void dummy_close(stream_encoded *stream)

{
  close(*(int *)stream->data);
  mem_free(stream->data);
  return;
}



void close_encoded(stream_encoded *stream)

{
  (*decoding_backends[stream->encoding]->close)(stream);
  mem_free(stream);
  return;
}



uchar * dummy_decode_buffer(uchar *data,int len,int *new_len)

{
  uchar *puVar1;
  
  puVar1 = memacpy(data,len);
  if (puVar1 != (uchar *)0x0) {
    *new_len = len;
  }
  return puVar1;
}



int dummy_read(stream_encoded *stream,uchar *data,int len)

{
  int __fd;
  ssize_t sVar1;
  int *piVar2;
  
  __fd = *(int *)stream->data;
  do {
    sVar1 = read(__fd,data,len);
    if (sVar1 != -1) {
      return sVar1;
    }
    piVar2 = __errno_location();
  } while (*piVar2 == 4);
  return -1;
}



int dummy_open(stream_encoded *stream,int fd)

{
  int *piVar1;
  int iVar2;
  
  piVar1 = (int *)mem_alloc(4);
  *(int **)&stream->data = piVar1;
  iVar2 = -1;
  if (piVar1 != (int *)0x0) {
    *piVar1 = fd;
    iVar2 = 0;
  }
  return iVar2;
}



stream_encoded * open_encoded(int fd,stream_encoding encoding)

{
  stream_encoded *p;
  int iVar1;
  stream_encoded *psVar2;
  
  p = (stream_encoded *)mem_alloc(8);
  psVar2 = p;
  if (p != (stream_encoded *)0x0) {
    p->encoding = encoding;
    iVar1 = (*decoding_backends[encoding]->open)(p,fd);
    if (iVar1 < 0) {
      psVar2 = (stream_encoded *)0x0;
      mem_free(p);
    }
  }
  return psVar2;
}



stream_encoding guess_encoding(uchar *filename)

{
  uchar *__s;
  size_t sVar1;
  size_t sVar2;
  int iVar3;
  uchar **ppuVar4;
  stream_encoding local_24;
  
  sVar1 = strlen((char *)filename);
  local_24 = ENCODING_GZIP;
  do {
    ppuVar4 = decoding_backends[local_24]->extensions;
    while ((ppuVar4 != (uchar **)0x0 && (__s = *ppuVar4, __s != (uchar *)0x0))) {
      sVar2 = strlen((char *)__s);
      if (((int)sVar2 <= (int)sVar1) &&
         (iVar3 = strcmp((char *)(filename + (sVar1 - sVar2)),(char *)__s), iVar3 == 0)) {
        return local_24;
      }
      ppuVar4 = ppuVar4 + 1;
    }
    local_24 = local_24 + ENCODING_GZIP;
    if (local_24 == ENCODINGS_KNOWN) {
      return ENCODING_NONE;
    }
  } while( true );
}



connection_state read_file(stream_encoded *stream,int readsize,string *page)

{
  string *psVar1;
  int iVar2;
  uchar *puVar3;
  void **ppvVar4;
  stream_encoding sVar5;
  stream_encoded *psVar6;
  uint size;
  uint uVar7;
  connection_state cVar8;
  string *in_stack_00000010;
  
  psVar1 = init_string(in_stack_00000010);
  if (psVar1 == (string *)0x0) {
    cVar8 = connection_state();
    psVar6 = (stream_encoded *)((ulonglong)cVar8 >> 0x20);
LAB_080aae83:
    return (connection_state)CONCAT44(psVar6,stream);
  }
  psVar1 = (string *)0x1000;
  if (page != (string *)0x0) {
    psVar1 = page;
  }
  iVar2 = in_stack_00000010->length;
  do {
    size = (int)&psVar1[0x20].source + iVar2 & 0xffffff00;
    uVar7 = iVar2 + 0xffU & 0xffffff00;
    if (uVar7 < size) {
      puVar3 = (uchar *)mem_realloc(in_stack_00000010->source,size);
      if (puVar3 == (uchar *)0x0) goto LAB_080aae20;
      in_stack_00000010->source = puVar3;
      memset(puVar3 + uVar7,0,size - uVar7);
    }
    if (in_stack_00000010->source == (uchar *)0x0) {
LAB_080aae20:
      done_string(in_stack_00000010);
      if (assert_failed == 0) {
        sVar5 = 0xfffe795c;
      }
      else {
        sVar5 = 0xfffe795d;
      }
      assert_failed = 0;
      stream->data = (void *)0x0;
      stream->encoding = sVar5;
      return (connection_state)CONCAT44(stream,stream);
    }
    iVar2 = (*decoding_backends[*(int *)readsize]->read)
                      ((stream_encoded *)readsize,
                       in_stack_00000010->source + in_stack_00000010->length,(int)psVar1);
    if (iVar2 < 0) {
      done_string(in_stack_00000010);
      ppvVar4 = (void **)__errno_location();
      if (*ppvVar4 == (void *)0x0) {
        cVar8 = connection_state();
        psVar6 = (stream_encoded *)((ulonglong)cVar8 >> 0x20);
      }
      else {
        stream->data = *ppvVar4;
        stream->encoding = ~ENCODING_NONE;
        psVar6 = stream;
      }
      goto LAB_080aae83;
    }
    if (iVar2 == 0) {
      puVar3 = in_stack_00000010->source;
      puVar3[in_stack_00000010->length] = '\0';
      if (assert_failed == 0) {
        sVar5 = 0xfffe7960;
      }
      else {
        sVar5 = 0xfffe795d;
      }
      assert_failed = 0;
      stream->data = (void *)0x0;
      stream->encoding = sVar5;
      return (connection_state)CONCAT44(puVar3,stream);
    }
    iVar2 = in_stack_00000010->length + iVar2;
    in_stack_00000010->length = iVar2;
  } while( true );
}



connection_state read_encoded_file(string *filename,string *page)

{
  int fd;
  void **ppvVar1;
  int iVar2;
  stream_encoded *stream;
  int *piVar3;
  uchar *name;
  undefined4 extraout_EDX;
  uchar *name_00;
  uchar *puVar4;
  uchar **ppuVar5;
  bool bVar6;
  stream_encoding local_94;
  stream_encoding local_90;
  void *local_88;
  stream_encoded local_84;
  stat stt;
  
  fd = open64((char *)page->source,0x100);
  ppvVar1 = (void **)__errno_location();
  local_88 = *ppvVar1;
  if (fd == -1) {
    piVar3 = get_opt_(config_options,name);
    if (*piVar3 == 0) {
LAB_080ab188:
      filename->source = (uchar *)0xffffffff;
      *(void **)&filename->length = local_88;
      return (connection_state)CONCAT44(local_88,filename);
    }
    iVar2 = page->length;
    local_94 = ENCODING_GZIP;
    do {
      local_90 = local_94;
      ppuVar5 = decoding_backends[local_94]->extensions;
      while ((ppuVar5 != (uchar **)0x0 && (*ppuVar5 != (uchar *)0x0))) {
        add_to_string(page,*ppuVar5);
        fd = open64((char *)page->source,0x100);
        if (-1 < fd) goto LAB_080aaf6f;
        ppuVar5 = ppuVar5 + 1;
        page->source[iVar2] = '\0';
        page->length = iVar2;
      }
      local_94 = local_94 + ENCODING_GZIP;
    } while (local_94 != ENCODINGS_KNOWN);
    if (fd == -1) goto LAB_080ab188;
    local_90 = ENCODING_NONE;
  }
  else {
    local_90 = guess_encoding(page->source);
  }
LAB_080aaf6f:
  set_bin(fd);
  iVar2 = __fxstat64(3,fd,(stat64 *)&stt);
  if (iVar2 == 0) {
    bVar6 = (stt.st_mode & 0xf000) != 0x8000;
    if (local_90 == ENCODING_NONE) {
      if (bVar6) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/encoding/encoding.c";
        errline = 0x11e;
        iVar2 = elinks_strlcmp(page->source,page->length,"/dev/stdin",10);
        if (((iVar2 != 0) ||
            (((stt.st_mode & 0xf000) != 0x1000 && ((stt.st_mode & 0xf000) != 0xc000)))) &&
           (piVar3 = get_opt_(config_options,name_00), *piVar3 == 0)) {
          connection_state();
          local_88 = local_84.data;
          puVar4 = local_84.encoding;
          goto LAB_080aafa5;
        }
      }
    }
    else {
      puVar4 = (uchar *)0xffffffff;
      if (bVar6) goto LAB_080aafa5;
    }
    stream = open_encoded(fd,local_90);
    if (stream == (stream_encoded *)0x0) {
      connection_state();
      local_88 = local_84.data;
      puVar4 = local_84.encoding;
    }
    else {
      if ((stt.st_size._4_4_ == (int)(string *)stt.st_size >> 0x1f) &&
         (-1 < (int)(string *)stt.st_size)) {
        read_file(&local_84,(int)stream,(string *)stt.st_size);
        local_88 = local_84.data;
      }
      else {
        local_88 = (void *)0x1b;
        local_84.encoding = (uchar *)0xffffffff;
      }
      close_encoded(stream);
      puVar4 = local_84.encoding;
    }
  }
  else {
    local_88 = *ppvVar1;
    puVar4 = (uchar *)0xffffffff;
  }
LAB_080aafa5:
  close(fd);
  filename->source = puVar4;
  *(void **)&filename->length = local_88;
  return (connection_state)CONCAT44(extraout_EDX,filename);
}



void lock_formhist_data(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + 1;
  return;
}



void unlock_formhist_data(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



int is_formhist_data_used(listbox_item *item)

{
  return (uint)(*(int *)((int)item->udata + 8) != 0);
}



listbox_item * get_formhist_data_root(listbox_item *item)

{
  return (listbox_item *)0x0;
}



int can_delete_formhist_data(listbox_item *item)

{
  return 1;
}



void delete_formhist_data(listbox_item *item,int last)

{
  formhist_data *form;
  bool bVar1;
  
  form = (formhist_data *)item->udata;
  if ((assert_failed == 0) &&
     (bVar1 = (form->object).refcount != 0, assert_failed = ZEXT14(bVar1), bVar1)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/formhist/dialogs.c";
    errline = 0x71;
    elinks_internal((uchar *)"assertion !is_object_used(formhist_data) failed!");
    delete_formhist_item(form);
    return;
  }
  delete_formhist_item(form);
  return;
}



uri * get_formhist_data_uri(listbox_item *item)

{
  uri *puVar1;
  
  puVar1 = get_uri((uchar *)((int)item->udata + 0x15),0);
  return puVar1;
}



uchar * __regparm3 _(uchar *msg,terminal *term)

{
  int cp_index;
  uchar *codeset;
  
  if ((msg != (uchar *)0x0) && (*msg != '\0')) {
    if (term != (terminal *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    msg = gettext(msg);
  }
  return msg;
}



uchar * get_formhist_data_info(listbox_item *item,terminal *term)

{
  void *pvVar1;
  string *psVar2;
  uchar *source;
  int *piVar3;
  string info;
  
  pvVar1 = item->udata;
  if (item->type != BI_FOLDER) {
    psVar2 = init_string(&info);
    if (psVar2 != (string *)0x0) {
      source = _("URL",term);
      add_format_to_string(&info,"%s: %s",source,(int)pvVar1 + 0x15);
      add_char_to_string(&info,'\n');
      if ((*(byte *)((int)pvVar1 + 0x14) & 1) == 0) {
        source = _((uchar *)"Forms are saved for this URL.",term);
        add_to_string(&info,source);
      }
      else {
        source = _((uchar *)"Forms are never saved for this URL.",term);
        add_to_string(&info,source);
      }
      add_char_to_string(&info,'\n');
      piVar3 = (int *)**(int **)((int)pvVar1 + 0xc);
      if (piVar3 == *(int **)((int)pvVar1 + 0xc)) {
        return info.source;
      }
      do {
        source = form_type2str(piVar3[5]);
        add_format_to_string(&info,(uchar *)"\n[%8s] ",source);
        add_to_string(&info,(uchar *)piVar3[2]);
        add_to_string(&info," = ");
        source = (uchar *)piVar3[3];
        if ((source != (uchar *)0x0) && (*source != '\0')) {
          if (piVar3[5] == 1) {
            add_to_string(&info,(uchar *)"********");
          }
          else {
            add_to_string(&info,source);
          }
        }
        piVar3 = (int *)*piVar3;
      } while ((int *)*(int *)((int)pvVar1 + 0xc) != piVar3);
      return info.source;
    }
  }
  return (uchar *)0x0;
}



uchar * get_formhist_data_text(listbox_item *item,terminal *term)

{
  uchar *puVar1;
  
  puVar1 = stracpy((uchar *)((int)item->udata + 0x15));
  return puVar1;
}



widget_handler_status_T push_save_button(dialog_data *dlg_data,widget_data *button)

{
  save_formhist_to_file();
  return EVENT_PROCESSED;
}



widget_handler_status_T push_toggle_dontsave_button(dialog_data *dlg_data,widget_data *button)

{
  void *pvVar1;
  listbox_data *plVar2;
  
  plVar2 = get_listbox_widget_data(dlg_data->widgets_data);
  if ((plVar2->sel != (listbox_item *)0x0) && (pvVar1 = plVar2->sel->udata, pvVar1 != (void *)0x0))
  {
    *(byte *)((int)pvVar1 + 0x14) =
         *(byte *)((int)pvVar1 + 0x14) & 0xfe | (*(byte *)((int)pvVar1 + 0x14) ^ 1) & 1;
  }
  return EVENT_PROCESSED;
}



widget_handler_status_T push_login_button(dialog_data *dlg_data,widget_data *button)

{
  void *pvVar1;
  listbox_data *plVar2;
  
  plVar2 = get_listbox_widget_data(dlg_data->widgets_data);
  if ((plVar2->sel != (listbox_item *)0x0) && (pvVar1 = plVar2->sel->udata, pvVar1 != (void *)0x0))
  {
    if ((*(byte *)((int)pvVar1 + 0x14) & 1) != 0) {
      info_box(dlg_data->win->term,0,(uchar *)"Form not saved",ALIGN_CENTER,
               (uchar *)
               "No saved information for this URL.\nIf you want to save passwords for this URL, enable it by pressing the \"Toggle saving\" button."
              );
      return EVENT_PROCESSED;
    }
    push_hierbox_goto_button(dlg_data,button);
  }
  return EVENT_PROCESSED;
}



void formhist_manager(session *ses)

{
  load_formhist_from_file();
  hierbox_browser(&formhist_browser,ses);
  return;
}



formhist_data * __regparm3 new_formhist_item(uchar *url)

{
  size_t __n;
  formhist_data *data;
  list_head_elinks *plVar1;
  listbox_item *plVar2;
  formhist_data *pfVar3;
  
  __n = strlen((char *)url);
  data = (formhist_data *)mem_calloc(1,__n + 0x18);
  pfVar3 = data;
  if (data != (formhist_data *)0x0) {
    memcpy(data->url,url,__n);
    plVar1 = (list_head_elinks *)mem_alloc(8);
    data->submit = plVar1;
    if (plVar1 != (list_head_elinks *)0x0) {
      *(list_head_elinks **)&plVar1->prev = plVar1;
      *(list_head_elinks **)&plVar1->next = plVar1;
      plVar2 = add_listbox_item(&formhist_browser,(listbox_item *)0x0,BI_LEAF,data,1);
      data->box_item = plVar2;
      if (plVar2 != (listbox_item *)0x0) {
        return data;
      }
      mem_free(data->submit);
    }
    pfVar3 = (formhist_data *)0x0;
    mem_free(data);
  }
  return pfVar3;
}



void __regparm3 done_formhist_item(formhist_data *form)

{
  done_listbox_item(&formhist_browser,form->box_item);
  done_submitted_value_list(form->submit);
  mem_free(form->submit);
  mem_free(form);
  return;
}



void dont_remember_form(void *form_)

{
  done_formhist_item((formhist_data *)form_);
  return;
}



void delete_formhist_item(formhist_data *form)

{
  form->next->prev = form->prev;
  form->prev->next = form->next;
  done_formhist_item(form);
  return;
}



void done_form_history(module *module)

{
  formhist_data *form;
  formhist_data *pfVar1;
  bool bVar2;
  
  form = (formhist_data *)saved_forms.next;
  pfVar1 = *(formhist_data **)saved_forms.next;
  if ((list_head_elinks *)saved_forms.next != &saved_forms) {
    do {
      delete_formhist_item(form);
      bVar2 = pfVar1 != (formhist_data *)&saved_forms;
      form = pfVar1;
      pfVar1 = pfVar1->next;
    } while (bVar2);
  }
  return;
}



// WARNING: Type propagation algorithm not settling

int save_formhist_to_file(void)

{
  int *piVar1;
  uchar *file_name;
  secure_save_info *ssi;
  int iVar2;
  uchar *puVar3;
  uchar *in_EDX;
  list_head_elinks *local_20;
  
  if (((elinks_home != (uchar *)0x0) && (piVar1 = get_opt_(cmdline_options,in_EDX), *piVar1 == 0))
     && (file_name = straconcat(elinks_home,0x812e22e,0), file_name != (uchar *)0x0)) {
    ssi = secure_open(file_name);
    mem_free(file_name);
    if (ssi != (secure_save_info *)0x0) {
      if ((list_head_elinks *)saved_forms.next != &saved_forms) {
        local_20 = (list_head_elinks *)saved_forms.next;
        do {
          if ((*(byte *)&local_20[2].prev & 1) == 0) {
            secure_fprintf(ssi,"%s\n",(int)&local_20[2].prev + 1);
            piVar1 = *(int **)local_20[1].prev;
            if (piVar1 != (int *)local_20[1].prev) {
              do {
                file_name = (uchar *)piVar1[3];
                if ((file_name == (uchar *)0x0) || (*file_name == '\0')) {
                  file_name = stracpy("");
                }
                else {
                  file_name = base64_encode(file_name);
                }
                if (file_name == (uchar *)0x0) {
                  return 0;
                }
                iVar2 = piVar1[2];
                puVar3 = form_type2str(piVar1[5]);
                secure_fprintf(ssi,"%s\t%s\t%s\n",puVar3,iVar2,file_name);
                mem_free(file_name);
                piVar1 = (int *)*piVar1;
              } while ((int *)local_20[1].prev != piVar1);
            }
            secure_fputc(ssi,10);
          }
          else {
            secure_fprintf(ssi,"dontsave\t%s\n\n",(int)&local_20[2].prev + 1);
          }
          local_20 = (list_head_elinks *)local_20->next;
        } while (local_20 != &saved_forms);
      }
      iVar2 = secure_close(ssi);
      if (iVar2 == 0) {
        loaded = 1;
        return 0;
      }
      return iVar2;
    }
  }
  return 0;
}



void remember_form(void *form_)

{
  formhist_data *pfVar1;
  int iVar2;
  formhist_data *pfVar3;
  formhist_data *form;
  
  pfVar1 = *(formhist_data **)saved_forms.next;
  form = (formhist_data *)saved_forms.next;
  if ((list_head_elinks *)saved_forms.next != &saved_forms) {
    do {
      pfVar3 = pfVar1;
      iVar2 = strcmp((char *)form->url,(char *)((int)form_ + 0x15));
      if (iVar2 == 0) {
        delete_formhist_item(form);
        pfVar1 = pfVar3->next;
      }
      else {
        pfVar1 = pfVar3->next;
      }
      form = pfVar3;
    } while (pfVar3 != (formhist_data *)&saved_forms);
  }
  *(undefined4 *)((int)form_ + 4) = 0x8144ec0;
  *(void **)form_ = saved_forms.next;
  saved_forms.next = form_;
  *(void **)(*(int *)form_ + 4) = form_;
  save_formhist_to_file();
  return;
}



void never_for_this_site(void *form_)

{
  *(byte *)((int)form_ + 0x14) = *(byte *)((int)form_ + 0x14) | 1;
  remember_form(form_);
  return;
}



int load_formhist_from_file(void)

{
  uchar *url;
  FILE *__stream;
  char *pcVar1;
  size_t sVar2;
  formhist_data *form;
  form_type type;
  submitted_value *psVar3;
  int iVar4;
  byte *pbVar5;
  byte *pbVar6;
  int in_GS_OFFSET;
  bool bVar7;
  bool bVar8;
  byte bVar9;
  uchar *local_434;
  uchar *local_430;
  uchar tmp [1024];
  int local_20;
  
  bVar9 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  iVar4 = 1;
  if (loaded == 0) {
    if ((elinks_home != (uchar *)0x0) &&
       (url = straconcat(elinks_home,0x812e22e,0), url != (uchar *)0x0)) {
      __stream = fopen64((char *)url,"rb");
      mem_free(url);
      if (__stream != (FILE *)0x0) {
LAB_080aba3e:
        while (pcVar1 = fgets((char *)tmp,0x400,__stream), pcVar1 != (char *)0x0) {
          if ((tmp[0] != 10) || (tmp[1] != '\0')) {
            pcVar1 = strchr((char *)tmp,9);
            bVar7 = false;
            bVar8 = pcVar1 == (char *)0x0;
            if (bVar8) {
              iVar4 = 9;
              pbVar5 = tmp;
              pbVar6 = (byte *)"dontsave,";
              do {
                if (iVar4 == 0) break;
                iVar4 = iVar4 + -1;
                bVar8 = *pbVar5 == *pbVar6;
                pbVar5 = pbVar5 + (uint)bVar9 * -2 + 1;
                pbVar6 = pbVar6 + (uint)bVar9 * -2 + 1;
              } while (bVar8);
              if (bVar8) {
                url = tmp + 9;
                bVar7 = true;
              }
              else {
                url = tmp;
                bVar7 = false;
              }
            }
            else {
              *pcVar1 = '\0';
              iVar4 = 9;
              url = (uchar *)(pcVar1 + 1);
              pbVar5 = tmp;
              pbVar6 = (byte *)"dontsave";
              do {
                if (iVar4 == 0) break;
                iVar4 = iVar4 + -1;
                bVar7 = *pbVar5 < *pbVar6;
                bVar8 = *pbVar5 == *pbVar6;
                pbVar5 = pbVar5 + (uint)bVar9 * -2 + 1;
                pbVar6 = pbVar6 + (uint)bVar9 * -2 + 1;
              } while (bVar8);
              bVar7 = (!bVar7 && !bVar8) == bVar7;
            }
            sVar2 = strlen((char *)url);
            url[sVar2 - 1] = '\0';
            form = new_formhist_item(url);
            if (form != (formhist_data *)0x0) {
              if (bVar7) {
                *(byte *)&form->field_0x14 = *(byte *)&form->field_0x14 | 1;
              }
LAB_080abae8:
              do {
                pcVar1 = fgets((char *)tmp,0x400,__stream);
                if ((pcVar1 == (char *)0x0) || ((tmp[0] == 10 && (tmp[1] == '\0'))))
                goto LAB_080abc4d;
                pcVar1 = strchr((char *)tmp,9);
                if (pcVar1 == (char *)0x0) goto fail;
                local_430 = (uchar *)(pcVar1 + 1);
                *pcVar1 = '\0';
                pcVar1 = strchr((char *)local_430,9);
                if (pcVar1 == (char *)0x0) {
                  if (tmp[0] == 0x2a) {
                    local_434 = tmp + 1;
                    url = "password";
                  }
                  else {
                    local_434 = tmp;
                    url = "text";
                  }
                }
                else {
                  *pcVar1 = '\0';
                  url = tmp;
                  local_434 = local_430;
                  local_430 = (uchar *)(pcVar1 + 1);
                }
                pcVar1 = strchr((char *)local_430,10);
                if (pcVar1 == (char *)0x0) goto fail;
                *pcVar1 = '\0';
                type = str2form_type(url);
                if (type == ~FC_TEXT) goto fail;
              } while ((*(byte *)&form->field_0x14 & 1) != 0);
              if (*local_430 == '\0') {
                url = stracpy(local_430);
              }
              else {
                url = base64_decode(local_430);
              }
              if (url != (uchar *)0x0) {
                psVar3 = init_submitted_value(local_434,url,type,(form_control *)0x0,0);
                mem_free(url);
                if (psVar3 != (submitted_value *)0x0) {
                  psVar3->next = (submitted_value *)form->submit->next;
                  psVar3->prev = (submitted_value *)form->submit;
                  *(submitted_value **)&form->submit->next = psVar3;
                  psVar3->next->prev = psVar3;
                  goto LAB_080abae8;
                }
              }
fail:
              done_formhist_item(form);
              iVar4 = 0;
              goto LAB_080abc22;
            }
          }
        }
        fclose(__stream);
        iVar4 = 1;
        loaded = 1;
        goto LAB_080abc22;
      }
    }
    iVar4 = 0;
  }
LAB_080abc22:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar4;
LAB_080abc4d:
  *(list_head_elinks **)&form->prev = &saved_forms;
  form->next = saved_forms.next;
  saved_forms.next = form;
  form->next->prev = form;
  goto LAB_080aba3e;
}



void memorize_form(session *ses,list_head_elinks *submit,form *forminfo)

{
  list_head_elinks *plVar1;
  int **ppiVar2;
  int **ppiVar3;
  int *piVar4;
  formhist_data *form;
  submitted_value *psVar5;
  int iVar6;
  int **ppiVar7;
  int local_34;
  list_head_elinks *local_30;
  int local_28;
  list_head_elinks *local_20;
  
  plVar1 = (list_head_elinks *)submit->next;
  while( true ) {
    if (plVar1 == submit) {
      return;
    }
    if (((plVar1[2].prev == (void *)0x1) && ((char *)plVar1[1].prev != (char *)0x0)) &&
       (*(char *)plVar1[1].prev != '\0')) break;
    plVar1 = (list_head_elinks *)plVar1->next;
  }
  form = new_formhist_item(forminfo->action);
  if (form == (formhist_data *)0x0) {
    return;
  }
  plVar1 = (list_head_elinks *)submit->next;
  while (plVar1 != submit) {
    if (plVar1[2].prev < (void *)0x2) {
      psVar5 = init_submitted_value
                         ((uchar *)plVar1[1].next,(uchar *)plVar1[1].prev,(form_type)plVar1[2].prev,
                          (form_control *)0x0,0);
      if (psVar5 == (submitted_value *)0x0) goto fail;
      psVar5->next = (submitted_value *)form->submit->next;
      psVar5->prev = (submitted_value *)form->submit;
      *(submitted_value **)&form->submit->next = psVar5;
      psVar5->next->prev = psVar5;
      plVar1 = (list_head_elinks *)plVar1->next;
    }
    else {
      plVar1 = (list_head_elinks *)plVar1->next;
    }
  }
  iVar6 = load_formhist_from_file();
  if ((iVar6 != 0) &&
     (local_30 = (list_head_elinks *)saved_forms.next,
     (list_head_elinks *)saved_forms.next != &saved_forms)) {
    do {
      iVar6 = strcmp((char *)((int)&local_30[2].prev + 1),(char *)form->url);
      if (iVar6 == 0) {
        if ((*(byte *)&local_30[2].prev & 1) != 0) {
fail:
          done_formhist_item(form);
          return;
        }
        plVar1 = form->submit;
        local_20 = (list_head_elinks *)plVar1->next;
        if (local_20 != plVar1) {
          ppiVar2 = (int **)local_30[1].prev;
          ppiVar3 = (int **)*ppiVar2;
          local_34 = 0;
          local_28 = 0;
          do {
            if (ppiVar3 != ppiVar2) {
              piVar4 = (int *)local_20[2].prev;
              ppiVar7 = ppiVar3;
              do {
                if ((piVar4 == ppiVar7[5]) &&
                   (iVar6 = strcmp((char *)local_20[1].next,(char *)ppiVar7[2]), iVar6 == 0)) {
                  local_34 = local_34 + 1;
                  if ((ppiVar7[3] != (int *)0x0) &&
                     (iVar6 = strcmp((char *)local_20[1].prev,(char *)ppiVar7[3]), iVar6 != 0))
                  goto LAB_080abf3d;
                  break;
                }
                ppiVar7 = (int **)*ppiVar7;
              } while (ppiVar7 != ppiVar2);
            }
            local_28 = local_28 + 1;
            local_20 = (list_head_elinks *)local_20->next;
          } while (local_20 != plVar1);
          if (((local_34 != 0) && (local_28 != 0)) && (local_28 == local_34)) goto fail;
        }
      }
      local_30 = (list_head_elinks *)local_30->next;
    } while (local_30 != &saved_forms);
  }
LAB_080abf3d:
  msg_box(ses->tab->term,(memory_list *)0x0,0,"Form history",ALIGN_CENTER,
          (uchar *)
          "Should this login be remembered?\n\nPlease note that the password will be stored obscured (but unencrypted) in a file on your disk.\n\nIf you are using a valuable password, answer NO."
          ,form,3,&DAT_0812762b,remember_form,1,&DAT_08127627,dont_remember_form,2,
          "Ne~ver for this site",never_for_this_site,0);
  return;
}



uchar * get_form_history_value(uchar *url,uchar *name)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  int iVar3;
  list_head_elinks *local_20;
  
  if ((((url != (uchar *)0x0) && (name != (uchar *)0x0)) && (*url != '\0')) &&
     ((*name != '\0' && (iVar3 = load_formhist_from_file(), iVar3 != 0)))) {
    local_20 = (list_head_elinks *)saved_forms.next;
    while (local_20 != &saved_forms) {
      if (((*(byte *)&local_20[2].prev & 1) == 0) &&
         (iVar3 = strcmp((char *)((int)&local_20[2].prev + 1),(char *)url), iVar3 == 0)) {
        puVar1 = (undefined4 *)local_20[1].prev;
        puVar2 = (undefined4 *)*puVar1;
        while (puVar2 != puVar1) {
          iVar3 = strcmp((char *)puVar2[2],(char *)name);
          if (iVar3 == 0) {
            return (uchar *)puVar2[3];
          }
          puVar2 = (undefined4 *)*puVar2;
        }
      }
      local_20 = (list_head_elinks *)local_20->next;
    }
  }
  return (uchar *)0x0;
}



void lock_globhist_item(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + 1;
  return;
}



void unlock_globhist_item(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



int is_globhist_item_used(listbox_item *item)

{
  return (uint)(*(int *)((int)item->udata + 8) != 0);
}



listbox_item * get_globhist_item_root(listbox_item *box_item)

{
  return (listbox_item *)0x0;
}



int can_delete_globhist_item(listbox_item *item)

{
  return 1;
}



void delete_globhist_item(listbox_item *item,int last)

{
  global_history_item *history_item;
  bool bVar1;
  
  history_item = (global_history_item *)item->udata;
  if ((assert_failed == 0) &&
     (bVar1 = (history_item->object).refcount != 0, assert_failed = ZEXT14(bVar1), bVar1)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/globhist/dialogs.c";
    errline = 0x62;
    elinks_internal((uchar *)"assertion !is_object_used(historyitem) failed!");
    delete_global_history_item(history_item);
    return;
  }
  delete_global_history_item(history_item);
  return;
}



uri * get_globhist_item_uri(listbox_item *item)

{
  uri *puVar1;
  
  puVar1 = get_uri(*(uchar **)((int)item->udata + 0x14),0);
  return puVar1;
}



uchar * __regparm3 _(uchar *msg,terminal *term)

{
  int cp_index;
  uchar *codeset;
  
  if ((msg != (uchar *)0x0) && (*msg != '\0')) {
    if (term != (terminal *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    msg = gettext(msg);
  }
  return msg;
}



uchar * get_globhist_item_info(listbox_item *box_item,terminal *term)

{
  void *pvVar1;
  undefined4 uVar2;
  string *psVar3;
  uchar *puVar4;
  char *pcVar5;
  string info;
  
  pvVar1 = box_item->udata;
  if (box_item->type != BI_FOLDER) {
    psVar3 = init_string(&info);
    if (psVar3 != (string *)0x0) {
      uVar2 = *(undefined4 *)((int)pvVar1 + 0x10);
      puVar4 = _((uchar *)"Title",term);
      add_format_to_string(&info,"%s: %s",puVar4,uVar2);
      uVar2 = *(undefined4 *)((int)pvVar1 + 0x14);
      puVar4 = _("URL",term);
      add_format_to_string(&info,(uchar *)"\n%s: %s",puVar4,uVar2);
      pcVar5 = ctime((time_t *)((int)pvVar1 + 0x18));
      puVar4 = _((uchar *)"Last visit time",term);
      add_format_to_string(&info,(uchar *)"\n%s: %s",puVar4,pcVar5);
      return info.source;
    }
  }
  return (uchar *)0x0;
}



uchar * get_globhist_item_text(listbox_item *box_item,terminal *term)

{
  void *pvVar1;
  int *piVar2;
  uchar *src;
  string *psVar3;
  uchar *in_EDX;
  string info;
  
  pvVar1 = box_item->udata;
  piVar2 = get_opt_(config_options,in_EDX);
  if ((*piVar2 == 0) || (src = *(uchar **)((int)pvVar1 + 0x10), *src == '\0')) {
    psVar3 = init_string(&info);
    src = (uchar *)0x0;
    if (psVar3 != (string *)0x0) {
      add_string_uri_to_string(&info,*(uchar **)((int)pvVar1 + 0x14),URI_PUBLIC);
      return info.source;
    }
  }
  else {
    src = stracpy(src);
  }
  return src;
}



widget_handler_status_T push_toggle_display_button(dialog_data *dlg_data,widget_data *widget_data)

{
  uint *puVar1;
  uchar *in_EDX;
  
  puVar1 = get_opt_(config_options,in_EDX);
  *puVar1 = (uint)(*puVar1 == 0);
  update_hierbox_browser(&globhist_browser);
  return EVENT_PROCESSED;
}



widget_handler_status_T push_search_button(dialog_data *dlg_data,widget_data *widget_data)

{
  do_edit_dialog(dlg_data->win->term,1,(uchar *)"Search history",gh_last_searched_title,
                 gh_last_searched_url,(session *)dlg_data->dlg->udata,dlg_data,history_search_do,
                 (anon_subr_void_dialog_ptr *)0x0,(void *)0x0,EDIT_DLG_SEARCH);
  return EVENT_PROCESSED;
}



void history_search_do(void *data)

{
  list_head_elinks *plVar1;
  void *pvVar2;
  int iVar3;
  
  pvVar2 = globhist_browser.root.child.next;
  iVar3 = globhist_simple_search(*(uchar **)((int)data + 0x60),*(uchar **)((int)data + 0x30));
  if ((iVar3 != 0) &&
     (plVar1 = (list_head_elinks *)globhist_browser.boxes.next,
     (list_head_elinks *)globhist_browser.root.child.next != &globhist_browser.root.child)) {
    while (plVar1 != &globhist_browser.boxes) {
      plVar1[2].next = pvVar2;
      plVar1[1].prev = pvVar2;
      plVar1 = (list_head_elinks *)plVar1->next;
    }
  }
  return;
}



widget_handler_status_T
push_bookmark_button(dialog_data *dlg_data,widget_data *some_useless_info_button)

{
  void *pvVar1;
  listbox_data *plVar2;
  
  plVar2 = get_listbox_widget_data(dlg_data->widgets_data);
  if ((plVar2->sel != (listbox_item *)0x0) && (pvVar1 = plVar2->sel->udata, pvVar1 != (void *)0x0))
  {
    launch_bm_add_dialog
              (dlg_data->win->term,(dialog_data *)0x0,(session *)0x0,*(uchar **)((int)pvVar1 + 0x10)
               ,*(uchar **)((int)pvVar1 + 0x14));
  }
  return EVENT_PROCESSED;
}



void history_manager(session *ses)

{
  if (gh_last_searched_title != (uchar *)0x0) {
    mem_free(gh_last_searched_title);
  }
  gh_last_searched_title = (uchar *)0x0;
  if (gh_last_searched_url != (uchar *)0x0) {
    mem_free(gh_last_searched_url);
  }
  gh_last_searched_url = (uchar *)0x0;
  hierbox_browser(&globhist_browser,ses);
  return;
}



void reap_deleted_globhist_items(void)

{
  bool bVar1;
  list_head_elinks *plVar2;
  list_head_elinks *p;
  list_head_elinks *plVar3;
  
  p = (list_head_elinks *)global_history_reap_list.next;
  plVar3 = *(list_head_elinks **)global_history_reap_list.next;
  if ((list_head_elinks *)global_history_reap_list.next != &global_history_reap_list) {
    do {
      if (p[1].next == (void *)0x0) {
        *(void **)((int)p->next + 4) = p->prev;
        *(void **)p->prev = p->next;
        mem_free(p[2].next);
        mem_free(p[2].prev);
        mem_free(p);
        plVar2 = (list_head_elinks *)plVar3->next;
      }
      else {
        plVar2 = (list_head_elinks *)plVar3->next;
      }
      bVar1 = plVar3 != &global_history_reap_list;
      p = plVar3;
      plVar3 = plVar2;
    } while (bVar1);
  }
  return;
}



void write_global_history(void)

{
  int *piVar1;
  uchar *file_name;
  secure_save_info *ssi;
  int iVar2;
  uchar *in_EDX;
  input_history *piVar3;
  
  if (((((global_history._12_1_ & 1) != 0) && (elinks_home != (uchar *)0x0)) &&
      (global_history_options[1].option_elinks.value != 0)) &&
     ((piVar1 = get_opt_(cmdline_options,in_EDX), *piVar1 == 0 &&
      (file_name = straconcat(elinks_home,"globhist",0), file_name != (uchar *)0x0)))) {
    ssi = secure_open(file_name);
    mem_free(file_name);
    if (ssi != (secure_save_info *)0x0) {
      piVar3 = (input_history *)global_history.entries.prev;
      if ((input_history *)global_history.entries.prev != &global_history) {
        do {
          iVar2 = secure_fprintf(ssi,"%s\t%s\t%ld\n",piVar3[1].entries.next,piVar3[1].entries.prev,
                                 piVar3[1].size);
          if (iVar2 < 0) break;
          piVar3 = (input_history *)(piVar3->entries).prev;
        } while (piVar3 != &global_history);
      }
      iVar2 = secure_close(ssi);
      if (iVar2 == 0) {
        global_history._12_1_ = global_history._12_1_ & 0xfe;
      }
    }
  }
  return;
}



evhook_status global_history_write_hook(va_list ap,void *data)

{
  write_global_history();
  return EVENT_HOOK_STATUS_NEXT;
}



int globhist_simple_search(uchar *search_url,uchar *search_title)

{
  byte *pbVar1;
  uchar uVar2;
  char *pcVar3;
  input_history *piVar4;
  
  if ((search_title != (uchar *)0x0) && (search_url != (uchar *)0x0)) {
    if (gh_last_searched_title != (uchar *)0x0) {
      mem_free(gh_last_searched_title);
    }
    gh_last_searched_title = stracpy(search_title);
    if (gh_last_searched_title != (uchar *)0x0) {
      if (gh_last_searched_url != (uchar *)0x0) {
        mem_free(gh_last_searched_url);
      }
      gh_last_searched_url = stracpy(search_url);
      if (gh_last_searched_url != (uchar *)0x0) {
        uVar2 = *search_title;
        if ((uVar2 == '\0') && (*search_url == '\0')) {
          piVar4 = (input_history *)global_history.entries.next;
          if ((input_history *)global_history.entries.next != &global_history) {
            do {
              pbVar1 = (byte *)(*(int *)&piVar4->field_0xc + 0x18);
              *pbVar1 = *pbVar1 | 2;
              piVar4 = (input_history *)(piVar4->entries).next;
            } while (piVar4 != &global_history);
          }
        }
        else {
          piVar4 = (input_history *)global_history.entries.next;
          if ((input_history *)global_history.entries.next != &global_history) {
            while( true ) {
              if (((uVar2 == '\0') ||
                  (pcVar3 = strcasestr((char *)piVar4[1].entries.next,(char *)search_title),
                  pcVar3 == (char *)0x0)) &&
                 ((*search_url == '\0' ||
                  (pcVar3 = c_strcasestr((char *)piVar4[1].entries.prev,(char *)search_url),
                  pcVar3 == (char *)0x0)))) {
                pbVar1 = (byte *)(*(int *)&piVar4->field_0xc + 0x18);
                *pbVar1 = *pbVar1 & 0xfd;
                piVar4 = (input_history *)(piVar4->entries).next;
              }
              else {
                pbVar1 = (byte *)(*(int *)&piVar4->field_0xc + 0x18);
                *pbVar1 = *pbVar1 | 2;
                piVar4 = (input_history *)(piVar4->entries).next;
              }
              if (piVar4 == &global_history) break;
              uVar2 = *search_title;
            }
          }
        }
        return 1;
      }
    }
  }
  return 0;
}



global_history_item * get_global_history_item(uchar *url)

{
  hash *hash;
  size_t keylen;
  hash_item *phVar1;
  
  hash = globhist_cache;
  if ((url != (uchar *)0x0) && (globhist_cache != (hash *)0x0)) {
    keylen = strlen((char *)url);
    phVar1 = get_hash_item(hash,url,keylen);
    if (phVar1 != (hash_item *)0x0) {
      return (global_history_item *)phVar1->value;
    }
  }
  return (global_history_item *)0x0;
}



void delete_global_history_item(global_history_item *history_item)

{
  uchar *key;
  hash *hash;
  size_t keylen;
  hash_item *item;
  
  history_item->next->prev = history_item->prev;
  history_item->prev->next = history_item->next;
  hash = globhist_cache;
  global_history.size = global_history.size + -1;
  if ((global_history._12_1_ & 2) == 0) {
    global_history._12_1_ = global_history._12_1_ | 1;
  }
  if (globhist_cache != (hash *)0x0) {
    key = history_item->url;
    keylen = strlen((char *)key);
    item = get_hash_item(hash,key,keylen);
    if (item != (hash_item *)0x0) {
      del_hash_item(globhist_cache,item);
      globhist_cache_entries = globhist_cache_entries + -1;
    }
  }
  done_listbox_item(&globhist_browser,history_item->box_item);
  history_item->box_item = (listbox_item *)0x0;
  *(list_head_elinks **)&history_item->prev = &global_history_reap_list;
  history_item->next = global_history_reap_list.next;
  global_history_reap_list.next = history_item;
  history_item->next->prev = history_item;
  return;
}



void done_global_history(module *module)

{
  write_global_history();
  if (globhist_cache != (hash *)0x0) {
    free_hash(&globhist_cache);
    globhist_cache_entries = 0;
  }
  while ((input_history *)global_history.entries.next != &global_history) {
    delete_global_history_item((global_history_item *)global_history.entries.next);
  }
  reap_deleted_globhist_items();
  if (gh_last_searched_title != (uchar *)0x0) {
    mem_free(gh_last_searched_title);
  }
  if (gh_last_searched_url != (uchar *)0x0) {
    mem_free(gh_last_searched_url);
    return;
  }
  return;
}



void add_global_history_item(uchar *url,uchar *title,time_t vtime)

{
  int iVar1;
  hash *hash;
  global_history_item *history_item;
  void **data;
  uchar *src;
  int iVar2;
  listbox_item *plVar3;
  size_t keylen;
  hash_item *phVar4;
  void *p;
  
  iVar1 = global_history_options[2].option_elinks.value;
  if ((url == (uchar *)0x0) || (global_history_options[1].option_elinks.value == 0)) {
    return;
  }
  history_item = get_global_history_item(url);
  if (history_item != (global_history_item *)0x0) {
    delete_global_history_item(history_item);
  }
  while (iVar1 <= global_history.size) {
    if ((input_history *)global_history.entries.prev == &global_history) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/globhist/globhist.c";
      errline = 0xe9;
      elinks_internal((uchar *)"global history is empty");
      global_history.size = 0;
      return;
    }
    delete_global_history_item((global_history_item *)global_history.entries.prev);
  }
  reap_deleted_globhist_items();
  data = (void **)mem_calloc(1,0x1c);
  if (data == (void **)0x0) {
    return;
  }
  *(time_t *)(data + 6) = vtime;
  src = "";
  if (title != (uchar *)0x0) {
    src = title;
  }
  src = stracpy(src);
  *(uchar **)(data + 4) = src;
  if (src == (uchar *)0x0) goto LAB_080acb6c;
  sanitize_title(src);
  src = stracpy(url);
  *(uchar **)(data + 5) = src;
  if (src != (uchar *)0x0) {
    iVar2 = sanitize_url(src);
    if (iVar2 == 0) {
      p = data[5];
      if (p == (void *)0x0) goto LAB_080acb61;
    }
    else {
      plVar3 = add_listbox_item(&globhist_browser,(listbox_item *)0x0,BI_LEAF,data,1);
      *(listbox_item **)(data + 3) = plVar3;
      if (plVar3 != (listbox_item *)0x0) {
        *(input_history **)(data + 1) = &global_history;
        *data = global_history.entries.next;
        global_history.entries.next = data;
        *(void ***)((int)*data + 4) = data;
        global_history.size = global_history.size + 1;
        if ((global_history._12_1_ & 2) == 0) {
          global_history._12_1_ = global_history._12_1_ | 1;
        }
        if ((globhist_cache == (hash *)0x0) &&
           (globhist_cache = init_hash8(), globhist_cache == (hash *)0x0)) {
          return;
        }
        hash = globhist_cache;
        if (iVar1 <= globhist_cache_entries) {
          return;
        }
        src = (uchar *)data[5];
        keylen = strlen((char *)src);
        phVar4 = add_hash_item(hash,src,keylen,data);
        if (phVar4 == (hash_item *)0x0) {
          return;
        }
        globhist_cache_entries = globhist_cache_entries + 1;
        return;
      }
      p = data[5];
    }
    mem_free(p);
  }
LAB_080acb61:
  mem_free(data[4]);
LAB_080acb6c:
  mem_free(data);
  return;
}



void read_global_history(void)

{
  int iVar1;
  int *piVar2;
  FILE *__stream;
  char *pcVar3;
  char *pcVar4;
  long vtime;
  uchar *in_EDX;
  char *__filename;
  int in_GS_OFFSET;
  uchar in_buffer [3072];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (global_history_options[1].option_elinks.value != 0) {
    piVar2 = get_opt_(cmdline_options,in_EDX);
    if (*piVar2 == 0) {
      __filename = "globhist";
      if (elinks_home != (uchar *)0x0) {
        __filename = (char *)straconcat(elinks_home,"globhist",0);
        if ((uchar *)__filename == (uchar *)0x0) goto LAB_080acbc0;
      }
      __stream = fopen64(__filename,"rb");
      if (elinks_home != (uchar *)0x0) {
        mem_free(__filename);
      }
      if (__stream != (FILE *)0x0) {
        global_history._12_1_ = global_history._12_1_ | 2;
        while( true ) {
          __filename = fgets((char *)in_buffer,0xc00,__stream);
          if (__filename == (char *)0x0) break;
          __filename = strchr((char *)in_buffer,9);
          if (__filename != (char *)0x0) {
            *__filename = '\0';
            pcVar3 = strchr(__filename + 1,9);
            if (pcVar3 != (char *)0x0) {
              *pcVar3 = '\0';
              pcVar4 = strchr(pcVar3 + 1,10);
              if (pcVar4 != (char *)0x0) {
                *pcVar4 = '\0';
                vtime = strtol(pcVar3 + 1,(char **)0x0,10);
                add_global_history_item((uchar *)(__filename + 1),in_buffer,vtime);
              }
            }
          }
        }
        global_history._12_1_ = global_history._12_1_ & 0xfd;
        fclose(__stream);
      }
    }
  }
LAB_080acbc0:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void init_global_history(module *module)

{
  read_global_history();
  return;
}



int utf8charlen(uchar *p)

{
  int iVar1;
  
  iVar1 = 0;
  if (p != (uchar *)0x0) {
    iVar1 = (int)((char *)0x810bfe0)[*p];
  }
  return iVar1;
}



uchar * utf8_prevchar(uchar *current,int pos,uchar *start)

{
  if (((start == (uchar *)0x0) || (current == (uchar *)0x0)) || (pos < 0)) {
    current = (byte *)0x0;
  }
  else {
    while (current != start) {
      while( true ) {
        if (pos < 1) {
          return current;
        }
        current = current + -1;
        if (((char)*current < '\0') && ((*current & 0xc0) != 0xc0)) break;
        pos = pos + -1;
        if (current == start) {
          return current;
        }
      }
    }
  }
  return current;
}



int unicode_to_cell(unicode_val_T c)

{
  if ((0x10ff < c) &&
     (((((c == 0x2329 || (c < 0x1160)) || (c == 0x232a)) ||
       ((((c - 0x2e80 < 0x7650 && (c != 0x303f)) ||
         ((c - 0xac00 < 0x2ba4 || ((c - 0xf900 < 0x200 || (c - 0xfe30 < 0x40)))))) ||
        (c - 0xff00 < 0x61)))) ||
      (((c - 0xffe0 < 7 || (c - 0x20000 < 0xfffe)) || (c - 0x30000 < 0xfffe)))))) {
    return 2;
  }
  return 1;
}



int hits_cmp(void *v1,void *v2)

{
  if (*(uint *)v1 == *(uint *)v2) {
    return 0;
  }
  return -(uint)(*(uint *)v2 < *(uint *)v1) | 1;
}



int compare_entities(void *key_,void *element_)

{
  byte bVar1;
  int iVar2;
  byte *pbVar3;
  byte *pbVar4;
  
  iVar2 = *(int *)((int)key_ + 4);
  pbVar3 = *(byte **)key_;
  pbVar4 = *(byte **)element_;
  if (iVar2 == 0) {
LAB_080acee8:
    iVar2 = 0;
    if (*pbVar4 != 0) {
      return -1;
    }
  }
  else {
    while (bVar1 = *pbVar4, *pbVar3 < bVar1 || *pbVar3 == bVar1) {
      if (*pbVar3 < bVar1) {
        return -1;
      }
      pbVar4 = pbVar4 + 1;
      iVar2 = iVar2 + -1;
      if (iVar2 == 0) goto LAB_080acee8;
      pbVar3 = pbVar3 + 1;
    }
    iVar2 = 1;
  }
  return iVar2;
}



void charsets_list_reset(void)

{
  i_name = 0;
  i_alias = 0;
  return;
}



fastfind_key_value * charsets_list_next(void)

{
  fastfind_key_value kv;
  fastfind_key_value *pfVar1;
  
  pfVar1 = (fastfind_key_value *)0x0;
  if (codepages[i_name].name != (uchar *)0x0) {
    i_alias = i_alias + 1;
    if (codepages[i_name].aliases[i_alias] == (uchar *)0x0) {
      i_name = i_name + 1;
      i_alias = 0;
      return (fastfind_key_value *)0x8149468;
    }
    pfVar1 = (fastfind_key_value *)0x8149468;
  }
  return pfVar1;
}



uchar * get_cp_name(int cp_index)

{
  char *pcVar1;
  
  pcVar1 = "none";
  if ((-1 < cp_index) && (pcVar1 = "System", -1 < (char)cp_index)) {
    pcVar1 = (char *)codepages[cp_index].name;
  }
  return (uchar *)pcVar1;
}



uchar * get_cp_config_name(int cp_index)

{
  char *pcVar1;
  
  pcVar1 = "none";
  if ((-1 < cp_index) && (pcVar1 = "System", -1 < (char)cp_index)) {
    pcVar1 = (char *)0x0;
    if (codepages[cp_index].aliases != (uchar **)0x0) {
      return *codepages[cp_index].aliases;
    }
  }
  return (uchar *)pcVar1;
}



uchar * get_cp_mime_name(int cp_index)

{
  uchar *puVar1;
  
  puVar1 = "none";
  if (-1 < cp_index) {
    puVar1 = (uchar *)0x0;
    if (codepages[cp_index & 0xffffff7f].aliases != (uchar **)0x0) {
      return *codepages[cp_index & 0xffffff7f].aliases;
    }
  }
  return puVar1;
}



int is_cp_utf8(int cp_index)

{
  return (uint)(codepages[cp_index & 0xffffff7f].aliases == aliases_utf8);
}



void free_charsets_lookup(void)

{
  fastfind_done(&ff_charsets_index);
  return;
}



void init_charsets_lookup(void)

{
  fastfind_index(&ff_charsets_index,FF_COMPRESS);
  return;
}



int get_cp_index(uchar *name)

{
  int iVar1;
  size_t key_len;
  codepage_desc *pcVar2;
  uint uVar3;
  uint uVar4;
  
  uVar4 = 0;
  iVar1 = c_strcasecmp((char *)name,"System");
  if (iVar1 == 0) {
    uVar4 = 0x80;
    name = (uchar *)nl_langinfo(0xe);
  }
  key_len = strlen((char *)name);
  pcVar2 = (codepage_desc *)fastfind_search(&ff_charsets_index,name,key_len);
  if (pcVar2 == (codepage_desc *)0x0) {
    uVar3 = 0xffffffff;
    if (uVar4 != 0) {
      uVar3 = get_cp_index((uchar *)"us-ascii");
      uVar3 = uVar3 | uVar4;
    }
  }
  else {
    if (assert_failed == 0) {
      if ((pcVar2 < codepages) ||
         ((codepage_desc *)((int)&codepages[0x22].table_elinks + 3) < pcVar2)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
        errline = 0x585;
        elinks_internal((uchar *)
                        "assertion codepages <= codepage && codepage < codepages + N_CODEPAGES failed!"
                       );
      }
      else {
        assert_failed = 0;
      }
    }
    uVar3 = (int)(pcVar2 + -0x8104f8) >> 4 | uVar4;
  }
  return uVar3;
}



unicode_val_T cp2u(int from,uchar c)

{
  unicode_val_T uVar1;
  bool bVar2;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0xfffd;
  }
  bVar2 = codepages[from & 0xffffff7fU].aliases == aliases_utf8;
  assert_failed = ZEXT14(bVar2);
  if (bVar2) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
    errline = 0x2e8;
    elinks_internal((uchar *)"assertion !is_cp_ptr_utf8(&codepages[from]) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0xfffd;
    }
  }
  if ((char)c < '\0') {
    uVar1 = (unicode_val_T)codepages[from & 0xffffff7fU].highhalf[(uint)c - 0x80];
    if (codepages[from & 0xffffff7fU].highhalf[(uint)c - 0x80] == 0xffff) {
      uVar1 = 0xfffd;
    }
    return uVar1;
  }
  return (uint)c;
}



unicode_val_T utf8_to_unicode(uchar **string,uchar *end)

{
  byte bVar1;
  byte *pbVar2;
  uint uVar3;
  byte *pbVar4;
  uint uVar5;
  
  pbVar2 = *string;
  bVar1 = *pbVar2;
  uVar5 = (uint)bVar1;
  if (end < pbVar2 + ((char *)0x810bfe0)[uVar5]) {
    return 0xfffffffd;
  }
  switch(((char *)0x810bfe0)[uVar5]) {
  default:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
    errline = 0x2cf;
    elinks_internal((uchar *)"utf8char_len_tab out of range");
    pbVar4 = *string + 1;
    break;
  case '\x01':
    uVar3 = (uint)bVar1;
    if (-1 < (char)bVar1) {
LAB_080ad390:
      *string = pbVar2 + ((char *)0x810bfe0)[uVar5];
      return uVar3;
    }
    pbVar4 = pbVar2 + 1;
    break;
  case '\x02':
    pbVar4 = pbVar2 + 1;
    if ((((uint)pbVar2[1] & 0xc0) == 0x80) &&
       (uVar3 = (uVar5 & 0x1f) * 0x40 + ((uint)pbVar2[1] & 0x3f), 0x7f < uVar3)) goto LAB_080ad390;
    break;
  case '\x03':
    pbVar4 = pbVar2 + 1;
    if (((((uint)pbVar2[1] & 0xc0) == 0x80) && (((uint)pbVar2[2] & 0xc0) == 0x80)) &&
       ((uVar3 = (uVar5 & 0xf) * 0x1000 + ((uint)pbVar2[2] & 0x3f) + ((uint)pbVar2[1] & 0x3f) * 0x40
        , 0x7ff < uVar3 && ((uVar3 & 0xfffff800) != 0xd800)))) goto LAB_080ad390;
    break;
  case '\x04':
    pbVar4 = pbVar2 + 1;
    if ((((uint)pbVar2[1] & 0xc0) == 0x80) &&
       (((((uint)pbVar2[2] & 0xc0) == 0x80 && (((uint)pbVar2[3] & 0xc0) == 0x80)) &&
        (uVar3 = (uVar5 & 0xf) * 0x40000 + ((uint)pbVar2[3] & 0x3f) +
                 ((uint)pbVar2[1] & 0x3f) * 0x1000 + ((uint)pbVar2[2] & 0x3f) * 0x40, 0xffff < uVar3
        )))) goto LAB_080ad390;
    break;
  case '\x05':
    pbVar4 = pbVar2 + 1;
    if (((((uint)pbVar2[1] & 0xc0) == 0x80) && (((uint)pbVar2[2] & 0xc0) == 0x80)) &&
       ((((uint)pbVar2[3] & 0xc0) == 0x80 &&
        ((((uint)pbVar2[4] & 0xc0) == 0x80 &&
         (uVar3 = (uVar5 & 0xf) * 0x1000000 + ((uint)pbVar2[4] & 0x3f) +
                  ((uint)pbVar2[1] & 0x3f) * 0x40000 + ((uint)pbVar2[2] & 0x3f) * 0x1000 +
                  ((uint)pbVar2[3] & 0x3f) * 0x40, 0x1fffff < uVar3)))))) goto LAB_080ad390;
    break;
  case '\x06':
    pbVar4 = pbVar2 + 1;
    if (((((((uint)pbVar2[1] & 0xc0) == 0x80) && (((uint)pbVar2[2] & 0xc0) == 0x80)) &&
         (((uint)pbVar2[3] & 0xc0) == 0x80)) &&
        ((((uint)pbVar2[4] & 0xc0) == 0x80 && (((uint)pbVar2[5] & 0xc0) == 0x80)))) &&
       (uVar3 = (uVar5 & 1) * 0x40000000 + ((uint)pbVar2[5] & 0x3f) +
                ((uint)pbVar2[1] & 0x3f) * 0x1000000 + ((uint)pbVar2[2] & 0x3f) * 0x40000 +
                ((uint)pbVar2[3] & 0x3f) * 0x1000 + ((uint)pbVar2[4] & 0x3f) * 0x40,
       0x3ffffff < uVar3)) goto LAB_080ad390;
  }
  *string = pbVar4;
  return 0xfffd;
}



unicode_val_T cp_to_unicode(int codepage,uchar **string,uchar *end)

{
  unicode_val_T uVar1;
  
  if (codepages[codepage & 0xffffff7f].aliases != aliases_utf8) {
    uVar1 = 0xfffffffd;
    if (*string < end) {
      uVar1 = cp2u(codepage,**string);
      *string = *string + 1;
    }
    return uVar1;
  }
  uVar1 = utf8_to_unicode(string,end);
  return uVar1;
}



void __regparm3 free_translation_table(conv_table *p)

{
  conv_table *pcVar1;
  int iVar2;
  
  iVar2 = 0;
  do {
    while (p[iVar2].t != 0) {
      pcVar1 = p + iVar2;
      iVar2 = iVar2 + 1;
      free_translation_table((conv_table *)pcVar1->u);
      if (iVar2 == 0x100) goto LAB_080ad616;
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 != 0x100);
LAB_080ad616:
  mem_free(p);
  return;
}



void __regparm3 new_translation_table(conv_table *p)

{
  conv_table *pcVar1;
  int iVar2;
  
  iVar2 = 0;
  do {
    while (p[iVar2].t != 0) {
      pcVar1 = p + iVar2;
      iVar2 = iVar2 + 1;
      free_translation_table((conv_table *)pcVar1->u);
      if (iVar2 == 0x100) goto LAB_080ad666;
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 != 0x100);
LAB_080ad666:
  iVar2 = 0;
  do {
    (&p->t)[iVar2] = 0;
    *(char **)(&p->u + iVar2) = "" + iVar2;
    iVar2 = iVar2 + 2;
  } while (iVar2 != 0x100);
  iVar2 = 0x80;
  do {
    p[iVar2].t = 0;
    p[iVar2].u = 0x810bfc8;
    iVar2 = iVar2 + 1;
  } while (iVar2 != 0x100);
  return;
}



unicode_val_T unicode_fold_label_case(unicode_val_T c)

{
  wint_t wVar1;
  
  wVar1 = towlower(c);
  return wVar1;
}



int utf8_ptr2chars(uchar *string,uchar *end)

{
  int iVar1;
  byte *pbVar2;
  
  if (((end != (uchar *)0x0) || (end = (uchar *)__rawmemchr(string,0), end != (byte *)0x0)) &&
     (string != (uchar *)0x0)) {
    pbVar2 = string + ((char *)0x810bfe0)[*string];
    iVar1 = 0;
    while (pbVar2 <= end) {
      iVar1 = iVar1 + 1;
      pbVar2 = pbVar2 + ((char *)0x810bfe0)[*pbVar2];
    }
    return iVar1;
  }
  return -1;
}



int strlen_utf8(uchar **str)

{
  byte *pbVar1;
  int iVar2;
  byte *pbVar3;
  byte *pbVar4;
  
  pbVar4 = *str;
  pbVar1 = (byte *)__rawmemchr(pbVar4,0);
  iVar2 = 0;
  while ((pbVar3 = pbVar4, pbVar4 == (byte *)0x0 ||
         (pbVar3 = pbVar4 + ((char *)0x810bfe0)[*pbVar4], pbVar3 <= pbVar1))) {
    iVar2 = iVar2 + 1;
    pbVar4 = pbVar3;
  }
  *str = pbVar4;
  return iVar2;
}



void free_conv_table(void)

{
  int iVar1;
  conv_table *pcVar2;
  byte bVar3;
  
  bVar3 = 0;
  if (utf_table_init == 0) {
    iVar1 = 0x80;
    do {
      pcVar2 = utf_table + iVar1;
      iVar1 = iVar1 + 1;
      mem_free((void *)pcVar2->u);
    } while (iVar1 != 0x100);
  }
  if (first != 0) {
    iVar1 = 0x200;
    pcVar2 = table_elinks;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      pcVar2->t = 0;
      pcVar2 = (conv_table *)(&pcVar2->t + (uint)bVar3 * 0x3ffffffe + 1);
    }
    first = 0;
  }
  new_translation_table(table_elinks);
  return;
}



uchar * encode_utf8(unicode_val_T u)

{
  byte bVar1;
  uint3 uVar2;
  byte bVar3;
  
  utf_buffer._4_2_ = 0;
  bVar3 = (byte)u;
  if (u < 0x80) {
    utf_buffer._0_4_ = u & 0xff;
    utf_buffer._4_2_ = 0;
    utf_buffer[6] = '\0';
    return utf_buffer;
  }
  if (u < 0x800) {
    utf_buffer._0_4_ = (uint)(CONCAT11(bVar3,(char)(u >> 6)) & 0xff1f | 0xc0) & 0xffff3fff | 0x8000;
  }
  else {
    if (u < 0x10000) {
      uVar2 = CONCAT12(bVar3,(short)(u >> 0xc)) & 0xff000f | 0xe0;
      utf_buffer._0_4_ =
           (uint)uVar2 & 0xff3f0000 | 0x800000 |
           (uint)CONCAT11((char)(u >> 6),(char)uVar2) & 0xffff3fff | 0x8000;
      utf_buffer._4_2_ = 0;
      utf_buffer[6] = '\0';
      return utf_buffer;
    }
    if (u < 0x200000) {
      utf_buffer._0_4_ =
           CONCAT13(bVar3,CONCAT12((char)(u >> 6),CONCAT11((char)(u >> 0xc),(char)(u >> 0x12)))) &
           0x3f3f3fff | 0x808080f0;
    }
    else {
      bVar1 = (byte)(u >> 0x18);
      if (u < 0x4000000) {
        utf_buffer._0_4_ =
             CONCAT13((char)(u >> 6),CONCAT12((char)(u >> 0xc),CONCAT11((char)(u >> 0x12),bVar1))) &
             0x3f3f3fff | 0x808080f8;
        utf_buffer._4_2_ = (ushort)bVar3 & 0xff3f | 0x80;
      }
      else {
        utf_buffer._0_4_ =
             CONCAT13((char)(u >> 0xc),CONCAT12((char)(u >> 0x12),CONCAT11(bVar1,bVar1 >> 6))) &
             0x3f3f3f01 | 0x808080fc;
        utf_buffer._4_2_ = CONCAT11(bVar3,(char)(u >> 6)) & 0x3f3f | 0x8080;
      }
    }
  }
  utf_buffer[6] = '\0';
  return utf_buffer;
}



uchar * u2cp_(unicode_val_T u,int to,nbsp_mode nbsp_mode)

{
  byte bVar1;
  ushort uVar2;
  uint uVar3;
  uchar *puVar4;
  int iVar5;
  table_entry *ptVar6;
  int iVar7;
  int iVar8;
  
  if (0x7f < u) {
    do {
      to = to & 0xffffff7f;
      if (codepages[to].aliases == aliases_utf8) {
        puVar4 = encode_utf8(u);
        return puVar4;
      }
      if (u == 0xa0) {
        if (nbsp_mode != NBSP_MODE_HACK) {
          return " ";
        }
        return "\x01";
      }
      if (u == 0xad) {
        return "";
      }
      if (0x9f < u) {
        if (u < 0xffff) {
          iVar5 = 0;
          do {
            if ((uint)codepages[to].highhalf[iVar5] == u) {
              return (uchar *)("" + iVar5 * 2 + 0x100);
            }
            iVar5 = iVar5 + 1;
          } while (iVar5 != 0x80);
        }
        ptVar6 = codepages[to].table_elinks;
        bVar1 = ptVar6->c;
        if (bVar1 != 0) {
          uVar2 = ptVar6->u;
          while( true ) {
            if ((uint)uVar2 == u) {
              return (uchar *)("" + (uint)bVar1 * 2);
            }
            bVar1 = ptVar6[1].c;
            if (bVar1 == 0) break;
            uVar2 = ptVar6[1].u;
            ptVar6 = ptVar6 + 1;
          }
        }
        iVar8 = 0x993;
        iVar5 = 0;
        do {
          iVar7 = iVar5 + iVar8 >> 1;
          uVar3 = unicode_7b[iVar7].x;
          if (uVar3 == u) {
            return unicode_7b[iVar7].s;
          }
          if (u < uVar3) {
            iVar8 = iVar7 + -1;
          }
          if (uVar3 < u) {
            iVar5 = iVar7 + 1;
          }
        } while (iVar5 <= iVar8);
        return "*";
      }
      u = (&unicode_7b[0x978].x)[u];
      if (u == 0) {
        return (uchar *)0x0;
      }
    } while (0x7f < u);
  }
  return (uchar *)("" + u * 2);
}



uchar * get_entity_string(uchar *str,int strlen,int encoding)

{
  byte bVar1;
  int first_time;
  uint nb_entity_cache [9];
  entity_cache entity_cache [9] [10];
  uint to;
  int iVar2;
  void *pvVar3;
  uint __nmemb;
  uint uVar4;
  ushort **ppuVar5;
  int iVar6;
  size_t __n;
  uint *puVar7;
  uchar *puVar8;
  unicode_val_T u;
  byte *pbVar9;
  uchar *puVar10;
  undefined4 *puVar11;
  bool bVar12;
  int local_38;
  string key;
  
  if (strlen < 1) {
    return (uchar *)0x0;
  }
  to = encoding & 0xffffff7f;
  if (codepages[to].aliases == aliases_utf8) {
skip:
    local_38 = 0;
  }
  else {
    if (first_time != 0) {
      iVar2 = 9;
      puVar11 = (undefined4 *)0x8149480;
      while (iVar2 != 0) {
        iVar2 = iVar2 + -1;
        *puVar11 = 0;
        puVar11 = puVar11 + 1;
      }
      first_time = 0;
    }
    local_38 = strlen;
    if (6 < strlen - 2U) {
      if (8 < strlen) goto skip;
      local_38 = 0;
    }
    __nmemb = *(uint *)(local_38 * 4 + 0x8149480);
    if (__nmemb != 0) {
      uVar4 = 0;
      puVar7 = (uint *)(local_38 * 0x168 + 0x81494c8);
      do {
        if (*puVar7 == to) {
          iVar2 = local_38 * 0x168 + uVar4 * 0x24;
          bVar12 = true;
          iVar6 = strlen;
          puVar8 = str;
          puVar10 = (uchar *)(iVar2 + 0x81494d0);
          do {
            if (iVar6 == 0) break;
            iVar6 = iVar6 + -1;
            bVar12 = *puVar8 == *puVar10;
            puVar8 = puVar8 + 1;
            puVar10 = puVar10 + 1;
          } while (bVar12);
          if (bVar12) {
            if (*(int *)(iVar2 + 0x81494c0) != -1) {
              *(int *)(iVar2 + 0x81494c0) = *(int *)(iVar2 + 0x81494c0) + 1;
            }
            return *(uchar **)(local_38 * 0x168 + 0x81494cc + uVar4 * 0x24);
          }
        }
        uVar4 = uVar4 + 1;
        puVar7 = puVar7 + 9;
      } while (uVar4 < __nmemb);
    }
  }
  if (*str == '#') {
    puVar8 = (uchar *)0x0;
    __n = 1;
    if (strlen != 1) {
      pbVar9 = str + 1;
      iVar2 = strlen + -1;
      bVar1 = str[1];
      if ((bVar1 | 0x20) == 0x78) {
        if ((iVar2 < 10) && (iVar2 != 1)) {
          iVar2 = strlen + -2;
          u = 0;
          pbVar9 = str + 2;
          do {
            bVar1 = *pbVar9;
            pbVar9 = pbVar9 + 1;
            __nmemb = (uint)bVar1 | 0x20;
            if ((byte)((char)__nmemb - 0x30U) < 10) {
              u = u << 4 | __nmemb - 0x30;
            }
            else {
              ppuVar5 = __ctype_b_loc();
              if ((*(byte *)((int)*ppuVar5 + __nmemb * 2 + 1) & 0x10) == 0) {
                puVar8 = (uchar *)0x0;
                goto LAB_080adc6a;
              }
              u = u << 4 | __nmemb - 0x57;
            }
            iVar2 = iVar2 + -1;
          } while (iVar2 != 0);
LAB_080adbec:
          puVar8 = u2cp_(u,to,NBSP_MODE_HACK);
          goto LAB_080adc5e;
        }
      }
      else {
        if (iVar2 < 0xb) {
          u = 0;
          while (((byte)(bVar1 - 0x30) < 10 && (u = ((uint)bVar1 - 0x30) + u * 10, u != 0xffffffff))
                ) {
            iVar2 = iVar2 + -1;
            if (iVar2 == 0) goto LAB_080adbec;
            pbVar9 = pbVar9 + 1;
            bVar1 = *pbVar9;
          }
        }
      }
      puVar8 = (uchar *)0x0;
      goto LAB_080adc6a;
    }
  }
  else {
    puVar8 = (uchar *)0x0;
    key.source = str;
    key.length = strlen;
    pvVar3 = bsearch(&key,entities,0x3e9,8,compare_entities);
    if (pvVar3 != (void *)0x0) {
      puVar8 = u2cp_(*(unicode_val_T *)((int)pvVar3 + 4),to,NBSP_MODE_HACK);
    }
LAB_080adc5e:
    if (codepages[to].aliases == aliases_utf8) {
      return puVar8;
    }
LAB_080adc6a:
    __n = strlen;
    if (0x13 < (uint)strlen) {
      return puVar8;
    }
  }
  __nmemb = ((uint *)&ram0x08149480)[local_38];
  if (1 < __nmemb) {
    qsort((void *)(local_38 * 0x168 + 0x81494c0),__nmemb,0x24,hits_cmp);
    __nmemb = *(uint *)(local_38 * 4 + 0x8149480);
    if (9 < __nmemb) goto LAB_080adc97;
  }
  __nmemb = __nmemb + 1;
  *(uint *)(local_38 * 4 + 0x8149480) = __nmemb;
LAB_080adc97:
  iVar2 = local_38 * 0x168 + -0x24 + __nmemb * 0x24;
  ((entity_cache *)&ram0x081494c0)[__nmemb + local_38 * 10 + -1].hits = 1;
  *(int *)(iVar2 + 0x81494c4) = strlen;
  *(uchar **)(iVar2 + 0x81494cc) = puVar8;
  *(uint *)(iVar2 + 0x81494c8) = to;
  memcpy((void *)(iVar2 + 0x81494d0),str,__n);
  *(undefined *)(iVar2 + 0x81494d0 + strlen) = 0;
  return puVar8;
}



uchar * convert_string_elinks
                  (conv_table *convert_table,uchar *chars,int charslen,int cp,
                  convert_string_mode mode,int *length,
                  anon_subr_void_void_ptr_uchar_ptr_int *callback,void *callback_data)

{
  byte bVar1;
  byte bVar2;
  uchar uVar3;
  void *pvVar4;
  byte *pbVar5;
  uchar *puVar6;
  uchar *puVar7;
  byte *pbVar8;
  int iVar9;
  int iVar10;
  conv_table *pcVar11;
  uchar *local_24;
  int local_20;
  
  if ((convert_table == (conv_table *)0x0) &&
     (pvVar4 = memchr(chars,0x26,charslen), pvVar4 == (void *)0x0)) {
    if (callback == (anon_subr_void_void_ptr_uchar_ptr_int *)0x0) {
      puVar6 = memacpy(chars,charslen);
      return puVar6;
    }
    local_24 = (uchar *)0x0;
    if (charslen != 0) {
      (*callback)(callback_data,chars,charslen);
      local_24 = (uchar *)0x0;
    }
  }
  else {
    local_24 = (uchar *)mem_alloc(0x101);
    if (local_24 != (uchar *)0x0) {
      iVar9 = 0;
      local_20 = 0;
      if (0 < charslen) {
        do {
          pbVar5 = chars + local_20;
          bVar1 = *pbVar5;
          if (bVar1 == 0x26) {
            if (mode + ~CSM_QUERY < 2) {
              local_24[iVar9] = '&';
              local_20 = local_20 + 1;
              goto flush;
            }
            local_20 = local_20 + 1;
            pbVar8 = pbVar5;
            iVar10 = local_20;
            while ((iVar10 < charslen &&
                   ((((bVar1 = pbVar8[1], (byte)(bVar1 + 0x9f) < 0x1a ||
                      ((byte)(bVar1 + 0xbf) < 0x1a)) || ((byte)(bVar1 - 0x30) < 10)) ||
                    (bVar1 == 0x23))))) {
              iVar10 = iVar10 + 1;
              pbVar8 = pbVar8 + 1;
            }
            if (((mode == CSM_DEFAULT) || ((chars[iVar10] != '=' && (chars[iVar10] != '&')))) &&
               (local_20 < iVar10)) {
              uVar3 = chars[iVar10];
              if (((0x19 < (byte)(uVar3 + 0x9f)) && (0x19 < (byte)(uVar3 + 0xbf))) &&
                 (9 < (byte)(uVar3 - 0x30))) {
                puVar6 = get_entity_string(chars + local_20,iVar10 - local_20,cp);
                iVar10 = iVar10 - (uint)(chars[iVar10] != ';');
                if (puVar6 == (uchar *)0x0) {
                  local_24[iVar9] = *pbVar5;
                  goto flush;
                }
                local_20 = (uint)(iVar10 < charslen) + iVar10;
                goto LAB_080ae179;
              }
            }
            local_24[iVar9] = '&';
flush:
            iVar10 = iVar9 + 1;
            puVar6 = "";
            puVar7 = local_24;
            if ((char)iVar10 != '\0') goto LAB_080adfa9;
            do {
              if (callback == (anon_subr_void_void_ptr_uchar_ptr_int *)0x0) {
                puVar7 = (uchar *)mem_realloc(local_24,iVar10 + 0x100);
                if (puVar7 == (uchar *)0x0) {
                  mem_free(local_24);
                  return (uchar *)0x0;
                }
              }
              else {
                local_24[iVar10] = '\0';
                (*callback)(callback_data,local_24,iVar10);
                iVar10 = 0;
                puVar7 = local_24;
              }
LAB_080adfa9:
              local_24 = puVar7;
              uVar3 = *puVar6;
              iVar9 = iVar10;
              while( true ) {
                if (uVar3 == '\0') goto LAB_080adfc9;
LAB_080adfb3:
                puVar6 = puVar6 + 1;
                iVar10 = iVar9 + 1;
                local_24[iVar9] = uVar3;
                if ((char)iVar10 == '\0') break;
                uVar3 = *puVar6;
                iVar9 = iVar10;
              }
            } while( true );
          }
          if ((-1 < (char)bVar1) ||
             (iVar10 = local_20, pcVar11 = convert_table, bVar2 = bVar1,
             convert_table == (conv_table *)0x0)) {
LAB_080adf66:
            local_24[iVar9] = bVar1;
            local_20 = local_20 + 1;
            goto flush;
          }
          while (pcVar11 = pcVar11 + bVar2, pcVar11->t != 0) {
            pbVar5 = pbVar5 + 1;
            if (charslen <= iVar10 + 1) goto LAB_080adf66;
            iVar10 = iVar10 + 1;
            pcVar11 = (conv_table *)pcVar11->u;
            bVar2 = *pbVar5;
          }
          local_20 = iVar10 + 1;
          puVar6 = (uchar *)pcVar11->u;
LAB_080ae179:
          uVar3 = *puVar6;
          if (uVar3 != '\0') {
            if (puVar6[1] != '\0') goto LAB_080adfb3;
            local_24[iVar9] = uVar3;
            goto flush;
          }
LAB_080adfc9:
        } while (local_20 < charslen);
      }
      local_24[iVar9] = '\0';
      if (length != (int *)0x0) {
        *length = iVar9;
      }
      if (callback != (anon_subr_void_void_ptr_uchar_ptr_int *)0x0) {
        if (iVar9 != 0) {
          (*callback)(callback_data,local_24,iVar9);
        }
        mem_free(local_24);
        local_24 = (uchar *)0x0;
      }
    }
  }
  return local_24;
}



void __regparm3 add_utf8(unicode_val_T u,uchar *str)

{
  byte bVar1;
  byte bVar2;
  byte *pbVar3;
  conv_table *p;
  conv_table *pcVar4;
  bool bVar5;
  
  utf_buffer._4_2_ = 0;
  utf_buffer[6] = '\0';
  bVar2 = (byte)u;
  if (u < 0x80) {
    utf_buffer._0_4_ = u & 0xff;
  }
  else {
    if (u < 0x800) {
      utf_buffer._0_4_ =
           (uint)(CONCAT11(bVar2,(char)(u >> 6)) & 0xff1f | 0xc0) & 0xffff3fff | 0x8000;
    }
    else {
      if (u < 0x10000) {
        utf_buffer._0_4_ =
             (uint)(CONCAT12(bVar2,CONCAT11((char)(u >> 6),(char)(u >> 0xc))) & 0xff3f0f | 0x80e0) &
             0xff3fffff | 0x800000;
      }
      else {
        if (u < 0x200000) {
          utf_buffer._0_4_ =
               CONCAT13(bVar2,CONCAT12((char)(u >> 6),CONCAT11((char)(u >> 0xc),(char)(u >> 0x12))))
               & 0x3f3f3fff | 0x808080f0;
        }
        else {
          bVar1 = (byte)(u >> 0x18);
          if (u < 0x4000000) {
            utf_buffer._0_4_ =
                 CONCAT13((char)(u >> 6),
                          CONCAT12((char)(u >> 0xc),CONCAT11((char)(u >> 0x12),bVar1))) & 0x3f3f3fff
                 | 0x808080f8;
            utf_buffer._4_2_ = (ushort)bVar2 & 0xff3f | 0x80;
          }
          else {
            utf_buffer._0_4_ =
                 CONCAT13((char)(u >> 0xc),CONCAT12((char)(u >> 0x12),CONCAT11(bVar1,bVar1 >> 6))) &
                 0x3f3f3f01 | 0x808080fc;
            utf_buffer._4_2_ = CONCAT11(bVar2,(char)(u >> 6)) & 0x3f3f | 0x8080;
          }
        }
      }
    }
  }
  pbVar3 = utf_buffer;
  pcVar4 = table_elinks;
  while (pbVar3[1] != 0) {
    p = pcVar4 + *pbVar3;
    if (p->t == 0) {
      if (assert_failed != 0) goto LAB_080ae3c9;
      bVar5 = (uchar *)p->u != "*";
      assert_failed = ZEXT14(bVar5);
      if (bVar5) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
        errline = 0x316;
        elinks_internal((uchar *)"assertion ct[*p].u.str == no_str failed: bad utf encoding #1");
        if (assert_failed != 0) goto LAB_080ae3c9;
      }
      p = (conv_table *)mem_calloc(0x100,8);
      if (p == (conv_table *)0x0) {
        return;
      }
      new_translation_table(p);
      pcVar4[*pbVar3].t = 1;
      *(conv_table **)&pcVar4[*pbVar3].u = p;
      pbVar3 = pbVar3 + 1;
      pcVar4 = p;
    }
    else {
      pcVar4 = (conv_table *)p->u;
      pbVar3 = pbVar3 + 1;
    }
  }
  if (assert_failed == 0) {
    bVar5 = pcVar4[*pbVar3].t != 0;
    assert_failed = ZEXT14(bVar5);
    if (bVar5) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
      errline = 0x323;
      elinks_internal((uchar *)"assertion !ct[*p].t failed: bad utf encoding #2");
      if (assert_failed != 0) goto LAB_080ae3c9;
    }
    if ((uchar *)pcVar4[*pbVar3].u == "*") {
      *(uchar **)&pcVar4[*pbVar3].u = str;
    }
  }
  else {
LAB_080ae3c9:
    assert_failed = 0;
  }
  return;
}



uchar * cp2utf8(int from,int c)

{
  ushort uVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  
  if ((c < 0x80) || (codepages[from & 0xffffff7fU].aliases == aliases_utf8)) {
    return (uchar *)("" + c * 2);
  }
  uVar1 = codepages[from & 0xffffff7fU].highhalf[(c & 0xffU) - 0x80];
  if (uVar1 == 0xffff) {
    bVar2 = 0xbd;
    bVar4 = 0xbf;
    bVar3 = 0xef;
  }
  else {
    if (uVar1 < 0x80) {
      utf_buffer._0_4_ = (uint)(byte)uVar1;
      utf_buffer._4_2_ = 0;
      utf_buffer[6] = '\0';
      return utf_buffer;
    }
    if (uVar1 < 0x800) {
      utf_buffer._0_4_ = (uint)(ushort)(uVar1 >> 6 & 0xff | uVar1 << 8) & 0xffff3f1f | 0x80c0;
      utf_buffer._4_2_ = 0;
      utf_buffer[6] = '\0';
      return utf_buffer;
    }
    bVar3 = (byte)(uVar1 >> 0xc) | 0xe0;
    bVar4 = (byte)(uVar1 >> 6) & 0x3f | 0x80;
    bVar2 = (byte)uVar1 & 0x3f | 0x80;
  }
  utf_buffer._0_2_ = CONCAT11(bVar4,bVar3);
  utf_buffer._0_4_ = (uint)CONCAT12(bVar2,utf_buffer._0_2_);
  utf_buffer._4_2_ = 0;
  utf_buffer[6] = '\0';
  return utf_buffer;
}



uchar * utf8_step_backward(uchar *string,uchar *start,int max,utf8_step way,int *count)

{
  int iVar1;
  byte bVar2;
  byte *pbVar3;
  byte *pbVar4;
  int iVar5;
  uint uVar6;
  byte *local_40;
  int local_20;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(string == (uchar *)0x0);
    if (string == (uchar *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
      errline = 0x1fe;
      elinks_internal((uchar *)"assertion string failed!");
      if (assert_failed != 0) goto LAB_080ae700;
    }
    assert_failed = ZEXT14(start == (uchar *)0x0);
    if (start == (uchar *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
      errline = 0x1ff;
      elinks_internal((uchar *)"assertion start failed!");
      if (assert_failed != 0) goto LAB_080ae700;
    }
    assert_failed = -(max >> 0x1f);
    if (assert_failed != 0) {
      assert_failed = -(max >> 0x1f);
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
      errline = 0x200;
      elinks_internal((uchar *)"assertion max >= 0 failed!");
      if (assert_failed != 0) goto LAB_080ae700;
    }
    local_20 = 0;
    if (way == UTF8_STEP_CHARACTERS) {
      local_20 = 0;
      while (start < string) {
        while( true ) {
          if (max <= local_20) goto LAB_080ae713;
          string = string + -1;
          if (((char)*string < '\0') && ((*string & 0xc0) != 0xc0)) break;
          local_20 = local_20 + 1;
          if (string <= start) goto LAB_080ae713;
        }
      }
    }
    else {
      if (way < (UTF8_STEP_CELLS_FEWER|UTF8_STEP_CELLS_MORE)) {
        if ((0 < max) && (start < string)) {
          local_40 = string;
          do {
            pbVar3 = string;
            string = pbVar3 + -1;
            if (string <= start) goto LAB_080ae8f8;
LAB_080ae766:
            bVar2 = pbVar3[-1];
            uVar6 = (uint)bVar2;
            pbVar4 = pbVar3;
          } while (((char)bVar2 < '\0') && (uVar6 = (uint)bVar2, (uVar6 & 0xc0) != 0xc0));
          do {
            pbVar3 = string;
            if (local_40 < pbVar3 + ((char *)0x810bfe0)[uVar6]) {
LAB_080ae858:
              iVar5 = 1;
              if (way == UTF8_STEP_CELLS_FEWER) goto LAB_080ae863;
LAB_080ae8d3:
              iVar1 = local_20 + iVar5;
            }
            else {
              switch(((char *)0x810bfe0)[uVar6]) {
              default:
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
                errline = 0x2cf;
                elinks_internal((uchar *)"utf8char_len_tab out of range");
                uVar6 = 0xfffd;
                goto LAB_080ae7d0;
              case '\x01':
                if ((char)bVar2 < '\0') break;
                uVar6 = (uint)bVar2;
LAB_080aeacb:
                if (uVar6 < 0x1100) goto LAB_080ae858;
                if (((uVar6 != 0x2329) && (0x115f < uVar6)) && (uVar6 != 0x232a)) goto LAB_080ae7d0;
                goto LAB_080ae8c8;
              case '\x02':
                if ((((uint)*pbVar4 & 0xc0) == 0x80) &&
                   (uVar6 = ((uint)*pbVar4 & 0x3f) + (uVar6 & 0x1f) * 0x40, 0x7f < uVar6)) {
LAB_080ae9a8:
                  if (uVar6 != 0xfffffffd) goto LAB_080aeacb;
                  goto LAB_080ae858;
                }
                break;
              case '\x03':
                if (((((uint)*pbVar4 & 0xc0) == 0x80) && (((uint)pbVar3[2] & 0xc0) == 0x80)) &&
                   ((uVar6 = ((uint)pbVar3[2] & 0x3f) + (uVar6 & 0xf) * 0x1000 +
                             ((uint)*pbVar4 & 0x3f) * 0x40, 0x7ff < uVar6 &&
                    ((uVar6 & 0xfffff800) != 0xd800)))) goto LAB_080ae9a8;
                break;
              case '\x04':
                if ((((uint)*pbVar4 & 0xc0) == 0x80) &&
                   (((((uint)pbVar3[2] & 0xc0) == 0x80 && (((uint)pbVar3[3] & 0xc0) == 0x80)) &&
                    (uVar6 = ((uint)pbVar3[3] & 0x3f) + (uVar6 & 0xf) * 0x40000 +
                             ((uint)*pbVar4 & 0x3f) * 0x1000 + ((uint)pbVar3[2] & 0x3f) * 0x40,
                    0xffff < uVar6)))) goto LAB_080ae9a8;
                break;
              case '\x05':
                if (((((uint)*pbVar4 & 0xc0) == 0x80) && (((uint)pbVar3[2] & 0xc0) == 0x80)) &&
                   ((((uint)pbVar3[3] & 0xc0) == 0x80 &&
                    ((((uint)pbVar3[4] & 0xc0) == 0x80 &&
                     (uVar6 = ((uint)pbVar3[4] & 0x3f) + (uVar6 & 0xf) * 0x1000000 +
                              ((uint)*pbVar4 & 0x3f) * 0x40000 + ((uint)pbVar3[2] & 0x3f) * 0x1000 +
                              ((uint)pbVar3[3] & 0x3f) * 0x40, 0x1fffff < uVar6))))))
                goto LAB_080ae9a8;
                break;
              case '\x06':
                if (((((((uint)*pbVar4 & 0xc0) == 0x80) && (((uint)pbVar3[2] & 0xc0) == 0x80)) &&
                     (((uint)pbVar3[3] & 0xc0) == 0x80)) &&
                    ((((uint)pbVar3[4] & 0xc0) == 0x80 && (((uint)pbVar3[5] & 0xc0) == 0x80)))) &&
                   (uVar6 = ((uint)pbVar3[5] & 0x3f) + (uVar6 & 1) * 0x40000000 +
                            ((uint)*pbVar4 & 0x3f) * 0x1000000 + ((uint)pbVar3[2] & 0x3f) * 0x40000
                            + ((uint)pbVar3[3] & 0x3f) * 0x1000 + ((uint)pbVar3[4] & 0x3f) * 0x40,
                   0x3ffffff < uVar6)) goto LAB_080ae9a8;
              }
              uVar6 = 0xfffd;
LAB_080ae7d0:
              if (((((0x764f < uVar6 - 0x2e80) || (uVar6 == 0x303f)) &&
                   ((0x2ba3 < uVar6 - 0xac00 &&
                    ((0x1ff < uVar6 - 0xf900 && (0x3f < uVar6 - 0xfe30)))))) &&
                  (0x60 < uVar6 - 0xff00)) &&
                 (((6 < uVar6 - 0xffe0 && (0xfffd < uVar6 - 0x20000)) && (0xfffd < uVar6 - 0x30000))
                 )) goto LAB_080ae858;
LAB_080ae8c8:
              iVar5 = 2;
              if (way != UTF8_STEP_CELLS_FEWER) goto LAB_080ae8d3;
LAB_080ae863:
              string = local_40;
              iVar1 = iVar5 + local_20;
              if (max < iVar5 + local_20) goto LAB_080ae713;
            }
            local_20 = iVar1;
            string = pbVar3;
            if ((max <= local_20) || (pbVar3 <= start)) goto LAB_080ae713;
            string = pbVar3 + -1;
            local_40 = pbVar3;
            if (start < string) goto LAB_080ae766;
LAB_080ae8f8:
            bVar2 = pbVar3[-1];
            uVar6 = (uint)bVar2;
            pbVar4 = pbVar3;
          } while( true );
        }
        local_20 = 0;
      }
      else {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
        errline = 0x22e;
        elinks_internal((uchar *)"impossible enum utf8_step");
      }
    }
  }
  else {
LAB_080ae700:
    assert_failed = 0;
    local_20 = 0;
  }
LAB_080ae713:
  if (count != (int *)0x0) {
    *count = local_20;
  }
  return string;
}



// WARNING: Removing unreachable block (ram,0x080af268)
// WARNING: Removing unreachable block (ram,0x080af274)
// WARNING: Removing unreachable block (ram,0x080aef63)
// WARNING: Removing unreachable block (ram,0x080aef68)

uchar * utf8_step_forward(uchar *string,uchar *end,int max,utf8_step way,int *count)

{
  byte bVar1;
  int iVar2;
  byte *pbVar3;
  uchar *puVar4;
  int iVar5;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(string == (uchar *)0x0);
    if (string == (uchar *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
      errline = 0x1ba;
      elinks_internal((uchar *)"assertion string failed!");
      if (assert_failed != 0) goto LAB_080aed38;
    }
    assert_failed = -(max >> 0x1f);
    if (assert_failed != 0) {
      assert_failed = -(max >> 0x1f);
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
      errline = 0x1bb;
      elinks_internal((uchar *)"assertion max >= 0 failed!");
      if (assert_failed != 0) goto LAB_080aed38;
    }
    if (end == (uchar *)0x0) {
      end = (uchar *)__rawmemchr(string,0);
    }
    iVar5 = 0;
    if (way == UTF8_STEP_CHARACTERS) {
      while (string < end) {
        while( true ) {
          if (max <= iVar5) goto invalid_arg;
          string = string + 1;
          if (((char)*string < '\0') && ((*string & 0xc0) != 0xc0)) break;
          iVar5 = iVar5 + 1;
          if (end <= string) goto invalid_arg;
        }
      }
    }
    else {
      if (way < (UTF8_STEP_CELLS_FEWER|UTF8_STEP_CELLS_MORE)) {
        if ((string < end) && (0 < max)) {
          bVar1 = ((char *)0x810bfe0)[*string];
          iVar2 = iVar5;
          if (end < string + (char)bVar1) {
            iVar5 = 1;
            string = end;
          }
          else {
            do {
              iVar5 = iVar2;
              if (bVar1 < 7) {
                    // WARNING: Could not recover jumptable at 0x080aee98. Too many branches
                    // WARNING: Treating indirect jump as call
                puVar4 = (uchar *)(**(code **)(&DAT_081026b8 + (uint)bVar1 * 4))();
                return puVar4;
              }
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
              errline = 0x2cf;
              elinks_internal((uchar *)"utf8char_len_tab out of range");
              pbVar3 = string + 1;
              if (way == UTF8_STEP_CELLS_FEWER) {
                if (iVar5 + 1 <= max) {
                  if (iVar5 + 1 < max) goto LAB_080aee62;
LAB_080aef88:
                  iVar5 = iVar5 + 1;
                  string = pbVar3;
                }
                goto invalid_arg;
              }
              if (max <= iVar5 + 1) goto LAB_080aef88;
LAB_080aee62:
              if (end <= pbVar3) goto LAB_080aef88;
              bVar1 = ((char *)0x810bfe0)[*pbVar3];
              iVar2 = iVar5 + 1;
              string = pbVar3;
            } while (pbVar3 + (char)bVar1 <= end);
            iVar5 = iVar5 + 2;
            string = end;
          }
        }
        else {
          iVar5 = 0;
        }
      }
      else {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
        errline = 0x1e5;
        elinks_internal((uchar *)"impossible enum utf8_step");
      }
    }
  }
  else {
LAB_080aed38:
    assert_failed = 0;
    iVar5 = 0;
  }
invalid_arg:
  if (count != (int *)0x0) {
    *count = iVar5;
  }
  return string;
}



conv_table * get_translation_table(int from,int to)

{
  byte bVar1;
  ushort uVar2;
  uint16_t *puVar3;
  table_entry *ptVar4;
  int lto;
  int lfr;
  uchar *puVar5;
  conv_table *pcVar6;
  uint u;
  uint uVar7;
  int iVar8;
  byte bVar9;
  
  bVar9 = 0;
  uVar7 = from & 0xffffff7f;
  u = to & 0xffffff7f;
  if (first != 0) {
    iVar8 = 0x200;
    pcVar6 = table_elinks;
    while (iVar8 != 0) {
      iVar8 = iVar8 + -1;
      pcVar6->t = 0;
      pcVar6 = (conv_table *)&pcVar6->u;
    }
    first = 0;
  }
  if (codepages[u].aliases == aliases_utf8) {
    if (uVar7 != lfr) {
      iVar8 = 0x80;
      lfr = uVar7;
      if (utf_table_init == 0) {
        do {
          pcVar6 = utf_table + iVar8;
          iVar8 = iVar8 + 1;
          mem_free((void *)pcVar6->u);
        } while (iVar8 != 0x100);
      }
      else {
        iVar8 = 0x200;
        pcVar6 = utf_table;
        while (iVar8 != 0) {
          iVar8 = iVar8 + -1;
          pcVar6->t = 0;
          pcVar6 = (conv_table *)&pcVar6->u;
        }
        utf_table_init = 0;
      }
      iVar8 = 0;
      do {
        *(char **)(&utf_table[0].u + iVar8) = "" + iVar8;
        iVar8 = iVar8 + 2;
      } while (iVar8 != 0x100);
      if (codepages[uVar7].aliases == aliases_utf8) {
        iVar8 = 0;
        do {
          puVar5 = stracpy((uchar *)("" + iVar8 + 0x100));
          *(uchar **)(&utf_table[0x80].u + iVar8) = puVar5;
          iVar8 = iVar8 + 2;
        } while (iVar8 != 0x100);
      }
      else {
        puVar3 = codepages[uVar7].highhalf;
        iVar8 = 0x80;
        do {
          uVar2 = puVar3[iVar8 + -0x80];
          if (uVar2 == 0xffff) {
            utf_table[iVar8].u = 0;
          }
          else {
            utf_buffer._4_2_ = 0;
            utf_buffer[6] = '\0';
            if (uVar2 < 0x80) {
              utf_buffer._0_4_ = (uint)(byte)uVar2;
            }
            else {
              if (uVar2 < 0x800) {
                utf_buffer._0_4_ =
                     (uint)(ushort)(uVar2 >> 6 & 0x1f | uVar2 << 8 | 0xc0) & 0xffff3fff | 0x8000;
              }
              else {
                utf_buffer._0_4_ =
                     (uint)(CONCAT12((byte)uVar2,CONCAT11((char)(uVar2 >> 6),(byte)(uVar2 >> 0xc)))
                            & 0xff3fff | 0x80e0) & 0xff3fffff | 0x800000;
              }
            }
            puVar5 = stracpy(utf_buffer);
            *(uchar **)&utf_table[iVar8].u = puVar5;
          }
          iVar8 = iVar8 + 1;
        } while (iVar8 != 0x100);
        bVar1 = (codepages[uVar7].table_elinks)->c;
        ptVar4 = codepages[uVar7].table_elinks;
        while (bVar1 != 0) {
          uVar2 = ptVar4->u;
          if (utf_table[bVar1].u == 0) {
            iVar8 = 7;
            puVar5 = utf_buffer;
            while (iVar8 != 0) {
              iVar8 = iVar8 + -1;
              *puVar5 = '\0';
              puVar5 = puVar5 + (uint)bVar9 * -2 + 1;
            }
            if (uVar2 < 0x80) {
              utf_buffer._0_4_ = utf_buffer._0_4_ & 0xffffff00 | (uint)(byte)uVar2;
            }
            else {
              if (uVar2 < 0x800) {
                utf_buffer._0_4_ =
                     utf_buffer._0_4_ & 0xffff0000 |
                     (uint)(ushort)(uVar2 >> 6 & 0x1f | uVar2 << 8 | 0xc0) & 0xffff3fff | 0x8000;
              }
              else {
                utf_buffer._0_4_ =
                     utf_buffer._0_4_ & 0xff000000 |
                     (uint)(CONCAT12((byte)uVar2,CONCAT11((char)(uVar2 >> 6),(byte)(uVar2 >> 0xc)))
                            & 0xff3fff | 0x80e0) & 0xff3fffff | 0x800000;
              }
            }
            puVar5 = stracpy(utf_buffer);
            *(uchar **)&utf_table[bVar1].u = puVar5;
          }
          bVar1 = ptVar4[1].c;
          ptVar4 = ptVar4 + 1;
        }
        iVar8 = 0x80;
        do {
          if (utf_table[iVar8].u == 0) {
            puVar5 = stracpy("*");
            *(uchar **)&utf_table[iVar8].u = puVar5;
          }
          iVar8 = iVar8 + 1;
        } while (iVar8 != 0x100);
      }
    }
    pcVar6 = utf_table;
  }
  else {
    if ((uVar7 != lfr) || (pcVar6 = table_elinks, u != lto)) {
      lto = u;
      lfr = uVar7;
      new_translation_table(table_elinks);
      if (codepages[uVar7].aliases == aliases_utf8) {
        add_utf8(0xa0,"\x01");
        add_utf8(0xad,"");
        puVar3 = codepages[u].highhalf;
        iVar8 = 0;
        do {
          uVar2 = *(ushort *)((int)puVar3 + iVar8);
          if (uVar2 != 0xffff) {
            add_utf8((uint)uVar2,(uchar *)("" + iVar8 + 0x100));
          }
          iVar8 = iVar8 + 2;
        } while (iVar8 != 0x100);
        bVar9 = (codepages[u].table_elinks)->c;
        ptVar4 = codepages[u].table_elinks;
        while (bVar9 != 0) {
          add_utf8((uint)ptVar4->u,(uchar *)("" + (uint)bVar9 * 2));
          bVar9 = ptVar4[1].c;
          ptVar4 = ptVar4 + 1;
        }
        iVar8 = 0;
        while( true ) {
          iVar8 = iVar8 + 1;
          u = unicode_7b[iVar8].x;
          if (u == 0xffffffff) break;
          if (0x7f < u) {
            add_utf8(u,unicode_7b[iVar8].s);
          }
        }
      }
      else {
        puVar3 = codepages[uVar7].highhalf;
        iVar8 = 0x80;
        do {
          if ((puVar3[iVar8 + -0x80] != 0xffff) &&
             (puVar5 = u2cp_((uint)puVar3[iVar8 + -0x80],u,NBSP_MODE_HACK), puVar5 != (uchar *)0x0))
          {
            *(uchar **)&table_elinks[iVar8].u = puVar5;
          }
          iVar8 = iVar8 + 1;
        } while (iVar8 != 0x100);
      }
      pcVar6 = table_elinks;
    }
  }
  return pcVar6;
}



int utf8_char2cells(uchar *utf8_char,uchar *end)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  
  if (((end == (uchar *)0x0) && (end = (uchar *)__rawmemchr(utf8_char,0), end == (uchar *)0x0)) ||
     (utf8_char == (uchar *)0x0)) {
    return -1;
  }
  uVar3 = (uint)*utf8_char;
  uVar2 = 0xfffffffd;
  if (end < utf8_char + ((char *)0x810bfe0)[uVar3]) goto LAB_080af7a8;
  switch(((char *)0x810bfe0)[uVar3]) {
  default:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
    errline = 0x2cf;
    elinks_internal((uchar *)"utf8char_len_tab out of range");
    uVar2 = 0xfffd;
    goto LAB_080af7a8;
  case '\x01':
    if ((char)*utf8_char < '\0') break;
    goto LAB_080af82b;
  case '\x02':
    if ((((uint)utf8_char[1] & 0xc0) != 0x80) ||
       (uVar2 = (uVar3 & 0x1f) * 0x40 + ((uint)utf8_char[1] & 0x3f), uVar2 < 0x80)) break;
LAB_080af8a1:
    if (uVar2 < 0x1100) goto LAB_080af82b;
    if ((0x115f < uVar2) && (uVar2 != 0x2329)) goto LAB_080af9c2;
    goto LAB_080af8c8;
  case '\x03':
    if ((((((uint)utf8_char[1] & 0xc0) == 0x80) && (((uint)utf8_char[2] & 0xc0) == 0x80)) &&
        (uVar2 = (uVar3 & 0xf) * 0x1000 + ((uint)utf8_char[2] & 0x3f) +
                 ((uint)utf8_char[1] & 0x3f) * 0x40, 0x7ff < uVar2)) &&
       ((uVar2 & 0xfffff800) != 0xd800)) goto LAB_080af8a1;
    break;
  case '\x04':
    if (((((uint)utf8_char[1] & 0xc0) != 0x80) ||
        ((((uint)utf8_char[2] & 0xc0) != 0x80 || (((uint)utf8_char[3] & 0xc0) != 0x80)))) ||
       (uVar2 = (uVar3 & 0xf) * 0x40000 + ((uint)utf8_char[3] & 0x3f) +
                ((uint)utf8_char[1] & 0x3f) * 0x1000 + ((uint)utf8_char[2] & 0x3f) * 0x40,
       uVar2 < 0x10000)) break;
LAB_080af9c2:
    if (uVar2 == 0x232a) goto LAB_080af8c8;
    goto LAB_080af7a8;
  case '\x05':
    if ((((((uint)utf8_char[1] & 0xc0) == 0x80) && (((uint)utf8_char[2] & 0xc0) == 0x80)) &&
        (((uint)utf8_char[3] & 0xc0) == 0x80)) &&
       ((((uint)utf8_char[4] & 0xc0) == 0x80 &&
        (uVar2 = (uVar3 & 0xf) * 0x1000000 + ((uint)utf8_char[4] & 0x3f) +
                 ((uint)utf8_char[1] & 0x3f) * 0x40000 + ((uint)utf8_char[2] & 0x3f) * 0x1000 +
                 ((uint)utf8_char[3] & 0x3f) * 0x40, 0x1fffff < uVar2)))) goto LAB_080af9c2;
    break;
  case '\x06':
    if ((((((uint)utf8_char[1] & 0xc0) == 0x80) && (((uint)utf8_char[2] & 0xc0) == 0x80)) &&
        ((((uint)utf8_char[3] & 0xc0) == 0x80 &&
         ((((uint)utf8_char[4] & 0xc0) == 0x80 && (((uint)utf8_char[5] & 0xc0) == 0x80)))))) &&
       (uVar2 = (uVar3 & 1) * 0x40000000 + ((uint)utf8_char[5] & 0x3f) +
                ((uint)utf8_char[1] & 0x3f) * 0x1000000 + ((uint)utf8_char[2] & 0x3f) * 0x40000 +
                ((uint)utf8_char[3] & 0x3f) * 0x1000 + ((uint)utf8_char[4] & 0x3f) * 0x40,
       0x3ffffff < uVar2)) goto LAB_080af9c2;
  }
  uVar2 = 0xfffd;
LAB_080af7a8:
  if (((((uVar2 - 0x2e80 < 0x7650) && (uVar2 != 0x303f)) || (uVar2 - 0xac00 < 0x2ba4)) ||
      (((uVar2 - 0xf900 < 0x200 || (uVar2 - 0xfe30 < 0x40)) ||
       ((uVar2 - 0xff00 < 0x61 || ((uVar2 - 0xffe0 < 7 || (uVar2 - 0x20000 < 0xfffe)))))))) ||
     (uVar2 - 0x30000 < 0xfffe)) {
LAB_080af8c8:
    iVar1 = 2;
  }
  else {
LAB_080af82b:
    iVar1 = 1;
  }
  return iVar1;
}



int utf8_cells2bytes(uchar *string,int max_cells,uchar *end)

{
  byte *utf8_char;
  int iVar1;
  int iVar2;
  uint uVar3;
  
  if ((assert_failed == 0) && (assert_failed = -(max_cells >> 0x1f), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
    errline = 0x18d;
    elinks_internal((uchar *)"assertion max_cells>=0 failed!");
  }
  if (((end == (uchar *)0x0) && (end = (uchar *)__rawmemchr(string,0), end == (byte *)0x0)) ||
     (string == (uchar *)0x0)) {
LAB_080afb48:
    utf8_char = (byte *)0xffffffff;
  }
  else {
    iVar2 = 0;
    uVar3 = 0;
    utf8_char = string;
    do {
      do {
        iVar1 = utf8_char2cells(utf8_char,end);
        if (iVar1 < 0) goto LAB_080afb48;
        uVar3 = uVar3 + iVar1;
        if ((uint)max_cells < uVar3) {
          return iVar2;
        }
      } while (utf8_char == (byte *)0x0);
      iVar2 = iVar2 + ((char *)0x810bfe0)[*utf8_char];
      utf8_char = string + iVar2;
    } while (utf8_char <= end);
    utf8_char = end + -(int)string;
  }
  return (int)utf8_char;
}



int utf8_ptr2cells(uchar *string,uchar *end)

{
  byte *pbVar1;
  byte *pbVar2;
  int iVar3;
  int local_20;
  
  if (((end == (uchar *)0x0) && (end = (uchar *)__rawmemchr(string,0), end == (byte *)0x0)) ||
     (string == (uchar *)0x0)) {
LAB_080afc70:
    local_20 = -1;
  }
  else {
    local_20 = 0;
    pbVar2 = string + ((char *)0x810bfe0)[*string];
    while (pbVar1 = pbVar2, pbVar1 <= end) {
      iVar3 = utf8_char2cells(string,end);
      if (iVar3 < 0) goto LAB_080afc70;
      local_20 = local_20 + iVar3;
      pbVar2 = pbVar1 + ((char *)0x810bfe0)[*pbVar1];
      string = pbVar1;
    }
  }
  return local_20;
}



void __regparm3 set_binding_values(uchar *domainname,uchar **dirnamep,uchar **codesetp)

{
  binding *pbVar1;
  bool bVar2;
  uchar *puVar3;
  size_t sVar4;
  uchar *__s2;
  int iVar5;
  uchar *__s1;
  uchar *__ptr;
  binding *pbVar6;
  binding *__ptr_00;
  
  if ((domainname == (uchar *)0x0) || (*domainname == '\0')) goto failed;
  __ptr_00 = _nl_domain_bindings__;
  if (_nl_domain_bindings__ != (binding *)0x0) {
    while( true ) {
      iVar5 = strcmp((char *)domainname,(char *)__ptr_00->domainname);
      if (iVar5 == 0) break;
      if ((iVar5 < 0) || (__ptr_00 = __ptr_00->next, __ptr_00 == (binding *)0x0)) goto LAB_080afe18;
    }
    if (__ptr_00 != (binding *)0x0) {
      bVar2 = false;
      if (dirnamep != (uchar **)0x0) {
        __s1 = *dirnamep;
        if (__s1 == (uchar *)0x0) {
          *dirnamep = __ptr_00->dirname;
        }
        else {
          __s2 = __ptr_00->dirname;
          iVar5 = strcmp((char *)__s1,(char *)__s2);
          bVar2 = false;
          if (iVar5 != 0) {
            iVar5 = strcmp((char *)__s1,(char *)"/usr/share/locale");
            puVar3 = "/usr/share/locale";
            __ptr = __s2;
            if (iVar5 != 0) {
              __s2 = (uchar *)__strdup(__s1);
              bVar2 = false;
              if (__s2 == (uchar *)0x0) goto LAB_080afd95;
              __ptr = __ptr_00->dirname;
              puVar3 = __s2;
            }
            __s2 = puVar3;
            if (__ptr != "/usr/share/locale") {
              free(__ptr);
            }
            __ptr_00->dirname = __s2;
            bVar2 = true;
          }
LAB_080afd95:
          *dirnamep = __s2;
        }
      }
      if (codesetp != (uchar **)0x0) {
        __s1 = *codesetp;
        if (__s1 == (uchar *)0x0) {
          *codesetp = __ptr_00->codeset;
        }
        else {
          __s2 = __ptr_00->codeset;
          if (((__s2 == (uchar *)0x0) || (iVar5 = strcmp((char *)__s1,(char *)__s2), iVar5 != 0)) &&
             (__s2 = (uchar *)__strdup(__s1), __s2 != (uchar *)0x0)) {
            if (__ptr_00->codeset != (uchar *)0x0) {
              free(__ptr_00->codeset);
            }
            __ptr_00->codeset_cntr = __ptr_00->codeset_cntr + 1;
            bVar2 = true;
            __ptr_00->codeset = __s2;
          }
          *codesetp = __s2;
        }
      }
      if (!bVar2) {
        return;
      }
      goto LAB_080afe06;
    }
  }
LAB_080afe18:
  if (((dirnamep == (uchar **)0x0) || (*dirnamep == (uchar *)0x0)) &&
     ((codesetp == (uchar **)0x0 || (*codesetp == (uchar *)0x0)))) {
    if (dirnamep != (uchar **)0x0) {
      *dirnamep = "/usr/share/locale";
    }
    if (codesetp == (uchar **)0x0) {
      return;
    }
    *codesetp = (uchar *)0x0;
    return;
  }
  sVar4 = strlen((char *)domainname);
  __ptr_00 = (binding *)malloc(sVar4 + 0x11);
  if (__ptr_00 == (binding *)0x0) goto failed;
  memcpy(__ptr_00->domainname,domainname,sVar4 + 1);
  if (dirnamep != (uchar **)0x0) {
    __s1 = *dirnamep;
    __s2 = "/usr/share/locale";
    if (__s1 == (uchar *)0x0) {
LAB_080afe97:
      *dirnamep = __s2;
      __ptr_00->dirname = __s2;
      goto LAB_080afe9c;
    }
    iVar5 = strcmp((char *)__s1,(char *)"/usr/share/locale");
    __s2 = "/usr/share/locale";
    if ((iVar5 == 0) || (__s2 = (uchar *)__strdup(__s1), __s2 != (uchar *)0x0)) goto LAB_080afe97;
failed_dirname:
    free(__ptr_00);
failed:
    if (dirnamep != (uchar **)0x0) {
      *dirnamep = (uchar *)0x0;
    }
    if (codesetp != (uchar **)0x0) {
      *codesetp = (uchar *)0x0;
    }
    return;
  }
  __ptr_00->dirname = "/usr/share/locale";
LAB_080afe9c:
  __ptr_00->codeset_cntr = 0;
  if (codesetp == (uchar **)0x0) {
    __ptr_00->codeset = (uchar *)0x0;
    goto LAB_080afed3;
  }
  __s1 = *codesetp;
  if (__s1 != (uchar *)0x0) {
    __s1 = (uchar *)__strdup(__s1);
    if (__s1 == (uchar *)0x0) {
      if (__ptr_00->dirname != "/usr/share/locale") {
        free(__ptr_00->dirname);
      }
      goto failed_dirname;
    }
    __ptr_00->codeset_cntr = __ptr_00->codeset_cntr + 1;
  }
  *codesetp = __s1;
  __ptr_00->codeset = __s1;
LAB_080afed3:
  pbVar1 = _nl_domain_bindings__;
  if ((_nl_domain_bindings__ == (binding *)0x0) ||
     (iVar5 = strcmp((char *)domainname,(char *)_nl_domain_bindings__->domainname), iVar5 < 0)) {
    __ptr_00->next = pbVar1;
    _nl_domain_bindings__ = __ptr_00;
  }
  else {
    do {
      pbVar6 = pbVar1;
      pbVar1 = pbVar6->next;
      if (pbVar1 == (binding *)0x0) break;
      iVar5 = strcmp((char *)domainname,(char *)pbVar1->domainname);
    } while (0 < iVar5);
    __ptr_00->next = pbVar1;
    pbVar6->next = __ptr_00;
  }
LAB_080afe06:
  _nl_msg_cat_cntr = _nl_msg_cat_cntr + 1;
  return;
}



uchar * bind_textdomain_codeset__(uchar *domainname,uchar *codeset)

{
  set_binding_values(domainname,(uchar **)0x0,&codeset);
  return codeset;
}



uchar * bindtextdomain__(uchar *domainname,uchar *dirname)

{
  set_binding_values(domainname,&dirname,(uchar **)0x0);
  return dirname;
}



uchar * dcgettext__(uchar *domainname,uchar *msgid,int category)

{
  uchar *puVar1;
  
  puVar1 = dcigettext__(domainname,msgid,(uchar *)0x0,0,0,category);
  return puVar1;
}



ulong __regparm3 plural_eval(expression *pexp,ulong n)

{
  int iVar1;
  int iVar2;
  ulong uVar3;
  ulong uVar4;
  bool bVar5;
  
  iVar1 = pexp->nargs;
  iVar2 = iVar1 + -1;
  bVar5 = iVar1 == 1;
  while( true ) {
    if (bVar5) {
      uVar3 = plural_eval((expression *)pexp->val,n);
      return (uint)(uVar3 == 0);
    }
    if (bVar5 || SBORROW4(iVar1,1) != iVar2 < 0) {
      if (iVar1 == 0) {
        if (pexp->operation == var) {
          return n;
        }
        if (pexp->operation == num) {
          return pexp->val;
        }
      }
      return 0;
    }
    if (iVar1 == 2) break;
    if (iVar1 != 3) {
      return 0;
    }
    uVar3 = plural_eval((expression *)pexp->val,n);
    pexp = *(expression **)(&pexp->field_0x10 + ~-(uint)(uVar3 == 0) * 4);
    iVar1 = pexp->nargs;
    iVar2 = iVar1 + -1;
    bVar5 = iVar2 == 0;
  }
  uVar3 = plural_eval((expression *)pexp->val,n);
  if (pexp->operation == lor) {
    if (uVar3 != 0) {
      return 1;
    }
  }
  else {
    if (pexp->operation != land) {
      uVar4 = plural_eval(*(expression **)&pexp->field_0xc,n);
      switch(pexp->operation) {
      case mult:
        return uVar4 * uVar3;
      case divide:
        return uVar3 / uVar4;
      case module:
        return uVar3 % uVar4;
      case plus:
        return uVar4 + uVar3;
      case minus:
        return uVar3 - uVar4;
      case less_than:
        return (uint)(uVar3 < uVar4);
      case greater_than:
        return (uint)(uVar4 < uVar3);
      case less_or_equal:
        return (uint)(uVar3 <= uVar4);
      case greater_or_equal:
        return (uint)(uVar4 <= uVar3);
      case equal:
        return (uint)(uVar3 == uVar4);
      case not_equal:
        return (uint)(uVar3 != uVar4);
      default:
        return 0;
      }
    }
    if (uVar3 == 0) {
      return 0;
    }
  }
  uVar3 = plural_eval(*(expression **)&pexp->field_0xc,n);
  return (uint)(uVar3 != 0);
}



int transcmp(void *p1,void *p2)

{
  int iVar1;
  
  iVar1 = strcmp((char *)((int)p1 + 0x18),(char *)((int)p2 + 0x18));
  if (iVar1 == 0) {
    iVar1 = strcmp(*(char **)p1,*(char **)p2);
    if (iVar1 == 0) {
      iVar1 = *(int *)((int)p1 + 4) - *(int *)((int)p2 + 4);
    }
  }
  return iVar1;
}



uchar * _nl_find_msg(loaded_l10nfile *domain_file,binding *domainbinding,uchar *msgid,
                    size_t *lengthp)

{
  loaded_domain *domain;
  nls_uint32 *pnVar1;
  uint uVar2;
  size_t sVar3;
  uint uVar4;
  nls_uint32 nVar5;
  nls_uint32 nVar6;
  int iVar7;
  uchar **ppuVar8;
  size_t *psVar9;
  int *piVar10;
  uint uVar11;
  string_desc *psVar12;
  byte *pbVar13;
  size_t *psVar14;
  uchar *__ptr;
  int iVar15;
  uint uVar16;
  int iVar17;
  size_t sVar18;
  bool bVar19;
  uchar *local_30;
  size_t local_2c;
  uchar *local_28;
  size_t local_24;
  size_t *local_20 [4];
  size_t freemem_size;
  uchar *freemem;
  
  if (domain_file->decided == 0) {
    _nl_load_domain(domain_file,domainbinding);
  }
  domain = (loaded_domain *)domain_file->data;
  if (domain != (loaded_domain *)0x0) {
    uVar16 = domain->hash_size;
    if ((2 < uVar16) && (pnVar1 = domain->hash_tab, pnVar1 != (nls_uint32 *)0x0)) {
      sVar3 = strlen((char *)msgid);
      uVar11 = 0;
      pbVar13 = msgid;
      while (*pbVar13 != 0) {
        uVar11 = uVar11 * 0x10 + (uint)*pbVar13;
        uVar4 = uVar11 & 0xf0000000;
        if (uVar4 != 0) {
          uVar11 = uVar11 ^ uVar4 ^ uVar4 >> 0x18;
        }
        pbVar13 = pbVar13 + 1;
      }
      iVar17 = uVar11 % (uVar16 - 2) + 1;
      iVar7 = domain->must_swap;
      uVar11 = uVar11 % uVar16;
LAB_080b03db:
      if (iVar7 == 0) {
        nVar6 = pnVar1[uVar11];
      }
      else {
        uVar4 = pnVar1[uVar11];
        nVar6 = uVar4 >> 0x18 | uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | uVar4 >> 8 & 0xff00;
      }
      if (nVar6 == 0) {
        return (uchar *)0x0;
      }
      if (iVar7 == 0) {
        psVar12 = domain->orig_tab;
        nVar5 = psVar12[nVar6 - 1].length;
      }
      else {
        iVar15 = nVar6 - 1;
        psVar12 = domain->orig_tab;
        nVar5 = psVar12[iVar15].length >> 0x18 | psVar12[iVar15].length << 0x18 |
                (psVar12[iVar15].length & 0xff00) << 8 | psVar12[iVar15].length >> 8 & 0xff00;
      }
      uVar4 = nVar6 - 1;
      if (sVar3 <= nVar5) {
        local_30 = domain->data;
        if (iVar7 == 0) {
          nVar6 = psVar12[uVar4].offset;
        }
        else {
          uVar2 = psVar12[uVar4].offset;
          nVar6 = uVar2 >> 0x18 | uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | uVar2 >> 8 & 0xff00;
        }
        iVar15 = strcmp((char *)msgid,(char *)(local_30 + nVar6));
        if (iVar15 == 0) goto found;
      }
      bVar19 = uVar11 < uVar16 - iVar17;
      uVar4 = uVar11 + iVar17;
      uVar11 = uVar11 + (iVar17 - uVar16);
      if (bVar19) {
        uVar11 = uVar4;
      }
      goto LAB_080b03db;
    }
    nVar6 = domain->nstrings;
    uVar16 = 0;
    while (uVar16 < nVar6) {
      iVar7 = domain->must_swap;
      local_30 = domain->data;
      while( true ) {
        uVar4 = nVar6 + uVar16 >> 1;
        if (iVar7 == 0) {
          nVar5 = domain->orig_tab[uVar4].offset;
        }
        else {
          uVar11 = domain->orig_tab[uVar4].offset;
          nVar5 = uVar11 >> 0x18 | uVar11 << 0x18 | (uVar11 & 0xff00) << 8 | uVar11 >> 8 & 0xff00;
        }
        iVar17 = strcmp((char *)msgid,(char *)(local_30 + nVar5));
        if (-1 < iVar17) break;
        nVar6 = uVar4;
        if (uVar4 <= uVar16) {
          return (uchar *)0x0;
        }
      }
      if (iVar17 == 0) goto found;
      uVar16 = uVar4 + 1;
    }
  }
  return (uchar *)0x0;
found:
  if (iVar7 == 0) {
    nVar6 = domain->trans_tab[uVar4].length;
    nVar5 = domain->trans_tab[uVar4].offset;
  }
  else {
    uVar16 = domain->trans_tab[uVar4].offset;
    uVar11 = domain->trans_tab[uVar4].length;
    nVar5 = uVar16 >> 0x18 | uVar16 << 0x18 | (uVar16 & 0xff00) << 8 | uVar16 >> 8 & 0xff00;
    nVar6 = uVar11 >> 0x18 | uVar11 << 0x18 | (uVar11 & 0xff00) << 8 | uVar11 >> 8 & 0xff00;
  }
  psVar14 = (size_t *)(local_30 + nVar5);
  sVar18 = nVar6 + 1;
  iVar7 = 0;
  if (domainbinding != (binding *)0x0) {
    iVar7 = domainbinding->codeset_cntr;
  }
  if (domain->codeset_cntr != iVar7) {
    _nl_free_domain_conv(domain);
    _nl_init_domain_conv(domain_file,domain,domainbinding);
  }
  if (domain->conv != (iconv_t)0xffffffff) {
    ppuVar8 = domain->conv_tab;
    if (ppuVar8 == (uchar **)0x0) {
      ppuVar8 = (uchar **)calloc(domain->nstrings,4);
      domain->conv_tab = ppuVar8;
      if (ppuVar8 == (uchar **)0x0) {
        domain->conv_tab = (uchar **)0xffffffff;
        goto converted;
      }
    }
    if (ppuVar8 != (uchar **)0xffffffff) {
      psVar9 = (size_t *)ppuVar8[uVar4];
      if (psVar9 == (size_t *)0x0) {
        __ptr = (uchar *)0x0;
        iVar7 = 0;
        do {
          local_28 = freemem + 4;
          local_24 = sVar18;
          local_20[0] = psVar14;
          if (3 < freemem_size) {
            local_2c = freemem_size - 4;
            sVar3 = iconv(domain->conv,(char **)local_20,&local_24,(char **)&local_28,&local_2c);
            if (sVar3 != 0xffffffff) {
              *(uchar **)freemem = local_28 + (-4 - (int)freemem);
              domain->conv_tab[uVar4] = freemem;
              iVar7 = freemem_size - (int)local_28;
              freemem_size = (uint)(freemem + iVar7) & 0xfffffffc;
              freemem = local_28 + ((uint)(freemem + iVar7) & 3);
              psVar9 = (size_t *)domain->conv_tab[uVar4];
              goto LAB_080b04ab;
            }
            piVar10 = __errno_location();
            if (*piVar10 != 7) goto converted;
          }
          if (iVar7 == 0) {
            freemem_size = 0xff0;
            iVar7 = 1;
            __ptr = (uchar *)malloc(0xff0);
          }
          else {
            iVar7 = iVar7 + 1;
            freemem_size = iVar7 * 0xff0;
            __ptr = (uchar *)realloc(__ptr,freemem_size);
          }
          freemem = __ptr;
        } while (__ptr != (uchar *)0x0);
        freemem = (uchar *)0x0;
        freemem_size = 0;
      }
      else {
LAB_080b04ab:
        sVar18 = *psVar9;
        psVar14 = psVar9 + 1;
      }
    }
  }
converted:
  *lengthp = sVar18;
  return (uchar *)psVar14;
}



uchar * __regparm3
plural_lookup(loaded_l10nfile *domain,ulong n,uchar *translation,size_t translation_len)

{
  void *pvVar1;
  ulong uVar2;
  uchar *puVar3;
  int iVar4;
  
  pvVar1 = domain->data;
  uVar2 = plural_eval(*(expression **)((int)pvVar1 + 0x30),n);
  if (*(uint *)((int)pvVar1 + 0x34) <= uVar2) {
    uVar2 = 0;
  }
  puVar3 = translation;
  do {
    if (uVar2 == 0) {
      return puVar3;
    }
    uVar2 = uVar2 - 1;
    iVar4 = __rawmemchr(puVar3,0);
    puVar3 = (uchar *)(iVar4 + 1);
  } while (puVar3 < translation + translation_len);
  return translation;
}



uchar * dcigettext__(uchar *domainname,uchar *msgid1,uchar *msgid2,int plural,ulong n,int category)

{
  int iVar1;
  binding *pbVar2;
  __compar_fn_t p_Var3;
  int *piVar4;
  binding *pbVar5;
  uchar uVar6;
  size_t sVar7;
  int iVar8;
  char *pcVar9;
  undefined4 uVar10;
  __uid_t _Var11;
  __uid_t _Var12;
  undefined4 *puVar13;
  loaded_l10nfile *domain;
  uchar *translation;
  loaded_l10nfile *plVar14;
  void **ppvVar15;
  void *pvVar16;
  void **ppvVar17;
  __gid_t _Var18;
  __gid_t _Var19;
  int iVar20;
  uchar *puVar21;
  uchar *puVar22;
  undefined *puVar23;
  undefined *puVar24;
  uchar **ppuVar25;
  undefined *puVar26;
  uint uVar27;
  uchar *puVar28;
  int in_GS_OFFSET;
  bool bVar29;
  byte bVar30;
  uchar *puStack120;
  __compar_fn_t ap_Stack116 [3];
  uchar *local_68;
  uchar *local_64;
  uchar *local_60;
  uchar *local_5c;
  size_t local_58;
  __compar_fn_t local_54;
  int local_50;
  int *local_4c;
  uchar *local_48;
  int *local_44;
  loaded_l10nfile *local_40;
  uchar *local_3c;
  binding *local_38;
  uchar *local_34;
  binding *local_30;
  void *local_24;
  int local_20;
  
  bVar30 = 0;
  local_48 = domainname;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_34 = msgid1;
  local_5c = msgid2;
  puVar26 = &stack0xffffff84;
  translation = (uchar *)0x0;
  if (msgid1 == (uchar *)0x0) goto LAB_080b09c8;
  if (domainname == (uchar *)0x0) {
    domainname = _nl_current_default_domain__;
  }
  local_48 = domainname;
  sVar7 = strlen((char *)msgid1);
  translation = local_34;
  iVar1 = -(sVar7 + 0x37 & 0xfffffff0);
  ppuVar25 = (uchar **)(&stack0xffffff84 + iVar1);
  local_54 = (__compar_fn_t)(sVar7 + 1);
  *(__compar_fn_t *)((int)ap_Stack116 + iVar1) = (__compar_fn_t)(sVar7 + 1);
  *(uchar **)((int)&puStack120 + iVar1) = translation;
  *(uchar ***)(&stack0xffffff84 + iVar1) = (uchar **)((int)&local_48 + iVar1);
  *(undefined4 *)(&stack0xffffff80 + iVar1) = 0x80b0848;
  memcpy(*(void **)(&stack0xffffff84 + iVar1),*(uchar **)((int)&puStack120 + iVar1),
         (size_t)*(__compar_fn_t *)((int)ap_Stack116 + iVar1));
  *(uchar **)((int)&local_60 + iVar1) = local_48;
  *(int *)((int)&local_5c + iVar1) = category;
  *(__compar_fn_t *)((int)ap_Stack116 + iVar1) = transcmp;
  *(uchar **)((int)&puStack120 + iVar1) = (uchar *)0x814a98c;
  *(uchar ***)(&stack0xffffff84 + iVar1) = (uchar **)((int)&local_60 + iVar1);
  *(undefined4 *)(&stack0xffffff80 + iVar1) = 0x80b086b;
  local_44 = (int *)tfind(*(void **)(&stack0xffffff84 + iVar1),*(void ***)((int)&puStack120 + iVar1)
                          ,*(__compar_fn_t *)((int)ap_Stack116 + iVar1));
  if ((local_44 != (int *)0x0) && (iVar8 = *local_44, *(int *)(iVar8 + 8) == _nl_msg_cat_cntr)) {
    if (plural == 0) {
      puVar26 = &stack0xffffff84 + iVar1;
      translation = *(uchar **)(iVar8 + 0x10);
    }
    else {
      translation = *(uchar **)(iVar8 + 0x10);
      domain = *(loaded_l10nfile **)(iVar8 + 0xc);
      *(undefined4 *)(&stack0xffffff84 + iVar1) = *(undefined4 *)(iVar8 + 0x14);
      *(undefined4 *)(&stack0xffffff80 + iVar1) = 0x80b0d96;
      translation = plural_lookup(domain,n,translation,*(size_t *)(&stack0xffffff84 + iVar1));
      puVar26 = &stack0xffffff84 + iVar1;
    }
    goto LAB_080b09c8;
  }
  *(undefined4 *)(&stack0xffffff80 + iVar1) = 0x80b0888;
  local_4c = __errno_location((&stack0xffffff80)[iVar1]);
  local_50 = *local_4c;
  pbVar2 = _nl_domain_bindings__;
  translation = local_48;
  if (enable_secure == 0) {
    *(undefined4 *)(&stack0xffffff80 + iVar1) = 0x80b09e7;
    _Var11 = getuid((&stack0xffffff80)[iVar1]);
    *(undefined4 *)(&stack0xffffff80 + iVar1) = 0x80b09ee;
    _Var12 = geteuid((&stack0xffffff80)[iVar1]);
    if (_Var11 == _Var12) {
      *(undefined4 *)(&stack0xffffff80 + iVar1) = 0x80b0dde;
      _Var18 = getgid((&stack0xffffff80)[iVar1]);
      *(undefined4 *)(&stack0xffffff80 + iVar1) = 0x80b0de5;
      _Var19 = getegid((&stack0xffffff80)[iVar1]);
      if (_Var18 == _Var19) {
        enable_secure = -1;
        pbVar2 = _nl_domain_bindings__;
        translation = local_48;
        goto joined_r0x080b08a6;
      }
    }
    enable_secure = 1;
    pbVar2 = _nl_domain_bindings__;
    translation = local_48;
  }
joined_r0x080b08a6:
  while (puVar22 = local_48, local_48 = translation, pbVar2 != (binding *)0x0) {
    *(uchar **)((int)&puStack120 + iVar1) = pbVar2->domainname;
    *(uchar **)(&stack0xffffff84 + iVar1) = puVar22;
    *(undefined4 *)(&stack0xffffff80 + iVar1) = 0x80b08d7;
    iVar8 = strcmp(*(char **)(&stack0xffffff84 + iVar1),
                   (char *)*(uchar **)((int)&puStack120 + iVar1));
    if (iVar8 == 0) {
      local_30 = pbVar2;
      if (pbVar2 == (binding *)0x0) {
        local_3c = "/usr/share/locale";
        ppuVar25 = (uchar **)(&stack0xffffff84 + iVar1);
        goto LAB_080b098d;
      }
      local_3c = pbVar2->dirname;
      ppuVar25 = (uchar **)(&stack0xffffff84 + iVar1);
      if (*local_3c == '/') goto LAB_080b098d;
      *(uchar **)(&stack0xffffff84 + iVar1) = local_3c;
      uVar27 = 0x1002;
      *(undefined4 *)(&stack0xffffff80 + iVar1) = 0x80b0903;
      sVar7 = strlen(*(char **)(&stack0xffffff84 + iVar1));
      piVar4 = local_4c;
      local_38 = pbVar2;
      local_30 = (binding *)(sVar7 + 1);
      puVar23 = &stack0xffffff84 + iVar1;
      goto LAB_080b0929;
    }
    if (iVar8 < 0) break;
    pbVar2 = pbVar2->next;
    translation = local_48;
    local_48 = puVar22;
  }
  local_30 = (binding *)0x0;
  local_3c = "/usr/share/locale";
LAB_080b098d:
  pcVar9 = "LC_XXX";
  switch(category) {
  case 0:
    pcVar9 = "LC_CTYPE";
    break;
  case 1:
    pcVar9 = "LC_NUMERIC";
    break;
  case 2:
    pcVar9 = "LC_TIME";
    break;
  case 3:
    pcVar9 = "LC_COLLATE";
    break;
  case 4:
    pcVar9 = "LC_MONETARY";
    break;
  case 5:
    pcVar9 = "LC_MESSAGES";
    break;
  case 6:
    pcVar9 = "LC_ALL";
  }
  if ((LANGUAGE == (uchar *)0x0) || (puVar22 = LANGUAGE, *LANGUAGE == '\0')) {
    *ppuVar25 = 0x813260b;
    ppuVar25[-1] = 0x80b0a2b;
    puVar22 = (uchar *)getenv((char *)*ppuVar25);
    if ((puVar22 == (uchar *)0x0) || (*puVar22 == '\0')) {
      ppuVar25[1] = (uchar *)0x0;
      *(int *)ppuVar25 = category;
      ppuVar25[-1] = 0x80b0d7b;
      puVar22 = (uchar *)setlocale((int)*ppuVar25,(char *)ppuVar25[1]);
    }
  }
  *ppuVar25 = local_48;
  ppuVar25[-1] = 0x80b0a49;
  local_58 = strlen((char *)*ppuVar25);
  *(char **)ppuVar25 = pcVar9;
  ppuVar25[-1] = 0x80b0a54;
  sVar7 = strlen((char *)*ppuVar25);
  iVar1 = -(local_58 + sVar7 + 0x23 & 0xfffffff0);
  local_38 = (binding *)((int)ppuVar25 + iVar1 + 0x1f & 0xfffffff0);
  *(binding **)((int)ppuVar25 + iVar1) = local_38;
  *(char **)((int)ppuVar25 + iVar1 + 4) = pcVar9;
  *(undefined4 *)((int)ppuVar25 + iVar1 + -4) = 0x80b0a76;
  pcVar9 = stpcpy(*(char **)((int)ppuVar25 + iVar1),*(char **)((int)ppuVar25 + iVar1 + 4));
  *(undefined **)((int)ppuVar25 + iVar1 + 4) = &DAT_08132419;
  *(char **)((int)ppuVar25 + iVar1) = pcVar9;
  *(undefined4 *)((int)ppuVar25 + iVar1 + -4) = 0x80b0a86;
  pcVar9 = stpcpy(*(char **)((int)ppuVar25 + iVar1),*(char **)((int)ppuVar25 + iVar1 + 4));
  translation = local_48;
  *(size_t *)((int)ppuVar25 + iVar1 + 8) = local_58;
  *(uchar **)((int)ppuVar25 + iVar1 + 4) = translation;
  *(char **)((int)ppuVar25 + iVar1) = pcVar9;
  *(undefined4 *)((int)ppuVar25 + iVar1 + -4) = 0x80b0a9c;
  puVar13 = (undefined4 *)
            mempcpy(*(uchar **)((int)ppuVar25 + iVar1),*(void **)((int)ppuVar25 + iVar1 + 4),
                    *(size_t *)((int)ppuVar25 + iVar1 + 8));
  *puVar13 = 0x6f6d2e;
  *(uchar **)((int)ppuVar25 + iVar1) = puVar22;
  *(undefined4 *)((int)ppuVar25 + iVar1 + -4) = 0x80b0aaa;
  sVar7 = strlen(*(char **)((int)ppuVar25 + iVar1));
  iVar8 = -(sVar7 + 0x1f & 0xfffffff0);
  puVar24 = (undefined *)((int)ppuVar25 + iVar8 + iVar1);
  puVar26 = (undefined *)((int)ppuVar25 + iVar8 + iVar1);
  translation = (uchar *)((int)ppuVar25 + iVar8 + iVar1 + 0x1f & 0xfffffff0);
LAB_080b0ac0:
  do {
    uVar6 = *puVar22;
    while (uVar6 != ':') {
      puVar21 = translation;
      if (uVar6 == '\0') {
        *translation = 'C';
        translation[1] = '\0';
LAB_080b0adc:
        pbVar5 = local_30;
        pbVar2 = local_38;
        bVar29 = *translation == 'C';
        if ((bVar29) && (bVar29 = translation[1] == '\0', bVar29)) goto LAB_080b09a8;
        iVar20 = 6;
        puVar21 = translation;
        puVar28 = (uchar *)"POSIX";
        goto code_r0x080b0b03;
      }
      do {
        puVar22 = puVar22 + 1;
        *puVar21 = uVar6;
        uVar6 = *puVar22;
        puVar21 = puVar21 + 1;
        if (uVar6 == ':') break;
      } while (uVar6 != '\0');
      *puVar21 = '\0';
      if (enable_secure != 1) goto LAB_080b0adc;
      *(uchar **)((int)ppuVar25 + iVar8 + iVar1) = translation;
      *(undefined4 *)((int)ppuVar25 + iVar8 + iVar1 + 4) = 0x2f;
      local_68 = translation;
      *(undefined4 *)((int)ppuVar25 + iVar8 + iVar1 + -4) = 0x80b0bee;
      pcVar9 = strchr(*(char **)((int)ppuVar25 + iVar8 + iVar1),
                      *(int *)((int)ppuVar25 + iVar8 + iVar1 + 4));
      translation = local_68;
      if (pcVar9 == (char *)0x0) goto LAB_080b0adc;
      uVar6 = *puVar22;
    }
    puVar22 = puVar22 + 1;
  } while( true );
LAB_080b0929:
  *piVar4 = 0;
  iVar1 = -((int)&local_30[1].codeset_cntr + uVar27 + 2 & 0xfffffff0);
  puVar24 = puVar23 + iVar1;
  puVar26 = puVar23 + iVar1;
  translation = (uchar *)((uint)(puVar23 + iVar1 + 0x1f) & 0xfffffff0);
  *(uint *)(puVar23 + iVar1 + 4) = uVar27;
  *(uchar **)(puVar23 + iVar1) = translation;
  *(undefined4 *)(puVar23 + iVar1 + -4) = 0x80b094e;
  pcVar9 = getcwd(*(char **)(puVar23 + iVar1),*(size_t *)(puVar23 + iVar1 + 4));
  pbVar2 = local_38;
  if (pcVar9 != (char *)0x0) goto code_r0x080b0952;
  if (*piVar4 != 0x22) {
    *local_4c = local_50;
    goto joined_r0x080b0d4b;
  }
  uVar27 = uVar27 + 0x20 + (uVar27 >> 1);
  puVar23 = puVar23 + iVar1;
  goto LAB_080b0929;
code_r0x080b0952:
  local_3c = translation;
  puVar22 = local_38->dirname;
  *(undefined4 *)(puVar23 + iVar1 + 4) = 0;
  *(uchar **)(puVar23 + iVar1) = translation;
  *(undefined4 *)(puVar23 + iVar1 + -4) = 0x80b096e;
  uVar10 = __rawmemchr();
  *(undefined4 *)(puVar23 + iVar1 + 4) = 0x8132419;
  *(undefined4 *)(puVar23 + iVar1) = uVar10;
  *(undefined4 *)(puVar23 + iVar1 + -4) = 0x80b097e;
  pcVar9 = stpcpy(*(char **)(puVar23 + iVar1),*(char **)(puVar23 + iVar1 + 4));
  *(uchar **)(puVar23 + iVar1 + 4) = puVar22;
  *(char **)(puVar23 + iVar1) = pcVar9;
  *(undefined4 *)(puVar23 + iVar1 + -4) = 0x80b098a;
  strcpy(*(char **)(puVar23 + iVar1),*(char **)(puVar23 + iVar1 + 4));
  local_30 = pbVar2;
  ppuVar25 = (uchar **)(puVar23 + iVar1);
  goto LAB_080b098d;
  while( true ) {
    iVar20 = iVar20 + -1;
    bVar29 = *puVar21 == *puVar28;
    puVar21 = puVar21 + (uint)bVar30 * -2 + 1;
    puVar28 = puVar28 + (uint)bVar30 * -2 + 1;
    if (!bVar29) break;
code_r0x080b0b03:
    if (iVar20 == 0) break;
  }
  if (bVar29) goto LAB_080b09a8;
  *(uchar **)((int)ppuVar25 + iVar8 + iVar1 + 4) = translation;
  local_68 = translation;
  *(binding **)((int)ppuVar25 + iVar8 + iVar1 + 0xc) = pbVar5;
  translation = local_3c;
  *(binding **)((int)ppuVar25 + iVar8 + iVar1 + 8) = pbVar2;
  *(uchar **)((int)ppuVar25 + iVar8 + iVar1) = translation;
  *(undefined4 *)((int)ppuVar25 + iVar8 + iVar1 + -4) = 0x80b0b2b;
  domain = _nl_find_domain(*(uchar **)((int)ppuVar25 + iVar8 + iVar1),
                           *(uchar **)((int)ppuVar25 + iVar8 + iVar1 + 4),
                           *(uchar **)((int)ppuVar25 + iVar8 + iVar1 + 8),
                           *(binding **)((int)ppuVar25 + iVar8 + iVar1 + 0xc));
  puVar21 = local_34;
  translation = local_68;
  if (domain != (loaded_l10nfile *)0x0) {
    *(void ***)((int)ppuVar25 + iVar8 + iVar1 + 0xc) = &local_24;
    pbVar2 = local_30;
    *(loaded_l10nfile **)((int)ppuVar25 + iVar8 + iVar1) = domain;
    *(uchar **)((int)ppuVar25 + iVar8 + iVar1 + 8) = puVar21;
    *(binding **)((int)ppuVar25 + iVar8 + iVar1 + 4) = pbVar2;
    *(undefined4 *)((int)ppuVar25 + iVar8 + iVar1 + -4) = 0x80b0b51;
    translation = _nl_find_msg(*(loaded_l10nfile **)((int)ppuVar25 + iVar8 + iVar1),
                               *(binding **)((int)ppuVar25 + iVar8 + iVar1 + 4),
                               *(uchar **)((int)ppuVar25 + iVar8 + iVar1 + 8),
                               *(size_t **)((int)ppuVar25 + iVar8 + iVar1 + 0xc));
    pbVar2 = local_30;
    puVar21 = local_34;
    if (translation != (uchar *)0x0) {
      *local_4c = local_50;
joined_r0x080b0c75:
      if (local_44 == (int *)0x0) {
        *(__compar_fn_t *)((int)ppuVar25 + iVar8 + iVar1) = local_54 + local_58 + 0x19;
        *(undefined4 *)((int)ppuVar25 + iVar8 + iVar1 + -4) = 0x80b0c8d;
        ppvVar15 = (void **)malloc(*(size_t *)((int)ppuVar25 + iVar8 + iVar1));
        p_Var3 = local_54;
        if (ppvVar15 != (void **)0x0) {
          *(uchar **)((int)ppuVar25 + iVar8 + iVar1 + 4) = local_34;
          *(__compar_fn_t *)((int)ppuVar25 + iVar8 + iVar1 + 8) = p_Var3;
          *(void ***)((int)ppuVar25 + iVar8 + iVar1) = ppvVar15 + 6;
          *(undefined4 *)((int)ppuVar25 + iVar8 + iVar1 + -4) = 0x80b0cb0;
          pvVar16 = mempcpy(*(void **)((int)ppuVar25 + iVar8 + iVar1),
                            *(void **)((int)ppuVar25 + iVar8 + iVar1 + 4),
                            *(size_t *)((int)ppuVar25 + iVar8 + iVar1 + 8));
          sVar7 = local_58;
          *ppvVar15 = pvVar16;
          *(void **)((int)ppuVar25 + iVar8 + iVar1) = pvVar16;
          *(int *)((int)ppuVar25 + iVar8 + iVar1 + 8) = sVar7 + 1;
          *(uchar **)((int)ppuVar25 + iVar8 + iVar1 + 4) = local_48;
          *(undefined4 *)((int)ppuVar25 + iVar8 + iVar1 + -4) = 0x80b0ccb;
          memcpy(*(void **)((int)ppuVar25 + iVar8 + iVar1),
                 *(void **)((int)ppuVar25 + iVar8 + iVar1 + 4),
                 *(size_t *)((int)ppuVar25 + iVar8 + iVar1 + 8));
          *(int *)(ppvVar15 + 1) = category;
          iVar20 = _nl_msg_cat_cntr;
          *(loaded_l10nfile **)(ppvVar15 + 3) = domain;
          *(uchar **)(ppvVar15 + 4) = translation;
          *(int *)(ppvVar15 + 2) = iVar20;
          ppvVar15[5] = local_24;
          *(code **)((int)ppuVar25 + iVar8 + iVar1 + 8) = transcmp;
          *(void ***)((int)ppuVar25 + iVar8 + iVar1 + 4) = &root;
          *(void ***)((int)ppuVar25 + iVar8 + iVar1) = ppvVar15;
          *(undefined4 *)((int)ppuVar25 + iVar8 + iVar1 + -4) = 0x80b0cfd;
          ppvVar17 = (void **)tsearch(*(void **)((int)ppuVar25 + iVar8 + iVar1),
                                      *(void ***)((int)ppuVar25 + iVar8 + iVar1 + 4),
                                      *(__compar_fn_t *)((int)ppuVar25 + iVar8 + iVar1 + 8));
          if ((ppvVar17 == (void **)0x0) || ((void **)*ppvVar17 != ppvVar15)) {
            *(void ***)((int)ppuVar25 + iVar8 + iVar1) = ppvVar15;
            *(undefined4 *)((int)ppuVar25 + iVar8 + iVar1 + -4) = 0x80b0d15;
            free(*(void **)((int)ppuVar25 + iVar8 + iVar1));
          }
        }
      }
      else {
        *(int *)(*local_44 + 8) = _nl_msg_cat_cntr;
        *(loaded_l10nfile **)(*local_44 + 0xc) = domain;
        *(uchar **)(*local_44 + 0x10) = translation;
        *(void **)(*local_44 + 0x14) = local_24;
      }
      puVar26 = (undefined *)((int)ppuVar25 + iVar8 + iVar1);
      if (plural != 0) {
        *(void **)((int)ppuVar25 + iVar8 + iVar1) = local_24;
        *(undefined4 *)((int)ppuVar25 + iVar8 + iVar1 + -4) = 0x80b0bb1;
        translation = plural_lookup(domain,n,translation,*(size_t *)((int)ppuVar25 + iVar8 + iVar1))
        ;
        puVar26 = (undefined *)((int)ppuVar25 + iVar8 + iVar1);
      }
      goto LAB_080b09c8;
    }
    plVar14 = domain->successor[0];
    translation = local_68;
    if (plVar14 != (loaded_l10nfile *)0x0) {
      local_60 = puVar22;
      iVar20 = 0;
      local_40 = domain;
      local_64 = local_68;
      do {
        *(void ***)((int)ppuVar25 + iVar8 + iVar1 + 0xc) = &local_24;
        *(uchar **)((int)ppuVar25 + iVar8 + iVar1 + 8) = puVar21;
        *(binding **)((int)ppuVar25 + iVar8 + iVar1 + 4) = pbVar2;
        *(loaded_l10nfile **)((int)ppuVar25 + iVar8 + iVar1) = plVar14;
        *(undefined4 *)((int)ppuVar25 + iVar8 + iVar1 + -4) = 0x80b0c59;
        translation = _nl_find_msg(*(loaded_l10nfile **)((int)ppuVar25 + iVar8 + iVar1),
                                   *(binding **)((int)ppuVar25 + iVar8 + iVar1 + 4),
                                   *(uchar **)((int)ppuVar25 + iVar8 + iVar1 + 8),
                                   *(size_t **)((int)ppuVar25 + iVar8 + iVar1 + 0xc));
        if (translation != (uchar *)0x0) {
          domain = local_40->successor[iVar20];
          *local_4c = local_50;
          goto joined_r0x080b0c75;
        }
        iVar20 = iVar20 + 1;
        plVar14 = local_40->successor[iVar20];
        translation = local_64;
        puVar22 = local_60;
      } while (plVar14 != (loaded_l10nfile *)0x0);
    }
  }
  goto LAB_080b0ac0;
LAB_080b09a8:
  *local_4c = local_50;
joined_r0x080b0d4b:
  translation = local_34;
  if ((plural != 0) && (puVar26 = puVar24, n != 1)) {
    translation = local_5c;
  }
LAB_080b09c8:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    *(undefined4 *)(puVar26 + -4) = 0x80b0e01;
    __stack_chk_fail();
  }
  return translation;
}



uchar * dcngettext__(uchar *domainname,uchar *msgid1,uchar *msgid2,ulong n,int category)

{
  uchar *puVar1;
  
  puVar1 = dcigettext__(domainname,msgid1,msgid2,1,n,category);
  return puVar1;
}



uchar * dgettext__(uchar *domainname,uchar *msgid)

{
  uchar *puVar1;
  
  puVar1 = dcgettext__(domainname,msgid,5);
  return puVar1;
}



uchar * dngettext__(uchar *domainname,uchar *msgid1,uchar *msgid2,ulong n)

{
  uchar *puVar1;
  
  puVar1 = dcngettext__(domainname,msgid1,msgid2,n,5);
  return puVar1;
}



uchar * _nl_find_language(uchar *name)

{
  uchar uVar1;
  
  uVar1 = *name;
  if ((uVar1 != '\0') && (uVar1 != '_')) {
    while ((uVar1 != '@' && ((uVar1 != '+' && (uVar1 != ','))))) {
      name = name + 1;
      uVar1 = *name;
      if (uVar1 == '_') {
        return name;
      }
      if (uVar1 == '\0') {
        return name;
      }
    }
  }
  return name;
}



int _nl_explode_name(uchar *name,uchar **language,uchar **modifier,uchar **territory,uchar **codeset
                    ,uchar **normalized_codeset,uchar **special,uchar **sponsor,uchar **revision)

{
  bool bVar1;
  uint uVar2;
  int iVar3;
  uchar uVar4;
  uchar *puVar5;
  uchar *codeset_00;
  uchar local_2d;
  int local_20;
  
  *modifier = (uchar *)0x0;
  *territory = (uchar *)0x0;
  *codeset = (uchar *)0x0;
  *normalized_codeset = (uchar *)0x0;
  *special = (uchar *)0x0;
  *sponsor = (uchar *)0x0;
  *revision = (uchar *)0x0;
  *language = name;
  uVar4 = *name;
  if ((((uVar4 == '_') || (uVar4 == '\0')) || (uVar4 == '@')) ||
     ((uVar4 == '+' || (puVar5 = name, uVar4 == ',')))) {
LAB_080b12a8:
    bVar1 = false;
    puVar5 = (uchar *)__rawmemchr(name,0);
    local_2d = *puVar5;
    uVar2 = 0;
  }
  else {
    do {
      codeset_00 = puVar5;
      puVar5 = codeset_00 + 1;
      local_2d = *puVar5;
      if (((local_2d == '_') || ((local_2d == '\0' || (local_2d == '@')))) || (local_2d == '+'))
      break;
    } while (local_2d != ',');
    if (name == puVar5) goto LAB_080b12a8;
    uVar2 = 0;
    bVar1 = false;
    if (local_2d == '_') {
      *puVar5 = '\0';
      puVar5 = codeset_00 + 2;
      *territory = puVar5;
      local_2d = *puVar5;
      while (local_2d != '.') {
        if ((((local_2d == '\0') || (local_2d == '@')) || (local_2d == '+')) ||
           ((local_2d == ',' || (local_2d == '_')))) {
          uVar2 = 0x20;
          bVar1 = false;
          goto LAB_080b0fc0;
        }
        puVar5 = puVar5 + 1;
        local_2d = *puVar5;
      }
      *puVar5 = '\0';
      codeset_00 = puVar5 + 1;
      *codeset = codeset_00;
      local_2d = *codeset_00;
      if ((local_2d != '\0') && (puVar5 = codeset_00, local_2d != '@')) {
        do {
          puVar5 = puVar5 + 1;
          if (*puVar5 == '@') break;
        } while (*puVar5 != '\0');
        if (puVar5 == codeset_00) {
          uVar2 = 0x30;
          goto LAB_080b1028;
        }
        codeset_00 = _nl_normalize_codeset(codeset_00,(size_t)(puVar5 + -(int)codeset_00));
        *normalized_codeset = codeset_00;
        iVar3 = strcmp((char *)*codeset,(char *)codeset_00);
        if (iVar3 != 0) {
          local_2d = *puVar5;
          bVar1 = true;
          uVar2 = 0x38;
          goto LAB_080b0fc0;
        }
        free(codeset_00);
        local_2d = *puVar5;
        codeset_00 = puVar5;
      }
      uVar2 = 0x30;
      bVar1 = true;
      puVar5 = codeset_00;
    }
  }
LAB_080b0fc0:
  if (local_2d == '@') {
    *puVar5 = '\0';
    uVar2 = uVar2 | 0xc0;
    *modifier = puVar5 + 1;
  }
  else {
    if (!bVar1) {
      local_20 = 0;
      codeset_00 = puVar5;
      uVar4 = local_2d;
      if (local_2d == '+') {
        *puVar5 = '\0';
        codeset_00 = puVar5 + 1;
        *modifier = codeset_00;
        uVar4 = *codeset_00;
        if ((((uVar4 == '\0') || (uVar4 == '+')) || (uVar4 == ',')) || (uVar4 == '_')) {
          uVar2 = uVar2 | 0xc0;
          local_20 = 2;
        }
        else {
          codeset_00 = puVar5 + 2;
          while (uVar4 = *codeset_00, uVar4 != '\0') {
            if (uVar4 == '+') goto LAB_080b11d9;
            if (uVar4 == ',') {
              local_2d = ',';
              goto LAB_080b11d9;
            }
            if (uVar4 == '_') {
              local_2d = '_';
              goto LAB_080b11d9;
            }
            codeset_00 = codeset_00 + 1;
          }
          local_2d = '\0';
LAB_080b11d9:
          uVar2 = uVar2 | 0xc0;
          local_20 = 2;
          uVar4 = local_2d;
        }
      }
      if (((byte)(uVar4 - 0x2b) < 2) || (uVar4 == '_')) {
        if (uVar4 == '+') {
          *codeset_00 = '\0';
          codeset_00 = codeset_00 + 1;
          *special = codeset_00;
          uVar4 = *codeset_00;
          if ((uVar4 != '\0') && (uVar4 != ',')) {
            while (uVar4 != '_') {
              codeset_00 = codeset_00 + 1;
              uVar4 = *codeset_00;
              if ((uVar4 == ',') || (uVar4 == '\0')) break;
            }
          }
          uVar2 = uVar2 | 4;
        }
        if (uVar4 == ',') {
          *codeset_00 = '\0';
          codeset_00 = codeset_00 + 1;
          *sponsor = codeset_00;
          uVar4 = *codeset_00;
          if ((uVar4 != '\0') && (uVar4 != '_')) {
            do {
              codeset_00 = codeset_00 + 1;
              uVar4 = *codeset_00;
              if (uVar4 == '_') break;
            } while (uVar4 != '\0');
          }
          uVar2 = uVar2 | 2;
        }
        if (uVar4 != '_') {
          return uVar2;
        }
        *codeset_00 = '\0';
        *revision = codeset_00 + 1;
        return uVar2 | 1;
      }
      if (local_20 != 1) {
        return uVar2;
      }
    }
  }
LAB_080b1028:
  if ((*territory != (uchar *)0x0) && (**territory == '\0')) {
    uVar2 = uVar2 & 0xffffffdf;
  }
  if ((*codeset != (uchar *)0x0) && (**codeset == '\0')) {
    uVar2 = uVar2 & 0xffffffef;
  }
  if (*modifier == (uchar *)0x0) {
    return uVar2;
  }
  if (**modifier == '\0') {
    uVar2 = uVar2 & 0xffffff7f;
  }
  return uVar2;
}



loaded_l10nfile *
_nl_find_domain(uchar *dirname,uchar *locale,uchar *domainname,binding *domainbinding)

{
  void *pvVar1;
  size_t sVar2;
  loaded_l10nfile *domain_file;
  loaded_l10nfile *domain_file_00;
  uchar *puVar3;
  uint mask;
  int iVar4;
  loaded_l10nfile *plVar5;
  uchar *local_3c;
  uchar *local_38;
  uchar *local_34;
  uchar *local_30;
  uchar *local_2c;
  uchar *local_28;
  uchar *local_24;
  uchar *local_20 [4];
  
  sVar2 = strlen((char *)dirname);
  domain_file = _nl_make_l10nflist(&_nl_loaded_domains,dirname,sVar2 + 1,0,locale,(uchar *)0x0,
                                   (uchar *)0x0,(uchar *)0x0,(uchar *)0x0,(uchar *)0x0,(uchar *)0x0,
                                   (uchar *)0x0,domainname,0);
  if (domain_file == (loaded_l10nfile *)0x0) {
    puVar3 = _nl_expand_alias(locale);
    if ((puVar3 == (uchar *)0x0) || (locale = (uchar *)__strdup(puVar3), locale != (uchar *)0x0)) {
      mask = _nl_explode_name(locale,local_20,&local_24,&local_28,&local_2c,&local_30,&local_34,
                              &local_38,&local_3c);
      sVar2 = strlen((char *)dirname);
      domain_file = _nl_make_l10nflist(&_nl_loaded_domains,dirname,sVar2 + 1,mask,local_20[0],
                                       local_28,local_2c,local_30,local_24,local_34,local_38,
                                       local_3c,domainname,1);
      if (domain_file != (loaded_l10nfile *)0x0) {
        if (domain_file->decided == 0) {
          _nl_load_domain(domain_file,domainbinding);
        }
        if (domain_file->data == (void *)0x0) {
          domain_file_00 = domain_file->successor[0];
          plVar5 = domain_file;
          while (domain_file_00 != (loaded_l10nfile *)0x0) {
            if (domain_file_00->decided == 0) {
              _nl_load_domain(domain_file_00,domainbinding);
            }
            if (plVar5->successor[0]->data != (void *)0x0) break;
            domain_file_00 = (loaded_l10nfile *)plVar5[1].filename;
            plVar5 = (loaded_l10nfile *)&plVar5->langdirname;
          }
        }
        if (puVar3 != (uchar *)0x0) {
          free(locale);
        }
        if ((mask & 8) != 0) {
          free(local_30);
        }
      }
    }
  }
  else {
    if (domain_file->decided == 0) {
      _nl_load_domain(domain_file,domainbinding);
      pvVar1 = domain_file->data;
    }
    else {
      pvVar1 = domain_file->data;
    }
    if ((pvVar1 == (void *)0x0) &&
       (domain_file_00 = domain_file->successor[0], domain_file_00 != (loaded_l10nfile *)0x0)) {
      iVar4 = 0;
      do {
        if (domain_file_00->decided == 0) {
          _nl_load_domain(domain_file_00,domainbinding);
        }
        if (domain_file->successor[iVar4]->data != (void *)0x0) break;
        iVar4 = iVar4 + 1;
        domain_file_00 = domain_file->successor[iVar4];
      } while (domain_file_00 != (loaded_l10nfile *)0x0);
      if (iVar4 < 0) {
        domain_file = (loaded_l10nfile *)0x0;
      }
      return domain_file;
    }
  }
  return domain_file;
}



uchar * gettext__(uchar *msgid)

{
  uchar *puVar1;
  
  puVar1 = dcgettext__((uchar *)0x0,msgid,5);
  return puVar1;
}



uchar * bind_textdomain_codeset(uchar *domainname,uchar *codeset)

{
  uchar *puVar1;
  
  puVar1 = bind_textdomain_codeset__(domainname,codeset);
  return puVar1;
}



uchar * bindtextdomain(uchar *domainname,uchar *dirname)

{
  uchar *puVar1;
  
  puVar1 = bindtextdomain__(domainname,dirname);
  return puVar1;
}



uchar * textdomain(uchar *domainname)

{
  uchar *puVar1;
  
  puVar1 = textdomain__(domainname);
  return puVar1;
}



uchar * dcngettext(uchar *domainname,uchar *msgid1,uchar *msgid2,ulong n,int category)

{
  uchar *puVar1;
  
  puVar1 = dcngettext__(domainname,msgid1,msgid2,n,category);
  return puVar1;
}



uchar * dngettext(uchar *domainname,uchar *msgid1,uchar *msgid2,ulong n)

{
  uchar *puVar1;
  
  puVar1 = dngettext__(domainname,msgid1,msgid2,n);
  return puVar1;
}



uchar * ngettext(uchar *msgid1,uchar *msgid2,ulong n)

{
  uchar *puVar1;
  
  puVar1 = ngettext__(msgid1,msgid2,n);
  return puVar1;
}



uchar * dcgettext(uchar *domainname,uchar *msgid,int category)

{
  uchar *puVar1;
  
  puVar1 = dcgettext__(domainname,msgid,category);
  return puVar1;
}



uchar * dgettext(uchar *domainname,uchar *msgid)

{
  uchar *puVar1;
  
  puVar1 = dgettext__(domainname,msgid);
  return puVar1;
}



uchar * gettext(uchar *msgid)

{
  uchar *puVar1;
  
  puVar1 = gettext__(msgid);
  return puVar1;
}



uchar * _nl_normalize_codeset(uchar *codeset,size_t name_len)

{
  byte bVar1;
  bool bVar2;
  ushort **ppuVar3;
  uint uVar4;
  undefined4 *puVar5;
  size_t __size;
  int iVar6;
  undefined4 *puVar7;
  
  __size = 4;
  if (name_len != 0) {
    ppuVar3 = __ctype_b_loc();
    bVar2 = true;
    iVar6 = 0;
    uVar4 = 0;
    do {
      if ((((*ppuVar3)[codeset[uVar4]] & 8) != 0) &&
         (iVar6 = iVar6 + 1, ((*ppuVar3)[codeset[uVar4]] & 0x400) != 0)) {
        bVar2 = false;
      }
      uVar4 = uVar4 + 1;
    } while (uVar4 < name_len);
    if (!bVar2) {
      __size = iVar6 + 1;
      goto LAB_080b16be;
    }
    __size = iVar6 + 4;
  }
  bVar2 = true;
LAB_080b16be:
  puVar5 = (undefined4 *)malloc(__size);
  if (puVar5 != (undefined4 *)0x0) {
    puVar7 = puVar5;
    if (bVar2) {
      *puVar5 = 0x6f7369;
      puVar7 = (undefined4 *)((int)puVar5 + 3);
    }
    if (name_len != 0) {
      uVar4 = 0;
      ppuVar3 = __ctype_b_loc();
      do {
        while( true ) {
          bVar1 = codeset[uVar4];
          if ((*(byte *)((int)*ppuVar3 + (uint)bVar1 * 2 + 1) & 4) == 0) break;
          uVar4 = uVar4 + 1;
          iVar6 = c_tolower((uint)bVar1);
          *(char *)puVar7 = (char)iVar6;
          puVar7 = (undefined4 *)((int)puVar7 + 1);
          if (name_len <= uVar4) goto LAB_080b1737;
        }
        if ((byte)(bVar1 - 0x30) < 10) {
          *(byte *)puVar7 = bVar1;
          puVar7 = (undefined4 *)((int)puVar7 + 1);
        }
        uVar4 = uVar4 + 1;
      } while (uVar4 < name_len);
    }
LAB_080b1737:
    *(undefined *)puVar7 = 0;
  }
  return (uchar *)puVar5;
}



// WARNING: Removing unreachable block (ram,0x080b1cac)

loaded_l10nfile *
_nl_make_l10nflist(loaded_l10nfile **l10nfile_list,uchar *dirlist,size_t dirlist_len,int mask,
                  uchar *language,uchar *territory,uchar *codeset,uchar *normalized_codeset,
                  uchar *modifier,uchar *special,uchar *sponsor,uchar *revision,uchar *filename,
                  int do_allocate)

{
  size_t sVar1;
  size_t sVar2;
  uchar *__dest;
  loaded_l10nfile *plVar3;
  uint mask_00;
  int iVar4;
  loaded_l10nfile *plVar5;
  int iVar6;
  uchar *dirlist_00;
  int iVar7;
  loaded_l10nfile *plVar8;
  loaded_l10nfile **pplVar9;
  int local_2c;
  int local_28;
  int local_24;
  char *local_20;
  
  sVar1 = strlen((char *)language);
  if ((mask & 0x20U) == 0) {
    local_2c = 0;
  }
  else {
    sVar2 = strlen((char *)territory);
    local_2c = sVar2 + 1;
  }
  if ((mask & 0x10U) == 0) {
    local_28 = 0;
  }
  else {
    sVar2 = strlen((char *)codeset);
    local_28 = sVar2 + 1;
  }
  if ((mask & 8U) == 0) {
    local_24 = 0;
  }
  else {
    sVar2 = strlen((char *)normalized_codeset);
    local_24 = sVar2 + 1;
  }
  iVar7 = 0;
  if ((mask & 0xc0U) != 0) {
    sVar2 = strlen((char *)modifier);
    iVar7 = sVar2 + 1;
  }
  if ((mask & 4U) == 0) {
    local_20 = (char *)0x0;
  }
  else {
    sVar2 = strlen((char *)special);
    local_20 = (char *)(sVar2 + 1);
  }
  iVar6 = 0;
  if ((mask & 3U) != 0) {
    iVar4 = 1;
    if ((mask & 2U) != 0) {
      sVar2 = strlen((char *)sponsor);
      iVar4 = sVar2 + 2;
    }
    iVar6 = 0;
    if ((mask & 1U) != 0) {
      sVar2 = strlen((char *)revision);
      iVar6 = sVar2 + 1;
    }
    iVar6 = iVar6 + iVar4;
  }
  sVar2 = strlen((char *)filename);
  dirlist_00 = (uchar *)malloc(dirlist_len + 2 + sVar1 + local_2c + local_28 + local_24 + iVar7 +
                               (int)local_20 + iVar6 + sVar2);
  plVar5 = (loaded_l10nfile *)0x0;
  if (dirlist_00 != (uchar *)0x0) {
    memcpy(dirlist_00,dirlist,dirlist_len);
    __argz_stringify(dirlist_00,dirlist_len,0x3a);
    dirlist_00[dirlist_len - 1] = '/';
    __dest = dirlist_00 + (dirlist_len - 1) + 1;
    local_20 = stpcpy((char *)__dest,(char *)language);
    if ((mask & 0x20U) != 0) {
      *local_20 = '_';
      local_20 = stpcpy(local_20 + 1,(char *)territory);
    }
    if ((mask & 0x10U) != 0) {
      *local_20 = '.';
      local_20 = stpcpy(local_20 + 1,(char *)codeset);
    }
    if ((mask & 8U) != 0) {
      *local_20 = '.';
      local_20 = stpcpy(local_20 + 1,(char *)normalized_codeset);
    }
    if ((mask & 0xc0U) != 0) {
      *local_20 = (-((mask & 0x40U) == 0) & 0x15U) + 0x2b;
      local_20 = stpcpy(local_20 + 1,(char *)modifier);
    }
    if ((mask & 4U) != 0) {
      *local_20 = '+';
      local_20 = stpcpy(local_20 + 1,(char *)special);
    }
    if ((mask & 3U) != 0) {
      *local_20 = ',';
      local_20 = local_20 + 1;
      if ((mask & 2U) != 0) {
        local_20 = stpcpy(local_20,(char *)sponsor);
      }
      if ((mask & 1U) != 0) {
        *local_20 = '_';
        local_20 = stpcpy(local_20 + 1,(char *)revision);
      }
    }
    *local_20 = '/';
    strcpy(local_20 + 1,(char *)filename);
    plVar5 = *l10nfile_list;
    plVar3 = plVar5;
    if (plVar5 != (loaded_l10nfile *)0x0) {
      plVar8 = (loaded_l10nfile *)0x0;
      do {
        plVar3 = plVar8;
        if (plVar5->filename != (uchar *)0x0) {
          iVar7 = strcmp((char *)plVar5->filename,(char *)dirlist_00);
          if (iVar7 == 0) {
            free(dirlist_00);
            return plVar5;
          }
          plVar3 = plVar5;
          if (iVar7 < 0) {
            plVar5 = (loaded_l10nfile *)0x0;
            plVar3 = plVar8;
            break;
          }
        }
        plVar5 = plVar5->next;
        plVar8 = plVar3;
      } while (plVar5 != (loaded_l10nfile *)0x0);
    }
    if (do_allocate == 0) {
      free(dirlist_00);
    }
    else {
      iVar7 = __argz_count(dirlist,dirlist_len);
      mask_00 = ((int)(mask & 0xffffaaaaU) >> 1) + (mask & 0x5555U);
      iVar6 = ((int)(mask_00 & 0xffffcccc) >> 2) + (mask_00 & 0x3333);
      mask_00 = (iVar6 >> 4) + iVar6 & 0xf0f;
      plVar5 = (loaded_l10nfile *)malloc((iVar7 << (char)(mask_00 >> 8) + (char)mask_00) * 4 + 0x1c)
      ;
      if (plVar5 != (loaded_l10nfile *)0x0) {
        plVar5->filename = dirlist_00;
        plVar5->langdirname = __dest;
        *(char **)&plVar5->langdirnamelen = local_20 + -(int)__dest;
        iVar7 = __argz_count(dirlist,dirlist_len);
        mask_00 = 1;
        if (iVar7 == 1) {
          mask_00 = (uint)((mask & 0x18U) == 0x18);
        }
        plVar5->decided = mask_00;
        plVar5->data = (void *)0x0;
        if (plVar3 == (loaded_l10nfile *)0x0) {
          plVar5->next = *l10nfile_list;
          *l10nfile_list = plVar5;
        }
        else {
          plVar5->next = plVar3->next;
          plVar3->next = plVar5;
        }
        iVar7 = __argz_count(dirlist,dirlist_len);
        mask_00 = mask - 1;
        if (iVar7 != 1) {
          mask_00 = mask;
        }
        iVar7 = 0;
        if (-1 < (int)mask_00) {
          do {
            if (((~mask & mask_00) == 0) &&
               ((((mask_00 & 0x47) == 0 || ((mask_00 & 0x98) == 0)) &&
                (pplVar9 = plVar5->successor + iVar7, (mask_00 & 0x18) != 0x18)))) {
              while (dirlist_00 = dirlist, dirlist_len != 0) {
                while( true ) {
                  if (dirlist_00 == (uchar *)0x0) goto LAB_080b1c6d;
                  iVar7 = iVar7 + 1;
                  sVar1 = strlen((char *)dirlist_00);
                  plVar3 = _nl_make_l10nflist(l10nfile_list,dirlist_00,sVar1 + 1,mask_00,language,
                                              territory,codeset,normalized_codeset,modifier,special,
                                              sponsor,revision,filename,1);
                  *pplVar9 = plVar3;
                  pplVar9 = pplVar9 + 1;
                  if (dirlist_00 == (uchar *)0x0) break;
                  if (dirlist + dirlist_len <= dirlist_00) goto LAB_080b1c6d;
                  iVar6 = __rawmemchr(dirlist_00,0);
                  dirlist_00 = (uchar *)(iVar6 + 1U);
                  if (dirlist + dirlist_len <= (uchar *)(iVar6 + 1U)) goto LAB_080b1c6d;
                }
              }
            }
LAB_080b1c6d:
            mask_00 = mask_00 - 1;
          } while (-1 < (int)mask_00);
        }
        plVar5->successor[iVar7] = (loaded_l10nfile *)0x0;
      }
    }
  }
  return plVar5;
}



uchar * language_to_name(int language)

{
  return languages[language].name;
}



int name_to_language(uchar *name)

{
  uchar *s1;
  int iVar1;
  int iVar2;
  
  if (languages[0].name != (uchar *)0x0) {
    iVar2 = 0;
    s1 = languages[0].name;
    do {
      iVar1 = c_strcasecmp((char *)s1,(char *)name);
      if (iVar1 == 0) {
        return iVar2;
      }
      iVar2 = iVar2 + 1;
      s1 = languages[iVar2].name;
    } while (s1 != (uchar *)0x0);
  }
  return 1;
}



int iso639_to_language(uchar *iso639)

{
  uchar *__s1;
  uchar *p;
  char *pcVar1;
  int iVar2;
  size_t sVar3;
  size_t __n;
  int iVar4;
  
  p = stracpy(iso639);
  if (p == (uchar *)0x0) {
    return 1;
  }
  pcVar1 = strchr((char *)p,0x2e);
  if (pcVar1 != (char *)0x0) {
    *pcVar1 = '\0';
  }
  pcVar1 = strchr((char *)p,0x5f);
  if (pcVar1 == (char *)0x0) {
    pcVar1 = strchr((char *)p,0x2d);
  }
  else {
    *pcVar1 = '-';
  }
  __s1 = languages[0].name;
  if (languages[0].name != (uchar *)0x0) {
    iVar4 = 0;
    do {
      iVar2 = strcmp((char *)languages[iVar4].iso639,(char *)p);
      if (iVar2 == 0) goto LAB_080b1f78;
      iVar4 = iVar4 + 1;
    } while (languages[iVar4].name != (uchar *)0x0);
  }
  if (pcVar1 == (char *)0x0) {
    sVar3 = strlen((char *)p);
    if (__s1 == (uchar *)0x0) goto LAB_080b1f57;
  }
  else {
    *pcVar1 = '\0';
    if (languages[0].name == (uchar *)0x0) goto LAB_080b1f57;
    iVar4 = 0;
    do {
      iVar2 = strcmp((char *)languages[iVar4].iso639,(char *)p);
      if (iVar2 == 0) goto LAB_080b1f78;
      iVar4 = iVar4 + 1;
    } while (languages[iVar4].name != (uchar *)0x0);
    sVar3 = strlen((char *)p);
  }
  iVar4 = 0;
  do {
    __s1 = languages[iVar4].iso639;
    if ((*__s1 == '\0') || (*__s1 == '-')) {
      __n = 0;
    }
    else {
      __n = 0;
      do {
        __n = __n + 1;
        if (__s1[__n] == '\0') break;
      } while (__s1[__n] != '-');
    }
    if ((int)sVar3 < (int)__n) {
      __n = sVar3;
    }
    iVar2 = strncmp((char *)__s1,(char *)p,__n);
    if (iVar2 == 0) {
LAB_080b1f78:
      mem_free(p);
      return iVar4;
    }
    iVar4 = iVar4 + 1;
  } while (languages[iVar4].name != (uchar *)0x0);
LAB_080b1f57:
  mem_free(p);
  return 1;
}



int get_system_language_index(void)

{
  uchar *iso639;
  int iVar1;
  
  iso639 = (uchar *)getenv("LANGUAGE");
  if (iso639 == (uchar *)0x0) {
    iso639 = (uchar *)getenv("LC_ALL");
    if (iso639 == (uchar *)0x0) {
      iso639 = (uchar *)getenv("LC_MESSAGES");
      if (iso639 == (uchar *)0x0) {
        iso639 = (uchar *)getenv("LANG");
        if (iso639 == (uchar *)0x0) {
          return 1;
        }
      }
    }
  }
  iVar1 = iso639_to_language(iso639);
  return iVar1;
}



uchar * language_to_iso639(int language)

{
  int iVar1;
  
  if ((language == 0) && (language = system_language, system_language == 0)) {
    iVar1 = get_system_language_index();
    return languages[iVar1].iso639;
  }
  return languages[language].iso639;
}



void set_language(int language)

{
  uchar *__src;
  char *pcVar1;
  
  if (system_language == 0) {
    system_language = get_system_language_index();
  }
  if (language != current_language) {
    current_language = language;
    if (language == 0) {
      language = system_language;
    }
    if (LANGUAGE == (uchar *)0x0) {
      LANGUAGE = (uchar *)malloc(0x100);
    }
    __src = language_to_iso639(language);
    strcpy((char *)LANGUAGE,(char *)__src);
    pcVar1 = strchr((char *)LANGUAGE,0x2d);
    if (pcVar1 != (char *)0x0) {
      *pcVar1 = '_';
    }
    _nl_msg_cat_cntr = _nl_msg_cat_cntr + 1;
  }
  return;
}



string * __regparm3 add_bytes_to_string__(string *string,uchar *bytes,int length)

{
  int iVar1;
  uint uVar2;
  uchar *puVar3;
  uint size;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  if (((bytes == (uchar *)0x0) || (string == (string *)0x0)) || (length < 0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 0xff;
    elinks_internal((uchar *)
                    "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  if (length == 0) {
    return string;
  }
  iVar1 = length + string->length;
  uVar2 = string->length + 0xffU & 0xffffff00;
  size = iVar1 + 0x100U & 0xffffff00;
  if (uVar2 < size) {
    puVar3 = (uchar *)mem_realloc(string->source,size);
    if (puVar3 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar3;
    memset(puVar3 + uVar2,0,size - uVar2);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  memcpy(string->source + string->length,bytes,length);
  string->source[iVar1] = '\0';
  string->length = iVar1;
  return string;
}



void _nl_free_domain_conv(loaded_domain *domain)

{
  iconv_t __cd;
  
  if ((int)domain->conv_tab - 1U < 0xfffffffe) {
    free(domain->conv_tab);
    __cd = domain->conv;
  }
  else {
    __cd = domain->conv;
  }
  if (__cd != (iconv_t)0xffffffff) {
    iconv_close(__cd);
    return;
  }
  return;
}



uchar * _nl_init_domain_conv
                  (loaded_l10nfile *domain_file,loaded_domain *domain,binding *domainbinding)

{
  char cVar1;
  int iVar2;
  uchar *__haystack;
  char *pcVar3;
  char *__fromcode;
  undefined *puVar4;
  iconv_t pvVar5;
  uchar *__tocode;
  size_t size;
  size_t __n;
  size_t nullentrylen;
  
  iVar2 = 0;
  if (domainbinding != (binding *)0x0) {
    iVar2 = domainbinding->codeset_cntr;
  }
  domain->codeset_cntr = iVar2;
  domain->conv = (iconv_t)0xffffffff;
  domain->conv_tab = (uchar **)0x0;
  __haystack = _nl_find_msg(domain_file,domainbinding,"",&nullentrylen);
  if (__haystack != (uchar *)0x0) {
    pcVar3 = strstr((char *)__haystack,"charset=");
    if (pcVar3 != (char *)0x0) {
      cVar1 = pcVar3[8];
      if ((((cVar1 == '\0') || (cVar1 == ' ')) || (cVar1 == '\t')) || (cVar1 == '\n')) {
        size = 1;
        __n = 0;
      }
      else {
        __n = 0;
        while( true ) {
          __n = __n;
          __n = __n + 1;
          cVar1 = pcVar3[__n + 9];
          if ((cVar1 == '\0') || (cVar1 == ' ')) break;
          if ((cVar1 == '\t') || (cVar1 == '\n')) break;
        }
        size = __n + 2;
      }
      __fromcode = (char *)mem_alloc(size);
      puVar4 = (undefined *)mempcpy(__fromcode,pcVar3 + 8,__n);
      *puVar4 = 0;
      if ((domainbinding == (binding *)0x0) ||
         (__tocode = domainbinding->codeset, __tocode == (uchar *)0x0)) {
        __tocode = (uchar *)getenv("OUTPUT_CHARSET");
        if ((__tocode == (uchar *)0x0) || (*__tocode == '\0')) {
          __tocode = elinks_locale_charset();
        }
      }
      pvVar5 = iconv_open((char *)__tocode,__fromcode);
      domain->conv = pvVar5;
      mem_free(__fromcode);
    }
  }
  return __haystack;
}



void _nl_load_domain(loaded_l10nfile *domain_file,binding *domainbinding)

{
  string *psVar1;
  char *length;
  int __fildes;
  int iVar2;
  loaded_domain *domain;
  uint uVar3;
  uchar *bytes;
  char *pcVar4;
  ushort **ppuVar5;
  ssize_t sVar6;
  int *piVar7;
  ulong uVar8;
  int *__ptr;
  uchar *puVar9;
  uchar *puVar10;
  byte *pbVar11;
  bool bVar12;
  byte bVar13;
  int *local_98;
  uint local_94;
  uint local_90;
  stat st;
  string filename;
  
  bVar13 = 0;
  domain_file->decided = 1;
  domain_file->data = (void *)0x0;
  psVar1 = init_string(&filename);
  bytes = program.path;
  if ((psVar1 == (string *)0x0) ||
     (length = strrchr((char *)program.path,0x2f), length == (char *)0x0)) {
LAB_080b245c:
    done_string(&filename);
  }
  else {
    length = length + (1 - (int)bytes);
    bVar12 = length == (char *)0x3;
    if (length < &DAT_00000004) goto LAB_080b245c;
    __fildes = 3;
    puVar9 = bytes + -4 + (int)length;
    puVar10 = "src";
    do {
      if (__fildes == 0) break;
      __fildes = __fildes + -1;
      bVar12 = *puVar9 == *puVar10;
      puVar9 = puVar9 + (uint)bVar13 * -2 + 1;
      puVar10 = puVar10 + (uint)bVar13 * -2 + 1;
    } while (bVar12);
    if ((((!bVar12) ||
         (psVar1 = add_bytes_to_string__(&filename,bytes,(int)length), psVar1 == (string *)0x0)) ||
        (psVar1 = add_to_string(&filename,"../po/"), psVar1 == (string *)0x0)) ||
       ((psVar1 = add_bytes_to_string__
                            (&filename,domain_file->langdirname,domain_file->langdirnamelen),
        psVar1 == (string *)0x0 ||
        (psVar1 = add_to_string(&filename,".gmo"), psVar1 == (string *)0x0)))) goto LAB_080b245c;
    __fildes = open64((char *)filename.source,0);
    done_string(&filename);
    if (__fildes != -1) goto source_success;
  }
  if (domain_file->filename == (uchar *)0x0) {
    return;
  }
  __fildes = open64((char *)domain_file->filename,0);
  if (__fildes == -1) {
    return;
  }
source_success:
  iVar2 = __fxstat64(3,__fildes,(stat64 *)&st);
  if (((iVar2 == 0) && (st.st_size._4_4_ == 0)) && (0x1b < (uint)st.st_size)) {
    __ptr = (int *)mmap64((void *)0x0,(uint)st.st_size,1,2,__fildes,0);
    if (__ptr != (int *)0xffffffff) {
      close(__fildes);
      __fildes = 1;
LAB_080b251b:
      if ((*__ptr != -0x21edfb6b) && (*__ptr != -0x6afbed22)) {
        if (__fildes != 0) {
          munmap(__ptr,(uint)st.st_size);
          return;
        }
        free(__ptr);
        return;
      }
      domain = (loaded_domain *)malloc(0x38);
      if (domain == (loaded_domain *)0x0) {
        return;
      }
      *(loaded_domain **)&domain_file->data = domain;
      *(int **)&domain->data = __ptr;
      domain->use_mmap = __fildes;
      domain->mmap_size = (uint)st.st_size;
      bVar12 = *__ptr != -0x6afbed22;
      domain->must_swap = (uint)bVar12;
      if (bVar12) {
        local_90 = (uint)__ptr[1] >> 0x18 | __ptr[1] << 0x18 | (__ptr[1] & 0xff00U) << 8 |
                   (uint)__ptr[1] >> 8 & 0xff00;
      }
      else {
        local_90 = __ptr[1];
      }
      if (local_90 == 0) {
        if (bVar12) {
          uVar3 = __ptr[2];
          domain->nstrings =
               uVar3 >> 0x18 | uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | uVar3 >> 8 & 0xff00;
          uVar3 = __ptr[3];
          domain->orig_tab =
               (string_desc *)
               ((int)__ptr +
               (uVar3 >> 0x18 | uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | uVar3 >> 8 & 0xff00));
          uVar3 = __ptr[4];
          domain->trans_tab =
               (string_desc *)
               ((int)__ptr +
               (uVar3 >> 0x18 | uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | uVar3 >> 8 & 0xff00));
          uVar3 = __ptr[5];
          domain->hash_size =
               uVar3 >> 0x18 | uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | uVar3 >> 8 & 0xff00;
          uVar3 = __ptr[6];
          uVar3 = uVar3 >> 0x18 | uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | uVar3 >> 8 & 0xff00;
        }
        else {
          domain->nstrings = __ptr[2];
          domain->orig_tab = (string_desc *)(__ptr[3] + (int)__ptr);
          domain->trans_tab = (string_desc *)(__ptr[4] + (int)__ptr);
          domain->hash_size = __ptr[5];
          uVar3 = __ptr[6];
        }
        domain->hash_tab = (nls_uint32 *)((int)__ptr + uVar3);
        bytes = _nl_init_domain_conv(domain_file,domain,domainbinding);
        if (bytes != (uchar *)0x0) {
          length = strstr((char *)bytes,"plural=");
          pcVar4 = strstr((char *)bytes,"nplurals=");
          if ((pcVar4 != (char *)0x0) && (length != (char *)0x0)) {
            pbVar11 = (byte *)(pcVar4 + 9);
            ppuVar5 = __ctype_b_loc();
            while (bVar13 = *pbVar11, (*(byte *)((int)*ppuVar5 + (uint)bVar13 * 2 + 1) & 0x20) != 0)
            {
              pbVar11 = pbVar11 + 1;
            }
            if ((byte)(bVar13 - 0x30) < 10) {
              uVar8 = 0;
              local_98 = (int *)pbVar11;
              do {
                local_98 = (int *)((byte *)local_98 + 1);
                uVar8 = ((uint)bVar13 - 0x30) + uVar8 * 10;
                bVar13 = *(byte *)local_98;
              } while ((byte)(bVar13 - 0x30) < 10);
              domain->nplurals = uVar8;
              if ((int *)pbVar11 != local_98) {
                filename.source = (uchar *)(length + 7);
                __fildes = gettext__parse(&filename);
                if (__fildes == 0) {
                  *(int *)&domain->plural = filename.length;
                  return;
                }
              }
            }
            else {
              domain->nplurals = 0;
            }
          }
        }
        if (plone.val == 0) {
          plvar.nargs = 0;
          plvar.operation = var;
          plone.nargs = 0;
          plone.operation = num;
          plone.val = 1;
          germanic_plural.nargs = 2;
          germanic_plural.operation = not_equal;
          germanic_plural.val = &plvar;
          germanic_plural._12_4_ = &plone;
        }
        domain->plural = &germanic_plural;
        domain->nplurals = 2;
        return;
      }
      if (__fildes == 0) {
        free(__ptr);
      }
      else {
        munmap(__ptr,(uint)st.st_size);
      }
      free(domain);
      domain_file->data = (void *)0x0;
      return;
    }
    __ptr = (int *)malloc((uint)st.st_size);
    if (__ptr == (int *)0x0) {
      return;
    }
    local_94 = (uint)st.st_size;
    local_98 = __ptr;
    do {
      while (sVar6 = read(__fildes,local_98,local_94), sVar6 != -1) {
        if (sVar6 < 1) goto LAB_080b24a9;
        local_94 = local_94 - sVar6;
        if (local_94 == 0) {
          close(__fildes);
          __fildes = 0;
          goto LAB_080b251b;
        }
        local_98 = (int *)((int)local_98 + sVar6);
      }
      piVar7 = __errno_location();
    } while (*piVar7 == 4);
  }
LAB_080b24a9:
  close(__fildes);
  return;
}



uchar * elinks_locale_charset(void)

{
  int iVar1;
  uchar uVar2;
  size_t sVar3;
  int __c;
  size_t sVar4;
  undefined4 *__ptr;
  FILE *__stream;
  uchar *__ptr_00;
  uchar *__s1;
  int in_GS_OFFSET;
  int local_90;
  uchar buf2 [51];
  uchar buf1 [51];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __s1 = (uchar *)nl_langinfo(0xe);
  __ptr_00 = charset_aliases;
  if (__s1 == (uchar *)0x0) {
    __s1 = "";
  }
  if (charset_aliases == (uchar *)0x0) {
    __ptr = (undefined4 *)malloc(0x17);
    if (__ptr == (undefined4 *)0x0) {
      charset_aliases = "";
    }
    else {
      *__ptr = 0x7273752f;
      __ptr[1] = 0x62696c2f;
      *(undefined *)(__ptr + 2) = 0x2f;
      *(undefined4 *)((int)__ptr + 9) = 0x72616863;
      *(undefined4 *)((int)__ptr + 0xd) = 0x2e746573;
      *(undefined4 *)((int)__ptr + 0x11) = 0x61696c61;
      *(undefined2 *)((int)__ptr + 0x15) = 0x73;
      __stream = fopen64((char *)__ptr,"rb");
      if (__stream != (FILE *)0x0) {
        local_90 = 0;
LAB_080b2b60:
        while (__c = _IO_getc((_IO_FILE *)__stream), __c != -1) {
          while (((__c != 0x20 && (__c != 10)) && (__c != 9))) {
            if (__c == 0x23) goto LAB_080b2cb8;
            ungetc(__c,__stream);
            __c = __isoc99_fscanf(__stream,"%50s %50s",buf1,buf2);
            if (__c < 2) goto LAB_080b2c78;
            sVar4 = strlen((char *)buf1);
            sVar3 = strlen((char *)buf2);
            if (local_90 == 0) {
              local_90 = sVar4 + sVar3 + 2;
              __ptr_00 = (uchar *)malloc(sVar4 + sVar3 + 3);
            }
            else {
              local_90 = local_90 + 2 + sVar4 + sVar3;
              __ptr_00 = (uchar *)realloc(__ptr_00,local_90 + 1);
            }
            if (__ptr_00 == (uchar *)0x0) {
              fclose(__stream);
              goto LAB_080b2d1b;
            }
            strcpy((char *)(__ptr_00 + ((local_90 - sVar3) - sVar4) + -2),(char *)buf1);
            strcpy((char *)(__ptr_00 + (local_90 - sVar3) + -1),(char *)buf2);
            __c = _IO_getc((_IO_FILE *)__stream);
            if (__c == -1) goto LAB_080b2c78;
          }
        }
LAB_080b2c78:
        fclose(__stream);
        if (local_90 != 0) {
          __ptr_00[local_90] = '\0';
          goto LAB_080b2c98;
        }
      }
LAB_080b2d1b:
      __ptr_00 = "";
LAB_080b2c98:
      free(__ptr);
      charset_aliases = __ptr_00;
    }
  }
  uVar2 = *charset_aliases;
  __ptr_00 = charset_aliases;
  do {
    if (uVar2 == '\0') {
LAB_080b2aa1:
      if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return __s1;
    }
    __c = strcmp((char *)__s1,(char *)__ptr_00);
    if ((__c == 0) || ((uVar2 == '*' && (__ptr_00[1] == '\0')))) {
      sVar4 = strlen((char *)__ptr_00);
      __s1 = __ptr_00 + sVar4 + 1;
      goto LAB_080b2aa1;
    }
    sVar4 = strlen((char *)__ptr_00);
    sVar3 = strlen((char *)(__ptr_00 + sVar4 + 1));
    __ptr_00 = __ptr_00 + sVar4 + 1 + sVar3 + 1;
    uVar2 = *__ptr_00;
  } while( true );
LAB_080b2cb8:
  __c = _IO_getc((_IO_FILE *)__stream);
  if (__c == 10) goto LAB_080b2b60;
  if (__c == -1) goto LAB_080b2c78;
  goto LAB_080b2cb8;
}



size_t __regparm3 read_alias_file(uchar *fname,int fname_len)

{
  int iVar1;
  byte bVar2;
  byte bVar3;
  undefined4 *puVar4;
  FILE *__stream;
  char *__filename;
  ushort **ppuVar5;
  size_t __size;
  size_t __n;
  size_t __size_00;
  uchar *puVar6;
  byte *pbVar7;
  ushort *puVar8;
  uint uVar9;
  alias_map *paVar10;
  size_t sVar11;
  byte *__src;
  byte *__src_00;
  int in_GS_OFFSET;
  size_t local_4034;
  size_t local_4030;
  uchar altbuf [8192];
  uchar buf [8192];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __filename = (char *)mem_alloc(fname_len + 0xe);
  puVar4 = (undefined4 *)mempcpy(__filename,fname,fname_len);
  *puVar4 = 0x636f6c2f;
  puVar4[1] = 0x2e656c61;
  puVar4[2] = 0x61696c61;
  *(undefined2 *)(puVar4 + 3) = 0x73;
  __stream = fopen64(__filename,"rb");
  mem_free(__filename);
  local_4034 = 0;
  if (__stream != (FILE *)0x0) {
    while (((*(byte *)&__stream->_flags & 0x10) == 0 &&
           (__filename = fgets_unlocked((char *)buf,0x2000,__stream), __filename != (char *)0x0))) {
      __filename = strchr((char *)buf,10);
      while ((__filename == (char *)0x0 &&
             (__filename = fgets_unlocked((char *)altbuf,0x2000,__stream), __filename != (char *)0x0
             ))) {
        __filename = strchr((char *)altbuf,10);
      }
      ppuVar5 = __ctype_b_loc();
      __src = buf;
      puVar8 = *ppuVar5;
      while (bVar3 = *__src, (*(byte *)((int)puVar8 + (uint)bVar3 * 2 + 1) & 0x20) != 0) {
        __src = __src + 1;
      }
      if ((bVar3 != 0x23) && (bVar3 != 0)) {
        bVar3 = __src[1];
        __src_00 = __src + 1;
        while (bVar3 != 0) {
          if ((*(byte *)((int)puVar8 + (uint)bVar3 * 2 + 1) & 0x20) != 0) {
            *__src_00 = 0;
            __src_00 = __src_00 + 1;
            puVar8 = *ppuVar5;
            bVar3 = *__src_00;
            goto LAB_080b2e66;
          }
          __src_00 = __src_00 + 1;
          bVar3 = *__src_00;
        }
        bVar3 = 0;
LAB_080b2e66:
        while ((*(byte *)((int)puVar8 + (uint)bVar3 * 2 + 1) & 0x20) != 0) {
          __src_00 = __src_00 + 1;
          bVar3 = *__src_00;
        }
        if (bVar3 != 0) {
          pbVar7 = __src_00 + 1;
          bVar3 = __src_00[1];
          if (bVar3 != 0) {
            bVar2 = *(byte *)((int)puVar8 + (uint)bVar3 * 2 + 1);
            while ((bVar2 & 0x20) == 0) {
              pbVar7 = pbVar7 + 1;
              bVar3 = *pbVar7;
              if (bVar3 == 0) goto LAB_080b2ec6;
              bVar2 = *(byte *)((int)puVar8 + (uint)bVar3 * 2 + 1);
            }
            if (bVar3 == 10) {
              *pbVar7 = 0;
              pbVar7[1] = 10;
            }
            else {
              *pbVar7 = 0;
            }
          }
LAB_080b2ec6:
          paVar10 = map;
          sVar11 = maxmap;
          if (maxmap <= nmap) {
            if (maxmap == 0) {
              __size = 800;
              sVar11 = 100;
            }
            else {
              sVar11 = maxmap * 2;
              __size = maxmap << 4;
            }
            paVar10 = (alias_map *)realloc(map,__size);
            if (paVar10 == (alias_map *)0x0) goto LAB_080b3095;
          }
          maxmap = sVar11;
          map = paVar10;
          __size = strlen((char *)__src);
          __size = __size + 1;
          __n = strlen((char *)__src_00);
          __n = __n + 1;
          uVar9 = __n + __size;
          if (string_space_max < uVar9 + string_space_act) {
            __size_00 = 0x400;
            if (0x3ff < uVar9) {
              __size_00 = uVar9;
            }
            __size_00 = __size_00 + string_space_max;
            puVar6 = (uchar *)realloc(string_space,__size_00);
            local_4030 = nmap;
            paVar10 = map;
            if (puVar6 == (uchar *)0x0) goto LAB_080b3095;
            if ((string_space != puVar6) && (nmap != 0)) {
              uVar9 = 0;
              do {
                paVar10[uVar9].alias = puVar6 + -(int)string_space + (int)paVar10[uVar9].alias;
                paVar10[uVar9].value = paVar10[uVar9].value + (int)(puVar6 + -(int)string_space);
                uVar9 = uVar9 + 1;
              } while (uVar9 < local_4030);
            }
            string_space = puVar6;
            string_space_max = __size_00;
          }
          else {
            local_4030 = nmap;
            paVar10 = map;
          }
          puVar6 = (uchar *)memcpy(string_space + string_space_act,__src,__size);
          paVar10[local_4030].alias = puVar6;
          sVar11 = nmap;
          paVar10 = map;
          string_space_act = __size + string_space_act;
          puVar6 = (uchar *)memcpy(string_space + string_space_act,__src_00,__n);
          paVar10[sVar11].value = puVar6;
          string_space_act = string_space_act + __n;
          nmap = nmap + 1;
          local_4034 = local_4034 + 1;
        }
      }
    }
    fclose(__stream);
    if (local_4034 != 0) {
      qsort(map,nmap,8,alias_compare);
    }
  }
LAB_080b3095:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_4034;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



uchar * _nl_expand_alias(uchar *name)

{
  uchar uVar1;
  uchar *locale_alias_path;
  size_t sVar2;
  uchar *fname;
  void *pvVar3;
  alias_map item;
  
LAB_080b31df:
  item.alias = name;
  if ((nmap == 0) || (pvVar3 = bsearch(&item,map,nmap,8,alias_compare), pvVar3 == (void *)0x0)) {
    uVar1 = *locale_alias_path;
    fname = locale_alias_path;
    if (uVar1 != '\0') {
joined_r0x080b3205:
      while (locale_alias_path = fname, uVar1 == ':') {
        uVar1 = fname[1];
        fname = fname + 1;
      }
      do {
        if (uVar1 == '\0') break;
        locale_alias_path = locale_alias_path + 1;
        uVar1 = *locale_alias_path;
      } while (uVar1 != ':');
      if (fname < locale_alias_path) {
        sVar2 = read_alias_file(fname,(int)(locale_alias_path + -(int)fname));
        if (sVar2 != 0) goto LAB_080b31df;
        uVar1 = *locale_alias_path;
        fname = locale_alias_path;
      }
      else {
        uVar1 = *locale_alias_path;
        fname = locale_alias_path;
      }
      if (uVar1 == '\0') goto LAB_080b3266;
      goto joined_r0x080b3205;
    }
LAB_080b3266:
    fname = (uchar *)0x0;
  }
  else {
    fname = *(uchar **)((int)pvVar3 + 4);
  }
  return fname;
}



int alias_compare(alias_map *map1,alias_map *map2)

{
  int iVar1;
  
  iVar1 = c_strcasecmp((char *)map1->alias,(char *)map2->alias);
  return iVar1;
}



uchar * ngettext__(uchar *msgid1,uchar *msgid2,ulong n)

{
  uchar *puVar1;
  
  puVar1 = dcngettext__((uchar *)0x0,msgid1,msgid2,n,5);
  return puVar1;
}



void gettext_free_exp__(expression *exp)

{
  int iVar1;
  
  if (exp == (expression *)0x0) {
    return;
  }
  iVar1 = exp->nargs;
  if (iVar1 != 2) {
    if (iVar1 != 3) {
      if (iVar1 != 1) {
        free(exp);
        return;
      }
      goto LAB_080b3356;
    }
    gettext_free_exp__(*(expression **)&exp->field_0x10);
  }
  gettext_free_exp__(*(expression **)&exp->field_0xc);
LAB_080b3356:
  gettext_free_exp__((expression *)exp->val);
  free(exp);
  return;
}



expression * __regparm3 new_exp(int nargs,operator op,expression **args)

{
  expression *peVar1;
  int iVar2;
  expression **ppeVar3;
  int iVar4;
  expression *exp;
  int local_24;
  
  iVar4 = nargs + -1;
  if (-1 < iVar4) {
    exp = args[iVar4];
    if (exp != (expression *)0x0) {
      ppeVar3 = args + nargs + -2;
      iVar2 = iVar4;
      do {
        iVar2 = iVar2 + -1;
        if (iVar2 < 0) goto LAB_080b33be;
        peVar1 = *ppeVar3;
        ppeVar3 = ppeVar3 + -1;
      } while (peVar1 != (expression *)0x0);
    }
LAB_080b3418:
    local_24 = nargs + -2;
    args = args + local_24;
    while( true ) {
      gettext_free_exp__(exp);
      iVar4 = iVar4 + -1;
      if (iVar4 < 0) break;
      exp = *args;
      args = args + -1;
    }
    return (expression *)0x0;
  }
LAB_080b33be:
  exp = (expression *)malloc(0x14);
  if (exp == (expression *)0x0) {
    if (-1 < iVar4) {
      exp = args[iVar4];
      goto LAB_080b3418;
    }
  }
  else {
    exp->nargs = nargs;
    exp->operation = op;
    if (-1 < iVar4) {
      iVar2 = 0;
      ppeVar3 = (expression **)(&exp->val + iVar4);
      args = args + iVar4;
      do {
        peVar1 = *args;
        iVar2 = iVar2 + 1;
        args = args + -1;
        *ppeVar3 = peVar1;
        ppeVar3 = ppeVar3 + -1;
      } while (iVar2 != nargs);
    }
  }
  return exp;
}



// WARNING: Could not reconcile some variable overlaps

int gettext__parse(void *arg)

{
  byte bVar1;
  int iVar2;
  uint uVar3;
  short *psVar4;
  expression *op;
  uint uVar5;
  byte *pbVar6;
  short *psVar7;
  undefined *puVar8;
  undefined *puVar9;
  int iVar10;
  expression *peVar11;
  byte *pbVar12;
  short *psVar13;
  int in_GS_OFFSET;
  undefined auStack1324 [31];
  byte local_50d;
  expression *local_504;
  undefined *local_500;
  byte **local_4fc;
  int local_4f8;
  int local_4f4;
  uint local_4f0;
  uint local_4ec;
  uint local_4e8;
  expression *local_4e4;
  uint local_4e0;
  YYSTYPE yyvsa [200];
  short yyssa [200];
  expression *args [2];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  psVar4 = yyssa;
  peVar11 = (expression *)yyvsa;
  local_4f8 = 0;
  local_4fc = (byte **)arg;
  local_4e0 = 0;
  local_4f0 = 0xfffffffe;
  local_4e8 = 200;
  local_4f4 = 199;
  op = peVar11;
  psVar7 = psVar4;
  puVar8 = auStack1324;
yysetstate:
  *psVar7 = (short)local_4e0;
  local_4e4 = op;
  puVar9 = puVar8;
  if (psVar4 + local_4f4 <= psVar7) {
    if (local_4e8 < 10000) {
      iVar10 = (int)((int)psVar7 - (int)psVar4) >> 1;
      uVar5 = 10000;
      if (local_4e8 * 2 < 0x2711) {
        uVar5 = local_4e8 * 2;
      }
      local_4e8 = uVar5;
      iVar2 = -(uVar5 * 6 + 0x21 & 0xfffffff0);
      puVar9 = puVar8 + iVar2;
      psVar13 = (short *)((uint)(puVar8 + iVar2 + 0x1b) & 0xfffffff0);
      local_4ec = iVar10 + 1U;
      *(uint *)(puVar8 + iVar2 + 8) = (iVar10 + 1U) * 2;
      local_504 = op;
      *(short **)(puVar8 + iVar2 + 4) = psVar4;
      *(short **)(puVar8 + iVar2) = psVar13;
      *(undefined4 *)(puVar8 + iVar2 + -4) = 0x80b3549;
      memcpy(*(void **)(puVar8 + iVar2),*(void **)(puVar8 + iVar2 + 4),
             *(size_t *)(puVar8 + iVar2 + 8));
      uVar3 = local_4ec;
      peVar11 = local_504;
      local_4e4 = (expression *)(psVar13 + uVar5);
      *(expression **)(puVar8 + iVar2) = (expression *)(psVar13 + uVar5);
      psVar7 = psVar13 + iVar10;
      *(uint *)(puVar8 + iVar2 + 8) = uVar3 << 2;
      *(expression **)(puVar8 + iVar2 + 4) = peVar11;
      *(undefined4 *)(puVar8 + iVar2 + -4) = 0x80b3571;
      memcpy(*(void **)(puVar8 + iVar2),*(void **)(puVar8 + iVar2 + 4),
             *(size_t *)(puVar8 + iVar2 + 8));
      local_4f4 = local_4e8 - 1;
      if (psVar7 < psVar13 + (local_4e8 - 1)) {
        peVar11 = (expression *)(&local_4e4->nargs + iVar10);
        puVar9 = puVar8 + iVar2;
        psVar4 = psVar13;
        goto yybackup;
      }
LAB_080b3760:
      iVar10 = 1;
      puVar8 = puVar9;
    }
    else {
      iVar10 = 2;
    }
    goto LAB_080b3765;
  }
yybackup:
  iVar10 = (int)yypact[local_4e0];
  puVar8 = puVar9;
  if (iVar10 != -10) {
    if (local_4f0 == 0xfffffffe) {
      pbVar6 = *local_4fc;
      local_50d = *pbVar6;
      if (local_50d != 0) {
        if ((local_50d == 9) || (local_50d == 0x20)) {
          do {
            pbVar6 = pbVar6 + 1;
            bVar1 = *pbVar6;
            if (bVar1 == 0) goto LAB_080b37d8;
          } while ((bVar1 == 9) || (bVar1 == 0x20));
          local_50d = bVar1;
        }
        local_4f0 = (uint)local_50d;
        pbVar12 = pbVar6 + 1;
        switch(local_50d) {
        case 0:
        case 10:
        case 0x3b:
          local_4f0 = 0;
          pbVar12 = pbVar6;
          break;
        default:
switchD_080b398b_caseD_1:
          local_4f0 = 0x100;
          break;
        case 0x21:
          if (*pbVar12 == 0x3d) {
            pbVar12 = pbVar6 + 2;
            local_500 = &DAT_0000000d;
            local_4f0 = 0x102;
          }
          break;
        case 0x25:
          local_500 = &DAT_00000005;
          local_4f0 = 0x105;
          break;
        case 0x26:
        case 0x7c:
          if (local_4f0 != (uint)*pbVar12) goto switchD_080b398b_caseD_1;
          pbVar12 = pbVar6 + 2;
          break;
        case 0x28:
        case 0x29:
        case 0x3a:
        case 0x3f:
        case 0x6e:
          break;
        case 0x2a:
          local_500 = (undefined *)0x3;
          local_4f0 = 0x105;
          break;
        case 0x2b:
          local_500 = &DAT_00000006;
          local_4f0 = 0x104;
          break;
        case 0x2d:
          local_500 = (undefined *)0x7;
          local_4f0 = 0x104;
          break;
        case 0x2f:
          local_500 = &DAT_00000004;
          local_4f0 = 0x105;
          break;
        case 0x30:
        case 0x31:
        case 0x32:
        case 0x33:
        case 0x34:
        case 0x35:
        case 0x36:
        case 0x37:
        case 0x38:
        case 0x39:
          bVar1 = *pbVar12;
          local_500 = (undefined *)(local_4f0 - 0x30);
          while ((byte)(bVar1 - 0x30) < 10) {
            pbVar12 = pbVar12 + 1;
            local_500 = (undefined *)(((uint)bVar1 - 0x30) + (int)local_500 * 10);
            bVar1 = *pbVar12;
          }
          local_4f0 = 0x106;
          break;
        case 0x3c:
          if (*pbVar12 == 0x3d) {
            local_500 = (undefined *)0xa;
            local_4f0 = 0x103;
            pbVar12 = pbVar6 + 2;
          }
          else {
            local_500 = &DAT_00000008;
            local_4f0 = 0x103;
          }
          break;
        case 0x3d:
          if (*pbVar12 != 0x3d) goto switchD_080b398b_caseD_1;
          local_500 = &DAT_0000000c;
          local_4f0 = 0x102;
          pbVar12 = pbVar6 + 2;
          break;
        case 0x3e:
          if (*pbVar12 == 0x3d) {
            local_500 = (undefined *)0xb;
            local_4f0 = 0x103;
            pbVar12 = pbVar6 + 2;
          }
          else {
            local_500 = &DAT_00000009;
            local_4f0 = 0x103;
          }
        }
        *local_4fc = pbVar12;
        goto LAB_080b35b3;
      }
LAB_080b37d8:
      *local_4fc = pbVar6;
      uVar5 = 0;
      local_4f0 = 0;
    }
    else {
LAB_080b35b3:
      if ((int)local_4f0 < 1) {
        uVar5 = 0;
        local_4f0 = 0;
      }
      else {
        uVar5 = 2;
        if (local_4f0 < 0x107) {
          uVar5 = (uint)""[local_4f0];
        }
      }
    }
    local_4ec = uVar5 + iVar10;
    if ((0x36 < local_4ec) || ((int)"\x01\n\v\x04\r\x0e\b\t"[local_4ec] != uVar5)) goto yydefault;
    bVar1 = 
            "\a\x01\x02\b\x03\x04\x0f\x10\t\x12\x13\x14\x15\x16\x17\x18\n\v\f\r\x0e\x0f\x10\x10\x1a\x0e\x0f\x10\x11\n\v\f\r\x0e\x0f\x10"
            [local_4ec];
    if (bVar1 == 0) goto yyerrlab;
    if (bVar1 != 9) {
      uVar5 = 0xfffffffe;
      if (local_4f0 == 0) {
        uVar5 = local_4f0;
      }
      peVar11 = (expression *)((expression **)peVar11 + 1);
      local_4f0 = uVar5;
      *(undefined **)&peVar11->nargs = local_500;
      local_4e0 = (uint)bVar1;
      local_4f8 = local_4f8 + -1 + (uint)(local_4f8 == 0);
      goto yynewstate;
    }
LAB_080b3ba5:
    iVar10 = 0;
LAB_080b3765:
    if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
      return iVar10;
    }
                    // WARNING: Subroutine does not return
    *(undefined4 *)(puVar8 + -4) = 0x80b3bec;
    __stack_chk_fail();
  }
yydefault:
  bVar1 = ""[local_4e0];
  local_4e0 = (uint)bVar1;
  if (bVar1 == 0) {
yyerrlab:
    if (local_4f8 != 3) {
LAB_080b3714:
      do {
        if (((iVar10 != -10) && (iVar10 + 1U < 0x37)) &&
           ("\x01\n\v\x04\r\x0e\b\t"[iVar10 + 1] == '\x01')) {
          bVar1 = 
                  "\a\x01\x02\b\x03\x04\x0f\x10\t\x12\x13\x14\x15\x16\x17\x18\n\v\f\r\x0e\x0f\x10\x10\x1a\x0e\x0f\x10\x11\n\v\f\r\x0e\x0f\x10"
                  [iVar10 + 1];
          if (bVar1 != 0) goto code_r0x080b3735;
        }
        if (psVar7 == psVar4) goto LAB_080b3760;
        psVar7 = psVar7 + -1;
        peVar11 = (expression *)((expression **)peVar11 + -1);
        iVar10 = (int)yypact[*psVar7];
      } while( true );
    }
    if (local_4f0 != 0) {
      local_4f0 = 0xfffffffe;
      goto LAB_080b3714;
    }
    goto LAB_080b3760;
  }
  local_4ec = (uint)""[(uint)bVar1];
  op = ((expression **)peVar11)[1 - (uint)""[(uint)bVar1]];
  switch(bVar1) {
  case 2:
    if (*(expression **)peVar11 == (expression *)0x0) goto LAB_080b3760;
    *(expression **)(local_4fc + 1) = *(expression **)peVar11;
    break;
  case 3:
    args[1] = ((expression **)peVar11)[-2];
    args[0] = ((expression **)peVar11)[-4];
    *(undefined4 *)(puVar9 + -4) = 0x80b389b;
    op = new_exp(3,0x10,args,puVar9[-4]);
    break;
  case 4:
    args[1] = *(expression **)peVar11;
    args[0] = ((expression **)peVar11)[-2];
    *(undefined4 *)(puVar9 + -4) = 0x80b38bd;
    op = new_exp(2,0xf,args,puVar9[-4]);
    break;
  case 5:
    args[1] = *(expression **)peVar11;
    args[0] = ((expression **)peVar11)[-2];
    *(undefined4 *)(puVar9 + -4) = 0x80b38df;
    op = new_exp(2,0xe,args,puVar9[-4]);
    break;
  case 6:
  case 7:
  case 8:
  case 9:
    op = ((expression **)peVar11)[-1];
    args[1] = *(expression **)peVar11;
    args[0] = ((expression **)peVar11)[-2];
    *(undefined4 *)(puVar9 + -4) = 0x80b3798;
    op = new_exp(2,op,args,puVar9[-4]);
    break;
  case 10:
    args[0] = *(expression **)peVar11;
    *(undefined4 *)(puVar9 + -4) = 0x80b3933;
    op = new_exp(1,2,args,puVar9[-4]);
    break;
  case 0xb:
    *(undefined4 *)(puVar9 + -4) = 0x80b3917;
    op = new_exp(0,0,0,puVar9[-4]);
    break;
  case 0xc:
    *(undefined4 *)(puVar9 + -4) = 0x80b38fa;
    op = new_exp(0,1,0,puVar9[-4]);
    if (op != (expression *)0x0) {
      *(expression **)&op->val = *(expression **)peVar11;
    }
    break;
  case 0xd:
    op = ((expression **)peVar11)[-1];
  }
  psVar7 = psVar7 + local_4ec * 0x7fffffff;
  ((expression **)peVar11 + local_4ec * 0x3fffffff)[1] = op;
  peVar11 = (expression *)((expression **)peVar11 + local_4ec * 0x3fffffff + 1);
  uVar5 = (int)*psVar7 + (int)(char)""[(uint)""[local_4e0] + 0xc];
  if ((uVar5 < 0x37) && (*psVar7 == (short)"\x01\n\v\x04\r\x0e\b\t"[uVar5])) {
    local_4e0 = (uint)
                      "\a\x01\x02\b\x03\x04\x0f\x10\t\x12\x13\x14\x15\x16\x17\x18\n\v\f\r\x0e\x0f\x10\x10\x1a\x0e\x0f\x10\x11\n\v\f\r\x0e\x0f\x10"
                      [uVar5];
  }
  else {
    local_4e0 = (int)(char)""[(uint)""[local_4e0] + 1];
  }
yynewstate:
  psVar7 = psVar7 + 1;
  op = local_4e4;
  goto yysetstate;
code_r0x080b3735:
  if (bVar1 == 9) goto LAB_080b3ba5;
  peVar11 = (expression *)((expression **)peVar11 + 1);
  *(undefined **)&peVar11->nargs = local_500;
  local_4e0 = (uint)bVar1;
  local_4f8 = 3;
  goto yynewstate;
}



uchar * textdomain__(uchar *domainname)

{
  uchar *__ptr;
  int iVar1;
  uchar *puVar2;
  
  __ptr = _nl_current_default_domain__;
  if (domainname == (uchar *)0x0) {
    return _nl_current_default_domain__;
  }
  if ((*domainname == '\0') || (iVar1 = strcmp((char *)domainname,(char *)"messages"), iVar1 == 0))
  {
    _nl_current_default_domain__ = "messages";
    puVar2 = _nl_current_default_domain__;
  }
  else {
    iVar1 = strcmp((char *)domainname,(char *)__ptr);
    if (iVar1 == 0) {
      if (__ptr == (uchar *)0x0) {
        return (uchar *)0x0;
      }
      _nl_msg_cat_cntr = _nl_msg_cat_cntr + 1;
      return __ptr;
    }
    puVar2 = (uchar *)__strdup(domainname);
    if (puVar2 == (uchar *)0x0) {
      return (uchar *)0x0;
    }
  }
  _nl_current_default_domain__ = puVar2;
  _nl_msg_cat_cntr = _nl_msg_cat_cntr + 1;
  puVar2 = __ptr;
  if ((__ptr != _nl_current_default_domain__) &&
     (puVar2 = _nl_current_default_domain__, __ptr != "messages")) {
    free(__ptr);
  }
  return puVar2;
}



uchar * get_event_name(int id)

{
  if ((-1 < id) && ((uint)id < eventssize)) {
    return events[id].name;
  }
  return (uchar *)0x0;
}



void done_event(void)

{
  event *peVar1;
  uint uVar2;
  
  if (eventssize != 0) {
    uVar2 = 0;
    do {
      peVar1 = events + uVar2;
      if (peVar1->handlers != (event_handler *)0x0) {
        mem_free(peVar1->handlers);
        peVar1 = events + uVar2;
      }
      uVar2 = uVar2 + 1;
      mem_free(peVar1->name);
    } while (uVar2 < eventssize);
  }
  if (events != (event *)0x0) {
    mem_free(events);
  }
  events = (event *)0x0;
  if (event_hash != (hash *)0x0) {
    free_hash(&event_hash);
  }
  eventssize = 0;
  return;
}



void init_event(void)

{
  event_hash = init_hash8();
  return;
}



void unregister_event_hook(int id,event_hook_T *callback)

{
  uint uVar1;
  uint uVar2;
  event_handler *peVar3;
  int iVar4;
  event_handler *__dest;
  event *peVar5;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(callback == (event_hook_T *)0x0);
  if (callback == (event_hook_T *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/event.c";
    errline = 0xfa;
    elinks_internal((uchar *)"assertion callback failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if ((-1 < id) && ((uint)id < eventssize)) {
    peVar5 = events + id;
    peVar3 = peVar5->handlers;
    if ((peVar3 != (event_handler *)0x0) && (uVar2 = peVar5->count, uVar2 != 0)) {
      __dest = peVar3;
      if (peVar3->callback == callback) {
        iVar4 = 0xc;
        uVar1 = 1;
      }
      else {
        uVar1 = 0;
        do {
          uVar1 = uVar1;
          __dest = __dest + 1;
          uVar1 = uVar1 + 1;
          if (uVar2 <= uVar1) {
            return;
          }
        } while (__dest->callback != callback);
        uVar1 = uVar1 + 2;
        if ((int)uVar1 <= (int)uVar1) {
          uVar1 = uVar1;
        }
        iVar4 = uVar1 * 0xc;
      }
      memmove(__dest,(void *)((int)&peVar3->callback + iVar4),(uVar2 - uVar1) * 0xc);
      uVar2 = peVar5->count - 1;
      peVar5->count = uVar2;
      if (uVar2 == 0) {
        mem_free(peVar5->handlers);
        peVar5->handlers = (event_handler *)0x0;
        return;
      }
      peVar3 = (event_handler *)mem_realloc(peVar5->handlers,uVar2 * 0xc);
      if (peVar3 != (event_handler *)0x0) {
        peVar5->handlers = peVar3;
      }
    }
  }
  return;
}



void __regparm3 trigger_event_va(int id,va_list ap_init)

{
  evhook_status eVar1;
  event_handler *peVar2;
  uint uVar3;
  
  if ((-1 < id) && ((uint)id < eventssize)) {
    uVar3 = 0;
    peVar2 = events[id].handlers;
    if (events[id].count != 0) {
      while ((eVar1 = (*peVar2->callback)(ap_init,peVar2->data), eVar1 != EVENT_HOOK_STATUS_LAST &&
             (uVar3 = uVar3 + 1, uVar3 <= events[id].count && events[id].count != uVar3))) {
        peVar2 = peVar2 + 1;
      }
    }
  }
  return;
}



void trigger_event(int id,...)

{
  trigger_event_va(id,&stack0x00000008);
  return;
}



int get_event_id(uchar *name)

{
  void *pvVar1;
  hash *hash;
  size_t keylen;
  hash_item *phVar2;
  
  if (assert_failed == 0) {
    if ((name == (uchar *)0x0) || (*name == '\0')) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/event.c";
      errline = 0x7d;
      elinks_internal((uchar *)"assertion name && name[0] failed: Empty or missing event name");
      if (assert_failed != 0) {
        assert_failed = 0;
        return -1;
      }
    }
    else {
      assert_failed = 0;
    }
    hash = event_hash;
    if (event_hash == (hash *)0x0) {
      return -1;
    }
    keylen = strlen((char *)name);
    phVar2 = get_hash_item(hash,name,keylen);
    if (phVar2 == (hash_item *)0x0) {
      return -1;
    }
    pvVar1 = phVar2->value;
    if (assert_failed == 0) {
      assert_failed = ZEXT14(pvVar1 == (void *)0x0);
      if (pvVar1 == (void *)0x0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/event.c";
        errline = 0x87;
        elinks_internal((uchar *)"assertion event != NULL failed: Hash item with no value");
        if (assert_failed != 0) {
          assert_failed = 0;
          return -1;
        }
      }
      return *(int *)((int)pvVar1 + 0xc);
    }
  }
  assert_failed = 0;
  return -1;
}



void unregister_event_hooks(event_hook_info *hooks)

{
  uchar *name;
  int id;
  
  name = hooks->name;
  while (name != (uchar *)0x0) {
    id = get_event_id(name);
    if (id != -1) {
      unregister_event_hook(id,hooks->callback);
    }
    name = hooks[1].name;
    hooks = hooks + 1;
  }
  return;
}



void trigger_event_name(uchar *name,...)

{
  int id;
  
  id = get_event_id(name);
  trigger_event_va(id,&stack0x00000008);
  return;
}



int register_event(uchar *name)

{
  event *peVar1;
  uint uVar2;
  event *peVar3;
  size_t keylen;
  hash_item *phVar4;
  uchar *key;
  uint uVar5;
  size_t size;
  uint uVar6;
  event *local_20;
  
  uVar2 = get_event_id(name);
  peVar1 = events;
  if (uVar2 == 0xffffffff) {
    uVar5 = eventssize + 8 & 0xfffffff8;
    uVar6 = eventssize + 7 & 0xfffffff8;
    local_20 = events;
    peVar3 = events;
    if (uVar6 < uVar5) {
      size = uVar5 * 0x10;
      peVar3 = (event *)mem_realloc(events,size);
      if (peVar3 == (event *)0x0) {
        return -1;
      }
      events = peVar3;
      memset(peVar3 + uVar6,0,size + uVar6 * -0x10);
    }
    if (peVar3 != (event *)0x0) {
      uVar5 = eventssize;
      if (peVar1 != peVar3) {
        uVar6 = 0;
        uVar5 = 0;
        local_20 = peVar3;
        if (eventssize != 0) {
          do {
            key = peVar3[uVar6].name;
            keylen = strlen((char *)key);
            phVar4 = get_hash_item(event_hash,key,keylen);
            if (phVar4 != (hash_item *)0x0) {
              *(event **)&phVar4->value = events + uVar6;
            }
            uVar6 = uVar6 + 1;
            peVar3 = events;
          } while (uVar6 < eventssize);
          local_20 = events;
          uVar5 = eventssize;
        }
      }
      local_20 = local_20 + uVar5;
      keylen = strlen((char *)name);
      key = memacpy(name,keylen);
      local_20->name = key;
      if (key != (uchar *)0x0) {
        phVar4 = add_hash_item(event_hash,key,keylen,local_20);
        if (phVar4 == (hash_item *)0x0) {
          mem_free(local_20->name);
          local_20->name = (uchar *)0x0;
        }
        else {
          local_20->handlers = (event_handler *)0x0;
          local_20->count = 0;
          local_20->id = eventssize;
          uVar2 = eventssize;
          eventssize = eventssize + 1;
        }
      }
    }
  }
  return uVar2;
}



int register_event_hook(int id,event_hook_T *callback,int priority,void *data)

{
  event_handler *peVar1;
  uint uVar2;
  event_handler *p;
  size_t size;
  uint uVar3;
  event_handler *__src;
  int iVar4;
  uint uVar5;
  event *peVar6;
  int iVar7;
  uint local_28;
  uint local_20;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return -1;
  }
  assert_failed = ZEXT14(callback == (event_hook_T *)0x0);
  if (callback == (event_hook_T *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/event.c";
    errline = 0xd1;
    elinks_internal((uchar *)"assertion callback failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return -1;
    }
  }
  if (id < 0) {
    return -1;
  }
  if (eventssize <= (uint)id) {
    return -1;
  }
  peVar6 = events + id;
  uVar5 = peVar6->count;
  if (uVar5 == 0) {
    p = peVar6->handlers;
    size = 0xc;
LAB_080b4510:
    p = (event_handler *)mem_realloc(p,size);
    if (p == (event_handler *)0x0) {
      return -1;
    }
    peVar6->handlers = p;
    local_28 = peVar6->count + 1;
    peVar6->count = local_28;
  }
  else {
    p = peVar6->handlers;
    local_20 = 0;
    __src = p;
    if (p->callback == callback) {
      local_20 = 0;
      iVar4 = 0xc;
      uVar3 = 1;
    }
    else {
      do {
        uVar2 = local_20;
        local_20 = uVar2 + 1;
        if (uVar5 <= local_20) break;
        peVar1 = __src + 1;
        __src = __src + 1;
      } while (peVar1->callback != callback);
      if (local_20 == uVar5) {
        size = (uVar2 + 2) * 0xc;
        goto LAB_080b4510;
      }
      uVar2 = uVar2 + 2;
      uVar3 = local_20;
      if ((int)local_20 <= (int)uVar2) {
        uVar3 = uVar2;
      }
      local_20 = local_20 * 0xc;
      iVar4 = uVar2 * 0xc;
    }
    memmove((void *)((int)&p->callback + local_20),(void *)((int)&p->callback + iVar4),
            (uVar5 - uVar3) * 0xc);
    local_28 = peVar6->count;
    p = peVar6->handlers;
  }
  if (local_28 == 1) {
    iVar4 = 0xc;
    iVar7 = 0;
    __src = peVar6->handlers;
    local_20 = 1;
  }
  else {
    uVar5 = 0;
    iVar4 = 0xc;
    if (p->priority < priority) {
      iVar4 = 0xc;
      iVar7 = 0;
      local_20 = 1;
      __src = p;
    }
    else {
      do {
        iVar7 = iVar4;
        uVar3 = uVar5;
        uVar5 = uVar3 + 1;
        local_20 = uVar5;
        if (local_28 - 1 <= uVar5) {
          uVar3 = uVar3 + 2;
          if ((int)uVar5 <= (int)uVar3) {
            local_20 = uVar3;
          }
          iVar7 = uVar5 * 0xc;
          __src = p + uVar5;
          iVar4 = uVar3 * 0xc;
          goto LAB_080b4412;
        }
        __src = (event_handler *)((int)&p->callback + iVar7);
        iVar4 = iVar7 + 0xc;
      } while (priority <= *(int *)((int)&p->priority + iVar7));
      uVar3 = uVar3 + 2;
      if ((int)uVar5 <= (int)uVar3) {
        local_20 = uVar3;
      }
      iVar4 = uVar3 * 0xc;
    }
  }
LAB_080b4412:
  memmove((void *)((int)&p->callback + iVar4),__src,(local_28 - local_20) * 0xc);
  *(event_hook_T **)((int)&peVar6->handlers->callback + iVar7) = callback;
  *(int *)((int)&peVar6->handlers->priority + iVar7) = priority;
  *(void **)((int)&peVar6->handlers->data + iVar7) = data;
  return id;
}



void register_event_hooks(event_hook_info *hooks)

{
  uchar *name;
  int id;
  
  name = hooks->name;
  while (name != (uchar *)0x0) {
    id = register_event(name);
    if (id != -1) {
      register_event_hook(id,hooks->callback,hooks->priority,hooks->data);
    }
    name = hooks[1].name;
    hooks = hooks + 1;
  }
  return;
}



int __regparm3 get_address(socket_info *info,addr_type type)

{
  string *psVar1;
  long *plVar2;
  uint uVar3;
  sockaddr *psVar4;
  uchar *name;
  string path;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(info == (socket_info *)0x0);
    if (info == (socket_info *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/interlink.c";
      errline = 0x8b;
      elinks_internal((uchar *)"assertion info failed!");
      if (assert_failed != 0) goto LAB_080b46fe;
    }
    assert_failed = 0;
    if (elinks_home != (uchar *)0x0) {
      psVar1 = init_string(&path);
      if (psVar1 != (string *)0x0) {
        add_to_string(&path,elinks_home);
        add_to_string(&path,"socket");
        plVar2 = get_opt_(cmdline_options,name);
        add_long_to_string(&path,*plVar2);
        uVar3 = ~path.length;
        if ((int)(uVar3 + 0x6c) < 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/interlink.c";
          errline = 0xae;
          elinks_internal((uchar *)"Socket path name \'%s\' is too long: %d >= %zu",path.source,
                          path.length,0x6c);
        }
        else {
          psVar4 = (sockaddr *)mem_calloc(1,0x6e);
          if (psVar4 != (sockaddr *)0x0) {
            memcpy(psVar4->sa_data,path.source,path.length);
            done_string(&path);
            psVar4->sa_family = 1;
            info->addr = psVar4;
            info->size = 0x6e - (uVar3 + 0x6c);
            return 1;
          }
        }
        done_string(&path);
        return -1;
      }
    }
  }
  else {
LAB_080b46fe:
    assert_failed = 0;
  }
  return -1;
}



void __regparm3 report_af_unix_error(uchar *function,int error)

{
  char *pcVar1;
  uchar *fmt;
  
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/interlink.c";
  errline = 0x149;
  pcVar1 = strerror(error);
  fmt = gettext((uchar *)"The call to %s failed: %d (%s)");
  elinks_error(fmt,function,error,pcVar1);
  return;
}



void __regparm3 unlink_unix(sockaddr *addr)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(addr == (sockaddr *)0x0);
  if (addr == (sockaddr *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/interlink.c";
    errline = 0xe1;
    elinks_internal((uchar *)"assertion addr failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  unlink(addr->sa_data);
  return;
}



void done_interlink(void)

{
  if (s_info_listen.addr != (sockaddr *)0x0) {
    if (s_info_listen.fd != -1) {
      close(s_info_listen.fd);
      s_info_listen.fd = -1;
    }
    unlink_unix(s_info_listen.addr);
    mem_free(s_info_listen.addr);
    s_info_listen.addr = (sockaddr *)0x0;
  }
  if (s_info_connect.addr != (sockaddr *)0x0) {
    if (s_info_connect.fd != -1) {
      close(s_info_connect.fd);
      s_info_connect.fd = -1;
    }
    mem_free(s_info_connect.addr);
    s_info_connect.addr = (sockaddr *)0x0;
  }
  if (s_info_accept.addr != (sockaddr *)0x0) {
    if (s_info_accept.fd != -1) {
      close(s_info_accept.fd);
      s_info_accept.fd = -1;
    }
    mem_free(s_info_accept.addr);
    s_info_accept.addr = (sockaddr *)0x0;
  }
  return;
}



void af_unix_connection(socket_info *info)

{
  int fdin;
  int *piVar1;
  socklen_t local_10 [2];
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(info == (socket_info *)0x0);
  if (info == (socket_info *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/interlink.c";
    errline = 0x154;
    elinks_internal((uchar *)"assertion info failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  local_10[0] = info->size;
  memset(info->addr,0,local_10[0]);
  fdin = accept(info->fd,(sockaddr *)info->addr,local_10);
  if (fdin < 0) {
    piVar1 = __errno_location();
    report_af_unix_error((uchar *)"accept()",*piVar1);
    return;
  }
  init_term(fdin,fdin);
  set_highpri();
  return;
}



void elinks_usleep(ulong useconds)

{
  int iVar1;
  fd_set *pfVar2;
  fd_set dummy;
  timeval delay;
  
  iVar1 = 0x20;
  pfVar2 = (fd_set *)&dummy;
  while (iVar1 != 0) {
    iVar1 = iVar1 + -1;
    pfVar2->fds_bits[0] = 0;
    pfVar2 = (fd_set *)(pfVar2->fds_bits + 1);
  }
  delay.tv_sec = 0;
  delay.tv_usec = useconds;
  select(0,(fd_set *)&dummy,(fd_set *)&dummy,(fd_set *)&dummy,(timeval *)&delay);
  return;
}



int init_interlink(void)

{
  int __domain;
  int iVar1;
  int *piVar2;
  __mode_t __mask;
  int iVar3;
  sockaddr *psVar4;
  ulong useconds;
  ulong uVar5;
  
  __domain = get_address(&s_info_connect,ADDR_IP_CLIENT);
  if (__domain != -1) {
    useconds = 50000;
    do {
      s_info_connect.fd = socket(__domain,1,0);
      if (s_info_connect.fd == -1) {
        piVar2 = __errno_location();
        report_af_unix_error((uchar *)"socket()",*piVar2);
        break;
      }
      iVar1 = connect(s_info_connect.fd,(sockaddr *)s_info_connect.addr,s_info_connect.size);
      if (-1 < iVar1) {
        if (s_info_connect.fd != -1) {
          return s_info_connect.fd;
        }
        goto LAB_080b4b07;
      }
      piVar2 = __errno_location();
      iVar1 = *piVar2;
      close(s_info_connect.fd);
      if ((iVar1 != 2) && (iVar1 != 0x6f)) {
        report_af_unix_error((uchar *)"connect()",*piVar2);
        break;
      }
      uVar5 = useconds + 50000;
      elinks_usleep(useconds);
      useconds = uVar5;
    } while (uVar5 != 200000);
  }
  if (s_info_connect.addr != (sockaddr *)0x0) {
    mem_free(s_info_connect.addr);
  }
  s_info_connect.addr = (sockaddr *)0x0;
LAB_080b4b07:
  __mask = umask(0x7f);
  __domain = get_address(&s_info_listen,ADDR_IP_SERVER);
  if (__domain != -1) {
    iVar1 = 0;
    useconds = 100000;
    while (s_info_listen.fd = socket(__domain,1,0), s_info_listen.fd != -1) {
      iVar3 = bind(s_info_listen.fd,(sockaddr *)s_info_listen.addr,s_info_listen.size);
      if (-1 < iVar3) {
        if (assert_failed == 0) {
          assert_failed = 0;
          psVar4 = (sockaddr *)mem_calloc(1,0x6e);
          if (psVar4 != (sockaddr *)0x0) {
            s_info_accept.size = 0x6e;
            s_info_accept.fd = s_info_listen.fd;
            s_info_accept.addr = psVar4;
            __domain = listen(s_info_listen.fd,100);
            if (__domain == 0) {
              set_handlers(s_info_listen.fd,af_unix_connection,(select_handler_T *)0x0,
                           (select_handler_T *)0x0,&s_info_accept);
              umask(__mask);
              return -1;
            }
            piVar2 = __errno_location();
            report_af_unix_error((uchar *)"listen()",*piVar2);
          }
        }
        else {
          assert_failed = 0;
        }
        goto free_and_error;
      }
      piVar2 = __errno_location();
      if (*piVar2 != 0x62) {
        report_af_unix_error((uchar *)"bind()",*piVar2);
      }
      iVar1 = iVar1 + 1;
      if (iVar1 == 3) {
        unlink_unix(s_info_listen.addr);
      }
      else {
        if (3 < iVar1) goto free_and_error;
      }
      elinks_usleep(useconds);
      close(s_info_listen.fd);
      useconds = useconds + 100000;
    }
    piVar2 = __errno_location();
    report_af_unix_error((uchar *)"socket()",*piVar2);
  }
free_and_error:
  done_interlink();
  umask(__mask);
  return -1;
}



void __regparm3 check_stdio(list_head_elinks *url_list)

{
  int iVar1;
  option_value *poVar2;
  int *piVar3;
  int *piVar4;
  uchar *name;
  uchar *name_00;
  uchar *name_01;
  uchar *extraout_EDX;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(remote_session_flags != 0), remote_session_flags != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/main.c";
    errline = 0x43;
    elinks_internal((uchar *)"assertion !remote_session_flags failed!");
  }
  iVar1 = isatty(0);
  if (iVar1 == 0) {
    name_00 = name;
    if ((url_list != (list_head_elinks *)0x0) && ((list_head_elinks *)url_list->next == url_list)) {
      poVar2 = get_opt_(config_options,name);
      *poVar2 = 1;
      add_to_string_list(url_list,(uchar *)"file:///dev/stdin",0x11);
      name_00 = extraout_EDX;
    }
    poVar2 = get_opt_(cmdline_options,name_00);
    *poVar2 = 1;
  }
  iVar1 = isatty(1);
  if (iVar1 == 0) {
    piVar3 = get_opt_(cmdline_options,name_01);
    if (*piVar3 == 0) {
      piVar4 = get_opt_(cmdline_options,(uchar *)0x0);
      if (*piVar4 == 0) {
        *piVar3 = 1;
      }
    }
  }
  return;
}



int init(EVP_PKEY_CTX *ctx)

{
  remote_session_flags remote;
  uchar *filename;
  int ctl;
  retval rVar1;
  int extraout_EAX;
  uchar *filename_00;
  int *piVar2;
  int extraout_EAX_00;
  int extraout_EAX_01;
  uchar **ppuVar3;
  string *psVar4;
  int out;
  int in;
  int std_in;
  terminal *term;
  uchar *extraout_EDX;
  uchar *extraout_EDX_00;
  uchar *name;
  uchar *extraout_EDX_01;
  uchar *name_00;
  uchar *extraout_EDX_02;
  uchar *extraout_EDX_03;
  uchar *extraout_EDX_04;
  option_elinks *local_6c;
  char *local_68;
  char *pcVar5;
  string info;
  list_head_elinks url_list;
  
  url_list.next = (option_elinks *)&url_list;
  url_list.prev = (option_elinks *)&url_list;
  init_osdep();
  filename = get_cwd();
  if ((filename == (uchar *)0x0) || (ctl = file_is_dir(filename), ctl == 0)) {
    filename_00 = (uchar *)getenv("HOME");
    if ((filename_00 != (uchar *)0x0) && (ctl = file_is_dir(filename_00), ctl != 0)) {
      chdir((char *)filename_00);
    }
    if (filename != (uchar *)0x0) goto LAB_080b4e76;
  }
  else {
LAB_080b4e76:
    mem_free(filename);
  }
  bindtextdomain("elinks",(uchar *)"/usr/share/locale");
  textdomain("elinks");
  set_language(0);
  init_event();
  init_charsets_lookup();
  init_colors_lookup();
  init_modules(main_modules);
  init_options();
  init_static_version();
  register_modules_options(main_modules);
  register_modules_options(builtin_modules);
  set_sigcld();
  get_system_name();
  ctl = check_terminal_pipes();
  if (ctl != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/main.c";
    errline = 0x88;
    filename = gettext((uchar *)"Cannot create a pipe for internal communication.");
    elinks_error(filename);
    program.terminate = 1;
    program.retval = RET_FATAL;
    return extraout_EAX_01;
  }
  rVar1 = parse_options(ac + -1,av + 1,(list_head_elinks *)(option_elinks *)&url_list);
  if (rVar1 != RET_OK) {
    if (rVar1 != RET_COMMAND) {
      program.retval = rVar1;
    }
    program.terminate = 1;
    free_string_list((list_head_elinks *)(option_elinks *)&url_list);
    return extraout_EAX;
  }
  if (remote_session_flags == 0) {
    check_stdio((list_head_elinks *)(option_elinks *)&url_list);
    filename = extraout_EDX_04;
  }
  else {
    program.terminate = 1;
    filename = extraout_EDX;
  }
  local_68 = "no-home";
  local_6c = cmdline_options;
  piVar2 = get_opt_(cmdline_options,filename);
  filename = extraout_EDX_00;
  if (*piVar2 == 0) {
    init_home(local_6c,local_68);
    filename = extraout_EDX_03;
  }
  local_68 = "no-connect";
  local_6c = cmdline_options;
  piVar2 = get_opt_(cmdline_options,filename);
  if (*piVar2 == 0) {
    local_68 = "dump";
    local_6c = cmdline_options;
    piVar2 = get_opt_(cmdline_options,name);
    if (*piVar2 != 0) goto LAB_080b4fd6;
    local_68 = "source";
    local_6c = cmdline_options;
    piVar2 = get_opt_(cmdline_options,(uchar *)0x0);
    if ((*piVar2 != 0) || (ctl = init_interlink(), filename = extraout_EDX_02, ctl == -1))
    goto LAB_080b4fd6;
  }
  else {
LAB_080b4fd6:
    load_config(local_6c,local_68);
    update_options_visibility();
    parse_options(ac + -1,av + 1,(list_head_elinks *)0x0);
    if (remote_session_flags == 0) {
      check_stdio((list_head_elinks *)0x0);
    }
    init_b = 1;
    ctl = -1;
    init_modules(builtin_modules);
    filename = extraout_EDX_01;
  }
  local_68 = "dump";
  piVar2 = get_opt_(cmdline_options,filename);
  filename = name_00;
  if (*piVar2 == 0) {
    pcVar5 = "source";
    local_6c = cmdline_options;
    ppuVar3 = (uchar **)get_opt_(cmdline_options,name_00);
    filename = *ppuVar3;
    if (filename != (uchar *)0x0) goto LAB_080b5051;
    if ((remote_session_flags & SES_REMOTE_PING) == 0) {
      if ((ctl == -1) && (remote_session_flags != 0)) {
        local_6c = (option_elinks *)gettext((uchar *)"No remote session to connect to.");
        usrerror((uchar *)local_6c,pcVar5);
        program.retval = RET_REMOTE;
      }
      else {
        local_6c = (option_elinks *)&info;
        psVar4 = encode_session_info((string *)local_6c,
                                     (list_head_elinks *)(option_elinks *)&url_list);
        if (psVar4 == (string *)0x0) {
          errline = 0xe0;
          local_68 = "Unable to encode session info.";
LAB_080b5353:
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/main.c";
          filename = gettext((uchar *)local_68);
          elinks_error(filename);
          program.retval = RET_FATAL;
          program.terminate = 1;
        }
        else {
          if (ctl == -1) {
            ctl = get_ctl_handle();
            out = get_output_handle();
            in = get_input_handle();
            term = attach_terminal(in,out,ctl,info.source,info.length);
            if (term == (terminal *)0x0) {
              errline = 0xf1;
              local_68 = "Unable to attach_terminal().";
              goto LAB_080b5353;
            }
          }
          else {
            close_terminal_pipes();
            remote = remote_session_flags;
            out = get_ctl_handle();
            in = get_output_handle();
            std_in = get_input_handle();
            handle_trm(std_in,in,ctl,ctl,out,info.source,info.length,remote);
            term = (terminal *)0x0;
          }
          if (program.terminate == 0) {
            handle_basic_signals(term);
          }
        }
        done_string((string *)local_6c);
      }
    }
    else {
      if (ctl == -1) {
        local_6c = (option_elinks *)gettext((uchar *)"No running ELinks found.");
        usrerror((uchar *)local_6c,pcVar5);
        program.retval = RET_PING;
      }
    }
LAB_080b5062:
    if (program.terminate == 0) goto LAB_080b5070;
  }
  else {
LAB_080b5051:
    if ((option_elinks *)&url_list != (option_elinks *)url_list.next) {
      local_6c = (option_elinks *)&url_list;
      dump_next((list_head_elinks *)(option_elinks *)&url_list);
      goto LAB_080b5062;
    }
    piVar2 = get_opt_(cmdline_options,filename);
    if (*piVar2 == 0) {
      local_68 = "source";
    }
    local_6c = (option_elinks *)gettext((uchar *)"URL expected after -%s");
    usrerror((uchar *)local_6c,local_68);
    program.retval = RET_SYNTAX;
    program.terminate = 1;
  }
  close_terminal_pipes(local_6c);
LAB_080b5070:
  free_string_list((list_head_elinks *)(option_elinks *)&url_list);
  return extraout_EAX_00;
}



void shrink_memory(int whole)

{
  shrink_dns_cache(whole);
  shrink_format_cache(whole);
  garbage_collection(whole);
  return;
}



int main(int argc,char **argv)

{
  program.terminate = 0;
  program.retval = RET_OK;
  program.path = (uchar *)*argv;
  av = (uchar **)argv;
  ac = argc;
  select_loop(init);
  done_interlink();
  check_bottom_halves();
  abort_all_downloads();
  check_bottom_halves();
  destroy_all_terminals();
  check_bottom_halves();
  free_all_itrms();
  abort_all_connections();
  check_bottom_halves();
  abort_all_connections();
  if (init_b != 0) {
    trigger_event_name("quit");
    free_history_lists();
    done_modules(builtin_modules);
    done_saved_session_info();
  }
  shrink_memory(1);
  free_charsets_lookup();
  free_colors_lookup();
  done_modules(main_modules);
  free_conv_table();
  check_bottom_halves();
  done_home();
  done_state_message();
  done_bfu_colors();
  unregister_modules_options(builtin_modules);
  unregister_modules_options(main_modules);
  done_options();
  done_event();
  terminate_osdep();
  return program.retval;
}



// WARNING: Exceeded maximum restarts with more pending

void done_module(module *module)

{
  module **ppmVar1;
  module *module_00;
  int iVar2;
  int iVar3;
  
  ppmVar1 = module->submodules;
  if ((ppmVar1 != (module **)0x0) && (*ppmVar1 != (module *)0x0)) {
    iVar3 = 0;
    do {
      iVar2 = iVar3;
      iVar3 = iVar2 + 1;
    } while (ppmVar1[iVar2 + 1] != (module *)0x0);
    if ((iVar2 != -1) && (module_00 = ppmVar1[iVar2], module_00 != (module *)0x0)) {
      iVar2 = iVar2 + -1;
      iVar3 = iVar2 * 4;
      while (done_module(module_00), iVar2 != -1) {
        module_00 = *(module **)((int)module->submodules + iVar3);
        iVar3 = iVar3 + -4;
        if (module_00 == (module *)0x0) break;
        iVar2 = iVar2 + -1;
      }
    }
  }
  if (module->hooks != (event_hook_info *)0x0) {
    unregister_event_hooks(module->hooks);
  }
  if (module->done == (anon_subr_void_module_ptr_for_done *)0x0) {
    return;
  }
                    // WARNING: Could not recover jumptable at 0x080b5575. Too many branches
                    // WARNING: Treating indirect jump as call
  (*module->done)();
  return;
}



void done_modules(module **modules)

{
  int iVar1;
  module *module;
  int iVar2;
  
  if ((modules != (module **)0x0) && (*modules != (module *)0x0)) {
    iVar1 = 0;
    do {
      iVar2 = iVar1;
      iVar1 = iVar2 + 1;
    } while (modules[iVar2 + 1] != (module *)0x0);
    if ((iVar2 != -1) && (module = modules[iVar2], module != (module *)0x0)) {
      iVar2 = iVar2 + -1;
      modules = modules + iVar2;
      while (done_module(module), iVar2 != -1) {
        module = *modules;
        modules = modules + -1;
        if (module == (module *)0x0) {
          return;
        }
        iVar2 = iVar2 + -1;
      }
    }
  }
  return;
}



// WARNING: Type propagation algorithm not settling

void init_module(module *module)

{
  module *module_00;
  int iVar1;
  
  if (module->init != (anon_subr_void_module_ptr_for_init *)0x0) {
    (*module->init)(module);
  }
  if (module->hooks != (event_hook_info *)0x0) {
    register_event_hooks(module->hooks);
  }
  if (((module *)module->submodules != (module *)0x0) &&
     (module_00 = (module *)((module *)module->submodules)->name, module_00 != (module *)0x0)) {
    iVar1 = 4;
    do {
      init_module(module_00);
      module_00 = *(module **)((int)module->submodules + iVar1);
      iVar1 = iVar1 + 4;
    } while (module_00 != (module *)0x0);
  }
  return;
}



void init_modules(module **modules)

{
  module *module;
  
  if (modules != (module **)0x0) {
    module = *modules;
    while (module != (module *)0x0) {
      init_module(module);
      module = modules[1];
      modules = modules + 1;
    }
  }
  return;
}



void unregister_module_options(module *module)

{
  module **ppmVar1;
  module *module_00;
  int iVar2;
  int iVar3;
  
  ppmVar1 = module->submodules;
  if ((ppmVar1 != (module **)0x0) && (*ppmVar1 != (module *)0x0)) {
    iVar3 = 0;
    do {
      iVar2 = iVar3;
      iVar3 = iVar2 + 1;
    } while (ppmVar1[iVar2 + 1] != (module *)0x0);
    if ((iVar2 != -1) && (module_00 = ppmVar1[iVar2], module_00 != (module *)0x0)) {
      iVar2 = iVar2 + -1;
      iVar3 = iVar2 * 4;
      while (unregister_module_options(module_00), iVar2 != -1) {
        module_00 = *(module **)((int)module->submodules + iVar3);
        iVar3 = iVar3 + -4;
        if (module_00 == (module *)0x0) break;
        iVar2 = iVar2 + -1;
      }
    }
  }
  if (module->options != (option_info *)0x0) {
    unregister_options(module->options,config_options);
  }
  return;
}



void unregister_modules_options(module **modules)

{
  int iVar1;
  module *module;
  int iVar2;
  
  if ((modules != (module **)0x0) && (*modules != (module *)0x0)) {
    iVar1 = 0;
    do {
      iVar2 = iVar1;
      iVar1 = iVar2 + 1;
    } while (modules[iVar2 + 1] != (module *)0x0);
    if ((iVar2 != -1) && (module = modules[iVar2], module != (module *)0x0)) {
      iVar2 = iVar2 + -1;
      modules = modules + iVar2;
      while (unregister_module_options(module), iVar2 != -1) {
        module = *modules;
        modules = modules + -1;
        if (module == (module *)0x0) {
          return;
        }
        iVar2 = iVar2 + -1;
      }
    }
  }
  return;
}



// WARNING: Type propagation algorithm not settling

void register_module_options(module *module)

{
  module *module_00;
  int iVar1;
  
  if (module->options != (option_info *)0x0) {
    register_options(module->options,config_options);
  }
  if (((module *)module->submodules != (module *)0x0) &&
     (module_00 = (module *)((module *)module->submodules)->name, module_00 != (module *)0x0)) {
    iVar1 = 4;
    do {
      register_module_options(module_00);
      module_00 = *(module **)((int)module->submodules + iVar1);
      iVar1 = iVar1 + 4;
    } while (module_00 != (module *)0x0);
  }
  return;
}



void register_modules_options(module **modules)

{
  module *module;
  
  if (modules != (module **)0x0) {
    module = *modules;
    while (module != (module *)0x0) {
      register_module_options(module);
      module = modules[1];
      modules = modules + 1;
    }
  }
  return;
}



int get_file_handles_count(void)

{
  int iVar1;
  int iVar2;
  
  iVar2 = 0;
  iVar1 = 0;
  do {
    while (((*(int *)((int)&threads[0].read_func + iVar2) == 0 &&
            (*(int *)((int)&threads[0].write_func + iVar2) == 0)) &&
           (*(int *)((int)&threads[0].error_func + iVar2) == 0))) {
      iVar2 = iVar2 + 0x10;
      if (iVar2 == 0x4000) {
        return iVar1;
      }
    }
    iVar2 = iVar2 + 0x10;
    iVar1 = iVar1 + 1;
  } while (iVar2 != 0x4000);
  return iVar1;
}



int __regparm3 can_read_or_write(int fd,int write)

{
  byte bVar1;
  fd_set *__writefds;
  fd_set *__readfds;
  int iVar2;
  fd_set *pfVar3;
  fd_set *wfds;
  fd_set fds;
  timeval tv;
  
  iVar2 = 0x20;
  __writefds = (fd_set *)&fds;
  __readfds = (fd_set *)0x0;
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  pfVar3 = __writefds;
  while (iVar2 != 0) {
    iVar2 = iVar2 + -1;
    pfVar3->fds_bits[0] = 0;
    pfVar3 = (fd_set *)(pfVar3->fds_bits + 1);
  }
  iVar2 = fd + 0x1f;
  if (-1 < fd) {
    iVar2 = fd;
  }
  if (write == 0) {
    __readfds = __writefds;
    __writefds = (fd_set *)0x0;
  }
  bVar1 = (byte)(fd >> 0x37);
  fds.__fds_bits[iVar2 >> 5] =
       fds.__fds_bits[iVar2 >> 5] | 1 << (((char)fd + (bVar1 >> 3) & 0x1f) - (bVar1 >> 3) & 0x1f);
  iVar2 = select(fd + 1,__readfds,__writefds,(fd_set *)0x0,(timeval *)&tv);
  return iVar2;
}



int can_write(int fd)

{
  int iVar1;
  
  iVar1 = can_read_or_write(fd,1);
  return iVar1;
}



int can_read(int fd)

{
  int iVar1;
  
  iVar1 = can_read_or_write(fd,0);
  return iVar1;
}



void set_handlers(int fd,select_handler_T *read_func,select_handler_T *write_func,
                 select_handler_T *error_func,void *data)

{
  byte bVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(0x3ffU < (uint)fd);
  if (0x3ffU < (uint)fd) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/select.c";
    errline = 0x95;
    elinks_internal((uchar *)
                    "assertion fd >= 0 && fd < FD_SETSIZE failed: set_handlers: handle %d >= FD_SETSIZE %d"
                    ,fd,0x400);
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  threads[fd].read_func = read_func;
  threads[fd].write_func = write_func;
  threads[fd].error_func = error_func;
  threads[fd].data = data;
  bVar1 = (byte)(fd >> 0x37);
  if (read_func == (select_handler_T *)0x0) {
    iVar2 = fd + 0x1f;
    if (-1 < fd) {
      iVar2 = fd;
    }
    uVar3 = 1 << (((char)fd + (bVar1 >> 3) & 0x1f) - (bVar1 >> 3) & 0x1f);
    iVar2 = iVar2 >> 5;
    w_read.__fds_bits[iVar2] = w_read.__fds_bits[iVar2] & ~uVar3;
    x_read.__fds_bits[iVar2] = x_read.__fds_bits[iVar2] & ~uVar3;
  }
  else {
    iVar2 = fd + 0x1f;
    if (-1 < fd) {
      iVar2 = fd;
    }
    iVar2 = iVar2 >> 5;
    uVar3 = 1 << (((char)fd + (bVar1 >> 3) & 0x1f) - (bVar1 >> 3) & 0x1f);
    w_read.__fds_bits[iVar2] = w_read.__fds_bits[iVar2] | uVar3;
  }
  if (write_func == (select_handler_T *)0x0) {
    w_write.__fds_bits[iVar2] = w_write.__fds_bits[iVar2] & ~uVar3;
    x_write.__fds_bits[iVar2] = x_write.__fds_bits[iVar2] & ~uVar3;
  }
  else {
    w_write.__fds_bits[iVar2] = w_write.__fds_bits[iVar2] | uVar3;
  }
  if (error_func == (select_handler_T *)0x0) {
    w_error.__fds_bits[iVar2] = w_error.__fds_bits[iVar2] & ~uVar3;
    x_error.__fds_bits[iVar2] = x_error.__fds_bits[iVar2] & ~uVar3;
  }
  else {
    w_error.__fds_bits[iVar2] = w_error.__fds_bits[iVar2] | uVar3;
  }
  if (((write_func == (select_handler_T *)0x0) && (read_func == (select_handler_T *)0x0)) &&
     (error_func == (select_handler_T *)0x0)) {
    if (w_max + -1 == fd) {
      uVar3 = w_max - 2;
      if (-1 < (int)uVar3) {
        while( true ) {
          iVar2 = (int)uVar3 >> 5;
          uVar4 = uVar3 & 0x1f;
          if ((((uint)w_read.__fds_bits[iVar2] >> uVar4 & 1) != 0) ||
             (((uint)w_write.__fds_bits[iVar2] >> uVar4 & 1) != 0)) break;
          if ((((uint)w_error.__fds_bits[iVar2] >> uVar4 & 1) != 0) ||
             (uVar3 = uVar3 - 1, uVar3 == 0xffffffff)) break;
        }
      }
      w_max = uVar3 + 1;
    }
  }
  else {
    if (w_max <= fd) {
      w_max = fd + 1;
    }
  }
  return;
}



select_handler_T * get_handler(int fd,select_handler_type tp)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return (select_handler_T *)0x0;
  }
  assert_failed = ZEXT14(0x3ffU < (uint)fd);
  if (0x3ffU < (uint)fd) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/select.c";
    errline = 0x80;
    elinks_internal((uchar *)
                    "assertion fd >= 0 && fd < FD_SETSIZE failed: get_handler: handle %d >= FD_SETSIZE %d"
                    ,fd,0x400);
    if (assert_failed != 0) {
      assert_failed = 0;
      return (select_handler_T *)0x0;
    }
  }
  if (tp == SELECT_HANDLER_WRITE) {
    return threads[fd].write_func;
  }
  if (tp == SELECT_HANDLER_READ) {
    return threads[fd].read_func;
  }
  if (tp != SELECT_HANDLER_ERROR) {
    if (tp != SELECT_HANDLER_DATA) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/select.c";
      errline = 0x8a;
      elinks_internal((uchar *)"get_handler: bad type %d",tp);
      return (select_handler_T *)0x0;
    }
    return (select_handler_T *)threads[fd].data;
  }
  return threads[fd].error_func;
}



void check_bottom_halves(void)

{
  undefined4 uVar1;
  code *pcVar2;
  void *p;
  
  if ((list_head_elinks *)bottom_halves.next != &bottom_halves) {
    do {
      p = bottom_halves.prev;
      uVar1 = *(undefined4 *)((int)bottom_halves.prev + 0xc);
      pcVar2 = *(code **)((int)bottom_halves.prev + 8);
      *(undefined4 *)(*(int *)bottom_halves.prev + 4) = *(undefined4 *)((int)bottom_halves.prev + 4)
      ;
      **(undefined4 **)((int)p + 4) = *(undefined4 *)p;
      mem_free(p);
      (*pcVar2)(uVar1);
    } while ((list_head_elinks *)bottom_halves.next != &bottom_halves);
  }
  return;
}



void select_loop(anon_subr_void *init)

{
  int iVar1;
  timeval_T *__timeout;
  uint uVar2;
  int iVar3;
  int *piVar4;
  char *pcVar5;
  uchar *fmt;
  int __errnum;
  void **ppvVar6;
  fd_set *pfVar7;
  fd_set *pfVar8;
  byte bVar9;
  int local_34;
  int local_30;
  timeval_T t;
  timeval_T last_time;
  
  clear_signal_mask_and_handlers();
  __errnum = 0x20;
  pfVar7 = &w_read;
  while (__errnum != 0) {
    __errnum = __errnum + -1;
    pfVar7->__fds_bits[0] = 0;
    pfVar7 = (fd_set *)(pfVar7->__fds_bits + 1);
  }
  __errnum = 0x20;
  pfVar7 = &w_write;
  while (__errnum != 0) {
    __errnum = __errnum + -1;
    pfVar7->__fds_bits[0] = 0;
    pfVar7 = (fd_set *)(pfVar7->__fds_bits + 1);
  }
  __errnum = 0x20;
  bVar9 = 0;
  pfVar7 = &w_error;
  while (__errnum != 0) {
    __errnum = __errnum + -1;
    pfVar7->__fds_bits[0] = 0;
    pfVar7 = (fd_set *)(pfVar7->__fds_bits + 1);
  }
  w_max = 0;
  timeval_now(&last_time);
  signal(0xd,(__sighandler_t)0x1);
  (*init)();
  check_bottom_halves();
  local_34 = 0;
  do {
    while( true ) {
      while( true ) {
        if (program.terminate != 0) {
          return;
        }
        check_signals();
        check_timers(&last_time);
        redraw_all_terminals();
        __errnum = 0x20;
        pfVar7 = &w_read;
        pfVar8 = &x_read;
        while (__errnum != 0) {
          __errnum = __errnum + -1;
          pfVar8->__fds_bits[0] = pfVar7->__fds_bits[0];
          pfVar7 = (fd_set *)(pfVar7->__fds_bits + (uint)bVar9 * 0x3ffffffe + 1);
          pfVar8 = (fd_set *)(pfVar8->__fds_bits + (uint)bVar9 * 0x3ffffffe + 1);
        }
        __errnum = 0x20;
        pfVar7 = &w_write;
        pfVar8 = &x_write;
        while (__errnum != 0) {
          __errnum = __errnum + -1;
          pfVar8->__fds_bits[0] = pfVar7->__fds_bits[0];
          pfVar7 = (fd_set *)(pfVar7->__fds_bits + (uint)bVar9 * 0x3ffffffe + 1);
          pfVar8 = (fd_set *)(pfVar8->__fds_bits + (uint)bVar9 * 0x3ffffffe + 1);
        }
        __errnum = 0x20;
        pfVar7 = &w_error;
        pfVar8 = &x_error;
        while (__errnum != 0) {
          __errnum = __errnum + -1;
          pfVar8->__fds_bits[0] = pfVar7->__fds_bits[0];
          pfVar7 = (fd_set *)(pfVar7->__fds_bits + (uint)bVar9 * 0x3ffffffe + 1);
          pfVar8 = (fd_set *)(pfVar8->__fds_bits + (uint)bVar9 * 0x3ffffffe + 1);
        }
        if (program.terminate != 0) {
          return;
        }
        __errnum = get_next_timer_time(&t);
        if ((__errnum == 0) && (w_max == 0)) {
          return;
        }
        critical_section = 1;
        iVar1 = check_signals();
        if (iVar1 == 0) break;
        critical_section = 0;
      }
      __timeout = (timeval_T *)0x0;
      if (__errnum != 0) {
        timeval_limit_to_zero_or_one(&t);
        __timeout = &t;
      }
      local_30 = select(w_max,(fd_set *)&x_read,(fd_set *)&x_write,(fd_set *)&x_error,
                        (timeval *)__timeout);
      if (-1 < local_30) break;
      piVar4 = __errno_location();
      __errnum = *piVar4;
      critical_section = 0;
      uninstall_alarm();
      if (__errnum != 4) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/select.c";
        errline = 0x117;
        pcVar5 = strerror(__errnum);
        fmt = gettext((uchar *)"The call to %s failed: %d (%s)");
        elinks_error(fmt,"select()",__errnum,pcVar5);
        local_34 = local_34 + 1;
        if (10 < local_34) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/select.c";
          errline = 0x11a;
          fmt = gettext((uchar *)"%d select() failures.");
          elinks_internal(fmt,local_34);
        }
      }
    }
    critical_section = 0;
    uninstall_alarm();
    check_signals();
    check_timers(&last_time);
    if ((local_30 != 0) && (0 < w_max)) {
      ppvVar6 = &threads[0].data;
      __errnum = 0;
      do {
        iVar1 = __errnum + 0x1f;
        if (-1 < __errnum) {
          iVar1 = __errnum;
        }
        iVar1 = iVar1 >> 5;
        uVar2 = (uint)(__errnum >> 0x1f) >> 0x1b;
        uVar2 = (__errnum + uVar2 & 0x1f) - uVar2;
        iVar3 = 0;
        if (((uint)x_read.__fds_bits[iVar1] >> (uVar2 & 0x1f) & 1) != 0) {
          iVar3 = 1;
          if ((code *)ppvVar6[-3] != (code *)0x0) {
            (*(code *)ppvVar6[-3])(*ppvVar6);
            check_bottom_halves();
            iVar3 = 1;
          }
        }
        if (((uint)x_write.__fds_bits[iVar1] >> (uVar2 & 0x1f) & 1) != 0) {
          iVar3 = 1;
          if ((code *)ppvVar6[-2] != (code *)0x0) {
            (*(code *)ppvVar6[-2])(*ppvVar6);
            check_bottom_halves();
            iVar3 = 1;
          }
        }
        if (((uint)x_error.__fds_bits[iVar1] >> (uVar2 & 0x1f) & 1) != 0) {
          iVar3 = 1;
          if ((code *)ppvVar6[-1] != (code *)0x0) {
            (*(code *)ppvVar6[-1])(*ppvVar6);
            check_bottom_halves();
            iVar3 = 1;
          }
        }
        local_30 = local_30 - iVar3;
        if (local_30 == 0) break;
        __errnum = __errnum + 1;
        ppvVar6 = ppvVar6 + 4;
      } while (__errnum < w_max);
    }
    local_34 = 0;
  } while( true );
}



int register_bottom_half_do(select_handler_T *fn,void *data)

{
  void *pvVar1;
  void **ppvVar2;
  int iVar3;
  list_head_elinks *plVar4;
  
  plVar4 = (list_head_elinks *)bottom_halves.next;
  if ((list_head_elinks *)bottom_halves.next != &bottom_halves) {
    do {
      if (((select_handler_T *)plVar4[1].next == fn) && (plVar4[1].prev == data)) goto LAB_080b6058;
      plVar4 = (list_head_elinks *)plVar4->next;
    } while (plVar4 != &bottom_halves);
  }
  ppvVar2 = (void **)mem_alloc(0x10);
  iVar3 = -1;
  if (ppvVar2 != (void **)0x0) {
    *(select_handler_T **)(ppvVar2 + 2) = fn;
    ppvVar2[3] = data;
    pvVar1 = plVar4->next;
    *(list_head_elinks **)(ppvVar2 + 1) = plVar4;
    *ppvVar2 = pvVar1;
    *(void ***)&plVar4->next = ppvVar2;
    *(void ***)((int)*ppvVar2 + 4) = ppvVar2;
LAB_080b6058:
    iVar3 = 0;
  }
  return iVar3;
}



int get_timers_count(void)

{
  list_head_elinks **pplVar1;
  int iVar2;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)timers.next;
  if ((list_head_elinks *)timers.next != &timers) {
    do {
      pplVar1 = (list_head_elinks **)&plVar3->next;
      iVar2 = iVar2 + 1;
      plVar3 = *pplVar1;
    } while (*pplVar1 != &timers);
  }
  return iVar2;
}



int get_next_timer_time(timeval_T *t)

{
  long lVar1;
  bool bVar2;
  
  bVar2 = (list_head_elinks *)timers.next != &timers;
  if (bVar2) {
    lVar1 = *(long *)((int)timers.next + 0xc);
    t->sec = *(long *)((int)timers.next + 8);
    t->usec = lVar1;
  }
  return (uint)bVar2;
}



void kill_timer(timer_id_T *id)

{
  timer_id_T p;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(id == (timer_id_T *)0x0), id == (timer_id_T *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/timer.c";
    errline = 0x6b;
    elinks_internal((uchar *)"assertion id != NULL failed!");
  }
  p = *id;
  if (p != (timer_id_T)0x0) {
    p->next->prev = p->prev;
    p->prev->next = p->next;
    mem_free(p);
    *id = (timer_id_T)0x0;
  }
  return;
}



// WARNING: Type propagation algorithm not settling

void install_timer(timer_id_T *id,milliseconds_T delay,anon_subr_void_void_ptr *func,void *data)

{
  timer_id_T ptVar1;
  int iVar2;
  list_head_elinks *plVar3;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(delay < 1 || id == (timer_id_T *)0x0),
     delay < 1 || id == (timer_id_T *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/timer.c";
    errline = 0x54;
    elinks_internal((uchar *)"assertion id && delay > 0 failed!");
  }
  ptVar1 = (timer_id_T)mem_alloc(0x18);
  *id = ptVar1;
  if (ptVar1 != (timer_id_T)0x0) {
    timeval_from_milliseconds(&ptVar1->interval,delay);
    *(anon_subr_void_void_ptr **)&ptVar1->func = func;
    ptVar1->data = data;
    plVar3 = (list_head_elinks *)timers.next;
    if ((list_head_elinks *)timers.next != &timers) {
      do {
        iVar2 = timeval_cmp((timeval_T *)(plVar3 + 1),&ptVar1->interval);
        if (-1 < iVar2) break;
        plVar3 = (list_head_elinks *)plVar3->next;
      } while (plVar3 != &timers);
    }
    ptVar1->next = *(timer **)plVar3->prev;
    ptVar1->prev = (timer *)plVar3->prev;
    *(timer_id_T *)&((timer_id_T)plVar3->prev)->next = ptVar1;
    *(timer_id_T *)&ptVar1->next->prev = ptVar1;
  }
  return;
}



void check_timers(timeval_T *last_time)

{
  list_head_elinks *p;
  int iVar1;
  list_head_elinks *plVar2;
  timeval_T interval;
  timeval_T now;
  
  timeval_now(&now);
  timeval_sub(&interval,last_time,&now);
  plVar2 = (list_head_elinks *)timers.next;
  if ((list_head_elinks *)timers.next != &timers) {
    do {
      timeval_sub_interval((timeval_T *)(plVar2 + 1),&interval);
      plVar2 = (list_head_elinks *)plVar2->next;
      p = (list_head_elinks *)timers.next;
    } while (plVar2 != &timers);
    while ((timers.next = p, p != &timers &&
           (iVar1 = timeval_is_positive((timeval_T *)(p + 1)), iVar1 == 0))) {
      *(void **)((int)p->next + 4) = p->prev;
      *(void **)p->prev = p->next;
      (*(code *)p[2].next)(p[2].prev);
      mem_free(p);
      check_bottom_halves();
      p = (list_head_elinks *)timers.next;
    }
  }
  last_time->sec = now.sec;
  last_time->usec = now.usec;
  return;
}



void __regparm3 add_module_to_string(string *string,module *module,terminal *term)

{
  int cp_index;
  uchar *codeset;
  uchar *msgid;
  module *module_00;
  
  msgid = module->name;
  if (msgid != (uchar *)0x0) {
    if (*msgid != '\0') {
      if (term != (terminal *)0x0) {
        cp_index = get_terminal_codepage(term);
        if (cp_index != current_charset) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
      }
      msgid = gettext(msgid);
    }
    add_to_string(string,msgid);
  }
  if (module->submodules != (module **)0x0) {
    add_to_string(string," (");
    if ((module->submodules != (module **)0x0) &&
       (module_00 = *module->submodules, module_00 != (module *)0x0)) {
      cp_index = 0;
      while( true ) {
        cp_index = cp_index + 1;
        add_module_to_string(string,module_00,term);
        module_00 = module->submodules[cp_index];
        if (module_00 == (module *)0x0) break;
        if (cp_index != 0) {
          add_to_string(string,", ");
        }
      }
    }
    add_to_string(string,")");
  }
  return;
}



uchar * get_dyn_full_version(terminal *term,int more)

{
  uchar ", " [3];
  string *psVar1;
  int cp_index;
  uchar *codeset;
  uchar *codeset_00;
  uchar *codeset_01;
  char *pcVar2;
  module *module;
  char *pcVar3;
  string string;
  
  psVar1 = init_string(&string);
  codeset_00 = (uchar *)0x0;
  if (psVar1 != (string *)0x0) {
    add_format_to_string(&string,(uchar *)"ELinks %s",0x81324c6);
    if (*build_id != '\0') {
      add_char_to_string(&string,(-(more == 0) & 0x16U) + 10);
      add_format_to_string(&string,"%s",build_id);
    }
    add_char_to_string(&string,'\n');
    codeset_01 = build_time;
    codeset_00 = build_date;
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Built on %s %s");
    add_format_to_string(&string,codeset,codeset_00,codeset_01);
    if (more != 0) {
      add_to_string(&string,"\n\n");
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      codeset_00 = gettext((uchar *)"Text WWW browser");
      add_to_string(&string,codeset_00);
    }
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset_00 = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset_00);
      current_charset = cp_index;
    }
    codeset_00 = gettext((uchar *)"Standard");
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset_01 = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset_01);
      current_charset = cp_index;
    }
    codeset_01 = gettext((uchar *)"Features:");
    cp_index = 0;
    string_concat(&string,&DAT_081281ca,codeset_01,&DAT_08131ec3,codeset_00,", ",&DAT_08131634,
                  0x810c614,0x8132e3d,0x810c614,"bzip2",0x810c614,0x812ecd7,0x810c614,0);
    module = builtin_modules[0];
    if (builtin_modules[0] != (module *)0x0) {
      while( true ) {
        cp_index = cp_index + 1;
        add_module_to_string(&string,module,term);
        module = builtin_modules[cp_index];
        if (module == (module *)0x0) break;
        if (cp_index != 0) {
          add_to_string(&string,", ");
        }
      }
    }
    codeset_01 = string.source;
    codeset_00 = string.source;
    if (more == 0) {
      pcVar3 = (char *)0x0;
      pcVar2 = strrchr((char *)string.source,10);
      if (pcVar2 != (char *)0x0) {
        pcVar3 = pcVar2 + (1 - (int)codeset_01);
      }
      if (assert_failed != 0) {
        assert_failed = 0;
        return codeset_01;
      }
      if ((codeset_01 == (uchar *)0x0) || (string.length <= (int)pcVar3)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/version.c";
        errline = 0x43;
        elinks_internal((uchar *)
                        "assertion string && string->source && start_at < string->length failed!");
        codeset_01 = string.source;
        if (assert_failed != 0) {
          assert_failed = 0;
          return string.source;
        }
      }
      else {
        assert_failed = 0;
      }
      codeset_01 = codeset_01 + (int)pcVar3;
      pcVar3 = (char *)0x0;
      codeset = codeset_01;
      do {
        pcVar2 = strchr((char *)codeset_01,0x20);
        if (pcVar2 == (char *)0x0) {
          return string.source;
        }
        if ((int)(pcVar2 + -(int)codeset) < 0x48) {
          codeset_01 = (uchar *)(pcVar2 + 1);
        }
        else {
          if (pcVar3 != (char *)0x0) {
            *pcVar3 = '\n';
          }
          codeset_01 = (uchar *)(pcVar3 + 1);
          pcVar2 = pcVar3;
          codeset = codeset_01;
        }
        pcVar3 = pcVar2;
        codeset_00 = string.source;
      } while (*codeset_01 != '\0');
    }
  }
  return codeset_00;
}



void init_static_version(void)

{
  uchar *src;
  
  src = get_dyn_full_version((terminal *)0x0,0);
  if (src != (uchar *)0x0) {
    safe_strncpy(full_static_version,src,0x400);
    mem_free(src);
  }
  return;
}



void menu_list_ext(terminal *term,void *fn_,void *xxx)

{
  int iVar1;
  int *piVar2;
  string *psVar3;
  size_t len;
  uchar *src;
  uchar *rtext;
  int iVar4;
  uchar *in_EDX;
  int iVar5;
  char *pcVar6;
  char *pcVar7;
  bool bVar8;
  byte bVar9;
  string translated;
  menu_item *local_20 [4];
  
  bVar9 = 0;
  piVar2 = get_opt_(config_options,in_EDX);
  iVar1 = *piVar2;
  local_20[0] = (menu_item *)0x0;
  iVar5 = *(int *)(iVar1 + 4);
  bVar8 = iVar5 == iVar1;
  if (!bVar8) {
LAB_080b6874:
    do {
      iVar4 = 0xb;
      pcVar6 = *(char **)(iVar5 + 0xc);
      pcVar7 = "_template_";
      do {
        if (iVar4 == 0) break;
        iVar4 = iVar4 + -1;
        bVar8 = *pcVar6 == *pcVar7;
        pcVar6 = pcVar6 + (uint)bVar9 * -2 + 1;
        pcVar7 = pcVar7 + (uint)bVar9 * -2 + 1;
      } while (bVar8);
      if (!bVar8) {
        psVar3 = init_string(&translated);
        if (psVar3 != (string *)0x0) {
          src = *(uchar **)(iVar5 + 0xc);
          len = strlen((char *)src);
          psVar3 = add_string_replace(&translated,src,len,'*','.');
          if (psVar3 != (string *)0x0) {
            if ((local_20[0] == (menu_item *)0x0) &&
               (local_20[0] = new_menu(FREE_LIST|FREE_TEXT|FREE_RTEXT|FREE_DATA|NO_INTL),
               local_20[0] == (menu_item *)0x0)) {
              done_string(&translated);
              return;
            }
            src = memacpy(translated.source,translated.length);
            rtext = stracpy(*(uchar **)(iVar5 + 0x20));
            if (rtext == (uchar *)0x0) {
              if (src != (uchar *)0x0) {
                mem_free(src);
              }
            }
            else {
              if (src != (uchar *)0x0) {
                add_to_menu(local_20,translated.source,rtext,ACT_MAIN_NONE,(menu_func_T *)fn_,src,
                            NO_FLAG);
                goto LAB_080b6868;
              }
              mem_free(rtext);
            }
            done_string(&translated);
            iVar5 = *(int *)(iVar5 + 4);
            bVar8 = iVar5 == iVar1;
            if (bVar8) break;
            goto LAB_080b6874;
          }
        }
        done_string(&translated);
      }
LAB_080b6868:
      iVar5 = *(int *)(iVar5 + 4);
      bVar8 = iVar5 == iVar1;
    } while (!bVar8);
    if (local_20[0] != (menu_item *)0x0) goto LAB_080b6933;
  }
  local_20[0] = mi_no_ext;
LAB_080b6933:
  do_menu(term,local_20[0],(void *)0x0,0);
  return;
}



option_elinks * __regparm3 get_real_opt(uchar *base,uchar *id)

{
  option_elinks *tree;
  string *psVar1;
  size_t len;
  string translated;
  
  tree = get_opt_rec_real(config_options,base);
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(tree == (option_elinks *)0x0), tree == (option_elinks *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/mime/dialogs.c";
    errline = 0x1d;
    elinks_internal((uchar *)"assertion opt failed!");
  }
  psVar1 = init_string(&translated);
  if (psVar1 != (string *)0x0) {
    len = strlen((char *)id);
    psVar1 = add_string_replace(&translated,id,len,'.','*');
    if (psVar1 != (string *)0x0) {
      tree = get_opt_rec_real(tree,translated.source);
    }
  }
  done_string(&translated);
  return tree;
}



void really_del_ext(void *fcp)

{
  option_elinks *option_elinks;
  
  option_elinks = get_real_opt((uchar *)"mime.extension",(uchar *)fcp);
  if (option_elinks != (option_elinks *)0x0) {
    delete_option(option_elinks);
    return;
  }
  return;
}



void add_mime_extension(void *data)

{
  string *psVar1;
  size_t len;
  uchar **ppuVar2;
  option_elinks *option_elinks;
  uchar *name_00;
  string name;
  
  if (data != (void *)0x0) {
    psVar1 = init_string(&name);
    if (psVar1 != (string *)0x0) {
      add_to_string(&name,(uchar *)"mime.extension.");
      len = strlen((char *)(uchar *)((int)data + 0x400));
      add_string_replace(&name,(uchar *)((int)data + 0x400),len,'.','*');
      really_del_ext(data);
      ppuVar2 = (uchar **)get_opt_(config_options,name_00);
      safe_strncpy(*ppuVar2,(uchar *)((int)data + 0x800),0x400);
      option_elinks = get_opt_rec(config_options,name.source);
      option_changed((session *)0x0,option_elinks);
      done_string(&name);
    }
  }
  return;
}



void menu_del_ext(terminal *term,void *fcp,void *xxx2)

{
  option_elinks *poVar1;
  uchar *text;
  memory_list *ml;
  
  if (fcp != (void *)0x0) {
    poVar1 = get_real_opt((uchar *)"mime.extension",(uchar *)fcp);
    if (poVar1 == (option_elinks *)0x0) {
      mem_free(fcp);
      return;
    }
    text = msg_text(term,(uchar *)"Delete extension %s -> %s?",fcp,poVar1->value);
    ml = getml(fcp,0);
    msg_box(term,ml,MSGBOX_FREE_TEXT,(uchar *)"Delete extension",ALIGN_CENTER,text,fcp,2,
            &DAT_0812762b,really_del_ext,1,&DAT_08127627,0,2);
  }
  return;
}



void menu_add_ext(terminal *term,void *fcp,void *xxx2)

{
  dialog *dlg;
  byte *dst;
  option_elinks *poVar1;
  int cp_index;
  uchar *codeset;
  memory_list *ml;
  bool bVar2;
  
  dlg = (dialog *)mem_calloc(1,0xce4);
  if (dlg != (dialog *)0x0) {
    dst = dlg[2].widgets[0].info + 4;
    if (fcp != (void *)0x0) {
      poVar1 = get_real_opt((uchar *)"mime.extension",(uchar *)fcp);
      if (poVar1 != (option_elinks *)0x0) {
        safe_strncpy(dlg[0xe].widgets[0].info + 0x14,(uchar *)fcp,0x400);
        safe_strncpy((uchar *)&dlg[0x1b].udata2,(uchar *)poVar1->value,0x400);
        safe_strncpy(dst,(uchar *)fcp,0x400);
      }
      mem_free(fcp);
    }
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Extension");
    dlg->title = codeset;
    dlg->layouter = generic_dialog_layouter;
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Extension(s)");
    add_dlg_field_do(dlg,WIDGET_FIELD,codeset,0,0,check_nonempty,0x400,
                     dlg[0xe].widgets[0].info + 0x14,(input_history *)0x0,INPFIELD_NONE);
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Content-Type");
    add_dlg_field_do(dlg,WIDGET_FIELD,codeset,0,0,check_nonempty,0x400,&dlg[0x1b].udata2,
                     (input_history *)0x0,INPFIELD_NONE);
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext("~OK");
    add_dlg_button_do(dlg,codeset,1,ok_dialog,(void *)0x0,add_mime_extension,dst);
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"~Cancel");
    add_dlg_button_do(dlg,codeset,2,cancel_dialog,(void *)0x0,(done_handler_T *)0x0,(void *)0x0);
    if ((assert_failed == 0) &&
       (bVar2 = dlg->number_of_widgets != 4, assert_failed = ZEXT14(bVar2), bVar2)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/mime/dialogs.c";
      errline = 0x87;
      elinks_internal((uchar *)"assertion 4 == (dlg)->number_of_widgets failed!");
    }
    ml = getml(dlg,0);
    do_dialog(term,dlg,ml);
    return;
  }
  if (fcp == (void *)0x0) {
    return;
  }
  mem_free(fcp);
  return;
}



uchar * __regparm3 get_content_filename(uri *uri,cache_entry *cached)

{
  uchar *str;
  size_t __n;
  uchar *__src;
  uchar *local_10;
  
  if ((((cached == (cache_entry *)0x0) &&
       (cached = find_in_cache(uri), cached == (cache_entry *)0x0)) ||
      (cached->head == (uchar *)0x0)) ||
     (str = parse_header(cached->head,(uchar *)"Content-Disposition",(uchar **)0x0),
     str == (uchar *)0x0)) {
    str = (uchar *)0x0;
  }
  else {
    parse_header_param(str,(uchar *)"filename",&local_10);
    mem_free(str);
    str = local_10;
    if (local_10 != (uchar *)0x0) {
      if (*local_10 == '\"') {
        __n = strlen((char *)local_10);
        if ((1 < (int)__n) && (str[__n - 1] == '\"')) {
          str[__n - 1] = '\0';
          memmove(local_10,local_10 + 1,__n);
          str = local_10;
        }
        if (str[1] == '\0') {
          mem_free(str);
          return (uchar *)0x0;
        }
      }
      __src = get_filename_position(str);
      str = local_10;
      if (*__src == '\0') {
        str = (uchar *)0x0;
        mem_free(local_10);
      }
      else {
        if (local_10 < __src) {
          __n = strlen((char *)__src);
          memmove(str,__src,__n + 1);
          str = local_10;
        }
      }
    }
  }
  return str;
}



string * add_mime_filename_to_string(string *string,uri *uri)

{
  uchar *cmd;
  size_t cmdlen;
  bool bVar1;
  
  cmd = get_content_filename(uri,(cache_entry *)0x0);
  if ((assert_failed == 0) &&
     (bVar1 = uri->data == (uchar *)0x0, assert_failed = ZEXT14(bVar1), bVar1)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/mime/mime.c";
    errline = 0x14b;
    elinks_internal((uchar *)"assertion uri->data failed!");
  }
  if (cmd == (uchar *)0x0) {
    string = add_uri_to_string(string,uri,URI_FILENAME);
  }
  else {
    cmdlen = strlen((char *)cmd);
    add_shell_safe_to_string(string,cmd,cmdlen);
    mem_free(cmd);
  }
  return string;
}



mime_handler * __regparm1 get_mime_type_handler(uchar *content_type,int xwin)

{
  mime_handler *pmVar1;
  int in_stack_00000008;
  
  pmVar1 = get_mime_handler_backends((uchar *)xwin,in_stack_00000008);
  return pmVar1;
}



uchar * get_extension_content_type(uchar *extension)

{
  uchar *puVar1;
  stream_encoding encoding;
  char *__s2;
  uchar *ctype;
  mime_handler *p;
  uchar **ppuVar2;
  int iVar3;
  
  if (assert_failed == 0) {
    if ((extension != (uchar *)0x0) && (*extension != '\0')) {
      assert_failed = 0;
      puVar1 = get_content_type_backends(extension);
      goto joined_r0x080b7316;
    }
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/mime/mime.c";
    errline = 0xb3;
    elinks_internal((uchar *)"assertion extension && *extension failed!");
  }
  puVar1 = get_content_type_backends(extension);
joined_r0x080b7316:
  if (puVar1 == (uchar *)0x0) {
    encoding = guess_encoding(extension);
    __s2 = strrchr((char *)extension,0x2e);
    if (__s2 != (char *)0x0) {
      if (encoding != ENCODING_NONE) {
        ppuVar2 = listext_encoded(encoding);
        while( true ) {
          if ((ppuVar2 == (uchar **)0x0) || (*ppuVar2 == (uchar *)0x0)) goto LAB_080b73b1;
          iVar3 = strcmp((char *)*ppuVar2,__s2);
          if (iVar3 == 0) break;
          ppuVar2 = ppuVar2 + 1;
        }
        *__s2 = '\0';
        ctype = get_content_type_backends(extension);
        *__s2 = '.';
        if (ctype != (uchar *)0x0) {
          return ctype;
        }
LAB_080b73b1:
        __s2 = strrchr((char *)extension,0x2e);
      }
      if ((__s2 != (char *)0x0) &&
         (ctype = straconcat((uchar *)"application/x-",__s2 + 1,0), puVar1 = ctype,
         ctype != (uchar *)0x0)) {
        p = get_mime_handler_backends(ctype,1);
        if (p == (mime_handler *)0x0) {
          puVar1 = (uchar *)0x0;
          mem_free(ctype);
        }
        else {
          mem_free(p);
        }
      }
    }
  }
  return puVar1;
}



uchar * get_cache_header_content_type(cache_entry *cached)

{
  byte *pbVar1;
  uchar *extension;
  char *pcVar2;
  size_t sVar3;
  byte *pbVar4;
  byte *pbVar5;
  int iVar6;
  uchar *local_20;
  
  extension = parse_header(cached->head,(uchar *)"Content-Type",(uchar **)0x0);
  if (extension != (uchar *)0x0) {
    pcVar2 = strchr((char *)extension,0x3b);
    if (pcVar2 != (char *)0x0) {
      *pcVar2 = '\0';
    }
    sVar3 = strlen((char *)extension);
    if (sVar3 != 0) {
      iVar6 = sVar3 - 1;
      if (extension[iVar6] < 0x21) {
        pbVar1 = extension + (sVar3 - 2);
        pbVar5 = extension + iVar6;
        do {
          pbVar4 = pbVar1;
          *pbVar5 = 0;
          if (iVar6 == 0) break;
          iVar6 = iVar6 + -1;
          pbVar1 = pbVar4 + -1;
          pbVar5 = pbVar4;
        } while (*pbVar4 < 0x21);
      }
    }
    if (*extension != '\0') {
      return extension;
    }
    mem_free(extension);
  }
  extension = get_content_filename(cached->uri,cached);
  local_20 = (uchar *)0x0;
  if (extension != (uchar *)0x0) {
    local_20 = get_extension_content_type(extension);
    mem_free(extension);
  }
  return local_20;
}



uchar * get_content_type(cache_entry *cached)

{
  list_head_elinks *plVar1;
  uchar *p;
  uchar *extension;
  size_t sVar2;
  int iVar3;
  char *pcVar4;
  void *len;
  int iVar5;
  
  if (cached->content_type != (uchar *)0x0) {
    return cached->content_type;
  }
  if ((cached->head != (uchar *)0x0) &&
     (p = get_cache_header_content_type(cached), p != (uchar *)0x0)) {
    if (*p != '\0') goto LAB_080b75c3;
    mem_free(p);
  }
  extension = get_extension_from_uri(cached->uri);
  if (extension != (uchar *)0x0) {
    sVar2 = strlen((char *)extension);
    iVar5 = sVar2 - 1;
    if (-1 < iVar5) {
      p = extension + sVar2;
      do {
        while (iVar3 = c_isupper((uint)p[-1]), iVar3 == 0) {
          p = p + -1;
          iVar5 = iVar5 + -1;
          if (iVar5 < 0) goto LAB_080b7577;
        }
        iVar3 = c_tolower((uint)p[-1]);
        p[-1] = (uchar)iVar3;
        p = p + -1;
        iVar5 = iVar5 + -1;
      } while (-1 < iVar5);
    }
LAB_080b7577:
    p = get_extension_content_type(extension);
    mem_free(extension);
    if (p != (uchar *)0x0) {
      if (*p != '\0') goto LAB_080b75c3;
      mem_free(p);
    }
  }
  plVar1 = (list_head_elinks *)(cached->frag).next;
  if ((plVar1 != &cached->frag) && (((uint)plVar1[1].prev | (uint)plVar1[1].next) == 0)) {
    len = plVar1[2].next;
    if ((-1 < (int)plVar1[2].prev) && ((0 < (int)plVar1[2].prev || ((void *)0x400 < len)))) {
      len = (void *)0x400;
    }
    extension = memacpy((uchar *)(plVar1 + 4),(int)len);
    if (extension != (uchar *)0x0) {
      pcVar4 = c_strcasestr((char *)extension,"<html>");
      if (pcVar4 == (char *)0x0) {
        mem_free(extension);
      }
      else {
        p = stracpy((uchar *)"text/html");
        mem_free(extension);
        if ((p != (uchar *)0x0) && (*p != '\0')) goto LAB_080b75c3;
      }
    }
  }
  p = stracpy(mime_options[1].option_elinks.value);
LAB_080b75c3:
  cached->content_type = p;
  return p;
}



uchar * get_content_type_backends(uchar *extension)

{
  mime_backend *pmVar1;
  uchar *puVar2;
  int iVar3;
  
  pmVar1 = &default_mime_backend;
  iVar3 = 0;
  while ((pmVar1->get_content_type == (anon_subr_uchar_ptr_uchar_ptr_for_get_content_type *)0x0 ||
         (puVar2 = (*pmVar1->get_content_type)(extension), puVar2 == (uchar *)0x0))) {
    iVar3 = iVar3 + 1;
    pmVar1 = mime_backends[iVar3];
    if (pmVar1 == (mime_backend *)0x0) {
      return (uchar *)0x0;
    }
  }
  return puVar2;
}



mime_handler * get_mime_handler_backends(uchar *ctype,int have_x)

{
  mime_backend *pmVar1;
  mime_handler *pmVar2;
  int iVar3;
  
  pmVar1 = &default_mime_backend;
  iVar3 = 0;
  while ((pmVar1->get_mime_handler ==
          (anon_subr_mime_handler_ptr_uchar_ptr_int_for_get_mime_handler *)0x0 ||
         (pmVar2 = (*pmVar1->get_mime_handler)(ctype,have_x), pmVar2 == (mime_handler *)0x0))) {
    iVar3 = iVar3 + 1;
    pmVar1 = mime_backends[iVar3];
    if (pmVar1 == (mime_backend *)0x0) {
      return (mime_handler *)0x0;
    }
  }
  return pmVar2;
}



mime_handler *
init_mime_handler(uchar *program,uchar *description,uchar *backend_name,int ask,int block)

{
  size_t __n;
  mime_handler *pmVar1;
  
  __n = strlen((char *)program);
  pmVar1 = (mime_handler *)mem_calloc(1,__n + 0xc);
  if (pmVar1 != (mime_handler *)0x0) {
    memcpy(pmVar1->program,program,__n);
    if (description == (uchar *)0x0) {
      description = "";
    }
    pmVar1->description = description;
    pmVar1->backend_name = backend_name;
    *(byte *)&pmVar1->field_0x8 =
         *(byte *)&pmVar1->field_0x8 & 0xfc | ((byte)block & 1) * '\x02' | (byte)ask & 1;
  }
  return pmVar1;
}



uchar * get_next_path_filename(uchar **path_ptr,uchar separator)

{
  uchar *src;
  uchar *puVar1;
  uchar *local_30;
  
  src = *path_ptr;
  local_30 = (uchar *)0x0;
  puVar1 = src;
  if (*src == '\0') {
LAB_080b77cb:
    *path_ptr = puVar1;
  }
  else {
    if (*src != separator) {
      do {
        puVar1 = puVar1 + 1;
        if (*puVar1 == '\0') {
          local_30 = puVar1 + -(int)src;
          goto LAB_080b77cb;
        }
      } while (*puVar1 != separator);
      local_30 = puVar1 + -(int)src;
    }
    *path_ptr = puVar1 + 1;
  }
  if (((int)local_30 < 1) || (src = memacpy(src,(int)local_30), src == (uchar *)0x0)) {
    puVar1 = (uchar *)0x0;
  }
  else {
    puVar1 = expand_tilde(src);
    mem_free(src);
  }
  return puVar1;
}



mime_handler * get_mime_handler_default(uchar *type,int have_x)

{
  uchar *backend_name;
  option_elinks *tree;
  string *psVar1;
  size_t len;
  char *pcVar2;
  option_elinks *tree_00;
  uchar *name_00;
  option_elinks *tree_01;
  uchar **ppuVar3;
  mime_handler *pmVar4;
  uchar *name_01;
  uchar *name_02;
  string name;
  
  tree = get_opt_rec_real(config_options,(uchar *)"mime.type");
  if (tree != (option_elinks *)0x0) {
    psVar1 = init_string(&name);
    if (psVar1 != (string *)0x0) {
      len = strlen((char *)type);
      psVar1 = add_string_replace(&name,type,len,'.','*');
      if ((psVar1 == (string *)0x0) ||
         (pcVar2 = strchr((char *)name.source,0x2f), pcVar2 == (char *)0x0)) {
        done_string(&name);
        return (mime_handler *)0x0;
      }
      *pcVar2 = '.';
      tree = get_opt_rec_real(tree,name.source);
      done_string(&name);
      if (tree != (option_elinks *)0x0) {
        if (assert_failed == 0) {
          assert_failed = 0;
        }
        tree_00 = get_opt_rec_real(config_options,(uchar *)"mime.handler");
        if ((tree_00 != (option_elinks *)0x0) &&
           (tree_00 = get_opt_rec_real(tree_00,(uchar *)tree->value),
           tree_00 != (option_elinks *)0x0)) {
          name_00 = get_system_str(have_x);
          tree_00 = get_opt_rec_real(tree_00,name_00);
          if (tree_00 != (option_elinks *)0x0) {
            tree_01 = (option_elinks *)get_opt_(tree_00,name_01);
            tree_00 = tree_01->next;
            tree_01 = (option_elinks *)get_opt_(tree_01,(uchar *)tree_00);
            backend_name = default_mime_module.name;
            name_00 = (uchar *)tree->value;
            tree = tree_01->next;
            ppuVar3 = (uchar **)get_opt_(tree_01,name_02);
            pmVar4 = init_mime_handler(*ppuVar3,name_00,backend_name,(int)tree,(int)tree_00);
            return pmVar4;
          }
        }
      }
    }
  }
  return (mime_handler *)0x0;
}



uchar * get_content_type_default(uchar *extension)

{
  int *piVar1;
  uchar *__s;
  size_t sVar2;
  option_elinks *poVar3;
  int *piVar4;
  size_t sVar5;
  uchar *puVar6;
  uchar *puVar7;
  uchar uVar8;
  
  sVar2 = strlen((char *)extension);
  if (extension <= extension + (sVar2 - 1)) {
    poVar3 = get_opt_rec_real(config_options,(uchar *)"mime.extension");
    piVar1 = (int *)poVar3->value;
    piVar4 = piVar1;
    while (piVar4 = (int *)*piVar4, piVar4 != piVar1) {
      __s = (uchar *)piVar4[3];
      sVar5 = strlen((char *)__s);
      puVar7 = __s + (sVar5 - 1);
      puVar6 = extension + (sVar2 - 1);
      do {
        if (puVar7 < __s) goto LAB_080b7a5a;
        uVar8 = '.';
        if (*puVar7 != '*') {
          uVar8 = *puVar7;
        }
        if (*puVar6 != uVar8) break;
        puVar6 = puVar6 + -1;
        puVar7 = puVar7 + -1;
      } while (extension <= puVar6);
      if (puVar7 < __s) {
LAB_080b7a5a:
        if ((puVar6 < extension) || (*puVar6 == '.')) {
          puVar7 = stracpy((uchar *)piVar4[8]);
          return puVar7;
        }
      }
    }
  }
  return (uchar *)0x0;
}



void __regparm3 done_mailcap_entry(mailcap_entry *entry)

{
  if (entry != (mailcap_entry *)0x0) {
    if (entry->testcommand != (uchar *)0x0) {
      mem_free(entry->testcommand);
    }
    if (entry->description != (uchar *)0x0) {
      mem_free(entry->description);
    }
    mem_free(entry);
  }
  return;
}



void init_mailcap(module *module)

{
  change_hook_info mimetypes_change_hooks [2];
  int *piVar1;
  uchar *name;
  
  register_change_hooks((change_hook_info *)&ram0x0810c638);
  piVar1 = get_opt_(cmdline_options,name);
  if (*piVar1 != 0) {
    mailcap_options[1].option_elinks.value = 0;
  }
  return;
}



uchar * __regparm3 get_mailcap_field(uchar **next)

{
  ushort **ppuVar1;
  byte *pbVar2;
  size_t sVar3;
  byte bVar4;
  byte *pbVar5;
  byte *__s;
  
  __s = (byte *)0x0;
  if ((next != (uchar **)0x0) && (__s = *next, __s != (byte *)0x0)) {
    ppuVar1 = __ctype_b_loc();
    while (bVar4 = *__s, pbVar2 = __s, (*(byte *)((int)*ppuVar1 + (uint)bVar4 * 2 + 1) & 0x20) != 0)
    {
      __s = __s + 1;
    }
    while (pbVar2 = (byte *)strchr((char *)(pbVar2 + (bVar4 == 0x3b)),0x3b), pbVar2 != (byte *)0x0)
    {
      pbVar5 = pbVar2 + -1;
      if (pbVar2[-1] != 0x5c) {
        *pbVar2 = 0;
        *next = pbVar2 + 1;
        if ((*(byte *)((int)*ppuVar1 + (uint)pbVar2[1] * 2 + 1) & 0x20) != 0) {
          pbVar2 = pbVar2 + 2;
          do {
            *next = pbVar2;
            bVar4 = *pbVar2;
            pbVar2 = pbVar2 + 1;
          } while ((*(byte *)((int)*ppuVar1 + (uint)bVar4 * 2 + 1) & 0x20) != 0);
        }
        goto joined_r0x080b7bc6;
      }
      bVar4 = *pbVar2;
    }
    *next = (uchar *)0x0;
    sVar3 = strlen((char *)__s);
    pbVar5 = __s + (sVar3 - 1);
joined_r0x080b7bc6:
    while (__s <= pbVar5) {
      if ((*(byte *)((int)*ppuVar1 + (uint)*pbVar5 * 2 + 1) & 0x20) == 0) {
        return __s;
      }
      *pbVar5 = 0;
      pbVar5 = pbVar5 + -1;
    }
  }
  return __s;
}



uchar * __regparm3 get_mailcap_field_text(uchar *field)

{
  byte bVar1;
  ushort *puVar2;
  ushort **ppuVar3;
  byte *src;
  uchar *puVar4;
  
  ppuVar3 = __ctype_b_loc();
  puVar2 = *ppuVar3;
  while ((*(byte *)((int)puVar2 + (uint)*field * 2 + 1) & 0x20) != 0) {
    field = field + 1;
  }
  if (*field == 0x3d) {
    src = field + 1;
    bVar1 = *(byte *)((int)puVar2 + (uint)field[1] * 2 + 1);
    while ((bVar1 & 0x20) != 0) {
      src = src + 1;
      bVar1 = *(byte *)((int)puVar2 + (uint)*src * 2 + 1);
    }
    puVar4 = stracpy(src);
    return puVar4;
  }
  return (uchar *)0x0;
}



uchar * __regparm3 format_command(uchar *command,uchar *type,int copiousoutput)

{
  uint uVar1;
  uchar uVar2;
  string *psVar3;
  uint uVar4;
  uchar *puVar5;
  char *source;
  int iVar6;
  uint size;
  uchar *__src;
  uchar *puVar7;
  uchar *__n;
  bool bVar8;
  byte bVar9;
  string cmd;
  
  bVar9 = 0;
  psVar3 = init_string(&cmd);
  if (psVar3 == (string *)0x0) {
    return (uchar *)0x0;
  }
LAB_080b7ca8:
  uVar2 = *command;
  __src = command;
LAB_080b7cb0:
  if (uVar2 == '\0') goto LAB_080b7dc6;
  puVar7 = __src;
  if (uVar2 == '%') {
joined_r0x080b7e29:
    __src = puVar7;
    if (uVar2 != '\'') {
      if (uVar2 == '\\') goto LAB_080b7db8;
      if (uVar2 == '%') {
        uVar2 = __src[1];
        if (uVar2 == '\0') {
LAB_080b7f59:
          done_string(&cmd);
          return (uchar *)0x0;
        }
        if (uVar2 == 's') {
          add_char_to_string(&cmd,'%');
        }
        else {
          if (uVar2 == 't') {
            if (type == (uchar *)0x0) goto LAB_080b7f59;
            add_to_string(&cmd,type);
          }
        }
        uVar2 = __src[2];
        __src = __src + 2;
      }
      goto LAB_080b7cb0;
    }
  }
  else {
    if (uVar2 == '\\') goto LAB_080b7db8;
    if (uVar2 != '\'') {
      do {
        puVar7 = puVar7 + 1;
        uVar2 = *puVar7;
        if (((uVar2 == '%') || (uVar2 == '\0')) || (uVar2 == '\\')) break;
      } while (uVar2 != '\'');
      if (__src < puVar7) {
        if (assert_failed == 0) {
          __n = puVar7 + -(int)__src;
          if ((__src == (uchar *)0x0) || ((int)__n < 0)) {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
            errline = 0xff;
            elinks_internal((uchar *)
                            "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                           );
            if (assert_failed != 0) goto LAB_080b7e18;
          }
          else {
            assert_failed = 0;
          }
          if (__n != (uchar *)0x0) {
            __src = __n + cmd.length;
            uVar1 = cmd.length + 0xffU >> 8;
            uVar4 = cmd.length + 0xffU & 0xffffff00;
            size = (uint)(__src + 0x100) & 0xffffff00;
            if (uVar4 <= size && size + uVar1 * -0x100 != 0) {
              puVar5 = (uchar *)mem_realloc(cmd.source,size);
              if (puVar5 == (uchar *)0x0) {
                uVar2 = *puVar7;
                goto joined_r0x080b7e29;
              }
              cmd.source = puVar5;
              memset(puVar5 + uVar4,0,size + uVar1 * -0x100);
            }
            if (cmd.source != (uchar *)0x0) {
              memcpy(cmd.source + cmd.length,__src,(size_t)__n);
              cmd.source[(int)__src] = '\0';
              cmd.length = (int)__src;
            }
          }
          uVar2 = *puVar7;
        }
        else {
LAB_080b7e18:
          assert_failed = 0;
          uVar2 = *puVar7;
        }
      }
      goto joined_r0x080b7e29;
    }
  }
  __src = __src + 1;
  bVar8 = __src == (uchar *)0x0;
  iVar6 = 3;
  puVar7 = __src;
  __n = "%s\'";
  do {
    if (iVar6 == 0) break;
    iVar6 = iVar6 + -1;
    bVar8 = *puVar7 == *__n;
    puVar7 = puVar7 + (uint)bVar9 * -2 + 1;
    __n = __n + (uint)bVar9 * -2 + 1;
  } while (bVar8);
  if (bVar8) {
    add_char_to_string(&cmd,'%');
    uVar2 = __src[4];
    __src = __src + 4;
  }
  else {
    add_char_to_string(&cmd,'\'');
    uVar2 = *__src;
    __src = __src;
  }
  goto LAB_080b7cb0;
LAB_080b7db8:
  if (__src[1] == '\0') {
LAB_080b7dc6:
    if (copiousoutput == 0) {
      return cmd.source;
    }
    source = getenv("PAGER");
    if ((uchar *)source == (uchar *)0x0) {
      source = "/usr/bin/pager";
      iVar6 = file_exists((uchar *)"/usr/bin/pager");
      if (iVar6 == 0) {
        source = "/usr/bin/less";
        iVar6 = file_exists((uchar *)"/usr/bin/less");
        if (iVar6 == 0) {
          source = "/usr/bin/more";
          iVar6 = file_exists((uchar *)"/usr/bin/more");
          if (iVar6 == 0) {
            return cmd.source;
          }
        }
      }
    }
    add_char_to_string(&cmd,'|');
    add_to_string(&cmd,(uchar *)source);
    return cmd.source;
  }
  command = __src + 2;
  add_char_to_string(&cmd,__src[1]);
  goto LAB_080b7ca8;
}



mailcap_entry * __regparm3 check_entries(mailcap_hash_item *item)

{
  mailcap_entry *pmVar1;
  uchar *path;
  int iVar2;
  
  pmVar1 = (mailcap_entry *)(item->entries).next;
  while( true ) {
    if (pmVar1 == (mailcap_entry *)item) {
      return (mailcap_entry *)0x0;
    }
    if (pmVar1->testcommand == (uchar *)0x0) break;
    path = format_command(pmVar1->testcommand,(uchar *)0x0,0);
    if (path != (uchar *)0x0) {
      iVar2 = exe(path);
      mem_free(path);
      if (iVar2 == 0) {
        return pmVar1;
      }
    }
    pmVar1 = (mailcap_entry *)((list_head_elinks *)&pmVar1->next)->next;
  }
  return pmVar1;
}



void done_mailcap(module *module)

{
  int **p;
  int **p_00;
  hash *phVar1;
  hash *phVar2;
  list_head_elinks *plVar3;
  int local_24;
  
  if (mailcap_map == (hash *)0x0) {
    return;
  }
  if (0 < 1 << ((byte)mailcap_map->width & 0x1f)) {
    local_24 = 0;
    phVar1 = mailcap_map;
    phVar2 = mailcap_map;
    do {
      plVar3 = (list_head_elinks *)phVar2->hash[local_24].next;
      if (plVar3 != phVar2->hash + local_24) {
        do {
          p = (int **)plVar3[2].next;
          if (p != (int **)0x0) {
            while (p_00 = (int **)*p, p_00 != p) {
              *(int **)(*p_00 + 1) = p_00[1];
              *(int **)p_00[1] = *p_00;
              if (p_00[2] != (int *)0x0) {
                mem_free(p_00[2]);
              }
              if (p_00[3] != (int *)0x0) {
                mem_free(p_00[3]);
              }
              mem_free(p_00);
            }
            mem_free(p);
            phVar1 = mailcap_map;
          }
          plVar3 = (list_head_elinks *)plVar3->next;
          phVar2 = phVar1;
        } while (phVar1->hash + local_24 != plVar3);
      }
      local_24 = local_24 + 1;
    } while (local_24 < 1 << ((byte)phVar2->width & 0x1f));
  }
  free_hash(&mailcap_map);
  return;
}



int change_hook_mailcap(session *ses,option_elinks *current,option_elinks *changed)

{
  if (((option_info *)changed != mailcap_options + 2) &&
     (((option_info *)changed != mailcap_options + 1 ||
      (mailcap_options[1].option_elinks.value != 0)))) {
    return 0;
  }
  done_mailcap(&mailcap_mime_module);
  return 0;
}



// WARNING: Type propagation algorithm not settling

mime_handler * get_mime_handler_mailcap(uchar *type,int options)

{
  hash *hash;
  uchar uVar1;
  size_t __n;
  hash_item *phVar2;
  mailcap_entry *entry;
  uchar *key;
  mime_handler *pmVar3;
  char *pcVar4;
  FILE *file;
  uchar *key_00;
  uchar *fmt;
  int iVar5;
  uint keylen;
  mailcap_entry *pmVar6;
  void *value;
  uchar *puVar7;
  int in_GS_OFFSET;
  uint local_94;
  uchar *local_80;
  uchar *local_74;
  uchar *local_70;
  int local_6c;
  size_t local_68;
  uchar *local_64;
  uchar implicitwild [64];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if (mailcap_options[1].option_elinks.value != 0) {
    if (mailcap_map == (hash *)0x0) {
      mailcap_map = init_hash8();
      if (mailcap_map != (hash *)0x0) {
        local_64 = (char *)mailcap_options[2].option_elinks.value;
        if ((mailcap_options[2].option_elinks.value == (uchar *)0x0) ||
           (uVar1 = *mailcap_options[2].option_elinks.value, uVar1 == '\0')) {
          local_64 = getenv("MAILCAP");
          if ((uchar *)local_64 == (uchar *)0x0) {
            local_64 = 
            "~/.mailcap:/etc/mailcap:/usr/local/etc/mailcap:/usr/share/mailcap:/usr/share/misc/mailcap"
            ;
            uVar1 = '~';
          }
          else {
            uVar1 = *local_64;
          }
        }
        local_94 = 0;
        while (uVar1 != '\0') {
          key = get_next_path_filename(&local_64,':');
          if (key != (uchar *)0x0) {
            file = (FILE *)fopen64((char *)key,"rb");
            local_68 = 0x400;
            local_6c = 1;
            if (file != (FILE *)0x0) {
              local_80 = (uchar *)0x0;
LAB_080b8320:
              local_80 = file_read_line(local_80,&local_68,file,&local_6c);
              if (local_80 != (uchar *)0x0) {
                if (((*local_80 != '#') &&
                    (local_70 = local_80, key_00 = get_mailcap_field(&local_70),
                    key_00 != (uchar *)0x0)) &&
                   (fmt = get_mailcap_field(&local_70), fmt != (uchar *)0x0)) {
                  __n = strlen((char *)fmt);
                  entry = (mailcap_entry *)mem_calloc(1,__n + 0x18);
                  if (entry != (mailcap_entry *)0x0) {
                    memcpy(entry->command,fmt,__n);
                    entry->priority = local_94;
                    local_74 = local_70;
LAB_080b83d0:
                    fmt = get_mailcap_field(&local_74);
                    do {
                      if (fmt == (uchar *)0x0) {
                        pcVar4 = strchr((char *)key_00,0x2f);
                        __n = strlen((char *)key_00);
                        if (pcVar4 == (char *)0x0) {
                          keylen = __n + 3;
                          if (keylen < 0x41) {
                            __memcpy_chk(implicitwild,key_00,__n,0x40);
                            implicitwild[__n] = '/';
                            implicitwild[__n + 1] = '*';
                            implicitwild[__n + 2] = '\0';
                            phVar2 = get_hash_item(mailcap_map,implicitwild,keylen);
                            if (phVar2 != (hash_item *)0x0) goto LAB_080b8464;
                            value = mem_alloc(__n + 0xf);
                            if (value == (void *)0x0) goto LAB_080b886a;
                            safe_strncpy((uchar *)((int)value + 8),implicitwild,__n + 4);
                            *(void **)((int)value + 4) = value;
                            *(void **)value = value;
                            phVar2 = add_hash_item(mailcap_map,(uchar *)((int)value + 8),keylen,
                                                   value);
                            if (phVar2 == (hash_item *)0x0) {
                              mem_free(value);
                              done_mailcap_entry(entry);
                            }
                            else {
LAB_080b846f:
                              entry->next = *(mailcap_entry **)*(int *)((int)value + 4);
                              entry->prev = *(mailcap_entry **)((int)value + 4);
                              (*(mailcap_entry **)((int)value + 4))->next = entry;
                              entry->next->prev = entry;
                            }
                          }
                          else {
                            if (entry->testcommand != (uchar *)0x0) {
                              mem_free(entry->testcommand);
                            }
                            if (entry->description != (uchar *)0x0) {
                              mem_free(entry->description);
                            }
                            mem_free(entry);
                          }
                        }
                        else {
                          phVar2 = get_hash_item(mailcap_map,key_00,__n);
                          if (phVar2 == (hash_item *)0x0) {
                            value = mem_alloc(__n + 0xc);
                            if (value != (void *)0x0) {
                              safe_strncpy((uchar *)((int)value + 8),key_00,__n + 1);
                              *(void **)((int)value + 4) = value;
                              *(void **)value = value;
                              phVar2 = add_hash_item(mailcap_map,(uchar *)((int)value + 8),__n,value
                                                    );
                              if (phVar2 != (hash_item *)0x0) goto LAB_080b846f;
                              mem_free(value);
                            }
                          }
                          else {
LAB_080b8464:
                            value = phVar2->value;
                            if (value != (void *)0x0) goto LAB_080b846f;
                          }
LAB_080b886a:
                          done_mailcap_entry(entry);
                        }
                        break;
                      }
                      iVar5 = c_strncasecmp((char *)fmt,"needsterminal",0xd);
                      if (iVar5 != 0) goto LAB_080b8490;
                      *(byte *)&entry->field_0x14 = *(byte *)&entry->field_0x14 | 1;
                      fmt = get_mailcap_field(&local_74);
                    } while( true );
                  }
                }
                goto LAB_080b8320;
              }
              fclose((FILE *)file);
            }
            local_94 = local_94 + 1;
            mem_free(key);
          }
          uVar1 = *local_64;
        }
        if (mailcap_map != (hash *)0x0) goto LAB_080b818d;
      }
    }
    else {
LAB_080b818d:
      hash = mailcap_map;
      __n = strlen((char *)type);
      phVar2 = get_hash_item(hash,type,__n);
      if ((phVar2 == (hash_item *)0x0) ||
         ((mailcap_hash_item *)phVar2->value == (mailcap_hash_item *)0x0)) {
        entry = (mailcap_entry *)0x0;
LAB_080b823a:
        pcVar4 = strchr((char *)type,0x2f);
        if (pcVar4 != (char *)0x0) {
          pcVar4 = pcVar4 + -(int)type;
          key = memacpy(type,(int)(pcVar4 + 3));
          if (key == (uchar *)0x0) goto LAB_080b8260;
          key[(int)(pcVar4 + 1)] = '*';
          (pcVar4 + 2)[(int)key] = '\0';
          phVar2 = get_hash_item(mailcap_map,key,(uint)(pcVar4 + 2));
          mem_free(key);
          if (((phVar2 != (hash_item *)0x0) &&
              ((mailcap_hash_item *)phVar2->value != (mailcap_hash_item *)0x0)) &&
             (pmVar6 = check_entries((mailcap_hash_item *)phVar2->value),
             pmVar6 != (mailcap_entry *)0x0)) {
            if ((entry == (mailcap_entry *)0x0) || (pmVar6->priority < entry->priority)) {
              entry = pmVar6;
            }
            goto LAB_080b81d5;
          }
        }
        if (entry == (mailcap_entry *)0x0) goto LAB_080b8260;
      }
      else {
        entry = check_entries((mailcap_hash_item *)phVar2->value);
        if ((entry == (mailcap_entry *)0x0) || (mailcap_options[5].option_elinks.value != 0))
        goto LAB_080b823a;
      }
LAB_080b81d5:
      key = format_command(entry->command,type,(uint)(*(byte *)&entry->field_0x14 >> 1) & 1);
      if (key != (uchar *)0x0) {
        pmVar3 = init_mime_handler(key,entry->description,mailcap_mime_module.name,
                                   mailcap_options[3].option_elinks.value,
                                   (uint)((*(byte *)&entry->field_0x14 & 3) != 0));
        mem_free(key);
        goto LAB_080b8262;
      }
    }
  }
LAB_080b8260:
  pmVar3 = (mime_handler *)0x0;
LAB_080b8262:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pmVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_080b8490:
  iVar5 = c_strncasecmp((char *)fmt,"copiousoutput",0xd);
  if (iVar5 == 0) {
    *(byte *)&entry->field_0x14 = *(byte *)&entry->field_0x14 | 2;
    goto LAB_080b83d0;
  }
  iVar5 = c_strncasecmp((char *)fmt,"test",4);
  if (iVar5 == 0) {
    fmt = get_mailcap_field_text(fmt + 4);
    entry->testcommand = fmt;
    if (fmt == (uchar *)0x0) goto LAB_080b852a;
    uVar1 = *fmt;
    puVar7 = fmt;
    while (uVar1 != '\0') {
      puVar7 = puVar7 + 1;
      if (uVar1 == '%') {
        uVar1 = *puVar7;
        if (uVar1 == 's') {
          mem_free(fmt);
          goto LAB_080b851b;
        }
      }
      else {
        uVar1 = *puVar7;
      }
    }
    goto LAB_080b83d0;
  }
  iVar5 = c_strncasecmp((char *)fmt,"description",0xb);
  if (iVar5 != 0) goto LAB_080b83d0;
  fmt = get_mailcap_field_text(fmt + 0xb);
  entry->description = fmt;
  if (fmt == (uchar *)0x0) goto LAB_080b851b;
  goto LAB_080b83d0;
LAB_080b851b:
  if (entry->testcommand != (uchar *)0x0) {
    mem_free(entry->testcommand);
  }
LAB_080b852a:
  if (entry->description != (uchar *)0x0) {
    mem_free(entry->description);
  }
  mem_free(entry);
  iVar5 = local_6c;
  fmt = gettext((uchar *)"Badly formated mailcap entry for type %s in \"%s\" line %d");
  usrerror(fmt,key_00,key,iVar5);
  goto LAB_080b8320;
}



void __regparm3 done_mimetypes_entry(mimetypes_entry *entry)

{
  if (entry != (mimetypes_entry *)0x0) {
    if (entry->content_type != (uchar *)0x0) {
      mem_free(entry->content_type);
    }
    mem_free(entry);
  }
  return;
}



void done_mimetypes(module *module)

{
  hash *phVar1;
  hash *phVar2;
  list_head_elinks *plVar3;
  int iVar4;
  
  if (mimetypes_map == (hash *)0x0) {
    return;
  }
  if (0 < 1 << ((byte)mimetypes_map->width & 0x1f)) {
    iVar4 = 0;
    phVar1 = mimetypes_map;
    phVar2 = mimetypes_map;
    do {
      plVar3 = (list_head_elinks *)phVar1->hash[iVar4].next;
      if (plVar3 != phVar1->hash + iVar4) {
        do {
          phVar1 = phVar2;
          if ((mimetypes_entry *)plVar3[2].next != (mimetypes_entry *)0x0) {
            done_mimetypes_entry((mimetypes_entry *)plVar3[2].next);
            phVar1 = mimetypes_map;
          }
          plVar3 = (list_head_elinks *)plVar3->next;
          phVar2 = phVar1;
        } while (phVar1->hash + iVar4 != plVar3);
      }
      iVar4 = iVar4 + 1;
    } while (iVar4 < 1 << ((byte)phVar1->width & 0x1f));
  }
  free_hash(&mimetypes_map);
  return;
}



int change_hook_mimetypes(session *ses,option_elinks *current,option_elinks *changed)

{
  if (((option_info *)changed != mimetypes_options + 2) &&
     (((option_info *)changed != mimetypes_options + 1 ||
      (mimetypes_options[1].option_elinks.value != 0)))) {
    return 0;
  }
  done_mimetypes(&mimetypes_mime_module);
  return 0;
}



void init_mimetypes(module *module)

{
  change_hook_info mimetypes_change_hooks [2];
  int *piVar1;
  uchar *name;
  
  register_change_hooks((change_hook_info *)&ram0x0810c650);
  piVar1 = get_opt_(cmdline_options,name);
  if (*piVar1 != 0) {
    mimetypes_options[1].option_elinks.value = 0;
  }
  return;
}



void __regparm3 parse_mimetypes_file(uchar *filename)

{
  ushort *puVar1;
  FILE *__stream;
  char *pcVar2;
  ushort **ppuVar3;
  size_t len;
  size_t keylen;
  hash_item *phVar4;
  mimetypes_entry *entry;
  uchar *puVar5;
  byte *key;
  byte *pbVar6;
  byte *src;
  int in_GS_OFFSET;
  uchar line [1024];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  __stream = fopen64((char *)filename,"rb");
  if (__stream != (FILE *)0x0) {
LAB_080b8a18:
    pcVar2 = fgets((char *)line,0x3ff,__stream);
    if (pcVar2 != (char *)0x0) {
      pcVar2 = strchr((char *)line,0x23);
      if (pcVar2 != (char *)0x0) {
        *pcVar2 = '\0';
      }
      ppuVar3 = __ctype_b_loc();
      src = line;
      while ((*(byte *)((int)*ppuVar3 + (uint)*src * 2 + 1) & 0x20) != 0) {
        src = src + 1;
      }
      key = src;
      if (*src != 0) {
        do {
          key = key;
          key = key + 1;
          if (*key == 0) goto LAB_080b8a18;
        } while ((*(byte *)((int)*ppuVar3 + (uint)*key * 2 + 1) & 0x20) == 0);
        *key = 0;
        pcVar2 = strchr((char *)src,0x2f);
        if (pcVar2 != (char *)0x0) {
          len = strlen((char *)src);
LAB_080b8ae0:
          key = key + 2;
          if (*key != 0) {
            puVar1 = *ppuVar3;
            pbVar6 = key;
            if ((*(byte *)((int)puVar1 + (uint)*key * 2 + 1) & 0x20) != 0) {
              do {
                key = key + 1;
              } while ((*(byte *)((int)puVar1 + (uint)*key * 2 + 1) & 0x20) != 0);
              pbVar6 = key;
              if (*key == 0) goto LAB_080b8a18;
            }
            do {
              key = pbVar6;
              pbVar6 = key + 1;
              if (*pbVar6 == 0) goto LAB_080b8a18;
            } while ((*(byte *)((int)puVar1 + (uint)*pbVar6 * 2 + 1) & 0x20) == 0);
            *pbVar6 = 0;
            keylen = strlen((char *)key);
            phVar4 = get_hash_item(mimetypes_map,key,keylen);
            if ((phVar4 == (hash_item *)0x0) &&
               (entry = (mimetypes_entry *)mem_calloc(1,keylen + 8), entry != (mimetypes_entry *)0x0
               )) {
              puVar5 = memacpy(src,len);
              entry->content_type = puVar5;
              if (puVar5 != (uchar *)0x0) {
                memcpy(entry->extension,key,keylen);
                phVar4 = add_hash_item(mimetypes_map,entry->extension,keylen,entry);
                if (phVar4 != (hash_item *)0x0) goto LAB_080b8ae0;
              }
              done_mimetypes_entry(entry);
            }
            goto LAB_080b8ae0;
          }
        }
      }
      goto LAB_080b8a18;
    }
    fclose(__stream);
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



uchar * get_content_type_mimetypes(uchar *extension)

{
  uchar uVar1;
  size_t keylen;
  char *pcVar2;
  hash_item *phVar3;
  uchar *filename;
  uchar *local_10;
  
  if (mimetypes_options[1].option_elinks.value == 0) {
    return (uchar *)0x0;
  }
  if (mimetypes_map == (hash *)0x0) {
    mimetypes_map = init_hash8();
    if (mimetypes_map == (hash *)0x0) {
      return (uchar *)0x0;
    }
    local_10 = (char *)mimetypes_options[2].option_elinks.value;
    if ((mimetypes_options[2].option_elinks.value != (uchar *)0x0) &&
       (*mimetypes_options[2].option_elinks.value != '\0')) goto LAB_080b8d10;
    local_10 = 
    "~/.mime.types:/etc/mime.types:/usr/local/etc/mime.types:/usr/share/mime.types:/usr/share/misc/mime.types"
    ;
    uVar1 = '~';
    while (uVar1 != '\0') {
LAB_080b8d10:
      filename = get_next_path_filename(&local_10,':');
      if (filename != (uchar *)0x0) {
        parse_mimetypes_file(filename);
        mem_free(filename);
      }
      uVar1 = *local_10;
    }
    if (mimetypes_map == (hash *)0x0) {
      return (uchar *)0x0;
    }
  }
  extension = extension + 1;
  keylen = strlen((char *)extension);
  if (keylen != 0) {
    while( true ) {
      phVar3 = get_hash_item(mimetypes_map,extension,keylen);
      if ((phVar3 != (hash_item *)0x0) && ((uchar **)phVar3->value != (uchar **)0x0)) {
        filename = stracpy(*(uchar **)phVar3->value);
        return filename;
      }
      pcVar2 = strchr((char *)extension,0x2e);
      if ((pcVar2 == (char *)0x0) ||
         (keylen = keylen + ~(uint)(pcVar2 + -(int)extension), keylen == 0)) break;
      extension = (uchar *)(pcVar2 + 1);
    }
  }
  return (uchar *)0x0;
}



int get_connections_count(void)

{
  list_head_elinks **pplVar1;
  int iVar2;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)connection_queue.next;
  if ((list_head_elinks *)connection_queue.next != &connection_queue) {
    do {
      pplVar1 = (list_head_elinks **)&plVar3->next;
      iVar2 = iVar2 + 1;
      plVar3 = *pplVar1;
    } while (*pplVar1 != &connection_queue);
  }
  return iVar2;
}



int get_keepalive_connections_count(void)

{
  list_head_elinks **pplVar1;
  int iVar2;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)keepalive_connections.next;
  if ((list_head_elinks *)keepalive_connections.next != &keepalive_connections) {
    do {
      pplVar1 = (list_head_elinks **)&plVar3->next;
      iVar2 = iVar2 + 1;
      plVar3 = *pplVar1;
    } while (*pplVar1 != &keepalive_connections);
  }
  return iVar2;
}



int get_connections_connecting_count(void)

{
  list_head_elinks **pplVar1;
  int iVar2;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)connection_queue.next;
  if ((list_head_elinks *)connection_queue.next != &connection_queue) {
    do {
      pplVar1 = (list_head_elinks **)&plVar3->next;
      iVar2 = iVar2 + (uint)((int)plVar3[10].next - 1U < 7);
      plVar3 = *pplVar1;
    } while (*pplVar1 != &connection_queue);
  }
  return iVar2;
}



int get_connections_transfering_count(void)

{
  list_head_elinks **pplVar1;
  int iVar2;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)connection_queue.next;
  if ((list_head_elinks *)connection_queue.next != &connection_queue) {
    do {
      pplVar1 = (list_head_elinks **)&plVar3->next;
      iVar2 = iVar2 + (uint)(7 < (int)plVar3[10].next);
      plVar3 = *pplVar1;
    } while (*pplVar1 != &connection_queue);
  }
  return iVar2;
}



void __regparm3 notify_connection_callbacks(connection *conn)

{
  connection_basic_state cVar1;
  uint uVar2;
  list_head_elinks *plVar3;
  list_head_elinks *plVar4;
  list_head_elinks *plVar5;
  connection *pcVar6;
  
  cVar1 = (conn->state).basic;
  uVar2 = conn->id;
  plVar4 = (list_head_elinks *)(conn->downloads).next;
  plVar5 = (list_head_elinks *)plVar4->next;
  do {
    plVar3 = plVar5;
    if (plVar4 == &conn->downloads) {
      return;
    }
    *(cache_entry **)&plVar4[1].prev = conn->cached;
    if ((code *)plVar4[2].next != (code *)0x0) {
      (*(code *)plVar4[2].next)(plVar4,plVar4[2].prev);
    }
    if (-1 < cVar1) {
      pcVar6 = (connection *)connection_queue.next;
      if ((list_head_elinks *)connection_queue.next == &connection_queue) {
        return;
      }
      while ((conn != pcVar6 || (uVar2 != conn->id))) {
        pcVar6 = pcVar6->next;
        if (pcVar6 == (connection *)&connection_queue) {
          return;
        }
      }
    }
    plVar5 = (list_head_elinks *)plVar3->next;
    plVar4 = plVar3;
  } while( true );
}



int is_entry_used(cache_entry *cached)

{
  list_head_elinks *plVar1;
  
  plVar1 = (list_head_elinks *)connection_queue.next;
  if ((list_head_elinks *)connection_queue.next != &connection_queue) {
    do {
      if ((cache_entry *)plVar1[4].prev == cached) {
        return 1;
      }
      plVar1 = (list_head_elinks *)plVar1->next;
    } while (plVar1 != &connection_queue);
  }
  return 0;
}



connection_priority __regparm3 get_priority(connection *conn)

{
  int iVar1;
  connection_priority cVar2;
  
  iVar1 = 0;
  cVar2 = PRI_MAIN;
  do {
    if (conn->pri[cVar2] != 0) break;
    iVar1 = iVar1 + 1;
    cVar2 = cVar2 + PRI_FRAME;
  } while (iVar1 != 7);
  if ((assert_failed == 0) && (assert_failed = ZEXT14(cVar2 == PRIORITIES), cVar2 == PRIORITIES)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x4f;
    elinks_internal((uchar *)"assertion priority != PRIORITIES failed: Connection has no owner");
    return PRIORITIES;
  }
  return cVar2;
}



void __regparm3 add_to_queue(connection *conn)

{
  connection_priority cVar1;
  connection_priority cVar2;
  connection *conn_00;
  
  cVar1 = get_priority(conn);
  conn_00 = (connection *)connection_queue.next;
  if ((list_head_elinks *)connection_queue.next != &connection_queue) {
    do {
      cVar2 = get_priority(conn_00);
      if (cVar1 < cVar2) break;
      conn_00 = conn_00->next;
    } while (conn_00 != (connection *)&connection_queue);
  }
  conn->next = conn_00->prev->next;
  conn->prev = conn_00->prev;
  conn_00->prev->next = conn;
  conn->next->prev = conn;
  return;
}



void sort_queue(void)

{
  connection *pcVar1;
  bool bVar2;
  connection_priority conn;
  connection_priority cVar3;
  connection *conn_00;
  
  while( true ) {
    if ((list_head_elinks *)connection_queue.next == &connection_queue) {
      return;
    }
    conn = *(connection **)connection_queue.next;
    if (conn == (connection *)&connection_queue) break;
    bVar2 = false;
    conn_00 = (connection *)connection_queue.next;
    do {
      conn = get_priority(conn);
      cVar3 = get_priority(conn_00);
      if (conn < cVar3) {
        conn = conn_00->next;
        bVar2 = true;
        conn->prev = conn_00->prev;
        conn_00->prev->next = conn_00->next;
        pcVar1 = conn->next;
        conn_00->prev = conn;
        conn_00->next = pcVar1;
        conn->next = conn_00;
        conn_00->next->prev = conn_00;
      }
      conn_00 = conn_00->next;
    } while ((conn_00 != (connection *)&connection_queue) &&
            (conn = conn_00->next, conn != (connection *)&connection_queue));
    if (!bVar2) {
      return;
    }
  }
  return;
}



connection_state connection_state(void)

{
  int *in_EAX;
  int in_EDX;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(in_EDX == -1);
    if (in_EDX == -1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
      errline = 0x84;
      elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
      if (assert_failed != 0) goto LAB_080b90b8;
    }
    in_EAX[1] = 0;
    *in_EAX = in_EDX;
    return (connection_state)CONCAT44(in_EDX,in_EAX);
  }
LAB_080b90b8:
  assert_failed = 0;
  in_EAX[1] = 0;
  *in_EAX = -0x186a3;
  return (connection_state)CONCAT44(0xfffe795d,in_EAX);
}



connection * __regparm3
init_connection(uri *uri,uri *proxied_uri,uri *referrer,off_t start,cache_mode cache_mode,
               connection_priority priority)

{
  socket_operations connection_socket_operations;
  connection *conn;
  socket *psVar1;
  progress *ppVar2;
  connection *pcVar3;
  bool bVar4;
  
  conn = (connection *)mem_calloc(1,0x9c);
  pcVar3 = conn;
  if (conn != (connection *)0x0) {
    if ((assert_failed == 0) &&
       (bVar4 = proxied_uri->protocol == 0xf, assert_failed = ZEXT14(bVar4), bVar4)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
      errline = 0x117;
      elinks_internal((uchar *)"assertion proxied_uri->protocol != PROTOCOL_PROXY failed!");
    }
    psVar1 = init_socket(conn,(socket_operations *)&ram0x08145df0);
    conn->socket = psVar1;
    if (psVar1 != (socket *)0x0) {
      psVar1 = init_socket(conn,(socket_operations *)0x8145df0);
      conn->data_socket = psVar1;
      if (psVar1 != (socket *)0x0) {
        ppVar2 = init_progress(start);
        conn->progress = ppVar2;
        if (ppVar2 == (progress *)0x0) {
          mem_free(conn->data_socket);
          mem_free(conn->socket);
          mem_free(conn);
          return (connection *)0x0;
        }
        conn->proxied_uri = proxied_uri;
        conn->uri = uri;
        conn->id = connection_id;
        connection_id = connection_id + 1;
        conn->pri[priority] = 1;
        conn->content_encoding = ENCODING_NONE;
        conn->stream_pipes[1] = -1;
        conn->stream_pipes[0] = -1;
        conn->cache_mode = cache_mode;
        *(list_head_elinks **)&(conn->downloads).prev = &conn->downloads;
        *(list_head_elinks **)&(conn->downloads).next = &conn->downloads;
        *(undefined4 *)&conn->est_length = 0xffffffff;
        *(undefined4 *)((int)&conn->est_length + 4) = 0xffffffff;
        conn->timer = (timer_id_T)0x0;
        if (referrer == (uri *)0x0) {
          return conn;
        }
        if ((referrer->protocol == 4) && (uri->protocol != 4)) {
          return conn;
        }
        (referrer->object).refcount = (referrer->object).refcount + 1;
        conn->referrer = referrer;
        return conn;
      }
      mem_free(conn->socket);
    }
    pcVar3 = (connection *)0x0;
    mem_free(conn);
  }
  return pcVar3;
}



host_connection * __regparm3 get_host_connection(connection *conn)

{
  uri *b;
  int iVar1;
  host_connection *phVar2;
  
  b = conn->uri;
  if ((b->host == (uchar *)0x0) ||
     (phVar2 = (host_connection *)host_connections.next,
     (list_head_elinks *)host_connections.next == &host_connections)) {
LAB_080b92a4:
    phVar2 = (host_connection *)0x0;
  }
  else {
    while (iVar1 = compare_uri(phVar2->uri,b,URI_HOST), iVar1 == 0) {
      phVar2 = phVar2->next;
      if (phVar2 == (host_connection *)&host_connections) goto LAB_080b92a4;
      b = conn->uri;
    }
  }
  return phVar2;
}



int __regparm3 add_host_connection(connection *conn)

{
  object *poVar1;
  uri *puVar2;
  host_connection *phVar3;
  
  phVar3 = get_host_connection(conn);
  if (phVar3 == (host_connection *)0x0) {
    if (conn->uri->host == (uchar *)0x0) {
      return 1;
    }
    phVar3 = (host_connection *)mem_calloc(1,0x10);
    if (phVar3 == (host_connection *)0x0) {
      return 0;
    }
    puVar2 = conn->uri;
    poVar1 = &puVar2->object;
    poVar1->refcount = poVar1->refcount + 1;
    phVar3->uri = puVar2;
    *(list_head_elinks **)&phVar3->prev = &host_connections;
    phVar3->next = host_connections.next;
    host_connections.next = phVar3;
    phVar3->next->prev = phVar3;
  }
  (phVar3->object).refcount = (phVar3->object).refcount + 1;
  return 1;
}



void set_connection_timeout(connection *conn)

{
  int iVar1;
  int *piVar2;
  uchar *name;
  
  kill_timer(&conn->timer);
  if ((*(byte *)&conn->field_0x78 & 2) == 0) {
    piVar2 = get_opt_(config_options,name);
    iVar1 = *piVar2;
  }
  else {
    piVar2 = get_opt_(config_options,name);
    iVar1 = *piVar2;
  }
  install_timer(&conn->timer,iVar1 * 500,connection_timeout_1,conn);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void set_connection_socket_timeout(socket *socket,connection_state state)

{
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(socket == (socket *)0x0), socket == (socket *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0xf6;
    elinks_internal((uchar *)"assertion socket failed!");
    set_connection_timeout(_DAT_00000008);
    return;
  }
  set_connection_timeout((connection *)socket->conn);
  return;
}



void connection_timeout_1(connection *conn)

{
  int iVar1;
  int *piVar2;
  uchar *in_EDX;
  
  if ((*(byte *)&conn->field_0x78 & 2) == 0) {
    piVar2 = get_opt_(config_options,in_EDX);
    iVar1 = *piVar2;
  }
  else {
    piVar2 = get_opt_(config_options,in_EDX);
    iVar1 = *piVar2;
  }
  install_timer(&conn->timer,iVar1 * 500,connection_timeout,conn);
  return;
}



void connection_timeout(connection *conn)

{
  conn->timer = (timer_id_T)0x0;
  timeout_socket(conn->socket);
  return;
}



void detach_connection(download *download,off_t pos)

{
  byte *pbVar1;
  connection *pcVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int *piVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  int iVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  bool bVar15;
  char *local_38;
  
  pcVar2 = download->conn;
  if (-1 < (download->state).basic) {
    if ((*(byte *)&pcVar2->field_0x78 & 4) != 0) {
LAB_080b9625:
      free_entry_to(pcVar2->cached,pos);
      return;
    }
    if (pcVar2->cached != (cache_entry *)0x0) {
      uVar14 = *(uint *)&pcVar2->est_length;
      uVar12 = *(uint *)((int)&pcVar2->est_length + 4);
      if ((uVar14 & uVar12) == 0xffffffff) {
        uVar14 = *(uint *)&pcVar2->from;
        uVar12 = *(uint *)((int)&pcVar2->from + 4);
      }
      local_38 = "document.cache.memory.size";
      piVar7 = get_opt_(config_options,(uchar *)pos);
      uVar3 = (*piVar7 * 0x19) / 100;
      iVar11 = (int)uVar3 >> 0x1f;
      if ((iVar11 <= (int)uVar12) && ((iVar11 < (int)uVar12 || (uVar3 <= uVar14)))) {
        uVar14 = pcVar2->pri[1];
        uVar12 = pcVar2->pri[0];
        uVar3 = pcVar2->pri[2];
        uVar8 = uVar12 + uVar14 + uVar3;
        uVar4 = pcVar2->pri[3];
        uVar9 = uVar8 + uVar4;
        uVar5 = pcVar2->pri[4];
        uVar10 = uVar9 + uVar5;
        uVar6 = pcVar2->pri[5];
        uVar13 = uVar6 + uVar10;
        uVar14 = ((int)uVar6 >> 0x1f) +
                 ((int)uVar12 >> 0x1f) + ((int)uVar14 >> 0x1f) + (uint)CARRY4(uVar12,uVar14) +
                 ((int)uVar3 >> 0x1f) + (uint)CARRY4(uVar12 + uVar14,uVar3) + ((int)uVar4 >> 0x1f) +
                 (uint)CARRY4(uVar8,uVar4) + ((int)uVar5 >> 0x1f) + (uint)CARRY4(uVar9,uVar5) +
                 (uint)CARRY4(uVar6,uVar10);
        if ((assert_failed == 0) &&
           (bVar15 = (uVar13 | uVar14) == 0, assert_failed = ZEXT14(bVar15), bVar15)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
          errline = 0x459;
          elinks_internal((uchar *)"assertion total_pri failed: detaching free connection",local_38)
          ;
        }
        shrink_format_cache(0);
        if (((uVar13 ^ 1 | uVar14) == 0) && ((pcVar2->cached->object).refcount == 0)) {
          pbVar1 = (byte *)&pcVar2->cached->field_0x5c;
          *pbVar1 = *pbVar1 & 0xef;
          *(byte *)&pcVar2->field_0x78 = *(byte *)&pcVar2->field_0x78 | 4;
          goto LAB_080b9625;
        }
      }
    }
  }
  return;
}



int register_check_queue(void)

{
  int iVar1;
  
  iVar1 = register_bottom_half_do(check_queue,(void *)0x0);
  return iVar1;
}



void shutdown_connection_stream(connection *conn)

{
  if (conn->stream == (stream_encoded *)0x0) {
    if (-1 < conn->stream_pipes[0]) {
      close(conn->stream_pipes[0]);
    }
  }
  else {
    close_encoded(conn->stream);
    conn->stream = (stream_encoded *)0x0;
  }
  if (-1 < conn->stream_pipes[1]) {
    close(conn->stream_pipes[1]);
  }
  conn->stream_pipes[1] = -1;
  conn->stream_pipes[0] = -1;
  return;
}



void __regparm3 free_connection_data(connection *conn)

{
  socket *socket;
  uchar *puVar1;
  host_connection *p;
  int iVar2;
  cache_entry *pcVar3;
  
  if ((assert_failed == 0) &&
     (assert_failed = ((uint)*(byte *)&conn->field_0x78 ^ 1) & 1, assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x18d;
    elinks_internal((uchar *)"assertion conn->running failed: connection already suspended");
  }
  *(byte *)&conn->field_0x78 = *(byte *)&conn->field_0x78 & 0xfe;
  active_connections = active_connections + -1;
  if (assert_failed == 0) {
    assert_failed = -(active_connections >> 0x1f);
    if (assert_failed == 0) goto LAB_080b9769;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x193;
    elinks_internal((uchar *)
                    "assertion active_connections >= 0 failed: active connections underflow");
    if (assert_failed == 0) goto LAB_080b9769;
  }
  assert_failed = 0;
  active_connections = 0;
LAB_080b9769:
  socket = conn->socket;
  if ((socket->ssl != (void *)0x0) && (pcVar3 = conn->cached, pcVar3 != (cache_entry *)0x0)) {
    if (pcVar3->ssl_info != (uchar *)0x0) {
      mem_free(pcVar3->ssl_info);
      pcVar3 = conn->cached;
      socket = conn->socket;
    }
    puVar1 = get_ssl_connection_cipher(socket);
    pcVar3->ssl_info = puVar1;
  }
  if (conn->done != (anon_subr_void_connection_ptr_for_done *)0x0) {
    (*conn->done)(conn);
  }
  done_socket(conn->socket);
  done_socket(conn->data_socket);
  shutdown_connection_stream(conn);
  if (conn->info != (void *)0x0) {
    mem_free(conn->info);
  }
  conn->info = (void *)0x0;
  kill_timer(&conn->timer);
  if ((conn->state).basic != S_WAIT) {
    p = get_host_connection(conn);
    if ((p != (host_connection *)0x0) &&
       (iVar2 = (p->object).refcount + -1, (p->object).refcount = iVar2, iVar2 == 0)) {
      p->next->prev = p->prev;
      p->prev->next = p->next;
      done_uri(p->uri);
      mem_free(p);
      return;
    }
  }
  return;
}



void set_connection_state(connection *conn,connection_state state)

{
  progress *progress;
  uint uVar1;
  void *pvVar2;
  int iVar3;
  list_head_elinks *plVar4;
  connection *pcVar5;
  
  progress = conn->progress;
  if ((conn->state).basic < 0) {
    if (-1 < state.basic) {
      iVar3 = (conn->state).syserr;
      (conn->prev_error).basic = (conn->state).basic;
      (conn->prev_error).syserr = iVar3;
      goto LAB_080b98e0;
    }
    (conn->state).syserr = state.syserr;
    (conn->state).basic = state.basic;
  }
  else {
LAB_080b98e0:
    (conn->state).syserr = state.syserr;
    (conn->state).basic = state.basic;
    if (state.basic == S_TRANS) {
      if (progress->timer == (timer_id_T)0x0) {
        uVar1 = conn->id;
        start_update_progress(progress,stat_timer,conn);
        update_progress(conn->progress,conn->received,conn->est_length,conn->from);
        pcVar5 = (connection *)connection_queue.next;
        if ((list_head_elinks *)connection_queue.next == &connection_queue) {
          return;
        }
        while ((conn != pcVar5 || (uVar1 != conn->id))) {
          pcVar5 = pcVar5->next;
          if (pcVar5 == (connection *)&connection_queue) {
            return;
          }
        }
      }
      goto LAB_080b99a1;
    }
  }
  kill_timer(&progress->timer);
LAB_080b99a1:
  plVar4 = (list_head_elinks *)(conn->downloads).next;
  while (plVar4 != &conn->downloads) {
    *(int *)&plVar4[4].next = state.syserr;
    *(connection_basic_state *)&plVar4[3].prev = state.basic;
    pvVar2 = (void *)(conn->prev_error).syserr;
    plVar4[4].prev = (void *)(conn->prev_error).basic;
    plVar4[5].next = pvVar2;
    plVar4 = (list_head_elinks *)plVar4->next;
  }
  if (state.basic < 0) {
    return;
  }
  notify_connection_callbacks(conn);
  return;
}



void set_connection_socket_state(socket *socket,connection_state state)

{
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(socket == (socket *)0x0), socket == (socket *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0xef;
    elinks_internal((uchar *)"assertion socket failed!");
  }
  set_connection_state((connection *)socket->conn,state);
  return;
}



void stat_timer(connection *conn)

{
  update_progress(conn->progress,conn->received,conn->est_length,conn->from);
  notify_connection_callbacks(conn);
  return;
}



int __regparm3 try_to_suspend_connection(connection *conn,uri *uri)

{
  connection *conn_00;
  connection_priority cVar1;
  connection_priority cVar2;
  int iVar3;
  uint uVar4;
  
  cVar1 = get_priority(conn);
  conn_00 = (connection *)connection_queue.prev;
  while( true ) {
    if ((conn_00 == (connection *)&connection_queue) ||
       (cVar2 = get_priority(conn_00), cVar2 <= cVar1)) {
      return -1;
    }
    if ((((conn_00->state).basic != S_WAIT) &&
        ((conn_00->uri->post == (uchar *)0x0 || (cVar2 = get_priority(conn_00), PRI_PRELOAD < cVar2)
         ))) && ((uri == (uri *)0x0 || (iVar3 = compare_uri(uri,conn_00->uri,URI_HOST), iVar3 != 0))
                )) break;
    conn_00 = conn_00->prev;
  }
  free_connection_data(conn_00);
  if (assert_failed == 0) {
    uVar4 = 0;
  }
  else {
    uVar4 = 0xfffe795d;
  }
  assert_failed = 0;
  set_connection_state(conn_00,(connection_state)(ulonglong)uVar4);
  return 0;
}



int load_uri(uri *uri,uri *referrer,download *download,connection_priority pri,cache_mode cache_mode
            ,off_t start)

{
  download_callback_T *pdVar1;
  void *pvVar2;
  download *pdVar3;
  progress *ppVar4;
  connection_basic_state cVar5;
  cache_entry *pcVar6;
  uri *uri_00;
  uri *b;
  int iVar7;
  connection_priority cVar8;
  connection *conn;
  connection_basic_state local_34;
  int local_30;
  connection_state error_state;
  
  if (assert_failed == 0) {
    error_state.basic = S_OK;
  }
  else {
    error_state.basic = S_INTERNAL;
  }
  assert_failed = 0;
  error_state.syserr = 0;
  if (download != (download *)0x0) {
    download->conn = (connection *)0x0;
    download->cached = (cache_entry *)0x0;
    download->pri = pri;
    if (assert_failed == 0) {
      cVar5 = S_OUT_OF_MEM;
    }
    else {
      cVar5 = S_INTERNAL;
    }
    assert_failed = 0;
    (download->state).basic = cVar5;
    (download->state).syserr = 0;
    if (assert_failed == 0) {
      cVar5 = S_WAIT;
    }
    else {
      cVar5 = S_INTERNAL;
    }
    assert_failed = 0;
    (download->prev_error).basic = cVar5;
    (download->prev_error).syserr = 0;
  }
  pcVar6 = get_validated_cache_entry(uri,cache_mode);
  if (pcVar6 == (cache_entry *)0x0) {
    uri_00 = get_proxied_uri(uri);
    b = get_proxy_uri(uri,&error_state);
    if (((uri_00 == (uri *)0x0) || (b == (uri *)0x0)) ||
       ((iVar7 = get_protocol_need_slash_after_host(b->protocol), iVar7 != 0 &&
        (*(short *)&b->field_0x2e == 0)))) {
      if (download != (download *)0x0) {
        if (error_state.basic == S_OK) {
          connection_state();
          error_state.basic = local_34;
          error_state.syserr = local_30;
        }
        (download->state).basic = error_state.basic;
        pvVar2 = download->data;
        (download->state).syserr = error_state.syserr;
        (*download->callback)(download,pvVar2);
      }
      if (b != (uri *)0x0) {
        done_uri(b);
      }
      if (uri_00 == (uri *)0x0) {
        return -1;
      }
    }
    else {
      conn = (connection *)connection_queue.next;
      if ((list_head_elinks *)connection_queue.next != &connection_queue) {
        do {
          if (((*(byte *)&conn->field_0x78 & 4) == 0) &&
             (iVar7 = compare_uri(conn->uri,b,0), iVar7 != 0)) {
            done_uri(b);
            done_uri(uri_00);
            cVar8 = get_priority(conn);
            if (pri < cVar8) {
              conn->next->prev = conn->prev;
              conn->prev->next = conn->next;
              conn->pri[pri] = conn->pri[pri] + 1;
              add_to_queue(conn);
              register_check_queue();
            }
            else {
              conn->pri[pri] = conn->pri[pri] + 1;
            }
            if (download != (download *)0x0) {
              ppVar4 = conn->progress;
              download->conn = conn;
              download->progress = ppVar4;
              download->cached = conn->cached;
              pdVar3 = (download *)(conn->downloads).next;
              download->prev = (download *)&conn->downloads;
              download->next = pdVar3;
              *(download **)&(conn->downloads).next = download;
              download->next->prev = download;
              set_connection_state(conn,conn->state);
              return 0;
            }
            return 0;
          }
          conn = conn->next;
        } while (conn != (connection *)&connection_queue);
      }
      conn = init_connection(b,uri_00,referrer,start,cache_mode,pri);
      if (conn != (connection *)0x0) {
        if (download != (download *)0x0) {
          ppVar4 = conn->progress;
          download->conn = conn;
          download->cached = (cache_entry *)0x0;
          download->progress = ppVar4;
          connection_state();
          (download->state).basic = local_34;
          (download->state).syserr = local_30;
          pdVar3 = (download *)(conn->downloads).next;
          download->prev = (download *)&conn->downloads;
          download->next = pdVar3;
          *(download **)&(conn->downloads).next = download;
          download->next->prev = download;
        }
        add_to_queue(conn);
        connection_state();
        set_connection_state(conn,(connection_state)CONCAT44(local_30,local_34));
        register_check_queue();
        return 0;
      }
      if (download != (download *)0x0) {
        connection_state();
        (download->state).basic = local_34;
        pvVar2 = download->data;
        (download->state).syserr = local_30;
        (*download->callback)(download,pvVar2);
      }
      done_uri(b);
    }
    done_uri(uri_00);
    return -1;
  }
  if (download != (download *)0x0) {
    download->cached = pcVar6;
    if (assert_failed == 0) {
      cVar5 = S_OK;
    }
    else {
      cVar5 = S_INTERNAL;
    }
    assert_failed = 0;
    (download->state).basic = cVar5;
    pdVar1 = download->callback;
    (download->state).syserr = 0;
    if (pdVar1 != (download_callback_T *)0x0) {
      (*pdVar1)(download,download->data);
      return 0;
    }
  }
  return 0;
}



void __regparm3 done_connection(connection *conn)

{
  if (-1 < (conn->state).basic) {
    assert_failed = 0;
    set_connection_state(conn,(connection_state)0xfffe795d);
  }
  conn->next->prev = conn->prev;
  conn->prev->next = conn->next;
  notify_connection_callbacks(conn);
  if (conn->referrer != (uri *)0x0) {
    done_uri(conn->referrer);
  }
  done_uri(conn->uri);
  done_uri(conn->proxied_uri);
  mem_free(conn->socket);
  mem_free(conn->data_socket);
  done_progress(conn->progress);
  mem_free(conn);
  return;
}



int __regparm3 do_keepalive_connection_callback(keepalive_connection *keep_conn)

{
  protocol_handler_T *ppVar1;
  uri *proxied_uri;
  uri *uri;
  connection *conn;
  connection_priority cVar2;
  int iVar3;
  connection_priority cVar4;
  connection *conn_00;
  
  proxied_uri = get_proxied_uri(keep_conn->uri);
  uri = get_proxy_uri(keep_conn->uri,(connection_state *)0x0);
  if (uri != (uri *)0x0) {
    if (proxied_uri == (uri *)0x0) goto LAB_080ba0c6;
    conn = init_connection(uri,proxied_uri,(uri *)0x0,0,CACHE_MODE_NEVER,PRI_CANCEL);
    if (conn != (connection *)0x0) {
      ppVar1 = keep_conn->done;
      cVar2 = get_priority(conn);
      conn_00 = (connection *)connection_queue.next;
      if ((list_head_elinks *)connection_queue.next != &connection_queue) {
        do {
          cVar4 = get_priority(conn_00);
          if (cVar2 < cVar4) break;
          conn_00 = conn_00->next;
        } while (conn_00 != (connection *)&connection_queue);
      }
      conn->next = conn_00->prev->next;
      conn->prev = conn_00->prev;
      conn_00->prev->next = conn;
      conn->next->prev = conn;
      iVar3 = has_keepalive_connection(conn);
      if ((iVar3 != 0) && (iVar3 = add_host_connection(conn), iVar3 != 0)) {
        active_connections = active_connections + 1;
        *(byte *)&conn->field_0x78 = *(byte *)&conn->field_0x78 | 1;
        (*ppVar1)(conn);
        return 1;
      }
      free_connection_data(conn);
      done_connection(conn);
      return 0;
    }
  }
  else {
    if (proxied_uri == (uri *)0x0) {
      return 0;
    }
  }
  done_uri(proxied_uri);
LAB_080ba0c6:
  if (uri != (uri *)0x0) {
    done_uri(uri);
  }
  return 0;
}



int has_keepalive_connection(connection *conn)

{
  void *pvVar1;
  uri *b;
  int iVar2;
  list_head_elinks *p;
  
  b = conn->uri;
  if ((b->host != (uchar *)0x0) &&
     (p = (list_head_elinks *)keepalive_connections.next,
     (list_head_elinks *)keepalive_connections.next != &keepalive_connections)) {
    while( true ) {
      iVar2 = compare_uri((uri *)p[1].next,b,URI_KEEPALIVE);
      if (iVar2 != 0) {
        *(void **)&conn->socket->fd = p[4].prev;
        *(byte *)&conn->socket->field_0x24 =
             *(byte *)&conn->socket->field_0x24 & 0xfe | *(byte *)&p[4].next & 1;
        pvVar1 = p->next;
        p[4].prev = (void *)0xffffffff;
        p[1].prev = (void *)0x0;
        *(void **)((int)pvVar1 + 4) = p->prev;
        *(void **)p->prev = p->next;
        if (p[4].prev != (void *)0xffffffff) {
          close((int)p[4].prev);
        }
        done_uri((uri *)p[1].next);
        mem_free(p);
        return 1;
      }
      p = (list_head_elinks *)p->next;
      if (p == &keepalive_connections) break;
      b = conn->uri;
    }
  }
  return 0;
}



void check_keepalive_connections(void)

{
  void *p;
  int iVar1;
  keepalive_connection *keep_conn;
  int iVar2;
  keepalive_connection *pkVar3;
  bool bVar4;
  timeval_T age;
  timeval_T now;
  
  timeval_now(&now);
  kill_timer(&keepalive_timeout);
  if ((list_head_elinks *)keepalive_connections.next != &keepalive_connections) {
    iVar2 = 0;
    keep_conn = (keepalive_connection *)keepalive_connections.next;
    pkVar3 = *(keepalive_connection **)keepalive_connections.next;
    do {
      iVar1 = can_read(keep_conn->socket);
      if (iVar1 == 0) {
        timeval_sub(&age,&keep_conn->creation_time,&now);
        iVar1 = timeval_cmp(&age,&keep_conn->timeout);
        if (0 < iVar1) goto LAB_080ba32c;
        iVar2 = iVar2 + 1;
      }
      else {
LAB_080ba32c:
        if ((keep_conn->done == (protocol_handler_T *)0x0) ||
           (iVar1 = do_keepalive_connection_callback(keep_conn), iVar1 == 0)) {
          keep_conn->next->prev = keep_conn->prev;
          keep_conn->prev->next = keep_conn->next;
          if (keep_conn->socket != -1) {
            close(keep_conn->socket);
          }
          done_uri(keep_conn->uri);
          mem_free(keep_conn);
        }
      }
      bVar4 = pkVar3 != (keepalive_connection *)&keepalive_connections;
      keep_conn = pkVar3;
      pkVar3 = pkVar3->next;
    } while (bVar4);
    while (0x1e < iVar2) {
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
      assert_failed =
           ZEXT14((list_head_elinks *)keepalive_connections.next == &keepalive_connections);
      if ((list_head_elinks *)keepalive_connections.next == &keepalive_connections) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
        errline = 0x290;
        elinks_internal((uchar *)
                        "assertion !list_empty(keepalive_connections) failed: keepalive list empty")
        ;
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
      }
      p = keepalive_connections.prev;
      if ((*(int *)((int)keepalive_connections.prev + 0xc) == 0) ||
         (iVar1 = do_keepalive_connection_callback
                            ((keepalive_connection *)keepalive_connections.prev), iVar1 == 0)) {
        *(undefined4 *)(*(int *)p + 4) = *(undefined4 *)((int)p + 4);
        **(undefined4 **)((int)p + 4) = *(undefined4 *)p;
        if (*(int *)((int)p + 0x24) != -1) {
          close(*(int *)((int)p + 0x24));
        }
        done_uri(*(uri **)((int)p + 8));
        mem_free(p);
      }
      iVar2 = iVar2 + -1;
    }
    if ((list_head_elinks *)keepalive_connections.next != &keepalive_connections) {
      install_timer(&keepalive_timeout,20000,keepalive_timer,(void *)0x0);
      return;
    }
  }
  return;
}



void keepalive_timer(void *x)

{
  keepalive_timeout = (timer_id_T)0x0;
  check_keepalive_connections();
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void add_keepalive_connection
               (connection *conn,long timeout_in_seconds,
               anon_subr_void_connection_ptr_for_done *done)

{
  uri *puVar1;
  void **ppvVar2;
  bool bVar3;
  
  if (assert_failed != 0) {
LAB_080ba658:
    assert_failed = 0;
    goto done;
  }
  bVar3 = conn->socket->fd == -1;
  assert_failed = ZEXT14(bVar3);
  if (bVar3) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x252;
    elinks_internal((uchar *)
                    "assertion conn->socket->fd != -1 failed: keepalive connection not connected");
    if (assert_failed != 0) goto LAB_080ba658;
  }
  puVar1 = conn->uri;
  bVar3 = puVar1->host == (uchar *)0x0;
  assert_failed = ZEXT14(bVar3);
  if (bVar3) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x21b;
    elinks_internal((uchar *)"assertion uri->host failed!");
    if (assert_failed == 0) goto LAB_080ba4ec;
    assert_failed = 0;
  }
  else {
LAB_080ba4ec:
    ppvVar2 = (void **)mem_calloc(1,0x28);
    if (ppvVar2 != (void **)0x0) {
      (puVar1->object).refcount = (puVar1->object).refcount + 1;
      *(anon_subr_void_connection_ptr_for_done **)(ppvVar2 + 3) = done;
      *(uri **)(ppvVar2 + 2) = puVar1;
      *(byte *)(ppvVar2 + 8) =
           *(byte *)(ppvVar2 + 8) & 0xfe | *(byte *)&conn->socket->field_0x24 & 1;
      ppvVar2[9] = (void *)conn->socket->fd;
      timeval_from_seconds((timeval_T *)(ppvVar2 + 4),timeout_in_seconds);
      timeval_now((timeval_T *)(ppvVar2 + 6));
      set_handlers(conn->socket->fd,(select_handler_T *)0x0,(select_handler_T *)0x0,
                   (select_handler_T *)0x0,(void *)0x0);
      conn->socket->fd = -1;
      *(list_head_elinks **)(ppvVar2 + 1) = &keepalive_connections;
      *ppvVar2 = keepalive_connections.next;
      keepalive_connections.next = ppvVar2;
      *(void ***)((int)*ppvVar2 + 4) = ppvVar2;
      goto done;
    }
  }
  if (done != (anon_subr_void_connection_ptr_for_done *)0x0) {
                    // WARNING: Could not recover jumptable at 0x080ba619. Too many branches
                    // WARNING: Treating indirect jump as call
    (*done)();
    return;
  }
done:
  free_connection_data(conn);
  done_connection(conn);
  register_check_queue();
  return;
}



void abort_connection(connection *conn,connection_state state)

{
  if ((assert_failed == 0) && (assert_failed = -(~state.basic >> 0x1f), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x2e3;
    elinks_internal((uchar *)
                    "assertion is_in_result_state(state) failed: connection didn\'t end in result state (%d)"
                    ,state.basic);
  }
  if ((state.basic == S_OK) && (conn->cached != (cache_entry *)0x0)) {
    normalize_cache_entry(conn->cached,conn->from);
  }
  set_connection_state(conn,state);
  if ((*(byte *)&conn->field_0x78 & 1) != 0) {
    free_connection_data(conn);
  }
  done_connection(conn);
  register_check_queue();
  return;
}



void abort_background_connections(void)

{
  connection *pcVar1;
  bool bVar2;
  connection_priority cVar3;
  uint uVar4;
  connection *conn;
  connection *pcVar5;
  
  conn = (connection *)connection_queue.next;
  pcVar5 = *(connection **)connection_queue.next;
  if ((list_head_elinks *)connection_queue.next != &connection_queue) {
    do {
      cVar3 = get_priority(conn);
      if (cVar3 < PRI_CANCEL) {
        pcVar1 = pcVar5->next;
      }
      else {
        if (assert_failed == 0) {
          uVar4 = 0xfffe795f;
        }
        else {
          uVar4 = 0xfffe795d;
        }
        assert_failed = 0;
        abort_connection(conn,(connection_state)(ulonglong)uVar4);
        pcVar1 = pcVar5->next;
      }
      bVar2 = pcVar5 != (connection *)&connection_queue;
      conn = pcVar5;
      pcVar5 = pcVar1;
    } while (bVar2);
  }
  return;
}



void abort_all_connections(void)

{
  keepalive_connection *keep_conn;
  int iVar1;
  uint uVar2;
  
  if ((list_head_elinks *)connection_queue.next != &connection_queue) {
    do {
      if (assert_failed == 0) {
        uVar2 = 0xfffe795f;
      }
      else {
        uVar2 = 0xfffe795d;
      }
      assert_failed = 0;
      abort_connection((connection *)connection_queue.next,(connection_state)(ulonglong)uVar2);
    } while ((list_head_elinks *)connection_queue.next != &connection_queue);
  }
  while (keep_conn = (keepalive_connection *)keepalive_connections.next,
        keepalive_connections.next = keep_conn,
        keep_conn != (keepalive_connection *)&keepalive_connections) {
    if ((keep_conn->done == (protocol_handler_T *)0x0) ||
       (iVar1 = do_keepalive_connection_callback(keep_conn), iVar1 == 0)) {
      keep_conn->next->prev = keep_conn->prev;
      keep_conn->prev->next = keep_conn->next;
      if (keep_conn->socket != -1) {
        close(keep_conn->socket);
      }
      done_uri(keep_conn->uri);
      mem_free(keep_conn);
    }
  }
  check_keepalive_connections();
  return;
}



void done_connection_socket(socket *socket,connection_state state)

{
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(socket == (socket *)0x0), socket == (socket *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x104;
    elinks_internal((uchar *)"assertion socket failed!");
  }
  abort_connection((connection *)socket->conn,state);
  return;
}



void cancel_download(download *download,int interrupt)

{
  download *pdVar1;
  connection *conn;
  connection_basic_state cVar2;
  bool bVar3;
  undefined4 local_24;
  undefined4 local_20;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(download == (download *)0x0);
  if (download == (download *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x3ee;
    elinks_internal((uchar *)"assertion download failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if ((download->state).basic < 0) {
    return;
  }
  bVar3 = download->conn == (connection *)0x0;
  assert_failed = ZEXT14(bVar3);
  if (bVar3) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x3f5;
    elinks_internal((uchar *)"assertion download->conn != NULL failed: last state is %d",
                    (download->state).basic,(download->state).syserr);
    if (assert_failed == 0) goto LAB_080ba979;
    cVar2 = S_INTERNAL;
  }
  else {
LAB_080ba979:
    cVar2 = S_INTERRUPTED;
  }
  assert_failed = 0;
  (download->state).basic = cVar2;
  pdVar1 = download->next;
  (download->state).syserr = 0;
  pdVar1->prev = download->prev;
  download->prev->next = download->next;
  conn = download->conn;
  conn->pri[download->pri] = conn->pri[download->pri] + -1;
  if (assert_failed == 0) {
    assert_failed = -(conn->pri[download->pri] >> 0x1f);
    if (assert_failed == 0) goto LAB_080ba9cd;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x3ff;
    elinks_internal((uchar *)
                    "assertion conn->pri[download->pri] >= 0 failed: priority counter underflow");
    if (assert_failed == 0) goto LAB_080ba9cd;
  }
  assert_failed = 0;
  conn->pri[download->pri] = 0;
LAB_080ba9cd:
  if (((list_head_elinks *)(conn->downloads).next == &conn->downloads) &&
     ((conn->pri[6] = conn->pri[6] + 1, interrupt != 0 || ((*(byte *)&conn->field_0x78 & 4) != 0))))
  {
    connection_state();
    abort_connection(conn,(connection_state)CONCAT44(local_20,local_24));
  }
  sort_queue();
  register_check_queue();
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void move_download(download *old,download *new,connection_priority newpri)

{
  connection *pcVar1;
  int iVar2;
  connection_basic_state cVar3;
  download *pdVar4;
  bool bVar5;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(old == (download *)0x0), old == (download *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x416;
    elinks_internal((uchar *)"assertion old failed!");
  }
  pcVar1 = old->conn;
  new->conn = pcVar1;
  new->cached = old->cached;
  iVar2 = (old->prev_error).syserr;
  (new->prev_error).basic = (old->prev_error).basic;
  (new->prev_error).syserr = iVar2;
  new->progress = old->progress;
  cVar3 = (old->state).basic;
  iVar2 = (old->state).syserr;
  new->pri = newpri;
  (new->state).basic = cVar3;
  (new->state).syserr = iVar2;
  if (-1 < (old->state).basic) {
    if (assert_failed == 0) {
      bVar5 = old->conn == (connection *)0x0;
      assert_failed = ZEXT14(bVar5);
      if (bVar5) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
        errline = 0x430;
        elinks_internal((uchar *)"assertion old->conn != NULL failed: last state is %d",
                        (old->state).basic,(old->state).syserr);
      }
      newpri = new->pri;
    }
    pcVar1->pri[newpri] = pcVar1->pri[newpri] + 1;
    pdVar4 = (download *)(pcVar1->downloads).next;
    new->prev = (download *)&pcVar1->downloads;
    new->next = pdVar4;
    *(download **)&(pcVar1->downloads).next = new;
    new->next->prev = new;
    sort_queue();
    cancel_download(old,0);
    return;
  }
  if (new->callback != (download_callback_T *)0x0) {
    new->conn = (connection *)0x0;
    new->progress = (progress *)0x0;
                    // WARNING: Could not recover jumptable at 0x080bac15. Too many branches
                    // WARNING: Treating indirect jump as call
    (*new->callback)();
    return;
  }
  return;
}



void __regparm3 run_connection(connection *conn)

{
  byte bVar1;
  protocol_handler_T *ppVar2;
  int iVar3;
  uint uVar4;
  
  ppVar2 = get_protocol_handler(conn->uri->protocol);
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(ppVar2 == (protocol_handler_T *)0x0);
  if (ppVar2 == (protocol_handler_T *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x2cd;
    elinks_internal((uchar *)"assertion func failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
    bVar1 = *(byte *)&conn->field_0x78;
  }
  else {
    bVar1 = *(byte *)&conn->field_0x78;
  }
  assert_failed = (uint)bVar1 & 1;
  if ((bVar1 & 1) != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x2cf;
    elinks_internal((uchar *)"assertion !conn->running failed: connection already running");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  iVar3 = add_host_connection(conn);
  if (iVar3 == 0) {
    if (assert_failed == 0) {
      uVar4 = 0xfffe795c;
    }
    else {
      uVar4 = 0xfffe795d;
    }
    assert_failed = 0;
    set_connection_state(conn,(connection_state)(ulonglong)uVar4);
    done_connection(conn);
    return;
  }
  active_connections = active_connections + 1;
  *(byte *)&conn->field_0x78 = *(byte *)&conn->field_0x78 | 1;
  (*ppVar2)(conn);
  return;
}



void retry_connection(connection *conn,connection_state state)

{
  int iVar1;
  int *piVar2;
  int iVar3;
  uchar *in_EDX;
  
  piVar2 = get_opt_(config_options,in_EDX);
  iVar1 = *piVar2;
  if ((assert_failed == 0) && (assert_failed = -(~state.basic >> 0x1f), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x2f6;
    elinks_internal((uchar *)
                    "assertion is_in_result_state(state) failed: connection didn\'t end in result state (%d)"
                    ,state.basic);
  }
  set_connection_state(conn,state);
  free_connection_data(conn);
  if (conn->uri->post != (uchar *)0x0) {
LAB_080bae4c:
    done_connection(conn);
    register_check_queue();
    return;
  }
  if (iVar1 != 0) {
    iVar3 = conn->tries + 1;
    conn->tries = iVar3;
    if (iVar1 <= iVar3) goto LAB_080bae4c;
  }
  iVar1 = (conn->state).syserr;
  (conn->prev_error).basic = (conn->state).basic;
  (conn->prev_error).syserr = iVar1;
  run_connection(conn);
  return;
}



void retry_connection_socket(socket *socket,connection_state state)

{
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(socket == (socket *)0x0), socket == (socket *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0xfd;
    elinks_internal((uchar *)"assertion socket failed!");
  }
  retry_connection((connection *)socket->conn,state);
  return;
}



void check_queue(void)

{
  int iVar1;
  int iVar2;
  connection *conn;
  int *piVar3;
  connection_priority cVar4;
  connection_priority cVar5;
  int iVar6;
  host_connection *phVar7;
  uint uVar8;
  uchar *in_EDX;
  uchar *name;
  list_head_elinks *plVar9;
  connection *conn_00;
  list_head_elinks *conn_01;
  uri *local_3c;
  char *local_38;
  uri *puVar10;
  
  piVar3 = get_opt_(config_options,in_EDX);
  iVar1 = *piVar3;
  local_38 = "connection.max_connections";
  local_3c = (uri *)config_options;
  piVar3 = get_opt_(config_options,name);
  iVar2 = *piVar3;
LAB_080baf90:
  conn_01 = (list_head_elinks *)connection_queue.next;
  check_keepalive_connections(local_3c,local_38);
joined_r0x080bafa4:
  conn_00 = (connection *)connection_queue.prev;
  if (conn_01 == &connection_queue) {
joined_r0x080bb101:
    while (((connection *)conn_01 != conn_00 && (cVar4 = get_priority(conn_00), PRI_PRELOAD < cVar4)
           )) {
      if ((conn_00->state).basic == S_WAIT) {
        if (assert_failed == 0) {
          uVar8 = 0xfffe795f;
        }
        else {
          uVar8 = 0xfffe795d;
        }
        assert_failed = 0;
        set_connection_state(conn_00,(connection_state)(ulonglong)uVar8);
        done_connection(conn_00);
        conn_00 = (connection *)connection_queue.prev;
      }
      else {
        conn_00 = conn_00->prev;
      }
    }
    return;
  }
  cVar4 = get_priority((connection *)conn_01);
  cVar5 = get_priority((connection *)conn_01);
  plVar9 = (list_head_elinks *)keepalive_connections.next;
  puVar10 = (uri *)local_38;
  conn_00 = (connection *)conn_01;
  while (keepalive_connections.next = plVar9, local_38 = (char *)puVar10, cVar4 == cVar5) {
    conn = conn_00->next;
    if ((((conn_00->state).basic == S_WAIT) &&
        (local_38 = (char *)conn_00->uri, ((uri *)local_38)->host != (uchar *)0x0)) &&
       (plVar9 != &keepalive_connections)) {
      while( true ) {
        local_3c = (uri *)plVar9[1].next;
        iVar6 = compare_uri(local_3c,(uri *)local_38,URI_KEEPALIVE);
        if (iVar6 != 0) break;
        plVar9 = (list_head_elinks *)plVar9->next;
        puVar10 = (uri *)local_38;
        if (plVar9 == &keepalive_connections) goto LAB_080bb070;
        local_38 = (char *)conn_00->uri;
      }
      phVar7 = get_host_connection(conn_00);
      if ((phVar7 == (host_connection *)0x0) || ((phVar7->object).refcount < iVar1)) {
        if (active_connections < iVar2) goto LAB_080bb130;
        iVar6 = try_to_suspend_connection(conn_00,(uri *)0x0);
      }
      else {
        iVar6 = try_to_suspend_connection(conn_00,phVar7->uri);
      }
      puVar10 = (uri *)local_38;
      if (iVar6 == 0) goto LAB_080baf90;
    }
LAB_080bb070:
    local_38 = (char *)puVar10;
    if (conn == (connection *)&connection_queue) break;
    cVar5 = get_priority(conn);
    plVar9 = (list_head_elinks *)keepalive_connections.next;
    conn_00 = conn;
  }
  do {
    conn_00 = (connection *)conn_01;
    cVar5 = get_priority(conn_00);
    conn_01 = (list_head_elinks *)conn_00;
    if (cVar4 != cVar5) goto joined_r0x080bafa4;
    conn_01 = (list_head_elinks *)conn_00->next;
    if ((conn_00->state).basic == S_WAIT) {
      phVar7 = get_host_connection(conn_00);
      if ((phVar7 == (host_connection *)0x0) || ((phVar7->object).refcount < iVar1)) {
        if (active_connections < iVar2) break;
        iVar6 = try_to_suspend_connection(conn_00,(uri *)0x0);
      }
      else {
        iVar6 = try_to_suspend_connection(conn_00,phVar7->uri);
      }
      if (iVar6 == 0) goto LAB_080baf90;
    }
    if (conn_01 == &connection_queue) {
      conn_01 = &connection_queue;
      conn_00 = (connection *)connection_queue.prev;
      goto joined_r0x080bb101;
    }
  } while( true );
LAB_080bb130:
  run_connection(conn_00);
  goto LAB_080baf90;
}



void __regparm3 del_dns_cache_entry(dnsentry *dnsentry)

{
  dnsentry->next->prev = dnsentry->prev;
  dnsentry->prev->next = dnsentry->next;
  if (dnsentry->addr != (sockaddr_storage *)0x0) {
    mem_free(dnsentry->addr);
  }
  mem_free(dnsentry);
  return;
}



void shrink_dns_cache(int whole)

{
  dnsentry *dnsentry;
  int iVar1;
  dnsentry *pdVar2;
  bool bVar3;
  timeval_T age;
  timeval_T max_age;
  timeval_T now;
  
  if (whole == 0) {
    timeval_from_seconds(&max_age,0xe10);
    timeval_now(&now);
    if ((list_head_elinks *)dns_cache.next != &dns_cache) {
      dnsentry = (dnsentry *)dns_cache.next;
      pdVar2 = *(dnsentry **)dns_cache.next;
      do {
        timeval_sub(&age,&dnsentry->creation_time,&now);
        iVar1 = timeval_cmp(&age,&max_age);
        if (0 < iVar1) {
          del_dns_cache_entry(dnsentry);
        }
        bVar3 = pdVar2 != (dnsentry *)&dns_cache;
        dnsentry = pdVar2;
        pdVar2 = pdVar2->next;
      } while (bVar3);
      return;
    }
  }
  else {
    dnsentry = (dnsentry *)dns_cache.next;
    pdVar2 = *(dnsentry **)dns_cache.next;
    if ((list_head_elinks *)dns_cache.next != &dns_cache) {
      do {
        del_dns_cache_entry(dnsentry);
        bVar3 = pdVar2 != (dnsentry *)&dns_cache;
        dnsentry = pdVar2;
        pdVar2 = pdVar2->next;
      } while (bVar3);
    }
  }
  return;
}



void __regparm3 done_dns_lookup(dnsquery *query,dns_result result)

{
  uchar *__src;
  sockaddr_storage *__src_00;
  int iVar1;
  size_t __n;
  dnsentry *p;
  sockaddr_storage *psVar2;
  list_head_elinks *dnsentry;
  
  if (query->h != -1) {
    set_handlers(query->h,(select_handler_T *)0x0,(select_handler_T *)0x0,(select_handler_T *)0x0,
                 (void *)0x0);
    close(query->h);
    query->h = -1;
  }
  *query->queryref = (dnsquery *)0x0;
  if (query->done != (dns_callback_T *)0x0) {
    __src = query->name;
    dnsentry = (list_head_elinks *)dns_cache.next;
    if ((list_head_elinks *)dns_cache.next != &dns_cache) {
      do {
        iVar1 = c_strcasecmp((char *)((dnsentry *)dnsentry)->name,(char *)__src);
        if (iVar1 == 0) {
          if (dnsentry != (list_head_elinks *)dns_cache.next) {
            ((dnsentry *)dnsentry)->next->prev = ((dnsentry *)dnsentry)->prev;
            ((dnsentry *)dnsentry)->prev->next = ((dnsentry *)dnsentry)->next;
            *(list_head_elinks **)&((dnsentry *)dnsentry)->prev = &dns_cache;
            ((dnsentry *)dnsentry)->next = dns_cache.next;
            dns_cache.next = dnsentry;
            *(list_head_elinks **)&((dnsentry *)dnsentry)->next->prev = dnsentry;
          }
          if ((dnsentry *)dnsentry != (dnsentry *)0x0) {
            if (result == DNS_ERROR) {
              (*query->done)(query->data,((dnsentry *)dnsentry)->addr,((dnsentry *)dnsentry)->addrno
                            );
              goto done;
            }
            del_dns_cache_entry((dnsentry *)dnsentry);
          }
          dnsentry = &dns_cache;
          break;
        }
        dnsentry = (list_head_elinks *)((dnsentry *)dnsentry)->next;
      } while (dnsentry != &dns_cache);
    }
    if (result == DNS_SUCCESS) {
      iVar1 = query->addrno;
      __src_00 = query->addr;
      __n = strlen((char *)__src);
      if ((assert_failed == 0) && (assert_failed = ZEXT14(iVar1 < 1), iVar1 < 1)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
        errline = 0x6b;
        elinks_internal((uchar *)"assertion addrno > 0 failed!");
      }
      p = (dnsentry *)mem_calloc(1,__n + 0x1c);
      if (p != (dnsentry *)0x0) {
        psVar2 = (sockaddr_storage *)mem_alloc(iVar1 << 7);
        p->addr = psVar2;
        if (psVar2 == (sockaddr_storage *)0x0) {
          mem_free(p);
        }
        else {
          memcpy(p->name,__src,__n);
          memcpy(p->addr,__src_00,iVar1 << 7);
          p->addrno = iVar1;
          timeval_now(&p->creation_time);
          p->next = ((dnsentry *)dnsentry)->next;
          *(list_head_elinks **)&p->prev = dnsentry;
          ((dnsentry *)dnsentry)->next = p;
          p->next->prev = p;
        }
      }
    }
    (*query->done)(query->data,query->addr,query->addrno);
  }
done:
  if (query->addr != (sockaddr_storage *)0x0) {
    mem_free(query->addr);
  }
  query->addr = (sockaddr_storage *)0x0;
  mem_free(query);
  return;
}



void kill_dns_request(void **queryref)

{
  dnsquery *query;
  
  query = (dnsquery *)*queryref;
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(query == (dnsquery *)0x0), query == (dnsquery *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
    errline = 0x216;
    elinks_internal((uchar *)"assertion query failed!");
  }
  query->done = (dns_callback_T *)0x0;
  done_dns_lookup(query,DNS_ERROR);
  return;
}



void async_dns_error(dnsquery *query)

{
  done_dns_lookup(query,DNS_ERROR);
  return;
}



dns_result __regparm3 read_dns_data(int h,void *data,size_t datalen)

{
  ssize_t sVar1;
  uint uVar2;
  
  uVar2 = 0;
  do {
    sVar1 = read(h,(void *)((int)data + uVar2),datalen - uVar2);
    if (sVar1 < 1) {
      return DNS_ERROR;
    }
    uVar2 = uVar2 + sVar1;
  } while (uVar2 < datalen);
  if ((assert_failed == 0) && (assert_failed = ZEXT14(uVar2 != datalen), uVar2 != datalen)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
    errline = 0x12f;
    elinks_internal((uchar *)"assertion done == datalen failed!");
    return DNS_SUCCESS;
  }
  return DNS_SUCCESS;
}



void async_dns_reader(dnsquery *query)

{
  int iVar1;
  dns_result dVar2;
  sockaddr_storage *psVar3;
  
  iVar1 = set_blocking_fd(query->h);
  if ((-1 < iVar1) && (dVar2 = read_dns_data(query->h,&query->addrno,4), dVar2 != DNS_ERROR)) {
    psVar3 = (sockaddr_storage *)mem_calloc(query->addrno,0x80);
    query->addr = psVar3;
    if (psVar3 == (sockaddr_storage *)0x0) goto LAB_080bb6ef;
    if (query->addrno < 1) {
LAB_080bb708:
      done_dns_lookup(query,DNS_SUCCESS);
      return;
    }
    iVar1 = 0;
    while (dVar2 = read_dns_data(query->h,psVar3 + iVar1,0x80), dVar2 != DNS_ERROR) {
      iVar1 = iVar1 + 1;
      if (query->addrno == iVar1 || query->addrno < iVar1) goto LAB_080bb708;
      psVar3 = query->addr;
    }
  }
  if (query->addr != (sockaddr_storage *)0x0) {
    mem_free(query->addr);
  }
LAB_080bb6ef:
  query->addr = (sockaddr_storage *)0x0;
  done_dns_lookup(query,DNS_ERROR);
  return;
}



dns_result __regparm3 write_dns_data(int h,void *data,size_t datalen)

{
  ssize_t sVar1;
  uint uVar2;
  
  uVar2 = 0;
  do {
    sVar1 = write(h,(void *)((int)data + uVar2),datalen - uVar2);
    if (sVar1 < 0) {
      return DNS_ERROR;
    }
    uVar2 = uVar2 + sVar1;
  } while (uVar2 < datalen);
  if ((assert_failed == 0) && (assert_failed = ZEXT14(uVar2 != datalen), uVar2 != datalen)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
    errline = 0x100;
    elinks_internal((uchar *)"assertion done == datalen failed!");
    return DNS_SUCCESS;
  }
  return DNS_SUCCESS;
}



dns_result do_real_lookup(uchar *name,sockaddr_storage **addrs,int *addrno,int in_thread)

{
  addrinfo *paVar1;
  bool bVar2;
  addrinfo *__ai;
  int iVar3;
  sockaddr_storage *psVar4;
  uint uVar5;
  size_t count;
  int local_50;
  addrinfo hint;
  addrinfo *local_20 [4];
  
  if (((addrs != (sockaddr_storage **)0x0) && (name != (uchar *)0x0)) && (addrno != (int *)0x0)) {
    uVar5 = 0;
    do {
      *(undefined4 *)((int)&((addrinfo *)&hint)->ai_flags + uVar5) = 0;
      uVar5 = uVar5 + 4;
    } while (uVar5 < 0x20);
    hint.ai_family = 0;
    hint.ai_socktype = 1;
    iVar3 = getaddrinfo((char *)name,(char *)0x0,(addrinfo *)&hint,local_20);
    if (iVar3 == 0) {
      count = 0;
      paVar1 = local_20[0];
      while (paVar1 != (addrinfo *)0x0) {
        paVar1 = paVar1->ai_next;
        count = count + 1;
      }
      if (in_thread == 0) {
        psVar4 = (sockaddr_storage *)mem_calloc(count,0x80);
      }
      else {
        psVar4 = (sockaddr_storage *)calloc(count,0x80);
      }
      *addrs = psVar4;
      if (psVar4 != (sockaddr_storage *)0x0) {
        *addrno = count;
        local_50 = 0;
        __ai = (addrinfo *)0x0;
        paVar1 = local_20[0];
        while( true ) {
          if (paVar1 == (addrinfo *)0x0) {
            freeaddrinfo(__ai);
            return DNS_SUCCESS;
          }
          psVar4 = *addrs;
          if (assert_failed != 0) break;
          bVar2 = 0x80 < paVar1->ai_addrlen;
          assert_failed = ZEXT14(bVar2);
          if (bVar2) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
            errline = 0xd3;
            elinks_internal((uchar *)"assertion ai_cur->ai_addrlen <= sizeof(*addr) failed!");
            if (assert_failed != 0) break;
          }
          memcpy((void *)((int)&psVar4->ss_family + local_50),paVar1->ai_addr,paVar1->ai_addrlen);
          paVar1 = paVar1->ai_next;
          local_50 = local_50 + 0x80;
          __ai = local_20[0];
        }
        assert_failed = 0;
        freeaddrinfo(local_20[0]);
        if (in_thread == 0) {
          mem_free(*addrs);
        }
        else {
          free(*addrs);
        }
        *addrs = (sockaddr_storage *)0x0;
        *addrno = 0;
        return DNS_ERROR;
      }
    }
  }
  return DNS_ERROR;
}



void async_dns_writer(void *data,int h)

{
  dns_result dVar1;
  int iVar2;
  int local_14;
  sockaddr_storage *local_10;
  
  dVar1 = do_real_lookup((uchar *)data,&local_10,&local_14,1);
  if (((dVar1 != DNS_ERROR) && (iVar2 = set_blocking_fd(h), -1 < iVar2)) &&
     (dVar1 = write_dns_data(h,&local_14,4), dVar1 != DNS_ERROR)) {
    if (0 < local_14) {
      iVar2 = 0;
      do {
        dVar1 = write_dns_data(h,local_10 + iVar2,0x80);
        if (dVar1 == DNS_ERROR) {
          return;
        }
        iVar2 = iVar2 + 1;
      } while (iVar2 < local_14);
    }
    free(local_10);
    return;
  }
  return;
}



dns_result __regparm3 init_dns_lookup(uchar *name,void **queryref,dns_callback_T *done,void *data)

{
  uchar *name_00;
  size_t __n;
  dnsquery *query;
  int *piVar1;
  int fd;
  dns_result result;
  uchar *name_01;
  
  __n = strlen((char *)name);
  query = (dnsquery *)mem_calloc(1,__n + 0x1c);
  if (query == (dnsquery *)0x0) {
    (*done)(data,(sockaddr_storage *)0x0,0);
    return DNS_ERROR;
  }
  query->done = done;
  name_00 = query->name;
  query->data = data;
  memcpy(name_00,name,__n);
  query->queryref = queryref;
  *(dnsquery **)queryref = query;
  piVar1 = get_opt_(config_options,name_01);
  if (*piVar1 == 0) {
    query->h = -1;
  }
  else {
    __n = strlen((char *)name_00);
    fd = start_thread(async_dns_writer,name_00,__n + 1);
    query->h = fd;
    if (fd != -1) {
      set_handlers(fd,async_dns_reader,(select_handler_T *)0x0,async_dns_error,query);
      return DNS_ASYNC;
    }
  }
  result = do_real_lookup(name_00,&query->addr,&query->addrno,0);
  done_dns_lookup(query,result);
  return result;
}



dns_result find_host(uchar *name,void **queryref,dns_callback_T *done,void *data,int no_cache)

{
  int iVar1;
  dns_result dVar2;
  list_head_elinks *plVar3;
  timeval_T max_age;
  timeval_T now;
  timeval_T age;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(queryref == (void **)0x0), queryref == (void **)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
    errline = 0x1f5;
    elinks_internal((uchar *)"assertion queryref failed!");
  }
  *queryref = (void *)0x0;
  if ((no_cache == 0) &&
     (plVar3 = (list_head_elinks *)dns_cache.next, (list_head_elinks *)dns_cache.next != &dns_cache)
     ) {
    do {
      iVar1 = c_strcasecmp((char *)(plVar3 + 3),(char *)name);
      if (iVar1 == 0) {
        if (plVar3 != (list_head_elinks *)dns_cache.next) {
          *(void **)((int)plVar3->next + 4) = plVar3->prev;
          *(void **)plVar3->prev = plVar3->next;
          *(list_head_elinks **)&plVar3->prev = &dns_cache;
          plVar3->next = dns_cache.next;
          dns_cache.next = plVar3;
          *(list_head_elinks **)((int)plVar3->next + 4) = plVar3;
        }
        if (plVar3 != (list_head_elinks *)0x0) {
          if (assert_failed == 0) {
            if ((int)plVar3[1].prev < 1) {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
              errline = 0x202;
              elinks_internal((uchar *)"assertion dnsentry && dnsentry->addrno > 0 failed!");
            }
            else {
              assert_failed = 0;
            }
          }
          timeval_from_seconds(&max_age,0xe10);
          timeval_now(&now);
          timeval_sub(&age,(timeval_T *)(plVar3 + 2),&now);
          iVar1 = timeval_cmp(&age,&max_age);
          if (iVar1 < 1) {
            (*done)(data,(sockaddr_storage *)plVar3[1].next,(int)plVar3[1].prev);
            return DNS_SUCCESS;
          }
        }
        break;
      }
      plVar3 = (list_head_elinks *)plVar3->next;
    } while (plVar3 != &dns_cache);
  }
  dVar2 = init_dns_lookup(name,queryref,done,data);
  return dVar2;
}



int has_progress(progress *progress)

{
  uint uVar1;
  timeval_T current_speed_after;
  
  timeval_from_milliseconds(&current_speed_after,100);
  uVar1 = timeval_cmp((timeval_T *)progress,&current_speed_after);
  return ~uVar1 >> 0x1f;
}



// WARNING: Removing unreachable block (ram,0x080bbf80)

void update_progress(progress *progress,off_t loaded,off_t size,off_t pos)

{
  timeval_T *t;
  off_t *poVar1;
  int *piVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  milliseconds_T milliseconds;
  int iVar6;
  long seconds;
  int iVar7;
  uint uVar8;
  timeval_T dis_b_interval;
  timeval_T dis_b_max;
  timeval_T elapsed;
  timeval_T now;
  
  timeval_now(&now);
  timeval_sub(&elapsed,&progress->last_time,&now);
  (progress->last_time).sec = now.sec;
  (progress->last_time).usec = now.usec;
  uVar3 = *(uint *)&progress->last_loaded;
  uVar8 = (uint)loaded - *(uint *)&progress->last_loaded;
  iVar7 = *(int *)((int)&progress->last_loaded + 4);
  *(uint *)&progress->loaded = (uint)loaded;
  *(int *)((int)&progress->loaded + 4) = loaded._4_4_;
  t = &progress->dis_b;
  *(uint *)&progress->last_loaded = (uint)loaded;
  *(int *)((int)&progress->last_loaded + 4) = loaded._4_4_;
  timeval_add_interval((timeval_T *)progress,&elapsed);
  timeval_add_interval(t,&elapsed);
  milliseconds = mult_ms(100,0x32);
  timeval_from_milliseconds(&dis_b_max,milliseconds);
  timeval_from_milliseconds(&dis_b_interval,100);
  while (iVar6 = timeval_cmp(t,&dis_b_max), -1 < iVar6) {
    uVar4 = progress->data_in_secs[0];
    poVar1 = &progress->cur_loaded;
    uVar5 = *(uint *)poVar1;
    *(uint *)poVar1 = *(uint *)poVar1 - uVar4;
    piVar2 = (int *)((int)&progress->cur_loaded + 4);
    *piVar2 = (*piVar2 - ((int)uVar4 >> 0x1f)) - (uint)(uVar5 < uVar4);
    memmove(progress->data_in_secs,progress->data_in_secs + 1,0xc4);
    progress->data_in_secs[0x31] = 0;
    timeval_sub_interval(t,&dis_b_interval);
  }
  progress->data_in_secs[0x31] = progress->data_in_secs[0x31] + uVar8;
  iVar6 = uVar8 + *(uint *)&progress->cur_loaded;
  iVar7 = ((loaded._4_4_ - iVar7) - (uint)((uint)loaded < uVar3)) +
          *(int *)((int)&progress->cur_loaded + 4) +
          (uint)CARRY4(uVar8,*(uint *)&progress->cur_loaded);
  *(int *)&progress->cur_loaded = iVar6;
  *(int *)((int)&progress->cur_loaded + 4) = iVar7;
  iVar7 = __divdi3(iVar6,iVar7,5,0);
  progress->current_speed = iVar7;
  *(undefined4 *)&progress->pos = (undefined4)pos;
  *(undefined4 *)((int)&progress->pos + 4) = pos._4_4_;
  *(undefined4 *)&progress->size = (undefined4)size;
  *(undefined4 *)((int)&progress->size + 4) = size._4_4_;
  if ((size != -1) && (size < pos)) {
    *(undefined4 *)&progress->size = (undefined4)pos;
    *(undefined4 *)((int)&progress->size + 4) = pos._4_4_;
  }
  iVar7 = timeval_div_off_t(progress->loaded,(timeval_T *)progress);
  progress->average_speed = iVar7;
  if (iVar7 != 0) {
    seconds = __divdi3(*(uint *)&progress->size - *(uint *)&progress->pos,
                       (*(int *)((int)&progress->size + 4) - *(int *)((int)&progress->pos + 4)) -
                       (uint)(*(uint *)&progress->size < *(uint *)&progress->pos),iVar7,
                       iVar7 >> 0x1f);
    timeval_from_seconds(&progress->estimated_time,seconds);
  }
  install_timer(&progress->timer,100,(anon_subr_void_void_ptr *)progress->timer_func,
                progress->timer_func_data);
  return;
}



void done_progress(progress *progress)

{
  bool bVar1;
  
  if ((assert_failed == 0) &&
     (bVar1 = progress->timer != (timer_id_T)0x0, assert_failed = ZEXT14(bVar1), bVar1)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/progress.c";
    errline = 0x2c;
    elinks_internal((uchar *)"assertion progress->timer == TIMER_ID_UNDEF failed!");
    mem_free(progress);
    return;
  }
  mem_free(progress);
  return;
}



progress * init_progress(off_t start)

{
  progress *ppVar1;
  
  ppVar1 = (progress *)mem_calloc(1,0x138);
  if (ppVar1 != (progress *)0x0) {
    *(undefined4 *)&ppVar1->start = (undefined4)start;
    *(undefined4 *)((int)&ppVar1->start + 4) = start._4_4_;
    ppVar1->timer = (timer_id_T)0x0;
  }
  return ppVar1;
}



void start_update_progress
               (progress *progress,anon_subr_void_void_ptr *timer_func,void *timer_func_data)

{
  undefined4 uVar1;
  int iVar2;
  progress *ppVar3;
  progress *ppVar4;
  progress tmp;
  
  if ((*(byte *)&progress->field_0x28 & 1) == 0) {
    iVar2 = 0x4e;
    ppVar3 = &tmp;
    while (iVar2 != 0) {
      iVar2 = iVar2 + -1;
      (ppVar3->elapsed).sec = 0;
      ppVar3 = (progress *)&(ppVar3->elapsed).usec;
    }
    iVar2 = 0x4e;
    tmp.start._0_4_ = *(undefined4 *)&progress->start;
    tmp.start._4_4_ = *(undefined4 *)((int)&progress->start + 4);
    tmp._40_1_ = tmp._40_1_ | 1;
    tmp.seek._0_4_ = *(undefined4 *)&progress->seek;
    tmp.seek._4_4_ = *(undefined4 *)((int)&progress->seek + 4);
    ppVar3 = &tmp;
    ppVar4 = progress;
    while (iVar2 != 0) {
      iVar2 = iVar2 + -1;
      (ppVar4->elapsed).sec = (ppVar3->elapsed).sec;
      ppVar3 = (progress *)&(ppVar3->elapsed).usec;
      ppVar4 = (progress *)&(ppVar4->elapsed).usec;
    }
  }
  timeval_now(&progress->last_time);
  uVar1 = *(undefined4 *)((int)&progress->loaded + 4);
  *(undefined4 *)&progress->last_loaded = *(undefined4 *)&progress->loaded;
  *(undefined4 *)((int)&progress->last_loaded + 4) = uVar1;
  *(anon_subr_void_void_ptr **)&progress->timer_func = timer_func;
  progress->timer_func_data = timer_func_data;
  return;
}



connection_state connection_state(void)

{
  int *in_EAX;
  int in_EDX;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(in_EDX == -1);
    if (in_EDX == -1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
      errline = 0x84;
      elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
      if (assert_failed != 0) goto LAB_080bc148;
    }
    in_EAX[1] = 0;
    *in_EAX = in_EDX;
    return (connection_state)CONCAT44(in_EDX,in_EAX);
  }
LAB_080bc148:
  assert_failed = 0;
  in_EAX[1] = 0;
  *in_EAX = -0x186a3;
  return (connection_state)CONCAT44(0xfffe795d,in_EAX);
}



void kill_buffer_data(read_buffer *rb,int n)

{
  size_t __n;
  
  if (assert_failed == 0) {
    if ((n < 0) || (rb->length < n)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
      errline = 0x3f4;
      elinks_internal((uchar *)"assertion n >= 0 && n <= rb->length failed: bad number of bytes: %d"
                      ,n);
      if (assert_failed != 0) goto LAB_080bc208;
    }
    else {
      assert_failed = 0;
    }
    if (n != 0) {
      __n = rb->length - n;
      rb->length = __n;
      memmove(rb->data,rb->data + n,__n);
      rb->freespace = rb->freespace + n;
      return;
    }
  }
  else {
LAB_080bc208:
    assert_failed = 0;
    rb->length = 0;
  }
  return;
}



read_buffer * alloc_read_buffer(socket *socket)

{
  socket_operation_T *psVar1;
  read_buffer *prVar2;
  undefined4 local_24;
  undefined4 local_20;
  
  prVar2 = (read_buffer *)mem_calloc(1,0x5000);
  if (prVar2 == (read_buffer *)0x0) {
    psVar1 = socket->ops->done;
    connection_state();
    (*psVar1)(socket,(connection_state)CONCAT44(local_20,local_24));
  }
  else {
    prVar2->freespace = 0x4ff0;
  }
  return prVar2;
}



socket * init_socket(void *conn,socket_operations *ops)

{
  socket *psVar1;
  
  psVar1 = (socket *)mem_calloc(1,0x28);
  if (psVar1 != (socket *)0x0) {
    psVar1->fd = -1;
    psVar1->conn = conn;
    psVar1->ops = ops;
  }
  return psVar1;
}



connect_info * __regparm3
init_connection_info(uri *uri,socket *socket,socket_connect_T connect_done)

{
  connect_info *pcVar1;
  int iVar2;
  
  pcVar1 = (connect_info *)mem_calloc(1,0x20);
  if (pcVar1 != (connect_info *)0x0) {
    pcVar1->done = connect_done;
    iVar2 = get_uri_port(uri);
    pcVar1->port = iVar2;
    iVar2 = uri->ip_family;
    pcVar1->triedno = -1;
    pcVar1->addr = (sockaddr_storage *)0x0;
    pcVar1->ip_family = iVar2;
    (uri->object).refcount = (uri->object).refcount + 1;
    pcVar1->uri = uri;
  }
  return pcVar1;
}



void __regparm3 done_connection_info(socket *socket)

{
  connect_info *pcVar1;
  
  pcVar1 = socket->connect_info;
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(pcVar1 == (connect_info *)0x0), pcVar1 == (connect_info *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
    errline = 0x81;
    elinks_internal((uchar *)"assertion socket->connect_info failed!");
  }
  if (pcVar1->dnsquery != (void *)0x0) {
    kill_dns_request(&pcVar1->dnsquery);
  }
  if (pcVar1->addr != (sockaddr_storage *)0x0) {
    mem_free(pcVar1->addr);
  }
  done_uri(pcVar1->uri);
  if (socket->connect_info != (connect_info *)0x0) {
    mem_free(socket->connect_info);
  }
  socket->connect_info = (connect_info *)0x0;
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void complete_connect_socket(socket *socket,uri *uri,socket_connect_T done)

{
  byte bVar1;
  uri *uri_00;
  socket_operation_T *UNRECOVERED_JUMPTABLE;
  int iVar2;
  connect_info *pcVar3;
  
  pcVar3 = socket->connect_info;
  if (pcVar3 == (connect_info *)0x0) {
    if ((assert_failed == 0) && (assert_failed = ZEXT14(uri == (uri *)0x0), uri == (uri *)0x0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
      errline = 0x1d8;
      elinks_internal((uchar *)"assertion uri && socket failed!");
    }
    pcVar3 = init_connection_info(uri,socket,done);
    if (pcVar3 == (connect_info *)0x0) {
      UNRECOVERED_JUMPTABLE = socket->ops->done;
      connection_state();
                    // WARNING: Could not recover jumptable at 0x080bc520. Too many branches
                    // WARNING: Treating indirect jump as call
      (*UNRECOVERED_JUMPTABLE)();
      return;
    }
    bVar1 = *(byte *)&socket->field_0x24;
    socket->connect_info = pcVar3;
  }
  else {
    uri_00 = pcVar3->uri;
    if (uri_00 != (uri *)0x0) {
      if ((*(byte *)&socket->field_0x24 & 4) == 0) {
        del_blacklist_entry(uri_00,SERVER_BLACKLIST_NO_TLS);
        bVar1 = *(byte *)&socket->field_0x24;
        goto joined_r0x080bc48c;
      }
      add_blacklist_entry(uri_00,SERVER_BLACKLIST_NO_TLS);
    }
    bVar1 = *(byte *)&socket->field_0x24;
  }
joined_r0x080bc48c:
  if ((((bVar1 & 2) != 0) && (socket->ssl == (void *)0x0)) &&
     (iVar2 = ssl_connect(socket), iVar2 < 0)) {
    return;
  }
  if (pcVar3->done != (socket_connect_T)0x0) {
    (*pcVar3->done)(socket);
  }
  done_connection_info(socket);
  return;
}



int get_pasv_socket(socket *ctrl_socket,sockaddr_storage *addr)

{
  int iVar1;
  socket_operation_T *psVar2;
  int iVar3;
  int *piVar4;
  int __domain;
  size_t __n;
  int in_GS_OFFSET;
  sockaddr_in6 *local_64;
  socklen_t local_50;
  sockaddr_in6 bind_addr6;
  sockaddr_in bind_addr4;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((*(byte *)&ctrl_socket->field_0x24 & 1) == 0) {
    local_64 = (sockaddr_in6 *)&bind_addr4;
    __domain = 2;
    __n = 0x10;
  }
  else {
    local_64 = &bind_addr6;
    __domain = 10;
    __n = 0x1c;
  }
  memset(addr,0,__n);
  memset(local_64,0,__n);
  local_50 = __n;
  iVar3 = getsockname(ctrl_socket->fd,(sockaddr *)addr,&local_50);
  if (iVar3 == 0) {
    __domain = socket(__domain,1,6);
    if (__domain < 0) {
      if (__domain == -1) goto LAB_080bc6b0;
    }
    else {
      iVar3 = set_nonblocking_fd(__domain);
      if (-1 < iVar3) {
        memcpy(local_64,addr,__n);
        if ((*(byte *)&ctrl_socket->field_0x24 & 1) == 0) {
          bind_addr4.sin_port = 0;
        }
        else {
          bind_addr6.sin6_port = 0;
        }
        iVar3 = bind(__domain,(sockaddr *)local_64,__n);
        if (((iVar3 == 0) &&
            (local_50 = __n, iVar3 = getsockname(__domain,(sockaddr *)addr,&local_50), iVar3 == 0))
           && (iVar3 = listen(__domain,1), iVar3 == 0)) {
          set_ip_tos_throughput(__domain);
          goto LAB_080bc667;
        }
      }
    }
    close(__domain);
  }
LAB_080bc6b0:
  psVar2 = ctrl_socket->ops->retry;
  piVar4 = __errno_location();
  (*psVar2)(ctrl_socket,(connection_state)CONCAT44(*piVar4,0xffffffff));
  __domain = -1;
LAB_080bc667:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return __domain;
}



void close_socket(socket *socket)

{
  int __fd;
  
  __fd = socket->fd;
  if (__fd != -1) {
    if (socket->ssl != (void *)0x0) {
      ssl_close(socket);
      __fd = socket->fd;
    }
    close(__fd);
    set_handlers(socket->fd,(select_handler_T *)0x0,(select_handler_T *)0x0,(select_handler_T *)0x0,
                 (void *)0x0);
    socket->fd = -1;
  }
  return;
}



void done_socket(socket *socket)

{
  list_head_elinks *plVar1;
  
  close_socket(socket);
  if (socket->connect_info != (connect_info *)0x0) {
    done_connection_info(socket);
  }
  if (socket->read_buffer != (read_buffer *)0x0) {
    mem_free(socket->read_buffer);
  }
  socket->read_buffer = (read_buffer *)0x0;
  if (socket->write_buffer != (void *)0x0) {
    mem_free(socket->write_buffer);
  }
  socket->write_buffer = (void *)0x0;
  plVar1 = (list_head_elinks *)socket_weak_refs.next;
  if ((list_head_elinks *)socket_weak_refs.next != &socket_weak_refs) {
    do {
      while ((socket *)plVar1[1].next != socket) {
        plVar1 = (list_head_elinks *)plVar1->next;
        if (plVar1 == &socket_weak_refs) {
          return;
        }
      }
      plVar1[1].next = (void *)0x0;
      plVar1 = (list_head_elinks *)plVar1->next;
    } while (plVar1 != &socket_weak_refs);
  }
  return;
}



void exception(socket *socket)

{
  uint uVar1;
  
  if (assert_failed == 0) {
    uVar1 = 0xfffe795e;
  }
  else {
    uVar1 = 0xfffe795d;
  }
  assert_failed = 0;
  (*socket->ops->retry)(socket,(connection_state)(ulonglong)uVar1);
  return;
}



void read_from_socket(socket *socket,read_buffer *buffer,connection_state state,socket_read_T *done)

{
  socket_weak_ref **ppsVar1;
  read_buffer *p;
  select_handler_T *write_func;
  uint uVar2;
  socket_weak_ref ref;
  
  p = socket->read_buffer;
  ref.socket = socket;
  ref.prev = (socket_weak_ref *)&socket_weak_refs;
  ref.next = (socket_weak_ref *)socket_weak_refs.next;
  ppsVar1 = (socket_weak_ref **)((int)socket_weak_refs.next + 4);
  socket_weak_refs.next = &ref;
  *ppsVar1 = &ref;
  buffer->done = done;
  if (assert_failed == 0) {
    uVar2 = 0;
  }
  else {
    uVar2 = 0xfffe795d;
  }
  assert_failed = 0;
  (*socket->ops->set_timeout)(socket,(connection_state)(ulonglong)uVar2);
  (*socket->ops->set_state)(socket,state);
  (ref.next)->prev = ref.prev;
  (ref.prev)->next = ref.next;
  if (ref.socket == (socket *)0x0) {
    if (p != buffer) {
      mem_free(buffer);
      return;
    }
  }
  else {
    p = socket->read_buffer;
    if ((p != (read_buffer *)0x0) && (buffer != p)) {
      mem_free(p);
    }
    write_func = (select_handler_T *)0x0;
    socket->read_buffer = buffer;
    if ((*(byte *)&socket->field_0x24 & 0x10) != 0) {
      write_func = get_handler(socket->fd,SELECT_HANDLER_WRITE);
    }
    set_handlers(socket->fd,read_select,write_func,exception,socket);
  }
  return;
}



void read_response_from_socket(socket *socket)

{
  read_buffer *buffer;
  uint uVar1;
  
  buffer = alloc_read_buffer(socket);
  if (buffer != (read_buffer *)0x0) {
    if (assert_failed == 0) {
      uVar1 = 4;
    }
    else {
      uVar1 = 0xfffe795d;
    }
    assert_failed = 0;
    read_from_socket(socket,buffer,(connection_state)(ulonglong)uVar1,socket->read_done);
  }
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void write_to_socket(socket *socket,uchar *data,int len,socket_write_T write_done)

{
  undefined4 *puVar1;
  select_handler_T *read_func;
  socket_operation_T *UNRECOVERED_JUMPTABLE;
  undefined4 in_stack_00000018;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(len < 1);
  if (len < 1) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
    errline = 0x32a;
    elinks_internal((uchar *)"assertion len > 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  assert_failed = 0;
  (*socket->ops->set_timeout)(socket,(connection_state)0x0);
  puVar1 = (undefined4 *)mem_alloc(len + 0x10);
  if (puVar1 == (undefined4 *)0x0) {
    UNRECOVERED_JUMPTABLE = socket->ops->done;
    connection_state();
  }
  else {
    puVar1[1] = len;
    puVar1[2] = 0;
    *puVar1 = in_stack_00000018;
    memcpy(puVar1 + 3,data,len);
    if (socket->write_buffer != (void *)0x0) {
      mem_free(socket->write_buffer);
    }
    read_func = (select_handler_T *)0x0;
    *(undefined4 **)&socket->write_buffer = puVar1;
    if ((*(byte *)&socket->field_0x24 & 0x10) != 0) {
      read_func = get_handler(socket->fd,SELECT_HANDLER_READ);
    }
    set_handlers(socket->fd,read_func,write_select,exception,socket);
    UNRECOVERED_JUMPTABLE = socket->ops->set_state;
  }
                    // WARNING: Could not recover jumptable at 0x080bcaf2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*UNRECOVERED_JUMPTABLE)();
  return;
}



void request_from_socket(socket *socket,uchar *data,int datalen,connection_state state,
                        socket_state sock_state,socket_read_T *read_done)

{
  socket->read_done = read_done;
  socket->state = sock_state;
  write_to_socket(socket,data,datalen,(socket_write_T)state.basic);
  return;
}



void read_select(socket *socket)

{
  void *pvVar1;
  int __fd;
  ssize_t sVar2;
  int *piVar3;
  read_buffer *buffer;
  ssize_t sVar4;
  uint *puVar5;
  int iVar6;
  socket_operation_T *psVar7;
  size_t __nbytes;
  uint size;
  undefined4 local_24;
  undefined4 local_20;
  
  buffer = socket->read_buffer;
  if (assert_failed != 0) {
LAB_080bccbe:
    assert_failed = 0;
    (*socket->ops->done)(socket,(connection_state)0xfffe795d);
    return;
  }
  assert_failed = ZEXT14(buffer == (read_buffer *)0x0);
  if (buffer == (read_buffer *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
    errline = 0x35a;
    elinks_internal((uchar *)"assertion rb != NULL failed: read socket has no buffer");
    if (assert_failed != 0) goto LAB_080bccbe;
  }
  assert_failed = 0;
  (*socket->ops->set_timeout)(socket,(connection_state)0x0);
  if ((*(byte *)&socket->field_0x24 & 0x10) == 0) {
    set_handlers(socket->fd,(select_handler_T *)0x0,(select_handler_T *)0x0,(select_handler_T *)0x0,
                 (void *)0x0);
    __nbytes = buffer->freespace;
    if (__nbytes != 0) goto LAB_080bcc1b;
LAB_080bcd65:
    size = buffer->length + 0x5010U & 0xfffff000;
    buffer = (read_buffer *)mem_realloc(buffer,size);
    if (buffer == (read_buffer *)0x0) {
      psVar7 = socket->ops->done;
      goto LAB_080bcf16;
    }
    iVar6 = (size - buffer->length) + -0x10;
    buffer->freespace = iVar6;
    if ((assert_failed == 0) && (assert_failed = ZEXT14(iVar6 < 1), iVar6 < 1)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
      errline = 0x371;
      elinks_internal((uchar *)"assertion rb->freespace > 0 failed!");
    }
    pvVar1 = socket->ssl;
    socket->read_buffer = buffer;
    __nbytes = buffer->freespace;
  }
  else {
    __nbytes = buffer->freespace;
    if (__nbytes == 0) goto LAB_080bcd65;
LAB_080bcc1b:
    pvVar1 = socket->ssl;
  }
  if (pvVar1 == (void *)0x0) {
    iVar6 = buffer->length;
    __fd = socket->fd;
    do {
      sVar4 = read(__fd,buffer->data + iVar6,__nbytes);
      if (sVar4 != -1) {
        if (sVar4 == 0) goto LAB_080bce58;
        sVar2 = -1;
        if (-1 < sVar4) {
          sVar2 = sVar4;
        }
        goto LAB_080bcc3e;
      }
      piVar3 = __errno_location();
    } while (*piVar3 == 4);
LAB_080bcc66:
    psVar7 = socket->ops->retry;
    piVar3 = __errno_location();
    (*psVar7)(socket,(connection_state)CONCAT44(*piVar3,0xffffffff));
    return;
  }
  sVar2 = ssl_read(socket,buffer->data + buffer->length,__nbytes);
LAB_080bcc3e:
  if (sVar2 == -3) {
    if (assert_failed == 0) {
      size = 8;
    }
    else {
      size = 0xfffe795d;
    }
    assert_failed = 0;
    read_from_socket(socket,buffer,(connection_state)(ulonglong)size,buffer->done);
    return;
  }
  if (sVar2 < -2) {
    if (sVar2 == -4) {
LAB_080bce58:
      if (socket->state != SOCKET_RETRY_ONCLOSE) {
        socket->state = SOCKET_CLOSED;
        (*buffer->done)(socket,buffer);
        return;
      }
      psVar7 = socket->ops->retry;
LAB_080bcf16:
      connection_state();
      (*psVar7)(socket,(connection_state)CONCAT44(local_20,local_24));
      return;
    }
LAB_080bccf9:
    buffer->length = buffer->length + sVar2;
    iVar6 = buffer->freespace - sVar2;
    buffer->freespace = iVar6;
    if ((assert_failed == 0) && (assert_failed = -(iVar6 >> 0x1f), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
      errline = 0x39d;
      elinks_internal((uchar *)"assertion rb->freespace >= 0 failed!");
    }
    (*buffer->done)(socket,buffer);
    return;
  }
  if (sVar2 != -2) {
    if (sVar2 == -1) goto LAB_080bcc66;
    goto LAB_080bccf9;
  }
  psVar7 = socket->ops->done;
  puVar5 = (uint *)__errno_location();
  size = *puVar5;
  if (assert_failed == 0) {
    assert_failed = ZEXT14(size == 0xffffffff);
    if (size != 0xffffffff) goto LAB_080bce3a;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
    errline = 0x84;
    elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
    if (assert_failed == 0) goto LAB_080bce3a;
  }
  assert_failed = 0;
  size = 0xfffe795d;
LAB_080bce3a:
  (*psVar7)(socket,(connection_state)(ulonglong)size);
  return;
}



void write_select(socket *socket)

{
  code **ppcVar1;
  code *UNRECOVERED_JUMPTABLE;
  int __fd;
  socket_operation_T *psVar2;
  ssize_t sVar3;
  select_handler_T *read_func;
  ssize_t sVar4;
  int *piVar5;
  uint *puVar6;
  code *error_func;
  uint uVar7;
  
  ppcVar1 = (code **)socket->write_buffer;
  if (assert_failed != 0) {
LAB_080bd11e:
    assert_failed = 0;
    (*socket->ops->done)(socket,(connection_state)0xfffe795d);
    return;
  }
  assert_failed = ZEXT14(ppcVar1 == (code **)0x0);
  if (ppcVar1 == (code **)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
    errline = 0x2d8;
    elinks_internal((uchar *)"assertion wb != NULL failed: write socket has no buffer");
    if (assert_failed != 0) goto LAB_080bd11e;
  }
  assert_failed = 0;
  (*socket->ops->set_timeout)(socket,(connection_state)0x0);
  if (socket->ssl == (void *)0x0) {
    if ((assert_failed == 0) &&
       (UNRECOVERED_JUMPTABLE = ppcVar1[1], error_func = ppcVar1[2],
       assert_failed =
            ZEXT14(UNRECOVERED_JUMPTABLE == error_func ||
                   (int)(UNRECOVERED_JUMPTABLE + -(int)error_func) < 0),
       UNRECOVERED_JUMPTABLE == error_func || (int)(UNRECOVERED_JUMPTABLE + -(int)error_func) < 0))
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
      errline = 0x2ef;
      elinks_internal((uchar *)"assertion wb->length - wb->pos > 0 failed!");
    }
    UNRECOVERED_JUMPTABLE = ppcVar1[2];
    error_func = ppcVar1[1];
    __fd = socket->fd;
    do {
      sVar4 = write(__fd,UNRECOVERED_JUMPTABLE + 0xc + (int)ppcVar1,
                    (size_t)(error_func + -(int)UNRECOVERED_JUMPTABLE));
      if (sVar4 != -1) {
        if (sVar4 == 0) goto LAB_080bd240;
        sVar3 = -1;
        if (-1 < sVar4) {
          sVar3 = sVar4;
        }
        goto LAB_080bd04d;
      }
      piVar5 = __errno_location();
    } while (*piVar5 == 4);
LAB_080bd1d7:
    psVar2 = socket->ops->retry;
    piVar5 = __errno_location();
    (*psVar2)(socket,(connection_state)CONCAT44(*piVar5,0xffffffff));
    return;
  }
  sVar3 = ssl_write(socket,(uchar *)(ppcVar1[2] + 0xc + (int)ppcVar1),
                    (int)(ppcVar1[1] + -(int)ppcVar1[2]));
LAB_080bd04d:
  if (sVar3 != -2) {
    if (sVar3 != -1) {
      if (sVar3 != -5) {
        if (sVar3 < 0) {
          return;
        }
        UNRECOVERED_JUMPTABLE = ppcVar1[2];
        ppcVar1[2] = UNRECOVERED_JUMPTABLE + sVar3;
        if (UNRECOVERED_JUMPTABLE + sVar3 != ppcVar1[1]) {
          return;
        }
        UNRECOVERED_JUMPTABLE = *ppcVar1;
        if ((*(byte *)&socket->field_0x24 & 0x10) == 0) {
          set_handlers(socket->fd,(select_handler_T *)0x0,(select_handler_T *)0x0,
                       (select_handler_T *)0x0,(void *)0x0);
        }
        else {
          read_func = get_handler(socket->fd,SELECT_HANDLER_READ);
          error_func = (select_handler_T *)0x0;
          if (read_func != (select_handler_T *)0x0) {
            error_func = exception;
          }
          set_handlers(socket->fd,read_func,(select_handler_T *)0x0,error_func,socket);
        }
        if (socket->write_buffer != (void *)0x0) {
          mem_free(socket->write_buffer);
        }
        socket->write_buffer = (void *)0x0;
                    // WARNING: Could not recover jumptable at 0x080bd0e9. Too many branches
                    // WARNING: Treating indirect jump as call
        (*UNRECOVERED_JUMPTABLE)();
        return;
      }
LAB_080bd240:
      if (assert_failed == 0) {
        uVar7 = 0xfffe795a;
      }
      else {
        uVar7 = 0xfffe795d;
      }
      assert_failed = 0;
      (*socket->ops->retry)(socket,(connection_state)(ulonglong)uVar7);
      return;
    }
    goto LAB_080bd1d7;
  }
  psVar2 = socket->ops->done;
  puVar6 = (uint *)__errno_location();
  uVar7 = *puVar6;
  if (assert_failed == 0) {
    assert_failed = ZEXT14(uVar7 == 0xffffffff);
    if (uVar7 != 0xffffffff) goto LAB_080bd226;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
    errline = 0x84;
    elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
    if (assert_failed == 0) goto LAB_080bd226;
  }
  assert_failed = 0;
  uVar7 = 0xfffe795d;
LAB_080bd226:
  (*psVar2)(socket,(connection_state)(ulonglong)uVar7);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void connect_socket(socket *csocket,connection_state state)

{
  int iVar1;
  connect_info *name;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  sockaddr_storage *psVar6;
  bool bVar7;
  bool bVar8;
  ushort uVar9;
  int *piVar10;
  int __domain;
  int **ppiVar11;
  int iVar12;
  int iVar13;
  uint uVar14;
  uchar *name_00;
  uchar *name_01;
  int iVar15;
  socket_operation_T *psVar16;
  in6_addr *piVar17;
  sockaddr_in6 *psVar18;
  uint32_t *puVar19;
  int in_GS_OFFSET;
  bool bVar20;
  bool bVar21;
  byte bVar22;
  socklen_t local_c4;
  connection_basic_state local_88;
  int local_84;
  int local_60;
  int local_58;
  undefined4 local_54;
  undefined4 local_50;
  int **local_44;
  sockaddr_in6 *local_40;
  sockaddr_in6 addr;
  
  bVar22 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  local_88 = state.basic;
  local_84 = state.syserr;
  name = csocket->connect_info;
  iVar2 = name->triedno;
  piVar10 = get_opt_(cmdline_options,(uchar *)name);
  iVar3 = *piVar10;
  piVar10 = get_opt_(config_options,name_00);
  iVar4 = *piVar10;
  piVar10 = get_opt_(config_options,name_01);
  iVar5 = *piVar10;
  (*csocket->ops->set_state)(csocket,state);
  if (-1 < csocket->fd) {
    close_socket(csocket);
  }
  local_58 = name->triedno + 1;
  if (name->addrno != local_58 && local_58 <= name->addrno) {
    iVar15 = local_58 * 0x80;
    bVar8 = false;
    bVar7 = false;
    local_60 = 0;
LAB_080bd453:
    psVar6 = name->addr;
    addr._0_4_ = *(uint *)((int)&psVar6->ss_family + iVar15);
    addr.sin6_flowinfo = *(uint *)((int)&psVar6->__ss_align + iVar15);
    addr.sin6_addr.__in6_u._0_4_ = *(int *)(psVar6->__ss_padding + iVar15);
    addr.sin6_addr.__in6_u._4_4_ = *(int *)(psVar6->__ss_padding + iVar15 + 4);
    addr.sin6_addr.__in6_u._8_4_ = *(int *)(psVar6->__ss_padding + iVar15 + 8);
    addr.sin6_addr.__in6_u._12_4_ = *(int *)(psVar6->__ss_padding + iVar15 + 0xc);
    uVar14 = addr._0_4_ & 0xffff;
    addr.sin6_scope_id = *(uint32_t *)(psVar6->__ss_padding + iVar15 + 0x10);
    __domain = name->ip_family;
    name->triedno = name->triedno + 1;
    iVar13 = local_60;
    if (iVar3 == 0) goto LAB_080bd4b7;
    if (addr.sin6_family != 10) {
      if ((addr.sin6_flowinfo & 0xff) == 0x7f) goto LAB_080bd4b7;
      iVar12 = getifaddrs(&local_44);
      ppiVar11 = local_44;
      if (iVar12 != 0) goto LAB_080bd632;
      while (ppiVar11 != (int **)0x0) {
        piVar10 = ppiVar11[3];
        if ((piVar10 != (int *)0x0) && (*(short *)piVar10 == 2)) {
          bVar21 = piVar10 + 1 == (int *)0x0;
          iVar12 = 4;
          puVar19 = &addr.sin6_flowinfo;
          piVar10 = piVar10 + 1;
          do {
            if (iVar12 == 0) break;
            iVar12 = iVar12 + -1;
            bVar21 = *(char *)puVar19 == *(char *)piVar10;
            puVar19 = (uint32_t *)((int)puVar19 + (uint)bVar22 * -2 + 1);
            piVar10 = (int *)((int)piVar10 + (uint)bVar22 * -2 + 1);
          } while (bVar21);
          if (bVar21) goto LAB_080bd608;
        }
        ppiVar11 = (int **)*ppiVar11;
      }
LAB_080bd676:
      bVar21 = false;
      goto LAB_080bd613;
    }
    local_40 = &addr;
    if ((((addr.sin6_addr.__in6_u._0_4_ == 0) && (addr.sin6_addr.__in6_u._4_4_ == 0)) &&
        (addr.sin6_addr.__in6_u._8_4_ == 0)) && (addr.sin6_addr.__in6_u._12_4_ == 0x1000000))
    goto LAB_080bd4c1;
    iVar12 = getifaddrs(&local_44);
    ppiVar11 = local_44;
    if (iVar12 == 0) {
joined_r0x080bd5bb:
      if (ppiVar11 != (int **)0x0) {
        while (piVar10 = ppiVar11[3], piVar10 != (int *)0x0) {
          if (*(short *)piVar10 == 10) {
            iVar12 = 0x10;
            bVar21 = &local_40->sin6_addr == (in6_addr *)0x0;
            piVar17 = &local_40->sin6_addr;
            piVar10 = piVar10 + 2;
            goto code_r0x080bd5fe;
          }
          if (*(short *)piVar10 != 2) break;
          iVar12 = 4;
          bVar21 = (int *)0xfffffffb < piVar10;
          bVar20 = piVar10 + 1 == (int *)0x0;
          psVar18 = &addr;
          piVar10 = piVar10 + 1;
          do {
            if (iVar12 == 0) break;
            iVar12 = iVar12 + -1;
            bVar21 = *(byte *)&psVar18->sin6_family < *(byte *)piVar10;
            bVar20 = *(byte *)&psVar18->sin6_family == *(byte *)piVar10;
            psVar18 = (sockaddr_in6 *)((int)psVar18 + (uint)bVar22 * -2 + 1);
            piVar10 = (int *)((int)piVar10 + (uint)bVar22 * -2 + 1);
          } while (bVar20);
          if ((!bVar21 && !bVar20) == bVar21) goto LAB_080bd608;
          ppiVar11 = (int **)*ppiVar11;
          if (ppiVar11 == (int **)0x0) goto LAB_080bd676;
        }
        goto LAB_080bd5d6;
      }
      goto LAB_080bd676;
    }
    goto LAB_080bd632;
  }
  bVar21 = true;
  bVar8 = false;
  bVar7 = false;
LAB_080bd7ad:
  if (assert_failed == 0) {
    assert_failed = 0;
  }
  if (((bVar21) && (iVar3 != 0)) && (bVar7)) {
    psVar16 = csocket->ops->done;
LAB_080bd8c5:
    connection_state();
    (*psVar16)(csocket,(connection_state)CONCAT44(local_50,local_54));
  }
  else {
    if ((bVar8) || (name->triedno == iVar2)) {
      if ((bVar8) && (iVar2 == -1)) {
        if (assert_failed == 0) {
          local_88 = S_NO_FORCED_DNS;
        }
        else {
          local_88 = S_INTERNAL;
        }
        assert_failed = 0;
        local_84 = 0;
      }
    }
    else {
      piVar10 = __errno_location();
      local_84 = *piVar10;
      local_88 = S_ERRNO;
    }
    (*csocket->ops->retry)(csocket,(connection_state)CONCAT44(local_84,local_88));
  }
LAB_080bd823:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
  while( true ) {
    iVar12 = iVar12 + -1;
    bVar21 = piVar17->__in6_u[0] == *(byte *)piVar10;
    piVar17 = (in6_addr *)((int)piVar17 + (uint)bVar22 * -2 + 1);
    piVar10 = (int *)((int)piVar10 + (uint)bVar22 * -2 + 1);
    if (!bVar21) break;
code_r0x080bd5fe:
    if (iVar12 == 0) break;
  }
  if (bVar21) goto LAB_080bd608;
LAB_080bd5d6:
  ppiVar11 = (int **)*ppiVar11;
  goto joined_r0x080bd5bb;
LAB_080bd608:
  bVar21 = true;
LAB_080bd613:
  freeifaddrs(local_44);
  if (!bVar21) {
LAB_080bd632:
    bVar7 = true;
    goto LAB_080bd43d;
  }
LAB_080bd4b7:
  if (uVar14 == 10) {
LAB_080bd4c1:
    if ((iVar4 == 0) || ((__domain != 6 && (__domain != 0)))) {
LAB_080bd540:
      bVar8 = true;
      goto LAB_080bd43d;
    }
    __domain = 10;
  }
  else {
    if (uVar14 != 2) goto LAB_080bd43d;
    if ((iVar5 == 0) || ((__domain != 4 && (__domain != 0)))) goto LAB_080bd540;
    __domain = 2;
  }
  __domain = socket(__domain,1,6);
  if (__domain == -1) {
    piVar10 = __errno_location();
    if ((*piVar10 == 0) || (bVar8 = false, iVar13 = *piVar10, local_60 != 0)) {
      bVar8 = false;
      iVar13 = local_60;
    }
    goto LAB_080bd43d;
  }
  iVar13 = set_nonblocking_fd(__domain);
  if (iVar13 < 0) {
    piVar10 = __errno_location();
    iVar13 = *piVar10;
    if (iVar13 != 0) goto LAB_080bd77a;
LAB_080bd782:
    iVar13 = local_60;
  }
  else {
    csocket->fd = __domain;
    uVar9 = (ushort)name->port;
    addr._0_4_ = addr._0_4_ & 0xffff | (uint)(ushort)(uVar9 >> 8 | uVar9 << 8) << 0x10;
    if (uVar14 == 10) {
      *(byte *)&csocket->field_0x24 = *(byte *)&csocket->field_0x24 | 1;
      local_c4 = 0x1c;
    }
    else {
      *(byte *)&csocket->field_0x24 = *(byte *)&csocket->field_0x24 & 0xfe;
      local_c4 = 0x10;
    }
    iVar13 = connect(__domain,(sockaddr *)&addr,local_c4);
    if (iVar13 == 0) {
      complete_connect_socket(csocket,(uri *)0x0,(socket_connect_T)0x0);
      goto LAB_080bd823;
    }
    piVar10 = __errno_location();
    iVar13 = *piVar10;
    if (((iVar13 == 0xb) || (iVar13 == 0x72)) || (iVar13 == 0x73)) {
      set_handlers(__domain,(select_handler_T *)0x0,connected,dns_exception,csocket);
      psVar16 = csocket->ops->set_state;
      goto LAB_080bd8c5;
    }
    if (iVar13 == 0) goto LAB_080bd782;
LAB_080bd77a:
    if (local_60 != 0) goto LAB_080bd782;
  }
  close(__domain);
  bVar8 = false;
LAB_080bd43d:
  local_58 = local_58 + 1;
  iVar15 = iVar15 + 0x80;
  local_60 = iVar13;
  if (name->addrno == local_58 || name->addrno < local_58) goto LAB_080bd7a8;
  goto LAB_080bd453;
LAB_080bd7a8:
  bVar21 = iVar13 == 0;
  goto LAB_080bd7ad;
}



// WARNING: Exceeded maximum restarts with more pending

void dns_found(socket *socket,sockaddr_storage *addr,int addrlen)

{
  connect_info *pcVar1;
  sockaddr_storage *__dest;
  uint uVar2;
  socket_operation_T *UNRECOVERED_JUMPTABLE;
  
  pcVar1 = socket->connect_info;
  if (addr == (sockaddr_storage *)0x0) {
    UNRECOVERED_JUMPTABLE = socket->ops->done;
  }
  else {
    if ((assert_failed == 0) &&
       (assert_failed = ZEXT14(pcVar1 == (connect_info *)0x0), pcVar1 == (connect_info *)0x0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
      errline = 0xe9;
      elinks_internal((uchar *)"assertion connect_info failed!");
    }
    __dest = (sockaddr_storage *)mem_alloc(addrlen << 7);
    pcVar1->addr = __dest;
    if (__dest != (sockaddr_storage *)0x0) {
      memcpy(__dest,addr,addrlen << 7);
      pcVar1->addrno = addrlen;
      if (assert_failed == 0) {
        uVar2 = 2;
      }
      else {
        uVar2 = 0xfffe795d;
      }
      assert_failed = 0;
      connect_socket(socket,(connection_state)(ulonglong)uVar2);
      return;
    }
    UNRECOVERED_JUMPTABLE = socket->ops->done;
  }
  connection_state();
                    // WARNING: Could not recover jumptable at 0x080bdaa0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*UNRECOVERED_JUMPTABLE)();
  return;
}



void timeout_socket(socket *socket)

{
  socket_operation_T *psVar1;
  uint uVar2;
  undefined4 local_14;
  undefined4 local_10;
  
  if (socket->connect_info == (connect_info *)0x0) {
    psVar1 = socket->ops->retry;
    connection_state();
    (*psVar1)(socket,(connection_state)CONCAT44(local_10,local_14));
    return;
  }
  if (socket->connect_info->dnsquery == (void *)0x0) {
    if (assert_failed == 0) {
      uVar2 = 0xfffe7956;
    }
    else {
      uVar2 = 0xfffe795d;
    }
    assert_failed = 0;
    connect_socket(socket,(connection_state)(ulonglong)uVar2);
    if (socket->connect_info == (connect_info *)0x0) {
      return;
    }
    psVar1 = socket->ops->set_timeout;
    if (assert_failed == 0) {
      uVar2 = 0;
      goto LAB_080bdb00;
    }
  }
  else {
    psVar1 = socket->ops->done;
    if (assert_failed == 0) {
      uVar2 = 0xfffe7956;
      goto LAB_080bdb00;
    }
  }
  uVar2 = 0xfffe795d;
LAB_080bdb00:
  assert_failed = 0;
  (*psVar1)(socket,(connection_state)(ulonglong)uVar2);
  return;
}



void dns_exception(socket *socket)

{
  uint uVar1;
  
  if (assert_failed == 0) {
    uVar1 = 0xfffe795e;
  }
  else {
    uVar1 = 0xfffe795d;
  }
  assert_failed = 0;
  connect_socket(socket,(connection_state)(ulonglong)uVar1);
  return;
}



void connected(socket *socket)

{
  int iVar1;
  int *piVar2;
  undefined4 uVar3;
  bool bVar4;
  socklen_t local_14;
  int local_10 [2];
  
  local_10[0] = 0;
  local_14 = 4;
  bVar4 = socket->connect_info == (connect_info *)0x0;
  assert_failed = ZEXT14(bVar4);
  if (bVar4) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
    errline = 0x1fa;
    elinks_internal((uchar *)"assertion socket->connect_info != NULL failed: Lost connect_info!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  iVar1 = getsockopt(socket->fd,1,4,local_10,&local_14);
  if (iVar1 == 0) {
    if (9999 < local_10[0]) {
      local_10[0] = local_10[0] + -10000;
    }
    iVar1 = local_10[0];
    if (local_10[0] == 0) {
      if (assert_failed == 0) {
        assert_failed = 0;
        complete_connect_socket(socket,(uri *)0x0,(socket_connect_T)0x0);
        return;
      }
      goto LAB_080bdd70;
    }
  }
  else {
    piVar2 = __errno_location();
    iVar1 = *piVar2;
    if (iVar1 == 0) {
      if (assert_failed == 0) {
        assert_failed = 0;
        uVar3 = 0xfffe7954;
        goto LAB_080bdcab;
      }
LAB_080bdd70:
      assert_failed = 0;
      uVar3 = 0xfffe795d;
      goto LAB_080bdcab;
    }
  }
  uVar3 = 0xffffffff;
LAB_080bdcab:
  connect_socket(socket,(connection_state)CONCAT44(iVar1,uVar3));
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void make_connection(socket *socket,uri *uri,socket_connect_T connect_done,int no_cache)

{
  byte bVar1;
  uchar *name;
  connect_info *pcVar2;
  int iVar3;
  dns_result dVar4;
  blacklist_flags bVar5;
  socket_operation_T *UNRECOVERED_JUMPTABLE;
  uint uVar6;
  
  name = get_uri_string(uri,URI_DNS_HOST);
  if (assert_failed == 0) {
    uVar6 = 0;
  }
  else {
    uVar6 = 0xfffe795d;
  }
  assert_failed = 0;
  (*socket->ops->set_timeout)(socket,(connection_state)(ulonglong)uVar6);
  if (name == (uchar *)0x0) {
    UNRECOVERED_JUMPTABLE = socket->ops->retry;
  }
  else {
    pcVar2 = init_connection_info(uri,socket,connect_done);
    if (pcVar2 == (connect_info *)0x0) {
      mem_free(name);
      UNRECOVERED_JUMPTABLE = socket->ops->retry;
      connection_state();
      goto LAB_080bdedb;
    }
    socket->connect_info = pcVar2;
    iVar3 = get_protocol_need_ssl(uri->protocol);
    bVar1 = *(byte *)&socket->field_0x24;
    *(byte *)&socket->field_0x24 = bVar1 & 0xfd | ((byte)iVar3 & 1) * '\x02';
    if ((bVar1 & 8) == 0) {
      bVar5 = get_blacklist_flags(uri);
      *(byte *)&socket->field_0x24 =
           *(byte *)&socket->field_0x24 & 0xfb | (byte)((bVar5 >> 2 & 1) << 2) | 8;
    }
    dVar4 = find_host(name,&pcVar2->dnsquery,dns_found,socket,no_cache);
    mem_free(name);
    if (dVar4 != DNS_ASYNC) {
      return;
    }
    UNRECOVERED_JUMPTABLE = socket->ops->set_state;
  }
  assert_failed = 0;
LAB_080bdedb:
                    // WARNING: Could not recover jumptable at 0x080bdee2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*UNRECOVERED_JUMPTABLE)();
  return;
}



void done_state_message(void)

{
  list_head_elinks **pplVar1;
  list_head_elinks *p;
  list_head_elinks *plVar2;
  list_head_elinks *plVar3;
  bool bVar4;
  
  plVar3 = (list_head_elinks *)strerror_buf.next;
  if ((list_head_elinks *)strerror_buf.next != &strerror_buf) {
    do {
      plVar3 = (list_head_elinks *)plVar3->next;
    } while (plVar3 != &strerror_buf);
  }
  plVar2 = (list_head_elinks *)strerror_buf.prev;
  if ((list_head_elinks *)strerror_buf.prev != plVar3) {
    do {
      pplVar1 = (list_head_elinks **)&plVar2->prev;
      plVar2 = *pplVar1;
    } while (*pplVar1 != plVar3);
  }
  plVar2 = *(list_head_elinks **)strerror_buf.next;
  p = (list_head_elinks *)strerror_buf.next;
  if ((list_head_elinks *)strerror_buf.next != plVar3) {
    do {
      plVar2->prev = p->prev;
      *(void **)p->prev = p->next;
      mem_free(p);
      bVar4 = plVar2 != plVar3;
      p = plVar2;
      plVar2 = (list_head_elinks *)plVar2->next;
    } while (bVar4);
  }
  return;
}



uchar * get_state_message(connection_state state,terminal *term)

{
  void *pvVar1;
  int cp_index;
  uchar *codeset;
  size_t n2;
  void **ppvVar2;
  void **__dest;
  list_head_elinks *plVar3;
  
  if ((term != (terminal *)0x0) &&
     (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
    codeset = get_cp_mime_name(cp_index);
    bind_textdomain_codeset("elinks",codeset);
    current_charset = cp_index;
  }
  __dest = (void **)gettext((uchar *)"Unknown error");
  if (state.basic == S_ERRNO) {
    codeset = (uchar *)strerror(state.syserr);
    if ((codeset != (uchar *)0x0) && (*codeset != '\0')) {
      n2 = strlen((char *)codeset);
      plVar3 = (list_head_elinks *)strerror_buf.next;
      if ((list_head_elinks *)strerror_buf.next != &strerror_buf) {
        do {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.c";
          errline = 0xb0;
          cp_index = elinks_strlcmp((uchar *)(plVar3 + 1),0xffffffff,codeset,n2);
          if (cp_index == 0) {
            return (uchar *)(plVar3 + 1);
          }
          plVar3 = (list_head_elinks *)plVar3->next;
        } while (plVar3 != &strerror_buf);
      }
      ppvVar2 = (void **)mem_calloc(1,n2 + 0xc);
      if (ppvVar2 != (void **)0x0) {
        __dest = ppvVar2 + 2;
        memcpy(__dest,codeset,n2 + 1);
        pvVar1 = plVar3->next;
        *(list_head_elinks **)(ppvVar2 + 1) = plVar3;
        *ppvVar2 = pvVar1;
        *(void ***)&plVar3->next = ppvVar2;
        *(void ***)((int)*ppvVar2 + 4) = ppvVar2;
      }
    }
  }
  else {
    cp_index = 0;
    ppvVar2 = (void **)"Waiting in queue";
    if (state.basic != S_WAIT) {
      do {
        cp_index = cp_index + 1;
        if ((void **)msg_dsc[cp_index].msg == (void **)0x0) {
          return (uchar *)__dest;
        }
        ppvVar2 = (void **)msg_dsc[cp_index].msg;
      } while (msg_dsc[cp_index].n != state.basic);
    }
    __dest = ppvVar2;
    if (*(char *)__dest != '\0') {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext((uchar *)__dest);
      return codeset;
    }
  }
  return (uchar *)__dest;
}



int ssl_close(socket *socket)

{
  gnutls_bye(*(undefined4 *)socket->ssl,0);
  done_ssl_connection(socket);
  return 0;
}



ssize_t ssl_read(socket *socket,uchar *data,int len)

{
  ssize_t sVar1;
  int *piVar2;
  
  sVar1 = gnutls_record_recv(*(undefined4 *)socket->ssl,data,len);
  if (0 < sVar1) {
    return sVar1;
  }
  if (sVar1 != -0x25) {
    if ((sVar1 == -0x34) || (sVar1 == -0x1c)) {
      return -3;
    }
    if (sVar1 == 0) {
      return -4;
    }
    if (sVar1 != -0x36) {
      piVar2 = __errno_location();
      *piVar2 = -0x186b2;
      return -2;
    }
  }
  return -1;
}



ssize_t ssl_write(socket *socket,uchar *data,int len)

{
  ssize_t sVar1;
  int *piVar2;
  
  sVar1 = gnutls_record_send(*(undefined4 *)socket->ssl,data,len);
  if (0 < sVar1) {
    return sVar1;
  }
  if ((sVar1 != -0x34) && (sVar1 != -0x1c)) {
    if (sVar1 == 0) {
      return -5;
    }
    if (sVar1 != -0x35) {
      piVar2 = __errno_location();
      *piVar2 = -0x186b2;
      return -2;
    }
  }
  return -1;
}



connection_state connection_state(void)

{
  int *in_EAX;
  int in_EDX;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(in_EDX == -1);
    if (in_EDX == -1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
      errline = 0x84;
      elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
      if (assert_failed != 0) goto LAB_080be328;
    }
    in_EAX[1] = 0;
    *in_EAX = in_EDX;
    return (connection_state)CONCAT44(in_EDX,in_EAX);
  }
LAB_080be328:
  assert_failed = 0;
  in_EAX[1] = 0;
  *in_EAX = -0x186a3;
  return (connection_state)CONCAT44(0xfffe795d,in_EAX);
}



void ssl_want_read(socket *socket)

{
  socket_operation_T *psVar1;
  int *piVar2;
  int iVar3;
  uint uVar4;
  undefined8 uVar5;
  char *local_28;
  undefined4 local_14;
  undefined4 local_10;
  
  if ((*(byte *)&socket->field_0x24 & 4) != 0) {
    gnutls_protocol_set_priority(*(undefined4 *)socket->ssl,protocol_priority);
  }
  uVar5 = gnutls_handshake(*(undefined4 *)socket->ssl);
  iVar3 = (int)uVar5;
  if (iVar3 != -0x1c) {
    if (iVar3 == 0) {
      local_28 = "connection.ssl.cert_verify";
      piVar2 = get_opt_(config_options,(uchar *)((ulonglong)uVar5 >> 0x20));
      if ((*piVar2 != 0) &&
         (iVar3 = gnutls_certificate_verify_peers(*(undefined4 *)socket->ssl,local_28), iVar3 != 0))
      {
        psVar1 = socket->ops->retry;
        connection_state();
        (*psVar1)(socket,(connection_state)CONCAT44(local_10,local_14));
        return;
      }
      complete_connect_socket(socket,(uri *)0x0,(socket_connect_T)0x0);
    }
    else {
      if (iVar3 != -0x34) {
        *(byte *)&socket->field_0x24 =
             *(byte *)&socket->field_0x24 & 0xfb |
             (byte)((((uint)(*(byte *)&socket->field_0x24 >> 2) ^ 1) & 1) << 2);
        if (assert_failed == 0) {
          uVar4 = 0xfffe794e;
        }
        else {
          uVar4 = 0xfffe795d;
        }
        assert_failed = 0;
        (*socket->ops->retry)(socket,(connection_state)(ulonglong)uVar4);
        return;
      }
    }
  }
  return;
}



int ssl_connect(socket *socket)

{
  socket_operation_T *psVar1;
  int iVar2;
  uint uVar3;
  int *piVar4;
  undefined8 uVar5;
  char *local_38;
  undefined4 local_14;
  undefined4 local_10;
  
  iVar2 = init_ssl_connection(socket);
  if (iVar2 == -0x186b2) {
    psVar1 = socket->ops->done;
    connection_state();
    (*psVar1)(socket,(connection_state)CONCAT44(local_10,local_14));
    return -1;
  }
  if ((*(byte *)&socket->field_0x24 & 4) != 0) {
    gnutls_protocol_set_priority(*(undefined4 *)socket->ssl,protocol_priority);
  }
  gnutls_transport_set_ptr(*(undefined4 *)socket->ssl,socket->fd);
  uVar5 = gnutls_handshake(*(undefined4 *)socket->ssl);
  iVar2 = (int)uVar5;
  if (iVar2 != -0x1c) {
    if (iVar2 == 0) {
      local_38 = "connection.ssl.cert_verify";
      piVar4 = get_opt_(config_options,(uchar *)((ulonglong)uVar5 >> 0x20));
      if ((*piVar4 == 0) ||
         (iVar2 = gnutls_certificate_verify_peers(*(undefined4 *)socket->ssl,local_38), iVar2 == 0))
      {
        return 0;
      }
    }
    else {
      if (iVar2 == -0x34) goto LAB_080be578;
      if (iVar2 != 0) {
        *(byte *)&socket->field_0x24 =
             *(byte *)&socket->field_0x24 & 0xfb |
             (byte)((((uint)(*(byte *)&socket->field_0x24 >> 2) ^ 1) & 1) << 2);
      }
    }
    if (assert_failed == 0) {
      uVar3 = 0xfffe794e;
    }
    else {
      uVar3 = 0xfffe795d;
    }
    assert_failed = 0;
    connect_socket(socket,(connection_state)(ulonglong)uVar3);
    return -1;
  }
LAB_080be578:
  if (assert_failed == 0) {
    uVar3 = 3;
  }
  else {
    uVar3 = 0xfffe795d;
  }
  assert_failed = 0;
  (*socket->ops->set_state)(socket,(connection_state)(ulonglong)uVar3);
  set_handlers(socket->fd,ssl_want_read,(select_handler_T *)0x0,dns_exception,socket);
  return -1;
}



void done_gnutls(module *module)

{
  if (xcred != (gnutls_certificate_credentials_t)0x0) {
    gnutls_certificate_free_credentials(xcred);
  }
  if (anon_cred != (gnutls_anon_client_credentials_t)0x0) {
    gnutls_anon_free_client_credentials(anon_cred);
  }
  gnutls_global_deinit();
  return;
}



void init_gnutls(module *module)

{
  char *pcVar1;
  char **ppcVar2;
  int iVar3;
  undefined4 uVar4;
  undefined8 uVar5;
  char *local_18;
  
  uVar5 = gnutls_global_init();
  local_18 = "connection.ssl.trusted_ca_file";
  ppcVar2 = (char **)get_opt_(config_options,(uchar *)((ulonglong)uVar5 >> 0x20));
  pcVar1 = *ppcVar2;
  if ((int)uVar5 < 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/ssl/ssl.c";
    errline = 0x81;
    local_18 = (char *)gnutls_strerror((int)uVar5,local_18);
    elinks_internal((uchar *)"GNUTLS init failed: %s",local_18);
    iVar3 = gnutls_anon_allocate_client_credentials(&anon_cred);
  }
  else {
    iVar3 = gnutls_anon_allocate_client_credentials(&anon_cred);
  }
  if (iVar3 < 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/ssl/ssl.c";
    errline = 0x85;
    local_18 = (char *)gnutls_strerror(iVar3,local_18);
    elinks_internal((uchar *)"GNUTLS anon credentials alloc failed: %s",local_18);
  }
  iVar3 = gnutls_certificate_allocate_credentials(&xcred);
  if (iVar3 < 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/ssl/ssl.c";
    errline = 0x8a;
    uVar4 = gnutls_strerror(iVar3,local_18);
    elinks_internal((uchar *)"GNUTLS X509 credentials alloc failed: %s",uVar4);
  }
  if (*pcVar1 != '\0') {
    gnutls_certificate_set_x509_trust_file(xcred,pcVar1,1);
    gnutls_certificate_set_verify_flags(xcred,2);
  }
  return;
}



uchar * get_ssl_connection_cipher(socket *socket)

{
  undefined4 *puVar1;
  string *psVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  uchar *puVar9;
  string str;
  
  puVar1 = (undefined4 *)socket->ssl;
  psVar2 = init_string(&str);
  puVar9 = (uchar *)0x0;
  if (psVar2 != (string *)0x0) {
    uVar3 = gnutls_compression_get(*puVar1);
    uVar3 = gnutls_compression_get_name(uVar3);
    uVar4 = gnutls_certificate_type_get(*puVar1);
    uVar4 = gnutls_certificate_type_get_name(uVar4);
    uVar5 = gnutls_mac_get(*puVar1);
    uVar5 = gnutls_mac_get_name(uVar5);
    uVar6 = gnutls_cipher_get(*puVar1);
    uVar6 = gnutls_cipher_get_name(uVar6);
    uVar7 = gnutls_kx_get(*puVar1);
    uVar7 = gnutls_kx_get_name(uVar7);
    uVar8 = gnutls_protocol_get_version(*puVar1);
    uVar8 = gnutls_protocol_get_name(uVar8);
    add_format_to_string
              (&str,(uchar *)"%s - %s - %s - %s - %s (compr: %s)",uVar8,uVar7,uVar6,uVar5,uVar4,
               uVar3);
    puVar9 = str.source;
  }
  return puVar9;
}



void done_ssl_connection(socket *socket)

{
  undefined4 *p;
  
  p = (undefined4 *)socket->ssl;
  if (p != (undefined4 *)0x0) {
    gnutls_deinit(*p);
    mem_free(p);
    socket->ssl = (void *)0x0;
  }
  return;
}



int init_ssl_connection(socket *socket)

{
  undefined4 *p;
  int iVar1;
  
  p = (undefined4 *)mem_alloc(4);
  if (p == (undefined4 *)0x0) {
    return -0x186b2;
  }
  iVar1 = gnutls_init(p,2);
  if (-1 < iVar1) {
    iVar1 = gnutls_credentials_set(*p,2,anon_cred);
    if (-1 < iVar1) {
      iVar1 = gnutls_credentials_set(*p,1,xcred);
      if ((-1 < iVar1) &&
         (iVar1 = gnutls_priority_set_direct(*p,"NORMAL:-CTYPE-OPENPGP",0), iVar1 == 0)) {
        gnutls_cipher_set_priority(*p,cipher_priority);
        gnutls_kx_set_priority(*p,kx_priority);
        *(undefined4 **)&socket->ssl = p;
        return -100000;
      }
      gnutls_deinit(*p);
      mem_free(p);
      return -0x186b2;
    }
    gnutls_deinit(*p);
  }
  mem_free(p);
  return -0x186b2;
}



int can_open_in_new(terminal *term)

{
  int iVar1;
  open_in_new *poVar2;
  uint uVar3;
  uint uVar4;
  
  poVar2 = open_in_new;
  uVar3 = 2;
  iVar1 = 0;
  do {
    poVar2 = poVar2 + 1;
    uVar4 = uVar3 & term->environment;
    uVar3 = poVar2->env;
    iVar1 = (iVar1 + 1) - (uint)(uVar4 == 0);
  } while (uVar3 != 0);
  return iVar1;
}



void open_new_window(terminal *term,uchar *exe_name,term_env_type environment,uchar *param)

{
  uint uVar1;
  open_in_new *poVar2;
  uchar *path;
  uchar *puVar3;
  int iVar4;
  uchar *str;
  
  iVar4 = 0;
  poVar2 = open_in_new;
  uVar1 = environment & 2U;
  do {
    poVar2 = poVar2 + 1;
    if (uVar1 != 0) {
      path = open_in_new[iVar4].command;
LAB_080beaa6:
      if ((assert_failed == 0) &&
         (assert_failed = ZEXT14(path == (uchar *)0x0), path == (uchar *)0x0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/osdep/newwin.c";
        errline = 0x4a;
        elinks_internal((uchar *)"assertion command failed!");
      }
      if ((environment & 2U) == 0) {
        str = path;
        if ((((environment & 0x20U) != 0) &&
            (str = (uchar *)getenv("ELINKS_TWTERM"), str == (uchar *)0x0)) &&
           (puVar3 = (uchar *)getenv("LINKS_TWTERM"), str = path, puVar3 != (uchar *)0x0)) {
          str = puVar3;
        }
      }
      else {
        str = (uchar *)getenv("ELINKS_XTERM");
        if ((str == (uchar *)0x0) &&
           (puVar3 = (uchar *)getenv("LINKS_XTERM"), str = path, puVar3 != (uchar *)0x0)) {
          str = puVar3;
        }
      }
      path = straconcat(str,&DAT_08134f9c,exe_name,&DAT_08134f9c,param,0);
      if (path != (uchar *)0x0) {
        exec_on_terminal(term,path,"",TERM_EXEC_NEWWIN);
        mem_free(path);
        return;
      }
      return;
    }
    iVar4 = iVar4 + 1;
    if (poVar2->env == 0) {
      path = (uchar *)0x0;
      goto LAB_080beaa6;
    }
    uVar1 = environment & poVar2->env;
  } while( true );
}



void sigwinch(void *s)

{
                    // WARNING: Could not recover jumptable at 0x080bebea. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)s)();
  return;
}



void set_bin(int fd)

{
  return;
}



int resize_window(int width,int height,int old_width,int old_height)

{
  return -1;
}



void want_draw(void)

{
  return;
}



void done_draw(void)

{
  return;
}



int get_output_handle(void)

{
  return 1;
}



void terminate_osdep(void)

{
  return;
}



void block_stdin(void)

{
  return;
}



void unblock_stdin(void)

{
  return;
}



void elinks_cfmakeraw(termios *t)

{
  t->c_iflag = t->c_iflag & 0xfffffe14;
  t->c_oflag = t->c_oflag & 0xfffffffe;
  t->c_lflag = t->c_lflag & 0xffff7fb4;
  t->c_cc[6] = '\x01';
  t->c_cc[5] = '\0';
  return;
}



int can_resize_window(int environment)

{
  return (uint)((environment & 10U) != 0);
}



int can_open_os_shell(int environment)

{
  return 1;
}



void set_highpri(void)

{
  return;
}



uchar * get_system_str(int xwin)

{
  char *pcVar1;
  
  pcVar1 = "unix-xwin";
  if (xwin == 0) {
    pcVar1 = "unix";
  }
  return (uchar *)pcVar1;
}



void init_osdep(void)

{
  setlocale(6,"");
  return;
}



int get_ctl_handle(void)

{
  int fd;
  int iVar1;
  int iVar2;
  
  iVar1 = isatty(0);
  iVar2 = 0;
  if ((iVar1 == 0) && (iVar2 = fd, fd < 0)) {
    iVar2 = open64("/dev/tty",0);
    return iVar2;
  }
  return iVar2;
}



int get_input_handle(void)

{
  int iVar1;
  
  iVar1 = get_ctl_handle();
  return iVar1;
}



uchar * get_window_title(void)

{
  uchar *puVar1;
  
  puVar1 = stracpy("");
  return puVar1;
}



uchar * get_clipboard_text(void)

{
  uchar *src;
  
  src = clipboard;
  if (clipboard == (uchar *)0x0) {
    src = "";
  }
  src = stracpy(src);
  return src;
}



int exe(uchar *path)

{
  int iVar1;
  
  iVar1 = system((char *)path);
  return iVar1;
}



int is_xterm(void)

{
  int xt;
  char *pcVar1;
  char *pcVar2;
  uint uVar3;
  
  if (xt != -1) {
    return xt;
  }
  pcVar1 = getenv("DISPLAY");
  pcVar2 = getenv("WINDOWID");
  if ((pcVar2 == (char *)0x0) || (*pcVar2 == '\0')) {
    pcVar2 = getenv("KONSOLE_DCOP_SESSION");
  }
  if (((pcVar1 == (char *)0x0) || (pcVar2 == (char *)0x0)) || (*pcVar1 == '\0')) {
    uVar3 = 0;
  }
  else {
    uVar3 = (uint)(*pcVar2 != '\0');
  }
  return uVar3;
}



int is_gnuscreen(void)

{
  int screen;
  char *pcVar1;
  
  if (screen != -1) {
    return screen;
  }
  pcVar1 = getenv("STY");
  return (uint)(pcVar1 != (char *)0x0);
}



void set_window_title(uchar *title,int codepage)

{
  uchar *puVar1;
  uint uVar2;
  uchar *puVar3;
  int iVar4;
  string *psVar5;
  size_t sVar6;
  unicode_val_T uVar7;
  uint uVar8;
  uchar *puVar9;
  uint size;
  uchar *__src;
  uchar *__n;
  string filtered;
  uchar *local_20 [4];
  
  iVar4 = is_xterm();
  if (((iVar4 != 0) || (iVar4 = is_gnuscreen(), iVar4 != 0)) &&
     (psVar5 = init_string(&filtered), psVar5 != (string *)0x0)) {
    if (title != (uchar *)0x0) {
      local_20[0] = title;
      sVar6 = strlen((char *)title);
      puVar3 = title;
LAB_080beed8:
      __src = puVar3;
      uVar7 = cp_to_unicode(codepage,local_20,title + sVar6);
      if (uVar7 != 0xfffffffd) {
        __n = local_20[0] + -(int)__src;
        puVar3 = local_20[0];
        if ((0x20 < uVar7 - 0x7f) && (puVar3 = local_20[0], 0x1f < uVar7)) {
          if (0x254 < (int)(__n + filtered.length)) {
            add_to_string(&filtered,"...");
            goto LAB_080befbb;
          }
          if (assert_failed != 0) {
LAB_080bf038:
            assert_failed = 0;
            puVar3 = local_20[0];
            goto LAB_080beed8;
          }
          if ((__src == (uchar *)0x0) || ((int)__n < 0)) {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
            errline = 0xff;
            elinks_internal((uchar *)
                            "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                           );
            if (assert_failed != 0) goto LAB_080bf038;
          }
          else {
            assert_failed = 0;
          }
          puVar3 = local_20[0];
          if (__n != (uchar *)0x0) {
            puVar1 = __n + filtered.length;
            uVar2 = filtered.length + 0xffU >> 8;
            uVar8 = filtered.length + 0xffU & 0xffffff00;
            size = (uint)(puVar1 + 0x100) & 0xffffff00;
            if (uVar8 <= size && size + uVar2 * -0x100 != 0) {
              puVar9 = (uchar *)mem_realloc(filtered.source,size);
              puVar3 = local_20[0];
              if (puVar9 == (uchar *)0x0) goto LAB_080beed8;
              filtered.source = puVar9;
              memset(puVar9 + uVar8,0,size + uVar2 * -0x100);
            }
            puVar3 = local_20[0];
            if (filtered.source != (uchar *)0x0) {
              memcpy(filtered.source + filtered.length,__src,(size_t)__n);
              filtered.source[(int)puVar1] = '\0';
              puVar3 = local_20[0];
              filtered.length = (int)puVar1;
            }
          }
        }
        goto LAB_080beed8;
      }
    }
LAB_080befbb:
    __printf_chk(1,&DAT_08131e7e,filtered.source);
    fflush(stdout);
    done_string(&filtered);
  }
  return;
}



void set_clipboard_text(uchar *data)

{
  int iVar1;
  string *psVar2;
  size_t len;
  string str;
  
  iVar1 = is_gnuscreen();
  if (iVar1 != 0) {
    psVar2 = init_string(&str);
    if (psVar2 == (string *)0x0) {
      return;
    }
    add_to_string(&str,(uchar *)"screen -X register . ");
    len = strlen((char *)data);
    add_shell_quoted_to_string(&str,data,len);
    if (str.length != 0) {
      system((char *)str.source);
    }
    if (str.source != (uchar *)0x0) {
      done_string(&str);
    }
  }
  if (clipboard != (uchar *)0x0) {
    free(clipboard);
  }
  clipboard = (uchar *)__strdup(data);
  return;
}



int is_twterm(void)

{
  int tw;
  char *pcVar1;
  
  if (tw != -1) {
    return tw;
  }
  pcVar1 = getenv("TWDISPLAY");
  return (uint)(pcVar1 != (char *)0x0);
}



int get_system_env(void)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  
  iVar1 = is_xterm();
  iVar2 = is_twterm();
  uVar3 = ~-(uint)(iVar1 == 0) & 2;
  if (iVar2 != 0) {
    uVar3 = uVar3 | 0x20;
  }
  iVar1 = is_gnuscreen();
  if (iVar1 != 0) {
    uVar3 = uVar3 | 4;
  }
  return uVar3 | 1;
}



uchar * get_shell(void)

{
  uchar *puVar1;
  
  puVar1 = (uchar *)getenv("SHELL");
  if ((puVar1 == (uchar *)0x0) || (*puVar1 == '\0')) {
    puVar1 = "/bin/sh";
  }
  return puVar1;
}



int c_pipe(int *fd)

{
  int iVar1;
  
  iVar1 = pipe(fd);
  return iVar1;
}



void unhandle_terminal_resize(int fd)

{
  install_signal_handler(0x1c,(anon_subr_void_void_ptr *)0x0,(void *)0x0,0);
  return;
}



void handle_terminal_resize(int fd,anon_subr_void *fn)

{
  install_signal_handler(0x1c,sigwinch,fn,0);
  return;
}



void set_cwd(uchar *path)

{
  int iVar1;
  int *piVar2;
  
  if (path != (uchar *)0x0) {
    do {
      iVar1 = chdir((char *)path);
      if (iVar1 == 0) {
        return;
      }
      piVar2 = __errno_location();
    } while (*piVar2 == 4);
  }
  return;
}



uchar * get_cwd(void)

{
  uchar *p;
  char *pcVar1;
  int *piVar2;
  size_t size;
  
  size = 0x80;
  do {
    p = (uchar *)mem_alloc(size);
    while( true ) {
      if ((p == (uchar *)0x0) || (pcVar1 = getcwd((char *)p,size), pcVar1 != (char *)0x0)) {
        return p;
      }
      mem_free(p);
      piVar2 = __errno_location();
      if (*piVar2 == 4) break;
      if (*piVar2 != 0x22) {
        return (uchar *)0x0;
      }
      size = size + 0x80;
      p = (uchar *)mem_alloc(size);
    }
  } while( true );
}



int get_e(uchar *env)

{
  char *__nptr;
  int iVar1;
  
  __nptr = getenv((char *)env);
  iVar1 = 0;
  if (__nptr != (char *)0x0) {
    iVar1 = strtol(__nptr,(char **)0x0,10);
  }
  return iVar1;
}



void get_terminal_size(int fd,int *x,int *y)

{
  int iVar1;
  int iVar2;
  winsize ws;
  
  iVar1 = ioctl(1,0x5413,&ws);
  if (iVar1 == -1) {
    *x = 0;
    *y = 0;
  }
  else {
    *x = (uint)ws.ws_col;
    *y = (uint)ws.ws_row;
  }
  if (*x == 0) {
    iVar2 = get_e((uchar *)"COLUMNS");
    iVar1 = 0x50;
    if (iVar2 != 0) {
      iVar1 = iVar2;
    }
    *x = iVar1;
  }
  if (*y == 0) {
    iVar2 = get_e((uchar *)"LINES");
    iVar1 = 0x19;
    if (iVar2 != 0) {
      iVar1 = iVar2;
    }
    *y = iVar1;
  }
  return;
}



void set_ip_tos_throughput(int socket)

{
  undefined4 local_10 [3];
  
  local_10[0] = 8;
  setsockopt(socket,0,1,local_10,4);
  return;
}



int set_blocking_fd(int fd)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = fcntl(fd,3,0);
  iVar2 = -1;
  if (-1 < (int)uVar1) {
    iVar2 = fcntl(fd,4,uVar1 & 0xfffff7ff);
  }
  return iVar2;
}



int set_nonblocking_fd(int fd)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = fcntl(fd,3,0);
  iVar2 = -1;
  if (-1 < (int)uVar1) {
    iVar2 = fcntl(fd,4,uVar1 | 0x800);
  }
  return iVar2;
}



int start_thread(anon_subr_void_void_ptr_int *fn,void *ptr,int l)

{
  int iVar1;
  __pid_t _Var2;
  list_head_elinks *plVar3;
  int p [2];
  
  iVar1 = pipe(p);
  if (((iVar1 < 0) || (iVar1 = set_nonblocking_fd(p[0]), iVar1 < 0)) ||
     (iVar1 = set_nonblocking_fd(p[1]), iVar1 < 0)) {
    p[0] = -1;
  }
  else {
    _Var2 = fork();
    plVar3 = (list_head_elinks *)terminals.next;
    if (_Var2 == 0) {
      while (plVar3 != &terminals) {
        if (0 < (int)plVar3[4].next) {
          close((int)plVar3[4].next);
        }
        plVar3 = (list_head_elinks *)plVar3->next;
      }
      close(p[0]);
      (*fn)(ptr,p[1]);
      write(p[1],&DAT_0813532d,1);
      close(p[1]);
                    // WARNING: Subroutine does not return
      _exit(0);
    }
    if (_Var2 == -1) {
      close(p[0]);
      close(p[1]);
      p[0] = -1;
    }
    else {
      close(p[1]);
    }
  }
  return p[0];
}



void sig_ign(void *x)

{
  return;
}



int check_signals(void)

{
  code *pcVar1;
  int iVar2;
  int iVar3;
  
  iVar2 = 0;
  iVar3 = 0;
  do {
    if (*(int *)((int)&signal_info[0].mask + iVar3) != 0) {
      pcVar1 = *(code **)((int)&signal_info[0].handler + iVar3);
      *(undefined4 *)((int)&signal_info[0].mask + iVar3) = 0;
      if (pcVar1 != (code *)0x0) {
        (*pcVar1)(*(undefined4 *)((int)&signal_info[0].data + iVar3));
      }
      check_bottom_halves();
      iVar2 = 1;
    }
    iVar3 = iVar3 + 0x10;
  } while (iVar3 != 0x200);
  return iVar2;
}



void sig_chld(void *p)

{
  __pid_t _Var1;
  
  do {
    _Var1 = waitpid(-1,(int *)0x0,1);
  } while (0 < _Var1);
  return;
}



void uninstall_alarm(void)

{
  pending_alarm = 0;
  alarm(0);
  return;
}



void sig_segv(terminal *term)

{
  fputc(7,(FILE *)stderr);
  fflush((FILE *)stderr);
  sleep(1);
  fwrite(&DAT_08131ec2,1,2,(FILE *)stderr);
  fwrite(
         "ELinks crashed. That shouldn\'t happen. Please report this incident to\nthe developers. If you would like to help to debug the problem you just\nuncovered, please keep the core you just got and send the developers\nthe output of \'bt\' command entered inside of gdb (which you run as:\ngdb elinks core). Thanks a lot for your cooperation!\n\n"
         ,1,0x14d,(FILE *)stderr);
  fputs((char *)full_static_version,(FILE *)stderr);
  fwrite(&DAT_081281ca,1,2,(FILE *)stderr);
  dump_backtrace(stderr,1);
                    // WARNING: Subroutine does not return
  abort();
}



void sig_cont(terminal *term)

{
  int iVar1;
  
  iVar1 = unblock_itrm();
  if (iVar1 != 0) {
    return;
  }
  resize_terminal();
  return;
}



void sig_tstp(terminal *term)

{
  __pid_t __pid;
  __pid_t _Var1;
  
  __pid = getpid();
  block_itrm();
  _Var1 = fork();
  if (_Var1 != 0) {
    raise(0x13);
    return;
  }
  sleep(1);
  kill(__pid,0x12);
                    // WARNING: Subroutine does not return
  _exit(0);
}



void sig_ctrl_c(terminal *term)

{
  int iVar1;
  
  iVar1 = is_blocked();
  if (iVar1 != 0) {
    return;
  }
  kbd_ctrl_c();
  return;
}



void clear_signal_mask_and_handlers(void)

{
  int iVar1;
  signal_info *psVar2;
  
  iVar1 = 0x80;
  psVar2 = signal_info;
  while (iVar1 != 0) {
    iVar1 = iVar1 + -1;
    psVar2->handler = (anon_subr_void_void_ptr_for_handler *)0x0;
    psVar2 = (signal_info *)&psVar2->data;
  }
  return;
}



void install_signal_handler(int sig,anon_subr_void_void_ptr *fn,void *data,int critical)

{
  int iVar1;
  sigaction *psVar2;
  byte bVar3;
  sigaction sa;
  
  bVar3 = 0;
  if (assert_failed == 0) {
    assert_failed = ZEXT14(0x1fU < (uint)sig);
    if (0x1fU < (uint)sig) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/osdep/signals.c";
      errline = 0x105;
      elinks_internal((uchar *)
                      "assertion sig >= 0 && sig < NUM_SIGNALS failed: bad signal number: %d",sig);
      if (assert_failed != 0) goto LAB_080bf922;
    }
    iVar1 = 0x23;
    psVar2 = (sigaction *)&sa;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      psVar2->__sigaction_handler = 0;
      psVar2 = (sigaction *)((int)psVar2 + (uint)bVar3 * -8 + 4);
    }
    if (fn == (anon_subr_void_void_ptr *)0x0) {
      sa.__sigaction_handler = (code *)0x1;
      sigfillset((sigset_t *)&sa.sa_mask);
      sigaction(sig,(sigaction *)&sa,(sigaction *)0x0);
      signal_info[sig].handler = (anon_subr_void_void_ptr_for_handler *)0x0;
      signal_info[sig].data = data;
      signal_info[sig].critical = critical;
    }
    else {
      sa.__sigaction_handler = got_signal;
      sigfillset((sigset_t *)&sa.sa_mask);
      *(anon_subr_void_void_ptr **)&signal_info[sig].handler = fn;
      signal_info[sig].data = data;
      signal_info[sig].critical = critical;
      sigaction(sig,(sigaction *)&sa,(sigaction *)0x0);
    }
  }
  else {
LAB_080bf922:
    assert_failed = 0;
  }
  return;
}



void set_sigcld(void)

{
  install_signal_handler(0x11,sig_chld,(void *)0x0,1);
  return;
}



void check_for_select_race(void)

{
  if (critical_section == 0) {
    return;
  }
  install_signal_handler(0xe,alarm_handler,(void *)0x0,1);
  pending_alarm = 1;
  alarm(1);
  return;
}



void alarm_handler(void *x)

{
  pending_alarm = 0;
  check_for_select_race();
  return;
}



void got_signal(int sig)

{
  int iVar1;
  int *piVar2;
  
  piVar2 = __errno_location();
  iVar1 = *piVar2;
  if ((uint)sig < 0x20) {
    if (signal_info[sig].handler != (anon_subr_void_void_ptr_for_handler *)0x0) {
      if (signal_info[sig].critical == 0) {
        signal_info[sig].mask = 1;
        check_for_select_race();
        *piVar2 = iVar1;
      }
      else {
        (*signal_info[sig].handler)(signal_info[sig].data);
        *piVar2 = iVar1;
      }
    }
  }
  return;
}



void unhandle_terminal_signals(terminal *term)

{
  install_signal_handler(1,(anon_subr_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(2,(anon_subr_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0x14,(anon_subr_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0x15,(anon_subr_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0x16,(anon_subr_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0x12,(anon_subr_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0xb,(anon_subr_void_void_ptr *)0x0,(void *)0x0,0);
  return;
}



void handle_basic_signals(terminal *term)

{
  install_signal_handler(1,sig_intr,term,0);
  install_signal_handler(2,sig_ctrl_c,term,0);
  install_signal_handler(0xf,sig_terminate,term,0);
  install_signal_handler(0x14,sig_tstp,term,0);
  install_signal_handler(0x15,sig_tstp,term,0);
  install_signal_handler(0x16,sig_ign,term,0);
  install_signal_handler(0x12,sig_cont,term,0);
  install_signal_handler(0xb,sig_segv,term,1);
  return;
}



void __regparm3 unhandle_basic_signals(terminal *term)

{
  install_signal_handler(1,(anon_subr_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(2,(anon_subr_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0xf,(anon_subr_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0x14,(anon_subr_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0x15,(anon_subr_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0x16,(anon_subr_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0x12,(anon_subr_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0xb,(anon_subr_void_void_ptr *)0x0,(void *)0x0,0);
  return;
}



void sig_terminate(terminal *term)

{
  unhandle_basic_signals(term);
  program.terminate = 1;
  program.retval = RET_SIGNAL;
  return;
}



void sig_intr(terminal *term)

{
  unhandle_basic_signals(term);
  if (term != (terminal *)0x0) {
    register_bottom_half_do(destroy_terminal,term);
    return;
  }
  program.terminate = 1;
  return;
}



void get_system_name(void)

{
  int iVar1;
  byte bVar2;
  int iVar3;
  FILE *__stream;
  size_t sVar4;
  uchar *puVar5;
  int in_GS_OFFSET;
  utsname name;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  iVar3 = uname((utsname *)&name);
  if (iVar3 == 0) {
    __snprintf_chk(system_name,0x400,1,0x400,"%s %s %s",&name,name.release,name.machine);
  }
  else {
    __stream = popen("uname -srm","r");
    if (__stream != (FILE *)0x0) {
      sVar4 = fread(system_name,1,0x3ff,__stream);
      if (sVar4 == 0) {
        pclose(__stream);
      }
      else {
        pclose(__stream);
        puVar5 = system_name;
        system_name[1023] = '\0';
        bVar2 = system_name[0];
        while (0x1f < bVar2) {
          puVar5 = puVar5 + 1;
          bVar2 = *puVar5;
        }
        *puVar5 = 0;
        if (system_name[0] != '\0') goto LAB_080bfef1;
      }
    }
    safe_strncpy(system_name,"Unix",0x400);
  }
LAB_080bfef1:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int __regparm3 init_mouse(int cons,int suspend)

{
  int iVar1;
  Gpm_Connect conn;
  
  if (suspend == 0) {
    conn.eventMask = 0xffff;
    conn.maxMod = 0;
    conn.defaultMask = 0;
    conn.minMod = 0;
  }
  else {
    conn.eventMask = 0;
    conn.maxMod = 0xffff;
    conn.defaultMask = 0xffff;
    conn.minMod = 0xffff;
  }
  gpm_visiblepointer = 1;
  iVar1 = Gpm_Open(&conn,cons);
  return iVar1;
}



void resume_mouse(void *h)

{
  int fd;
  
  if (h != (void *)0x0) {
    fd = init_mouse(*(int *)((int)h + 4),0);
    *(int *)h = fd;
    if (-1 < fd) {
      set_handlers(fd,gpm_mouse_in,(select_handler_T *)0x0,(select_handler_T *)0x0,h);
    }
  }
  return;
}



void suspend_mouse(void *h)

{
  int fd;
  
  if (h != (void *)0x0) {
    fd = init_mouse(*(int *)((int)h + 4),1);
    *(int *)h = fd;
    if (-1 < fd) {
      set_handlers(fd,(select_handler_T *)0x0,(select_handler_T *)0x0,(select_handler_T *)0x0,
                   (void *)0x0);
    }
  }
  return;
}



void unhandle_mouse(void *h)

{
  if (h != (void *)0x0) {
    set_handlers(*(int *)h,(select_handler_T *)0x0,(select_handler_T *)0x0,(select_handler_T *)0x0,
                 (void *)0x0);
    mem_free(h);
    Gpm_Close();
    return;
  }
  return;
}



void * handle_mouse(int cons,anon_subr_void_void_ptr_uchar_ptr_int *fn,void *data)

{
  int fd;
  int *data_00;
  
  fd = init_mouse(cons,0);
  if ((-1 < fd) && (data_00 = (int *)mem_alloc(0x10), data_00 != (int *)0x0)) {
    *data_00 = fd;
    data_00[1] = cons;
    *(anon_subr_void_void_ptr_uchar_ptr_int **)(data_00 + 2) = fn;
    *(void **)(data_00 + 3) = data;
    set_handlers(fd,gpm_mouse_in,(select_handler_T *)0x0,(select_handler_T *)0x0,data_00);
    return data_00;
  }
  return (void *)0x0;
}



void gpm_mouse_in(gpm_mouse_spec *gms)

{
  short *psVar1;
  int iVar2;
  short sVar3;
  Gpm_Event gev;
  interlink_event ev;
  
  iVar2 = Gpm_GetEvent(&gev);
  psVar1 = _gpm_arg;
  if (iVar2 < 1) {
    set_handlers(gms->h,(select_handler_T *)0x0,(select_handler_T *)0x0,(select_handler_T *)0x0,
                 (void *)0x0);
  }
  else {
    _gpm_buf[1] = 2;
    _gpm_arg[2] = gev.x + (short)gpm_zerobased;
    *psVar1 = gev.x + (short)gpm_zerobased;
    psVar1 = _gpm_arg;
    sVar3 = (short)gpm_zerobased + gev.y;
    _gpm_arg[3] = sVar3;
    psVar1[1] = sVar3;
    _gpm_arg[4] = 3;
    ioctl(1,0x541c,0x8148c81);
    ev.info._8_4_ = 0;
    if ((((gev.buttons & 4) == 0) && (ev.info._8_4_ = 1, (gev.buttons & 2) == 0)) &&
       (ev.info._8_4_ = 2, (gev.buttons & 1) == 0)) {
      ev.info._8_4_ = 4;
      if (-1 < gev.wdy) {
        if (gev.wdy == 0) {
          return;
        }
        ev.info._8_4_ = 3;
      }
    }
    if ((gev.type & GPM_DOWN) == 0) {
      if ((gev.type & GPM_UP) == 0) {
        if ((gev.type & GPM_DRAG) == 0) {
          if (gev.wdy == 0) {
            return;
          }
        }
        else {
          ev.info._8_4_ = ev.info._8_4_ | 0x40;
        }
      }
      else {
        ev.info._8_4_ = ev.info._8_4_ | 0x20;
      }
    }
    ev.info._0_4_ = (int)gev.x + -1;
    if ((int)ev.info < 0) {
      ev.info._0_4_ = 0;
    }
    ev.info._4_4_ = 0;
    if (-1 < (int)gev.y + -1) {
      ev.info._4_4_ = (int)gev.y + -1;
    }
    ev.ev = EVENT_MOUSE;
    (*gms->fn)(gms->data,(uchar *)&ev,0x10);
  }
  return;
}



void about_protocol_handler(connection *conn)

{
  cache_entry *cached;
  uint uVar1;
  char *__s2;
  int iVar2;
  uchar *data;
  size_t length;
  about_page *paVar3;
  
  cached = get_cache_entry(conn->uri);
  if ((cached != (cache_entry *)0x0) && (cached->content_type == (uchar *)0x0)) {
    __s2 = "bloat";
    paVar3 = about_pages;
    data = conn->uri->data;
    do {
      iVar2 = strcmp((char *)data,__s2);
      if (iVar2 == 0) {
        data = paVar3->string;
        length = strlen((char *)data);
        add_fragment(cached,0,data,length);
        *(size_t *)&conn->from = length;
        *(int *)((int)&conn->from + 4) = (int)length >> 0x1f;
        if (cached->content_type != (uchar *)0x0) {
          mem_free(cached->content_type);
        }
        break;
      }
      paVar3 = paVar3 + 1;
      __s2 = (char *)paVar3->name;
    } while ((uchar *)__s2 != (uchar *)0x0);
    data = stracpy((uchar *)"text/html");
    cached->content_type = data;
  }
  conn->cached = cached;
  if (assert_failed == 0) {
    uVar1 = 0xfffe7960;
  }
  else {
    uVar1 = 0xfffe795d;
  }
  assert_failed = 0;
  abort_connection(conn,(connection_state)(ulonglong)uVar1);
  return;
}



void close_all_non_term_fd(void)

{
  int __fd;
  int iVar1;
  rlimit lim;
  
  __fd = getrlimit64(RLIMIT_NOFILE,(rlimit64 *)&lim);
  if (__fd == 0) {
    if ((int)lim.rlim_max < 4) {
      return;
    }
  }
  else {
    lim.rlim_max._0_4_ = 0x400;
  }
  __fd = 3;
  do {
    iVar1 = __fd + 1;
    close(__fd);
    __fd = iVar1;
  } while (iVar1 < (int)lim.rlim_max);
  return;
}



connection_state init_directory_listing(string *page,uri *uri)

{
  char *pcVar1;
  int iVar2;
  uint uVar3;
  string *psVar4;
  char *source;
  uint uVar5;
  uchar *__src;
  uchar *puVar6;
  uint size;
  char *__n;
  undefined4 extraout_EDX;
  bool bVar7;
  uri *in_stack_0000000c;
  string *local_40;
  string location;
  string decoded;
  string dirpath;
  uchar local_1d [13];
  
  dirpath.source = (uchar *)0x0;
  dirpath.length = 0;
  decoded.source = (uchar *)0x0;
  decoded.length = 0;
  location.source = (uchar *)0x0;
  location.length = 0;
  iVar2 = in_stack_0000000c->protocol;
  psVar4 = init_string((string *)uri);
  if (psVar4 != (string *)0x0) {
    psVar4 = init_string(&dirpath);
    if (((((psVar4 != (string *)0x0) && (psVar4 = init_string(&decoded), psVar4 != (string *)0x0))
         && (psVar4 = init_string(&location), psVar4 != (string *)0x0)) &&
        (((psVar4 = add_uri_to_string(&dirpath,in_stack_0000000c,URI_DATA), psVar4 != (string *)0x0
          && (psVar4 = add_uri_to_string(&location,in_stack_0000000c,URI_DIR_LOCATION),
             psVar4 != (string *)0x0)) &&
         ((dirpath.length < 1 ||
          ((dirpath.source[dirpath.length + -1] == '/' ||
           (psVar4 = add_char_to_string(&dirpath,'/'), psVar4 != (string *)0x0)))))))) &&
       (psVar4 = add_string_to_string(&decoded,&dirpath), psVar4 != (string *)0x0)) {
      bVar7 = iVar2 == 4;
      decode_uri_string(&decoded);
      if (((((bVar7) || (psVar4 = add_char_to_string(&location,'/'), psVar4 != (string *)0x0)) &&
           (psVar4 = add_to_string((string *)uri,(uchar *)"<html>\n<head><title>"),
           psVar4 != (string *)0x0)) &&
          (((bVar7 || (psVar4 = add_html_to_string((string *)uri,location.source,location.length),
                      psVar4 != (string *)0x0)) &&
           (((psVar4 = add_html_to_string((string *)uri,decoded.source,decoded.length),
             psVar4 != (string *)0x0 &&
             ((psVar4 = add_to_string((string *)uri,(uchar *)"</title>\n<base href=\""),
              psVar4 != (string *)0x0 &&
              (psVar4 = add_html_to_string((string *)uri,location.source,location.length),
              psVar4 != (string *)0x0)))) &&
            (psVar4 = add_html_to_string((string *)uri,dirpath.source,dirpath.length),
            psVar4 != (string *)0x0)))))) &&
         (psVar4 = add_to_string((string *)uri,(uchar *)"\" />\n</head>\n<body>\n<h2>"),
         psVar4 != (string *)0x0)) {
        switch(in_stack_0000000c->protocol) {
        case 4:
          source = "Local";
          break;
        default:
          source = "?";
          break;
        case 6:
          source = "FSP";
          break;
        case 7:
          source = "FTP";
          break;
        case 8:
          source = "Gopher";
          break;
        case 0x10:
          source = "Samba";
        }
        psVar4 = add_to_string((string *)uri,(uchar *)source);
        if (((psVar4 != (string *)0x0) &&
            (psVar4 = add_to_string((string *)uri,(uchar *)" directory "), psVar4 != (string *)0x0))
           && ((bVar7 || (psVar4 = add_string_to_string((string *)uri,&location),
                         psVar4 != (string *)0x0)))) {
          local_1d[0] = '/';
          __src = dirpath.source;
          while( true ) {
            source = strchr((char *)__src,0x2f);
            if (source == (char *)0x0) {
              psVar4 = add_to_string((string *)uri,(uchar *)"</h2>\n<pre>");
              if (psVar4 != (string *)0x0) goto LAB_080c0848;
              goto out_of_memory;
            }
            done_string(&decoded);
            psVar4 = init_string(&decoded);
            if (psVar4 == (string *)0x0) goto out_of_memory;
            if (assert_failed != 0) break;
            __n = source + -(int)__src;
            if ((__src == (uchar *)0x0) || ((int)__n < 0)) {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
              errline = 0xff;
              elinks_internal((uchar *)
                              "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                             );
              if (assert_failed != 0) break;
            }
            else {
              assert_failed = 0;
            }
            if (__n != (char *)0x0) {
              pcVar1 = __n + decoded.length;
              uVar3 = decoded.length + 0xffU >> 8;
              uVar5 = decoded.length + 0xffU & 0xffffff00;
              size = (uint)(pcVar1 + 0x100) & 0xffffff00;
              if (uVar5 <= size && size + uVar3 * -0x100 != 0) {
                puVar6 = (uchar *)mem_realloc(decoded.source,size);
                if (puVar6 == (uchar *)0x0) goto out_of_memory;
                decoded.source = puVar6;
                memset(puVar6 + uVar5,0,size + uVar3 * -0x100);
              }
              if (decoded.source == (uchar *)0x0) goto out_of_memory;
              memcpy(decoded.source + decoded.length,__src,(size_t)__n);
              decoded.source[(int)pcVar1] = '\0';
              decoded.length = (int)pcVar1;
            }
            decode_uri_string(&decoded);
            psVar4 = add_to_string((string *)uri,(uchar *)"<a href=\"");
            if ((psVar4 == (string *)0x0) ||
               (psVar4 = add_html_to_string((string *)uri,location.source,location.length),
               psVar4 == (string *)0x0)) goto out_of_memory;
            __src = (uchar *)(source + 1);
            psVar4 = add_html_to_string((string *)uri,dirpath.source,
                                        (int)(__src + -(int)dirpath.source));
            if ((psVar4 == (string *)0x0) ||
               ((((psVar4 = add_to_string((string *)uri,"\">"), psVar4 == (string *)0x0 ||
                  (psVar4 = add_html_to_string((string *)uri,decoded.source,decoded.length),
                  psVar4 == (string *)0x0)) ||
                 (psVar4 = add_to_string((string *)uri,"</a>"), psVar4 == (string *)0x0)) ||
                (psVar4 = add_html_to_string((string *)uri,local_1d,1), psVar4 == (string *)0x0))))
            goto out_of_memory;
          }
          assert_failed = 0;
        }
      }
    }
  }
out_of_memory:
  done_string((string *)uri);
LAB_080c0848:
  local_40 = &dirpath;
  done_string(local_40);
  done_string(&decoded);
  done_string(&location);
  if (0 < uri->protocol) {
    if (assert_failed == 0) {
      __src = (uchar *)0xfffe7960;
    }
    else {
      __src = (uchar *)0xfffe795d;
    }
    assert_failed = 0;
    page->length = 0;
    page->source = __src;
    return (connection_state)CONCAT44(page,page);
  }
  if (assert_failed == 0) {
    __src = (uchar *)0xfffe795c;
  }
  else {
    __src = (uchar *)0xfffe795d;
  }
  assert_failed = 0;
  page->length = 0;
  page->source = __src;
  return (connection_state)CONCAT44(extraout_EDX,page);
}



connection_state connection_state(void)

{
  int *in_EAX;
  int in_EDX;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(in_EDX == -1);
    if (in_EDX == -1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
      errline = 0x84;
      elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
      if (assert_failed != 0) goto LAB_080c0ac8;
    }
    in_EAX[1] = 0;
    *in_EAX = in_EDX;
    return (connection_state)CONCAT44(in_EDX,in_EAX);
  }
LAB_080c0ac8:
  assert_failed = 0;
  in_EAX[1] = 0;
  *in_EAX = -0x186a3;
  return (connection_state)CONCAT44(0xfffe795d,in_EAX);
}



void data_protocol_handler(connection *conn)

{
  off_t *poVar1;
  int *piVar2;
  uri *uri;
  uri *puVar3;
  cache_entry *cached;
  void *pvVar4;
  uchar *src;
  uchar *puVar5;
  size_t length;
  uint uVar6;
  void *pvVar7;
  int iVar8;
  char *__s;
  char *pcVar9;
  char *pcVar10;
  bool bVar11;
  byte bVar12;
  undefined *local_2c;
  undefined4 local_24;
  undefined4 local_20;
  
  bVar12 = 0;
  uri = conn->uri;
  cached = get_cache_entry(uri);
  if (cached == (cache_entry *)0x0) {
    if (assert_failed == 0) {
      uVar6 = 0xfffe795c;
      goto LAB_080c0caf;
    }
  }
  else {
    puVar3 = conn->uri;
    conn->cached = cached;
    __s = (char *)puVar3->data;
    pvVar4 = memchr(__s,0x2c,(uint)*(ushort *)&puVar3->field_0x31);
    if (pvVar4 == (void *)0x0) {
      __s = "text/plain;charset=US-ASCII";
      bVar11 = false;
      local_2c = (undefined *)0x1b;
    }
    else {
      local_2c = (undefined *)((int)pvVar4 - (int)__s);
      if (&DAT_00000006 < local_2c) {
        iVar8 = 7;
        bVar11 = (char *)((int)pvVar4 + -7) == (char *)0x0;
        pcVar9 = ";base64";
        pcVar10 = (char *)((int)pvVar4 + -7);
        do {
          if (iVar8 == 0) break;
          iVar8 = iVar8 + -1;
          bVar11 = *pcVar9 == *pcVar10;
          pcVar9 = pcVar9 + (uint)bVar12 * -2 + 1;
          pcVar10 = pcVar10 + (uint)bVar12 * -2 + 1;
        } while (bVar11);
        if (!bVar11) goto LAB_080c0b5e;
        local_2c = local_2c + -7;
        bVar11 = true;
      }
      else {
LAB_080c0b5e:
        bVar11 = false;
      }
      if (((int)local_2c < 3) || (pvVar7 = memchr(__s,0x2f,(size_t)local_2c), pvVar7 == (void *)0x0)
         ) {
        __s = "text/plain;charset=US-ASCII";
        local_2c = (undefined *)0x1b;
      }
    }
    if (assert_failed == 0) {
      assert_failed = 0;
    }
    src = memacpy((uchar *)__s,(int)local_2c);
    if (src == (uchar *)0x0) {
LAB_080c0d50:
      connection_state();
      abort_connection(conn,(connection_state)CONCAT44(local_20,local_24));
      return;
    }
    puVar5 = straconcat((uchar *)"\r\nContent-Type: ",src,&DAT_081352f5,0);
    mem_free(src);
    if (puVar5 == (uchar *)0x0) goto LAB_080c0d50;
    if (cached->head != (uchar *)0x0) {
      mem_free(cached->head);
    }
    cached->head = puVar5;
    if (pvVar4 == (void *)0x0) {
      src = puVar3->data;
    }
    else {
      src = (uchar *)((int)pvVar4 + 1);
    }
    if ((src == (uchar *)0x0) ||
       (src = memacpy(src,(int)(uri->data + ((uint)*(ushort *)&uri->field_0x31 - (int)src))),
       src == (uchar *)0x0)) goto LAB_080c0d50;
    if (bVar11) {
      puVar5 = base64_encode(src);
      if (puVar5 == (uchar *)0x0) goto LAB_080c0d50;
      mem_free(src);
      src = puVar5;
    }
    else {
      decode_uri(src);
    }
    length = strlen((char *)src);
    add_fragment(cached,conn->from,src,length);
    poVar1 = &conn->from;
    uVar6 = *(uint *)poVar1;
    *(uint *)poVar1 = *(uint *)poVar1 + length;
    piVar2 = (int *)((int)&conn->from + 4);
    *piVar2 = *piVar2 + ((int)length >> 0x1f) + (uint)CARRY4(uVar6,length);
    mem_free(src);
    if (assert_failed == 0) {
      uVar6 = 0xfffe7960;
      goto LAB_080c0caf;
    }
  }
  uVar6 = 0xfffe795d;
LAB_080c0caf:
  assert_failed = 0;
  abort_connection(conn,(connection_state)(ulonglong)uVar6);
  return;
}



int parse_year(uchar **date_p,uchar *end)

{
  byte *pbVar1;
  byte *pbVar2;
  int iVar3;
  byte *pbVar4;
  
  pbVar4 = *date_p;
  if ((((end == (uchar *)0x0) || (pbVar4 + 1 < end)) && ((byte)(*pbVar4 - 0x30) < 10)) &&
     ((byte)(pbVar4[1] - 0x30) < 10)) {
    iVar3 = ((uint)pbVar4[1] - 0x210) + (uint)*pbVar4 * 10;
    if (((end == (uchar *)0x0) || (pbVar4 + 3 < end)) &&
       ((pbVar1 = pbVar4 + 2, (byte)(*pbVar1 - 0x30) < 10 &&
        (pbVar2 = pbVar4 + 3, (byte)(*pbVar2 - 0x30) < 10)))) {
      pbVar4 = pbVar4 + 4;
      iVar3 = (iVar3 * 10 + -0x30 + (uint)*pbVar1) * 10 + -0x79c + (uint)*pbVar2;
    }
    else {
      if (iVar3 < 0x46) {
        *date_p = pbVar4 + 2;
        return iVar3 + 100;
      }
    }
    *date_p = pbVar4;
  }
  else {
    iVar3 = -1;
  }
  return iVar3;
}



int parse_day(uchar **date_p,uchar *end)

{
  byte *pbVar1;
  int iVar2;
  
  pbVar1 = *date_p;
  if (((pbVar1 < end) || (end == (uchar *)0x0)) && ((byte)(*pbVar1 - 0x30) < 10)) {
    iVar2 = (uint)*pbVar1 - 0x30;
    if (((pbVar1 + 1 < end) || (end == (uchar *)0x0)) && ((byte)(pbVar1[1] - 0x30) < 10)) {
      iVar2 = ((uint)pbVar1[1] - 0x30) + iVar2 * 10;
      *date_p = pbVar1 + 2;
    }
    else {
      *date_p = pbVar1 + 1;
    }
  }
  else {
    iVar2 = 0x20;
  }
  return iVar2;
}



int parse_time(uchar **time,tm *tm,uchar *end)

{
  int iVar1;
  byte bVar2;
  byte *pbVar3;
  byte bVar4;
  byte *local_18;
  
  pbVar3 = *time;
  if (((((end == (uchar *)0x0) || (pbVar3 + 5 <= end)) && ((byte)(*pbVar3 - 0x30) < 10)) &&
      (((byte)(pbVar3[1] - 0x30) < 10 && (pbVar3[2] == 0x3a)))) &&
     ((bVar4 = pbVar3[3], (byte)(bVar4 - 0x30) < 10 &&
      (bVar2 = pbVar3[4], (byte)(bVar2 - 0x30) < 10)))) {
    iVar1 = ((uint)pbVar3[1] - 0x210) + (uint)*pbVar3 * 10;
    local_18 = pbVar3 + 5;
    tm->tm_hour = iVar1;
    tm->tm_min = ((uint)bVar2 - 0x210) + (uint)bVar4 * 10;
    tm->tm_sec = 0;
    if ((end == (uchar *)0x0) || (pbVar3 + 7 < end)) {
      bVar4 = pbVar3[5];
      if (bVar4 == 0x3a) {
        if ((end != (uchar *)0x0) && (end <= pbVar3 + 8)) {
          return 0;
        }
        if (9 < (byte)(pbVar3[6] - 0x30)) {
          return 0;
        }
        if (9 < (byte)(pbVar3[7] - 0x30)) {
          return 0;
        }
        local_18 = pbVar3 + 8;
        tm->tm_sec = ((uint)pbVar3[7] - 0x210) + (uint)pbVar3[6] * 10;
      }
      else {
        if ((bVar4 == 0x50) || (bVar4 == 0x41)) {
          if (iVar1 == 0xc) {
            tm->tm_hour = 0;
            bVar4 = pbVar3[5];
          }
          if (bVar4 == 0x50) {
            tm->tm_hour = tm->tm_hour + 0xc;
          }
          if (pbVar3[6] != 0x4d) {
            return 0;
          }
          local_18 = pbVar3 + 7;
        }
      }
      *time = local_18;
      if ((tm->tm_hour < 0x18) && (tm->tm_min < 0x3c)) {
        return (uint)(tm->tm_sec < 0x3c);
      }
    }
    else {
      *time = local_18;
      if ((tm->tm_hour < 0x18) && (tm->tm_min < 0x3c)) {
        return (uint)(tm->tm_sec < 0x3c);
      }
    }
  }
  return 0;
}



int parse_month(uchar **buf,uchar *end)

{
  uchar *str;
  int iVar1;
  
  str = *buf;
  if ((((end == (uchar *)0x0) || (str + 2 <= end)) && (*str != '\0')) &&
     ((str[1] != '\0' && (str[2] != '\0')))) {
    iVar1 = month2num(str);
    if (iVar1 != -1) {
      *buf = *buf + 3;
    }
  }
  else {
    iVar1 = -1;
  }
  return iVar1;
}



time_t parse_date(uchar **date_pos,uchar *end,int update_pos,int skip_week_day)

{
  uchar *puVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  uchar uVar5;
  uchar *puVar6;
  bool bVar7;
  tm tm;
  uchar *local_20 [4];
  
  local_20[0] = *date_pos;
  if (local_20[0] == (uchar *)0x0) {
    return 0;
  }
  if (skip_week_day == 0) goto LAB_080c11bd;
  bVar7 = end == (uchar *)0x0;
  if ((!bVar7) && (end <= local_20[0])) {
    return 0;
  }
  uVar5 = *local_20[0];
  puVar6 = local_20[0];
  if (uVar5 == ' ') {
LAB_080c1358:
    do {
      local_20[0] = local_20[0] + 1;
      if (local_20[0] < end) {
        uVar5 = *local_20[0];
      }
      else {
        if (!bVar7) break;
        uVar5 = *local_20[0];
      }
    } while ((uVar5 == '-') || (uVar5 == ' '));
  }
  else {
    do {
      if (uVar5 == '\0') {
        return 0;
      }
      local_20[0] = local_20[0] + 1;
      puVar6 = local_20[0];
      if ((end <= local_20[0]) && (!bVar7)) goto LAB_080c11b6;
      uVar5 = *local_20[0];
    } while (uVar5 != ' ');
    if (local_20[0] < end || bVar7) goto LAB_080c1358;
  }
LAB_080c11b6:
  if (puVar6 == local_20[0]) {
    return 0;
  }
LAB_080c11bd:
  if ((byte)(*local_20[0] - 0x30) < 10) {
    tm.tm_mday = parse_day(local_20,end);
    puVar6 = local_20[0];
    puVar1 = local_20[0];
    if (0x1f < tm.tm_mday) {
      return 0;
    }
    do {
      local_20[0] = puVar1;
      if ((end != (uchar *)0x0) && (end <= local_20[0])) break;
      puVar1 = local_20[0] + 1;
    } while ((*local_20[0] == '-') || (*local_20[0] == ' '));
    if (puVar6 == local_20[0]) {
      return 0;
    }
    tm.tm_mon = parse_month(local_20,end);
    puVar6 = local_20[0];
    puVar1 = local_20[0];
    if (tm.tm_mon < 0) {
      return 0;
    }
    do {
      local_20[0] = puVar1;
      if ((end != (uchar *)0x0) && (end <= local_20[0])) break;
      puVar1 = local_20[0] + 1;
    } while ((*local_20[0] == '-') || (*local_20[0] == ' '));
    if (puVar6 == local_20[0]) {
      return 0;
    }
    tm.tm_year = parse_year(local_20,end);
    puVar6 = local_20[0];
    puVar1 = local_20[0];
    if (tm.tm_year < 0) {
      return 0;
    }
    do {
      local_20[0] = puVar1;
      if ((end != (uchar *)0x0) && (end <= local_20[0])) break;
      puVar1 = local_20[0] + 1;
    } while ((*local_20[0] == '-') || (*local_20[0] == ' '));
    if (puVar6 == local_20[0]) {
      return 0;
    }
    iVar2 = parse_time(local_20,&tm,end);
    if (iVar2 == 0) {
      return 0;
    }
  }
  else {
    tm.tm_mon = parse_month(local_20,end);
    puVar6 = local_20[0];
    puVar1 = local_20[0];
    if (tm.tm_mon < 0) {
      return 0;
    }
    do {
      local_20[0] = puVar1;
      if ((end != (uchar *)0x0) && (end <= local_20[0])) break;
      puVar1 = local_20[0] + 1;
    } while ((*local_20[0] == '-') || (*local_20[0] == ' '));
    if (puVar6 == local_20[0]) {
      return 0;
    }
    tm.tm_mday = parse_day(local_20,end);
    puVar6 = local_20[0];
    puVar1 = local_20[0];
    if (0x1f < tm.tm_mday) {
      return 0;
    }
    do {
      local_20[0] = puVar1;
      if ((end != (uchar *)0x0) && (end <= local_20[0])) break;
      puVar1 = local_20[0] + 1;
    } while ((*local_20[0] == '-') || (*local_20[0] == ' '));
    if (puVar6 == local_20[0]) {
      return 0;
    }
    iVar2 = parse_time(local_20,&tm,end);
    puVar6 = local_20[0];
    puVar1 = local_20[0];
    if (iVar2 == 0) {
      return 0;
    }
    do {
      local_20[0] = puVar1;
      if ((end != (uchar *)0x0) && (end <= local_20[0])) break;
      puVar1 = local_20[0] + 1;
    } while ((*local_20[0] == '-') || (*local_20[0] == ' '));
    if (local_20[0] == puVar6) {
      return 0;
    }
    tm.tm_year = parse_year(local_20,end);
    if (tm.tm_year < 0) {
      return 0;
    }
  }
  if (update_pos != 0) {
    *date_pos = local_20[0];
  }
  iVar2 = tm.tm_mon + -2;
  if (iVar2 < 0) {
    iVar2 = tm.tm_mon + 10;
    tm.tm_year = tm.tm_year + -1;
  }
  iVar3 = (tm.tm_year + -0x44) * 0x5b5;
  iVar4 = iVar3 + 3;
  if (-1 < iVar3) {
    iVar4 = iVar3;
  }
  iVar2 = tm.tm_hour * 0xe10 + tm.tm_min * 0x3c + tm.tm_sec +
          ((iVar4 >> 2) + tm.tm_mday + -0x2a0 + (iVar2 * 0x99 + 2) / 5) * 0x15180;
  if (iVar2 == -1) {
    return 0;
  }
  return iVar2;
}



// WARNING: Type propagation algorithm not settling

uchar * get_header_param(uchar *e,uchar *name)

{
  byte bVar1;
  ushort *puVar2;
  int iVar3;
  int iVar4;
  ushort **ppuVar5;
  byte *pbVar6;
  byte *pbVar7;
  byte *pbVar8;
  byte bVar9;
  byte *pbVar10;
  byte *pbVar11;
  byte *pbVar12;
  
  do {
    do {
      bVar9 = *e;
      if (bVar9 == 0) {
        return (uchar *)0x0;
      }
      e = e + 1;
      iVar3 = c_toupper((uint)bVar9);
      iVar4 = c_toupper((uint)*name);
    } while (iVar3 != iVar4);
    bVar9 = *e;
    if (bVar9 == 0) {
      return (uchar *)0x0;
    }
    pbVar6 = name + 1;
    if (name[1] == 0) goto LAB_080c156b;
    while( true ) {
      iVar3 = c_toupper((uint)bVar9);
      iVar4 = c_toupper((uint)*pbVar6);
      if (iVar3 != iVar4) break;
      pbVar6 = pbVar6 + 1;
      e = e + 1;
      if (*pbVar6 == 0) goto LAB_080c1568;
      bVar9 = *e;
    }
  } while (*pbVar6 != 0);
LAB_080c1568:
  bVar9 = *e;
LAB_080c156b:
  ppuVar5 = __ctype_b_loc();
  puVar2 = *ppuVar5;
  while ((*(byte *)((int)puVar2 + (uint)bVar9 * 2 + 1) & 0x20) != 0) {
    e = e + 1;
    bVar9 = *e;
  }
  if (bVar9 == 0x3d) {
    bVar9 = e[1];
    pbVar6 = e + 1;
    bVar1 = *(byte *)((int)puVar2 + (uint)bVar9 * 2 + 1);
    while ((bVar1 & 0x20) != 0) {
      pbVar6 = pbVar6 + 1;
      bVar9 = *pbVar6;
      bVar1 = *(byte *)((int)puVar2 + (uint)bVar9 * 2 + 1);
    }
    if ((bVar9 == 0x27) || (bVar9 == 0x22)) {
      pbVar6 = pbVar6 + 1;
      bVar1 = *pbVar6;
      pbVar11 = pbVar6;
      if (bVar1 != bVar9) {
        do {
          if (bVar1 == 0) {
            return (uchar *)0x0;
          }
          pbVar11 = pbVar11 + 1;
          bVar1 = *pbVar11;
        } while (bVar1 != bVar9);
        goto joined_r0x080c15fe;
      }
    }
    else {
      pbVar11 = pbVar6;
      if ((*pbVar6 != 0) && ((*(byte *)((int)puVar2 + (uint)*pbVar6 * 2 + 1) & 0x20) == 0)) {
        do {
          pbVar11 = pbVar11 + 1;
          if (*pbVar11 == 0) break;
        } while ((*(byte *)((int)puVar2 + (uint)*pbVar11 * 2 + 1) & 0x20) == 0);
joined_r0x080c15fe:
        if (pbVar6 < pbVar11) {
          if (*pbVar6 == 0x20) goto LAB_080c1608;
          bVar9 = pbVar11[-1];
          pbVar7 = pbVar11;
          while ((pbVar11 = pbVar7, bVar9 == 0x20 && (pbVar11 = pbVar7 + -1, pbVar6 < pbVar11))) {
            bVar9 = pbVar7[-2];
            pbVar7 = pbVar11;
          }
        }
      }
    }
    if (pbVar6 != pbVar11) {
      pbVar7 = (byte *)mem_alloc((size_t)(pbVar11 + (1 - (int)pbVar6)));
      if (pbVar7 != (byte *)0x0) {
        pbVar10 = (byte *)0x0;
        pbVar8 = pbVar6;
        pbVar12 = pbVar7;
        if (pbVar6 < pbVar11) {
          do {
            bVar9 = *pbVar8;
            if (bVar9 < 0x20) {
              bVar9 = 0x2e;
            }
            pbVar8 = pbVar8 + 1;
            *pbVar12 = bVar9;
            pbVar12 = pbVar12 + 1;
          } while (pbVar8 < pbVar11);
          pbVar10 = pbVar11 + -(int)pbVar6;
        }
        pbVar7[(int)pbVar10] = 0;
        return pbVar7;
      }
      return (uchar *)0x0;
    }
  }
  return (uchar *)0x0;
LAB_080c1608:
  pbVar6 = pbVar6 + 1;
  goto joined_r0x080c15fe;
}



parse_header_param parse_header_param(uchar *str,uchar *name,uchar **ret)

{
  byte *pbVar1;
  uchar uVar2;
  byte bVar3;
  size_t n;
  size_t sVar4;
  int len;
  byte *pbVar5;
  uchar *puVar6;
  byte *src;
  
  if (ret != (uchar **)0x0) {
    *ret = (uchar *)0x0;
  }
  if (assert_failed != 0) {
    assert_failed = 0;
    return HEADER_PARAM_NOT_FOUND;
  }
  if (((name == (uchar *)0x0) || (str == (uchar *)0x0)) || (*name == '\0')) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/header.c";
    errline = 0xd8;
    elinks_internal((uchar *)"assertion str && name && *name failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return HEADER_PARAM_NOT_FOUND;
    }
    uVar2 = *str;
  }
  else {
    assert_failed = 0;
    uVar2 = *str;
  }
  if (uVar2 == '\0') {
    return HEADER_PARAM_NOT_FOUND;
  }
  n = strlen((char *)name);
  do {
    str = (uchar *)strchr((char *)str,0x3b);
    if (str == (byte *)0x0) {
      return HEADER_PARAM_NOT_FOUND;
    }
    while ((bVar3 = *str, bVar3 != 0 && ((bVar3 < 0x21 || (bVar3 == 0x3b))))) {
      str = str + 1;
    }
    sVar4 = strlen((char *)str);
    if (sVar4 < n) {
      return HEADER_PARAM_NOT_FOUND;
    }
    len = c_strncasecmp((char *)str,(char *)name,n);
  } while (len != 0);
  src = str + n;
  bVar3 = *src;
  if (bVar3 != 0) {
    if ((bVar3 < 0x21) || (bVar3 == 0x3d)) {
      do {
        src = src + 1;
        bVar3 = *src;
        if (bVar3 == 0) goto LAB_080c17e2;
      } while ((bVar3 == 0x3d) || (bVar3 < 0x21));
    }
    len = 0;
    do {
      bVar3 = src[len];
      if (bVar3 < 0x21) {
        if ((bVar3 != 9) && (bVar3 != 0x20)) goto LAB_080c189a;
      }
      else {
        if (bVar3 == 0x3b) goto LAB_080c189a;
      }
      len = len + 1;
    } while( true );
  }
LAB_080c17e2:
  if (ret == (uchar **)0x0) {
    return HEADER_PARAM_FOUND;
  }
  puVar6 = stracpy("");
  *ret = puVar6;
  goto joined_r0x080c17fc;
LAB_080c189a:
  if (len != 0) {
    if ((src[len + -1] == 9) || (src[len + -1] == 0x20)) {
      pbVar5 = src + len;
      do {
        len = len + -1;
        if (len == 0) goto LAB_080c18cb;
        pbVar1 = pbVar5 + -2;
        pbVar5 = pbVar5 + -1;
      } while ((*pbVar1 == 9) || (*pbVar1 == 0x20));
    }
    if ((1 < len) && ((*src == 0x27 && (pbVar5 = src + len, src[len + -1] == 0x27)))) {
      while( true ) {
        len = len + -2;
        src = src + 1;
        if (len < 2) break;
        if ((*src != 0x27) || (pbVar1 = pbVar5 + -2, pbVar5 = pbVar5 + -1, *pbVar1 != 0x27)) break;
      }
    }
  }
LAB_080c18cb:
  if (ret == (uchar **)0x0) {
    return HEADER_PARAM_FOUND;
  }
  puVar6 = memacpy(src,len);
  *ret = puVar6;
joined_r0x080c17fc:
  if (puVar6 != (uchar *)0x0) {
    return HEADER_PARAM_FOUND;
  }
  return HEADER_PARAM_OUT_OF_MEMORY;
}



uchar * parse_header(uchar *head,uchar *item,uchar **ptr)

{
  byte bVar1;
  int iVar2;
  int iVar3;
  uchar *puVar4;
  byte bVar5;
  byte bVar6;
  byte *len;
  byte *pbVar7;
  byte *pbVar8;
  
  if (head == (uchar *)0x0) {
    return (uchar *)0x0;
  }
LAB_080c19ae:
  pbVar7 = head;
  bVar5 = *head;
  do {
    do {
      do {
        if (bVar5 == 0) {
          return (uchar *)0x0;
        }
        len = pbVar7;
        if (bVar5 != 10) {
          while( true ) {
            pbVar7 = pbVar7 + 1;
            len = pbVar7;
            if (*pbVar7 == 10) break;
            if (*pbVar7 == 0) {
              return (uchar *)0x0;
            }
          }
        }
        pbVar7 = len + 1;
        bVar5 = *item;
        pbVar8 = item;
        if (bVar5 != 0) {
          bVar6 = len[1];
          while( true ) {
            if (bVar6 == 0) {
              return (uchar *)0x0;
            }
            iVar2 = c_toupper((uint)bVar5);
            iVar3 = c_toupper((uint)*pbVar7);
            if (iVar2 != iVar3) break;
            pbVar8 = pbVar8 + 1;
            pbVar7 = pbVar7 + 1;
            bVar5 = *pbVar8;
            if (bVar5 == 0) break;
            bVar6 = *pbVar7;
          }
        }
        bVar5 = *pbVar7;
        if (bVar5 == 0) {
          return (uchar *)0x0;
        }
      } while (*pbVar8 != 0);
      head = pbVar7;
      if ((bVar5 == 0x20) || (bVar6 = bVar5, bVar5 == 9)) {
        do {
          do {
            head = head + 1;
            bVar6 = *head;
          } while (bVar6 == 9);
        } while (bVar6 == 0x20);
        if (bVar6 == 0) {
          return (uchar *)0x0;
        }
      }
      if ((bVar6 == 0x3d) || (bVar6 == 0x3a)) {
        head = head + 1;
      }
      bVar6 = *head;
      if (bVar6 == 0) {
        return (uchar *)0x0;
      }
      if ((bVar6 == 9) || (bVar6 == 0x20)) {
        do {
          do {
            head = head + 1;
            bVar6 = *head;
          } while (bVar6 == 9);
        } while (bVar6 == 0x20);
        if (bVar6 == 0) {
          return (uchar *)0x0;
        }
      }
      len = head;
      bVar1 = bVar6;
    } while (pbVar7 == head);
    while (pbVar7 = head, bVar5 = bVar6, bVar1 != 0x7f) {
      if (((bVar1 < 0x21) && (bVar1 != 9)) && (bVar1 != 0x20)) {
        if (bVar1 == 0) {
          return (uchar *)0x0;
        }
        if ((bVar1 == 10) || (bVar1 == 0xd)) {
          if ((len <= head) || ((pbVar7 = len, len[-1] != 0x20 && (len[-1] != 9))))
          goto LAB_080c1b1c;
          goto joined_r0x080c1b04;
        }
        break;
      }
      len = len + 1;
      bVar1 = *len;
    }
  } while( true );
  while ((pbVar8 = pbVar7 + -2, pbVar7 = len, *pbVar8 == 9 || (*pbVar8 == 0x20))) {
joined_r0x080c1b04:
    len = pbVar7 + -1;
    if (len <= head) break;
  }
LAB_080c1b1c:
  if (assert_failed != 0) {
    assert_failed = 0;
    return (uchar *)0x0;
  }
  len = len + -(int)head;
  assert_failed = -((int)len >> 0x1f);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/header.c";
    errline = 0xb3;
    elinks_internal((uchar *)"assertion len >= 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (uchar *)0x0;
    }
  }
  if (len != (byte *)0x0) {
    puVar4 = memacpy(head,(int)len);
    if (puVar4 == (uchar *)0x0) {
      return (uchar *)0x0;
    }
    if (ptr != (uchar **)0x0) {
      *ptr = head;
      return puVar4;
    }
    return puVar4;
  }
  goto LAB_080c19ae;
}



protocol_handler_T * get_protocol_handler(protocol protocol)

{
  protocol_handler_T *ppVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (protocol_handler_T *)0x0;
  }
  assert_failed = ZEXT14(PROTOCOL_LUA < protocol);
  if (PROTOCOL_LUA < protocol) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 0xce;
    elinks_internal((uchar *)"assertion VALID_PROTOCOL(protocol) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (protocol_handler_T *)0x0;
    }
    ppVar1 = protocol_backends[protocol].handler;
  }
  else {
    ppVar1 = protocol_backends[protocol].handler;
  }
  return ppVar1;
}



int get_protocol_need_ssl(protocol protocol)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  assert_failed = ZEXT14(PROTOCOL_LUA < protocol);
  if (PROTOCOL_LUA < protocol) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 0xc6;
    elinks_internal((uchar *)"assertion VALID_PROTOCOL(protocol) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  return (uint)(*(byte *)&protocol_backends[protocol].field_0xc >> 3) & 1;
}



int get_protocol_free_syntax(protocol protocol)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  assert_failed = ZEXT14(PROTOCOL_LUA < protocol);
  if (PROTOCOL_LUA < protocol) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 0xbe;
    elinks_internal((uchar *)"assertion VALID_PROTOCOL(protocol) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  return (uint)(*(byte *)&protocol_backends[protocol].field_0xc >> 2) & 1;
}



int get_protocol_keep_double_slashes(protocol protocol)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  assert_failed = ZEXT14(PROTOCOL_LUA < protocol);
  if (PROTOCOL_LUA < protocol) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 0xb6;
    elinks_internal((uchar *)"assertion VALID_PROTOCOL(protocol) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  return (uint)(*(byte *)&protocol_backends[protocol].field_0xc >> 4) & 1;
}



int get_protocol_need_slash_after_host(protocol protocol)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  assert_failed = ZEXT14(PROTOCOL_LUA < protocol);
  if (PROTOCOL_LUA < protocol) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 0xae;
    elinks_internal((uchar *)"assertion VALID_PROTOCOL(protocol) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  return (uint)(*(byte *)&protocol_backends[protocol].field_0xc >> 1) & 1;
}



int get_protocol_need_slashes(protocol protocol)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  assert_failed = ZEXT14(PROTOCOL_LUA < protocol);
  if (PROTOCOL_LUA < protocol) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 0xa6;
    elinks_internal((uchar *)"assertion VALID_PROTOCOL(protocol) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  return (uint)*(byte *)&protocol_backends[protocol].field_0xc & 1;
}



int get_protocol_port(protocol protocol)

{
  uint uVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  assert_failed = ZEXT14(PROTOCOL_LUA < protocol);
  if (PROTOCOL_LUA < protocol) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 0x9a;
    elinks_internal((uchar *)"assertion VALID_PROTOCOL(protocol) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  uVar1 = protocol_backends[protocol].port;
  assert_failed = ZEXT14(0xffff < uVar1);
  if (0xffff < uVar1) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 0x9d;
    elinks_internal((uchar *)"assertion uri_port_is_valid(protocol_backends[protocol].port) failed!"
                   );
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  return uVar1;
}



protocol_external_handler_T * get_protocol_external_handler(terminal *term,uri *uri)

{
  code *pcVar1;
  uchar *puVar2;
  
  if (assert_failed == 0) {
    if ((uri == (uri *)0x0) || (0x14 < (uint)uri->protocol)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
      errline = 0x102;
      elinks_internal((uchar *)"assertion uri && VALID_PROTOCOL(uri->protocol) failed!");
      if (assert_failed != 0) goto LAB_080c2014;
    }
    else {
      assert_failed = 0;
    }
    puVar2 = get_user_program(term,uri->string,(uint)*(ushort *)&uri->field_0x28);
    if ((puVar2 == (uchar *)0x0) || (pcVar1 = user_protocol_handler, *puVar2 == '\0')) {
      pcVar1 = (protocol_external_handler_T *)0x0;
      if (protocol_backends[uri->protocol].handler == (protocol_handler_T *)0x0) {
        pcVar1 = generic_external_protocol_handler;
      }
      return pcVar1;
    }
  }
  else {
LAB_080c2014:
    assert_failed = 0;
    pcVar1 = (protocol_external_handler_T *)0x0;
  }
  return pcVar1;
}



protocol get_protocol(uchar *name,int namelen)

{
  size_t sVar1;
  size_t n;
  int iVar2;
  uchar *__s;
  int iVar3;
  protocol pVar4;
  bool bVar5;
  bool bVar6;
  int local_20;
  
  if (assert_failed == 0) {
    assert_failed = 0;
  }
  pVar4 = PROTOCOL_HTTP;
  iVar3 = 0x11;
  local_20 = 0;
  while( true ) {
    __s = protocol_backends[pVar4].name;
    sVar1 = strlen((char *)__s);
    n = namelen;
    if ((int)sVar1 <= namelen) {
      n = sVar1;
    }
    iVar2 = c_strncasecmp((char *)__s,(char *)name,n);
    bVar6 = false;
    bVar5 = iVar2 == 0;
    if (bVar5) {
      bVar6 = SBORROW4(sVar1,namelen);
      iVar2 = sVar1 - namelen;
      bVar5 = sVar1 == namelen;
      if (bVar5) {
        return pVar4;
      }
    }
    if (bVar5 || bVar6 != iVar2 < 0) {
      local_20 = pVar4 + PROTOCOL_BITTORRENT;
    }
    else {
      iVar3 = pVar4 + ~PROTOCOL_ABOUT;
    }
    if (iVar3 < local_20) break;
    pVar4 = (iVar3 + local_20) / 2;
  }
  __s = get_user_program((terminal *)0x0,name,namelen);
  return PROTOCOL_USER - (uint)(__s == (uchar *)0x0);
}



void generic_external_protocol_handler(session *ses,uri *uri)

{
  int iVar1;
  uchar *text;
  uint uVar2;
  
  iVar1 = uri->protocol;
  if (iVar1 == 0xb) {
    if (assert_failed == 0) {
      uVar2 = 0xfffe7708;
      goto LAB_080c2251;
    }
  }
  else {
    if (iVar1 != 0x12) {
      text = msg_text(ses->tab->term,
                      (uchar *)"This version of ELinks does not contain %s protocol support",
                      protocol_backends[iVar1].name);
      msg_box(ses->tab->term,(memory_list *)0x0,MSGBOX_FREE_TEXT,"Error",ALIGN_CENTER,text,ses,1,
              &DAT_081275e4,0,3);
      return;
    }
    if (assert_failed == 0) {
      uVar2 = 0xfffe7951;
      goto LAB_080c2251;
    }
  }
  uVar2 = 0xfffe795d;
LAB_080c2251:
  assert_failed = 0;
  print_error_dialog(ses,(connection_state)(ulonglong)uVar2,uri,PRI_CANCEL);
  return;
}



uri * get_proxied_uri(uri *uri)

{
  uri *puVar1;
  
  if (uri->protocol != 0xf) {
    puVar1 = get_composed_uri(uri,URI_BASE);
    return puVar1;
  }
  puVar1 = get_uri(uri->data,URI_BASE);
  return puVar1;
}



uchar * __regparm3 strip_proxy_protocol(uchar *proxy,uchar *strip1,uchar *strip2)

{
  size_t n;
  int iVar1;
  
  if (assert_failed == 0) {
    if ((proxy == (uchar *)0x0) || (*proxy == '\0')) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/proxy.c";
      errline = 0x57;
      elinks_internal((uchar *)"assertion proxy && *proxy failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  n = strlen((char *)strip1);
  iVar1 = c_strncasecmp((char *)proxy,(char *)strip1,n);
  if (iVar1 == 0) {
    n = strlen((char *)strip1);
    proxy = proxy + n;
  }
  else {
    if (strip2 != (uchar *)0x0) {
      n = strlen((char *)strip2);
      iVar1 = c_strncasecmp((char *)proxy,(char *)strip2,n);
      if (iVar1 == 0) {
        n = strlen((char *)strip2);
        proxy = proxy + n;
      }
    }
  }
  return proxy;
}



uchar * __regparm3
get_protocol_proxy(uchar *opt,uchar *env1,uchar *env2,uchar *strip1,uchar *strip2)

{
  uchar **ppuVar1;
  uchar *proxy;
  
  ppuVar1 = (uchar **)get_opt_(config_options,strip1);
  proxy = *ppuVar1;
  if (*proxy == '\0') {
    proxy = (uchar *)getenv((char *)env1);
  }
  if ((proxy == (uchar *)0x0) || (*proxy == '\0')) {
    proxy = (uchar *)getenv((char *)env2);
    if ((proxy == (uchar *)0x0) || (*proxy == '\0')) {
      return proxy;
    }
  }
  proxy = strip_proxy_protocol(proxy,strip1,strip2);
  return proxy;
}



uri * __regparm3 proxy_uri(uri *uri,uchar *proxy,connection_state *error_state)

{
  string *psVar1;
  uri *puVar2;
  connection_basic_state cVar3;
  string string;
  
  psVar1 = init_string(&string);
  if (psVar1 != (string *)0x0) {
    psVar1 = string_concat(&string,"proxy://",proxy,&DAT_08132419,0);
    if (psVar1 != (string *)0x0) {
      psVar1 = add_uri_to_string(&string,uri,URI_BASE);
      if (psVar1 != (string *)0x0) {
        puVar2 = get_uri(string.source,0);
        if (puVar2 == (uri *)0x0) {
          if (assert_failed == 0) {
            cVar3 = S_PROXY_ERROR;
          }
          else {
            cVar3 = S_INTERNAL;
          }
          assert_failed = 0;
          error_state->basic = cVar3;
          error_state->syserr = 0;
        }
        goto LAB_080c24ce;
      }
    }
  }
  if (assert_failed == 0) {
    cVar3 = S_OUT_OF_MEM;
  }
  else {
    cVar3 = S_INTERNAL;
  }
  assert_failed = 0;
  puVar2 = (uri *)0x0;
  error_state->basic = cVar3;
  error_state->syserr = 0;
LAB_080c24ce:
  done_string(&string);
  return puVar2;
}



uri * get_proxy_uri(uri *uri,connection_state *error_state)

{
  int iVar1;
  uri *puVar2;
  uchar *proxy;
  char *pcVar3;
  byte **ppbVar4;
  ushort **ppuVar5;
  char *pcVar6;
  char *pcVar7;
  uchar *name;
  byte bVar8;
  byte *__s;
  uchar *local_3c;
  uchar *local_20 [4];
  int get_proxy_event_id;
  
  if (uri->protocol == 0xf) {
    puVar2 = get_composed_uri(uri,URI_BASE);
    return puVar2;
  }
  local_20[0] = (uchar *)0x0;
  if (get_proxy_event_id == -1) {
    get_proxy_event_id = get_event_id((uchar *)"get-proxy");
  }
  trigger_event(get_proxy_event_id,local_20,uri->string);
  if (local_20[0] == (uchar *)0x0) {
    iVar1 = uri->protocol;
    if (iVar1 == 9) {
      local_3c = get_protocol_proxy((uchar *)"protocol.http.proxy.host",(uchar *)"HTTP_PROXY",
                                    (uchar *)"http_proxy",(uchar *)"http://",(uchar *)0x0);
    }
    else {
      if (iVar1 == 10) {
        local_3c = get_protocol_proxy((uchar *)"protocol.https.proxy.host",(uchar *)"HTTPS_PROXY",
                                      (uchar *)"https_proxy",(uchar *)"http://",(uchar *)0x0);
      }
      else {
        if (iVar1 != 7) goto LAB_080c25bc;
        local_3c = get_protocol_proxy((uchar *)"protocol.ftp.proxy.host",(uchar *)"FTP_PROXY",
                                      (uchar *)"ftp_proxy",(uchar *)"ftp://",(uchar *)"http://");
      }
    }
    if ((local_3c != (uchar *)0x0) && (*local_3c != '\0')) {
      pcVar3 = strchr((char *)local_3c,0x2f);
      if (pcVar3 != (char *)0x0) {
        *pcVar3 = '\0';
      }
      ppbVar4 = (byte **)get_opt_(config_options,name);
      __s = *ppbVar4;
      if (*__s == 0) {
        __s = (byte *)getenv("NO_PROXY");
      }
      if ((__s == (byte *)0x0) || (*__s == 0)) {
        __s = (byte *)getenv("no_proxy");
      }
      proxy = uri->host;
      pcVar3 = strchr((char *)proxy,0x2f);
      if (pcVar3 != (char *)0x0) {
        *pcVar3 = '\0';
      }
      if ((__s != (byte *)0x0) && (bVar8 = *__s, bVar8 != 0)) {
        ppuVar5 = __ctype_b_loc();
        while( true ) {
          pcVar6 = strchr((char *)__s,0x2c);
          while ((*(byte *)((int)*ppuVar5 + (uint)bVar8 * 2 + 1) & 0x20) != 0) {
            __s = __s + 1;
            bVar8 = *__s;
          }
          if (pcVar6 != (char *)0x0) {
            *pcVar6 = '\0';
          }
          pcVar7 = c_strcasestr((char *)proxy,(char *)__s);
          if (pcVar7 != (char *)0x0) {
            if (pcVar6 != (char *)0x0) {
              *pcVar6 = ',';
            }
            if (pcVar3 != (char *)0x0) {
              *pcVar3 = '/';
            }
            goto LAB_080c25bc;
          }
          if (pcVar6 == (char *)0x0) break;
          __s = (byte *)(pcVar6 + 1);
          *pcVar6 = ',';
          if ((__s == (byte *)0x0) || (bVar8 = pcVar6[1], bVar8 == 0)) break;
        }
      }
      if (pcVar3 != (char *)0x0) {
        *pcVar3 = '/';
      }
      puVar2 = proxy_uri(uri,local_3c,error_state);
      goto LAB_080c25cc;
    }
  }
  else {
    if (*local_20[0] != '\0') {
      proxy = strip_proxy_protocol(local_20[0],(uchar *)"http://",(uchar *)"ftp://");
      puVar2 = proxy_uri(uri,proxy,error_state);
      goto LAB_080c25cc;
    }
  }
LAB_080c25bc:
  puVar2 = get_composed_uri(uri,URI_BASE);
LAB_080c25cc:
  if (local_20[0] != (uchar *)0x0) {
    mem_free(local_20[0]);
  }
  return puVar2;
}



void decode_uri(uchar *src)

{
  byte *pbVar1;
  byte *pbVar2;
  byte bVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  
  pbVar2 = src + 1;
  pbVar1 = pbVar2;
  do {
    bVar3 = *src;
    if (bVar3 == 0x25) {
      bVar3 = *pbVar1;
      uVar5 = (uint)bVar3;
      if ((byte)(bVar3 - 0x30) < 10) {
        iVar6 = uVar5 - 0x30;
LAB_080c2895:
        if (-1 < iVar6) {
          bVar3 = pbVar1[1];
          uVar5 = (uint)bVar3;
          if ((byte)(bVar3 - 0x30) < 10) {
            iVar4 = uVar5 - 0x30;
          }
          else {
            if ((byte)(bVar3 + 0x9f) < 6) {
              iVar4 = uVar5 - 0x57;
            }
            else {
              if (5 < (byte)(bVar3 + 0xbf)) goto LAB_080c28f8;
              iVar4 = uVar5 - 0x37;
            }
          }
          if ((-1 < iVar4) && (iVar4 = iVar4 + iVar6 * 0x10, iVar4 != 0)) {
            bVar3 = (byte)iVar4;
            pbVar1 = pbVar1 + 2;
            pbVar2[-1] = bVar3;
            if (bVar3 == 0) {
              return;
            }
            goto LAB_080c286f;
          }
        }
      }
      else {
        if ((byte)(bVar3 + 0x9f) < 6) {
          iVar6 = uVar5 - 0x57;
          goto LAB_080c2895;
        }
        if ((byte)(bVar3 + 0xbf) < 6) {
          iVar6 = uVar5 - 0x37;
          goto LAB_080c2895;
        }
      }
LAB_080c28f8:
      pbVar2[-1] = 0x25;
    }
    else {
      pbVar2[-1] = bVar3;
      if (bVar3 == 0) {
        return;
      }
    }
LAB_080c286f:
    pbVar2 = pbVar2 + 1;
    src = pbVar1;
    pbVar1 = pbVar1 + 1;
  } while( true );
}



void decode_uri_string(string *string)

{
  size_t sVar1;
  
  decode_uri(string->source);
  sVar1 = strlen((char *)string->source);
  string->length = sVar1;
  return;
}



void done_uri(uri *uri)

{
  uchar *key;
  size_t keylen;
  hash_item *item;
  int iVar1;
  void *p;
  
  key = uri->string;
  keylen = strlen((char *)key);
  if ((assert_failed == 0) && (assert_failed = ZEXT14(uri_cache.object == 0), uri_cache.object == 0)
     ) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
    errline = 0x64d;
    elinks_internal((uchar *)"assertion is_object_used(&uri_cache) failed!");
  }
  iVar1 = (uri->object).refcount + -1;
  (uri->object).refcount = iVar1;
  if (iVar1 == 0) {
    p = (void *)0x0;
    item = get_hash_item(uri_cache.map,key,keylen);
    if (item != (hash_item *)0x0) {
      p = item->value;
    }
    if ((assert_failed == 0) && (assert_failed = ZEXT14(p == (void *)0x0), p == (void *)0x0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
      errline = 0x655;
      elinks_internal((uchar *)"assertion entry != NULL failed: Releasing unknown URI [%s]",key);
    }
    del_hash_item(uri_cache.map,item);
    mem_free(p);
    uri_cache.object = uri_cache.object + -1;
    if (uri_cache.object == 0) {
      free_hash((hash **)&uri_cache);
      return;
    }
  }
  return;
}



void free_uri_list(uri_list *list)

{
  uri *p;
  int iVar1;
  
  p = (uri *)list->uris;
  if (p == (uri *)0x0) {
    return;
  }
  if (0 < list->size) {
    iVar1 = 0;
    do {
      if (((uri **)p)[iVar1] != (uri *)0x0) {
        done_uri(((uri **)p)[iVar1]);
        p = (uri *)list->uris;
      }
      iVar1 = iVar1 + 1;
    } while (list->size != iVar1 && iVar1 <= list->size);
    if (p == (uri *)0x0) goto LAB_080c2b05;
  }
  mem_free(p);
LAB_080c2b05:
  list->uris = (uri **)0x0;
  list->size = 0;
  return;
}



void * __regparm3 mem_align_alloc__(void **ptr,size_t old,size_t new,size_t objsize,size_t mask)

{
  void *pvVar1;
  uint uVar2;
  size_t size;
  uint uVar3;
  int iVar4;
  
  uVar2 = mask + new & ~mask;
  uVar3 = mask + old & ~mask;
  if (uVar3 < uVar2) {
    size = uVar2 * objsize;
    pvVar1 = mem_realloc(*ptr,size);
    if (pvVar1 == (void *)0x0) {
      return (void *)0x0;
    }
    iVar4 = uVar3 * objsize;
    *ptr = pvVar1;
    memset((void *)((int)pvVar1 + iVar4),0,size - iVar4);
  }
  return *ptr;
}



string * __regparm3 add_bytes_to_string__(string *string,uchar *bytes,int length)

{
  int iVar1;
  void *pvVar2;
  
  if (assert_failed == 0) {
    if (((bytes == (uchar *)0x0) || (string == (string *)0x0)) || (length < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080c2bbf;
    }
    else {
      assert_failed = 0;
    }
    if (length != 0) {
      iVar1 = length + string->length;
      pvVar2 = mem_align_alloc__((void **)string,string->length,iVar1 + 1,1,0xff);
      if (pvVar2 == (void *)0x0) {
        string = (string *)0x0;
      }
      else {
        memcpy(string->source + string->length,bytes,length);
        string->source[iVar1] = '\0';
        string->length = iVar1;
      }
    }
  }
  else {
LAB_080c2bbf:
    assert_failed = 0;
    string = (string *)0x0;
  }
  return string;
}



void decode_uri_for_display(uchar *src)

{
  ushort **ppuVar1;
  byte bVar2;
  
  decode_uri(src);
  bVar2 = *src;
  if (bVar2 != 0) {
    ppuVar1 = __ctype_b_loc();
    do {
      if (((*ppuVar1)[bVar2] & 0x4002) != 0x4000) {
        *src = 0x2a;
      }
      src = src + 1;
      bVar2 = *src;
    } while (bVar2 != 0);
  }
  return;
}



void decode_uri_string_for_display(string *string)

{
  size_t sVar1;
  
  decode_uri_for_display(string->source);
  sVar1 = strlen((char *)string->source);
  string->length = sVar1;
  return;
}



uchar * get_extension_from_uri(uri *uri)

{
  uchar uVar1;
  uchar *puVar2;
  uchar *src;
  uchar *puVar3;
  bool bVar4;
  
  puVar3 = uri->data;
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(puVar3 == (uchar *)0x0), puVar3 == (uchar *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
    errline = 0x52a;
    elinks_internal((uchar *)"assertion pos failed!");
  }
  uVar1 = *puVar3;
  if ((((uVar1 != '\0') && (uVar1 != '\x01')) && (uVar1 != '#')) && (uVar1 != '?')) {
    bVar4 = true;
    puVar2 = (uchar *)0x0;
    do {
      if ((((puVar2 != (uchar *)0x0) || (bVar4)) || (src = puVar3, uVar1 != '.')) &&
         (bVar4 = uVar1 == '/', src = puVar2, bVar4)) {
        src = (uchar *)0x0;
      }
      puVar3 = puVar3 + 1;
      uVar1 = *puVar3;
    } while (((uVar1 != '\0') && (uVar1 != '#')) &&
            ((uVar1 != '\x01' && (puVar2 = src, uVar1 != '?'))));
    if ((src < puVar3) && (src != (uchar *)0x0)) {
      puVar3 = memacpy(src,(int)(puVar3 + -(int)src));
      return puVar3;
    }
  }
  return (uchar *)0x0;
}



int end_with_known_tld(uchar *s,int slen)

{
  uchar *tld [16];
  size_t n;
  int iVar1;
  int iVar2;
  uchar *__s;
  int local_20;
  
  if (slen != 0) {
    if (slen < 0) {
      slen = strlen((char *)s);
    }
    __s = "com";
    local_20 = 0;
    do {
      n = strlen((char *)__s);
      iVar2 = slen - n;
      if ((-1 < iVar2) && (iVar1 = c_strncasecmp((char *)(s + iVar2),(char *)__s,n), iVar1 == 0)) {
        return iVar2;
      }
      local_20 = local_20 + 1;
      __s = ((uchar **)&ram0x0810cac0)[local_20];
    } while (__s != (uchar *)0x0);
  }
  return -1;
}



int is_in_domain(uchar *domain,uchar *server,int server_len)

{
  size_t n;
  uint uVar1;
  int iVar2;
  
  n = strlen((char *)domain);
  if (server_len < (int)n) {
LAB_080c2ef2:
    uVar1 = 0;
  }
  else {
    if (n != server_len) {
      if (server[(server_len - n) + -1] != '.') goto LAB_080c2ef2;
      server = server + (server_len - n);
    }
    iVar2 = c_strncasecmp((char *)domain,(char *)server,n);
    uVar1 = (uint)(iVar2 == 0);
  }
  return uVar1;
}



int __regparm3 check_whether_file_exists(uchar *name)

{
  byte bVar1;
  uchar "\x01#?" [4];
  size_t __n;
  int iVar2;
  byte *pbVar3;
  int iVar4;
  
  __n = strlen((char *)name);
  iVar2 = file_exists(name);
  if (iVar2 == 0) {
    iVar2 = 0;
    do {
      bVar1 = "\x01#?"[iVar2];
      pbVar3 = (byte *)memchr(name,(uint)bVar1,__n);
      if (pbVar3 != (byte *)0x0) {
        *pbVar3 = 0;
        iVar4 = file_exists(name);
        *pbVar3 = bVar1;
        if (iVar4 != 0) {
          return (int)(pbVar3 + -(int)name);
        }
      }
      iVar2 = iVar2 + 1;
    } while (iVar2 != 3);
    __n = 0xffffffff;
  }
  return __n;
}



protocol __regparm3 find_uri_protocol(uchar *newurl)

{
  uchar *puVar1;
  uchar uVar2;
  int iVar3;
  size_t sVar4;
  char *pcVar5;
  char *pcVar6;
  uchar *s;
  uchar *puVar7;
  
  iVar3 = check_whether_file_exists(newurl);
  if (-1 < iVar3) {
    return PROTOCOL_FILE;
  }
  sVar4 = strcspn((char *)newurl,".:/@");
  puVar7 = newurl + sVar4;
  if ((*puVar7 == '@') ||
     ((((*puVar7 == ':' && (*newurl != '[')) &&
       (pcVar5 = strchr((char *)newurl,0x40), pcVar5 != (char *)0x0)) ||
      (iVar3 = c_strncasecmp((char *)newurl,"ftp.",4), iVar3 == 0)))) {
    return PROTOCOL_FTP;
  }
  if (*newurl == '[') {
    uVar2 = *puVar7;
    if (uVar2 == ':') {
      pcVar5 = strchr((char *)(puVar7 + 1),0x5d);
      pcVar6 = strchr((char *)(puVar7 + 1),0x3a);
      if (pcVar6 == (char *)0x0) {
        return PROTOCOL_UNKNOWN;
      }
      if (pcVar5 != (char *)0x0) {
        if (pcVar6 < pcVar5) {
          return PROTOCOL_HTTP;
        }
        return PROTOCOL_UNKNOWN;
      }
      return PROTOCOL_UNKNOWN;
    }
  }
  else {
    if (*newurl == '.') {
      return PROTOCOL_UNKNOWN;
    }
    uVar2 = *puVar7;
  }
  puVar1 = puVar7;
  if (uVar2 != '.') {
    return PROTOCOL_UNKNOWN;
  }
  do {
    s = puVar1 + 1;
    sVar4 = strcspn((char *)s,".:/?");
    puVar1 = s + sVar4;
  } while (*puVar1 == '.');
  do {
    do {
      puVar7 = puVar7 + 1;
      uVar2 = *puVar7;
    } while ((byte)(uVar2 - 0x30) < 10);
  } while (uVar2 == '.');
  if (((uVar2 != ':') && (uVar2 != '\0')) &&
     ((uVar2 != '/' &&
      ((puVar1 + -(int)s != (uchar *)0x2 &&
       (iVar3 = end_with_known_tld(s,(int)(puVar1 + -(int)s)), iVar3 < 0)))))) {
    return PROTOCOL_UNKNOWN;
  }
  return PROTOCOL_HTTP;
}



int __regparm3 compare_component(uchar *a,int alen,uchar *b,int blen)

{
  uint uVar1;
  bool bVar2;
  
  if ((alen == blen) && ((b != (uchar *)0x0) == (a != (uchar *)0x0))) {
    if ((alen == 0) || (a == (uchar *)0x0)) {
      uVar1 = 1;
    }
    else {
      bVar2 = true;
      do {
        if (alen == 0) break;
        alen = alen + -1;
        bVar2 = *a == *b;
        a = a + 1;
        b = b + 1;
      } while (bVar2);
      uVar1 = (uint)bVar2;
    }
  }
  else {
    uVar1 = 0;
  }
  return uVar1;
}



int compare_uri(uri *a,uri *b,uri_component components)

{
  uchar *b_00;
  uchar *a_00;
  int iVar1;
  size_t blen;
  size_t alen;
  bool bVar2;
  
  if (a == b) {
LAB_080c3300:
    iVar1 = 1;
  }
  else {
    if (components != 0) {
      if ((assert_failed == 0) &&
         (bVar2 = (components & 0x7840U) != 0, assert_failed = ZEXT14(bVar2), bVar2)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
        errline = 0x1d4;
        elinks_internal((uchar *)
                        "assertion can_compare_uri_components(components) failed: compare_uri() is a work in progress. Component unsupported"
                       );
      }
      if ((((((((components & 1U) == 0) || (a->protocol == b->protocol)) &&
             (((components & 2U) == 0 || (a->ip_family == b->ip_family)))) &&
            (((components & 4U) == 0 ||
             (iVar1 = compare_component(a->user,(uint)*(ushort *)&a->field_0x2a,b->user,
                                        (uint)*(ushort *)&b->field_0x2a), iVar1 != 0)))) &&
           (((components & 8U) == 0 ||
            (iVar1 = compare_component(a->password,(uint)*(ushort *)&a->field_0x2c,b->password,
                                       (uint)*(ushort *)&b->field_0x2c), iVar1 != 0)))) &&
          (((((components & 0x10U) == 0 ||
             (iVar1 = compare_component(a->host,(uint)*(ushort *)&a->field_0x2e,b->host,
                                        (uint)*(ushort *)&b->field_0x2e), iVar1 != 0)) &&
            (((components & 0x20U) == 0 ||
             (iVar1 = compare_component(a->port,(uint)*(byte *)&a->field_0x30,b->port,
                                        (uint)*(byte *)&b->field_0x30), iVar1 != 0)))) &&
           ((-1 < (char)components ||
            (iVar1 = compare_component(a->data,(uint)*(ushort *)&a->field_0x31,b->data,
                                       (uint)*(ushort *)&b->field_0x31), iVar1 != 0)))))) &&
         (((components & 0x100U) == 0 ||
          (iVar1 = compare_component(a->fragment,(uint)*(ushort *)&a->field_0x34,b->fragment,
                                     (uint)*(ushort *)&b->field_0x34), iVar1 != 0)))) {
        if ((components & 0x200U) != 0) {
          b_00 = b->post;
          blen = 0;
          if (b_00 != (uchar *)0x0) {
            blen = strlen((char *)b_00);
          }
          a_00 = a->post;
          alen = 0;
          if (a_00 != (uchar *)0x0) {
            alen = strlen((char *)a_00);
          }
          iVar1 = compare_component(a_00,alen,b_00,blen);
          return (uint)(iVar1 != 0);
        }
        goto LAB_080c3300;
      }
    }
    iVar1 = 0;
  }
  return iVar1;
}



int get_uri_port(uri *uri)

{
  uchar *__nptr;
  int iVar1;
  uint uVar2;
  uchar *local_10 [2];
  
  __nptr = uri->port;
  if (((__nptr == (uchar *)0x0) || (*(char *)&uri->field_0x30 == '\0')) ||
     (local_10[0] = __nptr, uVar2 = strtol((char *)__nptr,(char **)local_10,10),
     uri->port == local_10[0])) {
    iVar1 = get_protocol_port(uri->protocol);
    return iVar1;
  }
  if (assert_failed != 0) {
    return uVar2;
  }
  assert_failed = ZEXT14(0xffff < uVar2);
  if (0xffff >= uVar2) {
    return uVar2;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
  errline = 0x1b2;
  elinks_internal((uchar *)"assertion uri_port_is_valid(port) failed!");
  return uVar2;
}



// WARNING: Could not reconcile some variable overlaps

uri_errno parse_uri(uri *uri,uchar *uristring)

{
  byte bVar1;
  ushort uVar2;
  ushort **ppuVar3;
  protocol pVar4;
  byte *pbVar5;
  uri_errno uVar6;
  uint uVar7;
  size_t sVar8;
  int iVar9;
  int *piVar10;
  int iVar11;
  uint uVar12;
  byte bVar13;
  short sVar14;
  undefined2 uVar15;
  uint uVar16;
  byte *pbVar17;
  uri *puVar18;
  char *local_2c;
  byte local_25;
  byte *local_24;
  byte *local_20;
  
  bVar1 = 0;
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(uristring == (uchar *)0x0), uristring == (uchar *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
    errline = 0xd4;
    elinks_internal((uchar *)"assertion uristring != NULL failed: No uri to parse.");
  }
  iVar11 = 0xf;
  puVar18 = uri;
  while (iVar11 != 0) {
    iVar11 = iVar11 + -1;
    puVar18->string = (uchar *)0x0;
    puVar18 = (uri *)((int)puVar18 + (uint)bVar1 * -8 + 4);
  }
  if (assert_failed != 0) {
    assert_failed = 0;
    return URI_ERRNO_OK;
  }
  if (*uristring == '\0') {
    return URI_ERRNO_EMPTY;
  }
  uri->string = uristring;
  ppuVar3 = __ctype_b_loc();
  pbVar5 = uristring;
  while ((((bVar13 = *pbVar5, (*(byte *)(*ppuVar3 + bVar13) & 8) != 0 || (bVar13 == 0x2b)) ||
          (bVar13 == 0x2d)) || (bVar13 == 0x2e))) {
    pbVar5 = pbVar5 + 1;
  }
  if (((uristring == pbVar5) || (pbVar17 = pbVar5 + -1, 9 < (byte)(pbVar5[-1] - 0x30))) &&
     (pbVar17 = pbVar5, 10 < (byte)(bVar13 - 0x30))) {
    *(undefined2 *)&uri->field_0x28 = 0;
    return URI_ERRNO_INVALID_PROTOCOL;
  }
  sVar14 = (short)(pbVar17 + -(int)uristring);
  *(short *)&uri->field_0x28 = sVar14;
  if (sVar14 == 0) {
    return URI_ERRNO_INVALID_PROTOCOL;
  }
  pVar4 = get_protocol(uristring,(uint)(pbVar17 + -(int)uristring) & 0xffff);
  uri->protocol = pVar4;
  pbVar5 = uristring + *(ushort *)&uri->field_0x28;
  bVar13 = *pbVar5;
  if ((byte)(bVar13 - 0x30) < 10) {
    pbVar5 = pbVar5 + 1;
    uri->ip_family = (uint)bVar13 - 0x30;
    bVar13 = *pbVar5;
  }
  if (bVar13 != 0x3a) {
    return URI_ERRNO_INVALID_PROTOCOL;
  }
  local_20 = pbVar5 + 1;
  if ((pbVar5[1] == 0x2f) && (pbVar5[2] == 0x2f)) {
    local_20 = pbVar5 + 3;
    if (pbVar5[3] == 0x2f) {
      iVar11 = get_protocol_need_slash_after_host(uri->protocol);
      uVar6 = URI_ERRNO_TOO_MANY_SLASHES;
      goto joined_r0x080c35c0;
    }
  }
  else {
    iVar11 = get_protocol_need_slashes(uri->protocol);
    uVar6 = URI_ERRNO_NO_SLASHES;
joined_r0x080c35c0:
    if (iVar11 != 0) {
      return uVar6;
    }
  }
  iVar11 = get_protocol_free_syntax(uri->protocol);
  if (iVar11 != 0) {
    uri->data = local_20;
    sVar8 = strlen((char *)local_20);
    *(uint *)&uri->field_0x30 = *(uint *)&uri->field_0x30 & 0xff0000ff | (sVar8 & 0xffff) << 8;
    return URI_ERRNO_OK;
  }
  if (uri->protocol == 4) {
    bVar13 = *local_20;
    if (((bVar13 == 0) || (bVar13 == 0x23)) || (bVar13 == 1)) {
      uVar7 = 0;
      pbVar5 = local_20;
    }
    else {
      uVar7 = 0;
      do {
        uVar7 = uVar7 + 1;
        bVar13 = local_20[uVar7];
        if ((bVar13 == 0) || (bVar13 == 0x23)) break;
      } while (bVar13 != 1);
      if ((int)uVar7 < 0) {
        uVar7 = 0xffffffff;
        pbVar5 = local_20;
        do {
          if (uVar7 == 0) break;
          uVar7 = uVar7 - 1;
          bVar13 = *pbVar5;
          pbVar5 = pbVar5 + (uint)bVar1 * -2 + 1;
        } while (bVar13 != 0);
        uVar7 = ~uVar7 - 1;
        goto LAB_080c3ae1;
      }
      pbVar5 = local_20 + uVar7;
    }
    bVar1 = *pbVar5;
    if (bVar1 == 0x23) {
      uri->fragment = pbVar5 + 1;
      if ((pbVar5[1] == 0) || (pbVar5[1] == 1)) {
        uVar16 = 0;
        uVar15 = 0;
      }
      else {
        uVar12 = 0;
        do {
          uVar16 = uVar12 + 1;
          uVar15 = (undefined2)uVar16;
          iVar11 = uVar12 + 2;
          if (pbVar5[iVar11] == 0) break;
          uVar12 = uVar16;
        } while (pbVar5[iVar11] != 1);
        uVar16 = uVar16 & 0xffff;
      }
      pbVar5 = pbVar5 + 1 + uVar16;
      *(undefined2 *)&uri->field_0x34 = uVar15;
      bVar1 = *pbVar5;
    }
    if (bVar1 == 1) {
      uri->post = pbVar5 + 1;
    }
LAB_080c3ae1:
    if ((9 < (int)uVar7) && (iVar11 = c_strncasecmp((char *)local_20,"localhost/",10), iVar11 == 0))
    {
      local_20 = local_20 + 9;
      uVar7 = uVar7 - 9;
    }
    *(uint *)&uri->field_0x30 = *(uint *)&uri->field_0x30 & 0xff0000ff | (uVar7 & 0xffff) << 8;
    uri->data = local_20;
    return URI_ERRNO_OK;
  }
  local_2c = strchr((char *)local_20,0x5b);
  if (local_2c == (char *)0x0) {
    bVar1 = *local_20;
    local_24 = (byte *)0x0;
    local_25 = *(byte *)&uri->field_0x36;
  }
  else {
    local_24 = (byte *)strchr(local_2c,0x5d);
    if (local_24 == (byte *)0x0) {
      bVar1 = *local_20;
      local_2c = (char *)0x0;
      local_25 = *(byte *)&uri->field_0x36;
    }
    else {
      bVar1 = *local_20;
      if ((bVar1 == 0) || (bVar1 == 0x2f)) {
        iVar11 = 0;
      }
      else {
        iVar11 = 0;
        do {
          iVar11 = iVar11 + 1;
          if (local_20[iVar11] == 0) break;
        } while (local_20[iVar11] != 0x2f);
      }
      if (local_24 < local_20 + iVar11) {
        local_25 = *(byte *)&uri->field_0x36 | 1;
        *(byte *)&uri->field_0x36 = local_25;
        bVar1 = *local_20;
      }
      else {
        local_24 = (byte *)0x0;
        local_2c = (char *)0x0;
        local_25 = *(byte *)&uri->field_0x36;
      }
    }
  }
  if (bVar1 != 0) {
    iVar11 = 0;
    pbVar5 = local_20;
    if (bVar1 == 0x40) {
LAB_080c36ae:
      iVar11 = 0;
      do {
        iVar11 = iVar11 + 1;
        if (local_20[iVar11] == 0) break;
      } while (local_20[iVar11] != 0x2f);
    }
    else {
      do {
        iVar11 = iVar11 + 1;
        if (local_20[iVar11] == 0) break;
      } while (local_20[iVar11] != 0x40);
      pbVar5 = local_20 + iVar11;
      iVar11 = 0;
      if (bVar1 != 0x2f) goto LAB_080c36ae;
    }
    if ((pbVar5 < local_20 + iVar11) && (*pbVar5 != 0)) {
      while (bVar1 = pbVar5[1], bVar1 != 0) {
        uVar16 = 0;
        uVar7 = uVar16;
        if (bVar1 != 0x40) {
          do {
            uVar16 = uVar7 + 1;
            iVar11 = uVar7 + 2;
            if (pbVar5[iVar11] == 0) break;
            uVar7 = uVar16;
          } while (pbVar5[iVar11] != 0x40);
          if ((bVar1 == 0x2f) || (bVar1 == 0x3f)) break;
        }
        uVar7 = 0;
        do {
          uVar12 = uVar7 + 1;
          bVar13 = pbVar5[uVar7 + 2];
          if ((bVar13 == 0) || (bVar13 == 0x2f)) break;
          uVar7 = uVar12;
        } while (bVar13 != 0x3f);
        if (uVar12 <= uVar16) break;
        iVar11 = 1;
        iVar9 = 0;
        if (bVar1 != 0x40) {
          do {
            iVar11 = iVar9;
            if (pbVar5[iVar11 + 2] == 0) break;
            iVar9 = iVar11 + 1;
          } while (pbVar5[iVar11 + 2] != 0x40);
          iVar11 = iVar11 + 2;
        }
        pbVar5 = pbVar5 + iVar11;
      }
      pbVar17 = (byte *)strchr((char *)local_20,0x3a);
      if ((pbVar5 < pbVar17) || (pbVar17 == (byte *)0x0)) {
        uri->user = local_20;
        *(short *)&uri->field_0x2a = (short)pbVar5 - (short)local_20;
      }
      else {
        uri->user = local_20;
        uri->password = pbVar17 + 1;
        *(short *)&uri->field_0x2a = (short)pbVar17 - (short)local_20;
        *(short *)&uri->field_0x2c = ((short)pbVar5 + -1) - (short)pbVar17;
      }
      local_20 = pbVar5 + 1;
    }
  }
  if ((local_25 & 1) == 0) {
    bVar1 = *local_20;
    if ((((bVar1 == 0) || (bVar1 == 0x3a)) || (bVar1 == 0x2f)) || (bVar1 == 0x3f)) {
      iVar11 = 0;
    }
    else {
      iVar11 = 0;
      while( true ) {
        iVar11 = iVar11 + 1;
        bVar1 = local_20[iVar11];
        if ((bVar1 == 0) || (bVar1 == 0x3a)) break;
        if ((bVar1 == 0x2f) || (bVar1 == 0x3f)) break;
      }
    }
    local_24 = local_20 + iVar11;
    uVar2 = (short)local_24 - (short)local_20;
    uri->host = local_20;
    *(ushort *)&uri->field_0x2e = uVar2;
    if ((uVar2 != 0) && (local_20[(uint)uVar2 - 1] == 0x2e)) {
      return URI_ERRNO_TRAILING_DOTS;
    }
  }
  else {
    bVar1 = *local_24;
    if ((((bVar1 == 0) || (bVar1 == 0x3a)) || (bVar1 == 0x2f)) || (bVar1 == 0x3f)) {
      iVar11 = 0;
    }
    else {
      iVar11 = 0;
      while( true ) {
        iVar11 = iVar11 + 1;
        bVar1 = local_24[iVar11];
        if ((bVar1 == 0) || (bVar1 == 0x3a)) break;
        if ((bVar1 == 0x2f) || (bVar1 == 0x3f)) break;
      }
    }
    if (assert_failed != 0) {
      assert_failed = 0;
      return URI_ERRNO_IPV6_SECURITY;
    }
    pbVar5 = local_24 + (-1 - (int)local_2c);
    assert_failed = ZEXT14((byte *)0x400 < pbVar5);
    if ((byte *)0x400 < pbVar5) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
      errline = 0x15b;
      elinks_internal((uchar *)
                      "assertion addrlen >= 0 && addrlen < NI_MAXHOST failed: parse_uri(): addrlen value is bad (%d) for URL \'%s\'. Problems are likely to be encountered. Please report this, it is a security bug!"
                      ,pbVar5,uristring);
      if (assert_failed != 0) {
        assert_failed = 0;
        return URI_ERRNO_IPV6_SECURITY;
      }
    }
    *(undefined2 *)&uri->field_0x2e = (short)pbVar5;
    local_24 = local_24 + iVar11;
    *(char **)&uri->host = local_2c + 1;
  }
  bVar1 = *local_24;
  if (bVar1 == 0x3a) {
    if ((local_24[1] == 0) || (iVar11 = 0, local_24[1] == 0x2f)) {
      uri->port = local_24 + 1;
      *(undefined *)&uri->field_0x30 = 0;
      return URI_ERRNO_NO_PORT_COLON;
    }
    do {
      iVar9 = iVar11;
      if (local_24[iVar9 + 2] == 0) {
        pbVar5 = local_24 + iVar9 + 2;
        bVar1 = (char)pbVar5 - ((char)local_24 + '\x01');
        goto LAB_080c39df;
      }
      iVar11 = iVar9 + 1;
    } while (local_24[iVar9 + 2] != 0x2f);
    pbVar5 = local_24 + iVar9 + 2;
    bVar1 = (char)pbVar5 - ((char)local_24 + '\x01');
LAB_080c39df:
    pbVar17 = local_24 + 1;
    *(byte *)&uri->field_0x30 = bVar1;
    uri->port = pbVar17;
    if (bVar1 == 0) {
      return URI_ERRNO_NO_PORT_COLON;
    }
    if ((byte *)(uint)bVar1 == pbVar5 + -(int)pbVar17) {
      local_24 = pbVar17;
      if (pbVar5 <= pbVar17) {
LAB_080c3c9d:
        if (pbVar17 != (byte *)0x0) {
          piVar10 = __errno_location();
          *piVar10 = 0;
          uVar7 = strtol((char *)uri->port,(char **)0x0,10);
          if (0xffff < uVar7) {
            return URI_ERRNO_INVALID_PORT;
          }
          if (*piVar10 != 0) {
            return URI_ERRNO_INVALID_PORT;
          }
        }
        bVar1 = *local_24;
        goto LAB_080c387c;
      }
      bVar1 = *pbVar17;
      while ((byte)(bVar1 - 0x30) < 10) {
        local_24 = local_24 + 1;
        if (pbVar5 <= local_24) goto LAB_080c3c9d;
        bVar1 = *local_24;
      }
    }
    return URI_ERRNO_INVALID_PORT;
  }
LAB_080c387c:
  if (bVar1 == 0x2f) {
    local_24 = local_24 + 1;
  }
  else {
    iVar11 = get_protocol_need_slash_after_host(uri->protocol);
    if (iVar11 != 0) {
      return (-(uint)(*(short *)&uri->field_0x2e == 0) & 0xfffffffe) + URI_ERRNO_NO_HOST_SLASH;
    }
  }
  bVar1 = *local_24;
  if (((bVar1 == 0) || (bVar1 == 0x23)) || (bVar1 == 1)) {
    uVar7 = 0;
  }
  else {
    uVar7 = 0;
    do {
      uVar7 = uVar7 + 1;
      bVar1 = local_24[uVar7];
      if ((bVar1 == 0) || (bVar1 == 0x23)) break;
    } while (bVar1 != 1);
  }
  pbVar5 = local_24 + uVar7;
  uri->data = local_24;
  *(uint *)&uri->field_0x30 = *(uint *)&uri->field_0x30 & 0xff0000ff | (uVar7 & 0xffff) << 8;
  bVar1 = *pbVar5;
  if (bVar1 == 0x23) {
    uri->fragment = pbVar5 + 1;
    if ((pbVar5[1] == 0) || (pbVar5[1] == 1)) {
      uVar7 = 0;
      uVar15 = 0;
    }
    else {
      uVar16 = 0;
      do {
        uVar7 = uVar16 + 1;
        uVar15 = (undefined2)uVar7;
        iVar11 = uVar16 + 2;
        if (pbVar5[iVar11] == 0) break;
        uVar16 = uVar7;
      } while (pbVar5[iVar11] != 1);
      uVar7 = uVar7 & 0xffff;
    }
    pbVar5 = pbVar5 + 1 + uVar7;
    *(undefined2 *)&uri->field_0x34 = uVar15;
    bVar1 = *pbVar5;
  }
  if (bVar1 == 1) {
    uri->post = pbVar5 + 1;
    return URI_ERRNO_OK;
  }
  return URI_ERRNO_OK;
}



int is_ip_address(uchar *address,int addresslen)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int in_GS_OFFSET;
  in_addr addr4;
  uchar buffer [46];
  sockaddr_in6 addr6;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  uVar2 = 0;
  if ((uint)addresslen < 0x2e) {
    safe_strncpy(buffer,address,addresslen + 1);
    iVar3 = inet_pton(10,(char *)buffer,&addr6.sin6_addr);
    uVar2 = 1;
    if (iVar3 < 1) {
      iVar3 = inet_pton(2,(char *)buffer,&addr4);
      uVar2 = (uint)(0 < iVar3);
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



uchar * normalize_uri(uri *uri,uchar *uristring)

{
  uchar uVar1;
  uchar uVar2;
  int iVar3;
  int iVar4;
  uri_errno uVar5;
  size_t sVar6;
  uchar uVar7;
  uri *uri_00;
  byte *pbVar8;
  uchar *uristring_00;
  uchar *__src;
  int iVar9;
  bool bVar10;
  uchar *local_80;
  int local_74;
  uchar *local_60;
  uri uri_struct;
  
  uri_00 = &uri_struct;
  uristring_00 = uristring;
  if (uri != (uri *)0x0) goto LAB_080c3de5;
  do {
    uVar5 = parse_uri(uri_00,uristring_00);
    uri = uri_00;
    if (uVar5 != URI_ERRNO_OK) {
      return uristring;
    }
LAB_080c3de5:
    uri_00 = uri;
    if ((assert_failed == 0) &&
       (bVar10 = uri_00->data == (uchar *)0x0, assert_failed = ZEXT14(bVar10), bVar10)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
      errline = 0x2c4;
      elinks_internal((uchar *)"assertion uri->data failed!");
    }
    iVar3 = (uint)*(ushort *)&uri_00->field_0x28 - 1;
    if (iVar3 != -1) {
      pbVar8 = uri_00->string + iVar3;
      iVar9 = 0;
      do {
        while (iVar4 = c_isupper((uint)*pbVar8), iVar4 != 0) {
          iVar9 = iVar9 + -1;
          iVar4 = c_tolower((uint)*pbVar8);
          *pbVar8 = (byte)iVar4;
          pbVar8 = pbVar8 + -1;
          if (iVar3 + iVar9 == -1) goto LAB_080c3e5b;
        }
        iVar9 = iVar9 + -1;
        pbVar8 = pbVar8 + -1;
      } while (iVar3 + iVar9 != -1);
    }
LAB_080c3e5b:
    if (*(ushort *)&uri_00->field_0x2e != 0) {
      iVar3 = (uint)*(ushort *)&uri_00->field_0x2e - 1;
      if (-1 < iVar3) {
        pbVar8 = uri_00->host + iVar3;
        iVar9 = 0;
        do {
          while (iVar4 = c_isupper((uint)*pbVar8), iVar4 != 0) {
            iVar9 = iVar9 + -1;
            iVar4 = c_tolower((uint)*pbVar8);
            *pbVar8 = (byte)iVar4;
            pbVar8 = pbVar8 + -1;
            if (iVar3 + iVar9 < 0) goto LAB_080c3e68;
          }
          iVar9 = iVar9 + -1;
          pbVar8 = pbVar8 + -1;
        } while (-1 < iVar3 + iVar9);
      }
    }
LAB_080c3e68:
    uristring_00 = uri_00->data;
  } while (uri_00->protocol == PROTOCOL_PROXY);
  iVar3 = get_protocol_free_syntax(uri_00->protocol);
  if (iVar3 == 0) {
    iVar3 = 0;
    local_74 = 1;
    if (uri_00->protocol != PROTOCOL_UNKNOWN) {
      iVar3 = get_protocol_need_slash_after_host(uri_00->protocol);
      iVar3 = -iVar3;
      local_74 = get_protocol_keep_double_slashes(uri_00->protocol);
    }
    uristring_00 = uri_00->data + iVar3;
    uVar7 = *uristring_00;
    local_80 = uristring_00;
    local_60 = uristring_00;
LAB_080c3ee0:
    while (__src = local_80, uVar7 != '\0') {
      uVar1 = *__src;
      if (((uVar1 == '#') || (uVar1 == '\x01')) || (uVar1 == '?')) {
        sVar6 = strlen((char *)__src);
        memmove(local_60,__src,sVar6 + 1);
        return uristring;
      }
      if (uVar1 != '/') goto LAB_080c3f3a;
      if (__src[1] != '.') goto code_r0x080c3f6b;
      uVar2 = __src[2];
      if (uVar2 == '\0') {
LAB_080c407d:
        *local_60 = '/';
        local_60[1] = '\0';
        return uristring;
      }
      local_80 = __src + 2;
      if (uVar2 != '/') {
        if (uVar2 != '.') goto LAB_080c3f3a;
        local_80 = __src + 3;
        uVar7 = __src[3];
        if ((uVar7 != '/') && (uVar7 != '\0')) goto LAB_080c3f3a;
        do {
          if (local_60 <= uristring_00) break;
          local_60 = local_60 + -1;
        } while (*local_60 != '/');
        if (uVar7 == '\0') goto LAB_080c407d;
        goto LAB_080c3f4c;
      }
    }
  }
  return uristring;
code_r0x080c3f6b:
  if ((__src[1] != '/') || (local_80 = __src + 1, local_74 != 0)) {
LAB_080c3f3a:
    local_80 = __src + 1;
    *local_60 = uVar1;
    uVar7 = 0;
    if (uVar1 != '\0') {
      local_60 = local_60 + 1;
LAB_080c3f4c:
      uVar7 = *local_60;
    }
  }
  goto LAB_080c3ee0;
}



uri * add_to_uri_list(uri_list *list,uri *uri)

{
  int iVar1;
  uri **ppuVar2;
  uint uVar3;
  size_t size;
  uint uVar4;
  
  uVar3 = list->size + 4U & 0xfffffffc;
  uVar4 = list->size + 3U & 0xfffffffc;
  if (uVar4 < uVar3) {
    size = uVar3 * 4;
    ppuVar2 = (uri **)mem_realloc(list->uris,size);
    if (ppuVar2 == (uri **)0x0) {
      return (uri *)0x0;
    }
    list->uris = ppuVar2;
    memset(ppuVar2 + uVar4,0,size + uVar4 * -4);
  }
  ppuVar2 = list->uris;
  if (ppuVar2 == (uri **)0x0) {
    return (uri *)0x0;
  }
  iVar1 = list->size;
  (uri->object).refcount = (uri->object).refcount + 1;
  ppuVar2[iVar1] = uri;
  list->size = iVar1 + 1;
  return uri;
}



// WARNING: Could not reconcile some variable overlaps

void encode_win32_uri_string(string *string,uchar *name,int namelen)

{
  byte *pbVar1;
  int iVar2;
  uint uVar3;
  byte character;
  ushort *puVar4;
  uchar *puVar5;
  uint uVar6;
  byte bVar7;
  uchar uVar8;
  uint size;
  uchar n [4];
  
  n._0_2_ = 0x25;
  if (namelen < 0) {
    namelen = strlen((char *)name);
  }
  pbVar1 = name + namelen;
  if (name < pbVar1) {
    do {
      while (((((character = *name, 0x19 < (byte)(character + 0x9f) &&
                (0x19 < (byte)(character + 0xbf))) && (9 < (byte)(character - 0x30))) &&
              ((((character != 0x5f && (character != 0x2e)) &&
                ((character != 0x2d && ((character != 0x7e && (character != 0x21)))))) &&
               (character != 0x27)))) &&
             ((((character != 0x2a && (character != 0x29)) && (character != 0x28)) &&
              ((character != 0x3a && (character != 0x5c))))))) {
        character = character >> 4;
        bVar7 = character + 0x57;
        if (character < 10) {
          bVar7 = character + 0x30;
        }
        n._0_2_ = n._0_2_ & 0xff | (ushort)bVar7 << 8;
        character = *name & 0xf;
        uVar8 = character + 0x57;
        if (character < 10) {
          uVar8 = character + 0x30;
        }
        if (assert_failed != 0) {
LAB_080c423a:
          assert_failed = 0;
          goto joined_r0x080c424a;
        }
        if (string == (string *)0x0) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_080c423a;
        }
        else {
          assert_failed = 0;
        }
        iVar2 = string->length;
        size = iVar2 + 0x103U & 0xffffff00;
        uVar3 = iVar2 + 0xffU >> 8;
        uVar6 = iVar2 + 0xffU & 0xffffff00;
        if (uVar6 <= size && size + uVar3 * -0x100 != 0) {
          puVar5 = (uchar *)mem_realloc(string->source,size);
          if (puVar5 == (uchar *)0x0) goto joined_r0x080c424a;
          string->source = puVar5;
          memset(puVar5 + uVar6,0,size + uVar3 * -0x100);
        }
        if (string->source == (uchar *)0x0) goto joined_r0x080c424a;
        name = name + 1;
        puVar4 = (ushort *)(string->source + string->length);
        *puVar4 = n._0_2_;
        *(uchar *)(puVar4 + 1) = uVar8;
        string->source[iVar2 + 3] = '\0';
        string->length = iVar2 + 3;
        if (pbVar1 <= name) {
          return;
        }
      }
      add_char_to_string(string,character);
joined_r0x080c424a:
      name = name + 1;
    } while (name < pbVar1);
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void encode_uri_string(string *string,uchar *name,int namelen,int convert_slashes)

{
  byte *pbVar1;
  int iVar2;
  uint uVar3;
  byte bVar4;
  ushort *puVar5;
  uchar *puVar6;
  uint uVar7;
  byte character;
  uchar uVar8;
  uint size;
  uchar n [4];
  
  n._0_2_ = 0x25;
  if (namelen < 0) {
    namelen = strlen((char *)name);
  }
  pbVar1 = name + namelen;
  if (name < pbVar1) {
    do {
      character = *name;
      if ((((((byte)(character + 0x9f) < 0x1a) || ((byte)(character + 0xbf) < 0x1a)) ||
           ((byte)(character - 0x30) < 10)) ||
          ((((character == 0x5f || (character == 0x2e)) ||
            ((character == 0x2d || ((character == 0x7e || (character == 0x21)))))) ||
           (character == 0x27)))) ||
         ((((character == 0x2a || (character == 0x29)) || (character == 0x28)) ||
          ((convert_slashes == 0 && (character == 0x2f)))))) {
        add_char_to_string(string,character);
      }
      else {
        character = character >> 4;
        bVar4 = character + 0x57;
        if (character < 10) {
          bVar4 = character + 0x30;
        }
        n._0_2_ = n._0_2_ & 0xff | (ushort)bVar4 << 8;
        character = *name & 0xf;
        uVar8 = character + 0x57;
        if (character < 10) {
          uVar8 = character + 0x30;
        }
        if (assert_failed == 0) {
          if (string == (string *)0x0) {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
            errline = 0xff;
            elinks_internal((uchar *)
                            "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                           );
            if (assert_failed != 0) goto LAB_080c4453;
          }
          else {
            assert_failed = 0;
          }
          iVar2 = string->length;
          size = iVar2 + 0x103U & 0xffffff00;
          uVar3 = iVar2 + 0xffU >> 8;
          uVar7 = iVar2 + 0xffU & 0xffffff00;
          if (uVar7 <= size && size + uVar3 * -0x100 != 0) {
            puVar6 = (uchar *)mem_realloc(string->source,size);
            if (puVar6 == (uchar *)0x0) goto LAB_080c4460;
            string->source = puVar6;
            memset(puVar6 + uVar7,0,size + uVar3 * -0x100);
          }
          if (string->source != (uchar *)0x0) {
            puVar5 = (ushort *)(string->source + string->length);
            *puVar5 = n._0_2_;
            *(uchar *)(puVar5 + 1) = uVar8;
            string->source[iVar2 + 3] = '\0';
            string->length = iVar2 + 3;
          }
        }
        else {
LAB_080c4453:
          assert_failed = 0;
        }
      }
LAB_080c4460:
      name = name + 1;
    } while (name < pbVar1);
  }
  return;
}



uchar * __regparm3 translate_url(uchar *url,uchar *cwd)

{
  uchar uVar1;
  uri_errno uVar2;
  size_t sVar3;
  protocol pVar4;
  string *psVar5;
  int namelen;
  uint uVar6;
  uri_errno uVar7;
  uchar *name;
  uchar *__dest;
  int iVar8;
  uchar *__dest_00;
  byte bVar9;
  uri uri;
  string str;
  uchar *local_20 [4];
  
  bVar9 = 0;
  uVar1 = *url;
  while (uVar1 == ' ') {
    url = url + 1;
    uVar1 = *url;
  }
  if ((uVar1 == '\0') || (local_20[0] = expand_tilde(url), local_20[0] == (uchar *)0x0)) {
    return (uchar *)0x0;
  }
  uVar7 = URI_ERRNO_EMPTY;
  iVar8 = 0;
  do {
    uVar2 = parse_uri(&uri,local_20[0]);
    namelen = assert_failed;
    if (uVar7 == uVar2) {
      if (0x20 < iVar8) {
LAB_080c4a6e:
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
        errline = 0x449;
        elinks_error((uchar *)"Maximum number of parsing attempts exceeded for %s.",url);
      }
switchD_080c4618_caseD_1:
      mem_free(local_20[0]);
      return (uchar *)0x0;
    }
    iVar8 = iVar8 + 1;
    if (iVar8 == 0x22) goto LAB_080c4a6e;
    switch(uVar2) {
    case URI_ERRNO_OK:
      if ((uri.protocol != 0x12) ||
         (pVar4 = find_uri_protocol(local_20[0]), pVar4 == PROTOCOL_UNKNOWN)) {
        name = uri.data;
        if (uri.protocol == 4) {
          if ((cwd == (uchar *)0x0) || (*cwd == '\0')) goto LAB_080c4bef;
          if (assert_failed == 0) {
            if (uri.data == (uchar *)0x0) {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
              errline = 0x32e;
              elinks_internal((uchar *)
                              "assertion uri->protocol == PROTOCOL_FILE && uri->data failed!");
            }
            else {
              assert_failed = 0;
            }
          }
          uVar1 = *name;
          if ((uVar1 != '\0') && (uVar1 != '.')) goto LAB_080c4cb2;
          psVar5 = init_string(&str);
          if (psVar5 != (string *)0x0) {
            encode_uri_string(&str,cwd,-1,0);
            if (*name == '.') {
              *name = '/';
            }
            insert_in_string((uchar **)&uri,7,str.source,str.length);
            done_string(&str);
            goto LAB_080c4cd4;
          }
        }
        if (uri.protocol != 0xf) {
LAB_080c4bef:
          name = normalize_uri(&uri,uri.string);
          return name;
        }
        name = translate_url(uri.data,cwd);
        if (name == (uchar *)0x0) goto switchD_080c4618_caseD_1;
        *uri.data = '\0';
        uVar6 = 0xffffffff;
        __dest_00 = name;
        goto code_r0x080c4c38;
      }
      psVar5 = init_string(&str);
      if (psVar5 == (string *)0x0) {
        return (uchar *)0x0;
      }
      if (pVar4 == PROTOCOL_HTTP) {
        add_to_string(&str,(uchar *)"http://");
        add_to_string(&str,local_20[0]);
      }
      else {
        if (pVar4 != PROTOCOL_UNKNOWN) {
          if (pVar4 == PROTOCOL_FTP) {
            add_to_string(&str,(uchar *)"ftp://");
            encode_uri_string(&str,local_20[0],-1,0);
          }
          else {
            add_to_string(&str,(uchar *)"file://");
            if (*local_20[0] != '/') {
              add_to_string(&str,"./");
            }
            add_to_string(&str,local_20[0]);
          }
        }
      }
      uVar7 = URI_ERRNO_EMPTY;
      mem_free(local_20[0]);
      local_20[0] = str.source;
      break;
    default:
      goto switchD_080c4618_caseD_1;
    case URI_ERRNO_INVALID_PROTOCOL:
      pVar4 = find_uri_protocol(local_20[0]);
      psVar5 = init_string(&str);
      if (psVar5 == (string *)0x0) {
        return (uchar *)0x0;
      }
      if (pVar4 == PROTOCOL_FTP) {
        add_to_string(&str,(uchar *)"ftp://");
        encode_uri_string(&str,local_20[0],-1,0);
      }
      else {
        if (pVar4 == PROTOCOL_HTTP) {
          add_to_string(&str,(uchar *)"http://");
          add_to_string(&str,local_20[0]);
        }
        else {
          add_to_string(&str,(uchar *)"file://");
          if (*local_20[0] != '/') {
            add_to_string(&str,"./");
          }
          name = local_20[0];
          namelen = check_whether_file_exists(local_20[0]);
          encode_uri_string(&str,name,namelen,0);
          if (0 < namelen) {
            add_to_string(&str,name + namelen);
          }
        }
      }
      uVar7 = URI_ERRNO_INVALID_PROTOCOL;
      mem_free(local_20[0]);
      local_20[0] = str.source;
      break;
    case URI_ERRNO_NO_SLASHES:
      uVar7 = URI_ERRNO_NO_SLASHES;
      insert_in_string(local_20,(uint)uri._40_2_ + 1,"//",
                       (uint)(uri.string[(uint)uri._40_2_ + 1] != '/') + 1);
      break;
    case URI_ERRNO_TOO_MANY_SLASHES:
      if (assert_failed == 0) {
        uVar6 = (uint)uri._40_2_;
        if (((uri.string[uVar6] == ':') && (uri.string[uVar6 + 1] == '/')) &&
           (uri.string[uVar6 + 2] == '/')) {
          assert_failed = 0;
        }
        else {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
          errline = 0x499;
          elinks_internal((uchar *)
                          "assertion uri.string[uri.protocollen] == \':\' && uri.string[uri.protocollen + 1] == \'/\' && uri.string[uri.protocollen + 2] == \'/\' failed!"
                         );
          uVar6 = (uint)uri._40_2_;
          namelen = assert_failed;
        }
      }
      else {
        uVar6 = (uint)uri._40_2_;
      }
      name = uri.string + uVar6 + 3;
      uVar1 = *name;
      __dest_00 = name;
      while (uVar1 == '/') {
        __dest_00 = __dest_00 + 1;
        uVar1 = *__dest_00;
      }
      if ((namelen == 0) && (assert_failed = ZEXT14(__dest_00 <= name), __dest_00 <= name)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
        errline = 0x49e;
        elinks_internal((uchar *)"assertion to < from failed!");
      }
      sVar3 = strlen((char *)__dest_00);
      uVar7 = URI_ERRNO_TOO_MANY_SLASHES;
      memmove(name,__dest_00,sVar3 + 1);
      break;
    case URI_ERRNO_TRAILING_DOTS:
      name = uri.host + uri._46_2_;
      __dest_00 = name;
      if (assert_failed == 0) {
        if (((uri.host < name) && (name[-1] == '.')) && (*name != '.')) {
          assert_failed = 0;
        }
        else {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
          errline = 0x4b4;
          elinks_internal((uchar *)
                          "assertion uri.host < to && to[-1] == \'.\' && *from != \'.\' failed!");
          namelen = assert_failed;
        }
      }
      do {
        __dest = __dest_00;
        if (__dest <= uri.host) break;
        __dest_00 = __dest + -1;
      } while (__dest[-1] == '.');
      if ((namelen == 0) && (assert_failed = ZEXT14(name <= __dest), name <= __dest)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
        errline = 0x4b8;
        elinks_internal((uchar *)"assertion to < from failed!");
      }
      sVar3 = strlen((char *)name);
      uVar7 = URI_ERRNO_TRAILING_DOTS;
      memmove(__dest,name,sVar3 + 1);
      break;
    case URI_ERRNO_NO_PORT_COLON:
      if (assert_failed == 0) {
        if (((uri._48_1_ == 0) && (uri.string < uri.port)) && (uri.port[-1] == ':')) {
          assert_failed = 0;
        }
        else {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
          errline = 0x4bf;
          elinks_internal((uchar *)
                          "assertion uri.portlen == 0 && uri.string < uri.port && uri.port[-1] == \':\' failed!"
                         );
        }
      }
      name = uri.port;
      __dest_00 = uri.port + -1;
      sVar3 = strlen((char *)uri.port);
      uVar7 = URI_ERRNO_NO_PORT_COLON;
      memmove(__dest_00,name,sVar3 + 1);
      break;
    case URI_ERRNO_NO_HOST_SLASH:
      if (uri.port == (uchar *)0x0) {
        name = uri.host + (((uint)uri._54_1_ & 1) - (int)uri.string) + (uint)uri._46_2_;
      }
      else {
        name = uri.port + ((uint)uri._48_1_ - (int)uri.string);
      }
      if ((assert_failed == 0) &&
         (assert_failed = ZEXT14(uri.host == (uchar *)0x0), uri.host == (uchar *)0x0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
        errline = 0x4ca;
        elinks_internal((uchar *)
                        "assertion uri.host != NULL failed: uri.host not set after no host slash error"
                       );
      }
      uVar7 = URI_ERRNO_NO_HOST_SLASH;
      insert_in_string(local_20,(int)name,"/",1);
    }
  } while( true );
  while( true ) {
    name = name + 1;
    uVar1 = *name;
    if (uVar1 == '\0') break;
LAB_080c4cb2:
    if (uVar1 == '/') break;
  }
  uVar6 = 0xffffffff;
  __dest_00 = name;
  do {
    if (uVar6 == 0) break;
    uVar6 = uVar6 - 1;
    uVar1 = *__dest_00;
    __dest_00 = __dest_00 + (uint)bVar9 * -2 + 1;
  } while (uVar1 != '\0');
  memmove(uri.data,name,~uVar6);
LAB_080c4cd4:
  name = normalize_uri((uri *)0x0,uri.string);
  return name;
  while( true ) {
    uVar6 = uVar6 - 1;
    uVar1 = *__dest_00;
    __dest_00 = __dest_00 + (uint)bVar9 * -2 + 1;
    if (uVar1 == '\0') break;
code_r0x080c4c38:
    if (uVar6 == 0) break;
  }
  insert_in_string((uchar **)&uri,(int)(uri.data + -(int)uri.string),name,~uVar6 - 1);
  mem_free(name);
  name = normalize_uri((uri *)0x0,uri.string);
  return name;
}



uchar * join_urls(uri *base,uchar *rel)

{
  byte bVar1;
  uchar uVar2;
  ushort **ppuVar3;
  byte *pbVar4;
  byte *pbVar5;
  size_t sVar6;
  protocol pVar7;
  int iVar8;
  uchar *len;
  uchar *__n;
  uint uVar9;
  bool bVar10;
  uchar *local_20 [4];
  
  bVar1 = *rel;
  if (bVar1 == 0x23) {
    len = base->fragment;
    if ((len == (uchar *)0x0) && (len = base->post, len == (uchar *)0x0)) {
      uVar9 = 0xffffffff;
      len = base->string;
      do {
        if (uVar9 == 0) break;
        uVar9 = uVar9 - 1;
        uVar2 = *len;
        len = len + 1;
      } while (uVar2 != '\0');
      len = (uchar *)(~uVar9 - 1);
    }
    else {
      len = len + (-1 - (int)base->string);
    }
joined_r0x080c5007:
    if (len == (uchar *)0x0) {
LAB_080c4daf:
      ppuVar3 = __ctype_b_loc();
      pbVar4 = rel;
      while (((((*(byte *)(*ppuVar3 + bVar1) & 8) != 0 || (bVar1 == 0x2b)) || (bVar1 == 0x2d)) ||
             (bVar1 == 0x2e))) {
        pbVar4 = pbVar4 + 1;
        bVar1 = *pbVar4;
      }
      if (((((rel != pbVar4) && (pbVar5 = pbVar4 + -1, (byte)(pbVar4[-1] - 0x30) < 10)) ||
           (pbVar5 = pbVar4, (byte)(bVar1 - 0x30) < 0xb)) &&
          ((pbVar5 + -(int)rel != (byte *)0x0 &&
           (pVar7 = get_protocol(rel,(int)(pbVar5 + -(int)rel)), pVar7 != PROTOCOL_PROXY)))) &&
         ((pVar7 != PROTOCOL_UNKNOWN &&
          (local_20[0] = translate_url(rel,(uchar *)0x0), local_20[0] != (uchar *)0x0)))) {
        return local_20[0];
      }
      if (assert_failed != 0) {
        assert_failed = 0;
        return (uchar *)0x0;
      }
      bVar10 = base->data == (uchar *)0x0;
      assert_failed = ZEXT14(bVar10);
      if (bVar10) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
        errline = 0x3b4;
        elinks_internal((uchar *)"assertion base->data != NULL failed: bad base url");
        if (assert_failed != 0) {
          assert_failed = 0;
          return (uchar *)0x0;
        }
      }
      len = base->data;
      if (*len == '\0') {
        __n = len + -1;
        if (len[-1] != '/') goto LAB_080c4fee;
      }
      else {
        __n = len + -1;
        if (*len == '/') {
LAB_080c4fee:
          __n = len;
        }
      }
      uVar9 = 0;
      if (*rel != '/') {
        uVar2 = *__n;
        uVar9 = (uint)(uVar2 == '\0');
        if (((uVar2 != '\0') && (uVar2 != '\x01')) && (len = __n, uVar2 != '#')) {
          while (uVar2 != '?') {
            len = len + 1;
            bVar10 = uVar2 == '/';
            uVar2 = *len;
            if (bVar10) {
              __n = len;
            }
            if (((uVar2 == '\0') || (uVar2 == '#')) || (uVar2 == '\x01')) break;
          }
        }
      }
      sVar6 = strlen((char *)rel);
      __n = __n + -(int)base->string;
      local_20[0] = (uchar *)mem_alloc((size_t)(__n + uVar9 + 1 + sVar6));
      if (local_20[0] == (uchar *)0x0) {
        return (uchar *)0x0;
      }
      memcpy(local_20[0],base->string,(size_t)__n);
      if (uVar9 != 0) {
        local_20[0][(int)__n] = '/';
      }
      strcpy((char *)(local_20[0] + (int)(__n + uVar9)),(char *)rel);
      goto LAB_080c4f1c;
    }
    bVar10 = false;
  }
  else {
    if (bVar1 == 0x3f) {
      len = base->fragment;
      if ((len == (uchar *)0x0) && (len = base->post, len == (uchar *)0x0)) {
        uVar9 = 0xffffffff;
        len = base->string;
        do {
          if (uVar9 == 0) break;
          uVar9 = uVar9 - 1;
          uVar2 = *len;
          len = len + 1;
        } while (uVar2 != '\0');
        len = (uchar *)(~uVar9 - 1);
      }
      else {
        len = len + (-1 - (int)base->string);
      }
      local_20[0] = (uchar *)memchr(base->data,0x3f,(uint)*(ushort *)&base->field_0x31);
      if (local_20[0] != (uchar *)0x0) {
        len = local_20[0] + -(int)base->string;
      }
      goto joined_r0x080c5007;
    }
    if ((bVar1 != 0x2f) || (rel[1] != '/')) goto LAB_080c4daf;
    iVar8 = get_protocol_need_slashes(base->protocol);
    if (iVar8 == 0) {
      return (uchar *)0x0;
    }
    bVar10 = true;
    len = (uchar *)((uint)*(ushort *)&base->field_0x28 + 1);
  }
  local_20[0] = memacpy(base->string,(int)len);
  if (local_20[0] == (uchar *)0x0) {
    return (uchar *)0x0;
  }
  add_to_strn(local_20,rel);
  if (bVar10) {
    len = translate_url(local_20[0],(uchar *)0x0);
    mem_free(local_20[0]);
    return len;
  }
LAB_080c4f1c:
  len = normalize_uri((uri *)0x0,local_20[0]);
  return len;
}



string * add_uri_to_string(string *string,uri *uri,uri_component components)

{
  char cVar1;
  byte bVar2;
  uchar uVar3;
  ushort uVar4;
  int number;
  uchar *__src;
  void *pvVar5;
  string *psVar6;
  void *pvVar7;
  uchar *__n;
  size_t __n_00;
  uchar *puVar8;
  bool bVar9;
  byte bVar10;
  uri_component local_48;
  uchar *local_20 [4];
  
  bVar10 = 0;
  if (uri->protocol == 0x12) {
    psVar6 = add_to_string(string,uri->string);
    return psVar6;
  }
  if ((components & 1U) != 0) {
    __src = uri->string;
    uVar4 = *(ushort *)&uri->field_0x28;
    if (assert_failed == 0) {
      if ((string == (string *)0x0) || (__src == (uchar *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) goto LAB_080c5aa8;
      }
      else {
        assert_failed = 0;
      }
      if (uVar4 != 0) {
        number = (uint)uVar4 + string->length;
        pvVar5 = mem_align_alloc__((void **)string,string->length,number + 1,1,0xff);
        if (pvVar5 != (void *)0x0) {
          memcpy(string->source + string->length,__src,(uint)uVar4);
          string->source[number] = '\0';
          string->length = number;
        }
      }
    }
    else {
LAB_080c5aa8:
      assert_failed = 0;
    }
    if (((components & 2U) != 0) && (uri->ip_family != 0)) {
      add_long_to_string(string,uri->ip_family);
    }
    add_char_to_string(string,':');
    number = get_protocol_need_slashes(uri->protocol);
    if (number != 0) {
      add_to_string(string,"//");
    }
  }
  if (((components & 4U) == 0) || (uVar4 = *(ushort *)&uri->field_0x2a, uVar4 == 0)) {
    if (((components & 8U) != 0) && (uVar4 = *(ushort *)&uri->field_0x2c, uVar4 != 0)) {
      __src = uri->password;
      if (assert_failed == 0) {
        if ((string == (string *)0x0) || (__src == (uchar *)0x0)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_080c55a4;
        }
        else {
          assert_failed = 0;
        }
        number = (uint)uVar4 + string->length;
        pvVar5 = mem_align_alloc__((void **)string,string->length,number + 1,1,0xff);
        if (pvVar5 != (void *)0x0) {
          memcpy(string->source + string->length,__src,(uint)uVar4);
          string->source[number] = '\0';
          string->length = number;
        }
      }
      else {
LAB_080c55a4:
        assert_failed = 0;
      }
    }
  }
  else {
    __src = uri->user;
    if (assert_failed == 0) {
      if ((string == (string *)0x0) || (__src == (uchar *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) goto LAB_080c554c;
      }
      else {
        assert_failed = 0;
      }
      number = (uint)uVar4 + string->length;
      pvVar5 = mem_align_alloc__((void **)string,string->length,number + 1,1,0xff);
      if (pvVar5 != (void *)0x0) {
        memcpy(string->source + string->length,__src,(uint)uVar4);
        string->source[number] = '\0';
        string->length = number;
      }
    }
    else {
LAB_080c554c:
      assert_failed = 0;
    }
    if (((components & 8U) != 0) && (*(short *)&uri->field_0x2c != 0)) {
      add_char_to_string(string,':');
      add_bytes_to_string__(string,uri->password,(uint)*(ushort *)&uri->field_0x2c);
    }
    add_char_to_string(string,'@');
  }
  if (((components & 0x10U) != 0) && (uVar4 = *(ushort *)&uri->field_0x2e, uVar4 != 0)) {
    if (((*(byte *)&uri->field_0x36 & 1) != 0) && ((components & 0x20U) != 0)) {
      add_char_to_string(string,'[');
      uVar4 = *(ushort *)&uri->field_0x2e;
    }
    if ((components & 0x800U) == 0) {
LAB_080c51ae:
      add_bytes_to_string__(string,uri->host,(uint)uVar4);
    }
    else {
      __src = memacpy(uri->host,(uint)uVar4);
      if (__src == (uchar *)0x0) {
LAB_080c563f:
        uVar4 = *(ushort *)&uri->field_0x2e;
        goto LAB_080c51ae;
      }
      number = idna_to_ascii_lz(__src,local_20,0);
      if (number != 0) {
        mem_free(__src);
        goto LAB_080c563f;
      }
      add_to_string(string,local_20[0]);
      free(local_20[0]);
      mem_free(__src);
    }
    if (((*(byte *)&uri->field_0x36 & 1) != 0) && ((components & 0x20U) != 0)) {
      add_char_to_string(string,']');
    }
  }
  if ((components & 0x60U) != 0) {
    if (*(char *)&uri->field_0x30 == '\0') {
      if (((components & 0x40U) != 0) && (uri->protocol != PROTOCOL_USER)) {
        number = get_protocol_port(uri->protocol);
        add_char_to_string(string,':');
        add_long_to_string(string,number);
      }
    }
    else {
      add_char_to_string(string,':');
      __src = uri->port;
      bVar2 = *(byte *)&uri->field_0x30;
      if (assert_failed == 0) {
        if ((string == (string *)0x0) || (__src == (uchar *)0x0)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_080c5783;
        }
        else {
          assert_failed = 0;
        }
        if (bVar2 != 0) {
          number = (uint)bVar2 + string->length;
          pvVar5 = mem_align_alloc__((void **)string,string->length,number + 1,1,0xff);
          if (pvVar5 != (void *)0x0) {
            memcpy(string->source + string->length,__src,(uint)bVar2);
            string->source[number] = '\0';
            string->length = number;
          }
        }
      }
      else {
LAB_080c5783:
        assert_failed = 0;
      }
    }
  }
  if (((((components & 0x280U) != 0) || (components == URI_HTTP_REFERRER_HOST)) &&
      ((components & 0xffffff5fU) != 0)) &&
     (number = get_protocol_need_slash_after_host(uri->protocol), number != 0)) {
    add_char_to_string(string,'/');
  }
  if (((char)components < '\0') && ((*(uint *)&uri->field_0x30 & 0xffff00) != 0)) {
    __src = uri->data;
    uVar4 = *(ushort *)&uri->field_0x31;
    if (assert_failed == 0) {
      if ((string == (string *)0x0) || (__src == (uchar *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) goto LAB_080c57af;
      }
      else {
        assert_failed = 0;
      }
      if (uVar4 != 0) {
        number = (uint)uVar4 + string->length;
        pvVar5 = mem_align_alloc__((void **)string,string->length,number + 1,1,0xff);
        if (pvVar5 != (void *)0x0) {
          memcpy(string->source + string->length,__src,(uint)uVar4);
          string->source[number] = '\0';
          string->length = number;
        }
      }
    }
    else {
LAB_080c57af:
      assert_failed = 0;
    }
  }
  if ((components & 0x3000U) != 0) {
    __src = uri->data;
    if ((assert_failed == 0) &&
       (assert_failed = (uint)components >> 0xd & (uint)(components != URI_FILENAME),
       assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
      errline = 0x25a;
      elinks_internal((uchar *)
                      "assertion !wants(URI_FILENAME) || components == URI_FILENAME failed: URI_FILENAME should be used alone %d"
                      ,components);
    }
    if (((components & 0x1000U) != 0) && (*__src != '/')) {
      add_char_to_string(string,'/');
    }
    if ((*(uint *)&uri->field_0x30 & 0xffff00) == 0) {
      return string;
    }
    uVar3 = *__src;
    if ((((uVar3 == '\0') || (uVar3 == '#')) || (uVar3 == '\x01')) || (uVar3 == '?')) {
      __n = (uchar *)0x0;
    }
    else {
      __n = __src;
      do {
        __n = __n + 1;
        if (((components & 0x2000U) != 0) && (uVar3 == '/')) {
          __src = __n;
        }
        uVar3 = *__n;
        if (((uVar3 == '\0') || (uVar3 == '#')) || (uVar3 == '\x01')) {
          __n = __n + -(int)__src;
          goto LAB_080c52d0;
        }
      } while (uVar3 != '?');
      __n = __n + -(int)__src;
    }
LAB_080c52d0:
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
    if (((__src == (uchar *)0x0) || (string == (string *)0x0)) || ((int)__n < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) {
        assert_failed = 0;
        return (string *)0x0;
      }
    }
    else {
      assert_failed = 0;
    }
    if (__n != (uchar *)0x0) {
      puVar8 = __n + string->length;
      pvVar5 = mem_align_alloc__((void **)string,string->length,(size_t)(puVar8 + 1),1,0xff);
      if (pvVar5 == (void *)0x0) {
        return (string *)0x0;
      }
      memcpy(string->source + string->length,__src,(size_t)__n);
      string->source[(int)puVar8] = '\0';
      *(uchar **)&string->length = puVar8;
      return string;
    }
    return string;
  }
  if (((components & 0x4000U) == 0) || ((*(uint *)&uri->field_0x30 & 0xffff00) == 0)) {
    if (((components & 0x100U) != 0) && (*(short *)&uri->field_0x34 != 0)) {
      add_char_to_string(string,'#');
      add_bytes_to_string__(string,uri->fragment,(uint)*(ushort *)&uri->field_0x34);
    }
    if (((components & 0x200U) != 0) && (uri->post != (uchar *)0x0)) {
      add_char_to_string(string,'\x01');
      add_to_string(string,uri->post);
      return string;
    }
    if ((components & 0x400U) == 0) {
      return string;
    }
    __src = uri->post;
    bVar9 = __src == (uchar *)0x0;
    if (bVar9) {
      return string;
    }
    number = 10;
    __n = __src;
    puVar8 = (uchar *)"text/plain";
    do {
      if (number == 0) break;
      number = number + -1;
      bVar9 = *__n == *puVar8;
      __n = __n + (uint)bVar10 * -2 + 1;
      puVar8 = puVar8 + (uint)bVar10 * -2 + 1;
    } while (bVar9);
    if (bVar9) {
      add_to_string(string,(uchar *)" (PLAIN TEXT DATA)");
      return string;
    }
    number = 0x14;
    __n = (uchar *)"multipart/form-data;";
    do {
      if (number == 0) break;
      number = number + -1;
      bVar9 = *__src == *__n;
      __src = __src + (uint)bVar10 * -2 + 1;
      __n = __n + (uint)bVar10 * -2 + 1;
    } while (bVar9);
    if (bVar9) {
      add_to_string(string,(uchar *)" (MULTIPART FORM DATA)");
      return string;
    }
    add_to_string(string,(uchar *)" (POST DATA)");
    return string;
  }
  local_48 = 0x3f;
  pvVar5 = memchr(uri->data,0x3f,(uint)*(ushort *)&uri->field_0x31);
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(components != URI_QUERY), components != URI_QUERY)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
    errline = 0x271;
    elinks_internal((uchar *)
                    "assertion URI_QUERY == components failed: URI_QUERY should be used alone %d",
                    components);
    local_48 = components;
  }
  if (pvVar5 == (void *)0x0) {
    return string;
  }
  cVar1 = *(char *)((int)pvVar5 + 1);
  if (((cVar1 == '\0') || (cVar1 == '#')) || (cVar1 == '\x01')) {
    __n_00 = 0;
  }
  else {
    __n_00 = 0;
    do {
      __n_00 = __n_00 + 1;
      cVar1 = *(char *)((int)pvVar5 + __n_00 + 2);
      if ((cVar1 == '\0') || (cVar1 == '#')) break;
      __n_00 = __n_00;
    } while (cVar1 != '\x01');
  }
  if (assert_failed == 0) {
    if ((string == (string *)0x0) || ((int)__n_00 < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]",
                      local_48);
      if (assert_failed != 0) goto LAB_080c53b3;
    }
    else {
      assert_failed = 0;
    }
    if (__n_00 == 0) {
      return string;
    }
    number = __n_00 + string->length;
    pvVar7 = mem_align_alloc__((void **)string,string->length,number + 1,1,0xff);
    if (pvVar7 != (void *)0x0) {
      memcpy(string->source + string->length,(void *)((int)pvVar5 + 1),__n_00);
      string->source[number] = '\0';
      string->length = number;
      return string;
    }
  }
  else {
LAB_080c53b3:
    assert_failed = 0;
  }
  return (string *)0x0;
}



uchar * get_uri_string(uri *uri,uri_component components)

{
  string *psVar1;
  string string;
  
  psVar1 = init_string(&string);
  if ((psVar1 == (string *)0x0) ||
     (psVar1 = add_uri_to_string(&string,uri,components), psVar1 == (string *)0x0)) {
    done_string(&string);
    string.source = (uchar *)0x0;
  }
  return string.source;
}



uri * get_composed_uri(uri *uri,uri_component components)

{
  uchar *string;
  uri *puVar1;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(uri == (uri *)0x0);
    if (uri == (uri *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
      errline = 0x508;
      elinks_internal((uchar *)"assertion uri failed!");
      if (assert_failed != 0) goto LAB_080c5e7a;
    }
    string = get_uri_string(uri,components);
    if (string != (uchar *)0x0) {
      puVar1 = get_uri(string,0);
      mem_free(string);
      return puVar1;
    }
  }
  else {
LAB_080c5e7a:
    assert_failed = 0;
  }
  return (uri *)0x0;
}



uri * get_uri(uchar *string,uri_component components)

{
  size_t keylen;
  hash_item *phVar1;
  uri *uri_00;
  uri *__dest;
  uri_errno uVar2;
  uri uri;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(string == (uchar *)0x0), string == (uchar *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
    errline = 0x626;
    elinks_internal((uchar *)"assertion string failed!");
  }
  if (components != 0) {
    uVar2 = parse_uri(&uri,string);
    if (uVar2 != URI_ERRNO_OK) {
      return (uri *)0x0;
    }
    uri_00 = get_composed_uri(&uri,components);
    return uri_00;
  }
  if ((uri_cache.object == 0) && (uri_cache.map = init_hash8(), uri_cache.map == (hash *)0x0)) {
    return (uri *)0x0;
  }
  keylen = strlen((char *)string);
  if (assert_failed == 0) {
    assert_failed = ZEXT14((int)keylen < 1 || string == (uchar *)0x0);
    if ((int)keylen < 1 || string == (uchar *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
      errline = 0x607;
      elinks_internal((uchar *)"assertion string && length > 0 failed!");
      if (assert_failed != 0) goto LAB_080c5f69;
    }
    phVar1 = get_hash_item(uri_cache.map,string,keylen);
    if (phVar1 == (hash_item *)0x0) {
      uri_00 = (uri *)mem_calloc(1,keylen + 0x40);
      if (uri_00 != (uri *)0x0) {
        __dest = uri_00 + 1;
        memcpy(__dest,string,keylen);
        uVar2 = parse_uri(uri_00,(uchar *)__dest);
        if ((uVar2 == URI_ERRNO_OK) &&
           (phVar1 = add_hash_item(uri_cache.map,(uchar *)__dest,keylen,uri_00),
           phVar1 != (hash_item *)0x0)) {
          uri_cache.object = uri_cache.object + 1;
          goto LAB_080c5f29;
        }
        mem_free(uri_00);
      }
    }
    else {
      uri_00 = (uri *)phVar1->value;
      if (uri_00 != (uri *)0x0) {
LAB_080c5f29:
        (uri_00->object).refcount = (uri_00->object).refcount + 1;
        return uri_00;
      }
    }
  }
  else {
LAB_080c5f69:
    assert_failed = 0;
  }
  if (uri_cache.object != 0) {
    return (uri *)0x0;
  }
  free_hash((hash **)&uri_cache);
  return (uri *)0x0;
}



uri * get_translated_uri(uchar *uristring,uchar *cwd)

{
  uchar *string;
  uri *puVar1;
  
  puVar1 = (uri *)0x0;
  string = translate_url(uristring,cwd);
  if (string != (uchar *)0x0) {
    puVar1 = get_uri(string,0);
    mem_free(string);
  }
  return puVar1;
}



string * add_string_uri_to_string(string *string,uchar *uristring,uri_component components)

{
  uri_errno uVar1;
  string *psVar2;
  uri uri;
  
  uVar1 = parse_uri(&uri,uristring);
  psVar2 = (string *)0x0;
  if (uVar1 == URI_ERRNO_OK) {
    psVar2 = add_uri_to_string(string,&uri,components);
  }
  return psVar2;
}



uchar * get_user_program(terminal *term,uchar *progid,int progidlen)

{
  uint uVar1;
  string *psVar2;
  int iVar3;
  option_elinks *poVar4;
  int iVar5;
  uint size;
  uint xwin;
  uchar *source;
  string name;
  
  xwin = 0;
  if (term != (terminal *)0x0) {
    xwin = term->environment & 2;
  }
  psVar2 = init_string(&name);
  if (psVar2 == (string *)0x0) {
    return (uchar *)0x0;
  }
  add_to_string(&name,(uchar *)"protocol.user.");
  if (assert_failed == 0) {
    if ((progid == (uchar *)0x0) || (progidlen < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080c6168;
    }
    else {
      assert_failed = 0;
    }
    if (progidlen == 0) goto LAB_080c61dd;
    iVar5 = progidlen + name.length;
    uVar1 = name.length + 0xffU & 0xffffff00;
    size = iVar5 + 0x100U & 0xffffff00;
    if (uVar1 < size) {
      source = (uchar *)mem_realloc(name.source,size);
      if (source == (uchar *)0x0) goto LAB_080c6175;
      name.source = source;
      memset(source + uVar1,0,size - uVar1);
    }
    if (name.source != (uchar *)0x0) {
      memcpy(name.source + name.length,progid,progidlen);
      name.source[iVar5] = '\0';
      name.length = iVar5;
    }
  }
  else {
LAB_080c6168:
    assert_failed = 0;
  }
LAB_080c6175:
  iVar5 = progidlen + -1;
  if (-1 < iVar5) {
    source = name.source + progidlen;
    do {
      while (iVar3 = c_isupper((uint)source[0xd]), iVar3 == 0) {
        source = source + -1;
        iVar5 = iVar5 + -1;
        if (iVar5 < 0) goto LAB_080c61dd;
      }
      iVar3 = c_tolower((uint)source[0xd]);
      source[0xd] = (uchar)iVar3;
      source = source + -1;
      iVar5 = iVar5 + -1;
    } while (-1 < iVar5);
  }
LAB_080c61dd:
  add_char_to_string(&name,'.');
  source = get_system_str(xwin);
  add_to_string(&name,source);
  poVar4 = get_opt_rec_real(config_options,name.source);
  done_string(&name);
  if (poVar4 == (option_elinks *)0x0) {
    return (uchar *)0x0;
  }
  return (uchar *)poVar4->value;
}



void user_protocol_handler(session *ses,uri *uri)

{
  ushort uVar1;
  uint uVar2;
  char cVar3;
  int len;
  char *pcVar4;
  size_t __size;
  string *psVar5;
  uint uVar6;
  FILE *__s;
  int iVar7;
  uchar *text;
  size_t sVar8;
  uchar *text_00;
  uint size;
  undefined2 *__src;
  undefined2 *puVar9;
  uchar *puVar10;
  bool bVar11;
  byte bVar12;
  uchar *local_38;
  uchar *local_30;
  string string;
  
  bVar12 = 0;
  __src = (undefined2 *)
          get_user_program(ses->tab->term,uri->string,(uint)*(ushort *)&uri->field_0x28);
  if ((__src == (undefined2 *)0x0) || (*(char *)__src == '\0')) {
    text = memacpy(uri->string,(uint)*(ushort *)&uri->field_0x28);
    if (text == (uchar *)0x0) {
      text = msg_text(ses->tab->term,(uchar *)"No program specified for protocol %s.",&DAT_0812e3d8)
      ;
      info_box(ses->tab->term,MSGBOX_FREE_TEXT,(uchar *)"No program",ALIGN_CENTER,text);
      return;
    }
    text_00 = msg_text(ses->tab->term,(uchar *)"No program specified for protocol %s.",text);
    info_box(ses->tab->term,MSGBOX_FREE_TEXT,(uchar *)"No program",ALIGN_CENTER,text_00);
    mem_free(text);
    return;
  }
  if ((uri->data == (uchar *)0x0) || ((*(uint *)&uri->field_0x30 & 0xffff00) == 0)) {
LAB_080c6375:
    local_38 = (uchar *)0x0;
  }
  else {
    text = get_uri_string(uri,URI_QUERY);
    bVar11 = text == (uchar *)0x0;
    if (bVar11) goto LAB_080c6375;
    len = 8;
    text_00 = text;
    puVar10 = "subject=";
    do {
      if (len == 0) break;
      len = len + -1;
      bVar11 = *text_00 == *puVar10;
      text_00 = text_00 + (uint)bVar12 * -2 + 1;
      puVar10 = puVar10 + (uint)bVar12 * -2 + 1;
    } while (bVar11);
    if (bVar11) {
      text_00 = text + 8;
LAB_080c694b:
      if ((*text_00 == '\0') || (*text_00 == '&')) {
        len = 0;
      }
      else {
        len = 0;
        do {
          len = len + 1;
          if (text_00[len] == '\0') break;
        } while (text_00[len] != '&');
      }
      local_38 = memacpy(text_00,len);
      mem_free(text);
      if (local_38 != (uchar *)0x0) {
        decode_uri(local_38);
      }
    }
    else {
      pcVar4 = strstr((char *)text,"&subject=");
      text_00 = (uchar *)(pcVar4 + 9);
      if (pcVar4 != (char *)0x0) goto LAB_080c694b;
      mem_free(text);
      local_38 = (uchar *)0x0;
    }
  }
  local_30 = get_tempdir_filename((uchar *)"elinks-XXXXXX");
  if (local_30 != (uchar *)0x0) {
    len = safe_mkstemp(local_30);
    if (len < 0) {
      mem_free(local_30);
      local_30 = (uchar *)0x0;
    }
    else {
      text = uri->post;
      if (text != (uchar *)0x0) {
        pcVar4 = strchr((char *)text,10);
        if (pcVar4 != (char *)0x0) {
          text = (uchar *)(pcVar4 + 1);
        }
        __size = strlen((char *)text);
        if (__size != 0) {
          __s = fdopen(len,"w");
          if (__s != (FILE *)0x0) {
            __size = fwrite(text,__size,1,__s);
            if (__size == 1) {
              iVar7 = fclose(__s);
              if (iVar7 == 0) goto LAB_080c63d6;
            }
            else {
              fclose(__s);
            }
          }
          unlink((char *)local_30);
          mem_free(local_30);
          close(len);
          local_30 = (uchar *)0x0;
        }
      }
    }
  }
LAB_080c63d6:
  psVar5 = init_string(&string);
  text = (uchar *)0x0;
  if (psVar5 != (string *)0x0) {
    while (text = string.source, *(char *)__src != '\0') {
      sVar8 = 0;
      __size = 0;
      puVar9 = __src;
      if (*(char *)__src != '%') {
        do {
          sVar8 = sVar8 + 1;
          puVar9 = (undefined2 *)(sVar8 + (int)__src);
          __size = sVar8;
          if (*(char *)((int)__src + sVar8) == '%') break;
        } while (*(char *)((int)__src + sVar8) != '\0');
      }
      if (assert_failed == 0) {
        if ((int)__size < 0) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_080c642a;
        }
        else {
          assert_failed = 0;
        }
        if (__size != 0) {
          len = __size + string.length;
          uVar2 = string.length + 0xffU >> 8;
          uVar6 = string.length + 0xffU & 0xffffff00;
          size = len + 0x100U & 0xffffff00;
          if (uVar6 <= size && size + uVar2 * -0x100 != 0) {
            text = (uchar *)mem_realloc(string.source,size);
            if (text == (uchar *)0x0) goto LAB_080c6438;
            string.source = text;
            memset(text + uVar6,0,size + uVar2 * -0x100);
          }
          if (string.source != (uchar *)0x0) {
            memcpy(string.source + string.length,__src,__size);
            string.source[len] = '\0';
            string.length = len;
          }
        }
      }
      else {
LAB_080c642a:
        assert_failed = 0;
      }
LAB_080c6438:
      len = string.length;
      text = string.source;
      if (*(char *)puVar9 != '%') break;
      pcVar4 = (char *)((int)puVar9 + 1);
      switch(*(char *)((int)puVar9 + 1)) {
      case 'd':
        if ((*(uint *)&uri->field_0x30 & 0xffff00) != 0) {
          uVar1 = *(ushort *)&uri->field_0x31;
          text = uri->data;
LAB_080c6639:
          add_shell_safe_to_string(&string,text,(uint)uVar1);
          cVar3 = *pcVar4;
          break;
        }
        goto LAB_080c6606;
      default:
        if (assert_failed == 0) {
          assert_failed = 0;
          size = string.length + 0x102U & 0xffffff00;
          uVar2 = string.length + 0xffU >> 8;
          uVar6 = string.length + 0xffU & 0xffffff00;
          iVar7 = string.length + 2;
          if (size < uVar6 || size + uVar2 * -0x100 == 0) {
LAB_080c6487:
            if (string.source != (uchar *)0x0) {
              *(undefined2 *)(string.source + string.length) = *puVar9;
              string.source[len + 2] = '\0';
              string.length = iVar7;
            }
          }
          else {
            text = (uchar *)mem_realloc(string.source,size);
            if (text != (uchar *)0x0) {
              string.source = text;
              memset(text + uVar6,0,size + uVar2 * -0x100);
              goto LAB_080c6487;
            }
          }
          cVar3 = *pcVar4;
        }
        else {
          assert_failed = 0;
          cVar3 = *pcVar4;
        }
        break;
      case 'f':
        if (local_30 == (uchar *)0x0) goto LAB_080c6606;
        add_to_string(&string,local_30);
        cVar3 = *pcVar4;
        break;
      case 'h':
        if ((*(short *)&uri->field_0x2a == 0) || (*(ushort *)&uri->field_0x2e == 0)) {
          text = uri->host;
          if (text != (uchar *)0x0) {
            uVar1 = *(ushort *)&uri->field_0x2e;
            goto LAB_080c6639;
          }
          goto LAB_080c6606;
        }
        add_shell_safe_to_string
                  (&string,uri->user,
                   (int)(uri->host + ((uint)*(ushort *)&uri->field_0x2e - (int)uri->user)));
        cVar3 = *pcVar4;
        break;
      case 'p':
        if (*(byte *)&uri->field_0x30 == 0) goto LAB_080c6606;
        add_shell_safe_to_string(&string,uri->port,(uint)*(byte *)&uri->field_0x30);
        cVar3 = *pcVar4;
        break;
      case 's':
        if (local_38 == (uchar *)0x0) goto LAB_080c6606;
        __size = strlen((char *)local_38);
        add_shell_safe_to_string(&string,local_38,__size);
        cVar3 = *pcVar4;
        break;
      case 'u':
        text = uri->string;
        if (uri->post == (uchar *)0x0) {
          text_00 = (uchar *)strlen((char *)text);
        }
        else {
          text_00 = uri->post + (-1 - (int)text);
        }
        add_shell_safe_to_string(&string,text,(int)text_00);
        cVar3 = *pcVar4;
      }
      text = string.source;
      if (cVar3 == '\0') break;
LAB_080c6606:
      __src = puVar9 + 1;
    }
  }
  if (local_38 != (uchar *)0x0) {
    mem_free(local_38);
  }
  if (text == (uchar *)0x0) {
    if (local_30 == (uchar *)0x0) {
      return;
    }
    unlink((char *)local_30);
  }
  else {
    if (local_30 == (uchar *)0x0) {
      exec_on_terminal(ses->tab->term,text,"",TERM_EXEC_FG);
      mem_free(text);
      return;
    }
    exec_on_terminal(ses->tab->term,text,local_30,TERM_EXEC_FG);
    mem_free(text);
  }
  mem_free(local_30);
  return;
}



auth_entry * get_invalid_auth_entry(void)

{
  auth_entry *paVar1;
  
  paVar1 = (auth_entry *)auth_entry_list.next;
  if ((list_head_elinks *)auth_entry_list.next != &auth_entry_list) {
    do {
      if ((*(byte *)&paVar1->field_0x70 & 2) == 0) {
        return paVar1;
      }
      paVar1 = paVar1->next;
    } while (paVar1 != (auth_entry *)&auth_entry_list);
  }
  return (auth_entry *)0x0;
}



void __regparm3 done_auth_entry(auth_entry *entry)

{
  if (entry->box_item != (listbox_item *)0x0) {
    done_listbox_item(&auth_browser,entry->box_item);
  }
  done_uri(entry->uri);
  if (entry->realm != (uchar *)0x0) {
    mem_free(entry->realm);
  }
  if (entry->nonce != (uchar *)0x0) {
    mem_free(entry->nonce);
  }
  if (entry->opaque != (uchar *)0x0) {
    mem_free(entry->opaque);
  }
  mem_free(entry);
  return;
}



void del_auth_entry(auth_entry *entry)

{
  entry->next->prev = entry->prev;
  entry->prev->next = entry->next;
  done_auth_entry(entry);
  return;
}



void free_auth(void)

{
  list_head_elinks *p;
  list_head_elinks *plVar1;
  list_head_elinks *plVar2;
  list_head_elinks *plVar3;
  
  if ((list_head_elinks *)auth_entry_list.next != &auth_entry_list) {
    do {
      del_auth_entry((auth_entry *)auth_entry_list.next);
    } while ((list_head_elinks *)auth_entry_list.next != &auth_entry_list);
  }
  plVar3 = (list_head_elinks *)questions_queue.next;
  p = (list_head_elinks *)questions_queue.prev;
  if ((list_head_elinks *)questions_queue.next != &questions_queue) {
    do {
      plVar3 = (list_head_elinks *)plVar3->next;
    } while (plVar3 != &questions_queue);
  }
  while (p != plVar3) {
    p = (list_head_elinks *)p->prev;
  }
  plVar2 = *(list_head_elinks **)questions_queue.next;
  p = (list_head_elinks *)questions_queue.next;
  while (plVar1 = plVar2, p != plVar3) {
    plVar1->prev = p->prev;
    *(void **)p->prev = p->next;
    mem_free(p);
    plVar2 = (list_head_elinks *)plVar1->next;
    p = plVar1;
  }
  return;
}



void done_auth(module *xxx)

{
  free_auth();
  return;
}



auth_entry * __regparm3 find_auth_entry(uri *uri,uchar *realm)

{
  auth_entry **ppaVar1;
  int iVar2;
  auth_entry *paVar3;
  auth_entry *local_24;
  
  local_24 = (auth_entry *)0x0;
  paVar3 = (auth_entry *)auth_entry_list.next;
  if ((list_head_elinks *)auth_entry_list.next != &auth_entry_list) {
    do {
      iVar2 = compare_uri(paVar3->uri,uri,URI_HTTP_AUTH);
      if ((iVar2 != 0) &&
         ((realm == (uchar *)0x0 ||
          ((local_24 = paVar3, paVar3->realm != (uchar *)0x0 &&
           (iVar2 = strcmp((char *)paVar3->realm,(char *)realm), iVar2 == 0)))))) {
        return paVar3;
      }
      ppaVar1 = &paVar3->next;
      paVar3 = *ppaVar1;
    } while (*ppaVar1 != (auth_entry *)&auth_entry_list);
  }
  return local_24;
}



void __regparm3 set_auth_user(auth_entry *entry,uri *uri)

{
  ushort uVar1;
  uint __n;
  
  uVar1 = *(ushort *)&uri->field_0x2a;
  __n = (uint)uVar1;
  if (uVar1 < 0x27) {
    if (uVar1 == 0) goto LAB_080c6c97;
  }
  else {
    __n = 0x27;
  }
  memcpy(entry->user,uri->user,__n);
LAB_080c6c97:
  entry->user[__n] = '\0';
  return;
}



void __regparm3 set_auth_password(auth_entry *entry,uri *uri)

{
  ushort uVar1;
  uint __n;
  
  uVar1 = *(ushort *)&uri->field_0x2c;
  __n = (uint)uVar1;
  if (uVar1 < 0x27) {
    if (uVar1 == 0) goto LAB_080c6ce7;
  }
  else {
    __n = 0x27;
  }
  memcpy(entry->password,uri->password,__n);
LAB_080c6ce7:
  entry->password[__n] = '\0';
  return;
}



auth_entry * add_auth_entry(uri *uri,uchar *realm,uchar *nonce,uchar *opaque,uint digest)

{
  byte bVar1;
  auth_entry *entry;
  uchar *p;
  int iVar2;
  listbox_item *plVar3;
  bool bVar4;
  
  entry = find_auth_entry(uri,realm);
  if (entry == (auth_entry *)0x0) {
    entry = (auth_entry *)mem_calloc(1,0x74);
    if (entry == (auth_entry *)0x0) {
      return (auth_entry *)0x0;
    }
    (uri->object).refcount = (uri->object).refcount + 1;
    entry->uri = uri;
    if (realm != (uchar *)0x0) {
      p = stracpy(realm);
      entry->realm = p;
      if (p == (uchar *)0x0) {
        mem_free(entry);
        return (auth_entry *)0x0;
      }
    }
    set_auth_user(entry,uri);
    set_auth_password(entry,uri);
    plVar3 = add_listbox_item(&auth_browser,(listbox_item *)0x0,BI_LEAF,entry,1);
    entry->box_item = plVar3;
    if (plVar3 == (listbox_item *)0x0) {
      done_auth_entry(entry);
      return (auth_entry *)0x0;
    }
    *(list_head_elinks **)&entry->prev = &auth_entry_list;
    entry->next = auth_entry_list.next;
    auth_entry_list.next = entry;
    entry->next->prev = entry;
    if (nonce != (uchar *)0x0) {
      p = stracpy(nonce);
      entry->nonce = p;
      if (p == (uchar *)0x0) goto LAB_080c704a;
    }
    if (opaque != (uchar *)0x0) {
      p = stracpy(opaque);
      entry->opaque = p;
      if (p == (uchar *)0x0) {
LAB_080c704a:
        del_auth_entry(entry);
        return (auth_entry *)0x0;
      }
    }
    *(byte *)&entry->field_0x70 = *(byte *)&entry->field_0x70 & 0xfb | (byte)((digest & 1) << 2);
    goto LAB_080c6e3d;
  }
  bVar1 = *(byte *)&entry->field_0x70;
  if ((bVar1 & 1) != 0) {
    return (auth_entry *)0x0;
  }
  bVar4 = realm != (uchar *)0x0;
  p = entry->realm;
  if (bVar4 == (p != (uchar *)0x0)) {
    if (((bVar4) && (p != (uchar *)0x0)) && (iVar2 = strcmp((char *)realm,(char *)p), iVar2 != 0)) {
      bVar1 = *(byte *)&entry->field_0x70;
      p = entry->realm;
      goto LAB_080c6d4a;
    }
  }
  else {
LAB_080c6d4a:
    *(byte *)&entry->field_0x70 = bVar1 & 0xfd;
    if (p != (uchar *)0x0) {
      mem_free(p);
    }
    entry->realm = (uchar *)0x0;
    if (bVar4) {
      p = stracpy(realm);
      entry->realm = p;
      if (p == (uchar *)0x0) {
LAB_080c7073:
        del_auth_entry(entry);
        return (auth_entry *)0x0;
      }
      if (nonce != (uchar *)0x0) {
        if (entry->nonce != (uchar *)0x0) {
          mem_free(entry->nonce);
        }
        p = stracpy(nonce);
        entry->nonce = p;
        if (p == (uchar *)0x0) goto LAB_080c7073;
      }
      if (opaque != (uchar *)0x0) {
        if (entry->opaque != (uchar *)0x0) {
          mem_free(entry->opaque);
        }
        p = stracpy(opaque);
        entry->opaque = p;
        if (p == (uchar *)0x0) {
          del_auth_entry(entry);
          return (auth_entry *)0x0;
        }
      }
      *(byte *)&entry->field_0x70 = *(byte *)&entry->field_0x70 & 0xfb | (byte)((digest & 1) << 2);
    }
  }
  if (((entry->user[0] == '\0') || (uri->user == (uchar *)0x0)) || (*(short *)&uri->field_0x2a == 0)
     ) {
LAB_080c6e09:
    *(byte *)&entry->field_0x70 = *(byte *)&entry->field_0x70 & 0xfd;
    set_auth_user(entry,uri);
  }
  else {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/auth.c";
    errline = 0xb9;
    iVar2 = elinks_strlcmp(entry->user,0xffffffff,uri->user,(uint)*(ushort *)&uri->field_0x2a);
    if (iVar2 != 0) goto LAB_080c6e09;
  }
  if (((entry->password[0] != '\0') && (uri->password != (uchar *)0x0)) &&
     (*(short *)&uri->field_0x2c != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/auth.c";
    errline = 0xc0;
    iVar2 = elinks_strlcmp(entry->password,0xffffffff,uri->password,
                           (uint)*(ushort *)&uri->field_0x2c);
    if (iVar2 == 0) goto LAB_080c6e3d;
  }
  *(byte *)&entry->field_0x70 = *(byte *)&entry->field_0x70 & 0xfd;
  set_auth_password(entry,uri);
LAB_080c6e3d:
  if (((*(byte *)&entry->field_0x70 & 2) == 0) && (entry->realm != (uchar *)0x0)) {
    add_questions_entry(do_auth_dialog,entry);
    return entry;
  }
  return entry;
}



auth_entry * find_auth(uri *uri)

{
  uchar *puVar1;
  auth_entry *entry;
  int iVar2;
  
  entry = find_auth_entry(uri,(uchar *)0x0);
  if ((*(short *)&uri->field_0x2a != 0) || (*(short *)&uri->field_0x2c != 0)) {
    if (entry != (auth_entry *)0x0) {
      if (*(short *)&uri->field_0x2a == 0) {
        puVar1 = uri->password;
      }
      else {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/auth.c";
        errline = 0xf9;
        iVar2 = elinks_strlcmp(entry->user,0xffffffff,uri->user,(uint)*(ushort *)&uri->field_0x2a);
        if (iVar2 != 0) goto LAB_080c7120;
        puVar1 = uri->password;
      }
      if (puVar1 == (uchar *)0x0) goto LAB_080c71a0;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/auth.c";
      errline = 0xfa;
      iVar2 = elinks_strlcmp(entry->password,0xffffffff,uri->password,
                             (uint)*(ushort *)&uri->field_0x2c);
      if (iVar2 == 0) goto LAB_080c71a0;
    }
LAB_080c7120:
    entry = add_auth_entry(uri,(uchar *)0x0,(uchar *)0x0,(uchar *)0x0,0);
  }
  if (entry == (auth_entry *)0x0) {
    return (auth_entry *)0x0;
  }
LAB_080c71a0:
  if ((*(byte *)&entry->field_0x70 & 1) == 0) {
    if ((entry->user[0] != '\0') || (entry->password[0] != '\0')) {
      return entry;
    }
    del_auth_entry(entry);
  }
  return (auth_entry *)0x0;
}



void lock_auth_entry(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + 1;
  return;
}



void unlock_auth_entry(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



int is_auth_entry_used(listbox_item *item)

{
  return (uint)(*(int *)((int)item->udata + 8) != 0);
}



listbox_item * get_auth_entry_root(listbox_item *box_item)

{
  return (listbox_item *)0x0;
}



int can_delete_auth_entry(listbox_item *item)

{
  return 1;
}



void delete_auth_entry(listbox_item *item,int last)

{
  auth_entry *entry;
  bool bVar1;
  
  entry = (auth_entry *)item->udata;
  if ((assert_failed == 0) &&
     (bVar1 = (entry->object).refcount != 0, assert_failed = ZEXT14(bVar1), bVar1)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/dialogs.c";
    errline = 0xd4;
    elinks_internal((uchar *)"assertion !is_object_used(auth_entry) failed!");
    del_auth_entry(entry);
    return;
  }
  del_auth_entry(entry);
  return;
}



void auth_cancel(void *data)

{
  *(byte *)((int)data + 0x70) = *(byte *)((int)data + 0x70) & 0xfe;
  del_auth_entry((auth_entry *)data);
  return;
}



uri * get_auth_entry_uri(listbox_item *item)

{
  uri *puVar1;
  
  puVar1 = get_composed_uri(*(uri **)((int)item->udata + 0xc),URI_HTTP_AUTH);
  return puVar1;
}



string * __regparm3 add_bytes_to_string__(string *string,uchar *bytes,int length)

{
  int iVar1;
  uint uVar2;
  uchar *puVar3;
  uint size;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  if (((bytes == (uchar *)0x0) || (string == (string *)0x0)) || (length < 0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 0xff;
    elinks_internal((uchar *)
                    "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  if (length == 0) {
    return string;
  }
  iVar1 = length + string->length;
  uVar2 = string->length + 0xffU & 0xffffff00;
  size = iVar1 + 0x100U & 0xffffff00;
  if (uVar2 < size) {
    puVar3 = (uchar *)mem_realloc(string->source,size);
    if (puVar3 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar3;
    memset(puVar3 + uVar2,0,size - uVar2);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  memcpy(string->source + string->length,bytes,length);
  string->source[iVar1] = '\0';
  string->length = iVar1;
  return string;
}



uchar * __regparm3 _(terminal *term)

{
  int cp_index;
  uchar *codeset;
  terminal *in_EDX;
  
  if ((term != (terminal *)0x0) && (*(char *)&term->next != '\0')) {
    if (in_EDX != (terminal *)0x0) {
      cp_index = get_terminal_codepage(in_EDX);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    term = (terminal *)gettext((uchar *)term);
  }
  return (uchar *)term;
}



uchar * get_auth_entry_info(listbox_item *item,terminal *term)

{
  void *pvVar1;
  string *psVar2;
  uchar *source;
  size_t length;
  uchar *puVar3;
  string info;
  
  pvVar1 = item->udata;
  if (item->type != BI_FOLDER) {
    psVar2 = init_string(&info);
    if (psVar2 != (string *)0x0) {
      source = _((terminal *)0x812b6c9);
      add_format_to_string(&info,"%s: ",source);
      add_uri_to_string(&info,*(uri **)((int)pvVar1 + 0xc),URI_HTTP_AUTH);
      source = _((terminal *)"Realm");
      add_format_to_string(&info,"\n%s: ",source);
      source = *(uchar **)((int)pvVar1 + 0x10);
      if (source == (uchar *)0x0) {
        source = _((terminal *)&DAT_08128566);
        add_to_string(&info,source);
      }
      else {
        length = strlen((char *)source);
        if ((int)length < 0x200) {
          add_bytes_to_string__(&info,source,length);
        }
        else {
          add_bytes_to_string__(&info,source,0x200);
          add_to_string(&info,"...");
        }
      }
      if ((*(byte *)((int)pvVar1 + 0x70) & 2) == 0) {
        source = _((terminal *)"invalid");
      }
      else {
        source = _((terminal *)0x8127c3c);
      }
      puVar3 = _((terminal *)"State");
      add_format_to_string(&info,(uchar *)"\n%s: %s\n",puVar3,source);
      return info.source;
    }
  }
  return (uchar *)0x0;
}



uchar * get_auth_entry_text(listbox_item *item,terminal *term)

{
  uchar *puVar1;
  
  puVar1 = get_uri_string(*(uri **)((int)item->udata + 0xc),URI_HTTP_AUTH);
  return puVar1;
}



void auth_manager(session *ses)

{
  hierbox_browser(&auth_browser,ses);
  return;
}



void auth_ok(void *data)

{
  byte bVar1;
  session *ses;
  location *plVar2;
  int iVar3;
  uri *uri;
  int iVar4;
  bool bVar5;
  
  bVar5 = true;
  iVar3 = *(int *)((int)data + 8);
  ses = *(session **)((int)data + 4);
  bVar1 = *(byte *)(iVar3 + 0x70);
  *(byte *)(iVar3 + 0x70) = bVar1 & 0xfe;
  if (*(char *)(iVar3 + 0x20) == '\0') {
    bVar5 = *(char *)(iVar3 + 0x48) != '\0';
  }
  *(byte *)(iVar3 + 0x70) = bVar1 & 0xfc | bVar5 * '\x02';
  if (((bVar5 * '\x02' & 2U) == 0) || (plVar2 = (ses->history).current, plVar2 == (location *)0x0))
  goto LAB_080c7740;
  uri = (plVar2->vs).uri;
  if (*(short *)&uri->field_0x2a == 0) {
LAB_080c76af:
    if (uri->password == (uchar *)0x0) goto LAB_080c7740;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/dialogs.c";
    errline = 0x2e;
    iVar3 = elinks_strlcmp((uchar *)(iVar3 + 0x48),0xffffffff,uri->password,
                           (uint)*(ushort *)&uri->field_0x2c);
    if (iVar3 == 0) goto LAB_080c7740;
  }
  else {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/dialogs.c";
    errline = 0x2d;
    iVar4 = elinks_strlcmp((uchar *)(iVar3 + 0x20),0xffffffff,uri->user,
                           (uint)*(ushort *)&uri->field_0x2a);
    if (iVar4 == 0) goto LAB_080c76af;
  }
  uri = get_composed_uri(uri,0xffff82b3);
  if (uri != (uri *)0x0) {
    goto_uri_frame(ses,uri,(uchar *)0x0,CACHE_MODE_INCREMENT);
    done_uri(uri);
    return;
  }
LAB_080c7740:
  reload(ses,CACHE_MODE_INCREMENT);
  return;
}



void do_auth_dialog(session *ses,void *data)

{
  int iVar1;
  terminal *term;
  uchar *puVar2;
  auth_entry *done_data;
  uchar *label;
  int cp_index;
  uchar *codeset;
  uint __n;
  dialog *dlg;
  memory_list *ml;
  dialog_data *dlg_data;
  int in_GS_OFFSET;
  bool bVar3;
  uchar sticker [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  term = ses->tab->term;
  done_data = get_invalid_auth_entry();
  if (((done_data != (auth_entry *)0x0) && ((*(byte *)&done_data->field_0x70 & 1) == 0)) &&
     (label = get_uri_string(done_data->uri,URI_HTTP_AUTH), label != (uchar *)0x0)) {
    puVar2 = done_data->realm;
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Authentication required for %s at %s");
    __n = __snprintf_chk(sticker,0x400,1,0x400,codeset,puVar2,label);
    mem_free(label);
    if ((__n < 0x401) && (dlg = (dialog *)mem_calloc(1,__n + 0x115), dlg != (dialog *)0x0)) {
      *(byte *)&done_data->field_0x70 = *(byte *)&done_data->field_0x70 | 1;
      label = _((terminal *)"Authentication required");
      dlg->layouter = generic_dialog_layouter;
      dlg->title = label;
      memcpy(&dlg[3].abort,sticker,__n);
      *(session **)&dlg->udata = ses;
      *(auth_entry **)&dlg->udata2 = done_data;
      add_dlg_text(dlg,(uchar *)&dlg[3].abort,ALIGN_LEFT,0);
      label = _((terminal *)0x8132886);
      add_dlg_field_do(dlg,WIDGET_FIELD,label,0,0,(widget_handler_T *)0x0,0x28,done_data->user,
                       (input_history *)0x0,INPFIELD_FLOAT);
      label = _((terminal *)"Password");
      add_dlg_field_do(dlg,WIDGET_FIELD_PASS,label,0,0,(widget_handler_T *)0x0,0x28,
                       done_data->password,(input_history *)0x0,INPFIELD_FLOAT);
      label = _((terminal *)&DAT_081275e4);
      add_dlg_button_do(dlg,label,1,ok_dialog,(void *)0x0,auth_ok,dlg);
      label = _((terminal *)"~Cancel");
      add_dlg_button_do(dlg,label,2,ok_dialog,(void *)0x0,auth_cancel,done_data);
      if ((assert_failed == 0) &&
         (bVar3 = dlg->number_of_widgets != 5, assert_failed = ZEXT14(bVar3), bVar3)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/dialogs.c";
        errline = 0x76;
        elinks_internal((uchar *)"assertion 5 == (dlg)->number_of_widgets failed!");
      }
      ml = getml(dlg,0);
      dlg_data = do_dialog(term,dlg,ml);
      if (((dlg_data != (dialog_data *)0x0) && (done_data->user[0] != '\0')) &&
         (done_data->password[0] == '\0')) {
        select_widget_by_id(dlg_data,1);
      }
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void __regparm3 convert_to_md5_digest_hex_T(uchar *bin,uchar *hex)

{
  byte bVar1;
  uchar uVar2;
  int iVar3;
  
  iVar3 = 0;
  do {
    bVar1 = bin[iVar3] >> 4;
    uVar2 = bVar1 + 0x57;
    if (bVar1 < 10) {
      uVar2 = bVar1 + 0x30;
    }
    hex[iVar3 * 2] = uVar2;
    bVar1 = bin[iVar3] & 0xf;
    uVar2 = bVar1 + 0x57;
    if (bVar1 < 10) {
      uVar2 = bVar1 + 0x30;
    }
    hex[iVar3 * 2 + 1] = uVar2;
    iVar3 = iVar3 + 1;
  } while (iVar3 != 0x10);
  return;
}



// WARNING: Could not reconcile some variable overlaps

uchar * get_http_auth_digest_response(auth_entry *entry,uri *uri)

{
  uint *buf;
  int iVar1;
  int iVar2;
  ushort uVar3;
  int iVar4;
  byte bVar5;
  string *psVar6;
  uint __seed;
  uint uVar7;
  size_t len;
  undefined4 *puVar8;
  uchar *buf_00;
  uchar *puVar9;
  uint size;
  uint *buf_01;
  uint *puVar10;
  uint *puVar11;
  int in_GS_OFFSET;
  bool bVar12;
  string string;
  int local_174;
  MD5_CTX MD5Ctx_1;
  MD5_CTX MD5Ctx;
  md5_digest_hex_T Ha2_hex;
  md5_digest_hex_T ha1;
  md5_digest_hex_T response;
  md5_digest_hex_T cnonce;
  md5_digest_bin_T skey;
  md5_digest_bin_T md5;
  
  iVar4 = *(int *)(in_GS_OFFSET + 0x14);
  psVar6 = init_string(&string);
  buf_00 = (uchar *)0x0;
  if (psVar6 == (string *)0x0) goto LAB_080c81f6;
  __seed = time((time_t *)0x0);
  srand(__seed);
  local_174 = rand();
  digest_md5((uchar *)&local_174,4,md5);
  convert_to_md5_digest_hex_T(md5,cnonce);
  init_md5((md5_context *)&MD5Ctx_1);
  buf = (uint *)entry->user;
  buf_01 = buf;
  do {
    puVar11 = buf_01;
    __seed = *puVar11 + 0xfefefeff & ~*puVar11;
    uVar7 = __seed & 0x80808080;
    buf_01 = puVar11 + 1;
  } while (uVar7 == 0);
  bVar12 = (__seed & 0x8080) == 0;
  bVar5 = (byte)uVar7;
  if (bVar12) {
    bVar5 = (byte)(uVar7 >> 0x10);
  }
  if (bVar12) {
    buf_01 = (uint *)((int)puVar11 + 6);
  }
  update_md5((md5_context *)&MD5Ctx_1,(uchar *)buf,
             (int)buf_01 + ((-3 - (uint)CARRY1(bVar5,bVar5)) - (int)buf));
  update_md5((md5_context *)&MD5Ctx_1,":",1);
  buf_00 = entry->realm;
  len = strlen((char *)buf_00);
  update_md5((md5_context *)&MD5Ctx_1,buf_00,len);
  update_md5((md5_context *)&MD5Ctx_1,":",1);
  buf_01 = (uint *)entry->password;
  puVar11 = buf_01;
  do {
    puVar10 = puVar11;
    __seed = *puVar10 + 0xfefefeff & ~*puVar10;
    uVar7 = __seed & 0x80808080;
    puVar11 = puVar10 + 1;
  } while (uVar7 == 0);
  bVar12 = (__seed & 0x8080) == 0;
  bVar5 = (byte)uVar7;
  if (bVar12) {
    bVar5 = (byte)(uVar7 >> 0x10);
  }
  if (bVar12) {
    puVar11 = (uint *)((int)puVar10 + 6);
  }
  update_md5((md5_context *)&MD5Ctx_1,(uchar *)buf_01,
             (int)puVar11 + ((-3 - (uint)CARRY1(bVar5,bVar5)) - (int)buf_01));
  done_md5((md5_context *)&MD5Ctx_1,skey);
  convert_to_md5_digest_hex_T(skey,ha1);
  init_md5((md5_context *)&MD5Ctx_1);
  update_md5((md5_context *)&MD5Ctx_1,"GET",3);
  update_md5((md5_context *)&MD5Ctx_1,":/",2);
  update_md5((md5_context *)&MD5Ctx_1,uri->data,(uint)*(ushort *)&uri->field_0x31);
  done_md5((md5_context *)&MD5Ctx_1,skey);
  convert_to_md5_digest_hex_T(skey,Ha2_hex);
  init_md5((md5_context *)&MD5Ctx);
  update_md5((md5_context *)&MD5Ctx,ha1,0x20);
  update_md5((md5_context *)&MD5Ctx,":",1);
  buf_00 = entry->nonce;
  if (buf_00 != (uchar *)0x0) {
    len = strlen((char *)buf_00);
    update_md5((md5_context *)&MD5Ctx,buf_00,len);
  }
  update_md5((md5_context *)&MD5Ctx,":",1);
  update_md5((md5_context *)&MD5Ctx,(uchar *)"00000001",8);
  update_md5((md5_context *)&MD5Ctx,":",1);
  update_md5((md5_context *)&MD5Ctx,cnonce,0x20);
  update_md5((md5_context *)&MD5Ctx,":",1);
  update_md5((md5_context *)&MD5Ctx,"auth",4);
  update_md5((md5_context *)&MD5Ctx,":",1);
  update_md5((md5_context *)&MD5Ctx,Ha2_hex,0x20);
  done_md5((md5_context *)&MD5Ctx,md5);
  convert_to_md5_digest_hex_T(md5,response);
  add_to_string(&string,(uchar *)"username=\"");
  add_to_string(&string,(uchar *)buf);
  add_to_string(&string,"\", ");
  add_to_string(&string,(uchar *)"realm=\"");
  if (entry->realm != (uchar *)0x0) {
    add_to_string(&string,entry->realm);
  }
  add_to_string(&string,"\", ");
  add_to_string(&string,(uchar *)"nonce=\"");
  if (entry->nonce != (uchar *)0x0) {
    add_to_string(&string,entry->nonce);
  }
  add_to_string(&string,"\", ");
  add_to_string(&string,"uri=\"/");
  uVar3 = *(ushort *)&uri->field_0x31;
  buf_00 = uri->data;
  if (assert_failed == 0) {
    if (buf_00 == (uchar *)0x0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080c8024;
    }
    else {
      assert_failed = 0;
    }
    if (uVar3 != 0) {
      iVar2 = (uint)uVar3 + string.length;
      __seed = string.length + 0xffU >> 8;
      uVar7 = string.length + 0xffU & 0xffffff00;
      size = iVar2 + 0x100U & 0xffffff00;
      if (uVar7 <= size && size + __seed * -0x100 != 0) {
        puVar9 = (uchar *)mem_realloc(string.source,size);
        if (puVar9 == (uchar *)0x0) goto LAB_080c8030;
        string.source = puVar9;
        memset(puVar9 + uVar7,0,size + __seed * -0x100);
      }
      if (string.source != (uchar *)0x0) {
        memcpy(string.source + string.length,buf_00,(uint)uVar3);
        string.source[iVar2] = '\0';
        string.length = iVar2;
      }
    }
  }
  else {
LAB_080c8024:
    assert_failed = 0;
  }
LAB_080c8030:
  add_to_string(&string,"\", ");
  add_to_string(&string,(uchar *)"qop=auth, nc=00000001, ");
  add_to_string(&string,"cnonce=\"");
  iVar2 = string.length;
  if (assert_failed == 0) {
    assert_failed = 0;
    iVar1 = string.length + 0x20;
    size = string.length + 0x120U & 0xffffff00;
    __seed = string.length + 0xffU >> 8;
    uVar7 = string.length + 0xffU & 0xffffff00;
    if (uVar7 <= size && size + __seed * -0x100 != 0) {
      buf_00 = (uchar *)mem_realloc(string.source,size);
      if (buf_00 == (uchar *)0x0) goto LAB_080c80f5;
      string.source = buf_00;
      memset(buf_00 + uVar7,0,size + __seed * -0x100);
    }
    if (string.source != (uchar *)0x0) {
      puVar8 = (undefined4 *)(string.source + string.length);
      *puVar8 = cnonce._0_4_;
      puVar8[1] = cnonce._4_4_;
      puVar8[2] = cnonce._8_4_;
      puVar8[3] = cnonce._12_4_;
      puVar8[4] = cnonce._16_4_;
      puVar8[5] = cnonce._20_4_;
      puVar8[6] = cnonce._24_4_;
      puVar8[7] = cnonce._28_4_;
      string.source[iVar2 + 0x20] = '\0';
      string.length = iVar1;
    }
  }
  else {
    assert_failed = 0;
  }
LAB_080c80f5:
  add_to_string(&string,"\", ");
  add_to_string(&string,(uchar *)"response=\"");
  iVar2 = string.length;
  if (assert_failed == 0) {
    assert_failed = 0;
    iVar1 = string.length + 0x20;
    __seed = string.length + 0xffU >> 8;
    uVar7 = string.length + 0xffU & 0xffffff00;
    size = string.length + 0x120U & 0xffffff00;
    if (uVar7 <= size && size + __seed * -0x100 != 0) {
      buf_00 = (uchar *)mem_realloc(string.source,size);
      if (buf_00 == (uchar *)0x0) goto LAB_080c81aa;
      string.source = buf_00;
      memset(buf_00 + uVar7,0,size + __seed * -0x100);
    }
    if (string.source != (uchar *)0x0) {
      puVar8 = (undefined4 *)(string.source + string.length);
      *puVar8 = response._0_4_;
      puVar8[1] = response._4_4_;
      puVar8[2] = response._8_4_;
      puVar8[3] = response._12_4_;
      puVar8[4] = response._16_4_;
      puVar8[5] = response._20_4_;
      puVar8[6] = response._24_4_;
      puVar8[7] = response._28_4_;
      string.source[iVar2 + 0x20] = '\0';
      string.length = iVar1;
    }
  }
  else {
    assert_failed = 0;
  }
LAB_080c81aa:
  add_to_string(&string,"\"");
  buf_00 = string.source;
  if (entry->opaque != (uchar *)0x0) {
    add_to_string(&string,(uchar *)", opaque=\"");
    add_to_string(&string,entry->opaque);
    add_to_string(&string,"\"");
    buf_00 = string.source;
  }
LAB_080c81f6:
  if (iVar4 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return buf_00;
}



connection_state connection_state(void)

{
  int *in_EAX;
  int in_EDX;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(in_EDX == -1);
    if (in_EDX == -1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
      errline = 0x84;
      elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
      if (assert_failed != 0) goto LAB_080c8488;
    }
    in_EAX[1] = 0;
    *in_EAX = in_EDX;
    return (connection_state)CONCAT44(in_EDX,in_EAX);
  }
LAB_080c8488:
  assert_failed = 0;
  in_EAX[1] = 0;
  *in_EAX = -0x186a3;
  return (connection_state)CONCAT44(0xfffe795d,in_EAX);
}



void close_pipe_and_read(socket *data_socket)

{
  void *pvVar1;
  read_buffer *buffer;
  uint uVar2;
  
  pvVar1 = data_socket->conn;
  buffer = alloc_read_buffer(*(socket **)((int)pvVar1 + 0x60));
  if (buffer != (read_buffer *)0x0) {
    *(undefined4 *)buffer->data = 0x50545448;
    buffer[1].done = (socket_read_T *)0x302e312f;
    buffer[1].length = 0x30303220;
    buffer[1].freespace = 0xd4b4f20;
    buffer[1].data[0] = '\n';
    buffer->freespace = buffer->freespace + -0x11;
    buffer->length = 0x11;
    *(byte *)((int)pvVar1 + 0x78) = *(byte *)((int)pvVar1 + 0x78) | 2;
    close(data_socket->fd);
    data_socket->fd = -1;
    *(undefined4 *)(*(int *)((int)pvVar1 + 0x60) + 4) = 1;
    if (assert_failed == 0) {
      uVar2 = 4;
    }
    else {
      uVar2 = 0xfffe795d;
    }
    assert_failed = 0;
    read_from_socket(*(socket **)((int)pvVar1 + 0x60),buffer,(connection_state)(ulonglong)uVar2,
                     http_got_header);
  }
  return;
}



void __regparm3 send_post_data(connection *conn)

{
  int iVar1;
  int iVar2;
  int iVar3;
  byte bVar4;
  undefined2 uVar5;
  string *psVar6;
  char *pcVar7;
  uint size;
  undefined4 *puVar8;
  int iVar9;
  socket_write_T write_done;
  uchar *puVar10;
  char cVar11;
  byte *__s;
  size_t __n;
  undefined4 *puVar12;
  char cVar13;
  uint size_00;
  undefined4 *puVar14;
  int in_GS_OFFSET;
  bool bVar15;
  byte bVar16;
  uint local_1040;
  undefined4 local_1034;
  undefined4 local_1030;
  string data;
  uchar buffer [4096];
  
  bVar16 = 0;
  iVar3 = *(int *)(in_GS_OFFSET + 0x14);
  __s = conn->uri->post;
  psVar6 = init_string(&data);
  if (psVar6 == (string *)0x0) {
    connection_state();
    abort_connection(conn,(connection_state)CONCAT44(local_1030,local_1034));
    goto LAB_080c8879;
  }
  pcVar7 = strchr((char *)__s,10);
  if (pcVar7 != (char *)0x0) {
    __s = (byte *)(pcVar7 + 1);
  }
  __n = 0;
  while( true ) {
    bVar4 = *__s;
    size = (uint)bVar4;
    if ((bVar4 == 0) || (__s[1] == 0)) break;
    size_00 = size - 0x30;
    if ((9 < (byte)(bVar4 - 0x30)) && (size_00 = size - 0x57, 5 < (byte)(bVar4 + 0x9f))) {
      size_00 = 0xffffffff;
      if ((byte)(bVar4 + 0xbf) < 6) {
        size_00 = size - 0x37;
      }
    }
    if (assert_failed == 0) {
      assert_failed = ZEXT14(0xf < size_00);
      if (0xf < size_00) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/file/cgi.c";
        errline = 0x6b;
        elinks_internal((uchar *)"assertion h1 >= 0 && h1 < 16 failed!");
        if (assert_failed != 0) goto LAB_080c869f;
      }
      size = (uint)__s[1];
      cVar11 = (char)(size_00 << 4);
      if (9 < (byte)(__s[1] - 0x30)) goto LAB_080c86be;
LAB_080c861d:
      size = size - 0x30;
LAB_080c8620:
      cVar13 = (char)size;
      assert_failed = ZEXT14(0xf < size);
      if (0xf < size) goto LAB_080c871f;
    }
    else {
LAB_080c869f:
      size = (uint)__s[1];
      cVar11 = '\0';
      if ((byte)(__s[1] - 0x30) < 10) goto LAB_080c861d;
LAB_080c86be:
      if ((byte)((char)size + 0x9fU) < 6) {
        size = size - 0x57;
        goto LAB_080c8620;
      }
      if ((byte)((char)size + 0xbfU) < 6) {
        size = size - 0x37;
        goto LAB_080c8620;
      }
      assert_failed = 1;
      cVar13 = -1;
LAB_080c871f:
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/file/cgi.c";
      errline = 0x6f;
      elinks_internal((uchar *)"assertion h2 >= 0 && h2 < 16 failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        cVar13 = '\0';
      }
    }
    iVar2 = data.length;
    buffer[__n] = cVar13 + cVar11;
    __n = __n + 1;
    if (__n == 0x1000) {
      if (assert_failed == 0) {
        assert_failed = 0;
        size = data.length + 0x1100U & 0xffffff00;
        size_00 = data.length + 0xffU & 0xffffff00;
        iVar1 = data.length + 0x1000;
        if (size_00 < size) {
          puVar10 = (uchar *)mem_realloc(data.source,size);
          if (puVar10 != (uchar *)0x0) {
            data.source = puVar10;
            memset(puVar10 + size_00,0,size - size_00);
            goto LAB_080c87ba;
          }
        }
        else {
LAB_080c87ba:
          if (data.source != (uchar *)0x0) {
            puVar8 = (undefined4 *)(data.source + data.length);
            puVar12 = (undefined4 *)buffer;
            local_1040 = 0x1000;
            bVar15 = ((uint)puVar8 & 1) != 0;
            puVar14 = puVar8;
            if (bVar15) {
              puVar14 = (undefined4 *)((int)puVar8 + 1);
              puVar12 = (undefined4 *)(buffer + 1);
              *(uchar *)puVar8 = buffer[0];
              local_1040 = 0xfff;
            }
            if (((uint)puVar14 & 2) != 0) {
              uVar5 = *(undefined2 *)puVar12;
              puVar12 = (undefined4 *)((int)puVar12 + 2);
              *(undefined2 *)puVar14 = uVar5;
              puVar14 = (undefined4 *)((int)puVar14 + 2);
              local_1040 = local_1040 - 2;
            }
            iVar9 = 0;
            size = local_1040 >> 2;
            while (size != 0) {
              size = size - 1;
              *puVar14 = *puVar12;
              puVar12 = puVar12 + (uint)bVar16 * 0x3ffffffe + 1;
              puVar14 = puVar14 + (uint)bVar16 * 0x3ffffffe + 1;
            }
            if ((local_1040 & 2) != 0) {
              *(undefined2 *)puVar14 = *(undefined2 *)puVar12;
              iVar9 = 2;
            }
            if (bVar15) {
              *(undefined *)((int)puVar14 + iVar9) = *(undefined *)((int)puVar12 + iVar9);
            }
            __n = 0;
            data.source[iVar2 + 0x1000] = '\0';
            data.length = iVar1;
            goto LAB_080c8650;
          }
        }
        __n = 0;
      }
      else {
        assert_failed = 0;
        __n = 0;
      }
    }
LAB_080c8650:
    __s = __s + 2;
  }
  if (__n != 0) {
    if (assert_failed == 0) {
      if ((int)__n < 0) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) goto LAB_080c8a30;
      }
      else {
        assert_failed = 0;
      }
      iVar2 = __n + data.length;
      size_00 = iVar2 + 0x100U & 0xffffff00;
      size = data.length + 0xffU & 0xffffff00;
      if (size < size_00) {
        puVar10 = (uchar *)mem_realloc(data.source,size_00);
        if (puVar10 == (uchar *)0x0) goto LAB_080c8856;
        data.source = puVar10;
        memset(puVar10 + size,0,size_00 - size);
      }
      if (data.source != (uchar *)0x0) {
        memcpy(data.source + data.length,buffer,__n);
        data.source[iVar2] = '\0';
        data.length = iVar2;
      }
    }
    else {
LAB_080c8a30:
      assert_failed = 0;
    }
  }
LAB_080c8856:
  if (data.length == 0) {
    close_pipe_and_read(conn->data_socket);
  }
  else {
    if (assert_failed == 0) {
      write_done = (socket_write_T)&DAT_00000004;
    }
    else {
      write_done = (socket_write_T)0xfffe795d;
    }
    assert_failed = 0;
    write_to_socket(conn->data_socket,data.source,data.length,write_done);
  }
  done_string(&data);
LAB_080c8879:
  if (iVar3 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

int execute_cgi(connection *conn)

{
  uchar uVar1;
  cache_entry *pcVar2;
  void *pvVar3;
  int *piVar4;
  int iVar5;
  uchar *name;
  uchar **ppuVar6;
  uchar *value;
  size_t __n;
  __pid_t _Var7;
  http_connection_info *phVar8;
  uchar *value_00;
  string *string;
  uri *puVar9;
  uint uVar10;
  uchar *in_EDX;
  uchar *name_00;
  uchar *extraout_EDX;
  uchar *extraout_EDX_00;
  uchar *name_01;
  uchar *name_02;
  uchar *name_03;
  undefined4 *puVar11;
  int in_GS_OFFSET;
  byte bVar12;
  connection *local_11c;
  char *local_118;
  connection *pcVar13;
  uchar *local_f0;
  connection *local_e8;
  connection *local_e4;
  int local_e0;
  stat buf;
  int pipe_write [2];
  int pipe_read [2];
  uchar *local_68;
  uchar *local_64;
  uchar buf_1 [16];
  int local_20;
  
  bVar12 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if (assert_failed == 0) {
    local_e8 = (connection *)0xfffe7960;
  }
  else {
    local_e8 = (connection *)0xfffe795d;
  }
  assert_failed = 0;
  local_118 = "protocol.file.cgi.policy";
  local_11c = (connection *)config_options;
  piVar4 = get_opt_(config_options,in_EDX);
  if ((*piVar4 == 0) || ((conn->referrer != (uri *)0x0 && (conn->referrer->protocol != 4)))) {
    iVar5 = 1;
    local_e8 = (connection *)local_118;
    goto LAB_080c8b8a;
  }
  local_11c = (connection *)get_uri_string(conn->uri,URI_PATH);
  if (local_11c == (connection *)0x0) {
    connection_state();
    local_e8 = local_e4;
end2:
    abort_connection(conn,(connection_state)CONCAT44(local_e0,local_e8));
    iVar5 = 0;
    local_11c = conn;
  }
  else {
    decode_uri((uchar *)local_11c);
    pcVar13 = local_11c;
    iVar5 = __xstat64(3,(char *)local_11c,(stat64 *)&buf);
    if ((iVar5 == 0) && ((buf.st_mode & 0xf040) == 0x8040)) {
      pcVar13 = (connection *)0x2f;
      name = (uchar *)strrchr((char *)local_11c,0x2f);
      if (name != (uchar *)0x0) {
        uVar1 = name[1];
        name[1] = '\0';
        ppuVar6 = (uchar **)get_opt_(config_options,name);
        local_64 = *ppuVar6;
        do {
          pcVar13 = (connection *)0x3a;
          value = get_next_path_filename(&local_64,':');
          local_68 = value;
          if (value == (uchar *)0x0) {
            name[1] = uVar1;
            goto LAB_080c8c15;
          }
          __n = strlen((char *)value);
          if (value[__n - 1] != '/') {
            add_to_strn(&local_68,"/");
            __n = __n + 1;
            value = local_68;
          }
          iVar5 = strncmp((char *)local_11c,(char *)value,__n);
          mem_free(value);
        } while (iVar5 != 0);
        name[1] = uVar1;
        iVar5 = c_pipe(pipe_read);
        if ((iVar5 == 0) && (iVar5 = c_pipe(pipe_write), iVar5 == 0)) {
          _Var7 = fork();
          if (_Var7 < 0) {
            piVar4 = __errno_location();
            local_e0 = *piVar4;
            local_e8 = (connection *)0xffffffff;
          }
          else {
            if (_Var7 != 0) {
              mem_free(local_11c);
              local_e8 = (connection *)0x1;
              phVar8 = init_http_connection_info(conn,1,0,1);
              if (phVar8 == (http_connection_info *)0x0) {
                close(pipe_read[0]);
                close(pipe_read[1]);
                close(pipe_write[0]);
                close(pipe_write[1]);
                iVar5 = 0;
                local_11c = (connection *)pipe_write[1];
              }
              else {
                close(pipe_read[1]);
                close(pipe_write[0]);
                conn->socket->fd = pipe_read[0];
                conn->data_socket->fd = pipe_write[1];
                *(byte *)&conn->field_0x78 = *(byte *)&conn->field_0x78 | 8;
                set_nonblocking_fd(conn->socket->fd);
                local_11c = (connection *)conn->data_socket->fd;
                set_nonblocking_fd((int)local_11c);
                if (conn->uri->post == (uchar *)0x0) {
                  local_11c = (connection *)conn->data_socket;
                  close_pipe_and_read((socket *)local_11c);
                  iVar5 = 0;
                }
                else {
                  send_post_data(conn);
                  iVar5 = 0;
                }
              }
              goto LAB_080c8b8a;
            }
            local_f0 = conn->uri->post;
            value = get_uri_string(conn->uri,URI_QUERY);
            if (value == (uchar *)0x0) {
              iVar5 = env_set((uchar *)"QUERY_STRING","",-1);
            }
            else {
              iVar5 = env_set((uchar *)"QUERY_STRING",value,-1);
              mem_free(value);
            }
            if (iVar5 != 0) goto LAB_080c8e57;
            if (local_f0 == (uchar *)0x0) {
LAB_080c955a:
              value = "GET";
            }
            else {
              local_118 = strchr((char *)local_f0,10);
              if (local_118 != (char *)0x0) {
                iVar5 = env_set((uchar *)"CONTENT_TYPE",local_f0,(int)(local_118 + -(int)local_f0));
                if (iVar5 != 0) goto LAB_080c8e57;
                local_f0 = (uchar *)(local_118 + 1);
              }
              uVar10 = 0xffffffff;
              value = local_f0;
              do {
                if (uVar10 == 0) break;
                uVar10 = uVar10 - 1;
                uVar1 = *value;
                value = value + (uint)bVar12 * -2 + 1;
              } while (uVar1 != '\0');
              __snprintf_chk(buf_1,0x10,1,0x10,0x813389d,(int)(~uVar10 - 1) / 2);
              iVar5 = env_set((uchar *)"CONTENT_LENGTH",buf_1,-1);
              if (iVar5 != 0) goto LAB_080c8e57;
              value = "POST";
              if (local_f0 == (uchar *)0x0) goto LAB_080c955a;
            }
            iVar5 = env_set((uchar *)"REQUEST_METHOD",value,-1);
            if ((((((iVar5 != 0) ||
                   (iVar5 = env_set((uchar *)"SERVER_SOFTWARE",(uchar *)"ELinks/0.12pre5",-1),
                   iVar5 != 0)) ||
                  (iVar5 = env_set((uchar *)"SERVER_PROTOCOL","HTTP/1.0",-1), iVar5 != 0)) ||
                 (((iVar5 = env_set((uchar *)"SERVER_NAME",(uchar *)"localhost",-1), iVar5 != 0 ||
                   (iVar5 = env_set((uchar *)"REMOTE_ADDR",(uchar *)"127.0.0.1",-1), iVar5 != 0)) ||
                  ((iVar5 = env_set((uchar *)"GATEWAY_INTERFACE",(uchar *)"CGI/1.1",-1), iVar5 != 0
                   || ((iVar5 = env_set((uchar *)"SCRIPT_NAME",(uchar *)local_11c,-1), iVar5 != 0 ||
                       (iVar5 = env_set((uchar *)"SCRIPT_FILENAME",(uchar *)local_11c,-1),
                       iVar5 != 0)))))))) ||
                (iVar5 = env_set((uchar *)"PATH_TRANSLATED",(uchar *)local_11c,-1), iVar5 != 0)) ||
               (iVar5 = env_set((uchar *)"REDIRECT_STATUS","1",-1), iVar5 != 0)) {
LAB_080c8e57:
                    // WARNING: Subroutine does not return
              _exit(1);
            }
            ppuVar6 = (uchar **)get_opt_(config_options,name_00);
            pvVar3 = terminals.prev;
            value = *ppuVar6;
            if ((*value != '\0') && ((*value != ' ' || (value[1] != '\0')))) {
              iVar5 = 0xf;
              puVar11 = (undefined4 *)(buf_1 + 4);
              while (iVar5 != 0) {
                iVar5 = iVar5 + -1;
                *puVar11 = 0;
                puVar11 = puVar11 + (uint)bVar12 * 0x3ffffffe + 1;
              }
              buf_1._0_4_ = 0;
              if ((list_head_elinks *)terminals.next != &terminals) {
                local_68 = (uchar *)0x0;
                elinks_ulongcat(buf_1,(uint *)&local_68,*(uint *)((int)terminals.prev + 0x2c),'\x03'
                                ,0,10);
                buf_1[(int)local_68] = 'x';
                local_68 = local_68 + 1;
                elinks_ulongcat(buf_1,(uint *)&local_68,*(uint *)((int)pvVar3 + 0x30),'\x03',0,10);
              }
              value_00 = subst_user_agent(value,"0.12pre5",system_name,buf_1);
              value = extraout_EDX;
              if (value_00 != (uchar *)0x0) {
                env_set((uchar *)"HTTP_USER_AGENT",value_00,-1);
                mem_free(value_00);
                value = extraout_EDX_00;
              }
            }
            piVar4 = get_opt_(config_options,value);
            iVar5 = *piVar4;
            if (iVar5 == 2) {
              puVar9 = (uri *)get_opt_(config_options,name_01);
LAB_080c9524:
              env_set((uchar *)"HTTP_REFERER",puVar9->string,-1);
            }
            else {
              if (iVar5 == 3) {
                puVar9 = conn->referrer;
                if (puVar9 != (uri *)0x0) goto LAB_080c9524;
              }
              else {
                if ((iVar5 == 1) &&
                   (value = get_uri_string(conn->uri,URI_HTTP_REFERRER), value != (uchar *)0x0)) {
                  env_set((uchar *)"HTTP_REFERER",value,-1);
                  mem_free(value);
                }
              }
            }
            env_set((uchar *)"HTTP_ACCEPT","*/*",-1);
            ppuVar6 = (uchar **)get_opt_(config_options,name_02);
            value = *ppuVar6;
            if (*value == '\0') {
              piVar4 = get_opt_(config_options,name_03);
              if (*piVar4 != 0) {
                value = language_to_iso639(current_language);
                goto LAB_080c94a2;
              }
            }
            else {
LAB_080c94a2:
              env_set((uchar *)"HTTP_ACCEPT_LANGUAGE",value,-1);
            }
            pcVar2 = conn->cached;
            if ((((pcVar2 == (cache_entry *)0x0) || ((*(byte *)&pcVar2->field_0x5c & 8) != 0)) ||
                (pcVar2->head == (uchar *)0x0)) || (pcVar2->last_modified == (uchar *)0x0)) {
LAB_080c9486:
              if (2 < conn->cache_mode) goto LAB_080c938b;
            }
            else {
              if (conn->cache_mode < 3) {
                env_set((uchar *)"HTTP_IF_MODIFIED_SINCE",pcVar2->last_modified,-1);
                goto LAB_080c9486;
              }
LAB_080c938b:
              env_set((uchar *)"HTTP_PRAGMA","no-cache",-1);
              env_set((uchar *)"HTTP_CACHE_CONTROL","no-cache",-1);
            }
            string = send_cookies(conn->uri);
            if (string != (string *)0x0) {
              env_set((uchar *)"HTTP_COOKIE",string->source,-1);
              done_string(string);
            }
            iVar5 = dup2(pipe_write[0],0);
            if ((iVar5 < 0) || (iVar5 = dup2(pipe_read[1],1), iVar5 < 0)) {
                    // WARNING: Subroutine does not return
              _exit(2);
            }
            close_all_non_term_fd();
            *name = '\0';
            set_cwd((uchar *)local_11c);
            *name = '/';
            iVar5 = execl((char *)local_11c,(char *)local_11c,0);
            if (iVar5 != 0) {
                    // WARNING: Subroutine does not return
              _exit(3);
            }
            local_e0 = 0;
          }
          close(pipe_read[0]);
          close(pipe_read[1]);
          close(pipe_write[0]);
          close(pipe_write[1]);
        }
        else {
          piVar4 = __errno_location();
          local_e0 = *piVar4;
          local_e8 = (connection *)0xffffffff;
        }
        mem_free(local_11c);
        goto end2;
      }
    }
LAB_080c8c15:
    local_e8 = pcVar13;
    mem_free(local_11c);
    iVar5 = 1;
  }
LAB_080c8b8a:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail(local_11c,local_e8);
  }
  return iVar5;
}



void __regparm3 add_dir_entry(directory_entry *entry,string *page,int pathlen,uchar *dircolor)

{
  uchar *src;
  string *psVar1;
  size_t len;
  ssize_t sVar2;
  int iVar3;
  int in_GS_OFFSET;
  uchar *local_4a0;
  stat st;
  string uri_encoded_name;
  string html_encoded_name;
  uchar buf [1024];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  psVar1 = init_string(&html_encoded_name);
  if (psVar1 != (string *)0x0) {
    psVar1 = init_string(&uri_encoded_name);
    if (psVar1 == (string *)0x0) {
      done_string(&html_encoded_name);
    }
    else {
      encode_uri_string(&uri_encoded_name,entry->name + pathlen,-1,1);
      len = strlen((char *)entry->name);
      add_html_to_string(&html_encoded_name,entry->name + pathlen,len - pathlen);
      src = entry->attrib;
      len = strlen((char *)src);
      add_html_to_string(page,src,len);
      add_to_string(page,(uchar *)"<a href=\"");
      add_string_to_string(page,&uri_encoded_name);
      if (*entry->attrib == 'd') {
        add_char_to_string(page,'/');
        local_4a0 = (uchar *)0x0;
      }
      else {
        local_4a0 = (uchar *)0x0;
        if (*entry->attrib == 'l') {
          sVar2 = readlink((char *)entry->name,(char *)buf,0x400);
          if ((sVar2 == 0x400) || (sVar2 < 1)) {
            local_4a0 = (uchar *)0x0;
          }
          else {
            buf[sVar2] = '\0';
            local_4a0 = straconcat(" -> ",buf,0);
          }
          iVar3 = __xstat64(3,(char *)entry->name,(stat64 *)&st);
          if ((iVar3 == 0) && ((st.st_mode & 0xf000) == 0x4000)) {
            add_char_to_string(page,'/');
          }
        }
      }
      add_to_string(page,"\">");
      if ((*entry->attrib == 'd') && (*dircolor != '\0')) {
        string_concat(page,"<font color=\"",dircolor,"\"><b>",0);
      }
      add_string_to_string(page,&html_encoded_name);
      done_string(&uri_encoded_name);
      done_string(&html_encoded_name);
      if ((*entry->attrib == 'd') && (*dircolor != '\0')) {
        add_to_string(page,(uchar *)"</b></font>");
      }
      add_to_string(page,"</a>");
      if (local_4a0 != (uchar *)0x0) {
        len = strlen((char *)local_4a0);
        add_html_to_string(page,local_4a0,len);
        mem_free(local_4a0);
      }
      add_char_to_string(page,'\n');
    }
  }
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



connection_state connection_state(void)

{
  int *in_EAX;
  int in_EDX;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(in_EDX == -1);
    if (in_EDX == -1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
      errline = 0x84;
      elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
      if (assert_failed != 0) goto LAB_080c9908;
    }
    in_EAX[1] = 0;
    *in_EAX = in_EDX;
    return (connection_state)CONCAT44(in_EDX,in_EAX);
  }
LAB_080c9908:
  assert_failed = 0;
  in_EAX[1] = 0;
  *in_EAX = -0x186a3;
  return (connection_state)CONCAT44(0xfffe795d,in_EAX);
}



void file_protocol_handler(connection *connection)

{
  off_t *poVar1;
  int iVar2;
  uint uVar3;
  directory_entry *pdVar4;
  int *piVar5;
  string *psVar6;
  directory_entry *p;
  size_t pathlen;
  cache_entry *cached;
  uri *puVar7;
  color_T *pcVar8;
  uchar *name_00;
  int get_hidden;
  uchar *in_EDX;
  uchar *extraout_EDX;
  uchar *extraout_EDX_00;
  uchar *name_01;
  uchar *name_02;
  uchar *puVar9;
  directory_entry *entry;
  int in_GS_OFFSET;
  bool bVar10;
  byte bVar11;
  connection *local_7c;
  char *local_78;
  uchar *local_4c;
  int local_48;
  string local_44;
  string name;
  string page;
  uchar dircolor [8];
  
  bVar11 = 0;
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  local_78 = "anonymous";
  piVar5 = get_opt_(cmdline_options,in_EDX);
  bVar10 = *piVar5 == 0;
  if (!bVar10) {
    get_hidden = 0x12;
    name_00 = connection->uri->string;
    puVar9 = (uchar *)"file:///dev/stdin";
    do {
      if (get_hidden == 0) break;
      get_hidden = get_hidden + -1;
      bVar10 = *name_00 == *puVar9;
      name_00 = name_00 + (uint)bVar11 * -2 + 1;
      puVar9 = puVar9 + (uint)bVar11 * -2 + 1;
    } while (bVar10);
    if ((!bVar10) || (get_hidden = isatty(0), get_hidden != 0)) {
      if (assert_failed == 0) {
        local_78 = (char *)0xfffe7895;
      }
      else {
        local_78 = (char *)0xfffe795d;
      }
      assert_failed = 0;
      abort_connection(connection,(connection_state)ZEXT48(local_78));
      local_7c = connection;
      goto LAB_080c9992;
    }
  }
  local_7c = connection;
  get_hidden = execute_cgi(connection);
  if (get_hidden == 0) goto LAB_080c9992;
  psVar6 = init_string(&name);
  if ((psVar6 == (string *)0x0) ||
     (psVar6 = add_uri_to_string(&name,connection->uri,URI_PATH), psVar6 == (string *)0x0)) {
    done_string(&name);
    connection_state();
    abort_connection(connection,(connection_state)CONCAT44(local_44.length,local_44.source));
    local_7c = connection;
    local_78 = (char *)local_44.source;
    goto LAB_080c9992;
  }
  decode_uri_string(&name);
  if (((name.length < 1) || (name_00 = extraout_EDX, name.source[name.length + -1] != '/')) &&
     (get_hidden = file_is_dir(name.source), name_00 = extraout_EDX_00, get_hidden == 0)) {
    read_encoded_file(&local_44,&name);
    bVar10 = false;
    local_4c = (uchar *)0x0;
    local_48 = local_44.length;
    local_78 = (char *)local_44.source;
  }
  else {
    if ((*name.source == '\0') || (name.source[name.length + -1] == '/')) {
      piVar5 = get_opt_(config_options,name_00);
      get_hidden = *piVar5;
      piVar5 = __errno_location();
      *piVar5 = 0;
      p = get_directory_entries(name.source,get_hidden);
      if (p == (directory_entry *)0x0) {
        local_48 = *piVar5;
        local_78 = (char *)(uchar *)0xffffffff;
        if (*piVar5 == 0) {
          connection_state();
          local_48 = local_44.length;
          local_78 = (char *)local_44.source;
        }
      }
      else {
        init_directory_listing(&local_44,(uri *)&page);
        if (local_44.source == (uchar *)0xfffe7960) {
          pathlen = strlen((char *)name.source);
          piVar5 = get_opt_(config_options,name_01);
          if (*piVar5 == 0) {
            dircolor[0] = '\0';
          }
          else {
            pcVar8 = get_opt_(config_options,name_02);
            color_to_string(*pcVar8,dircolor);
          }
          if (p->name != (uchar *)0x0) {
            entry = p;
            do {
              add_dir_entry(entry,&page,pathlen,dircolor);
              mem_free(entry->attrib);
              mem_free(entry->name);
              pdVar4 = entry + 1;
              entry = entry + 1;
            } while (pdVar4->name != (uchar *)0x0);
          }
          mem_free(p);
          psVar6 = add_to_string(&page,(uchar *)"</pre>\n<hr/>\n</body>\n</html>\n");
          if (psVar6 != (string *)0x0) {
            connection_state();
            local_48 = local_44.length;
            local_78 = (char *)local_44.source;
            goto LAB_080c9b45;
          }
          done_string(&page);
        }
        connection_state();
        local_48 = local_44.length;
        local_78 = (char *)local_44.source;
      }
LAB_080c9b45:
      bVar10 = true;
      local_4c = (uchar *)0x0;
    }
    else {
      local_4c = "/";
      connection_state();
      bVar10 = false;
      local_48 = local_44.length;
      local_78 = (char *)local_44.source;
    }
  }
  done_string(&name);
  if ((uchar *)local_78 == (uchar *)0xfffe7960) {
    cached = get_cache_entry(connection->uri);
    connection->cached = cached;
    if (cached == (cache_entry *)0x0) {
      if (local_4c == (uchar *)0x0) {
        done_string(&page);
      }
LAB_080c9d02:
      connection_state();
      local_48 = local_44.length;
      local_78 = (char *)local_44.source;
    }
    else {
      if (local_4c == (uchar *)0x0) {
        add_fragment(cached,0,page.source,page.length);
        poVar1 = &connection->from;
        uVar3 = *(uint *)poVar1;
        *(uint *)poVar1 = *(uint *)poVar1 + page.length;
        piVar5 = (int *)((int)&connection->from + 4);
        *piVar5 = *piVar5 + (page.length >> 0x1f) + (uint)CARRY4(uVar3,page.length);
        if ((bVar10) && (cached->head == (uchar *)0x0)) {
          get_hidden = get_cp_index((uchar *)"System");
          name_00 = get_cp_mime_name(get_hidden);
          name_00 = straconcat((uchar *)"\r\nContent-Type: text/html; charset=",name_00,
                               &DAT_081352f5,0);
          if (name_00 == (uchar *)0x0) {
            connection_state();
            local_48 = local_44.length;
            local_78 = (char *)local_44.source;
          }
          if (cached->head != (uchar *)0x0) {
            mem_free(cached->head);
          }
          cached->head = name_00;
        }
        done_string(&page);
      }
      else {
        puVar7 = redirect_cache(cached,local_4c,1,0);
        if (puVar7 == (uri *)0x0) goto LAB_080c9d02;
      }
    }
  }
  abort_connection(connection,(connection_state)CONCAT44(local_48,local_78));
  local_7c = connection;
LAB_080c9992:
  if (iVar2 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail(local_7c,local_78);
  }
  return;
}



void finger_protocol_handler(connection *conn)

{
  cache_mode cVar1;
  
  cVar1 = conn->cache_mode;
  *(undefined4 *)&conn->from = 0;
  *(undefined4 *)((int)&conn->from + 4) = 0;
  make_connection(conn->socket,conn->uri,finger_send_request,(uint)(2 < cVar1));
  return;
}



void finger_send_request(socket *socket)

{
  ushort uVar1;
  void *__src;
  int iVar2;
  string *psVar3;
  uint uVar4;
  uint uVar5;
  uchar *puVar6;
  uint size;
  string req;
  
  __src = socket->conn;
  psVar3 = init_string(&req);
  if (psVar3 == (string *)0x0) {
    return;
  }
  if (*(int *)(*(int *)((int)__src + 0x14) + 0xc) == 0) goto LAB_080c9f40;
  add_char_to_string(&req,' ');
  iVar2 = *(int *)((int)__src + 0x14);
  uVar1 = *(ushort *)(iVar2 + 0x2a);
  __src = *(void **)(iVar2 + 0xc);
  if (assert_failed == 0) {
    if (__src == (void *)0x0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080ca000;
    }
    else {
      assert_failed = 0;
    }
    if (uVar1 != 0) {
      iVar2 = (uint)uVar1 + req.length;
      uVar5 = req.length + 0xffU >> 8;
      uVar4 = req.length + 0xffU & 0xffffff00;
      size = iVar2 + 0x100U & 0xffffff00;
      if (uVar4 <= size && size + uVar5 * -0x100 != 0) {
        puVar6 = (uchar *)mem_realloc(req.source,size);
        if (puVar6 == (uchar *)0x0) goto LAB_080c9f40;
        req.source = puVar6;
        memset(puVar6 + uVar4,0,size + uVar5 * -0x100);
      }
      if (req.source != (uchar *)0x0) {
        memcpy(req.source + req.length,__src,(uint)uVar1);
        req.source[iVar2] = '\0';
        req.length = iVar2;
      }
    }
  }
  else {
LAB_080ca000:
    assert_failed = 0;
  }
LAB_080c9f40:
  add_crlf_to_string(&req);
  if (assert_failed == 0) {
    uVar5 = 4;
  }
  else {
    uVar5 = 0xfffe795d;
  }
  assert_failed = 0;
  request_from_socket(socket,req.source,req.length,(connection_state)(ulonglong)uVar5,
                      SOCKET_END_ONCLOSE,finger_get_response);
  done_string(&req);
  return;
}



void finger_get_response(socket *socket,read_buffer *rb)

{
  off_t *poVar1;
  int *piVar2;
  connection *conn;
  uint uVar3;
  cache_entry *cached;
  int iVar4;
  uint length;
  
  conn = (connection *)socket->conn;
  cached = get_cache_entry(conn->uri);
  if (cached == (cache_entry *)0x0) {
    if (assert_failed == 0) {
      length = 0xfffe795c;
      goto LAB_080ca189;
    }
  }
  else {
    conn->cached = cached;
    if (socket->state != SOCKET_CLOSED) {
      length = rb->length;
      poVar1 = &conn->received;
      uVar3 = *(uint *)poVar1;
      *(uint *)poVar1 = *(int *)poVar1 + length;
      piVar2 = (int *)((int)&conn->received + 4);
      *piVar2 = *piVar2 + ((int)length >> 0x1f) + (uint)CARRY4(uVar3,length);
      iVar4 = add_fragment(cached,conn->from,rb->data,length);
      if (iVar4 == 1) {
        conn->tries = 0;
      }
      poVar1 = &conn->from;
      uVar3 = *(uint *)poVar1;
      *(uint *)poVar1 = *(int *)poVar1 + length;
      piVar2 = (int *)((int)&conn->from + 4);
      *piVar2 = *piVar2 + ((int)length >> 0x1f) + (uint)CARRY4(uVar3,length);
      kill_buffer_data(rb,length);
      if (assert_failed == 0) {
        length = 8;
      }
      else {
        length = 0xfffe795d;
      }
      assert_failed = 0;
      read_from_socket(conn->socket,rb,(connection_state)(ulonglong)length,finger_get_response);
      return;
    }
    if (assert_failed == 0) {
      length = 0xfffe7960;
      goto LAB_080ca189;
    }
  }
  length = 0xfffe795d;
LAB_080ca189:
  assert_failed = 0;
  abort_connection(conn,(connection_state)(ulonglong)length);
  return;
}



connection_state __regparm3 connection_state(connection_basic_state basic)

{
  int in_EDX;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(in_EDX == -1);
    if (in_EDX == -1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
      errline = 0x84;
      elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
      if (assert_failed != 0) goto LAB_080ca248;
    }
    *(undefined4 *)(basic + S_SENT) = 0;
    *(int *)basic = in_EDX;
    return (connection_state)CONCAT44(in_EDX,basic);
  }
LAB_080ca248:
  assert_failed = 0;
  *(undefined4 *)(basic + S_SENT) = 0;
  *(undefined4 *)basic = 0xfffe795d;
  return (connection_state)CONCAT44(0xfffe795d,basic);
}



int __regparm3 parse_psv_resp(uchar *data,int *n,int max_value)

{
  uint uVar1;
  byte *pbVar2;
  byte bVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  
  uVar1 = 0;
  do {
    *(undefined4 *)((int)n + uVar1) = 0;
    uVar1 = uVar1 + 4;
  } while (uVar1 < 0x18);
  pbVar2 = data;
  if (0x1f < *data) {
    do {
      pbVar2 = pbVar2 + 1;
    } while (0x1f < *pbVar2);
    if (data != pbVar2) {
      do {
        pbVar2 = pbVar2 + -1;
        if (data == pbVar2) {
          return 0;
        }
        bVar3 = *pbVar2;
      } while (9 < (byte)(bVar3 - 0x30));
      iVar6 = 5;
      do {
        if ((byte)(bVar3 - 0x30) < 10) {
          iVar4 = n[iVar6] + -0x30 + (uint)bVar3;
          n[iVar6] = iVar4;
          if (max_value < iVar4) {
            return 0;
          }
          iVar4 = 1;
          while( true ) {
            pbVar2 = pbVar2 + -1;
            if (data == pbVar2) goto LAB_080ca32c;
            if (9 < (byte)(*pbVar2 - 0x30)) break;
            iVar4 = iVar4 * 10;
            iVar5 = ((uint)*pbVar2 - 0x30) * iVar4 + n[iVar6];
            n[iVar6] = iVar5;
            if (max_value < iVar5) {
              return 0;
            }
          }
        }
        do {
          pbVar2 = pbVar2 + -1;
          if (data == pbVar2) {
LAB_080ca32c:
            return 6 - iVar6;
          }
          bVar3 = *pbVar2;
        } while (9 < (byte)(bVar3 - 0x30));
        iVar6 = iVar6 + -1;
      } while (iVar6 != -1);
    }
  }
  return 0;
}



void __regparm3 send_cmd(connection *conn,string *cmd,void *callback,connection_state state)

{
  request_from_socket(conn->socket,cmd->source,cmd->length,state,SOCKET_RETRY_ONCLOSE,
                      (socket_read_T *)callback);
  done_string(cmd);
  return;
}



int __regparm3 ftp_data_connect(connection *conn,int pf,sockaddr_storage *sa,int size_of_sockaddr)

{
  int fd;
  int iVar1;
  undefined4 local_24;
  undefined4 local_20;
  
  if (((conn->data_socket->fd == -1) && (fd = socket(pf,1,0), -1 < fd)) &&
     (iVar1 = set_nonblocking_fd(fd), -1 < iVar1)) {
    set_ip_tos_throughput(fd);
    conn->data_socket->fd = fd;
    connect(fd,(sockaddr *)sa,size_of_sockaddr);
    return 0;
  }
  connection_state((connection_basic_state)&local_24);
  abort_connection(conn,(connection_state)CONCAT44(local_20,local_24));
  return -1;
}



// WARNING: Could not reconcile some variable overlaps

int __regparm3 get_ftp_response(connection *conn,read_buffer *rb,int part,sockaddr_storage *sa)

{
  uchar *__s;
  uchar uVar1;
  void *pvVar2;
  int *piVar3;
  ulong uVar4;
  int iVar5;
  uchar *puVar6;
  int iVar7;
  uint uVar8;
  int iVar9;
  uchar *data;
  uchar *puVar10;
  bool bVar11;
  byte bVar12;
  int n [6];
  socklen_t local_24;
  uchar *local_20 [4];
  
  bVar12 = 0;
  __s = rb->data;
  data = (uchar *)&rb->field_0xf;
LAB_080ca4a3:
  pvVar2 = memchr(__s,10,rb->length);
  if (pvVar2 == (void *)0x0) {
    return 0;
  }
  piVar3 = __errno_location();
  *piVar3 = 0;
  uVar4 = strtoul((char *)__s,(char **)local_20,10);
  if (*piVar3 != 0) {
    return -1;
  }
  if ((int)uVar4 < 100) {
    return -1;
  }
  if (data != local_20[0]) {
    return -1;
  }
  if ((uVar4 != 0xe3) || (sa == (sockaddr_storage *)0x0)) {
    puVar6 = data;
    if ((uVar4 == 0xe5) && (sa != (sockaddr_storage *)0x0)) {
      local_24 = 0x1c;
      iVar7 = parse_psv_resp(data,n,0xffff);
      if (iVar7 != 1) {
        return -1;
      }
      uVar8 = 0;
      do {
        *(undefined4 *)((int)&sa->ss_family + uVar8) = 0;
        uVar8 = uVar8 + 4;
      } while (uVar8 < 0x1c);
      iVar7 = getpeername(conn->socket->fd,(sockaddr *)sa,&local_24);
      if (iVar7 != 0) {
        return -1;
      }
      sa->ss_family = 10;
      *(ushort *)&sa->field_0x2 = (ushort)n[5] >> 8 | (ushort)n[5] << 8;
      puVar6 = local_20[0];
    }
  }
  else {
    iVar7 = parse_psv_resp(data,n,0xff);
    if (iVar7 != 6) {
      return -1;
    }
    sa->__ss_align = 0;
    *(undefined4 *)sa->__ss_padding = 0;
    *(undefined4 *)(sa->__ss_padding + 4) = 0;
    sa->ss_family = 2;
    uVar8 = n[0] * 0x1000000 + n[1] * 0x10000 + n[3] + n[2] * 0x100;
    sa->__ss_align =
         uVar8 >> 0x18 | (uVar8 & 0xff0000) >> 8 | (uVar8 & 0xff00) << 8 | n[3] * 0x1000000;
    *(ushort *)&sa->field_0x2 = (short)(n[4] << 8) + (ushort)n[5] >> 8 | (ushort)n[5] * 0x100;
    puVar6 = local_20[0];
  }
  pvVar2 = (void *)((int)pvVar2 - (int)__s);
  if (*puVar6 == '-') {
    iVar7 = rb->length;
    if (iVar7 + -5 < 1) {
      return 0;
    }
    iVar5 = 0;
    do {
      if (rb->data[iVar5] == '\n') {
        iVar9 = 3;
        puVar6 = (uchar *)(&rb->field_0xd + iVar5);
        bVar11 = puVar6 == (uchar *)0x0;
        puVar10 = __s;
        do {
          if (iVar9 == 0) break;
          iVar9 = iVar9 + -1;
          bVar11 = *puVar6 == *puVar10;
          puVar6 = puVar6 + (uint)bVar12 * -2 + 1;
          puVar10 = puVar10 + (uint)bVar12 * -2 + 1;
        } while (bVar11);
        if ((bVar11) && (*(char *)((int)&rb[1].done + iVar5) == ' ')) goto code_r0x080ca5b7;
      }
      iVar5 = iVar5 + 1;
      if (iVar7 + -5 <= iVar5) {
        return 0;
      }
    } while( true );
  }
  goto LAB_080ca540;
code_r0x080ca5b7:
  pvVar2 = (void *)(iVar5 + 1);
  if (iVar7 <= (int)pvVar2) {
    return 0;
  }
  uVar1 = rb->data[(int)pvVar2];
  puVar6 = (uchar *)(&rb->field_0xe + iVar5);
  while (uVar1 != '\n') {
    pvVar2 = (void *)((int)pvVar2 + 1);
    if (iVar7 <= (int)pvVar2) {
      return 0;
    }
    uVar1 = *puVar6;
    puVar6 = puVar6 + 1;
  }
LAB_080ca540:
  if (part == 2) {
    return uVar4;
  }
  kill_buffer_data(rb,(int)pvVar2 + 1);
  if (part != 0) {
    return uVar4;
  }
  if (199 < (int)uVar4) {
    return uVar4;
  }
  goto LAB_080ca4a3;
}



void __regparm3 ftp_end_request(connection *conn)

{
  undefined4 in_ECX;
  int in_EDX;
  
  if ((in_EDX == -100000) && (conn->cached != (cache_entry *)0x0)) {
    normalize_cache_entry(conn->cached,conn->from);
  }
  set_connection_state(conn,(connection_state)CONCAT44(in_ECX,in_EDX));
  add_keepalive_connection(conn,600000,(anon_subr_void_connection_ptr_for_done *)0x0);
  return;
}



void ftp_data_accept(connection *conn)

{
  void *pvVar1;
  byte bVar2;
  socket *psVar3;
  int fd;
  int *piVar4;
  
  pvVar1 = conn->info;
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = -(conn->data_socket->fd >> 0x1f);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/ftp.c";
    errline = 0x581;
    elinks_internal((uchar *)"assertion conn->data_socket->fd >= 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  set_connection_timeout(conn);
  set_handlers(conn->data_socket->fd,(select_handler_T *)0x0,(select_handler_T *)0x0,
               (select_handler_T *)0x0,(void *)0x0);
  if ((*(byte *)&conn->socket->field_0x24 & 1) == 0) {
    bVar2 = *(byte *)((int)pvVar1 + 0x10) & 4;
  }
  else {
    bVar2 = *(byte *)((int)pvVar1 + 0x10) & 8;
  }
  if (bVar2 == 0) {
    fd = accept(conn->data_socket->fd,(sockaddr *)0x0,(socklen_t *)0x0);
    if (fd < 0) {
      piVar4 = __errno_location();
      retry_connection(conn,(connection_state)CONCAT44(*piVar4,0xffffffff));
      return;
    }
    close(conn->data_socket->fd);
    psVar3 = conn->data_socket;
  }
  else {
    psVar3 = conn->data_socket;
    fd = psVar3->fd;
  }
  psVar3->fd = fd;
  set_handlers(fd,got_something_from_data_connection,(select_handler_T *)0x0,(select_handler_T *)0x0
               ,conn);
  return;
}



// WARNING: Could not reconcile some variable overlaps

int __regparm3
display_dir_entry(cache_entry *cached,off_t *pos,int *tries,ftp_dir_html_format *format,
                 ftp_file_info *ftp_info)

{
  int iVar1;
  uint uVar2;
  string *psVar3;
  int iVar4;
  time_t tVar5;
  tm *__tp;
  size_t len;
  char *__format;
  int in_GS_OFFSET;
  string string;
  time_t local_80;
  uchar date [80];
  uchar permissions [10];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  permissions._0_4_ = 0x2d2d2d2d;
  permissions._4_4_ = 0x2d2d2d2d;
  permissions[8] = '-';
  permissions[9] = '\0';
  psVar3 = init_string(&string);
  iVar4 = -1;
  if (psVar3 == (string *)0x0) goto LAB_080cab4b;
  add_char_to_string(&string,*(uchar *)&ftp_info->type);
  uVar2 = ftp_info->permissions;
  if (uVar2 != 0) {
    if ((uVar2 & 0x100) != 0) {
      permissions._0_4_ = CONCAT31(permissions._1_3_,0x72);
    }
    if ((char)uVar2 < '\0') {
      permissions._0_2_ = CONCAT11(0x77,permissions[0]);
      permissions._0_4_ = permissions._0_4_ & 0xffff0000 | (uint)permissions._0_2_;
    }
    if ((uVar2 & 0x40) != 0) {
      permissions._0_3_ = CONCAT12(0x78,permissions._0_2_);
      permissions._0_4_ = permissions._0_4_ & 0xff000000 | (uint)permissions._0_3_;
    }
    if ((uVar2 & 0x800) != 0) {
      permissions._0_3_ = CONCAT12((-((uVar2 & 0x40) == 0) & 0xe0U) + 0x73,permissions._0_2_);
      permissions._0_4_ = permissions._0_4_ & 0xff000000 | (uint)permissions._0_3_;
    }
    if ((uVar2 & 0x20) != 0) {
      permissions._0_4_ = CONCAT13(0x72,permissions._0_3_);
    }
    if ((uVar2 & 0x10) != 0) {
      permissions._4_4_ = CONCAT31(permissions._5_3_,0x77);
    }
    if ((uVar2 & 8) != 0) {
      permissions._4_2_ = CONCAT11(0x78,permissions[4]);
      permissions._4_4_ = permissions._4_4_ & 0xffff0000 | (uint)permissions._4_2_;
    }
    if ((uVar2 & 0x400) != 0) {
      permissions._4_2_ = CONCAT11((-((uVar2 & 8) == 0) & 0xe0U) + 0x73,permissions[4]);
      permissions._4_4_ = permissions._4_4_ & 0xffff0000 | (uint)permissions._4_2_;
    }
    if ((uVar2 & 4) != 0) {
      permissions._4_3_ = CONCAT12(0x72,permissions._4_2_);
      permissions._4_4_ = permissions._4_4_ & 0xff000000 | (uint)permissions._4_3_;
    }
    if ((uVar2 & 2) != 0) {
      permissions._4_4_ = CONCAT13(0x77,permissions._4_3_);
    }
    if ((uVar2 & 1) != 0) {
      permissions[8] = 'x';
    }
    if ((uVar2 & 0x200) != 0) {
      permissions[8] = (-((uVar2 & 1) == 0) & 0xe0U) + 0x74;
    }
  }
  add_to_string(&string,permissions);
  add_char_to_string(&string,' ');
  add_to_string(&string,(uchar *)"   1 ftp      ftp ");
  uVar2 = *(uint *)((int)&ftp_info->size + 4);
  if ((*(uint *)&ftp_info->size & uVar2) == 0xffffffff) {
    add_to_string(&string,"           - ");
    if (ftp_info->mtime < 1) goto LAB_080cac6b;
LAB_080ca9b2:
    tVar5 = time((time_t *)0x0);
    local_80 = ftp_info->mtime;
    if ((*(byte *)&ftp_info->field_0x20 & 1) == 0) {
      __tp = gmtime(&local_80);
    }
    else {
      __tp = localtime(&local_80);
    }
    if ((local_80 + 0xed4e00 < tVar5) || (__format = "%b %e %H:%M", tVar5 < local_80 + -0xe10)) {
      __format = "%b %e  %Y";
    }
    len = strftime((char *)date,0x50,__format,__tp);
    add_cp_html_to_string(&string,format->libc_codepage,date,len);
  }
  else {
    add_format_to_string(&string,(uchar *)"%12lld ",*(uint *)&ftp_info->size,uVar2);
    if (0 < ftp_info->mtime) goto LAB_080ca9b2;
LAB_080cac6b:
    add_to_string(&string,"            ");
  }
  add_char_to_string(&string,' ');
  if ((ftp_info->type == FTP_FILE_DIRECTORY) && (format->colorize_dir != 0)) {
    add_to_string(&string,(uchar *)"<font color=\"");
    add_to_string(&string,format->dircolor);
    add_to_string(&string,(uchar *)"\"><b>");
  }
  add_to_string(&string,(uchar *)"<a href=\"");
  encode_uri_string(&string,(ftp_info->name).source,(ftp_info->name).length,0);
  if (ftp_info->type == FTP_FILE_DIRECTORY) {
    add_char_to_string(&string,'/');
  }
  add_to_string(&string,"\">");
  add_html_to_string(&string,(ftp_info->name).source,(ftp_info->name).length);
  add_to_string(&string,"</a>");
  if ((ftp_info->type == FTP_FILE_DIRECTORY) && (format->colorize_dir != 0)) {
    add_to_string(&string,(uchar *)"</b></font>");
  }
  if ((ftp_info->symlink).length != 0) {
    add_to_string(&string," -&gt; ");
    add_html_to_string(&string,(ftp_info->symlink).source,(ftp_info->symlink).length);
  }
  add_char_to_string(&string,'\n');
  iVar4 = add_fragment(cached,*pos,string.source,string.length);
  if (iVar4 != 0) {
    *tries = 0;
  }
  uVar2 = *(uint *)pos;
  *(int *)pos = *(int *)pos + string.length;
  *(int *)((int)pos + 4) =
       *(int *)((int)pos + 4) + (string.length >> 0x1f) + (uint)CARRY4(uVar2,string.length);
  done_string(&string);
  iVar4 = 0;
LAB_080cab4b:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return iVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int __regparm3
ftp_process_dirlist(cache_entry *cached,off_t *pos,uchar *buffer,int buflen,int last,int *tries,
                   ftp_dir_html_format *format)

{
  uint uVar1;
  void *pvVar2;
  ftp_file_info *pfVar3;
  int iVar4;
  string *psVar5;
  void *pvVar6;
  void *__n;
  int iVar7;
  void *pvVar8;
  uchar *src;
  ftp_file_info ftp_info;
  string string;
  
  iVar7 = 0;
  do {
    while( true ) {
      __n = (void *)(buflen - iVar7);
      if (__n == (void *)0x0) {
        return iVar7;
      }
      ftp_info._32_1_ = ftp_info._32_1_ & 0xfe;
      ftp_info.type = FTP_FILE_UNKNOWN;
      src = buffer + iVar7;
      ftp_info.name.source = "";
      ftp_info.name.length = 0;
      ftp_info.symlink.source = "";
      ftp_info.symlink.length = 0;
      ftp_info.size._0_4_ = 0xffffffff;
      ftp_info.size._4_4_ = 0xffffffff;
      ftp_info.mtime = 0;
      ftp_info.permissions = 0x1a4;
      pvVar2 = memchr(src,10,(size_t)__n);
      if (pvVar2 == (void *)0x0) {
        pvVar8 = __n;
        if (((int)__n < 0x4000) && (last == 0)) {
          return iVar7;
        }
      }
      else {
        pvVar6 = (void *)((int)pvVar2 - (int)src);
        __n = pvVar6;
        if (pvVar6 == (void *)0x0) {
          pvVar8 = (void *)0x1;
        }
        else {
          pvVar8 = (void *)((int)pvVar6 + 1);
          if (*(char *)((int)pvVar2 + -1) == '\r') {
            __n = (void *)((int)pvVar6 + -1);
            pvVar8 = (void *)((int)pvVar6 + 1);
          }
        }
      }
      iVar7 = iVar7 + (int)pvVar8;
      pfVar3 = parse_ftp_file_info(&ftp_info,src,(int)__n);
      if (pfVar3 != (ftp_file_info *)0x0) break;
      psVar5 = init_string(&string);
      if ((((psVar5 == (string *)0x0) ||
           (psVar5 = add_html_to_string(&string,src,(int)__n), psVar5 == (string *)0x0)) ||
          (psVar5 = add_char_to_string(&string,'\n'), psVar5 == (string *)0x0)) ||
         (iVar4 = add_fragment(cached,*pos,string.source,string.length), iVar4 == -1)) {
        done_string(&string);
        return -1;
      }
      uVar1 = *(uint *)pos;
      *(int *)pos = *(int *)pos + string.length;
      *(int *)((int)pos + 4) =
           *(int *)((int)pos + 4) + (string.length >> 0x1f) + (uint)CARRY4(uVar1,string.length);
      if (iVar4 == 1) {
        *tries = 0;
      }
      done_string(&string);
    }
  } while (((*ftp_info.name.source == '.') &&
           ((ftp_info.name.length == 1 ||
            ((ftp_info.name.length == 2 && (ftp_info.name.source[1] == '.')))))) ||
          (iVar4 = display_dir_entry(cached,pos,tries,format,&ftp_info), -1 < iVar4));
  return iVar7;
}



void got_something_from_data_connection(connection *conn)

{
  off_t *poVar1;
  int iVar2;
  void *pvVar3;
  int __fd;
  uint uVar4;
  uint length;
  int *piVar5;
  int iVar6;
  uchar **ppuVar7;
  color_T *pcVar8;
  uchar *buffer;
  cache_entry *pcVar9;
  int iVar10;
  uchar *name;
  uchar *name_00;
  size_t __n;
  int in_GS_OFFSET;
  string local_74 [2];
  ftp_file_info ftp_info;
  string string;
  ftp_dir_html_format format;
  
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  pvVar3 = conn->info;
  if (assert_failed != 0) {
LAB_080cb036:
    assert_failed = 0;
    goto LAB_080caff0;
  }
  assert_failed = -(conn->data_socket->fd >> 0x1f);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/ftp.c";
    errline = 0x5aa;
    elinks_internal((uchar *)"assertion conn->data_socket->fd >= 0 failed!");
    if (assert_failed != 0) goto LAB_080cb036;
  }
  set_connection_timeout(conn);
  if (conn->cached == (cache_entry *)0x0) {
    pcVar9 = get_cache_entry(conn->uri);
    conn->cached = pcVar9;
    if (pcVar9 == (cache_entry *)0x0) {
LAB_080cb1fe:
      if (assert_failed == 0) {
        length = 0xfffe795c;
      }
      else {
        length = 0xfffe795d;
      }
      assert_failed = 0;
      abort_connection(conn,(connection_state)(ulonglong)length);
      goto LAB_080caff0;
    }
  }
  if ((*(byte *)((int)pvVar3 + 0x10) & 1) != 0) {
    format.libc_codepage = get_cp_index((uchar *)"System");
    ppuVar7 = (uchar **)get_opt_(config_options,name);
    format.colorize_dir = (int)*ppuVar7;
    if ((uchar *)format.colorize_dir != (uchar *)0x0) {
      pcVar8 = get_opt_(config_options,name_00);
      color_to_string(*pcVar8,format.dircolor);
    }
    if (((*(byte *)((int)pvVar3 + 0x10) & 1) != 0) &&
       ((*(uint *)((int)&conn->from + 4) | *(uint *)&conn->from) == 0)) {
      if (conn->uri->data == (uchar *)0x0) {
        connection_state((connection_basic_state)local_74);
        abort_connection(conn,(connection_state)CONCAT44(local_74[0].length,local_74[0].source));
        goto LAB_080caff0;
      }
      init_directory_listing(local_74,(uri *)&string);
      if (local_74[0].source != (uchar *)0xfffe7960) {
        abort_connection(conn,(connection_state)CONCAT44(local_74[0].length,local_74[0].source));
        goto LAB_080caff0;
      }
      add_fragment(conn->cached,conn->from,string.source,string.length);
      poVar1 = &conn->from;
      length = *(uint *)poVar1;
      *(uint *)poVar1 = *(uint *)poVar1 + string.length;
      piVar5 = (int *)((int)&conn->from + 4);
      *piVar5 = *piVar5 + (string.length >> 0x1f) + (uint)CARRY4(length,string.length);
      done_string((string *)(uri *)&string);
      if ((*(uint *)&conn->uri->field_0x30 & 0xffff00) != 0) {
        ftp_info._32_1_ = ftp_info._32_1_ & 0xfe;
        ftp_info.type = FTP_FILE_DIRECTORY;
        ftp_info.name.source = "..";
        ftp_info.name.length = 2;
        ftp_info.symlink.source = "";
        ftp_info.symlink.length = 0;
        ftp_info.size._0_4_ = 0xffffffff;
        ftp_info.size._4_4_ = 0xffffffff;
        ftp_info.mtime = 0;
        ftp_info.permissions = 0x1ed;
        display_dir_entry(conn->cached,&conn->from,&conn->tries,&format,&ftp_info);
      }
      pcVar9 = conn->cached;
      if (pcVar9->content_type != (uchar *)0x0) {
        mem_free(pcVar9->content_type);
        pcVar9 = conn->cached;
      }
      buffer = stracpy((uchar *)"text/html");
      pcVar9->content_type = buffer;
    }
  }
  iVar10 = *(int *)((int)pvVar3 + 0xc);
  buffer = (uchar *)((int)pvVar3 + 0x11);
  __fd = conn->data_socket->fd;
  do {
    length = read(__fd,buffer + iVar10,0x4000 - iVar10);
    if (length != 0xffffffff) {
      if (-1 < (int)length) {
        if (length == 0) {
          iVar10 = ftp_process_dirlist(conn->cached,&conn->from,buffer,*(int *)((int)pvVar3 + 0xc),1
                                       ,&conn->tries,&format);
          if (iVar10 == -1) goto LAB_080cb1fe;
          if ((*(byte *)((int)pvVar3 + 0x10) & 1) != 0) {
            add_fragment(conn->cached,conn->from,(uchar *)"</pre>\n<hr/>\n</body>\n</html>",0x1c);
            poVar1 = &conn->from;
            length = *(uint *)poVar1;
            *(uint *)poVar1 = *(uint *)poVar1 + 0x1c;
            piVar5 = (int *)((int)&conn->from + 4);
            *piVar5 = *piVar5 + (uint)(0xffffffe3 < length);
          }
          close_socket(conn->data_socket);
          if (*(int *)((int)pvVar3 + 8) == 1) {
            connection_state((connection_basic_state)local_74);
            ftp_end_request(conn);
          }
          else {
            *(undefined4 *)((int)pvVar3 + 8) = 2;
            connection_state((connection_basic_state)local_74);
            set_connection_state
                      (conn,(connection_state)CONCAT44(local_74[0].length,local_74[0].source));
          }
        }
        else {
          poVar1 = &conn->received;
          uVar4 = *(uint *)poVar1;
          *(uint *)poVar1 = *(uint *)poVar1 + length;
          piVar5 = (int *)((int)&conn->received + 4);
          *piVar5 = *piVar5 + ((int)length >> 0x1f) + (uint)CARRY4(uVar4,length);
          if ((*(byte *)((int)pvVar3 + 0x10) & 1) == 0) {
            iVar10 = add_fragment(conn->cached,conn->from,buffer,length);
            if (iVar10 == 1) {
              conn->tries = 0;
            }
            poVar1 = &conn->from;
            uVar4 = *(uint *)poVar1;
            *(uint *)poVar1 = *(uint *)poVar1 + length;
            piVar5 = (int *)((int)&conn->from + 4);
            *piVar5 = *piVar5 + ((int)length >> 0x1f) + (uint)CARRY4(uVar4,length);
            if (assert_failed == 0) goto LAB_080cb2bf;
LAB_080cb349:
            length = 0xfffe795d;
          }
          else {
            iVar10 = ftp_process_dirlist(conn->cached,&conn->from,buffer,
                                         *(int *)((int)pvVar3 + 0xc) + length,0,&conn->tries,&format
                                        );
            if (iVar10 == -1) goto LAB_080cb1fe;
            __n = (length + *(int *)((int)pvVar3 + 0xc)) - iVar10;
            *(size_t *)((int)pvVar3 + 0xc) = __n;
            memmove(buffer,buffer + iVar10,__n);
            if (assert_failed != 0) goto LAB_080cb349;
LAB_080cb2bf:
            length = 8;
          }
          assert_failed = 0;
          set_connection_state(conn,(connection_state)(ulonglong)length);
        }
        goto LAB_080caff0;
      }
      piVar5 = __errno_location();
      iVar6 = *piVar5;
      break;
    }
    piVar5 = __errno_location();
    iVar6 = *piVar5;
  } while (iVar6 == 4);
  retry_connection(conn,(connection_state)CONCAT44(iVar6,0xffffffff));
LAB_080caff0:
  if (iVar2 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void __regparm3 ftp_send_retr_req(connection *conn)

{
  uchar *source;
  int iVar1;
  byte bVar2;
  socket *ctrl_socket;
  uri *puVar3;
  string *psVar4;
  char *__s;
  size_t sVar5;
  int *p;
  option_value *poVar6;
  uint *puVar7;
  int iVar8;
  void *pvVar9;
  uint size;
  char *pcVar10;
  uint uVar11;
  uchar *puVar12;
  undefined4 in_ECX;
  char *__n;
  undefined4 in_EDX;
  uchar *name;
  sockaddr_storage *psVar13;
  int in_GS_OFFSET;
  byte bVar14;
  string *local_118;
  string *local_110;
  string *local_10c;
  undefined4 local_104;
  undefined4 local_100;
  string pathname;
  string ftp_data_command;
  string command;
  string cmd;
  uchar pc [6];
  sockaddr_storage data_addr;
  sockaddr_in sa;
  
  bVar14 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  psVar4 = init_string(&cmd);
  if (psVar4 == (string *)0x0) {
    connection_state((connection_basic_state)&local_104);
    abort_connection(conn,(connection_state)CONCAT44(local_100,local_104));
    goto LAB_080cb5bf;
  }
  pvVar9 = conn->info;
  if (pvVar9 == (void *)0x0) {
    command.source = (uchar *)0x0;
    command.length = 0;
    ftp_data_command.source = (uchar *)0x0;
    ftp_data_command.length = 0;
    pathname.source = (uchar *)0x0;
    pathname.length = 0;
    if (conn->uri->data == (uchar *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/ftp.c";
      errline = 0x2a8;
      elinks_internal((uchar *)"conn->uri->data empty");
      assert_failed = 0;
      abort_connection(conn,(connection_state)0xfffe795d);
    }
    else {
      p = (int *)mem_calloc(1,0x4014);
      if (p == (int *)0x0) {
        if (assert_failed == 0) {
          size = 0xfffe795c;
        }
        else {
          size = 0xfffe795d;
        }
        assert_failed = 0;
        abort_connection(conn,(connection_state)(ulonglong)size);
      }
      else {
        *(int **)&conn->info = p;
        psVar4 = init_string(&command);
        if (psVar4 != (string *)0x0) {
          psVar4 = init_string(&ftp_data_command);
          if ((psVar4 != (string *)0x0) &&
             (psVar4 = init_string(&pathname), psVar4 != (string *)0x0)) {
            pvVar9 = conn->info;
            poVar6 = get_opt_(config_options,(uchar *)0x0);
            *(byte *)((int)pvVar9 + 0x10) =
                 *(byte *)((int)pvVar9 + 0x10) & 0xfb | ((byte)*poVar6 & 1) * '\x04';
            puVar7 = get_opt_(config_options,name);
            size = (*puVar7 & 1) * 8;
            bVar2 = *(byte *)((int)pvVar9 + 0x10);
            *(byte *)((int)pvVar9 + 0x10) = bVar2 & 0xf7 | (byte)size;
            ctrl_socket = conn->socket;
            if ((*(byte *)&ctrl_socket->field_0x24 & 1) == 0) {
              if ((bVar2 & 4) == 0) {
                iVar8 = get_pasv_socket(ctrl_socket,(sockaddr_storage *)&sa);
                if (iVar8 < 0) goto LAB_080cc0df;
                conn->data_socket->fd = iVar8;
                add_to_string(&ftp_data_command,(uchar *)"PORT ");
                add_long_to_string(&ftp_data_command,sa.sin_addr & 0xff);
                add_char_to_string(&ftp_data_command,',');
                add_long_to_string(&ftp_data_command,sa.sin_addr >> 8 & 0xff);
                add_char_to_string(&ftp_data_command,',');
                add_long_to_string(&ftp_data_command,sa.sin_addr >> 0x10 & 0xff);
                add_char_to_string(&ftp_data_command,',');
                add_long_to_string(&ftp_data_command,sa.sin_addr >> 0x18);
                add_char_to_string(&ftp_data_command,',');
                pc[4] = (uchar)sa.sin_port;
                add_long_to_string(&ftp_data_command,(uint)pc[4]);
                add_char_to_string(&ftp_data_command,',');
                pc[5] = (uchar)(sa.sin_port >> 8);
                add_long_to_string(&ftp_data_command,(uint)pc[5]);
              }
              else {
                add_to_string(&ftp_data_command,"PASV");
              }
            }
            else {
              if ((size & 8) == 0) {
                iVar8 = 0x20;
                psVar13 = &data_addr;
                while (iVar8 != 0) {
                  iVar8 = iVar8 + -1;
                  *(undefined4 *)psVar13 = 0;
                  psVar13 = (sockaddr_storage *)((int)psVar13 + (uint)bVar14 * -8 + 4);
                }
                iVar8 = get_pasv_socket(ctrl_socket,&data_addr);
                if (iVar8 < 0) {
LAB_080cc0df:
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/ftp.c";
                  errline = 0x2c2;
                  elinks_internal((uchar *)"Ftp data socket failure");
                  assert_failed = 0;
                  abort_connection(conn,(connection_state)0xfffe795d);
                  goto ret;
                }
                conn->data_socket->fd = iVar8;
                inet_ntop(10,data_addr.__ss_padding,(char *)&sa,0x2e);
                add_to_string(&ftp_data_command,"EPRT |2|");
                add_to_string(&ftp_data_command,(uchar *)&sa);
                add_char_to_string(&ftp_data_command,'|');
                add_long_to_string(&ftp_data_command,
                                   (uint)(ushort)(data_addr._2_2_ >> 8 | data_addr._2_2_ << 8));
                add_char_to_string(&ftp_data_command,'|');
              }
              else {
                add_to_string(&ftp_data_command,"EPSV");
              }
            }
            local_110 = &pathname;
            add_crlf_to_string(&ftp_data_command);
            psVar4 = add_uri_to_string(local_110,conn->uri,URI_PATH);
            if (psVar4 == (string *)0x0) {
LAB_080cc0a8:
              connection_state((connection_basic_state)&local_104);
              abort_connection(conn,(connection_state)CONCAT44(local_100,local_104));
            }
            else {
              decode_uri_string(local_110);
              if (pathname.length < 1) {
LAB_080cb826:
                puVar3 = conn->uri;
                if (((*(uint *)&puVar3->field_0x30 & 0xffff00) == 0) ||
                   (puVar3->data[(uint)*(ushort *)&puVar3->field_0x31 - 1] == '/')) {
                  *(byte *)(p + 4) = *(byte *)(p + 4) | 1;
                  *p = 4;
                  psVar4 = add_to_string(&command,(uchar *)"TYPE A");
                  if (((((psVar4 == (string *)0x0) ||
                        (psVar4 = add_crlf_to_string(&command), psVar4 == (string *)0x0)) ||
                       ((psVar4 = add_string_to_string(&command,&ftp_data_command),
                        psVar4 == (string *)0x0 ||
                        ((psVar4 = add_to_string(&command,"CWD "), psVar4 == (string *)0x0 ||
                         (psVar4 = add_string_to_string(&command,local_110), psVar4 == (string *)0x0
                         )))))) || (psVar4 = add_crlf_to_string(&command), psVar4 == (string *)0x0))
                     || ((psVar4 = add_to_string(&command,"LIST"), psVar4 == (string *)0x0 ||
                         (psVar4 = add_crlf_to_string(&command), psVar4 == (string *)0x0))))
                  goto LAB_080cbf78;
                  *(undefined4 *)&conn->from = 0;
                  *(undefined4 *)((int)&conn->from + 4) = 0;
                }
                else {
                  *(byte *)(p + 4) = *(byte *)(p + 4) & 0xfe;
                  *p = 3;
                  psVar4 = add_to_string(&command,(uchar *)"TYPE I");
                  if ((psVar4 == (string *)0x0) ||
                     ((psVar4 = add_crlf_to_string(&command), psVar4 == (string *)0x0 ||
                      (psVar4 = add_string_to_string(&command,&ftp_data_command),
                      psVar4 == (string *)0x0)))) goto LAB_080cc0a8;
                  size = *(uint *)&conn->from;
                  if ((*(uint *)((int)&conn->from + 4) | size) == 0) {
                    iVar8 = *(int *)((int)&conn->progress->start + 4);
                    size = *(uint *)&conn->progress->start;
                    if ((-1 < iVar8) && ((0 < iVar8 || (size != 0)))) goto LAB_080cb8d4;
                  }
                  else {
LAB_080cb8d4:
                    psVar4 = add_to_string(&command,(uchar *)"REST ");
                    if ((psVar4 == (string *)0x0) ||
                       ((psVar4 = add_long_to_string(&command,size), psVar4 == (string *)0x0 ||
                        (psVar4 = add_crlf_to_string(&command), psVar4 == (string *)0x0))))
                    goto LAB_080cc0a8;
                    *(byte *)(p + 4) = *(byte *)(p + 4) | 2;
                    *p = *p + 1;
                  }
                  psVar4 = add_to_string(&command,(uchar *)"RETR ");
                  if (((psVar4 == (string *)0x0) ||
                      (psVar4 = add_string_to_string(&command,local_110), psVar4 == (string *)0x0))
                     || (psVar4 = add_crlf_to_string(&command), psVar4 == (string *)0x0))
                  goto LAB_080cc0a8;
                }
                p[1] = *p;
                pvVar9 = mem_realloc(p,command.length + 0x4014);
                if (pvVar9 != (void *)0x0) {
                  conn->info = pvVar9;
                  memcpy((void *)((int)pvVar9 + 0x4011),command.source,command.length + 1);
                  done_string(local_110);
                  done_string(&ftp_data_command);
                  done_string(&command);
                  pvVar9 = conn->info;
                  goto LAB_080cb4db;
                }
              }
              else {
                if ((*pathname.source != '\n') && (iVar8 = 0, *pathname.source != '\r')) {
                  do {
                    iVar8 = iVar8 + 1;
                    if (pathname.length <= iVar8) goto LAB_080cb826;
                  } while ((pathname.source[iVar8] != '\r') && (pathname.source[iVar8] != '\n'));
                }
              }
LAB_080cbf78:
              connection_state((connection_basic_state)&local_104);
              abort_connection(conn,(connection_state)CONCAT44(local_100,local_104));
            }
            goto ret;
          }
        }
        if (assert_failed == 0) {
          size = 0xfffe795c;
        }
        else {
          size = 0xfffe795d;
        }
        assert_failed = 0;
        abort_connection(conn,(connection_state)(ulonglong)size);
      }
    }
ret:
    local_10c = &ftp_data_command;
    local_118 = &command;
    local_110 = &pathname;
    done_string(local_110);
    done_string(local_10c);
    done_string(local_118);
    done_string(&cmd);
    goto LAB_080cb5bf;
  }
LAB_080cb4db:
  source = (uchar *)((int)pvVar9 + 0x4011);
  __s = strchr((char *)source,10);
  if (__s == (char *)0x0) {
    add_to_string(&cmd,source);
  }
  else {
    __s = __s + 1;
    if (assert_failed == 0) {
      __n = __s + -(int)source;
      if ((source == (uchar *)0x0) || ((int)__n < 0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) goto LAB_080cb5e0;
      }
      else {
        assert_failed = 0;
      }
      if (__n != (char *)0x0) {
        pcVar10 = __n + cmd.length;
        size = (uint)(pcVar10 + 0x100) & 0xffffff00;
        uVar11 = cmd.length + 0xffU & 0xffffff00;
        if (uVar11 < size) {
          puVar12 = (uchar *)mem_realloc(cmd.source,size);
          if (puVar12 == (uchar *)0x0) goto LAB_080cb57b;
          cmd.source = puVar12;
          memset(puVar12 + uVar11,0,size - uVar11);
        }
        if (cmd.source != (uchar *)0x0) {
          memcpy(cmd.source + cmd.length,source,(size_t)__n);
          cmd.source[(int)pcVar10] = '\0';
          cmd.length = (int)pcVar10;
        }
      }
    }
    else {
LAB_080cb5e0:
      assert_failed = 0;
    }
LAB_080cb57b:
    sVar5 = strlen(__s);
    memmove(source,__s,sVar5 + 1);
  }
  send_cmd(conn,&cmd,ftp_retr_file,(connection_state)CONCAT44(in_ECX,in_EDX));
LAB_080cb5bf:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void ftp_protocol_handler(connection *conn)

{
  int iVar1;
  
  iVar1 = has_keepalive_connection(conn);
  if (iVar1 == 0) {
    make_connection(conn->socket,conn->uri,ftp_login,(uint)(2 < conn->cache_mode));
    return;
  }
  if (assert_failed != 0) {
    assert_failed = 0;
    ftp_send_retr_req(conn);
    return;
  }
  assert_failed = 0;
  ftp_send_retr_req(conn);
  return;
}



void ftp_got_final_response(socket *socket,read_buffer *rb)

{
  connection *conn;
  void *pvVar1;
  int iVar2;
  uri *puVar3;
  uint uVar4;
  cache_entry *cached;
  undefined4 uVar5;
  undefined4 local_24;
  undefined4 local_20;
  
  conn = (connection *)socket->conn;
  pvVar1 = conn->info;
  iVar2 = get_ftp_response(conn,rb,0,(sockaddr_storage *)0x0);
  if (iVar2 != -1) {
    if (iVar2 == 0) {
      if ((conn->state).basic == S_TRANS) {
        iVar2 = (conn->state).syserr;
        uVar5 = 8;
      }
      else {
        if (assert_failed == 0) {
          assert_failed = 0;
          uVar5 = 6;
          iVar2 = 0;
        }
        else {
          assert_failed = 0;
          uVar5 = 0xfffe795d;
          iVar2 = 0;
        }
      }
      read_from_socket(conn->socket,rb,(connection_state)CONCAT44(iVar2,uVar5),
                       ftp_got_final_response);
      return;
    }
    if ((iVar2 == 0x1c2) || (0x225 < iVar2)) {
      cached = conn->cached;
      if (cached == (cache_entry *)0x0) {
        cached = get_cache_entry(conn->uri);
        conn->cached = cached;
        if (cached == (cache_entry *)0x0) goto LAB_080cc390;
      }
      puVar3 = redirect_cache(cached,"/",1,0);
      if (puVar3 != (uri *)0x0) {
        if (assert_failed == 0) {
          uVar4 = 0xfffe7960;
        }
        else {
          uVar4 = 0xfffe795d;
        }
        assert_failed = 0;
        abort_connection(conn,(connection_state)(ulonglong)uVar4);
        return;
      }
    }
    else {
      if (iVar2 < 400) {
        if (*(int *)((int)pvVar1 + 8) == 2) {
          connection_state((connection_basic_state)&local_24);
          ftp_end_request(conn);
          return;
        }
        *(undefined4 *)((int)pvVar1 + 8) = 1;
        if ((conn->state).basic == S_TRANS) {
          return;
        }
        if (assert_failed == 0) {
          uVar4 = 6;
        }
        else {
          uVar4 = 0xfffe795d;
        }
        assert_failed = 0;
        set_connection_state(conn,(connection_state)(ulonglong)uVar4);
        return;
      }
    }
  }
LAB_080cc390:
  connection_state((connection_basic_state)&local_24);
  abort_connection(conn,(connection_state)CONCAT44(local_20,local_24));
  return;
}



void ftp_retr_file(socket *socket,read_buffer *rb)

{
  uchar *puVar1;
  off_t *poVar2;
  undefined uVar3;
  char cVar4;
  int iVar5;
  connection *conn;
  int fd;
  int iVar6;
  int iVar7;
  uint uVar8;
  progress *ppVar9;
  char *pcVar10;
  int *piVar11;
  undefined4 uVar12;
  uchar uVar13;
  uchar *__haystack;
  uchar *puVar14;
  undefined4 uVar15;
  int iVar16;
  int in_GS_OFFSET;
  bool bVar17;
  double dVar18;
  uint local_c4;
  int iStack192;
  undefined4 local_b4;
  undefined4 local_b0;
  uchar *local_a4;
  sockaddr_storage sa;
  
  iVar5 = *(int *)(in_GS_OFFSET + 0x14);
  conn = (connection *)socket->conn;
  piVar11 = (int *)conn->info;
  if (*piVar11 < 2) {
    fd = get_ftp_response(conn,rb,2,(sockaddr_storage *)0x0);
    if (fd == -1) goto LAB_080cc78b;
    if (fd == 0) {
      connection_state((connection_basic_state)&local_b4);
      read_from_socket(conn->socket,rb,(connection_state)CONCAT44(local_b0,local_b4),ftp_retr_file);
      goto LAB_080cc50e;
    }
    if (((99 < fd - 100U) || ((*(byte *)(piVar11 + 4) & 1) != 0)) ||
       ((*(uint *)&conn->est_length & *(uint *)((int)&conn->est_length + 4)) != 0xffffffff))
    goto LAB_080cc658;
    fd = rb->length;
    __haystack = rb->data;
    if ((fd < 1) || (uVar13 = rb->data[0], uVar13 == '\n')) {
LAB_080cc8aa:
      uVar3 = *(undefined *)((int)&rb->freespace + fd + 3);
      *(undefined *)((int)&rb->freespace + fd + 3) = 0;
      pcVar10 = strstr((char *)__haystack,"kbytes");
      *(undefined *)((int)&rb->freespace + fd + 3) = uVar3;
      if (pcVar10 != (char *)0x0) {
        puVar14 = (uchar *)(pcVar10 + -2);
        if (puVar14 < __haystack) {
LAB_080cc920:
          if (*puVar14 != ' ') goto LAB_080cc658;
        }
        else {
          uVar13 = pcVar10[-2];
          while (uVar13 != ' ') {
            puVar14 = puVar14 + -1;
            if (puVar14 < __haystack) goto LAB_080cc920;
            uVar13 = *puVar14;
          }
        }
        dVar18 = strtod((char *)(puVar14 + 1),(char **)&local_a4);
        if (puVar14 + 1 != local_a4) {
          bVar17 = true;
          local_c4 = (uint)(longlong)ROUND(dVar18 * 1024.00000000);
          iStack192 = (int)((ulonglong)(longlong)ROUND(dVar18 * 1024.00000000) >> 0x20);
          goto LAB_080cc989;
        }
      }
    }
    else {
      iVar6 = 0;
      iVar7 = 0;
      do {
        if (uVar13 == '(') {
          iVar6 = iVar7;
        }
        iVar7 = iVar7 + 1;
      } while ((iVar7 < fd) && (uVar13 = __haystack[iVar7], uVar13 != '\n'));
      if ((iVar6 == 0) || (iVar6 == fd + -1)) goto LAB_080cc8aa;
      iVar7 = iVar6 + 1;
      if ((9 < (byte)(*(char *)(&rb->field_0xd + iVar6) - 0x30U)) ||
         (puVar14 = rb->data + iVar6, iVar6 = iVar7, fd <= iVar7)) goto LAB_080cc658;
      do {
        iVar16 = iVar6;
        iVar6 = iVar16 + 1;
        if (fd <= iVar6) goto LAB_080cc658;
        puVar1 = puVar14 + 2;
        puVar14 = puVar14 + 1;
      } while ((byte)(*puVar1 - 0x30) < 10);
      cVar4 = *(char *)(&rb->field_0xd + iVar16);
      iVar16 = &rb->field_0xd + iVar16;
      while ((cVar4 == ' ' && (iVar6 = iVar6 + 1, iVar6 < fd))) {
        cVar4 = *(char *)(iVar16 + 1);
        iVar16 = iVar16 + 1;
      }
      if ((fd < iVar6 + 4) || (fd = c_strncasecmp((char *)(__haystack + iVar6),"byte",4), fd != 0))
      goto LAB_080cc658;
      piVar11 = __errno_location();
      *piVar11 = 0;
      local_c4 = strtol((char *)(__haystack + iVar7),(char **)0x0,10);
      if (*piVar11 != 0) goto LAB_080cc658;
      bVar17 = false;
      iStack192 = (int)local_c4 >> 0x1f;
LAB_080cc989:
      if ((-1 < iStack192) && ((0 < iStack192 || (local_c4 != 0)))) {
        if (bVar17) {
          poVar2 = &conn->progress->start;
          bVar17 = CARRY4(local_c4,*(uint *)poVar2);
          local_c4 = local_c4 + *(int *)poVar2;
          iStack192 = iStack192 + *(int *)((int)&conn->progress->start + 4) + (uint)bVar17;
        }
        *(uint *)&conn->est_length = local_c4;
        *(int *)((int)&conn->est_length + 4) = iStack192;
      }
    }
LAB_080cc658:
    fd = conn->data_socket->fd;
    if (fd != -1) {
      set_handlers(fd,ftp_data_accept,(select_handler_T *)0x0,(select_handler_T *)0x0,conn);
      ftp_got_final_response(socket,rb);
      goto LAB_080cc50e;
    }
  }
  else {
    fd = get_ftp_response(conn,rb,0,&sa);
    if (fd != -1) {
      if (fd == 0) {
        if (assert_failed == 0) {
          uVar8 = 6;
        }
        else {
          uVar8 = 0xfffe795d;
        }
        assert_failed = 0;
        read_from_socket(conn->socket,rb,(connection_state)(ulonglong)uVar8,ftp_retr_file);
        goto LAB_080cc50e;
      }
      if (fd == 0xe3) {
        iVar6 = ftp_data_connect(conn,2,&sa,0x10);
joined_r0x080cc6db:
        if (iVar6 != 0) goto LAB_080cc50e;
      }
      else {
        if (fd == 0xe5) {
          iVar6 = ftp_data_connect(conn,10,&sa,0x1c);
          goto joined_r0x080cc6db;
        }
      }
      iVar6 = piVar11[1] - (*piVar11 + -1);
      *piVar11 = *piVar11 + -1;
      if (iVar6 == 2) {
        if (399 < fd) goto LAB_080cc78b;
      }
      else {
        if (iVar6 == 3) {
          if (fd < 400) {
            if ((*(byte *)(piVar11 + 4) & 2) != 0) {
              if (fd == 0x15e) {
                ppVar9 = conn->progress;
                uVar15 = *(undefined4 *)&ppVar9->start;
                uVar12 = *(undefined4 *)((int)&ppVar9->start + 4);
                *(undefined4 *)&conn->from = uVar15;
                *(undefined4 *)((int)&conn->from + 4) = uVar12;
              }
              else {
                ppVar9 = conn->progress;
                uVar15 = *(undefined4 *)&conn->from;
                uVar12 = *(undefined4 *)((int)&conn->from + 4);
              }
              if (-1 < *(int *)((int)&ppVar9->start + 4)) {
                *(undefined4 *)&ppVar9->seek = uVar15;
                *(undefined4 *)((int)&ppVar9->seek + 4) = uVar12;
                ppVar9 = conn->progress;
                uVar15 = *(undefined4 *)&conn->from;
                uVar12 = *(undefined4 *)((int)&conn->from + 4);
              }
              *(undefined4 *)&ppVar9->start = uVar15;
              *(undefined4 *)((int)&ppVar9->start + 4) = uVar12;
            }
          }
          else {
            if ((*(byte *)(piVar11 + 4) & 1) != 0) goto LAB_080cc78b;
            *(undefined4 *)&conn->from = 0;
            *(undefined4 *)((int)&conn->from + 4) = 0;
          }
        }
        else {
          if (iVar6 != 1) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/ftp.c";
            errline = 0x3fa;
            elinks_internal((uchar *)"WHAT???");
          }
        }
      }
      assert_failed = 0;
      ftp_send_retr_req(conn);
      goto LAB_080cc50e;
    }
  }
LAB_080cc78b:
  connection_state((connection_basic_state)&local_b4);
  abort_connection(conn,(connection_state)CONCAT44(local_b0,local_b4));
LAB_080cc50e:
  if (iVar5 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void __regparm3 prompt_username_pw(connection *conn)

{
  uchar *puVar1;
  uint uVar2;
  cache_entry *pcVar3;
  undefined4 local_14;
  undefined4 local_10;
  
  pcVar3 = conn->cached;
  if (pcVar3 == (cache_entry *)0x0) {
    pcVar3 = get_cache_entry(conn->uri);
    conn->cached = pcVar3;
    if (pcVar3 == (cache_entry *)0x0) {
      connection_state((connection_basic_state)&local_14);
      abort_connection(conn,(connection_state)CONCAT44(local_10,local_14));
      return;
    }
  }
  if (pcVar3->content_type != (uchar *)0x0) {
    mem_free(pcVar3->content_type);
    pcVar3 = conn->cached;
  }
  puVar1 = stracpy((uchar *)"text/html");
  pcVar3->content_type = puVar1;
  if (conn->cached->content_type == (uchar *)0x0) {
    if (assert_failed == 0) {
      uVar2 = 0xfffe795c;
      goto LAB_080ccae3;
    }
  }
  else {
    add_auth_entry(conn->uri,(uchar *)"FTP Login",(uchar *)0x0,(uchar *)0x0,0);
    if (assert_failed == 0) {
      uVar2 = 0xfffe7960;
      goto LAB_080ccae3;
    }
  }
  uVar2 = 0xfffe795d;
LAB_080ccae3:
  assert_failed = 0;
  abort_connection(conn,(connection_state)(ulonglong)uVar2);
  return;
}



void ftp_pass_info(socket *socket,read_buffer *rb)

{
  connection *conn;
  int iVar1;
  uint uVar2;
  undefined4 local_14;
  undefined4 local_10;
  
  conn = (connection *)socket->conn;
  iVar1 = get_ftp_response(conn,rb,0,(sockaddr_storage *)0x0);
  if (iVar1 == -1) {
    connection_state((connection_basic_state)&local_14);
    abort_connection(conn,(connection_state)CONCAT44(local_10,local_14));
  }
  else {
    if (iVar1 == 0) {
      if (assert_failed == 0) {
        uVar2 = 5;
      }
      else {
        uVar2 = 0xfffe795d;
      }
      assert_failed = 0;
      read_from_socket(conn->socket,rb,(connection_state)(ulonglong)uVar2,ftp_pass_info);
      return;
    }
    if ((499 < iVar1) || (iVar1 == 0x14c)) {
      prompt_username_pw(conn);
      return;
    }
    if (iVar1 < 400) {
      if (assert_failed != 0) {
        assert_failed = 0;
        ftp_send_retr_req(conn);
        return;
      }
      assert_failed = 0;
      ftp_send_retr_req(conn);
      return;
    }
    if (assert_failed == 0) {
      uVar2 = 0xfffe7833;
    }
    else {
      uVar2 = 0xfffe795d;
    }
    assert_failed = 0;
    abort_connection(conn,(connection_state)(ulonglong)uVar2);
  }
  return;
}



void ftp_login(socket *socket)

{
  ushort uVar1;
  connection *conn;
  uchar *__src;
  auth_entry *paVar2;
  string *psVar3;
  uint uVar4;
  uchar *puVar5;
  int iVar6;
  uint size;
  string cmd;
  
  conn = (connection *)socket->conn;
  paVar2 = find_auth(conn->uri);
  psVar3 = init_string(&cmd);
  if (psVar3 == (string *)0x0) {
    if (assert_failed == 0) {
      uVar4 = 0xfffe795c;
    }
    else {
      uVar4 = 0xfffe795d;
    }
    assert_failed = 0;
    abort_connection(conn,(connection_state)(ulonglong)uVar4);
    return;
  }
  add_to_string(&cmd,(uchar *)"USER ");
  uVar1 = *(ushort *)&conn->uri->field_0x2a;
  if (uVar1 == 0) {
    if ((paVar2 == (auth_entry *)0x0) || ((*(byte *)&paVar2->field_0x70 & 2) == 0)) {
      add_to_string(&cmd,(uchar *)"anonymous");
    }
    else {
      add_to_string(&cmd,paVar2->user);
    }
    goto LAB_080ccd69;
  }
  __src = conn->uri->user;
  if (assert_failed == 0) {
    if (__src == (uchar *)0x0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080ccee8;
    }
    else {
      assert_failed = 0;
    }
    iVar6 = (uint)uVar1 + cmd.length;
    uVar4 = cmd.length + 0xffU & 0xffffff00;
    size = iVar6 + 0x100U & 0xffffff00;
    if (uVar4 < size) {
      puVar5 = (uchar *)mem_realloc(cmd.source,size);
      if (puVar5 == (uchar *)0x0) goto LAB_080ccd69;
      cmd.source = puVar5;
      memset(puVar5 + uVar4,0,size - uVar4);
    }
    if (cmd.source != (uchar *)0x0) {
      memcpy(cmd.source + cmd.length,__src,(uint)uVar1);
      cmd.source[iVar6] = '\0';
      cmd.length = iVar6;
    }
  }
  else {
LAB_080ccee8:
    assert_failed = 0;
  }
LAB_080ccd69:
  add_crlf_to_string(&cmd);
  if (assert_failed == 0) {
    uVar4 = 4;
  }
  else {
    uVar4 = 0xfffe795d;
  }
  assert_failed = 0;
  send_cmd(conn,&cmd,ftp_got_info,(connection_state)(ulonglong)uVar4);
  return;
}



void ftp_got_user_info(socket *socket,read_buffer *rb)

{
  connection *conn;
  uri *puVar1;
  uchar *__src;
  int iVar2;
  auth_entry *paVar3;
  string *psVar4;
  uchar **ppuVar5;
  uint uVar6;
  uchar *puVar7;
  uchar *puVar8;
  uchar *name;
  uint size;
  undefined4 local_34;
  undefined4 local_30;
  string cmd;
  
  conn = (connection *)socket->conn;
  iVar2 = get_ftp_response(conn,rb,0,(sockaddr_storage *)0x0);
  if (iVar2 == -1) {
    connection_state((connection_basic_state)&local_34);
    abort_connection(conn,(connection_state)CONCAT44(local_30,local_34));
    return;
  }
  if (iVar2 == 0) {
    read_from_socket(conn->socket,rb,conn->state,ftp_got_user_info);
    return;
  }
  if ((499 < iVar2) || (iVar2 == 0x14c)) {
LAB_080cd0d0:
    prompt_username_pw(conn);
    return;
  }
  if (iVar2 < 400) {
    if (iVar2 == 0xe6) {
      connection_state((connection_basic_state)&local_34);
      ftp_send_retr_req(conn);
      return;
    }
    paVar3 = find_auth(conn->uri);
    psVar4 = init_string(&cmd);
    if (psVar4 != (string *)0x0) {
      add_to_string(&cmd,(uchar *)"PASS ");
      puVar1 = conn->uri;
      name = (uchar *)(uint)*(ushort *)&puVar1->field_0x2c;
      if (*(ushort *)&puVar1->field_0x2c == 0) {
        if ((paVar3 == (auth_entry *)0x0) || ((*(byte *)&paVar3->field_0x70 & 2) == 0)) {
          ppuVar5 = (uchar **)get_opt_(config_options,name);
          add_to_string(&cmd,*ppuVar5);
        }
        else {
          if (*(short *)&puVar1->field_0x2a != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/ftp.c";
            errline = 0x12f;
            iVar2 = elinks_strlcasecmp(paVar3->user,0xffffffff,puVar1->user,
                                       (uint)*(ushort *)&puVar1->field_0x2a,1);
            if (iVar2 != 0) goto LAB_080cd0d0;
          }
          add_to_string(&cmd,paVar3->password);
        }
        goto LAB_080cd047;
      }
      __src = puVar1->password;
      if (assert_failed == 0) {
        if (__src == (uchar *)0x0) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_080cd2b8;
        }
        else {
          assert_failed = 0;
        }
        puVar8 = name + cmd.length;
        uVar6 = cmd.length + 0xffU & 0xffffff00;
        size = (uint)(puVar8 + 0x100) & 0xffffff00;
        if (uVar6 < size) {
          puVar7 = (uchar *)mem_realloc(cmd.source,size);
          if (puVar7 == (uchar *)0x0) goto LAB_080cd047;
          cmd.source = puVar7;
          memset(puVar7 + uVar6,0,size - uVar6);
        }
        if (cmd.source != (uchar *)0x0) {
          memcpy(cmd.source + cmd.length,__src,(size_t)name);
          cmd.source[(int)puVar8] = '\0';
          cmd.length = (int)puVar8;
        }
      }
      else {
LAB_080cd2b8:
        assert_failed = 0;
      }
LAB_080cd047:
      add_crlf_to_string(&cmd);
      if (assert_failed == 0) {
        uVar6 = 5;
      }
      else {
        uVar6 = 0xfffe795d;
      }
      assert_failed = 0;
      send_cmd(conn,&cmd,ftp_pass_info,(connection_state)(ulonglong)uVar6);
      return;
    }
    if (assert_failed == 0) {
      uVar6 = 0xfffe795c;
      goto LAB_080cd105;
    }
  }
  else {
    if (assert_failed == 0) {
      uVar6 = 0xfffe7833;
      goto LAB_080cd105;
    }
  }
  uVar6 = 0xfffe795d;
LAB_080cd105:
  assert_failed = 0;
  abort_connection(conn,(connection_state)(ulonglong)uVar6);
  return;
}



void ftp_got_info(socket *socket,read_buffer *rb)

{
  connection *conn;
  int iVar1;
  uint uVar2;
  undefined4 local_24;
  undefined4 local_20;
  
  conn = (connection *)socket->conn;
  iVar1 = get_ftp_response(conn,rb,0,(sockaddr_storage *)0x0);
  if (iVar1 == -1) {
    connection_state((connection_basic_state)&local_24);
    abort_connection(conn,(connection_state)CONCAT44(local_20,local_24));
  }
  else {
    if (iVar1 == 0) {
      read_from_socket(conn->socket,rb,conn->state,ftp_got_info);
    }
    else {
      if (iVar1 == 0xdc) {
        ftp_got_user_info(socket,rb);
        return;
      }
      if (assert_failed == 0) {
        uVar2 = 0xfffe7833;
      }
      else {
        uVar2 = 0xfffe795d;
      }
      assert_failed = 0;
      retry_connection(conn,(connection_state)(ulonglong)uVar2);
    }
  }
  return;
}



ftp_file_info * parse_ftp_winnt_response(ftp_file_info *info,uchar *src,int len)

{
  byte *end;
  byte bVar1;
  uchar uVar2;
  ulonglong uVar3;
  uchar *puVar4;
  uint uVar5;
  uint uVar6;
  time_t tVar7;
  int iVar8;
  tm *ptVar9;
  uint local_6c;
  int local_68;
  tm mtime;
  
  if (len < 0x28) {
    return (ftp_file_info *)0x0;
  }
  end = src + len;
  iVar8 = 0xb;
  (info->name).source = src + 0x27;
  *(byte **)&(info->name).length = end + (-0x27 - (int)src);
  ptVar9 = &mtime;
  while (iVar8 != 0) {
    iVar8 = iVar8 + -1;
    ptVar9->tm_sec = 0;
    ptVar9 = (tm *)&ptVar9->tm_min;
  }
  mtime.tm_isdst = -1;
  if ((src < end) && (bVar1 = *src, (byte)(bVar1 - 0x30) < 10)) {
    local_6c = 0;
    local_68 = 0;
    do {
      uVar3 = (ulonglong)local_6c;
      uVar5 = (uint)(uVar3 * 10);
      uVar6 = (uint)bVar1 - 0x30;
      local_6c = uVar6 + uVar5;
      local_68 = ((int)uVar6 >> 0x1f) + (int)(uVar3 * 10 >> 0x20) + local_68 * 10 +
                 (uint)CARRY4(uVar6,uVar5);
      src = src + 1;
      if (end <= src) break;
      bVar1 = *src;
    } while ((byte)(bVar1 - 0x30) < 10);
    if (((0 < local_68) || ((-1 < local_68 && (0xc < local_6c)))) ||
       ((local_68 < 1 && ((local_68 < 0 || (local_6c == 0)))))) {
      local_6c = 0xffffffff;
    }
  }
  else {
    local_6c = 0xffffffff;
  }
  if (end <= src + 2) {
    return (ftp_file_info *)0x0;
  }
  if (*src != 0x2d) {
    return (ftp_file_info *)0x0;
  }
  src = src + 1;
  mtime.tm_mon = local_6c;
  mtime.tm_mday = parse_day(&src,end);
  if (end <= src + 2) {
    return (ftp_file_info *)0x0;
  }
  if (*src != '-') {
    return (ftp_file_info *)0x0;
  }
  src = src + 1;
  mtime.tm_year = parse_year(&src,end);
  if (end <= src) {
    return (ftp_file_info *)0x0;
  }
  if (mtime.tm_year == -1) {
    return (ftp_file_info *)0x0;
  }
  while (*src == ' ') {
    src = src + 1;
    if (end <= src) {
      return (ftp_file_info *)0x0;
    }
  }
  iVar8 = parse_time(&src,&mtime,end);
  if (iVar8 == 0) {
    return (ftp_file_info *)0x0;
  }
  tVar7 = mktime((tm *)&mtime);
  info->mtime = tVar7;
  do {
    puVar4 = src;
    if (end <= src) break;
    uVar2 = *src;
    src = src + 1;
  } while (uVar2 != ' ');
  do {
    src = puVar4;
    if (end <= src) {
      return (ftp_file_info *)0x0;
    }
    uVar2 = *src;
    puVar4 = src + 1;
  } while (uVar2 == ' ');
  if (uVar2 == '<') {
    info->type = FTP_FILE_DIRECTORY;
    info->permissions = 0x1ed;
  }
  else {
    if ((byte)(uVar2 - 0x30) < 10) {
      info->type = FTP_FILE_PLAINFILE;
      local_6c = 0;
      local_68 = 0;
      while ((src < end && ((byte)(*src - 0x30) < 10))) {
        uVar3 = (ulonglong)local_6c;
        uVar5 = (uint)(uVar3 * 10);
        uVar6 = (uint)*src - 0x30;
        local_6c = uVar6 + uVar5;
        local_68 = ((int)uVar6 >> 0x1f) + (int)(uVar3 * 10 >> 0x20) + local_68 * 10 +
                   (uint)CARRY4(uVar6,uVar5);
        src = src + 1;
      }
      if (local_68 < 0) {
        local_6c = 0xffffffff;
        local_68 = -1;
      }
      *(uint *)&info->size = local_6c;
      *(int *)((int)&info->size + 4) = local_68;
      info->permissions = 0x1a4;
    }
    else {
      info->type = FTP_FILE_UNKNOWN;
    }
  }
  return info;
}



// WARNING: Type propagation algorithm not settling

ftp_file_info * parse_ftp_file_info(ftp_file_info *info,uchar *src,int len)

{
  ftp_file_type fVar1;
  ulonglong uVar2;
  void *pvVar3;
  time_t tVar4;
  uint uVar5;
  ftp_file_info *pfVar6;
  tm *ptVar7;
  time_t tVar8;
  uint uVar9;
  byte bVar10;
  byte *__s;
  int iVar11;
  byte *end;
  byte *end_00;
  byte *pbVar12;
  tm *ptVar13;
  byte *pbVar14;
  bool bVar15;
  byte bVar16;
  uint local_8c;
  int local_88;
  undefined4 local_68;
  uint local_64;
  tm mtime;
  time_t local_24;
  byte *local_20 [4];
  
  bVar16 = 0;
  if (assert_failed != 0) {
    assert_failed = 0;
    return (ftp_file_info *)0x0;
  }
  if (((src == (uchar *)0x0) || (info == (ftp_file_info *)0x0)) || (len < 1)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/parse.c";
    errline = 0x25d;
    elinks_internal((uchar *)"assertion info && src && len > 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (ftp_file_info *)0;
    }
    bVar10 = *src;
    if (bVar10 < 0x65) goto LAB_080cd798;
LAB_080cd850:
    if (((bVar10 == 0x70) || (bVar10 == 0x73)) || (bVar10 == 0x6c)) goto LAB_080cd868;
  }
  else {
    assert_failed = 0;
    bVar10 = *src;
    if (100 < bVar10) goto LAB_080cd850;
LAB_080cd798:
    if (0x61 < bVar10) goto LAB_080cd868;
    if (bVar10 == 0x2b) {
      end = src + len;
      end_00 = src + 1;
      if (end <= end_00) {
        return (ftp_file_info *)0x0;
      }
      do {
        __s = (byte *)memchr(end_00,0x2c,(size_t)(end + -(int)end_00));
        bVar16 = *end_00;
        end_00 = end_00 + 1;
        if (__s == (byte *)0x0) {
          __s = end;
        }
        if (bVar16 == 0x72) {
          info->type = FTP_FILE_PLAINFILE;
        }
        else {
          if (bVar16 < 0x73) {
            if (bVar16 == 0x6d) {
              if (end_00 < __s) {
                bVar16 = *end_00;
                local_64 = 0;
                if ((byte)(bVar16 - 0x30) < 10) {
                  local_8c = 0;
                  local_88 = 0;
                  do {
                    uVar9 = (uint)((ulonglong)local_8c * 10);
                    uVar5 = (uint)bVar16 - 0x30;
                    local_64 = uVar5 + uVar9;
                    local_88 = ((int)uVar5 >> 0x1f) +
                               (int)((ulonglong)local_8c * 10 >> 0x20) + local_88 * 10 +
                               (uint)CARRY4(uVar5,uVar9);
                    end_00 = end_00 + 1;
                    if (__s <= end_00) break;
                    bVar16 = *end_00;
                    local_8c = local_64;
                  } while ((byte)(bVar16 - 0x30) < 10);
                  if (((0 < local_88) || (local_88 < 0)) ||
                     ((0x7fffffff < local_64 || (local_88 < 0)))) {
                    local_64 = 0xffffffff;
                  }
                }
                info->mtime = local_64;
              }
            }
            else {
              if (bVar16 < 0x6e) {
                if (bVar16 == 9) {
                  if (end_00 < end) {
                    (info->name).source = end_00;
                    *(byte **)&(info->name).length = end + -(int)end_00;
                    return info;
                  }
                }
                else {
                  if (bVar16 == 0x2f) {
                    info->type = FTP_FILE_DIRECTORY;
                  }
                }
              }
            }
          }
          else {
            if ((bVar16 == 0x73) && (end_00 < __s)) {
              bVar16 = *end_00;
              local_8c = 0;
              local_88 = 0;
              if ((byte)(bVar16 - 0x30) < 10) {
                do {
                  uVar2 = (ulonglong)local_8c;
                  uVar9 = (uint)(uVar2 * 10);
                  uVar5 = (uint)bVar16 - 0x30;
                  local_8c = uVar5 + uVar9;
                  local_88 = ((int)uVar5 >> 0x1f) + (int)(uVar2 * 10 >> 0x20) + local_88 * 10 +
                             (uint)CARRY4(uVar5,uVar9);
                  end_00 = end_00 + 1;
                  if (__s <= end_00) break;
                  bVar16 = *end_00;
                } while ((byte)(bVar16 - 0x30) < 10);
                if (local_88 < 0) {
                  local_8c = 0xffffffff;
                  local_88 = -1;
                }
              }
              *(uint *)&info->size = local_8c;
              *(int *)((int)&info->size + 4) = local_88;
            }
          }
        }
        end_00 = __s + 1;
        if (end <= end_00) {
          return (ftp_file_info *)0x0;
        }
        if (__s == (byte *)0x0) {
          return (ftp_file_info *)0x0;
        }
      } while( true );
    }
    if (bVar10 == 0x2d) goto LAB_080cd868;
  }
  pvVar3 = memchr(src,0x3b,len);
  if (pvVar3 == (void *)0x0) {
    if ((byte)(bVar10 - 0x30) < 10) {
      pfVar6 = parse_ftp_winnt_response(info,src,len);
      return pfVar6;
    }
LAB_080cd868:
    end_00 = src + len;
    end = src + 1;
    if (((bVar10 == 100) || (bVar10 == 0x6c)) || (bVar10 == 0x2d)) {
      info->type = (uint)bVar10;
    }
    else {
      info->type = FTP_FILE_UNKNOWN;
    }
    iVar11 = 0xb;
    local_68 = 0;
    ptVar13 = &mtime;
    while (iVar11 != 0) {
      iVar11 = iVar11 + -1;
      ptVar13->tm_sec = 0;
      ptVar13 = (tm *)((int)ptVar13 + (uint)bVar16 * -8 + 4);
    }
    mtime.tm_isdst = -1;
    local_20[0] = end;
    if (end_00 <= end) {
      return (ftp_file_info *)0x0;
    }
    do {
      while ((end < end_00 && (*end != 0x20))) {
        end = end + 1;
      }
      switch(local_68) {
      case 0:
        local_68 = 1;
        if (end + -(int)local_20[0] == &DAT_00000009) {
          if (*local_20[0] == 0x2d) {
            uVar9 = 0;
LAB_080ce024:
            if (local_20[0][1] != 0x2d) {
              if (local_20[0][1] != 0x77) goto LAB_080cd9c2;
              uVar9 = uVar9 | 0x80;
            }
            bVar10 = local_20[0][2];
            if (bVar10 == 0x73) {
              uVar9 = uVar9 | 0x800;
LAB_080ce1a8:
              uVar9 = uVar9 | 0x40;
            }
            else {
              if (0x73 < bVar10) {
                if (bVar10 != 0x78) goto LAB_080cd9c2;
                goto LAB_080ce1a8;
              }
              if (bVar10 != 0x2d) {
                if (bVar10 != 0x53) goto LAB_080cd9c2;
                uVar9 = uVar9 | 0x800;
              }
            }
            if (local_20[0][3] != 0x2d) {
              if (local_20[0][3] != 0x72) goto LAB_080cd9c2;
              uVar9 = uVar9 | 0x20;
            }
            if (local_20[0][4] != 0x2d) {
              if (local_20[0][4] != 0x77) goto LAB_080cd9c2;
              uVar9 = uVar9 | 0x10;
            }
            bVar10 = local_20[0][5];
            if (bVar10 == 0x73) {
              uVar9 = uVar9 | 0x400;
LAB_080ce1bd:
              uVar9 = uVar9 | 8;
            }
            else {
              if (0x73 < bVar10) {
                if (bVar10 != 0x78) goto LAB_080cd9c2;
                goto LAB_080ce1bd;
              }
              if (bVar10 != 0x2d) {
                if (bVar10 != 0x53) goto LAB_080cd9c2;
                uVar9 = uVar9 | 0x400;
              }
            }
            if (local_20[0][6] != 0x2d) {
              if (local_20[0][6] != 0x72) goto LAB_080cd9c2;
              uVar9 = uVar9 | 4;
            }
            if (local_20[0][7] != 0x2d) {
              if (local_20[0][7] != 0x77) goto LAB_080cd9c2;
              uVar9 = uVar9 | 2;
            }
            bVar10 = local_20[0][8];
            if (bVar10 == 0x6c) {
LAB_080ce1ee:
              uVar9 = uVar9 & 0xfffffff7 | 0x400;
            }
            else {
              if (bVar10 < 0x6d) {
                if (bVar10 == 0x4c) goto LAB_080ce1ee;
                if (bVar10 == 0x54) {
                  uVar9 = uVar9 | 0x200;
                }
                else {
                  if (bVar10 != 0x2d) goto LAB_080cd9c2;
                }
              }
              else {
                if (bVar10 == 0x74) {
                  uVar9 = uVar9 | 0x200;
                }
                else {
                  if (bVar10 != 0x78) goto LAB_080cd9c2;
                }
                uVar9 = uVar9 | 1;
              }
            }
          }
          else {
            uVar9 = 0x100;
            if (*local_20[0] == 0x72) goto LAB_080ce024;
LAB_080cd9c2:
            uVar9 = 0;
          }
          info->permissions = uVar9;
          local_68 = 1;
        }
        break;
      case 1:
        if ((((*(uint *)&info->size & *(uint *)((int)&info->size + 4)) == 0xffffffff) ||
            (end + -(int)local_20[0] != (byte *)0x3)) ||
           (iVar11 = parse_month(local_20,end), iVar11 == -1)) {
          bVar10 = *local_20[0];
          if ((byte)(bVar10 - 0x30) < 10) {
            local_8c = 0;
            local_88 = 0;
            if (local_20[0] < end) {
              local_8c = 0;
              local_88 = 0;
              do {
                uVar2 = (ulonglong)local_8c;
                uVar9 = (uint)(uVar2 * 10);
                uVar5 = (uint)bVar10 - 0x30;
                local_8c = uVar5 + uVar9;
                local_88 = ((int)uVar5 >> 0x1f) + (int)(uVar2 * 10 >> 0x20) + local_88 * 10 +
                           (uint)CARRY4(uVar5,uVar9);
                local_20[0] = local_20[0] + 1;
                if (end <= local_20[0]) break;
                bVar10 = *local_20[0];
              } while ((byte)(bVar10 - 0x30) < 10);
              if (local_88 < 0) {
                local_8c = 0xffffffff;
                local_88 = -1;
              }
            }
            *(uint *)&info->size = local_8c;
            *(int *)((int)&info->size + 4) = local_88;
          }
          else {
            *(undefined4 *)&info->size = 0xffffffff;
            *(undefined4 *)((int)&info->size + 4) = 0xffffffff;
          }
        }
        else {
          local_68 = 2;
          mtime.tm_mon = iVar11;
        }
        break;
      case 2:
        mtime.tm_mday = parse_day(local_20,end);
        local_68 = 3;
        break;
      case 3:
        if ((byte)(*local_20[0] - 0x30) < 10) {
          pvVar3 = memchr(local_20[0],0x3a,(size_t)(end + -(int)local_20[0]));
          if (pvVar3 == (void *)0x0) {
            mtime.tm_year = parse_year(local_20,end);
          }
          else {
            iVar11 = parse_time(local_20,&mtime,end);
            if (iVar11 == 0) {
              mtime.tm_sec = 0;
              mtime.tm_min = 0;
              mtime.tm_hour = 0;
              local_68 = 4;
              break;
            }
          }
        }
        local_68 = 4;
        break;
      case 4:
        fVar1 = info->type;
        (info->name).source = local_20[0];
        __s = end_00 + -(int)local_20[0];
        *(byte **)&(info->name).length = __s;
        if (fVar1 == FTP_FILE_DIRECTORY) {
          if ((0 < (int)__s) && (__s[(int)(local_20[0] + -1)] == 0x2f)) {
            *(byte **)&(info->name).length = __s + -1;
          }
        }
        else {
          if (fVar1 == FTP_FILE_SYMLINK) goto joined_r0x080cde47;
          if ((((fVar1 == FTP_FILE_PLAINFILE) && ((*(byte *)&info->permissions & 0x49) != 0)) &&
              (0 < (int)__s)) && (__s[(int)(local_20[0] + -1)] == 0x2a)) {
            *(byte **)&(info->name).length = __s + -1;
          }
        }
        goto LAB_080cda01;
      }
      while( true ) {
        if (end_00 <= end) {
          return (ftp_file_info *)0x0;
        }
        local_20[0] = end;
        if (*end != 0x20) break;
        end = end + 1;
      }
    } while( true );
  }
  end_00 = src + len;
  local_20[0] = src;
  end = (byte *)memchr(src,0x3b,len);
  if (end == (byte *)0x0) {
    return (ftp_file_info *)0x0;
  }
  (info->name).source = src;
  __s = end + -(int)local_20[0];
  *(byte **)&(info->name).length = __s;
  if (4 < (int)__s) {
    iVar11 = 4;
    bVar15 = end + -4 == (byte *)0x0;
    pbVar12 = end + -4;
    pbVar14 = &DAT_0813297d;
    do {
      if (iVar11 == 0) break;
      iVar11 = iVar11 + -1;
      bVar15 = *pbVar12 == *pbVar14;
      pbVar12 = pbVar12 + (uint)bVar16 * -2 + 1;
      pbVar14 = pbVar14 + (uint)bVar16 * -2 + 1;
    } while (bVar15);
    if (bVar15) {
      info->type = FTP_FILE_DIRECTORY;
      *(byte **)&(info->name).length = __s + -4;
      goto LAB_080cdf41;
    }
  }
  info->type = FTP_FILE_PLAINFILE;
LAB_080cdf41:
  if (end_00 <= end) {
    return (ftp_file_info *)0x0;
  }
  bVar16 = *end;
  local_20[0] = end;
  while (bVar16 != 0x20) {
    local_20[0] = local_20[0] + 1;
    if (end_00 <= local_20[0]) {
      return (ftp_file_info *)0x0;
    }
    bVar16 = *local_20[0];
  }
  do {
    local_20[0] = local_20[0] + 1;
    if (end_00 <= local_20[0]) {
      return (ftp_file_info *)0x0;
    }
  } while (*local_20[0] == 0x20);
  while (*local_20[0] != 0x20) {
    local_20[0] = local_20[0] + 1;
    if (end_00 <= local_20[0]) {
      return (ftp_file_info *)0x0;
    }
  }
  do {
    local_20[0] = local_20[0] + 1;
    if (end_00 <= local_20[0]) {
      return (ftp_file_info *)0x0;
    }
  } while (*local_20[0] == 0x20);
  tVar8 = parse_date(local_20,end_00,1,0);
  info->mtime = tVar8;
  end = local_20[0];
  if (tVar8 == 0) {
    return (ftp_file_info *)0x0;
  }
  do {
    local_20[0] = end;
    if (end_00 <= local_20[0]) break;
    end = local_20[0] + 1;
  } while (*local_20[0] == 0x20);
  do {
    end = local_20[0];
    if (end_00 <= local_20[0]) break;
    bVar16 = *local_20[0];
    local_20[0] = local_20[0] + 1;
  } while (bVar16 != 0x20);
  do {
    local_20[0] = end;
    if (end_00 <= local_20[0]) {
      return info;
    }
    end = local_20[0] + 1;
  } while (*local_20[0] == 0x20);
  end = (byte *)memchr(local_20[0],0x28,(size_t)(end_00 + -(int)local_20[0]));
  if (end == (byte *)0x0) {
    return info;
  }
  if (end_00 <= end) {
    return info;
  }
  __s = end + 1;
  local_20[0] = __s;
  pvVar3 = memchr(__s,0x29,(size_t)(end_00 + -(int)__s));
  if (pvVar3 == (void *)0x0) {
    return info;
  }
  iVar11 = 0;
  uVar9 = 0;
  do {
    if ((int)((int)pvVar3 - (int)__s) <= iVar11) {
LAB_080ce27c:
      info->permissions = uVar9;
      return info;
    }
    bVar16 = end[iVar11 + 1];
    if (bVar16 == 0x45) {
      uVar9 = uVar9 | 1;
    }
    else {
      if (bVar16 < 0x46) {
        if (bVar16 == 0x2c) {
          uVar9 = uVar9 << 3;
        }
        else {
          if (bVar16 != 0x44) {
LAB_080ce27a:
            uVar9 = 0;
            goto LAB_080ce27c;
          }
LAB_080ce299:
          uVar9 = uVar9 | 2;
        }
      }
      else {
        if (bVar16 != 0x52) {
          if (bVar16 != 0x57) goto LAB_080ce27a;
          goto LAB_080ce299;
        }
        uVar9 = uVar9 | 4;
      }
    }
    iVar11 = iVar11 + 1;
  } while( true );
joined_r0x080cde47:
  if (end == (byte *)0x0) {
    __s = (info->symlink).source;
LAB_080cdeb9:
    if (__s == (byte *)0x0) {
      return (ftp_file_info *)0x0;
    }
    iVar11 = (info->name).length;
    if ((0 < iVar11) && ((info->name).source[iVar11 + -1] == '@')) {
      (info->name).length = iVar11 + -1;
    }
    iVar11 = (info->symlink).length;
    if ((0 < iVar11) && ((info->symlink).source[iVar11 + -1] == '/')) {
      (info->symlink).length = iVar11 + -1;
    }
LAB_080cda01:
    if (mtime.tm_year == 0) {
      local_24 = time((time_t *)0x0);
      ptVar7 = localtime(&local_24);
      mtime.tm_year = ptVar7->tm_year;
      if (ptVar7->tm_mon < mtime.tm_mon) {
        mtime.tm_year = mtime.tm_year + -1;
      }
    }
    tVar4 = mktime((tm *)&mtime);
    *(byte *)&info->field_0x20 = *(byte *)&info->field_0x20 | 1;
    info->mtime = tVar4;
    return info;
  }
  if (end_00 <= end + 3) {
    __s = (info->symlink).source;
    goto LAB_080cdeb9;
  }
  bVar15 = end_00 == end + 3;
  iVar11 = 4;
  __s = end;
  pbVar12 = &DAT_081326ac;
  do {
    if (iVar11 == 0) break;
    iVar11 = iVar11 + -1;
    bVar15 = *__s == *pbVar12;
    __s = __s + (uint)bVar16 * -2 + 1;
    pbVar12 = pbVar12 + (uint)bVar16 * -2 + 1;
  } while (bVar15);
  if (bVar15) {
    __s = end + 4;
    (info->symlink).source = __s;
    *(byte **)&(info->symlink).length = end_00 + (-4 - (int)end);
    *(byte **)&(info->name).length = end + -(int)local_20[0];
    goto LAB_080cdeb9;
  }
  end = (byte *)memchr(end + 1,0x20,(size_t)(end_00 + -(int)end));
  goto joined_r0x080cde47;
}



void free_blacklist(void)

{
  list_head_elinks **pplVar1;
  list_head_elinks *p;
  list_head_elinks *plVar2;
  list_head_elinks *plVar3;
  bool bVar4;
  
  plVar3 = (list_head_elinks *)blacklist.next;
  if ((list_head_elinks *)blacklist.next != &blacklist) {
    do {
      plVar3 = (list_head_elinks *)plVar3->next;
    } while (plVar3 != &blacklist);
  }
  plVar2 = (list_head_elinks *)blacklist.prev;
  if ((list_head_elinks *)blacklist.prev != plVar3) {
    do {
      pplVar1 = (list_head_elinks **)&plVar2->prev;
      plVar2 = *pplVar1;
    } while (*pplVar1 != plVar3);
  }
  plVar2 = *(list_head_elinks **)blacklist.next;
  p = (list_head_elinks *)blacklist.next;
  if ((list_head_elinks *)blacklist.next != plVar3) {
    do {
      plVar2->prev = p->prev;
      *(void **)p->prev = p->next;
      mem_free(p);
      bVar4 = plVar2 != plVar3;
      p = plVar2;
      plVar2 = (list_head_elinks *)plVar2->next;
    } while (bVar4);
  }
  return;
}



blacklist_entry * __regparm3 get_blacklist_entry(uri *uri)

{
  int iVar1;
  blacklist_entry *pbVar2;
  
  if (assert_failed == 0) {
    if ((uri == (uri *)0x0) || (*(short *)&uri->field_0x2e == 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/blacklist.c";
      errline = 0x21;
      elinks_internal((uchar *)"assertion uri && uri->hostlen > 0 failed!");
      pbVar2 = (blacklist_entry *)blacklist.next;
      if (assert_failed != 0) goto LAB_080ce3f0;
    }
    else {
      assert_failed = 0;
      pbVar2 = (blacklist_entry *)blacklist.next;
    }
    while( true ) {
      if (pbVar2 == (blacklist_entry *)&blacklist) {
        return (blacklist_entry *)0x0;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/blacklist.c";
      errline = 0x25;
      iVar1 = elinks_strlcasecmp(pbVar2->host,0xffffffff,uri->host,(uint)*(ushort *)&uri->field_0x2e
                                 ,1);
      if (iVar1 == 0) break;
      pbVar2 = pbVar2->next;
    }
  }
  else {
LAB_080ce3f0:
    assert_failed = 0;
    pbVar2 = (blacklist_entry *)0x0;
  }
  return pbVar2;
}



blacklist_flags get_blacklist_flags(uri *uri)

{
  blacklist_entry *pbVar1;
  blacklist_flags bVar2;
  
  pbVar1 = get_blacklist_entry(uri);
  bVar2 = SERVER_BLACKLIST_NONE;
  if (pbVar1 != (blacklist_entry *)0x0) {
    bVar2 = pbVar1->flags;
  }
  return bVar2;
}



void del_blacklist_entry(uri *uri,blacklist_flags flags)

{
  blacklist_entry *p;
  blacklist_flags bVar1;
  
  p = get_blacklist_entry(uri);
  if ((p != (blacklist_entry *)0x0) &&
     (bVar1 = ~flags & p->flags, p->flags = bVar1, bVar1 == SERVER_BLACKLIST_NONE)) {
    p->next->prev = p->prev;
    p->prev->next = p->next;
    mem_free(p);
    return;
  }
  return;
}



void add_blacklist_entry(uri *uri,blacklist_flags flags)

{
  blacklist_entry *pbVar1;
  void **ppvVar2;
  
  pbVar1 = get_blacklist_entry(uri);
  if (pbVar1 == (blacklist_entry *)0x0) {
    ppvVar2 = (void **)mem_alloc((uint)*(ushort *)&uri->field_0x2e + 0x10);
    if (ppvVar2 != (void **)0x0) {
      *(blacklist_flags *)(ppvVar2 + 2) = flags;
      safe_strncpy((uchar *)(ppvVar2 + 3),uri->host,(uint)*(ushort *)&uri->field_0x2e + 1);
      *(list_head_elinks **)(ppvVar2 + 1) = &blacklist;
      *ppvVar2 = blacklist.next;
      blacklist.next = ppvVar2;
      *(void ***)((int)*ppvVar2 + 4) = ppvVar2;
    }
  }
  else {
    pbVar1->flags = pbVar1->flags | flags;
  }
  return;
}



int compare_http_codes(void *key,void *element)

{
  return (int)((int)key - *(int *)element);
}



void http_error_document(connection *conn,int code)

{
  object *poVar1;
  uri *puVar2;
  int *data;
  
  if (assert_failed == 0) {
    if ((conn == (connection *)0x0) || (conn->uri == (uri *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/codes.c";
      errline = 0xca;
      elinks_internal((uchar *)"assertion conn && conn->uri failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  data = (int *)mem_calloc(1,8);
  if (data != (int *)0x0) {
    *data = code;
    puVar2 = conn->uri;
    poVar1 = &puVar2->object;
    poVar1->refcount = poVar1->refcount + 1;
    *(uri **)(data + 1) = puVar2;
    add_questions_entry(show_http_error_document,data);
    return;
  }
  return;
}



void show_http_error_document(session *ses,void *data)

{
  terminal *term;
  void *__key;
  undefined4 *puVar1;
  cache_entry *pcVar2;
  void *pvVar3;
  int cp_index;
  uchar *codeset;
  char *local_5c;
  string *psVar4;
  uchar *codeset_00;
  size_t length;
  cache_entry *cached;
  uchar *local_64;
  uchar *local_60;
  char *local_30;
  string string;
  
  term = ses->tab->term;
  pcVar2 = find_in_cache(*(uri **)((int)data + 4));
  cached = pcVar2;
  if ((pcVar2 != (cache_entry *)0x0) ||
     (cached = get_cache_entry(*(uri **)((int)data + 4)), cached != (cache_entry *)0x0)) {
    __key = *(void **)data;
    puVar1 = *(undefined4 **)((int)data + 4);
    pvVar3 = bsearch(__key,http_code,0x29,8,compare_http_codes);
    local_30 = (char *)0x0;
    if (pvVar3 != (void *)0x0) {
      local_30 = *(char **)((int)pvVar3 + 4);
    }
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"HTTP error %03d");
    codeset = asprintfa((char *)codeset,__key);
    local_5c = "Unknown error";
    if (local_30 != (char *)0x0) {
      local_5c = local_30;
    }
    psVar4 = init_string(&string);
    if (psVar4 == (string *)0x0) {
      if (codeset != (uchar *)0x0) {
        mem_free(codeset);
      }
    }
    else {
      local_64 = codeset;
      local_60 = codeset;
      add_format_to_string
                (&string,(uchar *)
                         "<html>\n <head><title>%s</title></head>\n <body>\n  <h1 align=\"left\">%s: %s</h1>\n  <hr />\n  <p>\n"
                 ,codeset,codeset,local_5c);
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset_00 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset_00);
        current_charset = cp_index;
      }
      codeset_00 = gettext((uchar *)
                           "  An error occurred on the server while fetching the document you\n  requested. However, the server did not send back any explanation of what\n  happened, so it is unknown what went wrong. Please contact the web\n  server administrator about this, if you believe that this error should\n  not occur since it is not a nice behaviour from the web server at all\n  and indicates that there is some much deeper problem with the web server\n  software.\n"
                          );
      add_format_to_string(&string,codeset_00,local_64,local_60,local_5c);
      add_format_to_string
                (&string,(uchar *)"  </p>\n  <p>\n  URI: <a href=\"%s\">%s</a>\n",*puVar1,*puVar1);
      add_format_to_string(&string,(uchar *)" </p>\n <hr />\n </body>\n</html>\n");
      if (codeset != (uchar *)0x0) {
        mem_free(codeset);
      }
      if (string.source != (uchar *)0x0) {
        cp_index = get_terminal_codepage(term);
        if (pcVar2 != (cache_entry *)0x0) {
          delete_entry_content(cached);
        }
        if (cached->content_type != (uchar *)0x0) {
          mem_free(cached->content_type);
        }
        codeset = stracpy((uchar *)"text/html");
        cached->content_type = codeset;
        if (cached->head != (uchar *)0x0) {
          mem_free(cached->head);
        }
        codeset = get_cp_mime_name(cp_index);
        codeset = straconcat((uchar *)"\r\nContent-Type: text/html; charset=",codeset,&DAT_081352f5,
                             0);
        cached->head = codeset;
        length = strlen((char *)string.source);
        add_fragment(cached,0,string.source,length);
        mem_free(string.source);
        draw_formatted(ses,1);
      }
    }
  }
  done_uri(*(uri **)((int)data + 4));
  mem_free(data);
  return;
}



void done_http(void)

{
  if (proxy_auth.realm != (uchar *)0x0) {
    mem_free(proxy_auth.realm);
  }
  if (proxy_auth.nonce != (uchar *)0x0) {
    mem_free(proxy_auth.nonce);
  }
  if (proxy_auth.opaque != (uchar *)0x0) {
    mem_free(proxy_auth.opaque);
  }
  free_blacklist();
  if (accept_charset != (uchar *)0x0) {
    mem_free(accept_charset);
  }
  return;
}



connection_state connection_state(void)

{
  int *in_EAX;
  int in_EDX;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(in_EDX == -1);
    if (in_EDX == -1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
      errline = 0x84;
      elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
      if (assert_failed != 0) goto LAB_080ce978;
    }
    in_EAX[1] = 0;
    *in_EAX = in_EDX;
    return (connection_state)CONCAT44(in_EDX,in_EAX);
  }
LAB_080ce978:
  assert_failed = 0;
  in_EAX[1] = 0;
  *in_EAX = -0x186a3;
  return (connection_state)CONCAT44(0xfffe795d,in_EAX);
}



void __regparm1 http_end_request(connection *conn,int notrunc)

{
  int *piVar1;
  undefined4 in_ECX;
  undefined4 uVar2;
  int in_EDX;
  uchar *name;
  undefined4 uVar3;
  
  shutdown_connection_stream(conn);
  if ((((conn->info != (void *)0x0) && (*(int *)((int)conn->info + 0x14) == 0)) &&
      (conn->socket->ssl == (void *)0x0)) &&
     ((piVar1 = get_opt_(config_options,name), *piVar1 == 0 || (conn->uri->post == (uchar *)0x0))))
  {
    if ((in_EDX == -100000) && (conn->cached != (cache_entry *)0x0)) {
      uVar3 = 0xffffffff;
      uVar2 = 0xffffffff;
      if (notrunc == 0) {
        uVar3 = *(undefined4 *)&conn->from;
        uVar2 = *(undefined4 *)((int)&conn->from + 4);
      }
      normalize_cache_entry(conn->cached,CONCAT44(uVar2,uVar3));
    }
    set_connection_state(conn,(connection_state)CONCAT44(in_ECX,in_EDX));
    add_keepalive_connection(conn,60000,(anon_subr_void_connection_ptr_for_done *)0x0);
    return;
  }
  abort_connection(conn,(connection_state)CONCAT44(in_ECX,in_EDX));
  return;
}



uchar * __regparm3 decompress_data(connection *conn,uchar *data,int len,int *new_len)

{
  void *pvVar1;
  uchar *puVar2;
  int __fd;
  ssize_t sVar3;
  int *piVar4;
  stream_encoded *psVar5;
  bool bVar6;
  int *local_34;
  uchar *local_28;
  uchar *local_24;
  size_t local_20;
  
  pvVar1 = conn->info;
  if (*(int *)((int)pvVar1 + 0x18) == -2) {
    bVar6 = *(int *)((int)pvVar1 + 0x1c) == -2;
    local_34 = (int *)((int)pvVar1 + 0x1c);
  }
  else {
    local_34 = (int *)((int)pvVar1 + 0x18);
    bVar6 = *(int *)((int)pvVar1 + 0x18) == 0;
  }
  local_28 = data;
  if (conn->content_encoding == ENCODING_NONE) {
    *new_len = len;
    if (0 < *local_34) {
      *local_34 = *local_34 - len;
    }
  }
  else {
    *new_len = 0;
    if ((conn->stream_pipes[0] == -1) &&
       (((__fd = c_pipe(conn->stream_pipes), __fd < 0 ||
         (__fd = set_nonblocking_fd(conn->stream_pipes[0]), __fd < 0)) ||
        (__fd = set_nonblocking_fd(conn->stream_pipes[1]), __fd < 0)))) {
LAB_080cec6e:
      local_28 = (uchar *)0x0;
    }
    else {
      local_24 = (uchar *)0x0;
      local_20 = len;
      do {
        if (bVar6) {
LAB_080ceb18:
          bVar6 = true;
        }
        else {
          __fd = conn->stream_pipes[1];
          do {
            sVar3 = write(__fd,local_28,local_20);
            if (sVar3 != -1) {
              if (-1 < sVar3) {
                local_28 = local_28 + sVar3;
                local_20 = local_20 - sVar3;
                if (0 < *local_34) {
                  *local_34 = *local_34 - sVar3;
                }
                if (*(int *)((int)pvVar1 + 0x18) == 0) goto LAB_080ceb18;
                if (local_20 == 0) {
                  return local_24;
                }
              }
              break;
            }
            piVar4 = __errno_location();
          } while (*piVar4 == 4);
        }
        if (conn->stream == (stream_encoded *)0x0) {
          psVar5 = open_encoded(conn->stream_pipes[0],conn->content_encoding);
          conn->stream = psVar5;
          if (psVar5 == (stream_encoded *)0x0) goto LAB_080cec6e;
        }
        puVar2 = (uchar *)mem_realloc(local_24,*new_len + 0xa0000);
        if (puVar2 == (uchar *)0x0) break;
        __fd = read_encoded(conn->stream,puVar2 + *new_len,0xa0000);
        local_24 = puVar2;
        if (__fd < 0) goto LAB_080cebf3;
        *new_len = *new_len + __fd;
      } while ((__fd == 0xa0000) || (local_20 != 0));
      if (!bVar6) {
        return local_24;
      }
LAB_080cebf3:
      shutdown_connection_stream(conn);
      local_28 = local_24;
    }
  }
  return local_28;
}



string * __regparm3 add_bytes_to_string__(string *string,uchar *bytes,int length)

{
  int iVar1;
  uint uVar2;
  uchar *puVar3;
  uint size;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  if (((bytes == (uchar *)0x0) || (string == (string *)0x0)) || (length < 0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 0xff;
    elinks_internal((uchar *)
                    "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  if (length == 0) {
    return string;
  }
  iVar1 = length + string->length;
  uVar2 = string->length + 0xffU & 0xffffff00;
  size = iVar1 + 0x100U & 0xffffff00;
  if (uVar2 < size) {
    puVar3 = (uchar *)mem_realloc(string->source,size);
    if (puVar3 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar3;
    memset(puVar3 + uVar2,0,size - uVar2);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  memcpy(string->source + string->length,bytes,length);
  string->source[iVar1] = '\0';
  string->length = iVar1;
  return string;
}



// WARNING: Type propagation algorithm not settling

http_connection_info * init_http_connection_info(connection *conn,int major,int minor,int close)

{
  uchar *name;
  http_connection_info *phVar1;
  blacklist_flags bVar2;
  int *piVar3;
  uchar *extraout_EDX;
  uchar *extraout_EDX_00;
  
  phVar1 = (http_connection_info *)mem_calloc(1,0x24);
  if (phVar1 != (http_connection_info *)0x0) {
    (phVar1->sent_version).major = major;
    (phVar1->sent_version).minor = minor;
    phVar1->close = close;
    if (conn->proxied_uri->protocol == 4) {
      bVar2 = phVar1->bl_flags;
      name = extraout_EDX;
    }
    else {
      bVar2 = get_blacklist_flags(conn->proxied_uri);
      phVar1->bl_flags = bVar2;
      name = extraout_EDX_00;
    }
    if (((bVar2 & SERVER_BLACKLIST_HTTP10) != SERVER_BLACKLIST_NONE) ||
       (piVar3 = get_opt_(config_options,name), *piVar3 != 0)) {
      (phVar1->sent_version).major = 1;
      (phVar1->sent_version).minor = 0;
    }
    if (conn->info != (void *)0x0) {
      mem_free(conn->info);
    }
    *(http_connection_info **)&conn->info = phVar1;
    return phVar1;
  }
  connection_state();
  http_end_request(conn,0);
  return (http_connection_info *)0x0;
}



void __regparm3 read_http_data_done(connection *conn)

{
  int code;
  
  if (((*(uint *)((int)&conn->from + 4) | *(uint *)&conn->from) == 0) &&
     (code = *(int *)((int)conn->info + 0x20), 399 < code)) {
    http_error_document(conn,code);
  }
  if (assert_failed == 0) {
    assert_failed = 0;
    http_end_request(conn,0);
    return;
  }
  assert_failed = 0;
  http_end_request(conn,0);
  return;
}



void __regparm3 read_more_http_data(connection *conn,read_buffer *rb,int already_got_anything)

{
  int iVar1;
  connection_basic_state cVar2;
  
  if (already_got_anything == 0) {
    cVar2 = (conn->state).basic;
    iVar1 = (conn->state).syserr;
  }
  else {
    if (assert_failed == 0) {
      assert_failed = 0;
      cVar2 = S_TRANS;
      iVar1 = 0;
    }
    else {
      assert_failed = 0;
      cVar2 = S_INTERNAL;
      iVar1 = 0;
    }
  }
  read_from_socket(conn->socket,rb,(connection_state)CONCAT44(iVar1,cVar2),read_http_data);
  return;
}



void read_http_data(socket *socket,read_buffer *rb)

{
  off_t *poVar1;
  byte bVar2;
  connection *conn;
  socket_state sVar3;
  uchar *data;
  int iVar4;
  uint uVar5;
  uchar *data_00;
  int n;
  int *piVar6;
  uint len;
  bool bVar7;
  uchar *local_3c;
  int local_34;
  void *local_30;
  uchar *local_20 [4];
  
  conn = (connection *)socket->conn;
  local_30 = conn->info;
  if (socket->state == SOCKET_CLOSED) {
    if (conn->content_encoding == ENCODING_NONE) goto LAB_080cf0b7;
    *(undefined4 *)((int)local_30 + 0x18) = 0;
    local_30 = conn->info;
    uVar5 = *(uint *)((int)local_30 + 0x18);
LAB_080cefe4:
    len = rb->length;
    if ((-1 < (int)uVar5) && ((int)uVar5 < (int)len)) {
      len = uVar5;
    }
    poVar1 = &conn->received;
    uVar5 = *(uint *)poVar1;
    *(uint *)poVar1 = *(int *)poVar1 + len;
    piVar6 = (int *)((int)&conn->received + 4);
    *piVar6 = *piVar6 + ((int)len >> 0x1f) + (uint)CARRY4(uVar5,len);
    data = decompress_data(conn,rb->data,len,(int *)local_20);
    iVar4 = add_fragment(conn->cached,conn->from,data,(ssize_t)local_20[0]);
    if (iVar4 == 1) {
      conn->tries = 0;
    }
    if ((data != (uchar *)0x0) && (rb->data != data)) {
      mem_free(data);
    }
    poVar1 = &conn->from;
    data = *(uchar **)poVar1;
    *(uchar **)poVar1 = local_20[0] + (int)*(uchar **)poVar1;
    piVar6 = (int *)((int)&conn->from + 4);
    *piVar6 = *piVar6 + ((int)local_20[0] >> 0x1f) + (uint)CARRY4((uint)data,(uint)local_20[0]);
    kill_buffer_data(rb,len);
    local_3c = local_20[0];
    if ((*(int *)((int)local_30 + 0x18) == 0) &&
       ((sVar3 = conn->socket->state, sVar3 == SOCKET_CLOSED || (sVar3 == SOCKET_RETRY_ONCLOSE)))) {
LAB_080cf0b7:
      read_http_data_done(conn);
      return;
    }
LAB_080cf088:
    bVar7 = local_3c != (uchar *)0x0;
    uVar5 = (uint)bVar7;
    if (bVar7) {
      read_more_http_data(conn,rb,1);
      return;
    }
    if (!bVar7) {
      read_more_http_data(conn,rb,0);
      return;
    }
  }
  else {
    uVar5 = *(uint *)((int)local_30 + 0x18);
    if (uVar5 != 0xfffffffe) goto LAB_080cefe4;
    data = rb->data;
    uVar5 = *(uint *)((int)local_30 + 0x1c);
    local_3c = (uchar *)0x0;
LAB_080cf1a3:
    if (uVar5 != 0xfffffffd) {
      if (uVar5 == 0xffffffff) goto LAB_080cf310;
      do {
        bVar7 = uVar5 == 0xfffffffe;
        if (bVar7) {
          uVar5 = 0;
        }
        len = rb->length;
        if ((int)uVar5 <= rb->length) {
          len = uVar5;
        }
        poVar1 = &conn->received;
        uVar5 = *(uint *)poVar1;
        *(uint *)poVar1 = *(int *)poVar1 + len;
        piVar6 = (int *)((int)&conn->received + 4);
        *piVar6 = *piVar6 + ((int)len >> 0x1f) + (uint)CARRY4(uVar5,len);
        data_00 = decompress_data(conn,data,len,(int *)local_20);
        iVar4 = add_fragment(conn->cached,conn->from,data_00,(ssize_t)local_20[0]);
        if (iVar4 == 1) {
          conn->tries = 0;
        }
        if ((data_00 != (uchar *)0x0) && (data != data_00)) {
          mem_free(data_00);
        }
        poVar1 = &conn->from;
        data_00 = *(uchar **)poVar1;
        *(uchar **)poVar1 = local_20[0] + (int)*(uchar **)poVar1;
        piVar6 = (int *)((int)&conn->from + 4);
        *piVar6 = *piVar6 + ((int)local_20[0] >> 0x1f) +
                  (uint)CARRY4((uint)data_00,(uint)local_20[0]);
        local_3c = local_3c + (int)local_20[0];
        kill_buffer_data(rb,len);
        if (bVar7) {
          *(undefined4 *)((int)local_30 + 0x1c) = 0xfffffffd;
          break;
        }
        if ((*(int *)((int)local_30 + 0x1c) != 0) || (rb->length < 1)) goto LAB_080cf088;
        if (rb->data[0] == '\n') {
          kill_buffer_data(rb,1);
        }
        else {
          if (rb->data[0] != '\r') goto LAB_080cf0e7;
          if (rb->length == 1) goto LAB_080cf088;
          if (*(char *)&rb->field_0xd != '\n') goto LAB_080cf0e7;
          kill_buffer_data(rb,2);
        }
        *(undefined4 *)((int)local_30 + 0x1c) = 0xffffffff;
LAB_080cf310:
        iVar4 = rb->length;
        if (iVar4 < 1) goto LAB_080cf088;
        bVar2 = rb->data[0];
        if (bVar2 == 10) {
          n = 1;
        }
        else {
          n = 0;
          local_34 = 1;
          if (bVar2 != 0xd) {
            if (bVar2 < 0x20) goto LAB_080cf0e7;
            local_34 = 0;
            while( true ) {
              n = local_34 + 1;
              if (iVar4 <= n) goto LAB_080cf088;
              bVar2 = *(byte *)(&rb->field_0xd + local_34);
              if (bVar2 == 10) {
                n = local_34 + 2;
                if (n == 0) goto LAB_080cf088;
                goto LAB_080cf39a;
              }
              if (bVar2 == 0xd) break;
              local_34 = n;
              if (bVar2 < 0x20) goto LAB_080cf0e7;
            }
            local_34 = local_34 + 2;
          }
          if (rb->data[local_34] != '\n') goto LAB_080cf0dc;
          iVar4 = iVar4 + -1;
          if (iVar4 <= n) goto LAB_080cf0df;
          n = n + 2;
LAB_080cf39a:
          if (n == -1) goto LAB_080cf0e7;
        }
        piVar6 = __errno_location();
        *piVar6 = 0;
        uVar5 = strtol((char *)data,(char **)local_20,0x10);
        if (((*piVar6 != 0) || (*local_20[0] == '\0')) || (local_20[0] == data)) goto LAB_080cf0e7;
        kill_buffer_data(rb,n);
        *(uint *)((int)local_30 + 0x1c) = uVar5;
        if (uVar5 != 0) goto LAB_080cf1a3;
        *(undefined4 *)((int)local_30 + 0x1c) = 0xfffffffe;
        uVar5 = 0xfffffffe;
      } while( true );
    }
    iVar4 = rb->length;
    if (iVar4 < 1) goto LAB_080cf088;
    bVar2 = rb->data[0];
    if (bVar2 == 10) {
      n = 1;
LAB_080cf437:
      kill_buffer_data(rb,n);
      if (n < 3) goto LAB_080cf0b7;
      uVar5 = *(uint *)((int)local_30 + 0x1c);
      goto LAB_080cf1a3;
    }
    n = 0;
    local_34 = 1;
    if (bVar2 != 0xd) {
      if (bVar2 < 0x20) goto LAB_080cf0e7;
      local_34 = 0;
      while( true ) {
        n = local_34 + 1;
        if (iVar4 <= n) goto LAB_080cf088;
        bVar2 = *(byte *)(&rb->field_0xd + local_34);
        if (bVar2 == 10) {
          n = local_34 + 2;
          if (n == 0) goto LAB_080cf088;
          goto LAB_080cf42e;
        }
        if (bVar2 == 0xd) break;
        local_34 = n;
        if (bVar2 < 0x20) goto LAB_080cf0e7;
      }
      local_34 = local_34 + 2;
    }
    if (rb->data[local_34] == '\n') {
      iVar4 = iVar4 + -1;
      if (n < iVar4) {
        n = n + 2;
LAB_080cf42e:
        if (n != -1) goto LAB_080cf437;
        goto LAB_080cf0e7;
      }
    }
    else {
LAB_080cf0dc:
      iVar4 = iVar4 + -1;
    }
LAB_080cf0df:
    if (n == iVar4) goto LAB_080cf088;
LAB_080cf0e7:
    uVar5 = 0xffffffff;
  }
  if (assert_failed == 0) {
    assert_failed = ZEXT14(uVar5 != 0xffffffff);
    if (uVar5 != 0xffffffff) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/http.c";
      errline = 0x56c;
      elinks_internal((uchar *)"assertion ret == -1 failed: Unexpected return value: %d",uVar5);
      if (assert_failed != 0) goto LAB_080cf49a;
    }
    uVar5 = 0xfffe78fc;
  }
  else {
LAB_080cf49a:
    uVar5 = 0xfffe795d;
  }
  assert_failed = 0;
  abort_connection(conn,(connection_state)(ulonglong)uVar5);
  return;
}



void __regparm3 add_url_to_http_string(string *header,uri *uri,int components)

{
  int iVar1;
  uchar *__src;
  uchar uVar2;
  uint uVar3;
  uchar *p;
  size_t __n;
  uint uVar4;
  uchar *puVar5;
  uint size;
  
  p = get_uri_string(uri,components);
  if (p != (uchar *)0x0) {
    uVar2 = *p;
    __src = p;
    while (uVar2 != '\0') {
      __n = strcspn((char *)__src," \t\r\n\\");
      if (assert_failed == 0) {
        if ((header == (string *)0x0) || ((int)__n < 0)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_080cf568;
        }
        else {
          assert_failed = 0;
        }
        if (__n == 0) goto LAB_080cf578;
        iVar1 = __n + header->length;
        uVar4 = header->length + 0xff;
        uVar3 = uVar4 >> 8;
        uVar4 = uVar4 & 0xffffff00;
        size = iVar1 + 0x100U & 0xffffff00;
        if (uVar4 <= size && size + uVar3 * -0x100 != 0) {
          puVar5 = (uchar *)mem_realloc(header->source,size);
          if (puVar5 == (uchar *)0x0) goto LAB_080cf578;
          header->source = puVar5;
          memset(puVar5 + uVar4,0,size + uVar3 * -0x100);
        }
        if (header->source == (uchar *)0x0) goto LAB_080cf578;
        memcpy(header->source + header->length,__src,__n);
        header->source[iVar1] = '\0';
        header->length = iVar1;
        uVar2 = __src[__n];
      }
      else {
LAB_080cf568:
        assert_failed = 0;
LAB_080cf578:
        uVar2 = __src[__n];
      }
      if (uVar2 == '\0') break;
      if (uVar2 == '\\') {
        add_char_to_string(header,'/');
      }
      else {
        add_to_string(header,"%20");
      }
      __src = __src + __n + 1;
      uVar2 = *__src;
    }
    mem_free(p);
  }
  return;
}



void http_got_header(socket *socket,read_buffer *rb)

{
  byte *src;
  int iVar1;
  byte *pbVar2;
  uchar uVar3;
  char cVar4;
  connection *conn;
  byte *pbVar5;
  uri *uri;
  socket_state sVar6;
  int local_a4;
  uint get;
  uchar *head;
  int *piVar7;
  uchar *name;
  char *pcVar8;
  cache_entry *cached;
  uchar *nonce;
  time_t seconds;
  byte *pbVar9;
  uchar *opaque;
  long seconds_00;
  byte bVar10;
  uint uVar11;
  progress *ppVar12;
  uchar *extraout_EDX;
  uchar *extraout_EDX_00;
  uri *uri_00;
  connection *p;
  uint extraout_EDX_01;
  byte *pbVar13;
  char *__needle;
  uint uVar14;
  byte *pbVar15;
  uchar **ppuVar16;
  stream_encoding encoding;
  bool bVar17;
  byte bVar18;
  int local_70;
  int local_6c;
  int local_50;
  int local_4c;
  uint local_48;
  undefined4 local_44;
  undefined4 local_40;
  timeval_T max_age;
  uchar *local_28;
  uchar *local_24;
  uchar *local_20 [4];
  
  bVar18 = 0;
  conn = (connection *)socket->conn;
  pbVar5 = (byte *)conn->info;
  uri = conn->proxied_uri;
  if ((conn->state).basic == S_PROC) {
    if (assert_failed != 0) goto LAB_080cf73f;
    local_48 = 7;
  }
  else {
    if (assert_failed == 0) {
      local_48 = 6;
      sVar6 = socket->state;
      goto joined_r0x080cfbc8;
    }
LAB_080cf73f:
    local_48 = 0xfffe795d;
  }
  sVar6 = socket->state;
joined_r0x080cfbc8:
  if (sVar6 == SOCKET_CLOSED) {
    assert_failed = 0;
    if ((conn->tries == 0) && (uri->host != (uchar *)0x0)) {
      if ((*pbVar5 & 2) == 0) {
        add_blacklist_entry(uri,SERVER_BLACKLIST_NO_CHARSET);
        conn->tries = -1;
      }
      else {
        del_blacklist_entry(uri,SERVER_BLACKLIST_NO_CHARSET);
      }
    }
    if (assert_failed == 0) {
      get = 0xfffe7959;
    }
    else {
      get = 0xfffe795d;
    }
    assert_failed = 0;
    retry_connection(conn,(connection_state)(ulonglong)get);
    return;
  }
  assert_failed = 0;
  src = rb->data;
  socket->state = SOCKET_RETRY_ONCLOSE;
  local_6c = 0;
  local_70 = 9;
  local_50 = 200;
LAB_080cf788:
  local_a4 = rb->length;
  if (local_a4 < 5) {
LAB_080cf790:
    local_4c = 0;
    if (0 < local_a4) {
      do {
        uVar3 = rb->data[local_4c];
        iVar1 = local_4c + 1;
        cVar4 = *(char *)(&rb->field_0xd + local_4c);
        if (uVar3 == '\0') {
          rb->data[local_4c] = ' ';
          local_a4 = rb->length;
        }
        else {
          if ((cVar4 == '\n') && (uVar3 == '\n')) {
            if (local_4c < local_a4 + -1) goto code_r0x080cf841;
          }
          else {
            if ((uVar3 == '\r') && ((local_4c < local_a4 + -3 && (cVar4 != '\r')))) {
              if (cVar4 != '\n') goto LAB_080cf916;
              if (*(char *)(&rb->field_0xe + local_4c) == '\r') {
                if (*(char *)(&rb->field_0xf + local_4c) != '\n') goto LAB_080cf916;
                local_4c = local_4c + 4;
                goto LAB_080cf847;
              }
            }
          }
        }
        local_4c = iVar1;
        if (local_a4 <= iVar1) break;
      } while( true );
    }
    goto LAB_080cf7bc;
  }
  local_a4 = c_strncasecmp((char *)src,"HTTP/",5);
  if (local_a4 == 0) {
    local_a4 = rb->length;
    goto LAB_080cf790;
  }
  goto LAB_080cf950;
LAB_080cfc8c:
  if (local_50 < 200) {
    mem_free(head);
    connection_state();
    abort_connection(conn,(connection_state)CONCAT44(local_40,local_44));
    return;
  }
  if (local_50 == 0x130) {
    mem_free(head);
    connection_state();
    http_end_request(conn,1);
    return;
  }
  if (local_50 == 0xcc) {
    mem_free(head);
    connection_state();
    http_end_request(conn,0);
    return;
  }
  if (local_50 == 200) {
    uri_00 = conn->uri;
    if (((uri_00->protocol == 0xf) && (conn->proxied_uri->protocol == 10)) &&
       (conn->socket->ssl == (void *)0x0)) {
      mem_free(head);
      *(byte *)&socket->field_0x24 = *(byte *)&socket->field_0x24 | 2;
      complete_connect_socket(socket,uri,http_send_header);
      return;
    }
  }
  else {
    uri_00 = conn->uri;
  }
  cached = get_cache_entry(uri_00);
  conn->cached = cached;
  if (cached == (cache_entry *)0x0) {
    mem_free(head);
LAB_080d0986:
    connection_state();
    abort_connection(conn,(connection_state)CONCAT44(local_40,local_44));
    return;
  }
  *(byte *)&cached->field_0x5c =
       *(byte *)&cached->field_0x5c & 0xbf | (byte)(((uint)*(byte *)&conn->field_0x78 & 8) << 3);
  cached = conn->cached;
  p = (connection *)cached->head;
  if (p != (connection *)0x0) {
    mem_free(p);
    cached = conn->cached;
    p = conn;
  }
  cached->head = head;
  piVar7 = get_opt_(config_options,(uchar *)p);
  if (*piVar7 == 0) {
    cached = conn->cached;
    local_24 = parse_header(cached->head,(uchar *)"Expires",(uchar **)0x0);
    if (local_24 != (uchar *)0x0) {
      seconds = parse_date(&local_24,(uchar *)0x0,0,1);
      mem_free(local_24);
      if ((seconds != 0) && (cached->cache_mode != CACHE_MODE_NEVER)) {
        timeval_from_seconds(&cached->max_age,seconds);
        *(byte *)&cached->field_0x5c = *(byte *)&cached->field_0x5c | 1;
      }
    }
    head = parse_header(cached->head,(uchar *)"Pragma",(uchar **)0x0);
    local_24 = head;
    if (head != (uchar *)0x0) {
      __needle = strstr((char *)head,"no-cache");
      if (__needle != (char *)0x0) {
        *(byte *)&cached->field_0x5c = *(byte *)&cached->field_0x5c & 0xfe;
        cached->cache_mode = CACHE_MODE_NEVER;
        head = local_24;
      }
      mem_free(head);
    }
    if ((cached->cache_mode != CACHE_MODE_NEVER) &&
       (head = parse_header(cached->head,(uchar *)"Cache-Control",(uchar **)0x0), local_24 = head,
       head != (uchar *)0x0)) {
      __needle = strstr((char *)head,"no-cache");
      if ((__needle == (char *)0x0) &&
         (__needle = strstr((char *)head,"must-revalidate"), __needle == (char *)0x0)) {
        __needle = strstr((char *)head,"max-age=");
        if ((assert_failed == 0) &&
           (bVar17 = cached->cache_mode == CACHE_MODE_NEVER, assert_failed = ZEXT14(bVar17), bVar17)
           ) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/http.c";
          errline = 0x683;
          elinks_internal((uchar *)"assertion cached->cache_mode != CACHE_MODE_NEVER failed!");
        }
        if (__needle != (char *)0x0) {
          seconds_00 = strtol(__needle + 8,(char **)0x0,10);
          timeval_from_seconds(&max_age,seconds_00);
          timeval_now(&cached->max_age);
          timeval_add_interval(&cached->max_age,&max_age);
          *(byte *)&cached->field_0x5c = *(byte *)&cached->field_0x5c | 1;
        }
      }
      else {
        *(byte *)&cached->field_0x5c = *(byte *)&cached->field_0x5c & 0xfe;
        cached->cache_mode = CACHE_MODE_NEVER;
      }
      mem_free(local_24);
    }
  }
  if (((((local_50 == 0x12d) || (local_50 == 0xc9)) || (local_50 == 0x12e)) ||
      ((local_50 == 0x12f || (local_50 == 0x133)))) &&
     (local_24 = parse_header(conn->cached->head,(uchar *)"Location",(uchar **)0x0),
     local_24 != (uchar *)0x0)) {
    get = (uint)(local_50 == 0x12f);
    if ((local_50 == 0x12e) &&
       (piVar7 = get_opt_(config_options,(uchar *)(extraout_EDX_01 & 0xffffff00 | get)),
       *piVar7 != 0)) {
      get = 1;
    }
    redirect_cache(conn->cached,local_24,get,-1);
    mem_free(local_24);
  }
  if (local_50 == 0x191) {
    head = parse_header(conn->cached->head,(uchar *)"WWW-Authenticate",&local_28);
    while (head != (uchar *)0x0) {
      local_a4 = c_strncasecmp((char *)head,"Basic",5);
      if (local_a4 != 0) {
        local_a4 = c_strncasecmp((char *)head,"Digest",6);
        if (local_a4 == 0) {
          name = get_header_param(head,(uchar *)"realm");
          nonce = get_header_param(head,(uchar *)"nonce");
          opaque = get_header_param(head,(uchar *)"opaque");
          add_auth_entry(uri,name,nonce,opaque,1);
          if (name != (uchar *)0x0) {
            mem_free(name);
          }
          if (nonce != (uchar *)0x0) {
            mem_free(nonce);
          }
          if (opaque != (uchar *)0x0) {
            mem_free(opaque);
          }
          mem_free(head);
        }
        else {
          local_a4 = c_strncasecmp((char *)head,"GSS-Negotiate",0xe);
          if (local_a4 == 0) {
            local_a4 = 1;
          }
          else {
            local_a4 = c_strncasecmp((char *)head,"Negotiate",10);
            if (local_a4 != 0) goto LAB_080d0698;
            local_a4 = 2;
          }
          local_a4 = http_negotiate_input(conn,uri,local_a4,local_28);
          mem_free(head);
          if (local_a4 == 0) goto LAB_080d077e;
        }
        break;
      }
      name = get_header_param(head,(uchar *)"realm");
      if (name != (uchar *)0x0) {
        add_auth_entry(uri,name,(uchar *)0x0,(uchar *)0x0,0);
        mem_free(name);
        mem_free(head);
        break;
      }
LAB_080d0698:
      mem_free(head);
      head = parse_header(local_28,(uchar *)"WWW-Authenticate",&local_28);
    }
  }
  else {
    if (local_50 == 0x197) {
      local_24 = parse_header(conn->cached->head,(uchar *)"Proxy-Authenticate",&local_28);
      while (local_24 != (uchar *)0x0) {
        local_a4 = c_strncasecmp((char *)local_24,"Basic",5);
        if (local_a4 == 0) {
          head = get_header_param(local_24,(uchar *)"realm");
          if (head != (uchar *)0x0) {
            if (proxy_auth.realm != (uchar *)0x0) {
              mem_free(proxy_auth.realm);
            }
            proxy_auth._112_1_ = proxy_auth._112_1_ & 0xfb;
            proxy_auth.realm = head;
            mem_free(local_24);
            break;
          }
        }
        else {
          local_a4 = c_strncasecmp((char *)local_24,"Digest",6);
          if (local_a4 == 0) {
            head = get_header_param(local_24,(uchar *)"realm");
            name = get_header_param(local_24,(uchar *)"nonce");
            nonce = get_header_param(local_24,(uchar *)"opaque");
            if (proxy_auth.realm != (uchar *)0x0) {
              mem_free(proxy_auth.realm);
            }
            proxy_auth.realm = head;
            if (proxy_auth.nonce != (uchar *)0x0) {
              mem_free(proxy_auth.nonce);
            }
            proxy_auth.nonce = name;
            if (proxy_auth.opaque != (uchar *)0x0) {
              mem_free(proxy_auth.opaque);
            }
            proxy_auth._112_1_ = proxy_auth._112_1_ | 4;
            proxy_auth.opaque = nonce;
            mem_free(local_24);
            break;
          }
        }
        mem_free(local_24);
        local_24 = parse_header(local_28,(uchar *)"Proxy-Authenticate",&local_28);
      }
    }
  }
  kill_buffer_data(rb,local_4c);
  *(undefined4 *)(pbVar5 + 0x14) = 0;
  *(undefined4 *)(pbVar5 + 0x18) = 0xffffffff;
  *(int *)(pbVar5 + 8) = local_70;
  *(int *)(pbVar5 + 4) = local_6c;
  local_24 = parse_header(conn->cached->head,"Connection",(uchar **)0x0);
  if ((local_24 == (uchar *)0x0) &&
     (local_24 = parse_header(conn->cached->head,(uchar *)"Proxy-Connection",(uchar **)0x0),
     local_24 == (uchar *)0x0)) {
    if ((local_6c < 1) || ((local_6c == 1 && (local_70 == 0)))) {
      *(undefined4 *)(pbVar5 + 0x14) = 1;
    }
  }
  else {
    local_a4 = c_strcasecmp((char *)local_24,"close");
    if (local_a4 == 0) {
      *(undefined4 *)(pbVar5 + 0x14) = 1;
    }
    mem_free(local_24);
  }
  get = *(uint *)&conn->from;
  *(undefined4 *)&conn->from = 0;
  *(undefined4 *)((int)&conn->from + 4) = 0;
  local_24 = parse_header(conn->cached->head,(uchar *)"Content-Range",(uchar **)0x0);
  if (local_24 != (uchar *)0x0) {
    uVar11 = 0xffffffff;
    head = local_24;
    do {
      if (uVar11 == 0) break;
      uVar11 = uVar11 - 1;
      uVar3 = *head;
      head = head + (uint)bVar18 * -2 + 1;
    } while (uVar3 != '\0');
    if (((6 < ~uVar11 - 1) && (local_24[5] = '\0', (byte)(local_24[6] - 0x30) < 10)) &&
       (local_a4 = c_strcasecmp((char *)local_24,"bytes"), local_a4 == 0)) {
      piVar7 = __errno_location();
      *piVar7 = 0;
      seconds_00 = strtol((char *)(local_24 + 6),(char **)0x0,10);
      if ((*piVar7 == 0) && (-1 < seconds_00)) {
        *(long *)&conn->from = seconds_00;
        *(int *)((int)&conn->from + 4) = seconds_00 >> 0x1f;
      }
    }
    mem_free(local_24);
  }
  if (get == 0) {
    uVar11 = *(uint *)&conn->from;
    uVar14 = *(uint *)((int)&conn->from + 4);
  }
  else {
    uVar14 = *(uint *)((int)&conn->from + 4);
    uVar11 = *(uint *)&conn->from;
    if (((uVar14 | uVar11) == 0) && ((*(byte *)&conn->field_0x78 & 2) == 0)) {
      *(byte *)&conn->field_0x78 = *(byte *)&conn->field_0x78 | 2;
    }
  }
  ppVar12 = conn->progress;
  local_a4 = *(int *)((int)&ppVar12->start + 4);
  if ((((local_a4 < 1) && ((local_a4 < 0 || (*(int *)&ppVar12->start == 0)))) &&
      (((int)get >> 0x1f < (int)uVar14 || (((int)get >> 0x1f <= (int)uVar14 && (get < uVar11))))))
     || ((int)uVar14 < 0)) {
    connection_state();
    abort_connection(conn,(connection_state)CONCAT44(local_40,local_44));
    return;
  }
  if (-1 < local_a4) {
    *(uint *)&ppVar12->seek = uVar11;
    *(uint *)((int)&ppVar12->seek + 4) = uVar14;
    ppVar12 = conn->progress;
    uVar11 = *(uint *)&conn->from;
    uVar14 = *(uint *)((int)&conn->from + 4);
  }
  *(uint *)&ppVar12->start = uVar11;
  *(uint *)((int)&ppVar12->start + 4) = uVar14;
  local_24 = parse_header(conn->cached->head,(uchar *)"Content-Length",(uchar **)0x0);
  if (local_24 != (uchar *)0x0) {
    piVar7 = __errno_location();
    *piVar7 = 0;
    get = strtol((char *)local_24,(char **)&local_28,10);
    if (((*piVar7 == 0) && (-1 < (int)get)) && (*local_28 == '\0')) {
      if (((*(int *)(pbVar5 + 0x14) == 0) || (1 < local_6c)) || ((local_6c == 1 && (0 < local_70))))
      {
        *(uint *)(pbVar5 + 0x18) = get;
      }
      local_a4 = *(int *)((int)&conn->from + 4);
      *(uint *)&conn->est_length = get + *(int *)&conn->from;
      *(int *)((int)&conn->est_length + 4) =
           ((int)get >> 0x1f) + local_a4 + (uint)CARRY4(get,*(uint *)&conn->from);
    }
    mem_free(local_24);
  }
  if ((*(byte *)&conn->field_0x78 & 2) == 0) {
    local_24 = parse_header(conn->cached->head,(uchar *)"Accept-Ranges",(uchar **)0x0);
    if (local_24 == (uchar *)0x0) {
      if ((*(uint *)((int)&conn->from + 4) | *(uint *)&conn->from) == 0) {
        *(byte *)&conn->field_0x78 = *(byte *)&conn->field_0x78 | 2;
      }
    }
    else {
      local_a4 = c_strcasecmp((char *)local_24,"none");
      if (local_a4 == 0) {
        *(byte *)&conn->field_0x78 = *(byte *)&conn->field_0x78 | 2;
      }
      mem_free(local_24);
    }
  }
  local_24 = parse_header(conn->cached->head,(uchar *)"Transfer-Encoding",(uchar **)0x0);
  if (local_24 != (uchar *)0x0) {
    local_a4 = c_strcasecmp((char *)local_24,"chunked");
    if (local_a4 == 0) {
      *(undefined4 *)(pbVar5 + 0x18) = 0xfffffffe;
      *(undefined4 *)(pbVar5 + 0x1c) = 0xffffffff;
    }
    mem_free(local_24);
  }
  if ((*(int *)(pbVar5 + 0x14) == 0) && (*(int *)(pbVar5 + 0x18) == -1)) {
    *(undefined4 *)(pbVar5 + 0x14) = 1;
  }
  local_24 = parse_header(conn->cached->head,(uchar *)"Last-Modified",(uchar **)0x0);
  if (local_24 != (uchar *)0x0) {
    cached = conn->cached;
    if (cached->last_modified != (uchar *)0x0) {
      local_a4 = c_strcasecmp((char *)cached->last_modified,(char *)local_24);
      if ((local_a4 != 0) &&
         (delete_entry_content(conn->cached),
         (*(uint *)((int)&conn->from + 4) | *(uint *)&conn->from) != 0)) {
        *(undefined4 *)&conn->from = 0;
        *(undefined4 *)((int)&conn->from + 4) = 0;
        mem_free(local_24);
        connection_state();
        retry_connection(conn,(connection_state)CONCAT44(local_40,local_44));
        return;
      }
      cached = conn->cached;
      if (cached->last_modified != (uchar *)0x0) {
        mem_free(local_24);
        goto LAB_080d00ad;
      }
    }
    cached->last_modified = local_24;
  }
LAB_080d00ad:
  cached = conn->cached;
  if (cached->last_modified == (uchar *)0x0) {
    local_24 = parse_header(cached->head,"Date",(uchar **)0x0);
    if (local_24 == (uchar *)0x0) {
      cached = conn->cached;
    }
    else {
      conn->cached->last_modified = local_24;
      cached = conn->cached;
    }
  }
  head = parse_header(cached->head,"ETag",(uchar **)0x0);
  local_24 = head;
  if (head != (uchar *)0x0) {
    cached = conn->cached;
    name = cached->etag;
    if (name == (uchar *)0x0) {
LAB_080d0350:
      cached->etag = local_24;
    }
    else {
      nonce = head;
      if ((*head == 'W') && (head[1] == '/')) {
        nonce = head + 2;
      }
      if ((*name == 'W') && (name[1] == '/')) {
        name = name + 2;
      }
      local_a4 = strcmp((char *)nonce,(char *)name);
      if (local_a4 != 0) {
        delete_entry_content(cached);
        if ((*(uint *)((int)&conn->from + 4) | *(uint *)&conn->from) != 0) {
          *(undefined4 *)&conn->from = 0;
          *(undefined4 *)((int)&conn->from + 4) = 0;
          mem_free(local_24);
LAB_080d077e:
          connection_state();
          retry_connection(conn,(connection_state)CONCAT44(local_40,local_44));
          return;
        }
        cached = conn->cached;
        head = local_24;
        if (cached->etag == (uchar *)0x0) goto LAB_080d0350;
      }
      mem_free(head);
    }
  }
  local_24 = parse_header(conn->cached->head,(uchar *)"Content-Encoding",(uchar **)0x0);
  if (local_24 == (uchar *)0x0) goto LAB_080d01da;
  encoding = ENCODING_NONE;
  head = get_extension_from_uri(uri);
  if (head == (uchar *)0x0) {
LAB_080d02fc:
    local_a4 = c_strcasecmp((char *)local_24,"gzip");
    if ((local_a4 == 0) || (local_a4 = c_strcasecmp((char *)local_24,"x-gzip"), local_a4 == 0)) {
      conn->content_encoding = ENCODING_GZIP;
    }
  }
  else {
    encoding = guess_encoding(head);
    mem_free(head);
    if (encoding != ENCODING_GZIP) goto LAB_080d02fc;
  }
  local_a4 = c_strcasecmp((char *)local_24,"deflate");
  if ((local_a4 == 0) || (local_a4 = c_strcasecmp((char *)local_24,"x-deflate"), local_a4 == 0)) {
    conn->content_encoding = ENCODING_DEFLATE;
  }
  if ((encoding != ENCODING_BZIP2) &&
     ((local_a4 = c_strcasecmp((char *)local_24,"bzip2"), local_a4 == 0 ||
      (local_a4 = c_strcasecmp((char *)local_24,"x-bzip2"), local_a4 == 0)))) {
    conn->content_encoding = ENCODING_BZIP2;
  }
  mem_free(local_24);
LAB_080d01da:
  encoding = conn->content_encoding;
  if (encoding != ENCODING_NONE) {
    cached = conn->cached;
    if (cached->encoding_info != (uchar *)0x0) {
      mem_free(cached->encoding_info);
      cached = conn->cached;
      encoding = conn->content_encoding;
    }
    head = get_encoding_name(encoding);
    head = stracpy(head);
    cached->encoding_info = head;
  }
  if ((*(int *)(pbVar5 + 0x18) == -1) || (*(int *)(pbVar5 + 0x14) != 0)) {
    socket->state = SOCKET_END_ONCLOSE;
  }
  read_http_data(socket,rb);
  return;
code_r0x080cf841:
  local_4c = local_4c + 2;
LAB_080cf847:
  if (local_4c == -1) {
LAB_080cf916:
    if (assert_failed == 0) {
      get = 0xfffe78fc;
    }
    else {
      get = 0xfffe795d;
    }
    assert_failed = 0;
    abort_connection(conn,(connection_state)(ulonglong)get);
    return;
  }
  if (local_4c == 0) {
LAB_080cf7bc:
    read_from_socket(conn->socket,rb,(connection_state)(ulonglong)local_48,http_got_header);
    return;
  }
  if (local_4c == -2) {
LAB_080cf950:
    local_4c = 0;
LAB_080cf957:
    if (local_50 == 0x65) goto LAB_080cf896;
    if (local_4c == 0) {
      head = stracpy((uchar *)"\r\nContent-Type: text/html\r\n");
      name = extraout_EDX_00;
    }
    else {
      head = memacpy(src,local_4c);
      name = extraout_EDX;
    }
    if (head != (uchar *)0x0) {
      piVar7 = get_opt_(config_options,name);
      if (((*piVar7 == 0) || ((*(int *)(pbVar5 + 0xc) == 1 && (*(int *)(pbVar5 + 0x10) == 0)))) ||
         (name = parse_header(head,(uchar *)"Server",(uchar **)0x0), name == (uchar *)0x0)) {
LAB_080cfa38:
        local_a4 = uri->protocol;
      }
      else {
        __needle = "mod_czech/3.1.0";
        ppuVar16 = buggy_servers;
        do {
          pcVar8 = strstr((char *)name,__needle);
          if (pcVar8 != (char *)0x0) {
            add_blacklist_entry(uri,SERVER_BLACKLIST_HTTP10);
            mem_free(name);
            if ((uchar *)__needle != (uchar *)0x0) {
              mem_free(head);
              if (assert_failed == 0) {
                get = 0xfffe7955;
              }
              else {
                get = 0xfffe795d;
              }
              assert_failed = 0;
              retry_connection(conn,(connection_state)(ulonglong)get);
              return;
            }
            goto LAB_080cfa38;
          }
          ppuVar16 = ppuVar16 + 1;
          __needle = (char *)*ppuVar16;
        } while ((uchar *)__needle != (uchar *)0x0);
        mem_free(name);
        local_a4 = uri->protocol;
      }
      name = head;
      if ((local_a4 == 4) &&
         (local_24 = parse_header(head,(uchar *)"Status",(uchar **)0x0), local_24 != (uchar *)0x0))
      {
        seconds_00 = strtol((char *)local_24,(char **)0x0,10);
        mem_free(local_24);
        if ((seconds_00 - 100U < 500) && (local_50 = seconds_00, seconds_00 == 0x65)) {
          mem_free(head);
          goto LAB_080d0986;
        }
      }
      while (local_20[0] = name, name = parse_header(local_20[0],(uchar *)"Set-Cookie",local_20),
            name != (uchar *)0x0) {
        set_cookie(uri,name);
        mem_free(name);
        name = local_20[0];
      }
      *(int *)(pbVar5 + 0x20) = local_50;
      if (local_50 != 100) goto LAB_080cfc8c;
      mem_free(head);
      if (assert_failed == 0) {
        local_48 = 7;
      }
      else {
        local_48 = 0xfffe795d;
      }
      assert_failed = 0;
      kill_buffer_data(rb,local_4c);
      goto LAB_080cf788;
    }
    if (assert_failed == 0) {
      get = 0xfffe795c;
      goto LAB_080cf8b2;
    }
  }
  else {
    bVar10 = rb->data[0];
    pbVar13 = src;
    while (bVar10 == 0x20) {
      pbVar13 = pbVar13 + 1;
      bVar10 = *pbVar13;
    }
    local_a4 = c_toupper((uint)bVar10);
    if ((((local_a4 == 0x48) && (local_a4 = c_toupper((uint)pbVar13[1]), local_a4 == 0x54)) &&
        (local_a4 = c_toupper((uint)pbVar13[2]), local_a4 == 0x54)) &&
       ((local_a4 = c_toupper((uint)pbVar13[3]), local_a4 == 0x50 && (pbVar13[4] == 0x2f)))) {
      pbVar13 = pbVar13 + 5;
      pbVar9 = pbVar13;
      while ((bVar10 = *pbVar9, bVar10 != 0x2e && (bVar10 != 0))) {
        pbVar9 = pbVar9 + 1;
      }
      if ((((pbVar13 != pbVar9) && (bVar10 != 0)) && ((int)(pbVar9 + -(int)pbVar13) < 5)) &&
         (pbVar2 = pbVar9 + 1, (byte)(pbVar9[1] - 0x30) < 10)) {
        local_6c = 0;
        local_50 = 1;
        pbVar15 = pbVar9;
        while( true ) {
          pbVar15 = pbVar15 + -1;
          if (9 < (byte)(*pbVar15 - 0x30)) goto LAB_080cf896;
          local_6c = local_6c + ((uint)*pbVar15 - 0x30) * local_50;
          if (pbVar15 <= pbVar13) break;
          local_50 = local_50 * 10;
        }
        while ((bVar10 != 0x20 && (bVar10 != 0))) {
          pbVar9 = pbVar9 + 1;
          bVar10 = *pbVar9;
        }
        if (((pbVar2 != pbVar9) && (bVar10 != 0)) && ((int)(pbVar9 + -(int)pbVar2) < 5)) {
          local_a4 = 1;
          local_70 = 0;
          pbVar13 = pbVar9;
          while( true ) {
            pbVar13 = pbVar13 + -1;
            if (9 < (byte)(*pbVar13 - 0x30)) goto LAB_080cf896;
            local_70 = local_70 + ((uint)*pbVar13 - 0x30) * local_a4;
            if (pbVar13 <= pbVar2) break;
            local_a4 = local_a4 * 10;
          }
          while (bVar10 == 0x20) {
            pbVar9 = pbVar9 + 1;
            bVar10 = *pbVar9;
          }
          if ((((byte)(bVar10 - 0x31) < 9) && ((byte)(pbVar9[1] - 0x30) < 10)) &&
             ((byte)(pbVar9[2] - 0x30) < 10)) {
            local_50 = (uint)bVar10 * 100 + -0x14d0 + (uint)pbVar9[2] + (uint)pbVar9[1] * 10;
            goto LAB_080cf957;
          }
        }
      }
    }
LAB_080cf896:
    if (assert_failed == 0) {
      get = 0xfffe78fc;
      goto LAB_080cf8b2;
    }
  }
  get = 0xfffe795d;
LAB_080cf8b2:
  assert_failed = 0;
  abort_connection(conn,(connection_state)(ulonglong)get);
  return;
}



uchar * subst_user_agent(uchar *fmt,uchar *version,uchar *sysname,uchar *termsize)

{
  int iVar1;
  byte bVar2;
  uint uVar3;
  char cVar4;
  string *psVar5;
  uint uVar6;
  uchar *source;
  size_t sVar7;
  int iVar8;
  uint size;
  undefined2 *puVar9;
  size_t __n;
  string agent;
  uint local_24;
  uchar bs [4];
  
  psVar5 = init_string(&agent);
  if (psVar5 == (string *)0x0) {
    return (uchar *)0x0;
  }
  do {
    cVar4 = *fmt;
    do {
      do {
        if (cVar4 == '\0') {
          return agent.source;
        }
        sVar7 = 0;
        __n = 0;
        puVar9 = (undefined2 *)fmt;
        if (cVar4 != '%') {
          do {
            sVar7 = sVar7 + 1;
            puVar9 = (undefined2 *)(sVar7 + (int)fmt);
            __n = sVar7;
            if (*(char *)((int)fmt + sVar7) == '%') break;
          } while (*(char *)((int)fmt + sVar7) != '\0');
        }
        if (assert_failed == 0) {
          if ((int)__n < 0) {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
            errline = 0xff;
            elinks_internal((uchar *)
                            "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                           );
            if (assert_failed != 0) goto LAB_080d0f92;
          }
          else {
            assert_failed = 0;
          }
          if (__n != 0) {
            iVar8 = __n + agent.length;
            uVar3 = agent.length + 0xffU >> 8;
            uVar6 = agent.length + 0xffU & 0xffffff00;
            size = iVar8 + 0x100U & 0xffffff00;
            if (uVar6 <= size && size + uVar3 * -0x100 != 0) {
              source = (uchar *)mem_realloc(agent.source,size);
              if (source == (uchar *)0x0) goto LAB_080d0fa0;
              agent.source = source;
              memset(source + uVar6,0,size + uVar3 * -0x100);
            }
            if (agent.source != (uchar *)0x0) {
              memcpy(agent.source + agent.length,fmt,__n);
              agent.source[iVar8] = '\0';
              agent.length = iVar8;
            }
          }
        }
        else {
LAB_080d0f92:
          assert_failed = 0;
        }
LAB_080d0fa0:
        iVar8 = agent.length;
        cVar4 = *(char *)puVar9;
        fmt = (uchar *)puVar9;
      } while (cVar4 != '%');
      bVar2 = *(byte *)((int)puVar9 + 1);
      fmt = (uchar *)((int)puVar9 + 1);
      if (bVar2 == 0x73) {
        add_to_string(&agent,sysname);
        cVar4 = *(char *)((int)puVar9 + 1);
      }
      else {
        if (bVar2 < 0x74) {
          if (bVar2 != 0x62) {
LAB_080d0fc6:
            if (assert_failed != 0) {
              assert_failed = 0;
              cVar4 = *fmt;
              goto LAB_080d1108;
            }
            assert_failed = 0;
            size = agent.length + 0x102U & 0xffffff00;
            uVar3 = agent.length + 0xffU >> 8;
            uVar6 = agent.length + 0xffU & 0xffffff00;
            iVar1 = agent.length + 2;
            if (size < uVar6 || size + uVar3 * -0x100 == 0) {
LAB_080d1001:
              if (agent.source != (uchar *)0x0) {
                *(undefined2 *)(agent.source + agent.length) = *puVar9;
                agent.source[iVar8 + 2] = '\0';
                agent.length = iVar1;
              }
            }
            else {
              source = (uchar *)mem_realloc(agent.source,size);
              if (source != (uchar *)0x0) {
                agent.source = source;
                memset(source + uVar6,0,size + uVar3 * -0x100);
                goto LAB_080d1001;
              }
            }
            cVar4 = *fmt;
            goto LAB_080d1108;
          }
          if ((list_head_elinks *)sessions.next == &sessions) break;
          local_24 = 0;
          bs = 0;
          bVar2 = *(byte *)((int)sessions.prev + 0xa8);
          elinks_ulongcat(bs,&local_24,
                          ((uint)bVar2 & 1) + ((uint)(bVar2 >> 1) & 1) + ((uint)(bVar2 >> 2) & 1),
                          '\x02',0,10);
          source = bs;
        }
        else {
          if (bVar2 == 0x74) {
            source = termsize;
            if (termsize == (uchar *)0x0) break;
          }
          else {
            source = version;
            if (bVar2 != 0x76) goto LAB_080d0fc6;
          }
        }
        add_to_string(&agent,source);
        cVar4 = *fmt;
      }
LAB_080d1108:
    } while (cVar4 == '\0');
    fmt = (uchar *)(puVar9 + 1);
  } while( true );
}



// WARNING: Could not reconcile some variable overlaps

void http_send_header(socket *socket)

{
  byte bVar1;
  undefined2 uVar2;
  connection *conn;
  uri *uri;
  bool bVar3;
  void *pvVar4;
  int iVar5;
  int *piVar6;
  http_connection_info *name;
  string *from;
  uchar **ppuVar7;
  char **ppcVar8;
  uchar *source;
  uchar *name_00;
  size_t sVar9;
  uint size;
  uint uVar10;
  undefined4 *puVar11;
  size_t sVar12;
  auth_entry *entry;
  cache_entry *pcVar13;
  int cp_index;
  char cVar14;
  uchar *extraout_EDX;
  uchar *name_01;
  uchar *extraout_EDX_00;
  uchar *extraout_EDX_01;
  uchar *extraout_EDX_02;
  uchar *extraout_EDX_03;
  uchar *name_02;
  http_connection_info *name_03;
  uchar *name_04;
  uchar *extraout_EDX_04;
  uchar *extraout_EDX_05;
  uchar *extraout_EDX_06;
  http_connection_info *extraout_EDX_07;
  http_connection_info *extraout_EDX_08;
  uchar *name_05;
  uri *uri_00;
  byte *__s;
  undefined4 *puVar15;
  char cVar16;
  undefined4 *puVar17;
  int in_GS_OFFSET;
  bool bVar18;
  byte bVar19;
  connection *local_108c;
  char *local_1088;
  uint local_1050;
  string ac;
  string header;
  void *local_1024;
  uchar ts [64];
  int local_20;
  
  bVar19 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  conn = (connection *)socket->conn;
  local_1088 = "protocol.http.trace";
  piVar6 = get_opt_(config_options,(uchar *)0x0);
  uri = conn->proxied_uri;
  cp_index = *piVar6;
  if ((((uri == (uri *)0x0) || (uri->host == (uchar *)0x0)) || (*uri->host == '\0')) ||
     (*(short *)&uri->field_0x2e == 0)) {
    assert_failed = 0;
    local_108c = (connection *)0x0;
    http_end_request(conn,0);
    goto LAB_080d12de;
  }
  local_1088 = (char *)0x1;
  local_108c = conn;
  name = init_http_connection_info(conn,1,1,0);
  if (name == (http_connection_info *)0x0) goto LAB_080d12de;
  from = init_string(&header);
  if (from == (string *)0x0) {
    connection_state();
    local_108c = (connection *)0x0;
    http_end_request(conn,0);
    goto LAB_080d12de;
  }
  if (conn->cached == (cache_entry *)0x0) {
    pcVar13 = find_in_cache(uri);
    conn->cached = pcVar13;
  }
  bVar18 = false;
  if (((conn->uri->protocol != 0xf) ||
      (bVar18 = conn->socket->ssl == (void *)0x0, conn->proxied_uri->protocol != 10)) ||
     (bVar3 = true, !bVar18)) {
    bVar3 = false;
  }
  if (cp_index == 0) {
    if (bVar3) {
      add_to_string(&header,(uchar *)"CONNECT ");
    }
    else {
      if (uri->post == (uchar *)0x0) {
        add_to_string(&header,"GET ");
      }
      else {
        add_to_string(&header,(uchar *)"POST ");
        *(byte *)&conn->field_0x78 = *(byte *)&conn->field_0x78 | 2;
      }
    }
  }
  else {
    add_to_string(&header,(uchar *)"TRACE ");
  }
  if (!bVar18) {
    add_char_to_string(&header,'/');
  }
  if (bVar3) {
    add_uri_to_string(&header,uri,URI_HTTP_CONNECT);
LAB_080d202a:
    add_to_string(&header," HTTP/");
    add_long_to_string(&header,(name->sent_version).major);
    add_char_to_string(&header,'.');
    add_long_to_string(&header,(name->sent_version).minor);
    add_crlf_to_string(&header);
    add_to_string(&header,(uchar *)"Host: ");
    add_uri_to_string(&header,uri,URI_HTTP_HOST);
    add_crlf_to_string(&header);
    name_00 = extraout_EDX_06;
    if (bVar18) {
LAB_080d14b6:
      ppuVar7 = (uchar **)get_opt_(config_options,name_00);
      name_00 = *ppuVar7;
      ppcVar8 = (char **)get_opt_(config_options,name_01);
      local_1088 = *ppcVar8;
      if ((proxy_auth._112_1_ & 4) == 0) {
        if ((*name_00 != '\0') &&
           (source = straconcat(name_00,0x812bbab,local_1088,0), name_00 = extraout_EDX_00,
           source != (uchar *)0x0)) {
          name_00 = base64_encode(source);
          if (name_00 != (uchar *)0x0) {
            add_to_string(&header,(uchar *)"Proxy-Authorization: Basic ");
            add_to_string(&header,name_00);
            add_crlf_to_string(&header);
            mem_free(name_00);
          }
          mem_free(source);
          name_00 = extraout_EDX_01;
        }
      }
      else {
        sVar9 = strlen((char *)name_00);
        if (0x26 < (int)sVar9) {
          sVar9 = 0x27;
        }
        sVar12 = strlen(local_1088);
        if (0x26 < (int)sVar12) {
          sVar12 = 0x27;
        }
        if (sVar9 != 0) {
          __memcpy_chk(0x814f000,name_00,sVar9,0x54);
        }
        proxy_auth.user[sVar9] = '\0';
        if (sVar12 != 0) {
          __memcpy_chk(0x814f028,local_1088,sVar12,0x2c);
        }
        proxy_auth.password[sVar12] = '\0';
        source = get_http_auth_digest_response(&proxy_auth,uri);
        name_00 = extraout_EDX_04;
        if (source != (uchar *)0x0) {
          add_to_string(&header,(uchar *)"Proxy-Authorization: Digest ");
          add_to_string(&header,source);
          add_crlf_to_string(&header);
          mem_free(source);
          name_00 = extraout_EDX_05;
        }
      }
    }
  }
  else {
    if (((conn->uri->protocol == 0xf) && (conn->proxied_uri->protocol == 10)) &&
       (conn->socket->ssl != (void *)0x0)) {
      add_url_to_http_string(&header,uri,0x80);
      goto LAB_080d202a;
    }
    if (bVar18) {
      add_url_to_http_string(&header,uri,-0x7741);
      add_to_string(&header," HTTP/");
      add_long_to_string(&header,(name->sent_version).major);
      add_char_to_string(&header,'.');
      add_long_to_string(&header,(name->sent_version).minor);
      add_crlf_to_string(&header);
      add_to_string(&header,(uchar *)"Host: ");
      add_uri_to_string(&header,uri,URI_HTTP_HOST);
      add_crlf_to_string(&header);
      name_00 = extraout_EDX;
      goto LAB_080d14b6;
    }
    add_url_to_http_string(&header,conn->uri,0x80);
    add_to_string(&header," HTTP/");
    add_long_to_string(&header,(name->sent_version).major);
    add_char_to_string(&header,'.');
    add_long_to_string(&header,(name->sent_version).minor);
    add_crlf_to_string(&header);
    add_to_string(&header,(uchar *)"Host: ");
    add_uri_to_string(&header,uri,URI_HTTP_HOST);
    add_crlf_to_string(&header);
    name_00 = extraout_EDX_02;
  }
  ppuVar7 = (uchar **)get_opt_(config_options,name_00);
  name_00 = *ppuVar7;
  if ((*name_00 != '\0') && ((*name_00 != ' ' || (name_00[1] != '\0')))) {
    cp_index = 0xf;
    puVar15 = (undefined4 *)(ts + 4);
    while (cp_index != 0) {
      cp_index = cp_index + -1;
      *puVar15 = 0;
      puVar15 = puVar15 + (uint)bVar19 * 0x3ffffffe + 1;
    }
    ts._0_4_ = (void *)0x0;
    add_to_string(&header,(uchar *)"User-Agent: ");
    pvVar4 = terminals.prev;
    if ((list_head_elinks *)terminals.next != &terminals) {
      local_1024 = (void *)0x0;
      elinks_ulongcat(ts,(uint *)&local_1024,*(uint *)((int)terminals.prev + 0x2c),'\x03',0,10);
      ts[(int)local_1024] = 'x';
      local_1024 = (void *)((int)local_1024 + 1);
      elinks_ulongcat(ts,(uint *)&local_1024,*(uint *)((int)pvVar4 + 0x30),'\x03',0,10);
    }
    name_00 = subst_user_agent(name_00,"0.12pre5",system_name,ts);
    if (name_00 != (uchar *)0x0) {
      add_to_string(&header,name_00);
      mem_free(name_00);
    }
    add_crlf_to_string(&header);
    name_00 = extraout_EDX_03;
  }
  if (!bVar3) {
    piVar6 = get_opt_(config_options,name_00);
    cp_index = *piVar6;
    if (cp_index == 2) {
      ppuVar7 = (uchar **)get_opt_(config_options,name_05);
      name_00 = *ppuVar7;
      if (*name_00 != '\0') {
        add_to_string(&header,(uchar *)"Referer: ");
        add_to_string(&header,name_00);
        add_crlf_to_string(&header);
      }
    }
    else {
      if (cp_index == 3) {
        if (conn->referrer != (uri *)0x0) {
          add_to_string(&header,(uchar *)"Referer: ");
          uri_00 = conn->referrer;
          goto LAB_080d2287;
        }
      }
      else {
        if (cp_index == 1) {
          add_to_string(&header,(uchar *)"Referer: ");
          uri_00 = uri;
LAB_080d2287:
          add_url_to_http_string(&header,uri_00,0xb1);
          add_crlf_to_string(&header);
        }
      }
    }
  }
  add_to_string(&header,(uchar *)"Accept: */*");
  add_crlf_to_string(&header);
  piVar6 = get_opt_(config_options,name_02);
  if (*piVar6 != 0) {
    add_to_string(&header,(uchar *)"Accept-Encoding: ");
    add_to_string(&header,(uchar *)"bzip2");
    add_to_string(&header,", ");
    add_to_string(&header,(uchar *)"deflate, gzip");
    add_crlf_to_string(&header);
  }
  if ((accept_charset == (uchar *)0x0) && (from = init_string(&ac), from != (string *)0x0)) {
    cp_index = 0;
    while (name_00 = get_cp_mime_name(cp_index), name_00 != (uchar *)0x0) {
      if (ac.length == 0) {
        add_to_string(&ac,(uchar *)"Accept-Charset: ");
      }
      else {
        add_to_string(&ac,", ");
      }
      cp_index = cp_index + 1;
      add_to_string(&ac,name_00);
    }
    cp_index = 0;
    if (ac.length != 0) {
      add_crlf_to_string(&ac);
      cp_index = ac.length;
    }
    accept_charset = memacpy(ac.source,cp_index);
    done_string(&ac);
  }
  name_03 = name;
  if ((((*(byte *)&name->bl_flags & 2) == 0) &&
      (piVar6 = get_opt_(config_options,(uchar *)name), name_03 = extraout_EDX_07, *piVar6 == 0)) &&
     (accept_charset != (uchar *)0x0)) {
    add_to_string(&header,accept_charset);
    name_03 = extraout_EDX_08;
  }
  ppuVar7 = (uchar **)get_opt_(config_options,(uchar *)name_03);
  name_00 = *ppuVar7;
  if (*name_00 == '\0') {
    piVar6 = get_opt_(config_options,name_04);
    if ((*piVar6 != 0) && (name_00 = language_to_iso639(current_language), name_00 != (uchar *)0x0))
    {
      add_to_string(&header,(uchar *)"Accept-Language: ");
      add_to_string(&header,name_00);
      add_crlf_to_string(&header);
    }
  }
  else {
    add_to_string(&header,(uchar *)"Accept-Language: ");
    add_to_string(&header,name_00);
    add_crlf_to_string(&header);
  }
  if (((name->sent_version).major == 1) && ((name->sent_version).minor == 1)) {
    if (conn->uri->protocol == 0xf) {
      add_to_string(&header,(uchar *)"Proxy-Connection: ");
    }
    else {
      add_to_string(&header,"Connection: ");
    }
    if ((uri->post == (uchar *)0x0) || (piVar6 = get_opt_(config_options,uri->post), *piVar6 == 0))
    {
      add_to_string(&header,(uchar *)"Keep-Alive");
    }
    else {
      add_to_string(&header,"close");
    }
    add_crlf_to_string(&header);
  }
  if ((((bVar3) || (pcVar13 = conn->cached, pcVar13 == (cache_entry *)0x0)) ||
      ((*(byte *)&pcVar13->field_0x5c & 8) != 0)) || (pcVar13->head == (uchar *)0x0)) {
LAB_080d1988:
    if (2 < conn->cache_mode) goto LAB_080d21e8;
  }
  else {
    if (conn->cache_mode < 3) {
      if (pcVar13->last_modified != (uchar *)0x0) {
        add_to_string(&header,(uchar *)"If-Modified-Since: ");
        add_to_string(&header,conn->cached->last_modified);
        add_crlf_to_string(&header);
        pcVar13 = conn->cached;
      }
      if (pcVar13->etag != (uchar *)0x0) {
        add_to_string(&header,(uchar *)"If-None-Match: ");
        add_to_string(&header,conn->cached->etag);
        add_crlf_to_string(&header);
      }
      goto LAB_080d1988;
    }
LAB_080d21e8:
    add_to_string(&header,(uchar *)"Pragma: no-cache");
    add_crlf_to_string(&header);
    add_to_string(&header,(uchar *)"Cache-Control: no-cache");
    add_crlf_to_string(&header);
  }
  if (bVar3) {
    add_crlf_to_string(&header);
  }
  else {
    if ((*(uint *)((int)&conn->from + 4) | *(uint *)&conn->from) == 0) {
      cp_index = *(int *)((int)&conn->progress->start + 4);
      if ((-1 < cp_index) && ((0 < cp_index || (*(int *)&conn->progress->start != 0))))
      goto LAB_080d1ee0;
    }
    else {
LAB_080d1ee0:
      add_to_string(&header,(uchar *)"Range: bytes=");
      size = *(uint *)&conn->from;
      if ((*(uint *)((int)&conn->from + 4) | size) == 0) {
        size = *(uint *)&conn->progress->start;
      }
      add_long_to_string(&header,size);
      add_char_to_string(&header,'-');
      add_crlf_to_string(&header);
    }
    cp_index = http_negotiate_output(uri,&header);
    if ((cp_index != 0) && (entry = find_auth(uri), entry != (auth_entry *)0x0)) {
      if ((*(byte *)&entry->field_0x70 & 4) == 0) {
        name_00 = straconcat(entry->user,0x812bbab,entry->password,0);
        if (name_00 != (uchar *)0x0) {
          source = base64_encode(name_00);
          mem_free(name_00);
          if (source != (uchar *)0x0) {
            add_to_string(&header,"Authorization: Basic ");
            add_to_string(&header,source);
            add_crlf_to_string(&header);
            mem_free(source);
          }
        }
      }
      else {
        name_00 = get_http_auth_digest_response(entry,uri);
        if (name_00 != (uchar *)0x0) {
          add_to_string(&header,"Authorization: Digest ");
          add_to_string(&header,name_00);
          add_crlf_to_string(&header);
          mem_free(name_00);
        }
      }
    }
    __s = uri->post;
    if (__s != (byte *)0x0) {
      local_1088 = strchr((char *)__s,10);
      if (local_1088 != (char *)0x0) {
        __s = (byte *)(local_1088 + 1);
        add_to_string(&header,"Content-Type: ");
        add_bytes_to_string__(&header,uri->post,(int)(local_1088 + -(int)uri->post));
        add_crlf_to_string(&header);
      }
      add_to_string(&header,(uchar *)"Content-Length: ");
      sVar9 = strlen((char *)__s);
      add_long_to_string(&header,sVar9 >> 1);
      add_crlf_to_string(&header);
    }
    from = send_cookies(uri);
    if (from != (string *)0x0) {
      add_to_string(&header,(uchar *)"Cookie: ");
      add_string_to_string(&header,from);
      add_crlf_to_string(&header);
      done_string(from);
    }
    add_crlf_to_string(&header);
    if (__s != (byte *)0x0) {
      if (assert_failed == 0) {
        assert_failed = 0;
      }
      cp_index = 0;
      while( true ) {
        bVar1 = *__s;
        size = (uint)bVar1;
        if ((bVar1 == 0) || (__s[1] == 0)) break;
        if ((byte)(bVar1 - 0x30) < 10) {
          size = size - 0x30;
LAB_080d1afb:
          if (assert_failed != 0) goto LAB_080d1ba9;
LAB_080d1b09:
          assert_failed = ZEXT14(0xf < size);
          if (0xf < size) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/http.c";
            errline = 0x3e6;
            elinks_internal((uchar *)
                            "assertion h1 >= 0 && h1 < 16 failed: h1 in the POST buffer is %d (%d/%c)"
                            ,size,(uint)*__s,(uint)*__s);
            if (assert_failed != 0) goto LAB_080d1ba9;
          }
          uVar10 = (uint)__s[1];
          cVar14 = (char)(size << 4);
          if ((byte)(__s[1] - 0x30) < 10) goto LAB_080d1b36;
LAB_080d1bc8:
          if ((byte)((char)uVar10 + 0x9fU) < 6) {
            uVar10 = uVar10 - 0x57;
            goto LAB_080d1b39;
          }
          if ((byte)((char)uVar10 + 0xbfU) < 6) {
            uVar10 = uVar10 - 0x37;
            goto LAB_080d1b39;
          }
          assert_failed = 1;
          uVar10 = 0xffffffff;
LAB_080d1c57:
          cVar16 = (char)uVar10;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/http.c";
          errline = 0x3ea;
          elinks_internal((uchar *)
                          "assertion h2 >= 0 && h2 < 16 failed: h2 in the POST buffer is %d (%d/%c)"
                          ,uVar10,(uint)__s[1],(uint)__s[1]);
          if (assert_failed != 0) {
            assert_failed = 0;
            cVar16 = '\0';
          }
        }
        else {
          if (5 < (byte)(bVar1 + 0x9f)) {
            size = size - 0x37;
            if (5 < (byte)(bVar1 + 0xbf)) {
              size = 0xffffffff;
            }
            goto LAB_080d1afb;
          }
          size = size - 0x57;
          if (assert_failed == 0) goto LAB_080d1b09;
LAB_080d1ba9:
          uVar10 = (uint)__s[1];
          cVar14 = '\0';
          if (9 < (byte)(__s[1] - 0x30)) goto LAB_080d1bc8;
LAB_080d1b36:
          uVar10 = uVar10 - 0x30;
LAB_080d1b39:
          cVar16 = (char)uVar10;
          assert_failed = ZEXT14(0xf < uVar10);
          if (0xf < uVar10) goto LAB_080d1c57;
        }
        iVar5 = header.length;
        ts[cp_index] = cVar16 + cVar14;
        cp_index = cp_index + 1;
        if (cp_index == 0x1000) {
          if (assert_failed == 0) {
            assert_failed = 0;
            size = header.length + 0x1100U & 0xffffff00;
            uVar10 = header.length + 0xffU & 0xffffff00;
            conn = (connection *)(header.length + 0x1000);
            if (uVar10 < size) {
              local_108c = (connection *)mem_realloc(header.source,size);
              if (local_108c != (connection *)0x0) {
                header.source = (uchar *)local_108c;
                memset((void *)((int)&local_108c->next + uVar10),0,size - uVar10);
                goto LAB_080d1d02;
              }
            }
            else {
LAB_080d1d02:
              if ((connection *)header.source != (connection *)0x0) {
                puVar11 = (undefined4 *)(header.source + header.length);
                puVar15 = (undefined4 *)ts;
                local_1050 = 0x1000;
                bVar18 = ((uint)puVar11 & 1) != 0;
                puVar17 = puVar11;
                if (bVar18) {
                  puVar17 = (undefined4 *)((int)puVar11 + 1);
                  puVar15 = (undefined4 *)(ts + 1);
                  *(uchar *)puVar11 = ts[0];
                  local_1050 = 0xfff;
                }
                if (((uint)puVar17 & 2) != 0) {
                  uVar2 = *(undefined2 *)puVar15;
                  puVar15 = (undefined4 *)((int)puVar15 + 2);
                  *(undefined2 *)puVar17 = uVar2;
                  puVar17 = (undefined4 *)((int)puVar17 + 2);
                  local_1050 = local_1050 - 2;
                }
                cp_index = 0;
                size = local_1050 >> 2;
                while (size != 0) {
                  size = size - 1;
                  *puVar17 = *puVar15;
                  puVar15 = puVar15 + (uint)bVar19 * 0x3ffffffe + 1;
                  puVar17 = puVar17 + (uint)bVar19 * 0x3ffffffe + 1;
                }
                if ((local_1050 & 2) != 0) {
                  *(undefined2 *)puVar17 = *(undefined2 *)puVar15;
                  cp_index = 2;
                }
                if (bVar18) {
                  *(undefined *)((int)puVar17 + cp_index) = *(undefined *)((int)puVar15 + cp_index);
                }
                cp_index = 0;
                *(undefined *)((int)(iVar5 + 0x1000) + (int)header.source) = 0;
                header.length = (int)conn;
                goto LAB_080d1b69;
              }
            }
            cp_index = 0;
          }
          else {
            assert_failed = 0;
            cp_index = 0;
          }
        }
LAB_080d1b69:
        __s = __s + 2;
      }
      if (cp_index != 0) {
        add_bytes_to_string__(&header,ts,cp_index);
      }
    }
  }
  if (assert_failed == 0) {
    size = 4;
  }
  else {
    size = 0xfffe795d;
  }
  assert_failed = 0;
  local_1088 = (char *)header.source;
  request_from_socket(socket,header.source,header.length,(connection_state)(ulonglong)size,
                      SOCKET_END_ONCLOSE,http_got_header);
  local_108c = (connection *)&header;
  done_string((string *)local_108c);
LAB_080d12de:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail(local_108c,local_1088);
}



void http_protocol_handler(connection *conn)

{
  int iVar1;
  
  iVar1 = has_keepalive_connection(conn);
  if (iVar1 != 0) {
    http_send_header(conn->socket);
    return;
  }
  make_connection(conn->socket,conn->uri,http_send_header,(uint)(2 < conn->cache_mode));
  return;
}



void proxy_protocol_handler(connection *conn)

{
  http_protocol_handler(conn);
  return;
}



negotiate * __regparm3 http_negotiate_get(uri *uri,int *isnew,int alloc)

{
  int iVar1;
  negotiate *pnVar2;
  
  pnVar2 = (negotiate *)negotiate_list.next;
  if ((list_head_elinks *)negotiate_list.next != &negotiate_list) {
    do {
      iVar1 = compare_uri(pnVar2->uri,uri,URI_HTTP_REFERRER_HOST);
      if (iVar1 != 0) {
        return pnVar2;
      }
      pnVar2 = pnVar2->next;
    } while (pnVar2 != (negotiate *)&negotiate_list);
  }
  pnVar2 = (negotiate *)0x0;
  if ((alloc != 0) && (pnVar2 = (negotiate *)mem_calloc(1,0x30), pnVar2 != (negotiate *)0x0)) {
    (uri->object).refcount = (uri->object).refcount + 1;
    pnVar2->uri = uri;
    if (isnew != (int *)0x0) {
      *isnew = 1;
    }
  }
  return pnVar2;
}



int __regparm3 http_negotiate_create_context(negotiate *neg)

{
  uint uVar1;
  int iVar2;
  OM_uint32 minor_status;
  
  uVar1 = gss_init_sec_context
                    (&minor_status,0,&neg->context,neg->server_name,0,1,0,0,&neg->input_token,0,
                     &neg->output_token,0,0);
  neg->status = uVar1;
  if (((uVar1 & 0xffff0000) != 0) || (iVar2 = 0, (neg->output_token).length == 0)) {
    iVar2 = -1;
  }
  return iVar2;
}



void __regparm3 http_negotiate_cleanup(negotiate *neg,int full)

{
  int iVar1;
  byte bVar2;
  OM_uint32 minor_status;
  
  bVar2 = 0;
  if (neg->context != (gss_ctx_id_t)0x0) {
    gss_delete_sec_context(&minor_status,&neg->context,0);
  }
  if ((neg->output_token).length != 0) {
    gss_release_buffer(&minor_status,&neg->output_token);
  }
  if (full != 0) {
    if (neg->server_name != (gss_name_t)0x0) {
      gss_release_name(&minor_status,&neg->server_name);
    }
    if ((neg->input_token).length != 0) {
      mem_free((neg->input_token).value);
      (neg->input_token).length = 0;
    }
    iVar1 = 0xc;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      neg->next = (negotiate *)0x0;
      neg = (negotiate *)((int)neg + (uint)bVar2 * -8 + 4);
    }
  }
  return;
}



int http_negotiate_output(uri *uri,string *header)

{
  negotiate *neg;
  int iVar1;
  size_t inlen;
  uchar *source;
  char *source_00;
  int local_20 [4];
  
  local_20[0] = 0;
  neg = http_negotiate_get(uri,(int *)0x0,0);
  if (neg != (negotiate *)0x0) {
    inlen = (neg->output_token).length;
    if (inlen == 0) {
      iVar1 = http_negotiate_create_context(neg);
      if (iVar1 < 0) {
        http_negotiate_cleanup(neg,1);
        return -1;
      }
      inlen = (neg->output_token).length;
    }
    source = base64_encode_bin((uchar *)(neg->output_token).value,inlen,local_20);
    if ((source != (uchar *)0x0) && (local_20[0] != 0)) {
      add_to_string(header,(uchar *)"Authorization: ");
      source_00 = "GSS-Negotiate";
      if (neg->type != 1) {
        source_00 = "Negotiate";
      }
      add_to_string(header,(uchar *)source_00);
      add_char_to_string(header,' ');
      add_to_string(header,source);
      add_crlf_to_string(header);
      http_negotiate_cleanup(neg,0);
      mem_free(source);
      return 0;
    }
  }
  return -1;
}



int __regparm3 http_negotiate_get_name(connection *conn,negotiate *neg)

{
  size_t sVar1;
  int iVar2;
  uri *puVar3;
  undefined *puVar4;
  int iVar5;
  uint uVar6;
  int in_GS_OFFSET;
  gss_buffer_desc token;
  OM_uint32 minor_status;
  char name [2048];
  
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  token.length = 0;
  token.value = (void *)0x0;
  puVar3 = conn->proxied_uri;
  puVar4 = &DAT_0813317e;
  if (neg->type == 1) {
    puVar4 = &DAT_0813317d;
  }
  sVar1 = (uint)(neg->type == 1) + 6 + (uint)*(ushort *)&puVar3->field_0x2e;
  if (sVar1 + 1 < 0x801) {
    token.length = sVar1;
    __snprintf_chk(name,sVar1,1,0x800,&DAT_08133183,puVar4,(uint)*(ushort *)&puVar3->field_0x2e,
                   puVar3->host);
    token.value = name;
    uVar6 = gss_import_name(&minor_status,&token,GSS_C_NT_HOSTBASED_SERVICE,&neg->server_name);
    iVar5 = 0;
    if ((uVar6 & 0xffff0000) == 0) goto LAB_080d2b33;
  }
  iVar5 = -1;
LAB_080d2b33:
  if (iVar2 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar5;
}



int http_negotiate_input(connection *conn,uri *uri,int type,uchar *data)

{
  negotiate *neg;
  int iVar1;
  ushort **ppuVar2;
  uchar *puVar3;
  byte *in;
  byte *pbVar4;
  byte bVar5;
  int local_20 [4];
  
  local_20[0] = 0;
  neg = http_negotiate_get(uri,local_20,1);
  if ((type == 1) || (neg->context == (gss_ctx_id_t)0x0)) {
    neg->type = type;
    if ((neg->context != (gss_ctx_id_t)0x0) && (neg->status == 0)) {
      http_negotiate_cleanup(neg,1);
      return -1;
    }
    if ((neg->server_name != (gss_name_t)0x0) ||
       (iVar1 = http_negotiate_get_name(conn,neg), -1 < iVar1)) {
      if ((data != (uchar *)0x0) && (*data != '\0')) {
        in = data + 0xe;
        if (type != 1) {
          in = data + 10;
        }
        bVar5 = *in;
        if (bVar5 != 0) {
          ppuVar2 = __ctype_b_loc();
          do {
            if ((*(byte *)((int)*ppuVar2 + (uint)bVar5 * 2 + 1) & 0x20) == 0) {
              if (((bVar5 != 0xd) && (bVar5 != 0)) && (pbVar4 = in, bVar5 != 10)) {
                while (((*(byte *)(*ppuVar2 + bVar5) & 8) != 0 || (bVar5 == 0x3d))) {
                  pbVar4 = pbVar4 + 1;
                  bVar5 = *pbVar4;
                }
                if (((bVar5 == 10) || (bVar5 == 0xd)) && (pbVar4 + -(int)in != (byte *)0x0)) {
                  puVar3 = base64_decode_bin(in,(int)(pbVar4 + -(int)in),(int *)&neg->input_token);
                  *(uchar **)&(neg->input_token).value = puVar3;
                  if (puVar3 == (uchar *)0x0) {
                    return -1;
                  }
                }
              }
              break;
            }
            in = in + 1;
            bVar5 = *in;
          } while (bVar5 != 0);
        }
      }
      iVar1 = http_negotiate_create_context(neg);
      if ((iVar1 == 0) && (local_20[0] != 0)) {
        *(list_head_elinks **)&neg->prev = &negotiate_list;
        neg->next = negotiate_list.next;
        negotiate_list.next = neg;
        neg->next->prev = neg;
      }
      return iVar1;
    }
  }
  return -1;
}



uchar * __regparm3 get_uri_rewrite_prefix(uri_rewrite_type type,uchar *url)

{
  uchar *puVar1;
  bool bVar2;
  option_elinks *poVar3;
  int iVar4;
  
  iVar4 = (-(uint)(type == URI_REWRITE_DUMB) & 0xfffffffe) + 5;
  if ((assert_failed == 0) &&
     (bVar2 = iVar4 != 5 && iVar4 != 3, assert_failed = ZEXT14(bVar2), bVar2)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/rewrite/rewrite.c";
    errline = 0xe6;
    elinks_internal((uchar *)
                    "assertion tree == URI_REWRITE_DUMB_TREE || tree == URI_REWRITE_SMART_TREE failed!"
                   );
  }
  poVar3 = get_opt_rec_real((option_elinks *)(uri_rewrite_options + iVar4),url);
  if (poVar3 != (option_elinks *)0x0) {
    puVar1 = (uchar *)poVar3->value;
    if ((puVar1 == (uchar *)0x0) || (*puVar1 != '\0')) {
      return puVar1;
    }
  }
  return (uchar *)0x0;
}



evhook_status goto_url_hook(va_list ap,void *data)

{
  uchar uVar1;
  byte bVar2;
  uchar **ppuVar3;
  uint uVar4;
  string *psVar5;
  char *pcVar6;
  uint uVar7;
  char **ppcVar8;
  char cVar9;
  int iVar10;
  size_t sVar11;
  uint size;
  uchar *name;
  undefined2 *__src;
  int iVar12;
  int iVar13;
  undefined2 *puVar14;
  uchar *__s;
  size_t __n;
  int local_90;
  uri *local_8c;
  uchar *local_88;
  int argslen [10];
  uchar *args [10];
  string n;
  
  ppuVar3 = *(uchar ***)ap;
  iVar12 = *(int *)(ap + 4);
  local_88 = "";
  __s = *ppuVar3;
  uVar1 = *__s;
  if (((uVar1 == '\0') || (uVar1 == ' ')) || (uVar1 == ':')) {
    iVar10 = 0;
  }
  else {
    iVar10 = 0;
    do {
      iVar10 = iVar10 + 1;
      uVar1 = __s[iVar10];
      if ((uVar1 == '\0') || (uVar1 == ' ')) break;
    } while (uVar1 != ':');
  }
  __s = __s + iVar10;
  if ((uri_rewrite_options[2].option_elinks.value == 0) || (uVar1 = *__s, uVar1 == '\0')) {
    __src = (undefined2 *)0x0;
LAB_080d2e96:
    if (uri_rewrite_options[1].option_elinks.value == 0) goto LAB_080d2ea3;
    if (*__s == '\0') {
      __src = (undefined2 *)get_uri_rewrite_prefix(URI_REWRITE_DUMB,*ppuVar3);
      goto LAB_080d2ea3;
    }
  }
  else {
    *__s = '\0';
    __src = (undefined2 *)get_uri_rewrite_prefix(URI_REWRITE_SMART,*ppuVar3);
    local_88 = __s + 1;
    *__s = uVar1;
    if (__src == (undefined2 *)0x0) goto LAB_080d2e96;
LAB_080d2ea3:
    if (__src != (undefined2 *)0x0) goto LAB_080d2eab;
  }
  __s = *ppuVar3;
  pcVar6 = strchr((char *)__s,0x3a);
  if (pcVar6 != (char *)0x0) {
    return EVENT_HOOK_STATUS_NEXT;
  }
  pcVar6 = strchr((char *)__s,0x2e);
  if (pcVar6 != (char *)0x0) {
    return EVENT_HOOK_STATUS_NEXT;
  }
  pcVar6 = strchr((char *)__s,0x2f);
  if (pcVar6 != (char *)0x0) {
    return EVENT_HOOK_STATUS_NEXT;
  }
  ppcVar8 = (char **)get_opt_(config_options,name);
  __src = (undefined2 *)*ppcVar8;
  if (__src == (undefined2 *)0x0) {
    return EVENT_HOOK_STATUS_NEXT;
  }
  if (*(char *)__src == '\0') {
    return EVENT_HOOK_STATUS_NEXT;
  }
  local_88 = *ppuVar3;
LAB_080d2eab:
  if ((iVar12 == 0) || (iVar12 = *(int *)(iVar12 + 0x14), iVar12 == 0)) {
    local_8c = (uri *)0x0;
  }
  else {
    local_8c = *(uri **)(iVar12 + 0x44);
  }
  n.source = (uchar *)0x0;
  n.length = 0;
  psVar5 = init_string(&n);
  if (psVar5 == (string *)0x0) {
    return EVENT_HOOK_STATUS_NEXT;
  }
  iVar10 = 0;
  iVar12 = 0;
  args[0] = local_88;
  __s = local_88;
  do {
    __s = __s + iVar10;
    if (*__s == ' ') {
      argslen[iVar12] = iVar10;
      iVar13 = iVar12 + 1;
      if (iVar13 == 10) {
        cVar9 = *(char *)__src;
        goto LAB_080d2f78;
      }
      do {
        __s = __s + 1;
      } while (*__s == ' ');
      args[iVar13] = __s;
      iVar10 = 1;
      iVar12 = iVar13;
    }
    else {
      if (*__s == '\0') {
        argslen[iVar12] = iVar10;
        cVar9 = *(char *)__src;
LAB_080d2f78:
        local_90 = iVar12 + 1;
        __s = n.source;
        do {
          n.source = __s;
          if (cVar9 == '\0') {
            if (__s != (uchar *)0x0) {
              mem_free(*ppuVar3);
              *ppuVar3 = __s;
              return EVENT_HOOK_STATUS_NEXT;
            }
            return EVENT_HOOK_STATUS_NEXT;
          }
          sVar11 = 0;
          __n = 0;
          puVar14 = __src;
          if (cVar9 != '%') {
            do {
              sVar11 = sVar11 + 1;
              puVar14 = (undefined2 *)((int)__src + sVar11);
              __n = sVar11;
              if (*(char *)((int)__src + sVar11) == '%') break;
            } while (*(char *)((int)__src + sVar11) != '\0');
          }
          if (assert_failed == 0) {
            if ((int)__n < 0) {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
              errline = 0xff;
              elinks_internal((uchar *)
                              "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                             );
              if (assert_failed != 0) goto LAB_080d2fae;
            }
            else {
              assert_failed = 0;
            }
            if (__n != 0) {
              iVar10 = __n + n.length;
              uVar4 = n.length + 0xffU >> 8;
              uVar7 = n.length + 0xffU & 0xffffff00;
              size = iVar10 + 0x100U & 0xffffff00;
              if (uVar7 <= size && size + uVar4 * -0x100 != 0) {
                __s = (uchar *)mem_realloc(n.source,size);
                if (__s == (uchar *)0x0) goto LAB_080d2fb8;
                n.source = __s;
                memset(__s + uVar7,0,size + uVar4 * -0x100);
              }
              if (n.source != (uchar *)0x0) {
                memcpy(n.source + n.length,__src,__n);
                n.source[iVar10] = '\0';
                n.length = iVar10;
              }
            }
          }
          else {
LAB_080d2fae:
            assert_failed = 0;
          }
LAB_080d2fb8:
          iVar10 = n.length;
          cVar9 = *(char *)puVar14;
          __src = puVar14;
          if (cVar9 != '%') goto LAB_080d2f78;
          bVar2 = *(byte *)((int)puVar14 + 1);
          __src = (undefined2 *)((int)puVar14 + 1);
          if (bVar2 < 0x3a) {
            if (bVar2 < 0x30) {
              if (bVar2 == 0x25) {
                add_char_to_string(&n,'%');
                cVar9 = *(char *)__src;
              }
              else {
LAB_080d30ee:
                if (assert_failed == 0) {
                  assert_failed = 0;
                  iVar13 = n.length + 2;
                  uVar4 = n.length + 0xffU >> 8;
                  uVar7 = n.length + 0xffU & 0xffffff00;
                  size = n.length + 0x102U & 0xffffff00;
                  if (size < uVar7 || size + uVar4 * -0x100 == 0) {
LAB_080d3162:
                    if (n.source != (uchar *)0x0) {
                      *(undefined2 *)(n.source + n.length) = *puVar14;
                      n.source[iVar10 + 2] = '\0';
                      n.length = iVar13;
                    }
                  }
                  else {
                    __s = (uchar *)mem_realloc(n.source,size);
                    if (__s != (uchar *)0x0) {
                      n.source = __s;
                      memset(__s + uVar7,0,size + uVar4 * -0x100);
                      goto LAB_080d3162;
                    }
                  }
                  cVar9 = *(char *)__src;
                }
                else {
                  assert_failed = 0;
                  cVar9 = *(char *)__src;
                }
              }
            }
            else {
              iVar10 = (uint)bVar2 - 0x30;
              if (local_90 <= iVar10) goto LAB_080d2feb;
              encode_uri_string(&n,args[iVar10],argslen[iVar10],1);
              cVar9 = *(char *)__src;
            }
LAB_080d3108:
            if (cVar9 == '\0') goto LAB_080d2f78;
            cVar9 = *(char *)(puVar14 + 1);
          }
          else {
            if (bVar2 != 99) {
              if (bVar2 != 0x73) goto LAB_080d30ee;
              if (local_88 == (uchar *)0x0) goto LAB_080d2feb;
              encode_uri_string(&n,local_88,-1,1);
              cVar9 = *(char *)__src;
              goto LAB_080d3108;
            }
            if (local_8c != (uri *)0x0) {
              add_uri_to_string(&n,local_8c,URI_ORIGINAL);
              cVar9 = *(char *)__src;
              goto LAB_080d3108;
            }
LAB_080d2feb:
            cVar9 = *(char *)(puVar14 + 1);
          }
          __src = puVar14 + 1;
          __s = n.source;
        } while( true );
      }
      iVar10 = iVar10 + 1;
    }
    __s = args[iVar12];
  } while( true );
}



void report_scripting_error(module *module,session *ses,uchar *msg)

{
  string *psVar1;
  int cp_index;
  uchar *fmt;
  uchar *msgid;
  terminal *term;
  string string;
  
  if (ses == (session *)0x0) {
    term = (terminal *)terminals.next;
    if ((list_head_elinks *)terminals.next == &terminals) {
      msgid = gettext(module->name);
      fmt = gettext((uchar *)"[%s error] %s");
      usrerror(fmt,msgid,msg);
      sleep(3);
      return;
    }
  }
  else {
    term = ses->tab->term;
  }
  psVar1 = init_string(&string);
  if (psVar1 != (string *)0x0) {
    msgid = module->name;
    if ((msgid != (uchar *)0x0) && (*msgid != '\0')) {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        fmt = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",fmt);
        current_charset = cp_index;
      }
      msgid = gettext(msgid);
    }
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      fmt = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",fmt);
      current_charset = cp_index;
    }
    fmt = gettext((uchar *)"An error occurred while running a %s script");
    add_format_to_string(&string,fmt,msgid);
    add_format_to_string(&string,":\n\n%s",msg);
    info_box(term,MSGBOX_FREE_TEXT|MSGBOX_NO_TEXT_INTL,(uchar *)"Browser scripting error",ALIGN_LEFT
             ,string.source);
  }
  return;
}



VALUE erb_module_method_missing(VALUE self,VALUE arg)

{
  return 4;
}



VALUE erb_stdout_p(int argc,VALUE *argv,VALUE self)

{
  uint uVar1;
  string *psVar2;
  int iVar3;
  uint uVar4;
  uchar *puVar5;
  uint size;
  size_t __n;
  char *__src;
  int iVar6;
  string string;
  
  psVar2 = init_string(&string);
  if (psVar2 != (string *)0x0) {
    iVar6 = 0;
    if (0 < argc) {
      do {
        iVar3 = rb_inspect(argv[iVar6]);
        __src = *(char **)(iVar3 + 0xc);
        iVar3 = *(int *)(iVar3 + 8);
        if (*__src == '\"') {
          __src = __src + 1;
          iVar3 = iVar3 + -1;
        }
        __n = iVar3 - (uint)(__src[iVar3 + -1] == '\"');
        if (assert_failed == 0) {
          if ((__src == (char *)0x0) || ((int)__n < 0)) {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
            errline = 0xff;
            elinks_internal((uchar *)
                            "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                           );
            if (assert_failed != 0) goto LAB_080d3650;
          }
          else {
            assert_failed = 0;
          }
          if (__n != 0) {
            iVar3 = __n + string.length;
            uVar1 = string.length + 0xffU >> 8;
            uVar4 = string.length + 0xffU & 0xffffff00;
            size = iVar3 + 0x100U & 0xffffff00;
            if (uVar4 <= size && size + uVar1 * -0x100 != 0) {
              puVar5 = (uchar *)mem_realloc(string.source,size);
              if (puVar5 == (uchar *)0x0) goto joined_r0x080d3660;
              string.source = puVar5;
              memset(puVar5 + uVar4,0,size + uVar1 * -0x100);
            }
            if (string.source != (uchar *)0x0) {
              memcpy(string.source + string.length,__src,__n);
              string.source[iVar3] = '\0';
              string.length = iVar3;
            }
          }
        }
        else {
LAB_080d3650:
          assert_failed = 0;
        }
joined_r0x080d3660:
        if (argc <= iVar6 + 1) break;
        iVar6 = iVar6 + 1;
        add_to_string(&string,", ");
      } while( true );
    }
    if ((list_head_elinks *)terminals.next == &terminals) {
      usrerror((uchar *)"[Ruby] %s",string.source);
      done_string(&string);
    }
    else {
      info_box((terminal *)terminals.next,MSGBOX_FREE_TEXT|MSGBOX_NO_TEXT_INTL,
               (uchar *)"Ruby Message",ALIGN_LEFT,string.source);
    }
  }
  return 4;
}



VALUE erb_module_message(VALUE self,VALUE str)

{
  int iVar1;
  uchar *text;
  char *pcVar2;
  
  iVar1 = rb_obj_as_string(str);
  text = memacpy(*(uchar **)(iVar1 + 0xc),*(int *)(iVar1 + 8));
  if (text != (uchar *)0x0) {
    pcVar2 = strchr((char *)text,10);
    if (pcVar2 != (char *)0x0) {
      *pcVar2 = '\0';
    }
    if ((list_head_elinks *)terminals.next == &terminals) {
      usrerror((uchar *)"[Ruby] %s",text);
      mem_free(text);
    }
    else {
      info_box((terminal *)terminals.next,MSGBOX_FREE_TEXT|MSGBOX_NO_TEXT_INTL,
               (uchar *)"Ruby Message",ALIGN_LEFT,text);
    }
  }
  return 4;
}



void alert_ruby_error(session *ses,uchar *msg)

{
  report_scripting_error(&ruby_scripting_module,ses,msg);
  return;
}



void erb_report_error(session *ses,int error)

{
  int iVar1;
  int iVar2;
  int iVar3;
  char *pcVar4;
  char *__s;
  int in_GS_OFFSET;
  uchar buff [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  switch(error) {
  default:
    __s = (char *)buff;
    __snprintf_chk(__s,0x400,1,0x400,"unknown longjmp status %d",error);
    break;
  case 1:
    __s = "unexpected return";
    break;
  case 2:
    __s = "unexpected break";
    break;
  case 3:
    __s = "unexpected next";
    break;
  case 4:
    __s = "retry outside of rescue clause";
    break;
  case 5:
    __s = "unexpected redo";
    break;
  case 6:
  case 8:
    iVar3 = rb_cFixnum;
    if (((((ruby_errinfo & 1) == 0) && (iVar3 = rb_cNilClass, ruby_errinfo != 4)) &&
        (iVar3 = rb_cFalseClass, ruby_errinfo != 0)) &&
       ((iVar3 = rb_cTrueClass, ruby_errinfo != 2 &&
        (iVar3 = rb_cSymbol, (char)ruby_errinfo != '\x0e')))) {
      iVar3 = *(int *)(ruby_errinfo + 4);
    }
    iVar2 = rb_obj_as_string(ruby_errinfo);
    if ((rb_eRuntimeError != iVar3) || (__s = "unhandled exception", *(int *)(iVar2 + 8) != 0)) {
      iVar3 = rb_class_path(iVar3);
      __s = (char *)buff;
      __snprintf_chk(__s,0x400,1,0x400,0x8127c04,*(undefined4 *)(iVar3 + 0xc),
                     *(undefined4 *)(iVar2 + 0xc));
      pcVar4 = strchr(__s,10);
      if (pcVar4 != (char *)0x0) {
        *pcVar4 = '\0';
      }
    }
  }
  alert_ruby_error(ses,(uchar *)__s);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void init_ruby(module *module)

{
  undefined4 uVar1;
  uchar *filename;
  int iVar2;
  int local_10 [2];
  
  ruby_init();
  ruby_script("ELinks-ruby");
  ruby_init_loadpath();
  rb_define_singleton_method(rb_stdout,0x8133190,erb_module_message,1);
  rb_define_global_function(&DAT_08132310,erb_stdout_p,0xffffffff);
  erb_module = rb_define_module(0x812bda3);
  uVar1 = rb_str_new2(0x81324c6);
  rb_define_const(erb_module,"VERSION",uVar1);
  filename = elinks_home;
  if (elinks_home == (uchar *)0x0) {
    filename = (uchar *)"/etc/elinks";
  }
  uVar1 = rb_str_new2(filename);
  rb_define_const(erb_module,&DAT_0813381e,uVar1);
  rb_define_module_function(erb_module,"message",erb_module_message,1);
  rb_define_module_function(erb_module,"method_missing",erb_module_method_missing,0xffffffff);
  rb_define_module_function(erb_module,&DAT_08132310,erb_stdout_p,0xffffffff);
  if (elinks_home == (uchar *)0x0) {
    filename = stracpy((uchar *)"/etc/elinks/hooks.rb");
  }
  else {
    filename = straconcat(elinks_home,0x81335b7,0);
  }
  if (filename != (uchar *)0x0) {
    iVar2 = file_can_read(filename);
    if (iVar2 != 0) {
      uVar1 = rb_str_new2(filename);
      rb_load_protect(uVar1,0,local_10);
      if (local_10[0] != 0) {
        erb_report_error((session *)0x0,local_10[0]);
      }
    }
    mem_free(filename);
  }
  return;
}



evhook_status script_hook_quit(va_list ap,void *data)

{
  erb_protect_info info;
  int local_14;
  VALUE args [1];
  
  info.args = args;
  info.name = "quit_hook";
  info.argc = 0;
  rb_protect(do_erb_protected_method_call,&info,&local_14);
  if (local_14 != 0) {
    erb_report_error((session *)0x0,local_14);
  }
  return EVENT_HOOK_STATUS_NEXT;
}



VALUE do_erb_protected_method_call(VALUE data)

{
  undefined4 uVar1;
  VALUE VVar2;
  
  if ((assert_failed == 0) && (assert_failed = ZEXT14(data == 0), data == 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/scripting/ruby/hooks.c";
    errline = 0x26;
    elinks_internal((uchar *)"assertion info failed!");
  }
  uVar1 = rb_intern(*(undefined4 *)data);
  VVar2 = rb_funcall3(erb_module,uVar1,*(undefined4 *)(data + 4),*(undefined4 *)(data + 8));
  return VVar2;
}



evhook_status script_hook_get_proxy(va_list ap,void *data)

{
  char *__s;
  uchar **ppuVar1;
  size_t sVar2;
  uint *puVar3;
  uchar *puVar4;
  erb_protect_info info;
  VALUE args [1];
  int local_10;
  
  __s = *(char **)(ap + 4);
  ppuVar1 = *(uchar ***)ap;
  if ((__s != (char *)0x0) && (ppuVar1 != (uchar **)0x0)) {
    sVar2 = strlen(__s);
    args = rb_str_new(__s,sVar2);
    info.name = "proxy_hook";
    info.argc = 1;
    info.args = args;
    puVar3 = (uint *)rb_protect(do_erb_protected_method_call,&info,&local_10);
    if (local_10 == 0) {
      if (((uint)puVar3 & 1) != 0) {
LAB_080d3d40:
        alert_ruby_error((session *)0x0,(uchar *)"proxy_hook must return a string or nil");
        return EVENT_HOOK_STATUS_NEXT;
      }
      if (puVar3 != (uint *)&DAT_00000004) {
        if ((((puVar3 == (uint *)0x0) || (puVar3 == (uint *)0x2)) ||
            (puVar3 == (uint *)&DAT_00000006)) || ((char)puVar3 == '\x0e')) goto LAB_080d3d40;
        if ((*puVar3 & 0x3f) != 1) {
          if ((*puVar3 & 0x3f) != 7) goto LAB_080d3d40;
          puVar4 = memacpy((uchar *)puVar3[3],puVar3[2]);
          if (puVar4 != (uchar *)0x0) {
            if (*ppuVar1 != (uchar *)0x0) {
              mem_free(*ppuVar1);
            }
            *ppuVar1 = puVar4;
          }
        }
      }
    }
    else {
      erb_report_error((session *)0x0,local_10);
    }
  }
  return EVENT_HOOK_STATUS_NEXT;
}



evhook_status script_hook_follow_url(va_list ap,void *data)

{
  uchar **ppuVar1;
  session *ses;
  size_t sVar2;
  uint *puVar3;
  uchar *__s;
  erb_protect_info info;
  VALUE args [1];
  int local_20 [4];
  
  ppuVar1 = *(uchar ***)ap;
  ses = *(session **)(ap + 4);
  __s = *ppuVar1;
  if (__s != (uchar *)0x0) {
    sVar2 = strlen((char *)__s);
    args = rb_str_new(__s,sVar2);
    info.name = "follow_url_hook";
    info.argc = 1;
    info.args = args;
    puVar3 = (uint *)rb_protect(do_erb_protected_method_call,&info,local_20);
    if (local_20[0] == 0) {
      if (((uint)puVar3 & 1) == 0) {
        if (puVar3 == (uint *)&DAT_00000004) {
          return EVENT_HOOK_STATUS_NEXT;
        }
        if ((((puVar3 != (uint *)0x0) && (puVar3 != (uint *)0x2)) &&
            (puVar3 != (uint *)&DAT_00000006)) && ((char)puVar3 != '\x0e')) {
          if ((*puVar3 & 0x3f) == 1) {
            return EVENT_HOOK_STATUS_NEXT;
          }
          if ((*puVar3 & 0x3f) == 7) {
            __s = memacpy((uchar *)puVar3[3],puVar3[2]);
            if (__s == (uchar *)0x0) {
              return EVENT_HOOK_STATUS_NEXT;
            }
            if (*ppuVar1 != (uchar *)0x0) {
              mem_free(*ppuVar1);
            }
            *ppuVar1 = __s;
            return EVENT_HOOK_STATUS_NEXT;
          }
        }
      }
      alert_ruby_error(ses,(uchar *)"follow_url_hook must return a string or nil");
    }
    else {
      erb_report_error(ses,local_20[0]);
    }
  }
  return EVENT_HOOK_STATUS_NEXT;
}



evhook_status script_hook_goto_url(va_list ap,void *data)

{
  uchar **ppuVar1;
  session *ses;
  location *plVar2;
  size_t sVar3;
  uint *puVar4;
  uchar *__s;
  erb_protect_info info;
  VALUE args [2];
  int local_20 [4];
  
  ppuVar1 = *(uchar ***)ap;
  ses = *(session **)(ap + 4);
  __s = *ppuVar1;
  if (__s == (uchar *)0x0) {
    return EVENT_HOOK_STATUS_NEXT;
  }
  sVar3 = strlen((char *)__s);
  args[0] = rb_str_new(__s,sVar3);
  if ((ses == (session *)0x0) || (plVar2 = (ses->history).current, plVar2 == (location *)0x0)) {
    args[1] = 4;
  }
  else {
    __s = ((plVar2->vs).uri)->string;
    sVar3 = strlen((char *)__s);
    args[1] = rb_str_new(__s,sVar3);
  }
  info.args = args;
  info.name = "goto_url_hook";
  info.argc = 2;
  puVar4 = (uint *)rb_protect(do_erb_protected_method_call,&info,local_20);
  if (local_20[0] != 0) {
    erb_report_error(ses,local_20[0]);
    return EVENT_HOOK_STATUS_NEXT;
  }
  if (((uint)puVar4 & 1) == 0) {
    if (puVar4 == (uint *)&DAT_00000004) {
      return EVENT_HOOK_STATUS_NEXT;
    }
    if ((((puVar4 != (uint *)0x0) && (puVar4 != (uint *)0x2)) && (puVar4 != (uint *)&DAT_00000006))
       && ((char)puVar4 != '\x0e')) {
      if ((*puVar4 & 0x3f) == 1) {
        return EVENT_HOOK_STATUS_NEXT;
      }
      if ((*puVar4 & 0x3f) == 7) {
        __s = memacpy((uchar *)puVar4[3],puVar4[2]);
        if (__s == (uchar *)0x0) {
          return EVENT_HOOK_STATUS_NEXT;
        }
        if (*ppuVar1 != (uchar *)0x0) {
          mem_free(*ppuVar1);
        }
        *ppuVar1 = __s;
        return EVENT_HOOK_STATUS_NEXT;
      }
    }
  }
  alert_ruby_error(ses,(uchar *)"goto_url_hook must return a string or nil");
  return EVENT_HOOK_STATUS_NEXT;
}



evhook_status script_hook_pre_format_html(va_list ap,void *data)

{
  cache_entry *cached;
  session *ses;
  uint length;
  fragment *pfVar1;
  uint *puVar2;
  erb_protect_info info;
  VALUE args [2];
  int local_20 [4];
  
  cached = *(cache_entry **)(ap + 4);
  ses = *(session **)ap;
  pfVar1 = get_cache_fragment(cached);
  if (((*(uint *)((int)&cached->length + 4) | *(uint *)&cached->length) != 0) &&
     (pfVar1->data[0] != '\0')) {
    args[0] = rb_str_new2(cached->uri->string);
    args[1] = rb_str_new(pfVar1->data,*(undefined4 *)&pfVar1->length);
    info.name = "pre_format_html_hook";
    info.argc = 2;
    info.args = args;
    puVar2 = (uint *)rb_protect(do_erb_protected_method_call,&info,local_20);
    if (local_20[0] == 0) {
      if (((uint)puVar2 & 1) == 0) {
        if (puVar2 == (uint *)&DAT_00000004) {
          return EVENT_HOOK_STATUS_NEXT;
        }
        if ((((puVar2 != (uint *)0x0) && (puVar2 != (uint *)0x2)) &&
            (puVar2 != (uint *)&DAT_00000006)) && ((char)puVar2 != '\x0e')) {
          if ((*puVar2 & 0x3f) == 1) {
            return EVENT_HOOK_STATUS_NEXT;
          }
          if ((*puVar2 & 0x3f) == 7) {
            length = puVar2[2];
            add_fragment(cached,0,(uchar *)puVar2[3],length);
            normalize_cache_entry(cached,(longlong)(int)length);
            return EVENT_HOOK_STATUS_NEXT;
          }
        }
      }
      alert_ruby_error(ses,(uchar *)"pre_format_html_hook must return a string or nil");
    }
    else {
      erb_report_error(ses,local_20[0]);
    }
  }
  return EVENT_HOOK_STATUS_NEXT;
}



int are_there_downloads(void)

{
  list_head_elinks *plVar1;
  
  plVar1 = (list_head_elinks *)downloads.next;
  if ((list_head_elinks *)downloads.next != &downloads) {
    do {
      if (plVar1[2].prev == (void *)0x0) {
        return 1;
      }
      plVar1 = (list_head_elinks *)plVar1->next;
    } while (plVar1 != &downloads);
  }
  return 0;
}



void lun_cancel(void *lun_hop_)

{
  (**(code **)((int)lun_hop_ + 0xc))
            (*(undefined4 *)lun_hop_,0,*(undefined4 *)((int)lun_hop_ + 0x10),0);
  if (*(void **)((int)lun_hop_ + 4) != (void *)0x0) {
    mem_free(*(void **)((int)lun_hop_ + 4));
  }
  if (*(void **)((int)lun_hop_ + 8) != (void *)0x0) {
    mem_free(*(void **)((int)lun_hop_ + 8));
  }
  mem_free(lun_hop_);
  return;
}



void lun_overwrite(void *lun_hop_)

{
  (**(code **)((int)lun_hop_ + 0xc))
            (*(undefined4 *)lun_hop_,*(undefined4 *)((int)lun_hop_ + 4),
             *(undefined4 *)((int)lun_hop_ + 0x10),0);
  if (*(void **)((int)lun_hop_ + 8) != (void *)0x0) {
    mem_free(*(void **)((int)lun_hop_ + 8));
  }
  mem_free(lun_hop_);
  return;
}



void lun_alternate(void *lun_hop_)

{
  (**(code **)((int)lun_hop_ + 0xc))
            (*(undefined4 *)lun_hop_,*(undefined4 *)((int)lun_hop_ + 8),
             *(undefined4 *)((int)lun_hop_ + 0x10),0);
  if (*(void **)((int)lun_hop_ + 4) != (void *)0x0) {
    mem_free(*(void **)((int)lun_hop_ + 4));
  }
  mem_free(lun_hop_);
  return;
}



widget_handler_status_T tp_show_header(dialog_data *dlg_data,widget_data *widget_data)

{
  void *pvVar1;
  
  pvVar1 = widget_data->widget->data;
  cached_header_dialog(*(session **)((int)pvVar1 + 0x3c),*(cache_entry **)((int)pvVar1 + 0x38));
  return EVENT_PROCESSED;
}



uchar * __regparm3 subst_file(uchar *prog,uchar *file)

{
  uchar uVar1;
  bool bVar2;
  string *psVar3;
  size_t sVar4;
  int iVar5;
  uchar *puVar6;
  uint uVar7;
  uint uVar8;
  uchar uVar9;
  uint size;
  size_t __n;
  uchar *puVar10;
  byte bVar11;
  string s;
  string name;
  
  bVar11 = 0;
  psVar3 = init_string(&name);
  bVar2 = true;
  if (psVar3 == (string *)0x0) {
    return (uchar *)0x0;
  }
LAB_080d42ac:
  uVar9 = *prog;
  if (uVar9 != '\0') {
    do {
      sVar4 = 0;
      __n = 0;
      puVar10 = prog;
      if (uVar9 != '%') {
        do {
          sVar4 = sVar4 + 1;
          __n = sVar4;
          puVar10 = prog + sVar4;
          if (prog[sVar4] == '%') break;
        } while (prog[sVar4] != '\0');
      }
      if (assert_failed == 0) {
        if ((int)__n < 0) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_080d43b8;
        }
        else {
          assert_failed = 0;
        }
        if (__n != 0) {
          iVar5 = __n + name.length;
          uVar8 = name.length + 0xffU >> 8;
          uVar7 = name.length + 0xffU & 0xffffff00;
          size = iVar5 + 0x100U & 0xffffff00;
          if (uVar7 <= size && size + uVar8 * -0x100 != 0) {
            puVar6 = (uchar *)mem_realloc(name.source,size);
            if (puVar6 == (uchar *)0x0) goto LAB_080d434a;
            name.source = puVar6;
            memset(puVar6 + uVar7,0,size + uVar8 * -0x100);
          }
          if (name.source != (uchar *)0x0) {
            memcpy(name.source + name.length,prog,__n);
            name.source[iVar5] = '\0';
            name.length = iVar5;
          }
        }
LAB_080d434a:
        uVar9 = *puVar10;
      }
      else {
LAB_080d43b8:
        assert_failed = 0;
        uVar9 = *puVar10;
      }
      if (uVar9 == '%') goto LAB_080d43ca;
      prog = puVar10;
      if (uVar9 == '\0') break;
    } while( true );
  }
  if (!bVar2) {
    return name.source;
  }
  psVar3 = init_string(&s);
  if (psVar3 == (string *)0x0) {
    return name.source;
  }
  add_to_string(&s,(uchar *)"/bin/cat ");
  uVar8 = 0xffffffff;
  puVar10 = file;
  do {
    if (uVar8 == 0) break;
    uVar8 = uVar8 - 1;
    uVar1 = *puVar10;
    puVar10 = puVar10 + (uint)bVar11 * -2 + 1;
  } while (uVar9 != uVar1);
  add_shell_quoted_to_string(&s,file,~uVar8 - 1);
  add_to_string(&s," | ");
  add_string_to_string(&s,&name);
  done_string(&name);
  return s.source;
LAB_080d43ca:
  prog = puVar10 + 1;
  __n = strlen((char *)file);
  add_shell_quoted_to_string(&name,file,__n);
  bVar2 = false;
  goto LAB_080d42ac;
}



void tp_save(type_query *type_query)

{
  if (type_query->external_handler != (uchar *)0x0) {
    mem_free(type_query->external_handler);
  }
  type_query->external_handler = (uchar *)0x0;
  query_file(type_query->ses,type_query->uri,type_query,continue_download,tp_cancel,1);
  return;
}



void done_type_query(type_query *type_query)

{
  object *poVar1;
  
  cancel_download(&type_query->download,0);
  poVar1 = &type_query->cached->object;
  poVar1->refcount = poVar1->refcount + -1;
  done_uri(type_query->uri);
  if (type_query->external_handler != (uchar *)0x0) {
    mem_free(type_query->external_handler);
  }
  if (type_query->target_frame != (uchar *)0x0) {
    mem_free(type_query->target_frame);
  }
  type_query->next->prev = type_query->prev;
  type_query->prev->next = type_query->next;
  mem_free(type_query);
  return;
}



void tp_display(type_query *type_query)

{
  session *ses;
  uri *puVar1;
  uchar *puVar2;
  location *plVar3;
  view_state *pvVar4;
  
  ses = type_query->ses;
  puVar1 = ses->loading_uri;
  ses->loading_uri = type_query->uri;
  puVar2 = (ses->task).target.frame;
  (ses->task).target.frame = type_query->target_frame;
  pvVar4 = ses_forward(ses,0);
  if (pvVar4 != (view_state *)0x0) {
    pvVar4->plain = 1;
  }
  plVar3 = (ses->history).current;
  ses->loading_uri = puVar1;
  (ses->task).target.frame = puVar2;
  *(session **)&(plVar3->download).data = ses;
  (plVar3->download).callback = doc_loading_callback;
  move_download(&type_query->download,&plVar3->download,PRI_MAIN);
  display_timer(ses);
  done_type_query(type_query);
  return;
}



void tp_cancel(void *data)

{
  cancel_download((download *)((int)data + 8),1);
  done_type_query((type_query *)data);
  return;
}



void lun_resume(void *lun_hop_)

{
  int *piVar1;
  void *p;
  void *data;
  int iVar2;
  int iVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  
  puVar4 = *(undefined4 **)((int)lun_hop_ + 0x10);
  if (*(int *)puVar4[3] == 1) {
    puVar5 = (undefined4 *)mem_calloc(1,0xc);
    if (puVar5 == (undefined4 *)0x0) {
      lun_cancel(lun_hop_);
      return;
    }
    p = (void *)puVar4[3];
    data = *(void **)((int)p + 4);
    *puVar5 = 0;
    iVar2 = *(int *)((int)data + 0x3c);
    puVar5[1] = iVar2;
    iVar3 = *(int *)((int)data + 0x40);
    piVar1 = (int *)(iVar3 + 0x38);
    *piVar1 = *piVar1 + 1;
    *(int *)(iVar2 + 0x68) = iVar3;
    if ((*(int *)((int)data + 0x48) != 0) && (*(void **)((int)p + 0xc) != (void *)0x0)) {
      mem_free(*(void **)((int)p + 0xc));
    }
    tp_cancel(data);
    mem_free(p);
    *(undefined4 **)puVar4 = puVar5 + 2;
    *(undefined4 **)(puVar4 + 3) = puVar5;
    puVar4[2] = 0x80d4ff0;
    puVar4 = *(undefined4 **)((int)lun_hop_ + 0x10);
  }
  (**(code **)((int)lun_hop_ + 0xc))
            (*(undefined4 *)lun_hop_,*(undefined4 *)((int)lun_hop_ + 4),puVar4,1);
  if (*(void **)((int)lun_hop_ + 8) != (void *)0x0) {
    mem_free(*(void **)((int)lun_hop_ + 8));
  }
  mem_free(lun_hop_);
  return;
}



void __regparm3 download_error_dialog(file_download *file_download,int saved_errno)

{
  terminal *term;
  char *pcVar1;
  uchar *text;
  
  pcVar1 = strerror(saved_errno);
  term = file_download->term;
  if (file_download->ses != (session *)0x0) {
    text = msg_text(term,(uchar *)"Could not create file \'%s\':\n%s",file_download->file,pcVar1);
    info_box(term,MSGBOX_FREE_TEXT,(uchar *)"Download error",ALIGN_CENTER,text);
  }
  return;
}



void create_download_file_do(terminal *term,uchar *file,void *data,int resume)

{
  uchar uVar1;
  int __errnum;
  uchar *path;
  int *piVar2;
  uchar **ppuVar3;
  char *pcVar4;
  uchar *name;
  uchar *puVar5;
  int __oflag;
  size_t local_2c;
  
  __oflag = -1;
  __errnum = *(int *)((int)data + 4);
  if (file != (uchar *)0x0) {
    path = get_cwd();
    set_cwd(term->cwd);
    mkalldirs(file);
    __oflag = 0x41;
    if (resume == 0) {
      __oflag = (-(uint)(__errnum == 0) & 0xffffff80) + 0x2c1;
    }
    __oflag = open64((char *)file,__oflag,(-(uint)(__errnum == 0) & 0x36) + 0x180);
    piVar2 = __errno_location();
    __errnum = *piVar2;
    if (path != (uchar *)0x0) {
      set_cwd(path);
      mem_free(path);
    }
    if (__oflag == -1) {
      pcVar4 = strerror(__errnum);
      path = msg_text(term,(uchar *)"Could not create file \'%s\':\n%s",file,pcVar4);
      info_box(term,MSGBOX_FREE_TEXT,(uchar *)"Download error",ALIGN_CENTER,path);
      mem_free(file);
    }
    else {
      set_bin(__oflag);
      if (*(int *)((int)data + 4) == 0) {
        ppuVar3 = (uchar **)get_opt_(config_options,name);
        path = *ppuVar3;
        safe_strncpy(path,file,0x400);
        local_2c = strlen((char *)path);
        if (-1 < (int)local_2c) {
          puVar5 = path + local_2c;
          uVar1 = *puVar5;
          while (uVar1 != '/') {
            local_2c = local_2c - 1;
            if (local_2c == 0xffffffff) {
              local_2c = 0xffffffff;
              break;
            }
            uVar1 = puVar5[-1];
            puVar5 = puVar5 + -1;
          }
        }
        path[local_2c + 1] = '\0';
      }
      if (*(uchar ***)data == (uchar **)0x0) {
        mem_free(file);
      }
      else {
        **(uchar ***)data = file;
      }
    }
  }
  (**(code **)((int)data + 8))(term,__oflag,*(undefined4 *)((int)data + 0xc),resume);
  mem_free(data);
  return;
}



void abort_download(file_download *file_download)

{
  uchar *p;
  
  done_download_display(file_download);
  if (file_download->ses != (session *)0x0) {
    check_questions_queue(file_download->ses);
  }
  if (file_download->dlg_data != (dialog_data *)0x0) {
    cancel_dialog(file_download->dlg_data,(widget_data *)0x0);
  }
  cancel_download(&file_download->download,(uint)(*(byte *)&file_download->field_0x68 >> 1) & 1);
  if (file_download->uri != (uri *)0x0) {
    done_uri(file_download->uri);
  }
  if (file_download->handle != -1) {
    close(file_download->handle);
  }
  if (file_download->external_handler != (uchar *)0x0) {
    mem_free(file_download->external_handler);
  }
  p = file_download->file;
  if (p != (uchar *)0x0) {
    if ((*(byte *)&file_download->field_0x68 & 1) != 0) {
      unlink((char *)p);
      p = file_download->file;
    }
    mem_free(p);
  }
  file_download->next->prev = file_download->prev;
  file_download->prev->next = file_download->next;
  mem_free(file_download);
  return;
}



// WARNING: Type propagation algorithm not settling

void __regparm3 kill_downloads_to_file(uchar *file)

{
  int iVar1;
  file_download *pfVar2;
  
  pfVar2 = (file_download *)downloads.next;
  if ((list_head_elinks *)downloads.next != &downloads) {
    do {
      while (iVar1 = strcmp((char *)((object *)&pfVar2->file)->refcount,(char *)file), iVar1 == 0) {
        pfVar2 = pfVar2->prev;
        abort_download(pfVar2->next);
        pfVar2 = pfVar2->next;
        if (pfVar2 == (file_download *)&downloads) {
          return;
        }
      }
      pfVar2 = pfVar2->next;
    } while (pfVar2 != (file_download *)&downloads);
  }
  return;
}



void detach_downloads_from_terminal(terminal *term)

{
  file_download *pfVar1;
  bool bVar2;
  file_download *file_download;
  file_download *pfVar3;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(term == (terminal *)0x0);
  if (term == (terminal *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c";
    errline = 0xe3;
    elinks_internal((uchar *)"assertion term != NULL failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  file_download = (file_download *)downloads.next;
  pfVar3 = *(file_download **)downloads.next;
  if ((list_head_elinks *)downloads.next != &downloads) {
    do {
      if (file_download->term == term) {
        if (file_download->external_handler == (uchar *)0x0) {
          file_download->term = (terminal *)0x0;
          if ((file_download->ses != (session *)0x0) && (term == file_download->ses->tab->term)) {
            file_download->ses = (session *)0x0;
          }
          goto LAB_080d4b50;
        }
        abort_download(file_download);
        pfVar1 = pfVar3->next;
      }
      else {
LAB_080d4b50:
        pfVar1 = pfVar3->next;
      }
      bVar2 = pfVar3 != (file_download *)&downloads;
      file_download = pfVar3;
      pfVar3 = pfVar1;
    } while (bVar2);
  }
  return;
}



void destroy_downloads(session *ses)

{
  list_head_elinks *plVar1;
  file_download *file_download;
  session *psVar2;
  file_download *pfVar3;
  bool bVar4;
  
  psVar2 = (session *)sessions.next;
  if ((list_head_elinks *)sessions.next != &sessions) {
    do {
      if ((psVar2 != ses) && (psVar2->tab->term == ses->tab->term)) {
        plVar1 = (list_head_elinks *)downloads.next;
        if ((list_head_elinks *)downloads.next == &downloads) {
          return;
        }
        do {
          while ((session *)plVar1[3].next != ses) {
            plVar1 = (list_head_elinks *)plVar1->next;
            if (plVar1 == &downloads) {
              return;
            }
          }
          *(session **)&plVar1[3].next = psVar2;
          plVar1 = (list_head_elinks *)plVar1->next;
        } while (plVar1 != &downloads);
        return;
      }
      psVar2 = psVar2->next;
    } while (psVar2 != (session *)&sessions);
  }
  file_download = (file_download *)downloads.next;
  pfVar3 = *(file_download **)downloads.next;
  if ((list_head_elinks *)downloads.next == &downloads) {
    return;
  }
  do {
    if (file_download->ses == ses) {
      if (file_download->external_handler == (uchar *)0x0) {
        file_download->ses = (session *)0x0;
      }
      else {
        abort_download(file_download);
      }
    }
    bVar4 = pfVar3 != (file_download *)&downloads;
    file_download = pfVar3;
    pfVar3 = pfVar3->next;
  } while (bVar4);
  return;
}



void abort_all_downloads(void)

{
  if ((list_head_elinks *)downloads.next != &downloads) {
    do {
      abort_download((file_download *)downloads.next);
    } while ((list_head_elinks *)downloads.next != &downloads);
  }
  return;
}



file_download * init_file_download(uri *uri,session *ses,uchar *file,int fd)

{
  file_download *file_download;
  uri *puVar1;
  file_download *pfVar2;
  
  file_download = (file_download *)mem_calloc(1,0x74);
  pfVar2 = file_download;
  if (file_download != (file_download *)0x0) {
    puVar1 = get_composed_uri(uri,URI_BASE);
    file_download->uri = puVar1;
    if (puVar1 == (uri *)0x0) {
      pfVar2 = (file_download *)0x0;
      mem_free(file_download);
    }
    else {
      init_download_display(file_download);
      file_download->file = file;
      (file_download->download).callback = download_data;
      *(file_download **)&(file_download->download).data = file_download;
      file_download->ses = ses;
      file_download->handle = fd;
      file_download->term = ses->tab->term;
      *(list_head_elinks **)&file_download->prev = &downloads;
      file_download->next = downloads.next;
      downloads.next = file_download;
      file_download->next->prev = file_download;
    }
  }
  return pfVar2;
}



void continue_download_do(terminal *term,int fd,void *data,int resume)

{
  type_query *type_query;
  file_download *file_download;
  uchar *puVar1;
  bool bVar2;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(data == (void *)0x0);
    if (data == (void *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c";
      errline = 0x379;
      elinks_internal((uchar *)"assertion codw_hop failed!");
      if (assert_failed != 0) goto LAB_080d4e1e;
    }
    bVar2 = *(int *)((int)data + 4) == 0;
    assert_failed = ZEXT14(bVar2);
    if (bVar2) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c";
      errline = 0x37a;
      elinks_internal((uchar *)"assertion codw_hop->type_query failed!");
      if (assert_failed != 0) goto LAB_080d4e1e;
    }
    bVar2 = *(int *)(*(int *)((int)data + 4) + 0x40) == 0;
    assert_failed = ZEXT14(bVar2);
    if (bVar2) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c";
      errline = 0x37b;
      elinks_internal((uchar *)"assertion codw_hop->type_query->uri failed!");
      if (assert_failed != 0) goto LAB_080d4e1e;
    }
    bVar2 = *(int *)(*(int *)((int)data + 4) + 0x3c) == 0;
    assert_failed = ZEXT14(bVar2);
    if (bVar2) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c";
      errline = 0x37c;
      elinks_internal((uchar *)"assertion codw_hop->type_query->ses failed!");
    }
  }
LAB_080d4e1e:
  type_query = *(type_query **)((int)data + 4);
  if ((*(uchar **)((int)data + 8) != (uchar *)0x0) &&
     (file_download =
           init_file_download(type_query->uri,type_query->ses,*(uchar **)((int)data + 8),fd),
     file_download != (file_download *)0x0)) {
    if (type_query->external_handler != (uchar *)0x0) {
      puVar1 = subst_file(type_query->external_handler,*(uchar **)((int)data + 0xc));
      *(byte *)&file_download->field_0x68 = *(byte *)&file_download->field_0x68 | 1;
      file_download->external_handler = puVar1;
      mem_free(*(void **)((int)data + 0xc));
      if (type_query->external_handler != (uchar *)0x0) {
        mem_free(type_query->external_handler);
      }
      type_query->external_handler = (uchar *)0x0;
    }
    *(byte *)&file_download->field_0x68 =
         *(byte *)&file_download->field_0x68 & 0xfb | (type_query->block != 0) << 2;
    display_download(term,file_download,type_query->ses);
    move_download(&type_query->download,&file_download->download,PRI_MAIN);
    done_type_query(type_query);
    mem_free(data);
    return;
  }
  if ((type_query->external_handler != (uchar *)0x0) && (*(void **)((int)data + 0xc) != (void *)0x0)
     ) {
    mem_free(*(void **)((int)data + 0xc));
  }
  tp_cancel(type_query);
  mem_free(data);
  return;
}



void common_download_do(terminal *term,int fd,void *data,int resume)

{
  uchar *file;
  session *ses;
  int iVar1;
  file_download *file_download;
  stat buf;
  
  file = *(uchar **)((int)data + 8);
  ses = *(session **)((int)data + 4);
  mem_free(data);
  if (file != (uchar *)0x0) {
    iVar1 = __fxstat64(3,fd,(stat64 *)&buf);
    if (iVar1 == 0) {
      file_download = init_file_download(ses->download_uri,ses,file,fd);
      if (file_download != (file_download *)0x0) {
        if (resume != 0) {
          *(undefined4 *)&file_download->seek = (undefined4)buf.st_size;
          *(undefined4 *)((int)&file_download->seek + 4) = buf.st_size._4_4_;
        }
        display_download(ses->tab->term,file_download,ses);
        load_uri(file_download->uri,ses->referrer,&file_download->download,PRI_MAIN,
                 CACHE_MODE_NORMAL,file_download->seek);
      }
    }
  }
  return;
}



void __regparm3 abort_download_and_beep(file_download *file_download,terminal *term)

{
  int *piVar1;
  
  if (term != (terminal *)0x0) {
    piVar1 = get_opt_(config_options,(uchar *)term);
    if (1 < file_download->notify + *piVar1) {
      beep_terminal(term);
    }
  }
  abort_download(file_download);
  return;
}



void __regparm3 download_data_store(download *download,file_download *file_download)

{
  terminal *suspect;
  connection_basic_state cVar1;
  connection_state state;
  uchar *p;
  uchar *text;
  int *piVar2;
  utimbuf foo;
  
  suspect = file_download->term;
  assert_terminal_ptr_not_dangling(suspect);
  if (assert_failed == 0) {
    if (suspect != (terminal *)0x0) {
      cVar1 = (download->state).basic;
      if (-1 < cVar1) {
        if (file_download->dlg_data == (dialog_data *)0x0) {
          return;
        }
        redraw_dialog(file_download->dlg_data,1);
        return;
      }
      if (cVar1 == S_OK) {
        if (file_download->external_handler != (uchar *)0x0) {
          close(file_download->handle);
          file_download->handle = -1;
          exec_on_terminal(suspect,file_download->external_handler,file_download->file,
                           (uint)(*(byte *)&file_download->field_0x68 >> 2) & TERM_EXEC_FG);
          *(byte *)&file_download->field_0x68 = *(byte *)&file_download->field_0x68 & 0xfe;
          abort_download_and_beep(file_download,suspect);
          return;
        }
        if (file_download->notify != 0) {
          p = get_uri_string(file_download->uri,URI_PUBLIC);
          done_download_display(file_download);
          if (p != (uchar *)0x0) {
            text = msg_text(suspect,(uchar *)"Download complete:\n%s",p);
            info_box(suspect,MSGBOX_FREE_TEXT,(uchar *)"Download",ALIGN_CENTER,text);
            mem_free(p);
          }
        }
        if (((uchar *)file_download->remotetime != (uchar *)0x0) &&
           (piVar2 = get_opt_(config_options,(uchar *)file_download->remotetime), *piVar2 != 0)) {
          foo.actime = file_download->remotetime;
          foo.modtime = foo.actime;
          utime((char *)file_download->file,(utimbuf *)&foo);
        }
        abort_download_and_beep(file_download,suspect);
        return;
      }
      p = get_uri_string(file_download->uri,URI_PUBLIC);
      state = download->state;
      abort_download_and_beep(file_download,suspect);
      if (p == (uchar *)0x0) {
        return;
      }
      text = get_state_message(state,suspect);
      text = msg_text(suspect,(uchar *)"Error downloading %s:\n\n%s",p,text);
      info_box(suspect,MSGBOX_FREE_TEXT,(uchar *)"Download error",ALIGN_CENTER,text);
      mem_free(p);
      return;
    }
  }
  else {
    assert_failed = 0;
    file_download->term = (terminal *)0x0;
  }
  abort_download(file_download);
  return;
}



void download_data(download *download,file_download *file_download)

{
  object *poVar1;
  cache_entry *pcVar2;
  progress *ppVar3;
  void *pvVar4;
  uri *puVar5;
  dialog_data *dlg_data;
  time_t tVar6;
  void *pvVar7;
  uint uVar8;
  int *piVar9;
  connection_basic_state cVar10;
  undefined4 uVar11;
  int __fd;
  undefined4 uVar12;
  list_head_elinks *plVar13;
  __off64_t _Var14;
  void *local_24;
  int local_20;
  
  pcVar2 = download->cached;
  if ((pcVar2 != (cache_entry *)0x0) && (7 < (uint)(download->state).basic)) {
    if (pcVar2->last_modified != (uchar *)0x0) {
      tVar6 = parse_date(&pcVar2->last_modified,(uchar *)0x0,0,1);
      file_download->remotetime = tVar6;
    }
    if ((pcVar2->redirect != (uri *)0x0) &&
       (__fd = file_download->redirect_cnt, file_download->redirect_cnt = __fd + 1, __fd < 10)) {
      cancel_download(&file_download->download,0);
      if (assert_failed == 0) {
        __fd = compare_uri(pcVar2->uri,file_download->uri,0);
        assert_failed = ZEXT14(__fd == 0);
        if (__fd == 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c";
          errline = 0x1a5;
          elinks_internal((uchar *)
                          "assertion compare_uri(cached->uri, file_download->uri, 0) failed: Redirecting using bad base URI"
                         );
        }
      }
      done_uri(file_download->uri);
      puVar5 = pcVar2->redirect;
      poVar1 = &puVar5->object;
      poVar1->refcount = poVar1->refcount + 1;
      file_download->uri = puVar5;
      if (assert_failed == 0) {
        cVar10 = S_WAIT_REDIR;
      }
      else {
        cVar10 = S_INTERNAL;
      }
      assert_failed = 0;
      (file_download->download).state.basic = cVar10;
      dlg_data = file_download->dlg_data;
      (file_download->download).state.syserr = 0;
      if (dlg_data != (dialog_data *)0x0) {
        redraw_dialog(dlg_data,1);
      }
      uVar11 = 0;
      ppVar3 = download->progress;
      uVar12 = 0;
      if (ppVar3 != (progress *)0x0) {
        uVar11 = *(undefined4 *)&ppVar3->start;
        uVar12 = *(undefined4 *)((int)&ppVar3->start + 4);
      }
      load_uri(file_download->uri,pcVar2->uri,&file_download->download,PRI_MAIN,CACHE_MODE_NORMAL,
               CONCAT44(uVar12,uVar11));
      return;
    }
    ppVar3 = (file_download->download).progress;
    if (ppVar3 != (progress *)0x0) {
      uVar8 = *(uint *)((int)&ppVar3->seek + 4);
      if ((uVar8 | *(uint *)&ppVar3->seek) != 0) {
        *(uint *)&file_download->seek = *(uint *)&ppVar3->seek;
        *(uint *)((int)&file_download->seek + 4) = uVar8;
        *(undefined4 *)&ppVar3->seek = 0;
        *(undefined4 *)((int)&ppVar3->seek + 4) = 0;
        _Var14 = lseek64(file_download->handle,file_download->seek,0);
        if (_Var14 < 0) {
          piVar9 = __errno_location();
          download_error_dialog(file_download,*piVar9);
LAB_080d5474:
          detach_connection(download,file_download->seek);
          abort_download(file_download);
          return;
        }
      }
    }
    plVar13 = (list_head_elinks *)(pcVar2->frag).next;
    if (&pcVar2->frag == plVar13) {
      local_24 = *(void **)&file_download->seek;
      local_20 = *(int *)((int)&file_download->seek + 4);
    }
    else {
      local_24 = *(void **)&file_download->seek;
      local_20 = *(int *)((int)&file_download->seek + 4);
      do {
        pvVar7 = (void *)((int)local_24 - (int)plVar13[1].next);
        __fd = (local_20 - (int)plVar13[1].prev) - (uint)(local_24 < plVar13[1].next);
        if (-1 < __fd) {
          pvVar4 = plVar13[2].next;
          if ((__fd <= (int)plVar13[2].prev) && ((__fd < (int)plVar13[2].prev || (pvVar7 < pvVar4)))
             ) {
            __fd = file_download->handle;
            while (uVar8 = write(__fd,(void *)((int)plVar13 + (int)pvVar7 + 0x20U),
                                 (size_t)((int)pvVar4 - (int)pvVar7)), uVar8 == 0xffffffff) {
              piVar9 = __errno_location();
              if (*piVar9 != 4) {
                download_error_dialog(file_download,*piVar9);
                goto LAB_080d5474;
              }
            }
            local_24 = (void *)(uVar8 + *(uint *)&file_download->seek);
            local_20 = ((int)uVar8 >> 0x1f) + *(int *)((int)&file_download->seek + 4) +
                       (uint)CARRY4(uVar8,*(uint *)&file_download->seek);
            *(void **)&file_download->seek = local_24;
            *(int *)((int)&file_download->seek + 4) = local_20;
          }
        }
        plVar13 = (list_head_elinks *)plVar13->next;
      } while (&pcVar2->frag != plVar13);
    }
    detach_connection(download,CONCAT44(local_20,local_24));
  }
  download_data_store(download,file_download);
  return;
}



int download_is_progressing(download *download)

{
  int iVar1;
  
  if ((download != (download *)0x0) && ((download->state).basic == S_TRANS)) {
    iVar1 = has_progress(download->progress);
    return (uint)(iVar1 != 0);
  }
  return 0;
}



// WARNING: Exceeded maximum restarts with more pending

void create_download_file
               (terminal *term,uchar *fi,uchar **real_file,int safe,int resume,
               anon_subr_void_terminal_ptr_int_void_ptr_int *callback,void *data)

{
  int iVar1;
  terminal *data_00;
  uchar *path;
  int *piVar2;
  int iVar3;
  terminal *p;
  terminal **udata;
  uchar *text;
  terminal *p_00;
  
  data_00 = (terminal *)mem_calloc(1,0x10);
  if (data_00 == (terminal *)0x0) {
                    // WARNING: Could not recover jumptable at 0x080d59ce. Too many branches
                    // WARNING: Treating indirect jump as call
    (*callback)();
    return;
  }
  *(uchar ***)&data_00->next = real_file;
  *(int *)&data_00->prev = safe;
  (data_00->windows).prev = data;
  *(anon_subr_void_terminal_ptr_int_void_ptr_int **)&(data_00->windows).next = callback;
  path = get_cwd();
  set_cwd(term->cwd);
  p_00 = (terminal *)expand_tilde(fi);
  if (resume != 0) {
    create_download_file_do(term,(uchar *)p_00,data_00,resume);
    goto joined_r0x080d5909;
  }
  piVar2 = get_opt_(config_options,(uchar *)p_00);
  iVar1 = *piVar2;
  if (iVar1 == 0) {
    create_download_file_do(term,(uchar *)p_00,data_00,0);
    goto joined_r0x080d5909;
  }
  iVar3 = file_is_dir((uchar *)p_00);
  if (iVar3 == 0) {
    p = (terminal *)get_unique_name((uchar *)p_00);
    if ((p == (terminal *)0x0) || (iVar1 == 1)) {
      if (p_00 != p) {
        mem_free(p_00);
      }
    }
    else {
      if (p_00 != p) {
        udata = (terminal **)mem_calloc(1,0x14);
        if (udata != (terminal **)0x0) {
          *udata = term;
          udata[1] = p_00;
          udata[4] = data_00;
          *(code **)(udata + 3) = create_download_file_do;
          udata[2] = p;
          if (p_00 == (terminal *)0x0) {
            p_00 = (terminal *)&DAT_0812e3d8;
          }
          text = msg_text(term,(uchar *)
                               "This file already exists:\n%s\n\nThe alternative filename is:\n%s",
                          p_00,p);
          msg_box(term,(memory_list *)0x0,MSGBOX_FREE_TEXT,(uchar *)"File exists",ALIGN_CENTER,text,
                  udata,4,"Sa~ve under the alternative name",lun_alternate,1,
                  "~Overwrite the original file",lun_overwrite,0,
                  "~Resume download of the original file",lun_resume,0,"~Cancel",lun_cancel,2);
          goto joined_r0x080d5909;
        }
        mem_free(p);
        goto LAB_080d5980;
      }
    }
    create_download_file_do(term,(uchar *)p,data_00,0);
  }
  else {
    text = msg_text(term,(uchar *)"\'%s\' is a directory.",p_00);
    info_box(term,MSGBOX_FREE_TEXT,(uchar *)"Download error",ALIGN_CENTER,text);
LAB_080d5980:
    mem_free(p_00);
    create_download_file_do(term,(uchar *)0x0,data_00,0);
  }
joined_r0x080d5909:
  if (path == (uchar *)0x0) {
    return;
  }
  set_cwd(path);
  mem_free(path);
  return;
}



void continue_download(void *data,uchar *file)

{
  uri *uri;
  undefined4 *p;
  string *psVar1;
  uchar *source;
  size_t cmdlen;
  string name;
  
  p = (undefined4 *)mem_calloc(1,0x10);
  if (p != (undefined4 *)0x0) {
    if (*(int *)((int)data + 0x48) == 0) {
LAB_080d5aa1:
      *(void **)(p + 1) = data;
      *(uchar **)(p + 3) = file;
      *p = 1;
      kill_downloads_to_file(file);
      create_download_file
                (*(terminal **)(*(int *)(*(int *)((int)data + 0x3c) + 8) + 0x14),file,
                 (uchar **)(p + 2),(uint)(*(int *)((int)data + 0x48) != 0),0,continue_download_do,p)
      ;
      return;
    }
    uri = *(uri **)((int)data + 0x40);
    source = (uchar *)tempnam((char *)0x0,"elinks");
    if (source != (uchar *)0x0) {
      psVar1 = init_string(&name);
      if (psVar1 == (string *)0x0) {
        free(source);
      }
      else {
        add_to_string(&name,source);
        free(source);
        source = get_extension_from_uri(uri);
        if (source != (uchar *)0x0) {
          cmdlen = strlen((char *)source);
          add_shell_safe_to_string(&name,source,cmdlen);
          mem_free(source);
        }
        file = name.source;
        if (name.source != (uchar *)0x0) goto LAB_080d5aa1;
      }
    }
    mem_free(p);
  }
  tp_cancel(data);
  return;
}



void tp_open(type_query *type_query)

{
  uchar *src;
  uchar *path;
  
  if ((type_query->external_handler == (uchar *)0x0) || (*type_query->external_handler == '\0')) {
    tp_display(type_query);
    return;
  }
  if ((type_query->uri->protocol == 4) && ((*(byte *)&type_query->field_0x50 & 1) == 0)) {
    src = get_uri_string(type_query->uri,URI_PATH);
    if (src != (uchar *)0x0) {
      decode_uri(src);
      path = subst_file(type_query->external_handler,src);
      mem_free(src);
      if (path != (uchar *)0x0) {
        exec_on_terminal(type_query->ses->tab->term,path,"",(uint)(type_query->block != 0));
        mem_free(path);
      }
    }
    done_type_query(type_query);
    return;
  }
  continue_download(type_query,"");
  return;
}



void __regparm3 common_download(session *ses,uchar *file,int resume)

{
  undefined4 *data;
  
  if (ses->download_uri != (uri *)0x0) {
    data = (undefined4 *)mem_calloc(1,0xc);
    if (data != (undefined4 *)0x0) {
      *(session **)(data + 1) = ses;
      *data = 0;
      kill_downloads_to_file(file);
      create_download_file
                (ses->tab->term,file,(uchar **)(data + 2),0,resume,common_download_do,data);
    }
  }
  return;
}



void resume_download(void *ses,uchar *file)

{
  common_download((session *)ses,file,1);
  return;
}



void start_download(void *ses,uchar *file)

{
  common_download((session *)ses,file,0);
  return;
}



int setup_download_handler(session *ses,download *loading,cache_entry *cached,int frame)

{
  object *poVar1;
  dialog *text;
  type_query *ptVar2;
  uri *puVar3;
  type_query *ptVar4;
  terminal *term;
  uchar *codeset;
  view_state *pvVar5;
  char *s2;
  int cp_index;
  mime_handler *p;
  type_query *type_query;
  uchar *puVar6;
  connection_basic_state cVar7;
  dialog *dlg;
  string *psVar8;
  uchar *src;
  int *piVar9;
  memory_list *ml;
  dialog_data *dlg_data;
  size_t sVar10;
  uchar *name;
  mime_handler *extraout_EDX;
  mime_handler *name_00;
  uchar *extraout_EDX_00;
  uchar *extraout_EDX_01;
  mime_handler *extraout_EDX_02;
  uint uVar11;
  int cp_index_00;
  bool bVar12;
  uchar *local_44;
  char *local_3c;
  undefined1 *local_30;
  string filename;
  
  codeset = get_content_type(cached);
  if ((codeset == (uchar *)0x0) || (*codeset == '\0')) {
plaintext_follow:
    uVar11 = 1;
LAB_080d5d07:
    pvVar5 = ses_forward(ses,frame);
    if (pvVar5 != (view_state *)0x0) {
      pvVar5->plain = uVar11;
    }
    return 0;
  }
  s2 = "text/html";
  cp_index_00 = 0;
  do {
    cp_index = c_strcasecmp((char *)codeset,s2);
    if (cp_index == 0) {
      uVar11 = (uint)*(byte *)&known_types[cp_index_00].field_0x4 & 1;
      goto LAB_080d5d07;
    }
    cp_index_00 = cp_index_00 + 1;
    s2 = (char *)known_types[cp_index_00].type;
  } while ((uchar *)s2 != (uchar *)0x0);
  p = get_mime_type_handler((uchar *)(ses->tab->term->environment & 2),(int)codeset);
  if (((p == (mime_handler *)0x0) && (sVar10 = strlen((char *)codeset), 3 < sVar10)) &&
     (cp_index_00 = c_strncasecmp((char *)codeset,"text",4), cp_index_00 == 0))
  goto plaintext_follow;
  ptVar2 = (type_query *)(ses->type_queries).next;
  while (ptVar2 != (type_query *)&ses->type_queries) {
    cp_index_00 = compare_uri(ptVar2->uri,ses->loading_uri,0);
    if (cp_index_00 != 0) goto LAB_080d5dcc;
    ptVar2 = ptVar2->next;
  }
  type_query = (type_query *)mem_calloc(1,0x54);
  if (type_query == (type_query *)0x0) {
LAB_080d5dcc:
    cp_index_00 = 0;
  }
  else {
    puVar3 = ses->loading_uri;
    poVar1 = &puVar3->object;
    poVar1->refcount = poVar1->refcount + 1;
    type_query->uri = puVar3;
    puVar6 = (uchar *)0x0;
    type_query->ses = ses;
    src = (ses->task).target.frame;
    if (src != (uchar *)0x0) {
      puVar6 = stracpy(src);
    }
    type_query->target_frame = puVar6;
    type_query->cached = cached;
    *(byte *)&type_query->field_0x50 =
         *(byte *)&type_query->field_0x50 & 0xfe | *(byte *)&cached->field_0x5c >> 6 & 1;
    (cached->object).refcount = (cached->object).refcount + 1;
    move_download(loading,&type_query->download,PRI_MAIN);
    if (assert_failed == 0) {
      cVar7 = S_OK;
    }
    else {
      cVar7 = S_INTERNAL;
    }
    assert_failed = 0;
    (loading->state).basic = cVar7;
    (loading->state).syserr = 0;
    ptVar4 = ptVar2->next;
    type_query->prev = ptVar2;
    type_query->next = ptVar4;
    ptVar2->next = type_query;
    type_query->next->prev = type_query;
    term = type_query->ses->tab->term;
    if (type_query->external_handler != (uchar *)0x0) {
      mem_free(type_query->external_handler);
    }
    type_query->external_handler = (uchar *)0x0;
    if (p != (mime_handler *)0x0) {
      type_query->block = (uint)(*(byte *)&p->field_0x8 >> 1) & 1;
      if ((*(byte *)&p->field_0x8 & 1) != 0) {
        local_44 = p->description;
        local_30 = &DAT_0812e3d8;
        if (*local_44 != '\0') {
          local_30 = &DAT_081327c1;
        }
        local_3c = "What to do?";
        goto LAB_080d5f3e;
      }
      codeset = stracpy(p->program);
      type_query->external_handler = codeset;
      tp_open(type_query);
LAB_080d679b:
      cp_index_00 = 1;
      goto LAB_080d5dd9;
    }
    local_3c = "Unknown type";
    local_30 = &DAT_0812e3d8;
    local_44 = "";
LAB_080d5f3e:
    dlg = (dialog *)mem_calloc(1,0x9a4);
    if (dlg == (dialog *)0x0) {
LAB_080d6494:
      cp_index_00 = 1;
    }
    else {
      psVar8 = init_string(&filename);
      if (psVar8 != (string *)0x0) {
        add_mime_filename_to_string(&filename,type_query->uri);
        if ((*(byte *)&term->field_0x38 & 2) == 0) {
          decode_uri_string_for_display(&filename);
        }
        else {
          decode_uri_string(&filename);
        }
      }
      text = dlg + 5;
      if (filename.length == 0) {
        if ((term != (terminal *)0x0) &&
           (cp_index_00 = get_terminal_codepage(term), cp_index_00 != current_charset)) {
          src = get_cp_mime_name(cp_index_00);
          bind_textdomain_codeset("elinks",src);
          current_charset = cp_index_00;
        }
        src = gettext((uchar *)"What would you like to do with the file (type: %s%s%s)?");
        __snprintf_chk(text,0x400,1,0xffffffff,src,codeset,local_30,local_44);
      }
      else {
        if ((term != (terminal *)0x0) &&
           (cp_index_00 = get_terminal_codepage(term), cp_index_00 != current_charset)) {
          src = get_cp_mime_name(cp_index_00);
          bind_textdomain_codeset("elinks",src);
          current_charset = cp_index_00;
        }
        src = gettext((uchar *)"What would you like to do with the file \'%s\' (type: %s%s%s)?");
        __snprintf_chk(text,0x400,1,0xffffffff,src,filename.source,codeset,local_30,local_44);
      }
      done_string(&filename);
      if (*local_3c != '\0') {
        if ((term != (terminal *)0x0) &&
           (cp_index_00 = get_terminal_codepage(term), cp_index_00 != current_charset)) {
          codeset = get_cp_mime_name(cp_index_00);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index_00;
        }
        local_3c = (char *)gettext((uchar *)local_3c);
      }
      *(byte *)&dlg->layout = *(byte *)&dlg->layout | 6;
      dlg->layouter = generic_dialog_layouter;
      *(char **)&dlg->title = local_3c;
      *(type_query **)&dlg->udata2 = type_query;
      add_dlg_text(dlg,(uchar *)text,ALIGN_LEFT,0);
      piVar9 = get_opt_(cmdline_options,name);
      if (*piVar9 == 0) {
        codeset = (uchar *)mem_calloc(1,0x400);
        if (codeset != (uchar *)0x0) {
          if (p != (mime_handler *)0x0) {
            safe_strncpy(codeset,p->program,0x400);
          }
          if ((term != (terminal *)0x0) &&
             (cp_index_00 = get_terminal_codepage(term), cp_index_00 != current_charset)) {
            src = get_cp_mime_name(cp_index_00);
            bind_textdomain_codeset("elinks",src);
            current_charset = cp_index_00;
          }
          src = gettext((uchar *)"Program (\'%\' will be replaced by the filename)");
          add_dlg_field_do(dlg,WIDGET_FIELD,src,0,0,(widget_handler_T *)0x0,0x400,codeset,
                           (input_history *)0x0,INPFIELD_NONE);
          type_query->external_handler = codeset;
          if ((term != (terminal *)0x0) &&
             (cp_index_00 = get_terminal_codepage(term), cp_index_00 != current_charset)) {
            codeset = get_cp_mime_name(cp_index_00);
            bind_textdomain_codeset("elinks",codeset);
            current_charset = cp_index_00;
          }
          codeset = gettext((uchar *)"Block the terminal");
          cp_index_00 = 8;
          add_dlg_radio_do(dlg,codeset,0,0,&type_query->block);
          local_30 = (undefined1 *)0x3;
          name_00 = extraout_EDX_02;
          goto LAB_080d61bb;
        }
      }
      else {
        if (p == (mime_handler *)0x0) {
          local_30 = (undefined1 *)0x1;
          cp_index_00 = 6;
          name_00 = p;
        }
        else {
          if ((term != (terminal *)0x0) &&
             (cp_index_00 = get_terminal_codepage(term), cp_index_00 != current_charset)) {
            codeset = get_cp_mime_name(cp_index_00);
            bind_textdomain_codeset("elinks",codeset);
            current_charset = cp_index_00;
          }
          codeset = gettext((uchar *)"The file will be opened with the program \'%s\'.");
          __snprintf_chk(&dlg[0x11].layouter,0x400,1,0xffffffff,codeset,p->program);
          add_dlg_text(dlg,(uchar *)&dlg[0x11].layouter,ALIGN_LEFT,0);
          cp_index_00 = 7;
          codeset = stracpy(p->program);
          type_query->external_handler = codeset;
          local_30 = (undefined1 *)0x2;
          name_00 = extraout_EDX;
          if (codeset == (uchar *)0x0) {
            mem_free(dlg);
            goto LAB_080d679b;
          }
        }
LAB_080d61bb:
        piVar9 = get_opt_(cmdline_options,(uchar *)name_00);
        if ((*piVar9 == 0) || (p != (mime_handler *)0x0)) {
          if ((term != (terminal *)0x0) &&
             (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
            codeset = get_cp_mime_name(cp_index);
            bind_textdomain_codeset("elinks",codeset);
            current_charset = cp_index;
          }
          codeset = gettext((uchar *)"~Open");
          add_dlg_button_do(dlg,codeset,1,ok_dialog,(void *)0x0,tp_open,type_query);
          codeset = extraout_EDX_01;
        }
        else {
          cp_index_00 = cp_index_00 + -1;
          codeset = extraout_EDX_00;
        }
        piVar9 = get_opt_(cmdline_options,codeset);
        if (*piVar9 == 0) {
          if ((term != (terminal *)0x0) &&
             (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
            codeset = get_cp_mime_name(cp_index);
            bind_textdomain_codeset("elinks",codeset);
            current_charset = cp_index;
          }
          codeset = gettext((uchar *)"Sa~ve");
          add_dlg_button_do(dlg,codeset,1,ok_dialog,(void *)0x0,tp_save,type_query);
        }
        else {
          cp_index_00 = cp_index_00 + -1;
        }
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        codeset = gettext((uchar *)"~Display");
        add_dlg_button_do(dlg,codeset,1,ok_dialog,(void *)0x0,tp_display,type_query);
        if ((type_query->cached == (cache_entry *)0x0) || (type_query->cached->head == (uchar *)0x0)
           ) {
          cp_index_00 = cp_index_00 + -1;
        }
        else {
          if ((term != (terminal *)0x0) &&
             (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
            codeset = get_cp_mime_name(cp_index);
            bind_textdomain_codeset("elinks",codeset);
            current_charset = cp_index;
          }
          codeset = gettext((uchar *)"Show ~header");
          add_dlg_button_do(dlg,codeset,1,tp_show_header,type_query,(done_handler_T *)0x0,
                            (void *)0x0);
        }
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        codeset = gettext((uchar *)"~Cancel");
        add_dlg_button_do(dlg,codeset,2,ok_dialog,(void *)0x0,tp_cancel,type_query);
        if ((assert_failed == 0) &&
           (bVar12 = dlg->number_of_widgets != cp_index_00, assert_failed = ZEXT14(bVar12), bVar12))
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c";
          errline = 0x4e0;
          elinks_internal((uchar *)"assertion widgets == (dlg)->number_of_widgets failed!");
        }
        ml = getml(dlg,0);
        if (ml != (memory_list *)0x0) {
          dlg_data = do_dialog(term,dlg,ml);
          if (dlg_data != (dialog_data *)0x0) {
            select_widget_by_id(dlg_data,(int)local_30);
            cp_index_00 = 1;
            goto LAB_080d5dce;
          }
          goto LAB_080d6494;
        }
      }
      mem_free(dlg);
      cp_index_00 = 1;
    }
  }
LAB_080d5dce:
  if (p == (mime_handler *)0x0) {
    return cp_index_00;
  }
LAB_080d5dd9:
  mem_free(p);
  return cp_index_00;
}



void create_history(ses_history *history)

{
  *(ses_history **)&(history->history).prev = history;
  *(ses_history **)&(history->history).next = history;
  history->current = (location *)0x0;
  return;
}



void add_to_history(ses_history *history,location *loc)

{
  location *plVar1;
  
  if (history->current != (location *)0x0) {
    loc->next = history->current->next;
    loc->prev = history->current;
    history->current->next = loc;
    loc->next->prev = loc;
    history->current = loc;
    return;
  }
  plVar1 = (location *)(history->history).next;
  *(ses_history **)&loc->prev = history;
  loc->next = plVar1;
  *(location **)&(history->history).next = loc;
  loc->next->prev = loc;
  history->current = loc;
  return;
}



void del_from_history(ses_history *history,location *loc)

{
  location *plVar1;
  
  plVar1 = history->current;
  if (plVar1 == loc) {
    plVar1 = plVar1->prev;
    history->current = plVar1;
  }
  if ((location *)history == plVar1) {
    plVar1 = (location *)0x0;
    if ((location *)history != loc->next) {
      plVar1 = loc->next;
    }
    history->current = plVar1;
  }
  loc->next->prev = loc->prev;
  loc->prev->next = loc->next;
  return;
}



void go_history(session *ses,location *loc)

{
  task_type tVar1;
  
  tVar1 = (ses->task).type;
  ses->reloadlevel = CACHE_MODE_NORMAL;
  if (tVar1 == TASK_NONE) {
    if (((ses->history).current != (location *)0x0) && ((location *)&ses->history != loc)) {
      abort_loading(ses,0);
      set_session_referrer(ses,(uri *)0x0);
      ses_goto(ses,(loc->vs).uri,(uchar *)0x0,loc,CACHE_MODE_ALWAYS,TASK_HISTORY,0);
    }
    return;
  }
  abort_loading(ses,0);
  print_screen_status(ses);
  reload(ses,CACHE_MODE_NORMAL);
  return;
}



void go_history_by_n(session *ses,int n)

{
  location *plVar1;
  location *plVar2;
  location *loc;
  
  plVar2 = (ses->history).current;
  if (plVar2 == (location *)0x0) {
    return;
  }
  if (n < 1) {
    do {
      loc = plVar2;
      if (n == 0) {
        go_history(ses,loc);
        return;
      }
      n = n + 1;
      plVar2 = loc->prev;
    } while (loc->prev != (location *)&ses->history);
  }
  else {
    do {
      n = n + -1;
      plVar1 = plVar2->next;
      loc = plVar2;
      if (plVar1 == (location *)&ses->history) break;
      loc = plVar1;
      plVar2 = plVar1;
    } while (n != 0);
  }
  go_history(ses,loc);
  return;
}



void go_unback(session *ses)

{
  go_history_by_n(ses,1);
  return;
}



void go_back(session *ses)

{
  go_history_by_n(ses,-1);
  return;
}



void clean_unhistory(ses_history *history)

{
  location *loc;
  
  loc = history->current;
  if (loc != (location *)0x0) {
    while (loc = *(location **)loc, loc != (location *)history) {
      loc->next->prev = loc->prev;
      loc->prev->next = loc->next;
      destroy_location(loc);
      loc = history->current;
    }
  }
  return;
}



void destroy_history(ses_history *history)

{
  location *loc;
  
  loc = (location *)(history->history).next;
  while ((location *)history != loc) {
    loc->next->prev = loc->prev;
    loc->prev->next = loc->next;
    destroy_location(loc);
    loc = (location *)(history->history).next;
  }
  history->current = (location *)0x0;
  return;
}



void ses_history_move(session *ses)

{
  location *history;
  location *loc;
  int iVar1;
  int *piVar2;
  location *plVar3;
  uchar *name;
  
  free_files(ses);
  if (ses->search_word != (uchar *)0x0) {
    mem_free(ses->search_word);
  }
  loc = (ses->history).current;
  ses->search_word = (uchar *)0x0;
  if (((loc != (location *)0x0) && (loc = (ses->task).target.location, loc != (location *)0x0)) &&
     (history = (location *)&ses->history, loc != history)) {
    (ses->history).current = loc;
    iVar1 = compare_uri((loc->vs).uri,ses->loading_uri,0);
    if (iVar1 == 0) {
      plVar3 = (ses->history).current;
      if (loc == plVar3) {
        plVar3 = loc->prev;
        (ses->history).current = plVar3;
      }
      if (history == plVar3) {
        plVar3 = (location *)0x0;
        if (history != loc->next) {
          plVar3 = loc->next;
        }
        (ses->history).current = plVar3;
      }
      loc->next->prev = loc->prev;
      loc->prev->next = loc->next;
      destroy_location(loc);
      ses_forward(ses,0);
      piVar2 = get_opt_(config_options,name);
      if (*piVar2 != 0) {
        clean_unhistory((ses_history *)history);
        return;
      }
    }
  }
  return;
}



void destroy_location(location *loc)

{
  list_head_elinks *plVar1;
  list_head_elinks *plVar2;
  list_head_elinks *p;
  list_head_elinks *plVar3;
  
  plVar3 = (list_head_elinks *)(loc->frames).next;
  plVar1 = &loc->frames;
  p = plVar3;
  if (plVar3 != plVar1) {
    do {
      destroy_vs((view_state *)(plVar3 + 2),1);
      mem_free(plVar3[1].next);
      plVar3 = (list_head_elinks *)plVar3->next;
    } while (plVar3 != plVar1);
    plVar3 = (list_head_elinks *)(loc->frames).next;
    p = plVar3;
  }
  while (plVar3 != plVar1) {
    plVar3 = (list_head_elinks *)plVar3->next;
  }
  plVar3 = (list_head_elinks *)(loc->frames).prev;
  while (plVar3 != plVar1) {
    plVar3 = (list_head_elinks *)plVar3->prev;
  }
  plVar3 = (list_head_elinks *)p->next;
  while (plVar2 = plVar3, p != plVar1) {
    plVar2->prev = p->prev;
    *(void **)p->prev = p->next;
    mem_free(p);
    plVar3 = (list_head_elinks *)plVar2->next;
    p = plVar2;
  }
  destroy_vs(&loc->vs,1);
  mem_free(loc);
  return;
}



void copy_location(location *dst,location *src)

{
  void *pvVar1;
  list_head_elinks *plVar2;
  void **p;
  uchar *puVar3;
  list_head_elinks *plVar4;
  
  plVar4 = &dst->frames;
  *(list_head_elinks **)&(dst->frames).prev = plVar4;
  *(list_head_elinks **)&(dst->frames).next = plVar4;
  plVar2 = (list_head_elinks *)(src->frames).prev;
  do {
    if (plVar2 == &src->frames) {
      copy_vs(&dst->vs,&src->vs);
      return;
    }
    p = (void **)mem_calloc(1,0x40);
    if (p != (void **)0x0) {
      puVar3 = stracpy((uchar *)plVar2[1].next);
      *(uchar **)(p + 2) = puVar3;
      if (puVar3 == (uchar *)0x0) {
        mem_free(p);
        return;
      }
      p[3] = (void *)0x0;
      copy_vs((view_state *)(p + 4),(view_state *)(plVar2 + 2));
      pvVar1 = plVar4->next;
      *(list_head_elinks **)(p + 1) = plVar4;
      *p = pvVar1;
      *(void ***)&plVar4->next = p;
      *(void ***)((int)*p + 4) = p;
    }
    plVar2 = (list_head_elinks *)plVar2->prev;
  } while( true );
}



download * get_current_download(session *ses)

{
  location *plVar1;
  connection_basic_state cVar2;
  download *pdVar3;
  list_head_elinks *plVar4;
  
  if (ses == (session *)0x0) {
    return (download *)0x0;
  }
  if ((ses->task).type == TASK_NONE) {
    plVar1 = (ses->history).current;
    if (plVar1 == (location *)0x0) {
      return (download *)0x0;
    }
    pdVar3 = &plVar1->download;
    cVar2 = (plVar1->download).state.basic;
  }
  else {
    pdVar3 = &ses->loading;
    cVar2 = (ses->loading).state.basic;
  }
  if (cVar2 == S_OK) {
    plVar4 = (list_head_elinks *)(ses->more_files).next;
    if (plVar4 != &ses->more_files) {
      while (((*(byte *)&plVar4[1].prev & 1) == 0 || ((int)plVar4[7].prev < 0))) {
        plVar4 = (list_head_elinks *)plVar4->next;
        if (plVar4 == &ses->more_files) {
          return pdVar3;
        }
      }
      return (download *)(plVar4 + 4);
    }
  }
  return pdVar3;
}



link * get_current_link_in_view(document_view *doc_view)

{
  int iVar1;
  link *plVar2;
  
  if ((((doc_view == (document_view *)0x0) || (iVar1 = doc_view->vs->current_link, iVar1 < 0)) ||
      (doc_view->document->nlinks <= iVar1)) ||
     ((plVar2 = doc_view->document->links + iVar1, plVar2 != (link *)0x0 &&
      (LINK_MAP < plVar2->type)))) {
    plVar2 = (link *)0x0;
  }
  return plVar2;
}



int eat_kbd_repeat_count(session *ses)

{
  int iVar1;
  
  iVar1 = (ses->kbdprefix).repeat_count;
  (ses->kbdprefix).repeat_count = 0;
  print_screen_status(ses);
  return iVar1;
}



link * get_current_session_link(session *ses)

{
  int iVar1;
  document_view *pdVar2;
  link *plVar3;
  
  pdVar2 = current_frame(ses);
  if ((((pdVar2 == (document_view *)0x0) || (iVar1 = pdVar2->vs->current_link, iVar1 < 0)) ||
      (pdVar2->document->nlinks <= iVar1)) ||
     ((plVar3 = pdVar2->document->links + iVar1, plVar3 != (link *)0x0 && (LINK_MAP < plVar3->type))
     )) {
    plVar3 = (link *)0x0;
  }
  return plVar3;
}



uchar * get_current_link_name(session *ses,uchar *str,size_t str_size)

{
  link *plVar1;
  global_history_item *pgVar2;
  uchar *src;
  uchar *url;
  
  plVar1 = get_current_session_link(ses);
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(str_size == 0 || str == (uchar *)0x0),
     str_size == 0 || str == (uchar *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
    errline = 0x56b;
    elinks_internal((uchar *)"assertion str && str_size > 0 failed!");
  }
  if (plVar1 == (link *)0x0) {
    return (uchar *)0x0;
  }
  url = plVar1->where;
  if (url == (uchar *)0x0) {
    url = plVar1->where_img;
    pgVar2 = get_global_history_item(url);
  }
  else {
    pgVar2 = get_global_history_item(url);
  }
  if ((((pgVar2 == (global_history_item *)0x0) ||
       (src = pgVar2->title, pgVar2->title == (uchar *)0x0)) &&
      (src = url, plVar1->type < LINK_BUTTON)) &&
     (src = (uchar *)plVar1->data, (uchar *)plVar1->data == (uchar *)0x0)) {
    src = url;
  }
  url = safe_strncpy(str,src,str_size);
  return url;
}



uchar * get_current_link_url(session *ses,uchar *str,size_t str_size)

{
  link *plVar1;
  uchar *src;
  
  plVar1 = get_current_session_link(ses);
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(str_size == 0 || str == (uchar *)0x0),
     str_size == 0 || str == (uchar *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
    errline = 0x55a;
    elinks_internal((uchar *)"assertion str && str_size > 0 failed!");
  }
  if (plVar1 == (link *)0x0) {
    return (uchar *)0x0;
  }
  src = plVar1->where;
  if (src == (uchar *)0x0) {
    src = plVar1->where_img;
  }
  src = safe_strncpy(str,src,str_size);
  return src;
}



uchar * get_current_title(session *ses,uchar *str,size_t str_size)

{
  document_view *pdVar1;
  uchar *src;
  
  pdVar1 = current_frame(ses);
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(str_size == 0 || str == (uchar *)0x0),
     str_size == 0 || str == (uchar *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
    errline = 0x546;
    elinks_internal((uchar *)"assertion str && str_size > 0 failed!");
  }
  if ((pdVar1 != (document_view *)0x0) && (src = pdVar1->document->title, src != (uchar *)0x0)) {
    src = safe_strncpy(str,src,str_size);
    return src;
  }
  return (uchar *)0x0;
}



uchar * get_current_url(session *ses,uchar *str,size_t str_size)

{
  location *plVar1;
  uri *puVar2;
  uchar *puVar3;
  uchar *src;
  uchar *puVar4;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(str_size == 0 || str == (uchar *)0x0),
     str_size == 0 || str == (uchar *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
    errline = 0x52d;
    elinks_internal((uchar *)"assertion str && str_size > 0 failed!");
    plVar1 = (ses->history).current;
  }
  else {
    plVar1 = (ses->history).current;
  }
  if (plVar1 == (location *)0x0) {
    puVar2 = ses->loading_uri;
  }
  else {
    puVar2 = (plVar1->vs).uri;
  }
  if (puVar2 != (uri *)0x0) {
    if (puVar2->post == (uchar *)0x0) {
      src = puVar2->string;
      puVar3 = (uchar *)strlen((char *)src);
    }
    else {
      src = puVar2->string;
      puVar3 = puVar2->post + (-1 - (int)src);
    }
    puVar4 = (uchar *)(str_size - 1);
    if ((int)puVar3 <= (int)(uchar *)(str_size - 1)) {
      puVar4 = puVar3;
    }
    src = safe_strncpy(str,src,(size_t)(puVar4 + 1));
    return src;
  }
  return (uchar *)0x0;
}



void set_session_referrer(session *ses,uri *referrer)

{
  if (ses->referrer != (uri *)0x0) {
    done_uri(ses->referrer);
  }
  if (referrer != (uri *)0x0) {
    (referrer->object).refcount = (referrer->object).refcount + 1;
  }
  ses->referrer = referrer;
  return;
}



frame * ses_find_frame(session *ses,uchar *name)

{
  location *plVar1;
  frame *pfVar2;
  int iVar3;
  
  plVar1 = (ses->history).current;
  if (assert_failed != 0) {
    assert_failed = 0;
    return (frame *)0x0;
  }
  assert_failed = ZEXT14(plVar1 == (location *)0x0);
  if (plVar1 == (location *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
    errline = 0x4ed;
    elinks_internal((uchar *)
                    "assertion have_location(ses) failed: ses_request_frame: no location yet");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (frame *)0x0;
    }
  }
  pfVar2 = (frame *)(plVar1->frames).prev;
  while( true ) {
    if (pfVar2 == (frame *)&plVar1->frames) {
      return (frame *)0x0;
    }
    iVar3 = c_strcasecmp((char *)pfVar2->name,(char *)name);
    if (iVar3 == 0) break;
    pfVar2 = pfVar2->prev;
  }
  return pfVar2;
}



void __regparm3 load_additional_file(file_to_load *ftl,cache_mode cache_mode)

{
  document_view *pdVar1;
  uri *referrer;
  
  pdVar1 = current_frame(ftl->ses);
  if ((pdVar1 == (document_view *)0x0) || (pdVar1->document == (document *)0x0)) {
    referrer = (uri *)0x0;
  }
  else {
    referrer = pdVar1->document->uri;
  }
  load_uri(ftl->uri,referrer,&ftl->download,ftl->pri,cache_mode,-1);
  return;
}



void process_file_requests(session *ses)

{
  file_to_load *pfVar1;
  byte *pbVar2;
  byte bVar3;
  bool bVar4;
  file_to_load *ftl;
  
  bVar3 = *(byte *)&(ses->status).field_0x34;
  if ((bVar3 & 2) == 0) {
    *(byte *)&(ses->status).field_0x34 = bVar3 | 2;
    pfVar1 = (file_to_load *)&ses->more_files;
    do {
      ftl = (file_to_load *)(ses->more_files).next;
      if (ftl == pfVar1) break;
      bVar4 = false;
      do {
        while ((*(byte *)&ftl->field_0xc & 1) == 0) {
          *(byte *)&ftl->field_0xc = *(byte *)&ftl->field_0xc | 1;
          load_additional_file(ftl,CACHE_MODE_NORMAL);
          ftl = ftl->next;
          bVar4 = true;
          if (ftl == pfVar1) goto LAB_080d7353;
        }
        ftl = ftl->next;
      } while (ftl != pfVar1);
LAB_080d7353:
    } while (bVar4);
    pbVar2 = (byte *)&(ses->status).field_0x34;
    *pbVar2 = *pbVar2 & 0xfd;
  }
  return;
}



void abort_loading(session *ses,int interrupt)

{
  location *plVar1;
  bool bVar2;
  list_head_elinks *plVar3;
  
  plVar1 = (ses->history).current;
  if (plVar1 != (location *)0x0) {
    cancel_download(&plVar1->download,interrupt);
    do {
      plVar3 = (list_head_elinks *)(ses->more_files).next;
      if (plVar3 == &ses->more_files) break;
      bVar2 = false;
      do {
        if (((*(byte *)&plVar3[1].prev & 1) != 0) && (-1 < (int)plVar3[7].prev)) {
          cancel_download((download *)(plVar3 + 4),interrupt);
          bVar2 = true;
        }
        plVar3 = (list_head_elinks *)plVar3->next;
      } while (plVar3 != &ses->more_files);
    } while (bVar2);
  }
  abort_preloading(ses,interrupt);
  return;
}



void reload(session *ses,cache_mode cache_mode)

{
  location *plVar1;
  file_to_load *ftl;
  
  abort_loading(ses,0);
  if (cache_mode == CACHE_MODE_INCREMENT) {
    cache_mode = CACHE_MODE_NEVER;
    if (ses->reloadlevel < 4) {
      cache_mode = ses->reloadlevel + CACHE_MODE_NORMAL;
      ses->reloadlevel = cache_mode;
    }
  }
  else {
    ses->reloadlevel = cache_mode;
  }
  plVar1 = (ses->history).current;
  if (plVar1 != (location *)0x0) {
    *(session **)&(plVar1->download).data = ses;
    (plVar1->download).callback = doc_loading_callback;
    load_uri((plVar1->vs).uri,ses->referrer,&plVar1->download,PRI_MAIN,cache_mode,-1);
    ftl = (file_to_load *)(ses->more_files).next;
    while ((file_to_load *)&ses->more_files != ftl) {
      while (((*(byte *)&ftl->field_0xc & 1) != 0 && (-1 < (ftl->download).state.basic))) {
        ftl = ftl->next;
        if ((file_to_load *)&ses->more_files == ftl) {
          return;
        }
      }
      *(file_to_load **)&(ftl->download).data = ftl;
      (ftl->download).callback = file_loading_callback;
      load_additional_file(ftl,cache_mode);
      ftl = ftl->next;
    }
  }
  return;
}



void check_questions_queue(session *ses)

{
  void *p;
  
  if ((list_head_elinks *)questions_queue.next != &questions_queue) {
    do {
      p = questions_queue.next;
      (**(code **)((int)questions_queue.next + 8))
                (ses,*(undefined4 *)((int)questions_queue.next + 0xc));
      *(undefined4 *)(*(int *)p + 4) = *(undefined4 *)((int)p + 4);
      **(undefined4 **)((int)p + 4) = *(undefined4 *)p;
      mem_free(p);
    } while ((list_head_elinks *)questions_queue.next != &questions_queue);
  }
  return;
}



void free_files(session *ses)

{
  list_head_elinks *plVar1;
  int *piVar2;
  bool bVar3;
  list_head_elinks *plVar4;
  list_head_elinks *p;
  list_head_elinks *plVar5;
  
  plVar1 = &ses->more_files;
  do {
    plVar5 = (list_head_elinks *)(ses->more_files).next;
    p = plVar5;
    if (plVar5 == plVar1) goto joined_r0x080d75be;
    bVar3 = false;
    do {
      if (((*(byte *)&plVar5[1].prev & 1) != 0) && (-1 < (int)plVar5[7].prev)) {
        cancel_download((download *)(plVar5 + 4),0);
        bVar3 = true;
      }
      plVar5 = (list_head_elinks *)plVar5->next;
    } while (plVar5 != plVar1);
  } while (bVar3);
  plVar5 = (list_head_elinks *)(ses->more_files).next;
  p = plVar5;
  if (plVar5 != plVar1) {
    do {
      if (plVar5[2].prev != (void *)0x0) {
        piVar2 = (int *)((int)plVar5[2].prev + 8);
        *piVar2 = *piVar2 + -1;
      }
      if ((uri *)plVar5[3].prev != (uri *)0x0) {
        done_uri((uri *)plVar5[3].prev);
      }
      if (plVar5[3].next != (void *)0x0) {
        mem_free(plVar5[3].next);
      }
      plVar5 = (list_head_elinks *)plVar5->next;
    } while (plVar5 != plVar1);
    plVar5 = (list_head_elinks *)(ses->more_files).next;
    p = plVar5;
  }
joined_r0x080d75be:
  while (plVar5 != plVar1) {
    plVar5 = (list_head_elinks *)plVar5->next;
  }
  plVar5 = (list_head_elinks *)(ses->more_files).prev;
  while (plVar5 != plVar1) {
    plVar5 = (list_head_elinks *)plVar5->prev;
  }
  plVar5 = (list_head_elinks *)p->next;
  while (plVar4 = plVar5, p != plVar1) {
    plVar4->prev = p->prev;
    *(void **)p->prev = p->next;
    mem_free(p);
    plVar5 = (list_head_elinks *)plVar4->next;
    p = plVar4;
  }
  return;
}



void __regparm3 done_session_info(session_info *info)

{
  info->next->prev = info->prev;
  info->prev->next = info->next;
  kill_timer(&info->timer);
  if (info->uri != (uri *)0x0) {
    done_uri(info->uri);
  }
  if (info->referrer != (uri *)0x0) {
    done_uri(info->referrer);
  }
  mem_free(info);
  return;
}



void session_info_timeout(int id)

{
  session_info *info;
  session *psVar1;
  
  info = (session_info *)session_info.next;
  if ((list_head_elinks *)session_info.next != &session_info) {
    do {
      if (id == info->id) {
        if ((list_head_elinks *)sessions.next == &sessions) goto LAB_080d76ae;
        psVar1 = (session *)sessions.next;
        if ((session *)sessions.next == info->ses) goto LAB_080d76b5;
        goto LAB_080d76a4;
      }
      info = info->next;
    } while (info != (session_info *)&session_info);
  }
  return;
LAB_080d76ae:
  info->ses = (session *)0x0;
  goto LAB_080d76b5;
  while (psVar1 != info->ses) {
LAB_080d76a4:
    psVar1 = psVar1->next;
    if (psVar1 == (session *)&sessions) goto LAB_080d76ae;
  }
LAB_080d76b5:
  info->timer = (timer_id_T)0x0;
  done_session_info(info);
  return;
}



void done_saved_session_info(void)

{
  if ((list_head_elinks *)session_info.next != &session_info) {
    do {
      done_session_info((session_info *)session_info.next);
    } while ((list_head_elinks *)session_info.next != &session_info);
  }
  return;
}



void dialog_goto_url_open(void *data)

{
  dialog_goto_url((session *)data,(uchar *)0x0);
  return;
}



void __regparm3 init_remote_session(session *ses,remote_session_flags *remote_ptr,uri *uri)

{
  remote_session_flags rVar1;
  uchar *text;
  remote_session_flags rVar2;
  int codepage;
  
  rVar1 = *remote_ptr;
  if ((rVar1 & SES_REMOTE_CURRENT_TAB) != 0) {
    goto_uri(ses,uri);
    rVar2 = SES_REMOTE_NEW_TAB;
    if ((rVar1 & ~SES_REMOTE_CURRENT_TAB) != 0) {
      rVar2 = rVar1 & ~SES_REMOTE_CURRENT_TAB;
    }
    *remote_ptr = rVar2;
    return;
  }
  if ((rVar1 & SES_REMOTE_NEW_TAB) == 0) {
    if ((rVar1 & SES_REMOTE_NEW_WINDOW) != 0) {
      codepage = can_open_in_new(ses->tab->term);
      if (codepage == 0) {
        return;
      }
      open_uri_in_new_window
                (ses,uri,(uri *)0x0,ses->tab->term->environment,CACHE_MODE_NORMAL,TASK_NONE);
      return;
    }
    if ((rVar1 & SES_REMOTE_ADD_BOOKMARK) != 0) {
      if (uri == (uri *)0x0) {
        return;
      }
      codepage = get_cp_index((uchar *)"System");
      add_bookmark_cp((bookmark *)0x0,1,codepage,uri->string,uri->string);
      return;
    }
    if ((rVar1 & SES_REMOTE_INFO_BOX) != 0) {
      if (uri == (uri *)0x0) {
        return;
      }
      text = memacpy(uri->data,(uint)*(ushort *)&uri->field_0x31);
      if (text == (uchar *)0x0) {
        return;
      }
      info_box(ses->tab->term,MSGBOX_FREE_TEXT,"Error",ALIGN_CENTER,text);
      return;
    }
  }
  else {
    open_uri_in_new_tab(ses,uri,0,1);
  }
  if ((rVar1 & SES_REMOTE_PROMPT_URL) != 0) {
    dialog_goto_url_open(ses);
  }
  return;
}



string * encode_session_info(string *info,list_head_elinks *url_list)

{
  int iVar1;
  void *__src;
  uint uVar2;
  list_head_elinks *plVar3;
  string *psVar4;
  uint uVar5;
  uchar *puVar6;
  uint size;
  size_t __n;
  
  psVar4 = init_string(info);
  if (psVar4 == (string *)0x0) {
    return (string *)0x0;
  }
  plVar3 = (list_head_elinks *)url_list->next;
  do {
    while( true ) {
      if (plVar3 == url_list) {
        return info;
      }
      __src = plVar3[1].next;
      if (assert_failed == 0) break;
LAB_080d798e:
      assert_failed = 0;
      plVar3 = (list_head_elinks *)plVar3->next;
    }
    __n = (int)plVar3[1].prev + 1;
    if (((info == (string *)0x0) || (__src == (void *)0x0)) || ((int)__n < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080d798e;
    }
    else {
      assert_failed = 0;
    }
    if (__n != 0) {
      iVar1 = __n + info->length;
      uVar5 = info->length + 0xff;
      uVar2 = uVar5 >> 8;
      uVar5 = uVar5 & 0xffffff00;
      size = iVar1 + 0x100U & 0xffffff00;
      if (uVar5 <= size && size + uVar2 * -0x100 != 0) {
        puVar6 = (uchar *)mem_realloc(info->source,size);
        if (puVar6 == (uchar *)0x0) goto LAB_080d7974;
        info->source = puVar6;
        memset(puVar6 + uVar5,0,size + uVar2 * -0x100);
      }
      if (info->source != (uchar *)0x0) {
        memcpy(info->source + info->length,__src,__n);
        info->source[iVar1] = '\0';
        info->length = iVar1;
      }
    }
LAB_080d7974:
    plVar3 = (list_head_elinks *)plVar3->next;
  } while( true );
}



session * init_session(session *base_session,terminal *term,uri *uri,int in_background)

{
  object *poVar1;
  location *plVar2;
  uri *uri_00;
  view_state *vs;
  terminal *term_00;
  session *ses;
  window *pwVar3;
  led *plVar4;
  int tab;
  int *piVar5;
  char **ppcVar6;
  uchar *name;
  option_elinks *option_elinks;
  uchar *name_00;
  uchar *name_01;
  uchar *extraout_EDX;
  uchar *extraout_EDX_00;
  uchar *extraout_EDX_01;
  uchar *name_02;
  uchar *extraout_EDX_02;
  uchar *extraout_EDX_03;
  
  ses = (session *)mem_calloc(1,0xe0);
  if (ses == (session *)0x0) {
    return (session *)0x0;
  }
  pwVar3 = init_tab(term,ses,tabwin_func);
  ses->tab = pwVar3;
  if (pwVar3 == (window *)0x0) {
    mem_free(ses);
    return (session *)0x0;
  }
  create_history(&ses->history);
  *(list_head_elinks **)&(ses->scrn_frames).prev = &ses->scrn_frames;
  *(list_head_elinks **)&(ses->scrn_frames).next = &ses->scrn_frames;
  *(list_head_elinks **)&(ses->more_files).prev = &ses->more_files;
  *(list_head_elinks **)&(ses->more_files).next = &ses->more_files;
  *(list_head_elinks **)&(ses->type_queries).prev = &ses->type_queries;
  *(list_head_elinks **)&(ses->type_queries).next = &ses->type_queries;
  (ses->task).type = TASK_NONE;
  ses->display_timer = (timer_id_T)0x0;
  init_led_panel(&(ses->status).leds);
  plVar4 = register_led(ses,0);
  (ses->status).ssl_led = plVar4;
  plVar4 = register_led(ses,1);
  (ses->status).insert_mode_led = plVar4;
  plVar4 = register_led(ses,2);
  (ses->status).ecmascript_led = plVar4;
  plVar4 = register_led(ses,3);
  *(byte *)&ses->status = *(byte *)&ses->status | 0x78;
  (ses->status).popup_led = plVar4;
  *(list_head_elinks **)&ses->prev = &sessions;
  ses->next = sessions.next;
  sessions.next = ses;
  ses->next->prev = ses;
  update_status();
  if (sessions.next == sessions.prev) {
    term_00 = ses->tab->term;
    ppcVar6 = (char **)get_opt_(config_options,name_00);
    name = extraout_EDX;
    if (**ppcVar6 == '\0') {
      info_box(term_00,0,(uchar *)"Warning",ALIGN_CENTER,
               (uchar *)
               "You have an empty string in protocol.http.user_agent - this was a default value in the past, substituted by default ELinks User-Agent string. However, currently this means that NO User-Agent HEADER WILL BE SENT AT ALL - if this is really what you want, set its value to \" \", otherwise please delete the line with this setting from your configuration file (if you have no idea what I\'m talking about, just do this), so that the correct default setting will be used. Apologies for any inconvience caused."
              );
      name = extraout_EDX_01;
    }
    piVar5 = get_opt_(config_options,name);
    name = extraout_EDX_00;
    if (*piVar5 == 0) {
      option_elinks = get_opt_rec(config_options,(uchar *)"config.saving_style_w");
      option_elinks->value = 1;
      option_changed(ses,option_elinks);
      piVar5 = get_opt_(config_options,name_02);
      name = extraout_EDX_02;
      if (*piVar5 != 3) {
        info_box(term_00,0,(uchar *)"Warning",ALIGN_CENTER,
                 (uchar *)
                 "You have option config.saving_style set to a de facto obsolete value. The configuration saving algorithms of ELinks were changed from the last time you upgraded ELinks. Now, only those options which you actually changed are saved to the configuration file, instead of all the options. This simplifies our situation greatly when we see that some option has an inappropriate default value or we need to change the semantics of some option in a subtle way. Thus, we recommend you change the value of config.saving_style option to 3 in order to get the \"right\" behaviour. Apologies for any inconvience caused."
                );
        name = extraout_EDX_03;
      }
    }
    if (first_use == 0) {
      if ((uri == (uri *)0x0) && (piVar5 = get_opt_(config_options,name), *piVar5 != 0)) {
        name = get_auto_save_bookmark_foldername_utf8();
        if (name != (uchar *)0x0) {
          open_bookmark_folder(ses,name);
          mem_free(name);
        }
        goto LAB_080d7c21;
      }
    }
    else {
      if (uri == (uri *)0x0) {
        first_use = 0;
        msg_box(term_00,(memory_list *)0x0,0,(uchar *)"Welcome",ALIGN_CENTER,
                (uchar *)
                "Welcome to ELinks!\n\nPress ESC for menu. Documentation is available in Help menu."
                ,ses,1,&DAT_081275e4,dialog_goto_url_open,3);
        goto LAB_080d7c21;
      }
      first_use = 0;
      msg_box(term_00,(memory_list *)0x0,0,(uchar *)"Welcome",ALIGN_CENTER,
              (uchar *)
              "Welcome to ELinks!\n\nPress ESC for menu. Documentation is available in Help menu.",
              ses,1,&DAT_081275e4,0,3);
    }
  }
  if ((base_session != (session *)0x0) &&
     (plVar2 = (base_session->history).current, plVar2 != (location *)0x0)) {
    uri_00 = (plVar2->vs).uri;
    poVar1 = &uri_00->object;
    poVar1->refcount = poVar1->refcount + 1;
    ses_load(ses,uri_00,(uchar *)0x0,(location *)0x0,CACHE_MODE_ALWAYS,TASK_FORWARD);
    if ((ses->doc_view != (document_view *)0x0) &&
       (((vs = ses->doc_view->vs, vs != (view_state *)0x0 &&
         (base_session->doc_view != (document_view *)0x0)) &&
        (base_session->doc_view->vs != (view_state *)0x0)))) {
      destroy_vs(vs,1);
      copy_vs(vs,base_session->doc_view->vs);
      ses->doc_view->vs = vs;
    }
  }
  if (uri == (uri *)0x0) {
    tab = goto_url_home(ses);
    if ((tab == 0) && (piVar5 = get_opt_(config_options,name_01), *piVar5 != 0)) {
      dialog_goto_url_open(ses);
    }
  }
  else {
    goto_uri(ses,uri);
  }
LAB_080d7c21:
  if (in_background == 0) {
    tab = get_tab_number(ses->tab);
    switch_to_tab(term,tab,-1);
  }
  if (term->main_menu == (menu *)0x0) {
    activate_bfu_technology(ses,-1);
  }
  return ses;
}



file_to_load * __regparm3 request_additional_file(session *ses,uchar *name,uri *uri,int pri)

{
  file_to_load *pfVar1;
  file_to_load *pfVar2;
  protocol_external_handler_T *ppVar3;
  int iVar4;
  uchar *puVar5;
  file_to_load *pfVar6;
  
  if ((uri->protocol == 0x12) ||
     (ppVar3 = get_protocol_external_handler(ses->tab->term,uri),
     ppVar3 != (protocol_external_handler_T *)0x0)) {
LAB_080d7f17:
    pfVar6 = (file_to_load *)0x0;
  }
  else {
    pfVar1 = (file_to_load *)(ses->more_files).next;
    while (pfVar1 != (file_to_load *)&ses->more_files) {
      iVar4 = compare_uri(pfVar1->uri,uri,URI_BASE);
      if (iVar4 != 0) {
        if ((void *)pfVar1->pri != (void *)pri && pri <= (int)pfVar1->pri) {
          pfVar1->pri = pri;
          move_download(&pfVar1->download,&pfVar1->download,pri);
          return (file_to_load *)0x0;
        }
        goto LAB_080d7f17;
      }
      pfVar1 = pfVar1->next;
    }
    pfVar6 = (file_to_load *)mem_calloc(1,0x50);
    if (pfVar6 != (file_to_load *)0x0) {
      (uri->object).refcount = (uri->object).refcount + 1;
      pfVar6->uri = uri;
      puVar5 = stracpy(name);
      (pfVar6->download).callback = file_loading_callback;
      *(file_to_load **)&(pfVar6->download).data = pfVar6;
      pfVar6->target_frame = puVar5;
      pfVar6->ses = ses;
      pfVar6->pri = pri;
      pfVar2 = pfVar1->next;
      pfVar6->prev = pfVar1;
      pfVar6->next = pfVar2;
      pfVar1->next = pfVar6;
      pfVar6->next->prev = pfVar6;
    }
  }
  return pfVar6;
}



int session_is_loading(session *ses)

{
  download *pdVar1;
  int iVar2;
  cache_entry *cached;
  
  pdVar1 = get_current_download(ses);
  if (pdVar1 != (download *)0x0) {
    if (-1 < (pdVar1->state).basic) {
      return 1;
    }
    if ((pdVar1->cached != (cache_entry *)0x0) &&
       (iVar2 = cache_entry_is_valid(pdVar1->cached), iVar2 != 0)) {
      cached = pdVar1->cached;
      if ((assert_failed == 0) &&
         (assert_failed = ZEXT14(cached == (cache_entry *)0x0), cached == (cache_entry *)0x0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
        errline = 0x22b;
        elinks_internal((uchar *)"assertion cached failed!");
      }
      cached = follow_cached_redirects(cached);
      if ((cached != (cache_entry *)0x0) && (cached->redirect == (uri *)0x0)) {
        return (uint)((*(byte *)&cached->field_0x5c & 8) != 0);
      }
    }
  }
  return 0;
}



void add_questions_entry(anon_subr_void_session_ptr_void_ptr *callback,void *data)

{
  void **ppvVar1;
  
  ppvVar1 = (void **)mem_alloc(0x10);
  if (ppvVar1 != (void **)0x0) {
    *(anon_subr_void_session_ptr_void_ptr **)(ppvVar1 + 2) = callback;
    ppvVar1[3] = data;
    *(list_head_elinks **)(ppvVar1 + 1) = &questions_queue;
    *ppvVar1 = questions_queue.next;
    questions_queue.next = ppvVar1;
    *(void ***)((int)*ppvVar1 + 4) = ppvVar1;
  }
  return;
}



int add_session_info(session *ses,uri *uri,uri *referrer,cache_mode cache_mode,task_type task)

{
  int data;
  void **ppvVar1;
  void *pvVar2;
  
  ppvVar1 = (void **)mem_calloc(1,0x24);
  data = session_info_id;
  pvVar2 = (void *)0xffffffff;
  if (ppvVar1 != (void **)0x0) {
    *(int *)(ppvVar1 + 2) = session_info_id;
    session_info_id = session_info_id + 1;
    install_timer((timer_id_T *)(ppvVar1 + 3),10000,session_info_timeout,(void *)data);
    *(session **)(ppvVar1 + 4) = ses;
    *(task_type *)(ppvVar1 + 7) = task;
    *(cache_mode *)(ppvVar1 + 8) = cache_mode;
    if (uri != (uri *)0x0) {
      (uri->object).refcount = (uri->object).refcount + 1;
      *(uri **)(ppvVar1 + 5) = uri;
    }
    if (referrer != (uri *)0x0) {
      (referrer->object).refcount = (referrer->object).refcount + 1;
      *(uri **)(ppvVar1 + 6) = referrer;
    }
    *(list_head_elinks **)(ppvVar1 + 1) = &session_info;
    *ppvVar1 = session_info.next;
    session_info.next = ppvVar1;
    *(void ***)((int)*ppvVar1 + 4) = ppvVar1;
    pvVar2 = ppvVar1[2];
  }
  return (int)pvVar2;
}



void __regparm3 request_frameset(session *ses,frameset_desc *frameset_desc,int depth)

{
  uchar *name;
  uri *uri;
  location *plVar1;
  void *pvVar2;
  list_head_elinks *plVar3;
  int iVar4;
  void **p;
  uchar *puVar5;
  list_head_elinks *plVar6;
  frameset_desc *frameset_desc_00;
  frameset_desc *pfVar7;
  int iVar8;
  
  if ((5 < depth) || (frameset_desc->n < 1)) {
    return;
  }
  iVar8 = 0;
  pfVar7 = frameset_desc;
LAB_080d8224:
  frameset_desc_00 = pfVar7->frame_desc[0].subframe;
  if (frameset_desc_00 == (frameset_desc *)0x0) {
    name = pfVar7->frame_desc[0].name;
    if ((name != (uchar *)0x0) && (uri = pfVar7->frame_desc[0].uri, uri != (uri *)0x0)) {
      plVar1 = (ses->history).current;
      if (assert_failed == 0) {
        assert_failed = ZEXT14(plVar1 == (location *)0x0);
        if (plVar1 == (location *)0x0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
          errline = 0x153;
          elinks_internal((uchar *)"assertion have_location(ses) failed: request_frame: no location"
                         );
          if (assert_failed != 0) goto LAB_080d83d0;
        }
        plVar3 = (list_head_elinks *)(plVar1->frames).next;
        while (plVar3 != &plVar1->frames) {
          iVar4 = c_strcasecmp((char *)plVar3[1].next,(char *)name);
          if (iVar4 == 0) {
            plVar6 = (list_head_elinks *)(ses->scrn_frames).next;
            if (plVar6 == &ses->scrn_frames) goto LAB_080d8378;
            goto LAB_080d835e;
          }
          plVar3 = (list_head_elinks *)plVar3->next;
        }
        p = (void **)mem_calloc(1,0x40);
        if (p != (void **)0x0) {
          puVar5 = stracpy(name);
          *(uchar **)(p + 2) = puVar5;
          if (puVar5 == (uchar *)0x0) {
            mem_free(p);
          }
          else {
            init_vs((view_state *)(p + 4),uri,-1);
            pvVar2 = plVar3->next;
            *(list_head_elinks **)(p + 1) = plVar3;
            *p = pvVar2;
            *(void ***)&plVar3->next = p;
            *(void ***)((int)*p + 4) = p;
            request_additional_file(ses,name,(uri *)p[5],1);
          }
        }
      }
      else {
LAB_080d83d0:
        assert_failed = 0;
      }
    }
  }
  else {
LAB_080d8208:
    request_frameset(ses,frameset_desc_00,depth + 1);
  }
  goto LAB_080d8213;
  while (plVar6 = (list_head_elinks *)plVar6->next, plVar6 != &ses->scrn_frames) {
LAB_080d835e:
    if (((list_head_elinks *)plVar6[3].next == plVar3 + 2) &&
       (frameset_desc_00 = *(frameset_desc **)((int)plVar6[2].prev + 200),
       frameset_desc_00 != (frameset_desc *)0x0)) goto LAB_080d8208;
  }
LAB_080d8378:
  request_additional_file(ses,name,(uri *)plVar3[2].prev,1);
LAB_080d8213:
  iVar8 = iVar8 + 1;
  pfVar7 = (frameset_desc *)pfVar7->frame_desc;
  if (frameset_desc->n == iVar8 || frameset_desc->n < iVar8) {
    return;
  }
  goto LAB_080d8224;
}



void print_error_dialog(session *ses,connection_state state,uri *uri,connection_priority priority)

{
  terminal *term;
  string *psVar1;
  uchar *src;
  int cp_index;
  uchar *codeset;
  string msg;
  
  if (priority != PRI_CSS) {
    psVar1 = init_string(&msg);
    if (psVar1 != (string *)0x0) {
      if ((uri != (uri *)0x0) && (src = get_uri_string(uri,URI_PUBLIC), src != (uchar *)0x0)) {
        if ((*(byte *)&ses->tab->term->field_0x38 & 2) == 0) {
          decode_uri_for_display(src);
        }
        else {
          decode_uri(src);
        }
        term = ses->tab->term;
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        codeset = gettext((uchar *)"Unable to retrieve %s");
        add_format_to_string(&msg,codeset,src);
        mem_free(src);
        add_to_string(&msg,":\n\n");
      }
      src = get_state_message(state,ses->tab->term);
      add_to_string(&msg,src);
      info_box(ses->tab->term,MSGBOX_FREE_TEXT,"Error",ALIGN_CENTER,msg.source);
    }
  }
  return;
}



int decode_session_info(terminal *term,terminal_info *info)

{
  byte bVar1;
  terminal *term_00;
  list_head_elinks *plVar2;
  void *pvVar3;
  uchar *uristring;
  session *ses;
  uri *uri;
  window *pwVar4;
  uint uVar5;
  void *__n;
  session_info *info_00;
  uri *uri_00;
  int iVar6;
  void *len;
  session *local_38;
  uchar *local_30;
  remote_session_flags local_20 [4];
  
  __n = (void *)info->length;
  local_20[0] = 0;
  len = (void *)info->magic;
  if (len == (void *)0xfffffeff) {
    if (info->session_info == 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
      errline = 0x42f;
      elinks_internal((uchar *)"Remote magic with no remote flags");
      return 0;
    }
    if ((list_head_elinks *)sessions.next == &sessions) {
      return 0;
    }
    term_00 = *(terminal **)(*(int *)((int)sessions.next + 8) + 0x14);
    bVar1 = *(byte *)&term_00->field_0x38;
    plVar2 = (list_head_elinks *)sessions.next;
    while ((bVar1 & 1) == 0) {
      plVar2 = (list_head_elinks *)plVar2->next;
      if (plVar2 == &sessions) {
        return 0;
      }
      term_00 = *(terminal **)((int)plVar2[1].next + 0x14);
      bVar1 = *(byte *)&term_00->field_0x38;
    }
    local_20[0] = info->session_info;
    pwVar4 = get_tab_by_number(term_00,term_00->current_tab);
    if (pwVar4 == (window *)0x0) {
      return 0;
    }
    local_38 = (session *)pwVar4->data;
    if (local_38 == (session *)0x0) {
      return 0;
    }
    goto LAB_080d893d;
  }
  if (len == (void *)0xffffff00) {
    info_00 = (session_info *)session_info.next;
    if ((list_head_elinks *)session_info.next != &session_info) {
      do {
        if (info->session_info == info_00->id) {
          if ((list_head_elinks *)sessions.next == &sessions) goto LAB_080d87da;
          ses = (session *)sessions.next;
          if (info_00->ses == (session *)sessions.next) goto LAB_080d87e1;
          goto LAB_080d87d4;
        }
        info_00 = info_00->next;
      } while (info_00 != (session_info *)&session_info);
    }
    goto LAB_080d8707;
  }
  if ((0 < (int)len) &&
     (iVar6 = (int)__n + -8, local_38 = (session *)0x0, __n = len, (int)len <= iVar6))
  goto LAB_080d85a1;
  local_38 = (session *)0x0;
  goto LAB_080d884f;
LAB_080d87da:
  info_00->ses = (session *)0x0;
  goto LAB_080d87e1;
  while (info_00->ses != ses) {
LAB_080d87d4:
    ses = ses->next;
    if (ses == (session *)&sessions) goto LAB_080d87da;
  }
LAB_080d87e1:
  ses = init_session(info_00->ses,term,info_00->uri,0);
  if (ses != (session *)0x0) {
    if ((info_00->uri != (uri *)0x0) && (info_00->task != TASK_NONE)) {
      abort_loading(ses,1);
      ses->reloadlevel = info_00->cache_mode;
      set_session_referrer(ses,info_00->referrer);
      ses_goto(ses,info_00->uri,(uchar *)0x0,(location *)0x0,info_00->cache_mode,info_00->task,0);
    }
    done_session_info(info_00);
    return 1;
  }
  done_session_info(info_00);
LAB_080d8707:
  local_38 = (session *)0x0;
LAB_080d893d:
  if (0 < (int)__n) {
LAB_080d85a1:
    local_30 = info->data;
    do {
      pvVar3 = memchr(local_30,0,(size_t)__n);
      len = __n;
      if (pvVar3 != (void *)0x0) {
        len = (void *)((int)pvVar3 - (int)local_30);
      }
      uri_00 = (uri *)0x0;
      uristring = memacpy(local_30,(int)len);
      if (uristring != (uchar *)0x0) {
        uri_00 = get_hooked_uri(uristring,local_38,term->cwd);
        mem_free(uristring);
      }
      __n = (void *)((int)__n + ~(uint)len);
      uri = uri_00;
      if (local_20[0] == 0) {
        plVar2 = (list_head_elinks *)(term->windows).next;
        if (uri_00 == (uri *)0x0) {
          uri = get_uri((uchar *)"about:blank",0);
        }
        ses = init_session(local_38,term,uri,(uint)(plVar2 != &term->windows));
        if (ses == (session *)0x0) {
          __n = (void *)0x0;
        }
        else {
          if (uri_00 == (uri *)0x0) {
            if (assert_failed == 0) {
              uVar5 = 0xfffe7957;
            }
            else {
              uVar5 = 0xfffe795d;
            }
            assert_failed = 0;
            print_error_dialog(ses,(connection_state)(ulonglong)uVar5,(uri *)0x0,PRI_MAIN);
          }
        }
        if (uri != (uri *)0x0) {
LAB_080d85d1:
          done_uri(uri);
        }
      }
      else {
        if (uri_00 != (uri *)0x0) {
          init_remote_session(local_38,local_20,uri_00);
          goto LAB_080d85d1;
        }
      }
      if ((int)__n < 1) {
        if (local_20[0] == 0) {
          return (uint)(&term->windows != (list_head_elinks *)(term->windows).next);
        }
        return 0;
      }
      local_30 = local_30 + (int)len + 1;
    } while( true );
  }
  if (local_20[0] == 0) {
LAB_080d884f:
    ses = init_session(local_38,term,(uri *)0x0,0);
    uVar5 = (uint)(ses != (session *)0x0);
  }
  else {
    init_remote_session(local_38,local_20,(uri *)0x0);
    uVar5 = 0;
  }
  return uVar5;
}



void load_frames(session *ses)

{
  frameset_desc *frameset_desc;
  void *pvVar1;
  uri *uri;
  list_head_elinks *plVar2;
  int iVar3;
  int in_stack_00000008;
  
  if ((*(int *)(in_stack_00000008 + 0x14) != 0) &&
     (frameset_desc = *(frameset_desc **)(*(int *)(in_stack_00000008 + 0x14) + 200),
     frameset_desc != (frameset_desc *)0x0)) {
    request_frameset(ses,frameset_desc,0);
    plVar2 = (list_head_elinks *)(ses->scrn_frames).next;
    while (plVar2 != &ses->scrn_frames) {
      pvVar1 = plVar2[2].prev;
      if ((pvVar1 != (void *)0x0) && (0 < *(int *)((int)pvVar1 + 0xac))) {
        iVar3 = 0;
        do {
          uri = *(uri **)(*(int *)((int)pvVar1 + 0xb0) + iVar3 * 4);
          if (uri != (uri *)0x0) {
            request_additional_file(ses,"",uri,2);
          }
          iVar3 = iVar3 + 1;
        } while (iVar3 < *(int *)((int)pvVar1 + 0xac));
      }
      plVar2 = (list_head_elinks *)plVar2->next;
    }
  }
  return;
}



void tabwin_func(window *tab,term_event *ev)

{
  document_view *pdVar1;
  session *ses;
  window *pwVar2;
  terminal *term;
  uchar *p;
  type_query *type_query;
  document_view *pdVar3;
  window *pwVar4;
  document_view *p_00;
  document_view *doc_view;
  
  ses = (session *)tab->data;
  if (ev->ev < 6) {
    switch(ev->ev) {
    default:
      *(byte *)&tab->field_0x28 = *(byte *)&tab->field_0x28 | 1;
    case EVENT_REDRAW:
      if ((ses != (session *)0x0) &&
         (pwVar2 = ses->tab, term = pwVar2->term, pwVar4 = get_tab_by_number(term,term->current_tab)
         , pwVar2 == pwVar4)) {
        draw_formatted(ses,(uint)*(byte *)&tab->field_0x28 & 1);
        if ((*(byte *)&tab->field_0x28 & 1) != 0) {
          load_frames(ses);
          process_file_requests(ses);
          *(byte *)&tab->field_0x28 = *(byte *)&tab->field_0x28 & 0xfe;
        }
        print_screen_status(ses);
        return;
      }
      break;
    case EVENT_KBD:
    case EVENT_MOUSE:
      if (ses != (session *)0x0) {
        if (assert_failed == 0) {
          pwVar2 = ses->tab;
          pwVar4 = get_tab_by_number(pwVar2->term,pwVar2->term->current_tab);
          assert_failed = ZEXT14(pwVar2 != pwVar4);
          if (pwVar2 != pwVar4) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
            errline = 0x51c;
            elinks_internal((uchar *)"assertion ses->tab == get_current_tab(ses->tab->term) failed!"
                           );
          }
        }
        send_event(ses,ev);
        return;
      }
      break;
    case EVENT_ABORT:
      if (ses != (session *)0x0) {
        if (assert_failed == 0) {
          assert_failed = 0;
          destroy_downloads(ses);
          abort_loading(ses,0);
          free_files(ses);
          if (ses->doc_view != (document_view *)0x0) {
            detach_formatted(ses->doc_view);
            mem_free(ses->doc_view);
          }
          doc_view = (document_view *)(ses->scrn_frames).next;
          pdVar1 = (document_view *)&ses->scrn_frames;
          p_00 = doc_view;
          if (doc_view != pdVar1) {
            do {
              detach_formatted(doc_view);
              doc_view = doc_view->next;
            } while (doc_view != pdVar1);
            doc_view = (document_view *)(ses->scrn_frames).next;
            p_00 = doc_view;
          }
          while (pdVar1 != doc_view) {
            doc_view = doc_view->next;
          }
          doc_view = (document_view *)(ses->scrn_frames).prev;
          while (doc_view != pdVar1) {
            doc_view = doc_view->prev;
          }
          doc_view = p_00->next;
          while (pdVar3 = doc_view, p_00 != pdVar1) {
            pdVar3->prev = p_00->prev;
            p_00->prev->next = p_00->next;
            mem_free(p_00);
            doc_view = pdVar3->next;
            p_00 = pdVar3;
          }
          destroy_history(&ses->history);
          set_session_referrer(ses,(uri *)0x0);
          if (ses->loading_uri != (uri *)0x0) {
            done_uri(ses->loading_uri);
          }
          kill_timer(&ses->display_timer);
          type_query = (type_query *)(ses->type_queries).next;
          while (type_query != (type_query *)&ses->type_queries) {
            done_type_query(type_query);
            type_query = (type_query *)(ses->type_queries).next;
          }
          if (ses->download_uri != (uri *)0x0) {
            done_uri(ses->download_uri);
          }
          if (ses->search_word != (uchar *)0x0) {
            mem_free(ses->search_word);
          }
          if (ses->last_search_word != (uchar *)0x0) {
            mem_free(ses->last_search_word);
          }
          p = (ses->status).last_title;
          if (p != (uchar *)0x0) {
            mem_free(p);
          }
          ses->next->prev = ses->prev;
          ses->prev->next = ses->next;
        }
        else {
          assert_failed = 0;
        }
      }
      if ((list_head_elinks *)sessions.next != &sessions) {
        update_status();
        return;
      }
    }
  }
  return;
}



void display_timer(session *ses)

{
  void *pvVar1;
  uri *uri;
  list_head_elinks *plVar2;
  milliseconds_T a;
  int iVar3;
  document *pdVar4;
  timeval_T duration;
  timeval_T stop;
  timeval_T start;
  
  timeval_now(&start);
  draw_formatted(ses,3);
  timeval_now(&stop);
  timeval_sub(&duration,&start,&stop);
  a = timeval_to_milliseconds(&duration);
  a = mult_ms(a,0x14);
  if (a < 200) {
    a = 200;
  }
  install_timer(&ses->display_timer,a,display_timer,ses);
  pdVar4 = ses->doc_view->document;
  if (pdVar4 != (document *)0x0) {
    if (pdVar4->frame_desc != (frameset_desc *)0x0) {
      request_frameset(ses,pdVar4->frame_desc,0);
      plVar2 = (list_head_elinks *)(ses->scrn_frames).next;
      while (plVar2 != &ses->scrn_frames) {
        pvVar1 = plVar2[2].prev;
        if ((pvVar1 != (void *)0x0) && (0 < *(int *)((int)pvVar1 + 0xac))) {
          iVar3 = 0;
          do {
            uri = *(uri **)(*(int *)((int)pvVar1 + 0xb0) + iVar3 * 4);
            if (uri != (uri *)0x0) {
              request_additional_file(ses,"",uri,2);
            }
            iVar3 = iVar3 + 1;
          } while (iVar3 < *(int *)((int)pvVar1 + 0xac));
        }
        plVar2 = (list_head_elinks *)plVar2->next;
      }
      pdVar4 = ses->doc_view->document;
      if (pdVar4 == (document *)0x0) goto LAB_080d8e6b;
    }
    if (0 < (pdVar4->css_imports).size) {
      iVar3 = 0;
      do {
        uri = (pdVar4->css_imports).uris[iVar3];
        if (uri != (uri *)0x0) {
          request_additional_file(ses,"",uri,2);
        }
        iVar3 = iVar3 + 1;
      } while (iVar3 < (pdVar4->css_imports).size);
    }
  }
LAB_080d8e6b:
  process_file_requests(ses);
  return;
}



void doc_loading_callback(download *download,session *ses)

{
  connection_basic_state cVar1;
  uchar *title;
  cache_entry *cached;
  void *pvVar2;
  list_head_elinks *plVar3;
  bool bVar4;
  time_t vtime;
  int *piVar5;
  option_value *poVar6;
  fragment *pfVar7;
  uchar *name;
  uchar *name_00;
  int iVar8;
  document *pdVar9;
  uri *uri;
  
  cVar1 = (download->state).basic;
  if (cVar1 < 0) {
    cached = download->cached;
    if ((cached != (cache_entry *)0x0) && ((*(byte *)&cached->field_0x5c & 2) == 0)) {
      (cached->object).refcount = (cached->object).refcount + 1;
      pfVar7 = get_cache_fragment(cached);
      if ((pfVar7 != (fragment *)0x0) && ((cached->frag).next == (cached->frag).prev)) {
        if (pre_format_html_event == -1) {
          pre_format_html_event = get_event_id((uchar *)"pre-format-html");
        }
        trigger_event(pre_format_html_event,ses,cached);
        *(byte *)&cached->field_0x5c = *(byte *)&cached->field_0x5c | 2;
      }
      (cached->object).refcount = (cached->object).refcount + -1;
    }
    kill_timer(&ses->display_timer);
    draw_formatted(ses,1);
    piVar5 = get_opt_(cmdline_options,name);
    if (*piVar5 == 0) {
      pdVar9 = ses->doc_view->document;
      bVar4 = false;
    }
    else {
      pdVar9 = ses->doc_view->document;
      bVar4 = false;
      if ((list_head_elinks *)(pdVar9->forms).next != &pdVar9->forms) {
        poVar6 = get_opt_(cmdline_options,name_00);
        *poVar6 = 0;
        pdVar9 = ses->doc_view->document;
        bVar4 = true;
      }
    }
    if (pdVar9 != (document *)0x0) {
      if (pdVar9->frame_desc != (frameset_desc *)0x0) {
        request_frameset(ses,pdVar9->frame_desc,0);
        plVar3 = (list_head_elinks *)(ses->scrn_frames).next;
        while (plVar3 != &ses->scrn_frames) {
          pvVar2 = plVar3[2].prev;
          if ((pvVar2 != (void *)0x0) && (0 < *(int *)((int)pvVar2 + 0xac))) {
            iVar8 = 0;
            do {
              uri = *(uri **)(*(int *)((int)pvVar2 + 0xb0) + iVar8 * 4);
              if (uri != (uri *)0x0) {
                request_additional_file(ses,"",uri,2);
              }
              iVar8 = iVar8 + 1;
            } while (iVar8 < *(int *)((int)pvVar2 + 0xac));
          }
          plVar3 = (list_head_elinks *)plVar3->next;
        }
        pdVar9 = ses->doc_view->document;
        if (pdVar9 == (document *)0x0) goto LAB_080d9063;
      }
      if (0 < (pdVar9->css_imports).size) {
        iVar8 = 0;
        do {
          uri = (pdVar9->css_imports).uris[iVar8];
          if (uri != (uri *)0x0) {
            request_additional_file(ses,"",uri,2);
          }
          iVar8 = iVar8 + 1;
        } while (iVar8 < (pdVar9->css_imports).size);
      }
    }
LAB_080d9063:
    process_file_requests(ses);
    start_document_refreshes(ses);
    if ((download->state).basic != S_OK) {
      print_error_dialog(ses,download->state,ses->doc_view->document->uri,download->pri);
    }
  }
  else {
    if ((cVar1 < 8) || (ses->display_timer != (timer_id_T)0x0)) {
      bVar4 = false;
    }
    else {
      display_timer(ses);
      bVar4 = false;
    }
  }
  check_questions_queue(ses);
  print_screen_status(ses);
  if (download->pri != PRI_CSS) {
    title = ses->doc_view->document->title;
    if (download->conn == (connection *)0x0) {
      if (download->cached == (cache_entry *)0x0) goto LAB_080d8f03;
      uri = download->cached->uri;
    }
    else {
      uri = download->conn->proxied_uri;
    }
    if (uri != (uri *)0x0) {
      vtime = time((time_t *)0x0);
      add_global_history_item(uri->string,title,vtime);
    }
  }
LAB_080d8f03:
  if (bVar4) {
    auto_submit_form(ses);
    return;
  }
  return;
}



void file_loading_callback(download *download,file_to_load *ftl)

{
  cache_entry *pcVar1;
  session *ses;
  uri *puVar2;
  uchar *puVar3;
  cache_entry *pcVar4;
  
  pcVar4 = (ftl->download).cached;
  if (pcVar4 != (cache_entry *)0x0) {
    pcVar1 = ftl->cached;
    if (pcVar4 == pcVar1) goto LAB_080d91a8;
    if (pcVar1 != (cache_entry *)0x0) {
      (pcVar1->object).refcount = (pcVar1->object).refcount + -1;
      pcVar4 = (ftl->download).cached;
    }
    ftl->cached = pcVar4;
    (pcVar4->object).refcount = (pcVar4->object).refcount + 1;
  }
  pcVar4 = ftl->cached;
LAB_080d91a8:
  if (((pcVar4 != (cache_entry *)0x0) && ((*(byte *)&pcVar4->field_0x5c & 4) == 0)) &&
     (download->pri != PRI_CSS)) {
    ses = ftl->ses;
    puVar2 = ses->loading_uri;
    ses->loading_uri = ftl->uri;
    puVar3 = (ses->task).target.frame;
    (ses->task).target.frame = ftl->target_frame;
    setup_download_handler(ses,&ftl->download,ftl->cached,1);
    ses->loading_uri = puVar2;
    (ses->task).target.frame = puVar3;
  }
  doc_loading_callback(download,ftl->ses);
  return;
}



void __regparm3 free_task(session *ses)

{
  bool bVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  bVar1 = (ses->task).type == TASK_NONE;
  assert_failed = ZEXT14(bVar1);
  if (bVar1) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
    errline = 0x2c;
    elinks_internal((uchar *)"assertion ses->task.type failed: Session has no task");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (ses->loading_uri != (uri *)0x0) {
    done_uri(ses->loading_uri);
    ses->loading_uri = (uri *)0x0;
  }
  (ses->task).type = TASK_NONE;
  return;
}



uri * get_hooked_uri(uchar *uristring,session *ses,uchar *cwd)

{
  int goto_url_event_id;
  uri *puVar1;
  
  uristring = stracpy(uristring);
  if (uristring != (uchar *)0x0) {
    if (goto_url_event_id == -1) {
      goto_url_event_id = get_event_id((uchar *)"goto-url");
    }
    trigger_event(goto_url_event_id,&uristring,ses);
    if (uristring != (uchar *)0x0) {
      puVar1 = (uri *)0x0;
      if (*uristring != '\0') {
        puVar1 = get_translated_uri(uristring,cwd);
      }
      mem_free(uristring);
      return puVar1;
    }
  }
  return (uri *)0x0;
}



// WARNING: Type propagation algorithm not settling

view_state * ses_forward(session *ses,int loaded_in_frame)

{
  ses_history *history;
  object *poVar1;
  byte *pbVar2;
  uchar *puVar3;
  uri *puVar4;
  document_view *pdVar5;
  frame *pfVar6;
  view_state *vs;
  location *dst;
  bool bVar7;
  
  if (loaded_in_frame == 0) {
    free_files(ses);
    if (ses->search_word != (uchar *)0x0) {
      mem_free(ses->search_word);
    }
    ses->search_word = (uchar *)0x0;
  }
  history = &ses->history;
  dst = (location *)0x0;
  if (loaded_in_frame == 0) goto LAB_080d93fd;
LAB_080d9378:
  puVar3 = (ses->task).target.frame;
  do {
    if ((puVar3 == (uchar *)0x0) || (*puVar3 == '\0')) {
      if (assert_failed != 0) {
        assert_failed = 0;
        return (view_state *)0x0;
      }
      assert_failed = ZEXT14(dst == (location *)0x0);
      if (dst == (location *)0x0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
        errline = 0x15d;
        elinks_internal((uchar *)"assertion loc failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return (view_state *)0x0;
        }
      }
      *(list_head_elinks **)&(dst->frames).prev = &dst->frames;
      vs = &dst->vs;
      *(list_head_elinks **)&(dst->frames).next = &dst->frames;
      init_vs(vs,ses->loading_uri,(dst->vs).plain);
      add_to_history(history,dst);
LAB_080d94c8:
      pbVar2 = (byte *)&(ses->status).field_0x34;
      *pbVar2 = *pbVar2 & 0xfe;
      if ((ses->task).type == TASK_FORWARD) {
        clean_unhistory(history);
        return vs;
      }
      return vs;
    }
    if (assert_failed != 0) {
      assert_failed = 0;
      return (view_state *)0x0;
    }
    bVar7 = (ses->history).current == (location *)0x0;
    assert_failed = ZEXT14(bVar7);
    if (bVar7) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
      errline = 0x137;
      elinks_internal((uchar *)"assertion have_location(ses) failed: no location yet");
      if (assert_failed != 0) {
        assert_failed = 0;
        return (view_state *)0;
      }
    }
    if (loaded_in_frame == 0) {
      copy_location(dst,(ses->history).current);
      add_to_history(history,dst);
    }
    pfVar6 = ses_find_frame(ses,(ses->task).target.frame);
    if (pfVar6 != (frame *)0x0) {
      vs = &pfVar6->vs;
      if (loaded_in_frame == 0) {
        destroy_vs(vs,1);
        init_vs(vs,ses->loading_uri,(pfVar6->vs).plain);
      }
      else {
        done_uri((pfVar6->vs).uri);
        puVar4 = ses->loading_uri;
        poVar1 = &puVar4->object;
        poVar1->refcount = poVar1->refcount + 1;
        (pfVar6->vs).uri = puVar4;
        pdVar5 = (pfVar6->vs).doc_view;
        if (pdVar5 != (document_view *)0x0) {
          pdVar5->vs = (view_state *)0x0;
          (pfVar6->vs).doc_view = (document_view *)0x0;
        }
      }
      goto LAB_080d94c8;
    }
    if (loaded_in_frame == 0) {
      del_from_history(history,dst);
      destroy_location(dst);
    }
    (ses->task).target.frame = (uchar *)0x0;
    if (loaded_in_frame != 0) goto LAB_080d9378;
LAB_080d93fd:
    dst = (location *)mem_calloc(1,0x70);
    if (dst == (location *)0x0) {
      return (view_state *)0x0;
    }
    (dst->download).next = (ses->loading).next;
    (dst->download).prev = (ses->loading).prev;
    (dst->download).conn = (ses->loading).conn;
    (dst->download).cached = (ses->loading).cached;
    (dst->download).callback = (ses->loading).callback;
    (dst->download).data = (ses->loading).data;
    (dst->download).progress = (ses->loading).progress;
    (dst->download).state.basic = (ses->loading).state.basic;
    (dst->download).state.syserr = (ses->loading).state.syserr;
    (dst->download).prev_error.basic = (ses->loading).prev_error.basic;
    (dst->download).prev_error.syserr = (ses->loading).prev_error.syserr;
    (dst->download).pri = (ses->loading).pri;
    puVar3 = (ses->task).target.frame;
  } while( true );
}



void post_no(void *task_)

{
  reload(*(session **)task_,CACHE_MODE_NORMAL);
  done_uri(*(uri **)((int)task_ + 4));
  return;
}



void ses_load(session *ses,uri *uri,uchar *target_frame,location *target_location,
             cache_mode cache_mode,task_type task_type)

{
  (ses->loading).callback = loading_callback;
  *(session **)&(ses->loading).data = ses;
  ses->loading_uri = uri;
  (ses->task).type = task_type;
  (ses->task).target.frame = target_frame;
  (ses->task).target.location = target_location;
  load_uri(uri,ses->referrer,&ses->loading,PRI_MAIN,cache_mode,-1);
  return;
}



void ses_goto(session *ses,uri *uri,uchar *target_frame,location *target_location,
             cache_mode cache_mode,task_type task_type,int redir)

{
  byte *pbVar1;
  document *pdVar2;
  document_refresh *refresh;
  bool bVar3;
  bool bVar4;
  cache_entry *pcVar5;
  session **p;
  uchar *p_00;
  uchar *text;
  memory_list *ml;
  int *piVar6;
  byte *src;
  ushort **ppuVar7;
  int iVar8;
  int slen;
  uchar *p_01;
  uchar *p_02;
  byte *pbVar9;
  byte bVar10;
  int iVar11;
  byte *pbVar12;
  char *local_88;
  byte *s;
  bool bVar13;
  
  if ((*(byte *)&uri->field_0x36 & 2) == 0) {
LAB_080d9750:
    bVar4 = false;
  }
  else {
    piVar6 = get_opt_(config_options,(uchar *)uri);
    bVar4 = true;
    if (*piVar6 == 0) goto LAB_080d9750;
  }
  if (((ses->doc_view != (document_view *)0x0) &&
      (pdVar2 = ses->doc_view->document, pdVar2 != (document *)0x0)) &&
     (refresh = pdVar2->refresh, refresh != (document_refresh *)0x0)) {
    kill_document_refresh(refresh);
  }
  if ((assert_failed == 0) &&
     (bVar13 = ses->loading_uri != (uri *)0x0, assert_failed = ZEXT14(bVar13), bVar13)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
    errline = 0xb6;
    elinks_internal((uchar *)"assertion !ses->loading_uri failed: Buggy URI reference counting");
  }
  if (redir == 0) {
    ses->redirect_cnt = 0;
  }
  if ((uri->user != (uchar *)0x0) && (*(short *)&uri->field_0x2a != 0)) {
    local_88 = "document.browse.links.warn_malicious";
    piVar6 = get_opt_(config_options,uri->user);
    if (*piVar6 != 0) {
      if (assert_failed == 0) {
        if ((uri->user == (uchar *)0x0) || (*(short *)&uri->field_0x2a == 0)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
          errline = 0x7e;
          elinks_internal((uchar *)"assertion uri->user && uri->userlen failed!",local_88);
        }
        else {
          assert_failed = 0;
        }
      }
      src = memacpy(uri->user,(uint)*(ushort *)&uri->field_0x2a);
      if (src != (byte *)0x0) {
        decode_uri_for_display(src);
        bVar10 = *src;
        s = src;
LAB_080d99f8:
        if (bVar10 != 0) {
          ppuVar7 = __ctype_b_loc();
          iVar8 = 0;
          pbVar12 = s;
          do {
            if (((*(byte *)(*ppuVar7 + bVar10) & 8) == 0) && (bVar10 != 0x2e)) break;
            iVar8 = iVar8 + 1;
            bVar10 = s[iVar8];
            pbVar12 = s + iVar8;
          } while (bVar10 != 0);
          slen = iVar8;
          if ((iVar8 != 0) && (s[iVar8 + -1] == 0x2e)) {
            pbVar9 = s + iVar8;
            iVar11 = 0;
            do {
              iVar11 = iVar11 + 1;
              if (iVar8 <= iVar11) {
                slen = iVar8 - iVar11;
                break;
              }
              pbVar1 = pbVar9 + -2;
              pbVar9 = pbVar9 + -1;
              slen = iVar8 - iVar11;
            } while (*pbVar1 == 0x2e);
          }
          iVar8 = end_with_known_tld(s,slen);
          if (iVar8 != -1) {
            bVar13 = true;
            bVar3 = false;
            mem_free(src);
            goto LAB_080d984b;
          }
          bVar10 = *pbVar12;
          if (bVar10 != 0) {
            do {
              if (((*(byte *)(*ppuVar7 + bVar10) & 8) != 0) && (s = pbVar12, bVar10 != 0x2e))
              goto LAB_080d99f8;
              pbVar12 = pbVar12 + 1;
              bVar10 = *pbVar12;
            } while (bVar10 != 0);
          }
          bVar10 = 0;
          s = pbVar12;
          goto LAB_080d99f8;
        }
        mem_free(src);
      }
    }
  }
  if ((*(byte *)&uri->field_0x36 & 2) != 0) {
    if ((ses->referrer != (uri *)0x0) &&
       (pcVar5 = find_in_cache(ses->referrer), pcVar5 != (cache_entry *)0x0)) {
      bVar13 = false;
      bVar3 = true;
      if ((*(byte *)&pcVar5->field_0x5c & 8) != 0) goto LAB_080d984b;
    }
    pcVar5 = get_validated_cache_entry(uri,cache_mode);
    if (pcVar5 != (cache_entry *)0x0) goto LAB_080d9806;
  }
  if (bVar4) {
    bVar13 = false;
    bVar3 = false;
LAB_080d984b:
    p = (session **)mem_alloc(0x18);
    if (p != (session **)0x0) {
      *p = ses;
      (uri->object).refcount = (uri->object).refcount + 1;
      *(uri **)(p + 1) = uri;
      *(cache_mode *)(p + 2) = cache_mode;
      *(task_type *)(p + 3) = task_type;
      *(uchar **)(p + 4) = target_frame;
      *(location **)(p + 5) = target_location;
      if (bVar13) {
        p_01 = memacpy(uri->host,(uint)*(ushort *)&uri->field_0x2e);
        p_02 = memacpy(uri->user,(uint)*(ushort *)&uri->field_0x2a);
        p_00 = get_uri_string(uri,URI_PUBLIC);
        text = msg_text(ses->tab->term,
                        (uchar *)
                        "The URL you are about to follow might be maliciously crafted in order to confuse you. By following the URL you will be connecting to host \"%s\" as user \"%s\".\n\nDo you want to go to URL %s?"
                        ,p_01,p_02,p_00);
        if (p_01 != (uchar *)0x0) {
          mem_free(p_01);
        }
        if (p_02 != (uchar *)0x0) {
          mem_free(p_02);
        }
      }
      else {
        local_88 = "Do you want to follow the redirect and post form data to URL %s?";
        if (((redir == 0) &&
            (local_88 = 
             "The form data you are about to post might be incomplete.\nDo you want to post to URL %s?"
            , !bVar3)) &&
           (local_88 = "Do you want to post form data to URL %s?", task_type != TASK_FORWARD)) {
          local_88 = "Do you want to repost form data to URL %s?";
        }
        p_00 = get_uri_string(uri,URI_PUBLIC);
        text = msg_text(ses->tab->term,(uchar *)local_88,p_00);
      }
      if (p_00 != (uchar *)0x0) {
        mem_free(p_00);
      }
      ml = getml(p,0);
      msg_box(ses->tab->term,ml,MSGBOX_FREE_TEXT,(uchar *)"Warning",ALIGN_CENTER,text,p,2,
              &DAT_0812762b,post_yes,1,&DAT_08127627,post_no,2);
    }
    return;
  }
LAB_080d9806:
  (uri->object).refcount = (uri->object).refcount + 1;
  ses_load(ses,uri,target_frame,target_location,cache_mode,task_type);
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void __regparm3
do_follow_url(session *ses,uri *uri,uchar *target,task_type task,cache_mode cache_mode,
             int do_referrer)

{
  protocol_external_handler_T *UNRECOVERED_JUMPTABLE;
  uint uVar1;
  document_view *pdVar2;
  int *piVar3;
  session *psVar4;
  int iVar5;
  int iVar6;
  uchar *puVar7;
  uchar *puVar8;
  bool bVar9;
  byte bVar10;
  uri *local_2c;
  
  bVar10 = 0;
  if (uri == (uri *)0x0) {
    if (assert_failed == 0) {
      uVar1 = 0xfffe7957;
    }
    else {
      uVar1 = 0xfffe795d;
    }
    assert_failed = 0;
    print_error_dialog(ses,(connection_state)(ulonglong)uVar1,(uri *)0x0,PRI_CANCEL);
    return;
  }
  UNRECOVERED_JUMPTABLE = get_protocol_external_handler(ses->tab->term,uri);
  if (UNRECOVERED_JUMPTABLE != (protocol_external_handler_T *)0x0) {
                    // WARNING: Could not recover jumptable at 0x080d9c99. Too many branches
                    // WARNING: Treating indirect jump as call
    (*UNRECOVERED_JUMPTABLE)();
    return;
  }
  if (((do_referrer == 0) || (pdVar2 = current_frame(ses), pdVar2 == (document_view *)0x0)) ||
     (pdVar2->document == (document *)0x0)) {
    local_2c = (uri *)0x0;
  }
  else {
    local_2c = pdVar2->document->uri;
  }
  bVar9 = target == (uchar *)0x0;
  if (!bVar9) {
    iVar6 = 7;
    puVar7 = target;
    puVar8 = "_blank";
    do {
      if (iVar6 == 0) break;
      iVar6 = iVar6 + -1;
      bVar9 = *puVar7 == *puVar8;
      puVar7 = puVar7 + (uint)bVar10 * -2 + 1;
      puVar8 = puVar8 + (uint)bVar10 * -2 + 1;
    } while (bVar9);
    if (bVar9) {
      piVar3 = get_opt_(config_options,(uchar *)uri);
      iVar6 = *piVar3;
      if (iVar6 == 3) {
        piVar3 = get_opt_(cmdline_options,(uchar *)uri);
        if (((*piVar3 == 0) && (iVar5 = can_open_in_new(ses->tab->term), iVar5 != 0)) &&
           ((piVar3 = get_opt_(cmdline_options,(uchar *)uri), *piVar3 == 0 &&
            (piVar3 = get_opt_(cmdline_options,(uchar *)uri), *piVar3 == 0)))) {
          open_uri_in_new_window(ses,uri,local_2c,ses->tab->term->environment,cache_mode,task);
          return;
        }
      }
      else {
        if (iVar6 < 1) goto LAB_080d9ccb;
      }
      psVar4 = init_session(ses,ses->tab->term,uri,(uint)(iVar6 == 2));
      if (psVar4 != (session *)0x0) {
        ses = psVar4;
      }
    }
  }
LAB_080d9ccb:
  ses->reloadlevel = cache_mode;
  if (((ses->task).type != task) || (iVar6 = compare_uri(ses->loading_uri,uri,0), iVar6 == 0)) {
    abort_loading(ses,0);
    set_session_referrer(ses,local_2c);
    ses_goto(ses,uri,target,(location *)0x0,cache_mode,task,0);
  }
  return;
}



void __regparm3
follow_url(session *ses,uri *uri,uchar *target,task_type task,cache_mode cache_mode,int referrer)

{
  int follow_url_event_id;
  uri *uri_00;
  uchar *local_20 [4];
  
  if (uri == (uri *)0x0) {
    local_20[0] = (uchar *)0x0;
  }
  else {
    local_20[0] = get_uri_string(uri,0xffff83bf);
    if (local_20[0] != (uchar *)0x0) {
      if (follow_url_event_id == -1) {
        follow_url_event_id = get_event_id((uchar *)"follow-url");
      }
      trigger_event(follow_url_event_id,local_20,ses);
      if (local_20[0] == (uchar *)0x0) {
        return;
      }
      if (*local_20[0] == '\0') {
        mem_free(local_20[0]);
        return;
      }
      uri_00 = get_translated_uri(local_20[0],ses->tab->term->cwd);
      mem_free(local_20[0]);
      do_follow_url(ses,uri_00,target,task,cache_mode,referrer);
      if (uri_00 == (uri *)0x0) {
        return;
      }
      done_uri(uri_00);
      return;
    }
  }
  do_follow_url(ses,uri,target,task,cache_mode,referrer);
  return;
}



void goto_imgmap(session *ses,uri *uri,uchar *target)

{
  follow_url(ses,uri,target,TASK_IMGMAP,CACHE_MODE_NORMAL,1);
  return;
}



void goto_uri_frame(session *ses,uri *uri,uchar *target,cache_mode cache_mode)

{
  follow_url(ses,uri,target,TASK_FORWARD,cache_mode,1);
  return;
}



void map_selected(terminal *term,void *ld_,void *ses_)

{
  uri *uri;
  
  uri = get_uri(*(uchar **)ld_,0);
  goto_uri_frame((session *)ses_,uri,*(uchar **)((int)ld_ + 4),CACHE_MODE_NORMAL);
  if (uri != (uri *)0x0) {
    done_uri(uri);
    return;
  }
  return;
}



void delayed_goto_uri_frame(void *data)

{
  frame *pfVar1;
  uchar *local_14;
  
  if ((assert_failed == 0) && (assert_failed = ZEXT14(data == (void *)0x0), data == (void *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
    errline = 0x2a8;
    elinks_internal((uchar *)"assertion deo failed!");
  }
  pfVar1 = ses_find_frame(*(session **)data,*(uchar **)((int)data + 8));
  if (pfVar1 == (frame *)0x0) {
    local_14 = (uchar *)0x0;
  }
  else {
    local_14 = pfVar1->name;
  }
  goto_uri_frame(*(session **)data,*(uri **)((int)data + 4),local_14,CACHE_MODE_NORMAL);
  done_uri(*(uri **)((int)data + 4));
  mem_free(*(void **)((int)data + 8));
  mem_free(data);
  return;
}



void goto_uri(session *ses,uri *uri)

{
  follow_url(ses,uri,(uchar *)0x0,TASK_FORWARD,CACHE_MODE_NORMAL,0);
  return;
}



void goto_url_with_hook(session *ses,uchar *url)

{
  uri *uri;
  
  if (*url != '\0') {
    uri = get_hooked_uri(url,ses,ses->tab->term->cwd);
    if (uri != (uri *)0x0) {
      goto_uri(ses,uri);
      done_uri(uri);
      return;
    }
  }
  return;
}



int goto_url_home(session *ses)

{
  uchar **ppuVar1;
  uchar *url;
  uchar *in_EDX;
  
  ppuVar1 = (uchar **)get_opt_(config_options,in_EDX);
  url = *ppuVar1;
  if (*url == '\0') {
    url = (uchar *)getenv("WWW_HOME");
  }
  if ((url != (uchar *)0x0) && (*url != '\0')) {
    goto_url_with_hook(ses,url);
    return 1;
  }
  return 0;
}



void goto_url(session *ses,uchar *url)

{
  uri *uri;
  
  uri = get_uri(url,0);
  goto_uri(ses,uri);
  if (uri != (uri *)0x0) {
    done_uri(uri);
    return;
  }
  return;
}



// WARNING: Type propagation algorithm not settling

void loading_callback(download *download,session *ses)

{
  connection_basic_state cVar1;
  int def;
  protocol_external_handler_T *ppVar2;
  cache_entry *cached;
  document_view *name;
  fragment *pfVar3;
  int *piVar4;
  int to;
  uri *uri;
  uchar *name_00;
  int hdef;
  bool bVar5;
  uchar *local_64;
  location *local_60;
  cache_mode local_5c;
  task_type local_58;
  menu_item *local_24;
  memory_list *local_20 [4];
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  bVar5 = (ses->task).type == TASK_NONE;
  assert_failed = ZEXT14(bVar5);
  if (bVar5) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
    errline = 0x211;
    elinks_internal((uchar *)"assertion ses->task.type failed: loading_callback: no ses->task");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (download == (download *)0x0) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
    errline = 0x1d2;
    elinks_internal((uchar *)"assertion download_p && *download_p failed!");
    if (assert_failed == 0) goto LAB_080da336;
LAB_080da55e:
    assert_failed = 0;
    hdef = 0;
    goto LAB_080da3f9;
  }
LAB_080da336:
  bVar5 = ses->loading_uri == (uri *)0x0;
  assert_failed = ZEXT14(bVar5);
  if (bVar5) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
    errline = 0x1d3;
    elinks_internal((uchar *)"assertion ses->loading_uri != NULL failed: no ses->loading_uri");
    if (assert_failed != 0) goto LAB_080da55e;
  }
  if (ses->loading_uri->protocol == 0x12) {
    hdef = 0;
    goto LAB_080da3f9;
  }
  if ((((ses->task).type == TASK_IMGMAP) && (-1 < (download->state).basic)) ||
     (cached = download->cached, cached == (cache_entry *)0x0)) {
    hdef = 0;
    goto LAB_080da3f9;
  }
  if (((cached->redirect == (uri *)0x0) ||
      (hdef = ses->redirect_cnt, ses->redirect_cnt = hdef + 1, 9 < hdef)) ||
     ((local_58 = (ses->task).type, local_58 == TASK_HISTORY &&
      ((ses->history).current == (location *)0x0)))) goto LAB_080da38b;
  if (assert_failed == 0) {
    hdef = compare_uri(cached->uri,ses->loading_uri,URI_BASE);
    assert_failed = ZEXT14(hdef == 0);
    if (hdef == 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
      errline = 0x19f;
      elinks_internal((uchar *)
                      "assertion compare_uri(cached->uri, ses->loading_uri, URI_BASE) failed: Redirecting using bad base URI"
                     );
    }
  }
  if (cached->redirect->protocol == 0x12) {
    hdef = 0;
    goto LAB_080da3f9;
  }
  abort_loading(ses,0);
  local_60 = (ses->history).current;
  if (local_60 == (location *)0x0) {
    download = (download *)0x0;
  }
  else {
    download = &local_60->download;
  }
  set_session_referrer(ses,cached->uri);
  if (local_58 == TASK_IMGMAP) {
LAB_080da960:
    local_5c = CACHE_MODE_NORMAL;
    local_60 = (location *)0x0;
    local_64 = (ses->task).target.frame;
  }
  else {
    if (local_58 < TASK_RELOAD) {
      if (local_58 != TASK_FORWARD) {
LAB_080da38b:
        kill_timer(&ses->display_timer);
        local_58 = (ses->task).type;
        if (local_58 == TASK_IMGMAP) {
          cached = find_in_cache(ses->loading_uri);
          name = current_frame(ses);
          if (cached == (cache_entry *)0x0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
            errline = 0x179;
            elinks_internal((uchar *)"can\'t find cache entry");
          }
          else {
            pfVar3 = get_cache_fragment(cached);
            if (((pfVar3 != (fragment *)0x0) && (name != (document_view *)0x0)) &&
               (name->document != (document *)0x0)) {
              piVar4 = get_opt_(config_options,(uchar *)name);
              hdef = *piVar4;
              piVar4 = get_opt_(config_options,name_00);
              def = *piVar4;
              to = get_terminal_codepage(ses->tab->term);
              hdef = get_image_map(cached->head,pfVar3->data,pfVar3->data + *(int *)&pfVar3->length,
                                   &local_24,local_20,ses->loading_uri,&name->document->options,
                                   (ses->task).target.frame,to,def,hdef);
              if (hdef == 0) {
                add_empty_window(ses->tab->term,freeml,local_20[0]);
                do_menu(ses->tab->term,local_24,ses,0);
              }
            }
          }
        }
        else {
          if (local_58 < TASK_RELOAD) {
            if ((local_58 == TASK_FORWARD) &&
               (hdef = setup_download_handler(ses,&ses->loading,cached,0), hdef != 0)) {
              hdef = 2;
              free_task(ses);
              reload(ses,CACHE_MODE_NORMAL);
              goto LAB_080da3f9;
            }
          }
          else {
            if (local_58 == TASK_RELOAD) {
              (ses->task).target.location = ((ses->history).current)->prev;
              ses_history_move(ses);
              ses_forward(ses,0);
            }
            else {
              if (local_58 == TASK_HISTORY) {
                ses_history_move(ses);
              }
            }
          }
        }
        if ((download->state).basic < 0) {
          local_60 = (ses->history).current;
          if (local_60 != (location *)0x0) {
            hdef = (ses->loading).state.syserr;
            (local_60->download).state.basic = (ses->loading).state.basic;
            (local_60->download).state.syserr = hdef;
          }
        }
        else {
          local_60 = (ses->history).current;
          if (local_60 != (location *)0x0) {
            download = &local_60->download;
          }
          move_download(&ses->loading,download,PRI_MAIN);
        }
        hdef = 1;
        free_task(ses);
        goto LAB_080da3f9;
      }
      uri = cached->redirect;
      ppVar2 = get_protocol_external_handler(ses->tab->term,uri);
      if (ppVar2 != (protocol_external_handler_T *)0x0) {
        (*ppVar2)(ses,uri);
        download = (download *)0x0;
        hdef = 0;
        goto LAB_080da3f9;
      }
      goto LAB_080da960;
    }
    if (local_58 == TASK_RELOAD) {
      local_5c = ses->reloadlevel;
      local_60 = (location *)0x0;
    }
    else {
      if (local_58 != TASK_HISTORY) goto LAB_080da38b;
      local_5c = CACHE_MODE_NORMAL;
      local_60 = (ses->task).target.location;
    }
    local_58 = TASK_RELOAD;
    local_64 = (uchar *)0x0;
  }
  hdef = 2;
  ses_goto(ses,cached->redirect,local_64,local_60,local_5c,local_58,1);
LAB_080da3f9:
  if (download != (download *)0x0) {
    if (hdef != 2) {
      if (hdef == 1) {
        download->callback = doc_loading_callback;
        *(session **)&download->data = ses;
        display_timer(ses);
      }
      if ((download->state).basic < 0) {
        if ((ses->task).type != TASK_NONE) {
          free_task(ses);
        }
        if (hdef == 1) {
          doc_loading_callback(download,ses);
        }
        cVar1 = (download->state).basic;
        if ((cVar1 != S_OK) && (cVar1 < 0)) {
          uri = (uri *)0x0;
          if (download->conn != (connection *)0x0) {
            uri = download->conn->uri;
          }
          print_error_dialog(ses,download->state,uri,download->pri);
          if (hdef == 0) {
            reload(ses,CACHE_MODE_NORMAL);
          }
        }
      }
    }
    check_questions_queue(ses);
    print_screen_status(ses);
    return;
  }
  return;
}



void abort_preloading(session *ses,int interrupt)

{
  if ((ses->task).type == TASK_NONE) {
    return;
  }
  cancel_download(&ses->loading,interrupt);
  free_task(ses);
  return;
}



void post_yes(void *task_)

{
  abort_preloading(*(session **)task_,0);
  ses_load(*(session **)task_,*(uri **)((int)task_ + 4),*(uchar **)((int)task_ + 0x10),
           *(location **)((int)task_ + 0x14),*(cache_mode *)((int)task_ + 8),
           *(task_type *)((int)task_ + 0xc));
  return;
}



void set_term_color16(screen_char *schar,color_flags flags,uchar fg,uchar bg)

{
  byte bVar1;
  int iVar2;
  byte bVar3;
  uint uVar4;
  uint uVar5;
  byte bVar6;
  uint uVar7;
  
  uVar4 = (uint)fg;
  uVar7 = (uint)bg;
  if ((flags & COLOR_INCREASE_CONTRAST) != 0) {
    uVar4 = (uint)"\a"[uVar4 * 8 + uVar7];
  }
  bVar1 = schar->attr;
  if (bVar1 != 0) {
    if ((bVar1 & 0x10) != 0) {
      uVar4 = uVar4 ^ 1;
    }
    if ((bVar1 & 8) != 0) {
      uVar4 = uVar4 | 8;
    }
    if (((bVar1 & 0x20) != 0) && ((flags & COLOR_ENHANCE_UNDERLINE) != 0)) {
      uVar4 = (uVar4 | 8) ^ 4;
    }
  }
  bVar6 = bg;
  if (((flags & COLOR_INCREASE_CONTRAST) != 0) ||
     ((uVar5 = uVar4, bVar3 = (byte)uVar4, bg == (byte)uVar4 &&
      (uVar5 = uVar7, bVar3 = bg, (flags & COLOR_ENSURE_CONTRAST) != 0)))) {
    if ((flags & COLOR_ENSURE_INVERTED_CONTRAST) == 0) {
      uVar5 = (uint)"\a"[uVar4 * 8 + uVar7];
      bVar3 = "\a"[uVar4 * 8 + uVar7];
    }
    else {
      iVar2 = uVar4 * 8 + uVar7;
      uVar5 = uVar7;
      uVar7 = (uint)"\a"[iVar2];
      bVar6 = "\a"[iVar2];
      bVar3 = bg;
    }
  }
  if ((uVar5 & 8) != 0) {
    schar->attr = bVar1 | 8;
  }
  if (((int)(uVar5 & 7) >> 2 | (uVar5 & 7) * 2 & 7) < (((uint)(bVar6 >> 2) | uVar7 * 2) & 7)) {
    schar->attr = schar->attr | 0x40;
  }
  schar->color[0] = bVar3 | (byte)(uVar7 << 4);
  return;
}



void set_term_color(screen_char *schar,color_pair *pair,color_flags flags,color_mode color_mode)

{
  byte bVar1;
  color_mode_info *pcVar2;
  rgb *prVar3;
  bool bVar4;
  rgb *prVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  byte bVar12;
  int iVar13;
  int iVar14;
  int iVar15;
  int local_80;
  int local_68;
  int local_60;
  byte local_5c;
  byte local_2d;
  
  if ((assert_failed == 0) && (bVar4 = 5 < color_mode + 1U, assert_failed = ZEXT14(bVar4), bVar4)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/color.c";
    errline = 299;
    elinks_internal((uchar *)
                    "assertion color_mode >= COLOR_MODE_DUMP && color_mode < COLOR_MODES failed!");
  }
  switch(color_mode) {
  case COLOR_MODE_MONO:
    if ((flags & COLOR_DECREASE_LIGHTNESS) == 0) goto switchD_080dafb8_caseD_2;
    schar->attr = schar->attr | 0x40;
    local_68 = 1;
    break;
  default:
    local_68 = 1;
    if ((flags & COLOR_DECREASE_LIGHTNESS) != 0) break;
  case COLOR_MODE_88:
  case COLOR_MODE_256:
switchD_080dafb8_caseD_2:
    local_68 = 0;
    break;
  case COLOR_MODE_DUMP:
  case COLOR_MODES:
    goto switchD_080dafb8_caseD_ffffffff;
  }
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(schar == (screen_char *)0x0), schar == (screen_char *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/color.c";
    errline = 0x16e;
    elinks_internal((uchar *)"assertion schar failed!");
  }
  pcVar2 = color_modes[color_mode];
  prVar3 = (&pcVar2->palette)[local_68 * 2 + 2];
  uVar11 = pair->foreground;
  prVar5 = pcVar2->palette;
  uVar7 = (uVar11 & 0xff0000) >> 0x10;
  uVar6 = uVar11 >> 8 & 0xff;
  uVar9 = (uint)(&prVar3[uVar7 * 2 + uVar6].r + (uVar11 & 0xff)) & 0xfff;
  if ((((rgb *)cache[uVar9].level == (rgb *)0x0) || (prVar3 != (rgb *)cache[uVar9].level)) ||
     (uVar11 != cache[uVar9].rgb)) {
    uVar10 = 0;
    local_5c = 0;
    if (1 < (int)prVar3) {
      iVar8 = (uVar11 & 0xff) - (uint)prVar5->b;
      iVar13 = uVar6 - prVar5->g;
      iVar14 = uVar7 - prVar5->r;
      local_2d = 0;
      local_80 = iVar14 * iVar14 * 3 + iVar13 * iVar13 * 4 + iVar8 * iVar8 * 2;
      iVar8 = 1;
      while( true ) {
        iVar13 = uVar7 - prVar5[iVar8].r;
        iVar14 = uVar6 - prVar5[iVar8].g;
        iVar15 = (uVar11 & 0xff) - (uint)prVar5[iVar8].b;
        iVar13 = iVar13 * iVar13 * 3 + iVar14 * iVar14 * 4 + iVar15 * iVar15 * 2;
        local_5c = local_2d;
        if (iVar13 < local_80) {
          local_5c = (byte)iVar8;
          local_80 = iVar13;
        }
        if ((rgb *)(iVar8 + 1) == prVar3) break;
        iVar8 = iVar8 + 1;
        local_2d = local_5c;
      }
      uVar10 = (uint)local_5c;
    }
    cache[uVar9].color = uVar10;
    *(rgb **)&cache[uVar9].level = prVar3;
    cache[uVar9].rgb = uVar11;
    prVar5 = pcVar2->palette;
  }
  else {
    local_5c = *(byte *)&cache[uVar9].color;
  }
  prVar3 = (&pcVar2->palette)[local_68 * 2 + 1];
  uVar11 = pair->background;
  uVar7 = (uVar11 & 0xff0000) >> 0x10;
  uVar9 = uVar11 >> 8 & 0xff;
  uVar6 = (uint)(&prVar3[uVar7 * 2 + uVar9].r + (uVar11 & 0xff)) & 0xfff;
  if ((((rgb *)cache[uVar6].level == (rgb *)0x0) || (prVar3 != (rgb *)cache[uVar6].level)) ||
     (uVar11 != cache[uVar6].rgb)) {
    uVar10 = 0;
    if (1 < (int)prVar3) {
      iVar8 = (uVar11 & 0xff) - (uint)prVar5->b;
      iVar14 = uVar7 - prVar5->r;
      iVar13 = uVar9 - prVar5->g;
      local_2d = 0;
      local_60 = iVar14 * iVar14 * 3 + iVar13 * iVar13 * 4 + iVar8 * iVar8 * 2;
      iVar8 = 1;
      while( true ) {
        iVar13 = uVar7 - prVar5[iVar8].r;
        iVar14 = uVar9 - prVar5[iVar8].g;
        iVar15 = (uVar11 & 0xff) - (uint)prVar5[iVar8].b;
        iVar13 = iVar13 * iVar13 * 3 + iVar14 * iVar14 * 4 + iVar15 * iVar15 * 2;
        if (iVar13 < local_60) {
          local_2d = (byte)iVar8;
          local_60 = iVar13;
        }
        if ((rgb *)(iVar8 + 1) == prVar3) break;
        iVar8 = iVar8 + 1;
      }
      uVar10 = (uint)local_2d;
    }
    cache[uVar6].color = uVar10;
    *(rgb **)&cache[uVar6].level = prVar3;
    cache[uVar6].rgb = uVar11;
  }
  else {
    uVar10 = (uint)*(byte *)&cache[uVar6].color;
  }
  bVar12 = (byte)uVar10;
  if (color_mode < 4) {
    if (1 < color_mode) {
      if ((local_5c == bVar12) && (bVar12 = local_5c, (flags & COLOR_ENSURE_CONTRAST) != 0)) {
        if ((flags & COLOR_ENSURE_INVERTED_CONTRAST) == 0) {
          if (local_5c == 0) {
            local_5c = 0xf;
          }
          else {
            local_5c = 0;
          }
        }
        else {
          bVar12 = -(local_5c == 0) & 0xf;
        }
      }
      schar->color[0] = local_5c;
      schar->color[1] = bVar12;
      return;
    }
    if (color_mode == COLOR_MODE_DUMP) goto LAB_080db080;
  }
  else {
    if (color_mode == COLOR_MODES) {
LAB_080db080:
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/color.c";
      errline = 0x177;
      elinks_internal((uchar *)"Bad color mode, it should _never_ occur here.");
      return;
    }
  }
  if ((flags & COLOR_INCREASE_CONTRAST) != 0) {
    local_5c = "\a"[(uint)local_5c * 8 + uVar10];
  }
  bVar1 = schar->attr;
  if (bVar1 != 0) {
    if ((bVar1 & 0x10) != 0) {
      local_5c = local_5c ^ 1;
    }
    if ((bVar1 & 8) != 0) {
      local_5c = local_5c | 8;
    }
    if (((bVar1 & 0x20) != 0) && ((flags & COLOR_ENHANCE_UNDERLINE) != 0)) {
      local_5c = (local_5c | 8) ^ 4;
    }
  }
  uVar11 = uVar10;
  uVar6 = uVar10;
  if ((flags & COLOR_INCREASE_CONTRAST) == 0) {
    if (local_5c == bVar12) {
      if ((flags & COLOR_ENSURE_CONTRAST) != 0) goto LAB_080daf40;
      uVar6 = (uint)local_5c;
    }
    else {
      uVar11 = (uint)local_5c;
    }
  }
  else {
LAB_080daf40:
    if ((flags & COLOR_ENSURE_INVERTED_CONTRAST) == 0) {
      local_5c = "\a"[(uint)local_5c * 8 + uVar10];
      uVar11 = (uint)local_5c;
    }
    else {
      uVar10 = (uint)"\a"[(uint)local_5c * 8 + uVar10];
      uVar6 = (uint)"\a"[(uint)local_5c * 8 + uVar10];
      local_5c = bVar12;
    }
  }
  if ((uVar11 & 8) != 0) {
    schar->attr = bVar1 | 8;
  }
  if (((int)(uVar11 & 7) >> 2 | (uVar11 & 7) * 2 & 7) < ((uVar6 >> 2 | uVar10 * 2) & 7)) {
    schar->attr = schar->attr | 0x40;
  }
  schar->color[0] = (byte)(uVar10 << 4) | local_5c;
switchD_080dafb8_caseD_ffffffff:
  return;
}



screen_char * get_char(terminal *term,int x,int y)

{
  screen_char *psVar1;
  int iVar2;
  int iVar3;
  
  if (assert_failed == 0) {
    if (((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) ||
       (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080db1b2;
    }
    else {
      assert_failed = 0;
    }
    iVar3 = 0;
    if ((-1 < x) && (iVar3 = term->width + -1, x <= iVar3)) {
      iVar3 = x;
    }
    iVar2 = 0;
    if (-1 < y) {
      iVar2 = term->height + -1;
      if (y <= iVar2) {
        iVar2 = y;
      }
      iVar2 = iVar2 * term->width;
    }
    psVar1 = term->screen->image + iVar2 + iVar3;
  }
  else {
LAB_080db1b2:
    assert_failed = 0;
    psVar1 = (screen_char *)0x0;
  }
  return psVar1;
}



void set_cursor(terminal *term,int x,int y,int blockable)

{
  terminal_screen *ptVar1;
  int *piVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if ((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 0x234;
    elinks_internal((uchar *)"assertion term && term->screen failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  if ((blockable == 0) || (piVar2 = get_opt_(term->spec,(uchar *)blockable), *piVar2 == 0)) {
    ptVar1 = term->screen;
    if (ptVar1->cx != x) goto LAB_080db2b6;
  }
  else {
    ptVar1 = term->screen;
    x = term->width + -1;
    y = term->height + -1;
    if (ptVar1->cx != x) {
LAB_080db2b6:
      iVar4 = ptVar1->cy;
      goto LAB_080db2b9;
    }
  }
  iVar4 = ptVar1->cy;
  if (iVar4 == y) {
    return;
  }
LAB_080db2b9:
  iVar3 = 0;
  if ((-1 < x) && (iVar3 = term->width + -1, x <= iVar3)) {
    iVar3 = x;
  }
  iVar5 = 0;
  if ((-1 < y) && (iVar5 = term->height + -1, y <= iVar5)) {
    iVar5 = y;
  }
  iVar6 = iVar4;
  if (iVar4 <= iVar5) {
    iVar6 = iVar5;
  }
  if (iVar5 <= iVar4) {
    iVar4 = iVar5;
  }
  if (iVar4 < ptVar1->dirty_from) {
    ptVar1->dirty_from = iVar4;
  }
  if (ptVar1->dirty_to < iVar6) {
    ptVar1->dirty_to = iVar6;
  }
  term->screen->cx = iVar3;
  term->screen->cy = iVar5;
  return;
}



void draw_box(terminal *term,box *box,uchar data,screen_char_attr attr,color_pair *color)

{
  int iVar1;
  uchar *name;
  terminal_screen *ptVar2;
  screen_char *psVar3;
  uchar *puVar4;
  color_mode *pcVar5;
  screen_char *__src;
  int iVar6;
  int iVar7;
  int iVar8;
  uchar *puVar9;
  screen_char *schar;
  
  iVar7 = box->y;
  iVar8 = box->x;
  if (assert_failed == 0) {
    if (((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) ||
       (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080db3d4;
    }
    else {
      assert_failed = 0;
    }
    iVar1 = term->width;
    iVar6 = 0;
    if ((-1 < iVar8) && (iVar6 = iVar1 + -1, iVar8 < iVar1 + -1)) {
      iVar6 = iVar8;
    }
    iVar8 = 0;
    if ((-1 < iVar7) && (iVar8 = term->height + -1, iVar7 < iVar8)) {
      iVar8 = iVar7;
    }
    __src = term->screen->image + iVar8 * iVar1 + iVar6;
    if (__src != (screen_char *)0x0) {
      iVar8 = term->height - box->y;
      name = (uchar *)box->width;
      iVar7 = box->height;
      if (iVar8 <= box->height) {
        iVar7 = iVar8;
      }
      puVar4 = (uchar *)(iVar1 - box->x);
      puVar9 = name;
      if ((int)puVar4 <= (int)name) {
        puVar9 = puVar4;
      }
      if ((0 < (int)puVar9) && (0 < iVar7)) {
        schar = __src + (int)(puVar9 + -1);
        schar->attr = (uchar)attr;
        schar->data = (uint)data;
        psVar3 = __src;
        if (color == (color_pair *)0x0) {
          *(undefined2 *)schar->color = 0;
        }
        else {
          pcVar5 = get_opt_(term->spec,name);
          set_term_color(schar,color,0,*pcVar5);
        }
        while (psVar3 < schar) {
          psVar3->data = schar->data;
          *(undefined4 *)&psVar3->attr = *(undefined4 *)&schar->attr;
          psVar3 = psVar3 + 1;
        }
        iVar7 = iVar7 + -1;
        if (iVar7 != 0) {
          schar = __src;
          do {
            schar = schar + term->width;
            memcpy(schar,__src,(int)puVar9 << 3);
            iVar7 = iVar7 + -1;
          } while (iVar7 != 0);
        }
        ptVar2 = term->screen;
        iVar7 = box->y;
        iVar8 = box->height + iVar7;
        if (iVar7 < ptVar2->dirty_from) {
          ptVar2->dirty_from = iVar7;
        }
        if (ptVar2->dirty_to < iVar8) {
          ptVar2->dirty_to = iVar8;
          return;
        }
      }
    }
  }
  else {
LAB_080db3d4:
    assert_failed = 0;
  }
  return;
}



void clear_terminal(terminal *term)

{
  box box;
  
  box.width = term->width;
  box.x = 0;
  if (box.width < 0) {
    box.width = 0;
  }
  box.height = 0;
  if (-1 < term->height) {
    box.height = term->height;
  }
  box.y = 0;
  draw_box(term,&box,' ',0,(color_pair *)0x0);
  set_cursor(term,0,0,1);
  return;
}



void draw_shadow(terminal *term,box *box,color_pair *color,int width,int height)

{
  box dbox;
  
  dbox.y = box->height + box->y;
  dbox.x = width + box->x;
  if (dbox.x < 0) {
    dbox.x = 0;
  }
  if (dbox.y < 0) {
    dbox.y = 0;
  }
  dbox.width = box->width - width;
  if (dbox.width < 0) {
    dbox.width = 0;
  }
  dbox.height = 0;
  if (-1 < height) {
    dbox.height = height;
  }
  draw_box(term,&dbox,' ',0,color);
  dbox.y = height + box->y;
  dbox.x = box->width + box->x;
  if (dbox.x < 0) {
    dbox.x = 0;
  }
  if (dbox.y < 0) {
    dbox.y = 0;
  }
  if (width < 0) {
    width = 0;
  }
  dbox.height = 0;
  if (-1 < box->height) {
    dbox.height = box->height;
  }
  dbox.width = width;
  draw_box(term,&dbox,' ',0,color);
  return;
}



void draw_char_data(terminal *term,int x,int y,unicode_val_T data)

{
  terminal_screen *ptVar1;
  int iVar2;
  screen_char *psVar3;
  int iVar4;
  
  if (assert_failed == 0) {
    if (((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) ||
       (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080db725;
    }
    else {
      assert_failed = 0;
    }
    iVar4 = 0;
    if ((-1 < x) && (iVar4 = term->width + -1, x <= iVar4)) {
      iVar4 = x;
    }
    iVar2 = 0;
    if (-1 < y) {
      iVar2 = term->height + -1;
      if (y <= iVar2) {
        iVar2 = y;
      }
      iVar2 = iVar2 * term->width;
    }
    psVar3 = term->screen->image + iVar2 + iVar4;
    if (psVar3 != (screen_char *)0x0) {
      psVar3->data = data;
      if (data == 0xfffffffd) {
        psVar3->attr = '\0';
      }
      ptVar1 = term->screen;
      if (y < ptVar1->dirty_from) {
        ptVar1->dirty_from = y;
      }
      if (ptVar1->dirty_to < y) {
        ptVar1->dirty_to = y;
      }
    }
  }
  else {
LAB_080db725:
    assert_failed = 0;
  }
  return;
}



void draw_char(terminal *term,int x,int y,unicode_val_T data,screen_char_attr attr,color_pair *color
              )

{
  terminal_screen *name;
  int iVar1;
  color_mode *pcVar2;
  int iVar3;
  screen_char *schar;
  
  if (assert_failed == 0) {
    if (((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) ||
       (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080db81c;
    }
    else {
      assert_failed = 0;
    }
    iVar3 = 0;
    if ((-1 < x) && (iVar3 = term->width + -1, x <= iVar3)) {
      iVar3 = x;
    }
    iVar1 = 0;
    if (-1 < y) {
      iVar1 = term->height + -1;
      if (y <= iVar1) {
        iVar1 = y;
      }
      iVar1 = iVar1 * term->width;
    }
    name = term->screen;
    schar = name->image + iVar1 + iVar3;
    if (schar != (screen_char *)0x0) {
      schar->data = data;
      schar->attr = (uchar)attr;
      pcVar2 = get_opt_(term->spec,(uchar *)name);
      set_term_color(schar,color,0,*pcVar2);
      name = term->screen;
      if (y < name->dirty_from) {
        name->dirty_from = y;
      }
      if (name->dirty_to < y) {
        name->dirty_to = y;
        return;
      }
    }
  }
  else {
LAB_080db81c:
    assert_failed = 0;
  }
  return;
}



void draw_line(terminal *term,int x,int y,int l,screen_char *line)

{
  screen_char *psVar1;
  terminal_screen *ptVar2;
  unicode_val_T uVar3;
  int iVar4;
  int iVar5;
  screen_char *__dest;
  
  if (assert_failed == 0) {
    if (((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) ||
       (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080dba88;
    }
    iVar5 = 0;
    if ((-1 < x) && (iVar5 = term->width + -1, x <= iVar5)) {
      iVar5 = x;
    }
    iVar4 = 0;
    if (-1 < y) {
      iVar4 = term->height + -1;
      if (y <= iVar4) {
        iVar4 = y;
      }
      iVar4 = iVar4 * term->width;
    }
    __dest = term->screen->image + iVar4 + iVar5;
  }
  else {
LAB_080dba88:
    __dest = (screen_char *)0x0;
  }
  assert_failed = ZEXT14(line == (screen_char *)0x0);
  if (line == (screen_char *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 0x97;
    elinks_internal((uchar *)"assertion line failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (__dest == (screen_char *)0x0) {
    return;
  }
  iVar5 = term->width - x;
  if (l <= iVar5) {
    iVar5 = l;
  }
  if (iVar5 == 0) {
    return;
  }
  if ((*(byte *)&term->field_0x38 & 2) == 0) {
    memcpy(__dest,line,iVar5 << 3);
  }
  else {
    if ((x == 0) && (line->data == 0xfffffffd)) {
      __dest->data = 0x20;
      iVar5 = iVar5 + -1;
      *(undefined4 *)&__dest->attr = *(undefined4 *)&line->attr;
      __dest = __dest + 1;
      line->data = 0xfffffffd;
      line = line + 1;
    }
    if (0 < iVar5 + -1) {
      psVar1 = line + iVar5 + -1;
      iVar4 = unicode_to_cell(psVar1->data);
      if (iVar4 == 2) {
        uVar3 = psVar1->data;
        psVar1->data = 0x20;
        memcpy(__dest,line,iVar5 << 3);
        psVar1->data = uVar3;
        goto LAB_080dba2a;
      }
    }
    memcpy(__dest,line,iVar5 << 3);
  }
LAB_080dba2a:
  ptVar2 = term->screen;
  if (y < ptVar2->dirty_from) {
    ptVar2->dirty_from = y;
  }
  if (ptVar2->dirty_to < y) {
    ptVar2->dirty_to = y;
  }
  return;
}



void draw_char_color(terminal *term,int x,int y,color_pair *color)

{
  terminal_screen *ptVar1;
  int iVar2;
  color_mode *pcVar3;
  int iVar4;
  screen_char *schar;
  
  if (assert_failed == 0) {
    if (((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) ||
       (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080dbb7c;
    }
    else {
      assert_failed = 0;
    }
    iVar4 = 0;
    if ((-1 < x) && (iVar4 = term->width + -1, x <= iVar4)) {
      iVar4 = x;
    }
    iVar2 = 0;
    if (-1 < y) {
      iVar2 = term->height + -1;
      if (y <= iVar2) {
        iVar2 = y;
      }
      iVar2 = iVar2 * term->width;
    }
    schar = term->screen->image + iVar2 + iVar4;
    if (schar != (screen_char *)0x0) {
      pcVar3 = get_opt_(term->spec,(uchar *)term->screen);
      set_term_color(schar,color,0,*pcVar3);
      ptVar1 = term->screen;
      if (y < ptVar1->dirty_from) {
        ptVar1->dirty_from = y;
      }
      if (ptVar1->dirty_to < y) {
        ptVar1->dirty_to = y;
        return;
      }
    }
  }
  else {
LAB_080dbb7c:
    assert_failed = 0;
  }
  return;
}



void draw_border_char(terminal *term,int x,int y,border_char border,color_pair *color)

{
  terminal_screen *name;
  int iVar1;
  color_mode *pcVar2;
  int iVar3;
  screen_char *schar;
  
  if (assert_failed == 0) {
    if (((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) ||
       (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080dbc9c;
    }
    else {
      assert_failed = 0;
    }
    iVar3 = 0;
    if ((-1 < x) && (iVar3 = term->width + -1, x <= iVar3)) {
      iVar3 = x;
    }
    iVar1 = 0;
    if (-1 < y) {
      iVar1 = term->height + -1;
      if (y <= iVar1) {
        iVar1 = y;
      }
      iVar1 = iVar1 * term->width;
    }
    name = term->screen;
    schar = name->image + iVar1 + iVar3;
    if (schar != (screen_char *)0x0) {
      schar->attr = -0x80;
      schar->data = border & 0xff;
      pcVar2 = get_opt_(term->spec,(uchar *)name);
      set_term_color(schar,color,0,*pcVar2);
      name = term->screen;
      if (y < name->dirty_from) {
        name->dirty_from = y;
      }
      if (name->dirty_to < y) {
        name->dirty_to = y;
        return;
      }
    }
  }
  else {
LAB_080dbc9c:
    assert_failed = 0;
  }
  return;
}



void draw_border(terminal *term,box *box,color_pair *color,int width)

{
  uchar data;
  int y;
  terminal_screen *ptVar1;
  border_char p2 [6];
  border_char p1 [6];
  int iVar2;
  int iVar3;
  int x;
  int x_00;
  int y_00;
  border_char *pbVar4;
  box bbox;
  
  pbVar4 = (border_char *)&ram0x0810d498;
  if (1 < width) {
    pbVar4 = (border_char *)&ram0x0810d480;
  }
  y = box->width;
  x = box->x;
  x_00 = x + -1;
  if (x_00 < 0) {
    x_00 = 0;
  }
  y_00 = box->y + -1;
  if (y_00 < 0) {
    y_00 = 0;
  }
  iVar2 = y + 2;
  if (iVar2 < 0) {
    iVar2 = 0;
  }
  iVar3 = box->height + 2;
  if (iVar3 < 0) {
    iVar3 = 0;
  }
  if (2 < iVar2) {
    bbox.height = 1;
    if (x < 0) {
      x = 0;
    }
    bbox.width = 0;
    if (-1 < y) {
      bbox.width = y;
    }
    data = *(uchar *)(pbVar4 + 5);
    bbox.x = x;
    bbox.y = y_00;
    draw_box(term,&bbox,data,SCREEN_ATTR_FRAME,color);
    bbox.y = iVar3 + -1 + bbox.y;
    draw_box(term,&bbox,data,SCREEN_ATTR_FRAME,color);
  }
  if (2 < iVar3) {
    bbox.y = box->y;
    bbox.width = 1;
    if (bbox.y < 0) {
      bbox.y = 0;
    }
    bbox.height = 0;
    if (-1 < box->height) {
      bbox.height = box->height;
    }
    data = *(uchar *)(pbVar4 + 4);
    bbox.x = x_00;
    draw_box(term,&bbox,data,SCREEN_ATTR_FRAME,color);
    bbox.x = iVar2 + -1 + bbox.x;
    draw_box(term,&bbox,data,SCREEN_ATTR_FRAME,color);
  }
  if ((1 < iVar2) && (1 < iVar3)) {
    x = iVar2 + -1 + x_00;
    y = y_00 + iVar3 + -1;
    draw_border_char(term,x_00,y_00,*pbVar4,color);
    draw_border_char(term,x,y_00,pbVar4[1],color);
    draw_border_char(term,x_00,y,pbVar4[2],color);
    draw_border_char(term,x,y,pbVar4[3],color);
  }
  ptVar1 = term->screen;
  if (ptVar1->dirty_from != y_00 && y_00 <= ptVar1->dirty_from) {
    ptVar1->dirty_from = y_00;
  }
  if (ptVar1->dirty_to < y_00 + iVar3) {
    ptVar1->dirty_to = y_00 + iVar3;
  }
  return;
}



void draw_border_cross(terminal *term,int x,int y,border_cross_direction dir,color_pair *color)

{
  uchar *name;
  uchar border_trans [2] [4];
  int iVar1;
  uint uVar2;
  color_mode *pcVar3;
  int iVar4;
  screen_char *schar;
  
  if (assert_failed == 0) {
    if (((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) ||
       (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080dc04b;
    }
    else {
      assert_failed = 0;
    }
    iVar4 = 0;
    if ((-1 < x) && (iVar4 = term->width + -1, x <= iVar4)) {
      iVar4 = x;
    }
    iVar1 = 0;
    if (-1 < y) {
      iVar1 = term->height + -1;
      if (y <= iVar1) {
        iVar1 = y;
      }
      iVar1 = iVar1 * term->width;
    }
    schar = term->screen->image + iVar1 + iVar4;
    if ((schar != (screen_char *)0x0) && ((char)schar->attr < '\0')) {
      name = (uchar *)schar->data;
      uVar2 = dir >> 1;
      if (name == (uchar *)(uint)((uchar *)&ram0x0810d4b0)[uVar2 * 4]) {
        schar->data = (uint)*(byte *)((dir & 1) + 0x810d4b1 + uVar2 * 4);
      }
      else {
        if (name == (uchar *)(uint)*(byte *)((uVar2 * 4 - (dir & 1)) + 0x810d4b2)) {
          schar->data = 0xc5;
        }
      }
      pcVar3 = get_opt_(term->spec,name);
      set_term_color(schar,color,0,*pcVar3);
      return;
    }
  }
  else {
LAB_080dc04b:
    assert_failed = 0;
  }
  return;
}



void draw_text(terminal *term,int x,int y,uchar *text,int length,screen_char_attr attr,
              color_pair *color)

{
  screen_char *schar;
  terminal_screen *ptVar1;
  byte bVar2;
  color_mode *pcVar3;
  unicode_val_T c;
  int iVar4;
  uint uVar5;
  int iVar6;
  screen_char *psVar7;
  int local_3c;
  screen_char *local_38;
  terminal_screen *local_34;
  screen_char *local_30;
  uchar *local_20 [4];
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  uVar5 = (uint)length >> 0x1f | (uint)(text == (uchar *)0x0);
  assert_failed = uVar5;
  if (uVar5 == 0) {
    if (term->width == x || term->width < x) {
      return;
    }
  }
  else {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 0x1f7;
    elinks_internal((uchar *)"assertion text && length >= 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
    if (term->width == x || term->width < x) {
      return;
    }
  }
  if (term->height == y || term->height < y) {
    return;
  }
  if ((*(byte *)&term->field_0x38 & 2) == 0) {
    if (length < 1) {
      return;
    }
    if ((term->screen == (terminal_screen *)0x0) || (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    else {
      assert_failed = 0;
    }
    iVar4 = term->width;
    local_3c = 0;
    if ((-1 < x) && (local_3c = iVar4 + -1, x <= local_3c)) {
      local_3c = x;
    }
    iVar6 = 0;
    if ((-1 < y) && (iVar6 = term->height + -1, y <= iVar6)) {
      iVar6 = y;
    }
    local_34 = term->screen;
    psVar7 = local_34->image + iVar4 * iVar6 + local_3c;
    if (psVar7 == (screen_char *)0x0) {
      return;
    }
    if (iVar4 - x < length) {
      length = iVar4 - x;
    }
    iVar4 = 0;
    if (-1 < length + -1) {
      iVar4 = length + -1;
    }
    schar = psVar7 + iVar4;
    if (color == (color_pair *)0x0) {
      if ((psVar7 <= schar) && (bVar2 = *text, bVar2 != 0)) {
        do {
          psVar7->data = (uint)bVar2;
          psVar7 = psVar7 + 1;
          if (schar < psVar7) break;
          text = text + 1;
          bVar2 = *text;
        } while (bVar2 != 0);
        local_34 = term->screen;
      }
    }
    else {
      schar->attr = (uchar)attr;
      pcVar3 = get_opt_(term->spec,(uchar *)term);
      set_term_color(schar,color,0,*pcVar3);
      if (psVar7 < schar) {
        bVar2 = *text;
        while (bVar2 != 0) {
          text = text + 1;
          schar->data = (uint)bVar2;
          psVar7->data = (uint)bVar2;
          *(undefined4 *)&psVar7->attr = *(undefined4 *)&schar->attr;
          psVar7 = psVar7 + 1;
          if (schar <= psVar7) goto LAB_080dc332;
          bVar2 = *text;
        }
        bVar2 = 0;
      }
      else {
LAB_080dc332:
        bVar2 = *text;
      }
      schar->data = (uint)bVar2;
      local_34 = term->screen;
    }
    if (y < local_34->dirty_from) {
      local_34->dirty_from = y;
    }
    if (y <= local_34->dirty_to) {
      return;
    }
    local_34->dirty_to = y;
    return;
  }
  local_20[0] = text;
  assert_failed = uVar5;
  if (uVar5 != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 0x1af;
    elinks_internal((uchar *)"assertion text && length >= 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (length < 1) {
    return;
  }
  if (term->width <= x) {
    return;
  }
  c = utf8_to_unicode(local_20,text + length);
  if (c == 0xfffffffd) {
    return;
  }
  if (assert_failed == 0) {
    if ((term->screen == (terminal_screen *)0x0) || (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080dc459;
    }
    else {
      assert_failed = 0;
    }
    local_38 = (screen_char *)0x0;
    if ((-1 < x) && (local_38 = (screen_char *)(term->width + -1), x <= (int)local_38)) {
      local_38 = (screen_char *)x;
    }
    iVar4 = 0;
    if (-1 < y) {
      iVar4 = term->height + -1;
      if (y <= iVar4) {
        iVar4 = y;
      }
      iVar4 = iVar4 * term->width;
    }
    local_30 = term->screen->image + iVar4 + (int)local_38;
    local_38 = local_30 + 1;
  }
  else {
LAB_080dc459:
    assert_failed = 0;
    local_38 = (screen_char *)&DAT_00000008;
    local_30 = (screen_char *)0x0;
  }
  if (color != (color_pair *)0x0) {
    local_30->attr = (uchar)attr;
    pcVar3 = get_opt_(term->spec,(uchar *)term);
    set_term_color(local_30,color,0,*pcVar3);
  }
  if ((local_30->data == 0xfffffffd) && (0 < x + -1)) {
    draw_char_data(term,x + -1,y,0x20);
  }
  iVar4 = unicode_to_cell(c);
  if (iVar4 == 2) {
    iVar4 = x + 1;
    if (iVar4 < term->width) {
      local_30->data = c;
      iVar4 = x + 2;
      local_38->data = 0xfffffffd;
      local_38->attr = '\0';
      local_38 = local_38 + 1;
    }
    else {
      local_30->data = 0x20;
    }
  }
  else {
    local_30->data = c;
    iVar4 = x + 1;
  }
  if (iVar4 < term->width) {
    while (c = utf8_to_unicode(local_20,text + length), c != 0xfffffffd) {
      if (color != (color_pair *)0x0) {
        local_38->data = local_30->data;
        *(undefined4 *)&local_38->attr = *(undefined4 *)&local_30->attr;
      }
      iVar6 = unicode_to_cell(c);
      if (iVar6 == 2) {
        iVar6 = iVar4 + 1;
        if (iVar6 < term->width) {
          local_38->data = c;
          iVar6 = iVar4 + 2;
          local_38[1].data = 0xfffffffd;
          local_38[1].attr = '\0';
          local_38 = local_38 + 1;
        }
        else {
          local_38->data = 0x20;
        }
      }
      else {
        local_38->data = c;
        iVar6 = iVar4 + 1;
      }
      if (term->width == iVar6 || term->width < iVar6) break;
      local_38 = local_38 + 1;
      iVar4 = iVar6;
    }
  }
  ptVar1 = term->screen;
  if (y < ptVar1->dirty_from) {
    ptVar1->dirty_from = y;
  }
  if (ptVar1->dirty_to < y) {
    ptVar1->dirty_to = y;
  }
  return;
}



void fix_dwchar_around_box(terminal *term,box *box,int border,int shadow_width,int shadow_height)

{
  int iVar1;
  int iVar2;
  screen_char *psVar3;
  int iVar4;
  int iVar5;
  
  if ((*(byte *)&term->field_0x38 & 2) == 0) {
    return;
  }
  iVar5 = box->x;
  iVar2 = iVar5 + -1;
  iVar4 = iVar2 - border;
  if (iVar4 < 1) {
LAB_080dc8f0:
    iVar4 = term->width;
    iVar2 = (shadow_width - border) + iVar2;
  }
  else {
    iVar2 = box->y;
    iVar5 = border * 2 + box->height;
    if (assert_failed == 0) {
      if ((term->screen == (terminal_screen *)0x0) || (term->screen->image == (screen_char *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
        errline = 0x27;
        elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
        if (assert_failed != 0) goto LAB_080dcb38;
      }
      else {
        assert_failed = 0;
      }
      iVar1 = 0;
      iVar2 = iVar2 - border;
      if (-1 < iVar2) {
        iVar1 = term->height + -1;
        if (iVar2 <= iVar1) {
          iVar1 = iVar2;
        }
        iVar1 = iVar1 * term->width;
      }
      iVar2 = term->width + -1;
      if (iVar2 < iVar4) {
        iVar4 = iVar2;
      }
      psVar3 = term->screen->image + iVar1 + iVar4;
    }
    else {
LAB_080dcb38:
      assert_failed = 0;
      psVar3 = (screen_char *)0x0;
    }
    if (iVar5 == 0) {
      iVar5 = box->x;
      iVar2 = iVar5 + -1;
      goto LAB_080dc8f0;
    }
    while( true ) {
      iVar5 = iVar5 + -1;
      iVar2 = unicode_to_cell(psVar3->data);
      if (iVar2 == 2) {
        psVar3->data = 0x20;
        iVar4 = term->width;
      }
      else {
        iVar4 = term->width;
      }
      if (iVar5 == 0) break;
      psVar3 = psVar3 + iVar4;
    }
    iVar5 = box->x;
    iVar2 = (shadow_width - border) + iVar5 + -1;
  }
  if (iVar2 < 1) {
    iVar5 = border + box->width + iVar5;
    if (iVar4 <= iVar5) goto LAB_080dc922;
LAB_080dc874:
    iVar2 = box->y;
    if (assert_failed == 0) {
      if ((term->screen == (terminal_screen *)0x0) || (term->screen->image == (screen_char *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
        errline = 0x27;
        elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
        if (assert_failed != 0) goto LAB_080dc884;
      }
      else {
        assert_failed = 0;
      }
      iVar4 = 0;
      if ((-1 < iVar5) && (iVar4 = term->width + -1, iVar5 <= iVar4)) {
        iVar4 = iVar5;
      }
      iVar5 = 0;
      iVar2 = iVar2 - border;
      if (-1 < iVar2) {
        iVar5 = term->height + -1;
        if (iVar2 <= iVar5) {
          iVar5 = iVar2;
        }
        iVar5 = iVar5 * term->width;
      }
      psVar3 = term->screen->image + iVar5 + iVar4;
    }
    else {
LAB_080dc884:
      assert_failed = 0;
      psVar3 = (screen_char *)0x0;
    }
    iVar2 = shadow_height;
    if (shadow_height == 0) {
      iVar4 = term->width;
      iVar5 = box->width + box->x + border;
      goto LAB_080dc922;
    }
    while( true ) {
      if (psVar3->data == 0xfffffffd) {
        psVar3->data = 0x20;
        iVar5 = term->width;
      }
      else {
        iVar5 = term->width;
      }
      if (iVar2 + -1 == 0) break;
      psVar3 = psVar3 + iVar5;
      iVar2 = iVar2 + -1;
    }
    shadow_width = box->width + box->x + border + shadow_width;
    if (iVar5 <= shadow_width) {
      return;
    }
  }
  else {
    if (iVar2 < iVar4) {
      iVar5 = box->y;
      iVar4 = box->height;
      if (assert_failed == 0) {
        if ((term->screen == (terminal_screen *)0x0) || (term->screen->image == (screen_char *)0x0))
        {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
          errline = 0x27;
          elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
          if (assert_failed != 0) goto LAB_080dc9e7;
        }
        else {
          assert_failed = 0;
        }
        iVar1 = 0;
        iVar5 = iVar4 + iVar5 + border;
        if (-1 < iVar5) {
          iVar1 = term->height + -1;
          if (iVar5 <= iVar1) {
            iVar1 = iVar5;
          }
          iVar1 = iVar1 * term->width;
        }
        iVar5 = term->width + -1;
        if (iVar2 <= iVar5) {
          iVar5 = iVar2;
        }
        psVar3 = term->screen->image + iVar1 + iVar5;
      }
      else {
LAB_080dc9e7:
        assert_failed = 0;
        psVar3 = (screen_char *)0x0;
      }
      iVar2 = shadow_height;
      if (shadow_height == 0) {
        iVar4 = term->width;
        iVar5 = box->x;
      }
      else {
        while( true ) {
          iVar5 = unicode_to_cell(psVar3->data);
          if (iVar5 == 2) {
            psVar3->data = 0x20;
            iVar4 = term->width;
          }
          else {
            iVar4 = term->width;
          }
          if (iVar2 + -1 == 0) break;
          psVar3 = psVar3 + iVar4;
          iVar2 = iVar2 + -1;
        }
        iVar5 = box->x;
      }
    }
    iVar5 = border + box->width + iVar5;
    if (iVar5 < iVar4) goto LAB_080dc874;
LAB_080dc922:
    shadow_width = iVar5 + shadow_width;
    if (iVar4 <= shadow_width) {
      return;
    }
  }
  iVar2 = box->y;
  iVar5 = border * 2 + box->height;
  if (assert_failed == 0) {
    if ((term->screen == (terminal_screen *)0x0) || (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080dcb88;
    }
    else {
      assert_failed = 0;
    }
    iVar4 = 0;
    if ((-1 < shadow_width) && (iVar4 = term->width + -1, shadow_width <= iVar4)) {
      iVar4 = shadow_width;
    }
    iVar1 = 0;
    shadow_height = (iVar2 - border) + shadow_height;
    if (-1 < shadow_height) {
      iVar1 = term->height + -1;
      if (shadow_height <= iVar1) {
        iVar1 = shadow_height;
      }
      iVar1 = iVar1 * term->width;
    }
    psVar3 = term->screen->image + iVar1 + iVar4;
  }
  else {
LAB_080dcb88:
    assert_failed = 0;
    psVar3 = (screen_char *)0x0;
  }
  if (iVar5 != 0) {
    while( true ) {
      iVar5 = iVar5 + -1;
      if (psVar3->data == 0xfffffffd) {
        psVar3->data = 0x20;
      }
      if (iVar5 == 0) break;
      psVar3 = psVar3 + term->width;
    }
  }
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void term_send_event(terminal *term,term_event *ev)

{
  int height;
  int width;
  term_event_type tVar1;
  list_head_elinks *plVar2;
  uint uVar3;
  window *pwVar4;
  uchar *fmt;
  window *pwVar5;
  bool bVar6;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(ev == (term_event *)0x0 || term == (terminal *)0x0);
  if (ev == (term_event *)0x0 || term == (terminal *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
    errline = 0x44;
    elinks_internal((uchar *)"assertion ev && term failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
    tVar1 = ev->ev;
  }
  else {
    tVar1 = ev->ev;
  }
  if (EVENT_ABORT < tVar1) {
    return;
  }
  uVar3 = 1 << ((byte)ev->ev & 0x1f);
  if ((uVar3 & 0x26) != 0) {
    bVar6 = (list_head_elinks *)(term->windows).next == &term->windows;
    assert_failed = ZEXT14(bVar6);
    if (bVar6) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
      errline = 0x79;
      elinks_internal((uchar *)"assertion !list_empty(term->windows) failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    pwVar5 = (window *)(term->windows).next;
    if (pwVar5->type == WINDOW_TAB) {
      pwVar5 = get_tab_by_number(term,term->current_tab);
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
      assert_failed = ZEXT14(pwVar5 == (window *)0x0);
      if (pwVar5 == (window *)0x0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
        errline = 0x81;
        elinks_internal((uchar *)"assertion win != NULL failed: No tab to send the event to!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
      }
    }
                    // WARNING: Could not recover jumptable at 0x080dce06. Too many branches
                    // WARNING: Treating indirect jump as call
    (*pwVar5->handler)();
    return;
  }
  if ((uVar3 & 0x11) == 0) {
    if ((uVar3 & 8) == 0) {
      return;
    }
  }
  else {
    height = *(int *)((int)&ev->info + 4);
    width = *(int *)&ev->info;
    if ((height < 0) || (width < 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
      errline = 0x4f;
      fmt = gettext((uchar *)"Bad terminal size: %d, %d");
      elinks_error(fmt,width,height);
      return;
    }
    resize_screen(term,width,height);
    erase_screen(term);
  }
  if (term->screen->image != (screen_char *)0x0) {
    clear_terminal(term);
    term->redrawing = TREDRAW_DELAYED;
    if (ev->ev == EVENT_RESIZE) {
      plVar2 = (list_head_elinks *)(term->windows).prev;
      while (&term->windows != plVar2) {
        (*(code *)plVar2[1].prev)(plVar2,ev);
        plVar2 = (list_head_elinks *)plVar2->prev;
      }
    }
    else {
      pwVar5 = (window *)(term->windows).prev;
      while (pwVar5 != (window *)&term->windows) {
        while ((pwVar5->type == WINDOW_NORMAL ||
               (pwVar4 = get_tab_by_number(pwVar5->term,pwVar5->term->current_tab), pwVar4 == pwVar5
               ))) {
          (*pwVar5->handler)(pwVar5,ev);
          pwVar5 = pwVar5->prev;
          if (pwVar5 == (window *)&term->windows) goto LAB_080dcd47;
        }
        pwVar5 = pwVar5->prev;
      }
    }
LAB_080dcd47:
    term->redrawing = TREDRAW_READY;
  }
  return;
}



void __regparm3 term_send_ucs(terminal *term,unicode_val_T u,term_event_modifier_T modifier)

{
  term_event ev;
  
  ev.info._8_4_ = 0;
  ev.ev = EVENT_KBD;
  ev.info._0_4_ = u;
  ev.info._4_4_ = modifier;
  term_send_event(term,&ev);
  return;
}



void in_term(terminal *term)

{
  terminal_info *info;
  uint uVar1;
  object *poVar2;
  uchar uVar3;
  undefined2 uVar4;
  int iVar5;
  int __fd;
  terminal_interlink *ptVar6;
  term_event_modifier_T modifier;
  byte bVar7;
  size_t size;
  ssize_t sVar8;
  int *piVar9;
  char *pcVar10;
  uchar *fmt;
  unicode_val_T *puVar11;
  term_event_type tVar12;
  option_elinks *poVar13;
  uint uVar14;
  int from;
  unicode_val_T u;
  terminal_interlink *p;
  uint uVar15;
  size_t __nbytes;
  terminal_info *ptVar16;
  unicode_val_T *puVar17;
  unicode_val_T *puVar18;
  unicode_val_T *puVar19;
  int in_GS_OFFSET;
  bool bVar20;
  byte bVar21;
  term_event tev;
  uchar name [42];
  
  bVar21 = 0;
  uVar15 = 0x100;
  iVar5 = *(int *)(in_GS_OFFSET + 0x14);
  p = term->interlink;
  size = 0x11c;
  if (p == (terminal_interlink *)0x0) {
LAB_080dcf8a:
    p = (terminal_interlink *)mem_realloc(p,size);
    if (p == (terminal_interlink *)0x0) {
switchD_080dd16c_caseD_5:
      destroy_terminal(term);
      goto LAB_080dd058;
    }
    if (term->interlink == (terminal_interlink *)0x0) {
      uVar14 = 0;
      do {
        *(undefined4 *)((int)&p->qlen + uVar14) = 0;
        uVar14 = uVar14 + 4;
      } while (uVar14 < 0x1c);
    }
    term->interlink = p;
    from = p->qlen;
    __nbytes = uVar15 - from;
    p->qfreespace = __nbytes;
  }
  else {
    __nbytes = p->qfreespace;
    if (__nbytes == 0) {
      from = p->qlen;
LAB_080dcf7b:
      uVar15 = from + 0x100U & 0xffffff00;
      size = uVar15 + 0x1c;
      goto LAB_080dcf8a;
    }
    from = p->qlen;
    if (0x100 < (int)(__nbytes - from)) goto LAB_080dcf7b;
  }
  info = (terminal_info *)p->input_queue;
  __fd = term->fdin;
  do {
    sVar8 = read(__fd,p->input_queue + from,__nbytes);
    if (sVar8 != -1) {
      if (sVar8 < 1) goto LAB_080dd048;
      p->qfreespace = p->qfreespace - sVar8;
      uVar15 = p->qlen + sVar8;
      p->qlen = uVar15;
      if (uVar15 < 0x10) goto LAB_080dd058;
      puVar18 = &p[2].utf8.min;
      puVar11 = (unicode_val_T *)term->cwd;
      goto LAB_080dd159;
    }
    piVar9 = __errno_location();
  } while (*piVar9 == 4);
  if (*piVar9 != 0x68) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
    errline = 0x1e3;
    pcVar10 = strerror(*piVar9);
    from = *piVar9;
    fmt = gettext((uchar *)"Could not read event: %d (%s)");
    elinks_error(fmt,from,pcVar10);
  }
LAB_080dd048:
  destroy_terminal(term);
LAB_080dd058:
  if (iVar5 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_080dd159:
  ptVar6 = term->interlink;
  tVar12 = (info->event).ev;
  switch(tVar12) {
  case EVENT_INIT:
    if ((0x13f < (uint)ptVar6->qlen) && (*(int *)p[0xb].input_queue + 0x140U <= (uint)ptVar6->qlen))
    {
      uVar3 = *(uchar *)&p[1].utf8.len;
      *(undefined *)((int)&p[2].utf8.len + 3) = 0;
      ptVar16 = info;
      while (uVar3 != '\0') {
        if ((((0x19 < (byte)(uVar3 + 0x9f)) && (0x19 < (byte)(uVar3 + 0xbf))) &&
            (9 < (byte)(uVar3 - 0x30))) && ((uVar3 != '_' && (uVar3 != '-')))) {
          from = get_terminal_codepage(term);
          if (from != current_charset) {
            fmt = get_cp_mime_name(from);
            bind_textdomain_codeset("elinks",fmt);
            current_charset = from;
          }
          fmt = gettext((uchar *)"Warning: terminal name contains illicit chars.");
          usrerror(fmt);
          goto LAB_080dd3ac;
        }
        uVar3 = ptVar16->name[1];
        ptVar16 = (terminal_info *)((int)&(ptVar16->event).ev + 1);
      }
      __snprintf_chk(name,0x2a,1,0x2a,"terminal.%s",&p[1].utf8.len);
      poVar2 = &term->spec->object;
      poVar2->refcount = poVar2->refcount + -1;
      poVar13 = get_opt_rec(config_options,name);
      term->spec = poVar13;
      (poVar13->object).refcount = (poVar13->object).refcount + 1;
      from = get_terminal_codepage(term);
      uVar15 = is_cp_utf8(from);
      fmt = (uchar *)((uVar15 & 1) * 2);
      bVar7 = *(byte *)&term->field_0x38 & 0xfd | (byte)fmt;
      *(byte *)&term->field_0x38 = bVar7;
      if (((uint)fmt & 2) == 0) {
        piVar9 = get_opt_(term->spec,fmt);
        if (*piVar9 != 0) {
          bVar7 = *(byte *)&term->field_0x38;
          goto LAB_080dd6c7;
        }
        from = 0;
        bVar7 = *(byte *)&term->field_0x38;
      }
      else {
LAB_080dd6c7:
        from = 1;
      }
      *(byte *)&term->field_0x38 = bVar7 & 0xfb | (byte)(from << 2);
LAB_080dd3ac:
      uVar15 = 0x100;
      bVar20 = ((uint)puVar11 & 1) != 0;
      puVar17 = puVar18;
      puVar19 = puVar11;
      if (bVar20) {
        uVar15 = 0xff;
        *(undefined *)puVar11 = *(undefined *)puVar18;
        puVar17 = (unicode_val_T *)((int)&p[2].utf8.min + 1);
        puVar19 = (unicode_val_T *)(term->cwd + 1);
      }
      if (((uint)puVar19 & 2) != 0) {
        uVar4 = *(undefined2 *)puVar17;
        uVar15 = uVar15 - 2;
        puVar17 = (unicode_val_T *)((int)puVar17 + 2);
        *(undefined2 *)puVar19 = uVar4;
        puVar19 = (unicode_val_T *)((int)puVar19 + 2);
      }
      from = 0;
      uVar14 = uVar15 >> 2;
      while (uVar14 != 0) {
        uVar14 = uVar14 - 1;
        *puVar19 = *puVar17;
        puVar17 = puVar17 + (uint)bVar21 * 0x3ffffffe + 1;
        puVar19 = puVar19 + (uint)bVar21 * 0x3ffffffe + 1;
      }
      if ((uVar15 & 2) != 0) {
        *(undefined2 *)puVar19 = *(undefined2 *)puVar17;
        from = 2;
      }
      if (bVar20) {
        *(undefined *)((int)puVar19 + from) = *(undefined *)((int)puVar17 + from);
      }
      term->cwd[0xff] = '\0';
      term->environment = p[0xb].utf8.modifier;
      tev.info._4_4_ = p[1].qfreespace;
      tev.info._0_4_ = p[1].qlen;
      tev.info._8_4_ = 0;
      tev.ev = EVENT_INIT;
      term_send_event(term,&tev);
      from = decode_session_info(term,info);
      if (from != 0) {
        (info->event).ev = EVENT_REDRAW;
        tVar12 = EVENT_REDRAW;
        ptVar16 = info;
        goto LAB_080dd17a;
      }
      destroy_terminal(term);
      if (program.terminate != 0) {
        from = get_terminal_codepage(term);
        if (from != current_charset) {
          fmt = get_cp_mime_name(from);
          bind_textdomain_codeset("elinks",fmt);
          current_charset = from;
        }
        fmt = gettext((uchar *)"Failed to create session.");
        usrerror(fmt);
        program.retval = RET_FATAL;
      }
    }
    goto LAB_080dd058;
  case EVENT_KBD:
    uVar15 = p[1].qlen;
    modifier = p[1].qfreespace;
    if (0xff < (int)uVar15) {
      uVar15 = -uVar15;
    }
    reset_timer();
    if ((modifier == KBD_MOD_CTRL) && ((uVar15 == 0x4c || (uVar15 == 0x6c)))) {
      redraw_terminal_cls(term);
    }
    else {
      if (uVar15 == 0xfffffe00) {
        destroy_terminal(term);
        goto LAB_080dd058;
      }
      bVar7 = *(byte *)&term->field_0x38 >> 2;
      if ((ptVar6->utf8).len != 0) {
        if ((uVar15 - 0x80 < 0x40) && ((bVar7 & 1) != 0)) {
          uVar14 = (ptVar6->utf8).ucs << 6;
          u = uVar15 & 0x3f | uVar14;
          (ptVar6->utf8).ucs = u;
          from = (ptVar6->utf8).len + -1;
          (ptVar6->utf8).len = from;
          if (from == 0) {
            if ((u < (ptVar6->utf8).min) || ((uVar14 & 0xfffff800) == 0xd800)) {
              u = 0xfffd;
            }
            term_send_ucs(term,u,(term->interlink->utf8).modifier);
          }
          break;
        }
        (ptVar6->utf8).len = 0;
        term_send_ucs(term,0xfffd,(term->interlink->utf8).modifier);
      }
      bVar20 = (bVar7 & 1) != 0;
      if (((int)uVar15 < 0x80) || (!bVar20)) {
        if (((int)uVar15 < 0) || (bVar20)) {
          tev.info._8_4_ = 0;
          tev.ev = EVENT_KBD;
          tev.info._0_4_ = uVar15;
          tev.info._4_4_ = modifier;
          term_send_event(term,&tev);
        }
        else {
          from = get_terminal_codepage(term);
          u = cp2u(from,(uchar)uVar15);
          term_send_ucs(term,u,modifier);
        }
      }
      else {
        if (((uVar15 & 0xc0) == 0xc0) && ((uVar15 & 0xfe) != 0xfe)) {
          from = 0;
          uVar14 = 0x80;
          if ((char)(uchar)uVar15 < '\0') {
            do {
              uVar14 = uVar14 >> 1;
              from = from + 1;
            } while ((uVar14 & uVar15) != 0);
          }
          if (assert_failed == 0) {
            uVar1 = from - 2;
            assert_failed = ZEXT14(4 < uVar1);
            if (4 < uVar1) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
              errline = 0x1a7;
              elinks_internal((uchar *)"assertion len >= 2 && len <= 6 failed!");
              if (assert_failed != 0) goto LAB_080dd5c1;
            }
            (ptVar6->utf8).len = from + -1;
            (ptVar6->utf8).ucs = uVar14 - 1 & uVar15;
            (ptVar6->utf8).min = min[uVar1];
            (ptVar6->utf8).modifier = modifier;
            break;
          }
LAB_080dd5c1:
          assert_failed = 0;
        }
        term_send_ucs(term,0xfffd,modifier);
      }
    }
    break;
  case EVENT_MOUSE:
    reset_timer();
    tev.ev = (info->event).ev;
    tev.info._0_4_ = p[1].qlen;
    tev.info._4_4_ = p[1].qfreespace;
    tev.info._8_4_ = p[1].utf8.ucs;
    if ((((tev.info._8_4_ & 0x20) == 0) || (tev.info._4_4_ != (term->prev_mouse_event).y)) ||
       (((tev.info._8_4_ ^ (term->prev_mouse_event).button) & 0xffffffdf) != 0)) {
      (term->prev_mouse_event).x = (uint)tev.info;
      (term->prev_mouse_event).y = tev.info._4_4_;
      (term->prev_mouse_event).button = tev.info._8_4_;
      term_send_event(term,&tev);
    }
    else {
      (term->prev_mouse_event).x = 0;
      (term->prev_mouse_event).y = 0;
      (term->prev_mouse_event).button = 0;
    }
    break;
  case EVENT_REDRAW:
  case EVENT_RESIZE:
    ptVar16 = (terminal_info *)0x0;
LAB_080dd17a:
    tev.info._4_4_ = p[1].qfreespace;
    tev.info._0_4_ = p[1].qlen;
    tev.info._8_4_ = 0;
    tev.ev = tVar12;
    term_send_event(term,&tev);
    if (ptVar16 == (terminal_info *)0x0) break;
    from = ptVar16->length + 0x140;
    if (from != 0) goto LAB_080dd128;
    goto LAB_080dd058;
  case EVENT_ABORT:
    goto switchD_080dd16c_caseD_5;
  default:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
    errline = 0x1bb;
    tVar12 = (info->event).ev;
    fmt = gettext((uchar *)"Bad event %d");
    elinks_error(fmt,tVar12);
  }
  from = 0x10;
LAB_080dd128:
  p->qfreespace = p->qfreespace + from;
  __nbytes = p->qlen - from;
  p->qlen = __nbytes;
  if ((__nbytes == 0) || (memmove(info,p->input_queue + from,__nbytes), (uint)p->qlen < 0x10))
  goto LAB_080dd058;
  goto LAB_080dd159;
}



ssize_t hard_read(int fd,uchar *data,size_t datalen)

{
  ssize_t sVar1;
  int *piVar2;
  size_t __nbytes;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return -1;
  }
  assert_failed = ZEXT14(data == (uchar *)0x0);
  if (data == (uchar *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/hardio.c";
    errline = 0x84;
    elinks_internal((uchar *)"assertion data && datalen >= 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return -1;
    }
  }
  __nbytes = datalen;
  if (datalen != 0) {
    while( true ) {
      while (sVar1 = read(fd,data,__nbytes), sVar1 == -1) {
        piVar2 = __errno_location();
        if (*piVar2 != 4) {
          return -1;
        }
      }
      if (sVar1 < 1) break;
      __nbytes = __nbytes - sVar1;
      if (__nbytes == 0) goto LAB_080dd888;
      data = data + sVar1;
    }
    if (sVar1 != 0) {
      return -1;
    }
  }
LAB_080dd888:
  return datalen - __nbytes;
}



ssize_t hard_write(int fd,uchar *data,size_t datalen)

{
  ssize_t sVar1;
  int *piVar2;
  size_t __n;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return -1;
  }
  assert_failed = ZEXT14(data == (uchar *)0x0);
  if (data == (uchar *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/hardio.c";
    errline = 0x66;
    elinks_internal((uchar *)"assertion data && datalen >= 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return -1;
    }
  }
  __n = datalen;
  if (datalen != 0) {
    while( true ) {
      while (sVar1 = write(fd,data,__n), sVar1 == -1) {
        piVar2 = __errno_location();
        if (*piVar2 != 4) {
          return -1;
        }
      }
      if (sVar1 < 1) break;
      __n = __n - sVar1;
      if (__n == 0) goto LAB_080dd968;
      data = data + sVar1;
    }
    if (sVar1 != 0) {
      return -1;
    }
  }
LAB_080dd968:
  return datalen - __n;
}



int is_blocked(void)

{
  uint uVar1;
  
  uVar1 = 0;
  if (ditrm != (itrm *)0x0) {
    uVar1 = (uint)*(byte *)&ditrm->field_0x74 & 1;
  }
  return uVar1;
}



void __regparm3 send_done_sequence(int h,int altscreen)

{
  hard_write(h,"\x1b[2J",4);
  send_mouse_done_sequence(h);
  if (altscreen != 0) {
    hard_write(h,"\x1b[?47l",6);
  }
  hard_write(h,"\x1b8\r \b",5);
  return;
}



void __regparm3 unhandle_itrm_stdin(itrm *itrm)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = -((itrm->in).std >> 0x1f);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
    errline = 0x4d5;
    elinks_internal((uchar *)"assertion itrm->in.std >= 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  set_handlers((itrm->in).std,(select_handler_T *)0x0,(select_handler_T *)0x0,free_itrm,itrm);
  return;
}



void block_itrm(void)

{
  if (ditrm != (itrm *)0x0) {
    *(byte *)&ditrm->field_0x74 = *(byte *)&ditrm->field_0x74 | 1;
    block_stdin();
    kill_timer(&ditrm->timer);
    (ditrm->in).queue.len = 0;
    unhandle_terminal_resize((ditrm->in).ctl);
    send_done_sequence((ditrm->out).std,(uint)(*(byte *)&ditrm->field_0x74 >> 1) & 1);
    tcsetattr((ditrm->in).ctl,0,(termios *)&ditrm->t);
    unhandle_itrm_stdin(ditrm);
    suspend_mouse(ditrm->mouse_h);
  }
  return;
}



void __regparm3 handle_itrm_stdin(itrm *itrm)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = -((itrm->in).std >> 0x1f);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
    errline = 0x4c8;
    elinks_internal((uchar *)"assertion itrm->in.std >= 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  set_handlers((itrm->in).std,in_kbd,(select_handler_T *)0x0,free_itrm,itrm);
  return;
}



void __regparm3 set_kbd_interlink_event(interlink_event *ev,int key,term_event_modifier_T modifier)

{
  if (key < -0xff) {
    key = -key;
  }
  *(undefined4 *)((int)&ev->info + 8) = 0;
  ev->ev = EVENT_KBD;
  *(int *)&ev->info = key;
  *(term_event_modifier_T *)((int)&ev->info + 4) = modifier;
  return;
}



void __regparm3 send_init_sequence(int h,int altscreen)

{
  hard_write(h,"\x1b)0\x1b7",5);
  if (altscreen != 0) {
    hard_write(h,"\x1b[?47h",6);
  }
  send_mouse_init_sequence(h);
  return;
}



void get_terminal_name(uchar *name)

{
  uchar *puVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  uchar uVar5;
  undefined2 *puVar6;
  int iVar7;
  bool bVar8;
  
  puVar1 = (uchar *)getenv("TERM");
  uVar3 = 0x20;
  bVar8 = ((uint)name & 1) != 0;
  if (bVar8) {
    uVar3 = 0x1f;
    uVar2 = (uint)(name + 1) & 2;
    *name = '\0';
    puVar6 = (undefined2 *)(name + 1);
  }
  else {
    uVar2 = (uint)name & 2;
    puVar6 = (undefined2 *)name;
  }
  if (uVar2 != 0) {
    *puVar6 = 0;
    uVar3 = uVar3 - 2;
    puVar6 = puVar6 + 1;
  }
  uVar2 = 0;
  do {
    *(undefined4 *)((int)puVar6 + uVar2) = 0;
    uVar2 = uVar2 + 4;
  } while (uVar2 < (uVar3 & 0xfffffffc));
  puVar6 = (undefined2 *)((int)puVar6 + uVar2);
  if ((uVar3 & 2) != 0) {
    *puVar6 = 0;
    puVar6 = puVar6 + 1;
  }
  if (bVar8) {
    *(undefined *)puVar6 = 0;
  }
  if ((puVar1 != (uchar *)0x0) && (uVar5 = *puVar1, uVar5 != '\0')) {
    iVar7 = 0;
    do {
      if ((((0x19 < (byte)(uVar5 + 0x9f)) && (0x19 < (byte)(uVar5 + 0xbf))) &&
          (9 < (byte)(uVar5 - 0x30))) && (uVar5 != '_')) {
        uVar5 = '-';
      }
      iVar4 = iVar7 + 1;
      name[iVar7] = uVar5;
      uVar5 = puVar1[iVar4];
    } while ((iVar4 < 0x1f) && (iVar7 = iVar4, uVar5 != '\0'));
  }
  return;
}



void free_itrm(itrm *itrm)

{
  int iVar1;
  uchar *title_00;
  int codepage;
  int in_GS_OFFSET;
  uchar title [32];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (itrm == (itrm *)0x0) goto LAB_080ddf01;
  if ((*(byte *)&itrm->field_0x74 & 8) == 0) {
    title_00 = itrm->orig_title;
    if ((title_00 == (uchar *)0x0) || (*title_00 == '\0')) {
      if ((*(byte *)&itrm->field_0x74 & 4) != 0) {
        get_terminal_name(title);
        if (title[0] != '\0') {
          codepage = get_cp_index("US-ASCII");
          set_window_title(title,codepage);
        }
      }
    }
    else {
      set_window_title(title_00,itrm->title_codepage);
    }
    unhandle_terminal_resize((itrm->in).ctl);
    disable_mouse();
    send_done_sequence((itrm->out).std,(uint)(*(byte *)&itrm->field_0x74 >> 1) & 1);
    tcsetattr((itrm->in).ctl,0,(termios *)&itrm->t);
  }
  if (itrm->orig_title != (uchar *)0x0) {
    mem_free(itrm->orig_title);
  }
  itrm->orig_title = (uchar *)0x0;
  if ((*(byte *)&itrm->field_0x74 & 8) == 0) {
    codepage = (itrm->in).std;
LAB_080dde1f:
    set_handlers(codepage,(select_handler_T *)0x0,(select_handler_T *)0x0,(select_handler_T *)0x0,
                 (void *)0x0);
  }
  else {
    codepage = (itrm->in).std;
    if (-1 < codepage) goto LAB_080dde1f;
  }
  set_handlers((itrm->in).sock,(select_handler_T *)0x0,(select_handler_T *)0x0,
               (select_handler_T *)0x0,(void *)0x0);
  set_handlers((itrm->out).std,(select_handler_T *)0x0,(select_handler_T *)0x0,
               (select_handler_T *)0x0,(void *)0x0);
  set_handlers((itrm->out).sock,(select_handler_T *)0x0,(select_handler_T *)0x0,
               (select_handler_T *)0x0,(void *)0x0);
  kill_timer(&itrm->timer);
  if (itrm == ditrm) {
    ditrm = (itrm *)0x0;
  }
  title_00 = (itrm->out).queue.data;
  if (title_00 != (uchar *)0x0) {
    mem_free(title_00);
  }
  title_00 = (itrm->in).queue.data;
  if (title_00 != (uchar *)0x0) {
    mem_free(title_00);
  }
  mem_free(itrm);
LAB_080ddf01:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void free_all_itrms(void)

{
  if (ditrm != (itrm *)0x0) {
    free_itrm(ditrm);
  }
  return;
}



void itrm_queue_event(itrm *itrm,uchar *data,int len)

{
  int *piVar1;
  uchar *puVar2;
  select_handler_T *read_func;
  int iVar3;
  size_t __n;
  ssize_t sVar4;
  
  if (len == 0) {
    return;
  }
  if (((itrm->out).queue.len == 0) && (iVar3 = can_write((itrm->out).sock), iVar3 != 0)) {
    sVar4 = write((itrm->out).sock,data,len);
    if (sVar4 < 1) {
      register_bottom_half_do(free_itrm,itrm);
      return;
    }
  }
  else {
    sVar4 = 0;
  }
  if (sVar4 < len) {
    __n = len - sVar4;
    puVar2 = (uchar *)mem_realloc((itrm->out).queue.data,(itrm->out).queue.len + __n);
    if (puVar2 == (uchar *)0x0) {
      free_itrm(itrm);
      return;
    }
    (itrm->out).queue.data = puVar2;
    memcpy(puVar2 + (itrm->out).queue.len,data + sVar4,__n);
    piVar1 = &(itrm->out).queue.len;
    *piVar1 = *piVar1 + __n;
    read_func = get_handler((itrm->out).sock,SELECT_HANDLER_READ);
    set_handlers((itrm->out).sock,read_func,itrm_queue_write,free_itrm,itrm);
  }
  return;
}



void itrm_queue_write(itrm *itrm)

{
  uchar *__dest;
  ssize_t sVar1;
  select_handler_T *data;
  select_handler_T *error_func;
  select_handler_T *read_func;
  size_t __n;
  
  __n = (itrm->out).queue.len;
  if (0x7f < (int)__n) {
    __n = 0x80;
  }
  if (assert_failed == 0) {
    assert_failed = ZEXT14(__n == 0);
    if (__n == 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
      errline = 0x55;
      elinks_internal((uchar *)"assertion qlen failed: event queue empty");
      if (assert_failed != 0) goto LAB_080de1ae;
    }
    sVar1 = write((itrm->out).sock,(itrm->out).queue.data,__n);
    if (sVar1 < 1) {
      if (sVar1 != 0) {
        free_itrm(itrm);
        return;
      }
    }
    else {
      __n = (itrm->out).queue.len - sVar1;
      (itrm->out).queue.len = __n;
      if (__n == 0) {
        data = get_handler((itrm->out).sock,SELECT_HANDLER_DATA);
        error_func = get_handler((itrm->out).sock,SELECT_HANDLER_ERROR);
        read_func = get_handler((itrm->out).sock,SELECT_HANDLER_READ);
        set_handlers((itrm->out).sock,read_func,(select_handler_T *)0x0,error_func,data);
      }
      else {
        if (assert_failed == 0) {
          assert_failed = ZEXT14((int)__n < 1);
          if ((int)__n < 1) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
            errline = 0x67;
            elinks_internal((uchar *)"assertion itrm->out.queue.len > 0 failed!");
            __n = (itrm->out).queue.len;
          }
          else {
            __n = (itrm->out).queue.len;
          }
        }
        __dest = (itrm->out).queue.data;
        memmove(__dest,__dest + sVar1,__n);
      }
    }
  }
  else {
LAB_080de1ae:
    assert_failed = 0;
  }
  return;
}



int __regparm3 setraw(itrm *itrm,int save_orig)

{
  int iVar1;
  int iVar2;
  termios *ptVar3;
  int in_GS_OFFSET;
  termios t;
  int local_20;
  
  iVar2 = 0xf;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  ptVar3 = &t;
  while (iVar2 != 0) {
    iVar2 = iVar2 + -1;
    ptVar3->c_iflag = 0;
    ptVar3 = (termios *)&ptVar3->c_oflag;
  }
  iVar2 = tcgetattr((itrm->in).ctl,(termios *)&t);
  if (iVar2 == 0) {
    if (save_orig != 0) {
      (itrm->t).c_iflag = t.c_iflag;
      (itrm->t).c_oflag = t.c_oflag;
      (itrm->t).c_cflag = t.c_cflag;
      (itrm->t).c_lflag = t.c_lflag;
      *(undefined4 *)&(itrm->t).c_line = t._16_4_;
      *(undefined4 *)((itrm->t).c_cc + 3) = t.c_cc._3_4_;
      *(undefined4 *)((itrm->t).c_cc + 7) = t.c_cc._7_4_;
      *(undefined4 *)((itrm->t).c_cc + 0xb) = t.c_cc._11_4_;
      *(undefined4 *)((itrm->t).c_cc + 0xf) = t.c_cc._15_4_;
      *(undefined4 *)((itrm->t).c_cc + 0x13) = t.c_cc._19_4_;
      *(undefined4 *)((itrm->t).c_cc + 0x17) = t.c_cc._23_4_;
      *(undefined4 *)((itrm->t).c_cc + 0x1b) = t.c_cc._27_4_;
      *(undefined4 *)((itrm->t).c_cc + 0x1f) = t._48_4_;
      (itrm->t).c_ispeed = t.c_ispeed;
      (itrm->t).c_ospeed = t.c_ospeed;
    }
    if (t.c_cc[2] == '\0') {
      itrm->verase = -1;
    }
    else {
      itrm->verase = (uint)t.c_cc[2];
    }
    elinks_cfmakeraw(&t);
    t.c_lflag = t.c_lflag | 0x101;
    t.c_oflag = t.c_oflag | 1;
    iVar1 = tcsetattr((itrm->in).ctl,0,(termios *)&t);
    iVar2 = 0;
    if (iVar1 == 0) goto LAB_080de2c3;
  }
  iVar2 = -1;
LAB_080de2c3:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int unblock_itrm(void)

{
  int iVar1;
  
  if ((ditrm != (itrm *)0x0) && (((ditrm->in).ctl < 0 || (iVar1 = setraw(ditrm,0), iVar1 == 0)))) {
    *(byte *)&ditrm->field_0x74 = *(byte *)&ditrm->field_0x74 & 0xfe;
    send_init_sequence((ditrm->out).std,(uint)(*(byte *)&ditrm->field_0x74 >> 1) & 1);
    handle_itrm_stdin(ditrm);
    resume_mouse(ditrm->mouse_h);
    handle_terminal_resize((ditrm->in).ctl,resize_terminal);
    unblock_stdin();
    return 0;
  }
  return -1;
}



void handle_trm(int std_in,int std_out,int sock_in,int sock_out,int ctl_in,void *init_string,
               int init_len,int remote)

{
  int iVar1;
  itrm *itrm;
  uchar *p;
  size_t sVar2;
  int *piVar3;
  int iVar4;
  uchar *name;
  size_t sVar5;
  terminal_info *ptVar6;
  int in_GS_OFFSET;
  terminal_info info;
  
  iVar4 = 0x51;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  ptVar6 = &info;
  while (iVar4 != 0) {
    iVar4 = iVar4 + -1;
    (ptVar6->event).ev = EVENT_INIT;
    ptVar6 = (terminal_info *)&(ptVar6->event).info;
  }
  get_terminal_size(ctl_in,(int *)&info.event.info,(int *)((int)&info.event.info + 4));
  info.event.ev = EVENT_INIT;
  info.system_env = get_system_env();
  info.length = init_len;
  if (remote == 0) {
    piVar3 = get_opt_(cmdline_options,name);
    info.session_info = *piVar3;
    info.magic = -0x100;
  }
  else {
    info.session_info = remote;
    info.magic = -0x101;
  }
  itrm = (itrm *)mem_calloc(1,0x78);
  if (itrm != (itrm *)0x0) {
    p = (uchar *)mem_calloc(1,0x40);
    (itrm->in).queue.data = p;
    if (p == (uchar *)0x0) {
      mem_free(itrm);
    }
    else {
      ditrm = itrm;
      (itrm->in).std = std_in;
      (itrm->out).std = std_out;
      (itrm->in).sock = sock_in;
      (itrm->out).sock = sock_out;
      itrm->timer = (timer_id_T)0x0;
      (itrm->in).ctl = ctl_in;
      *(byte *)&itrm->field_0x74 = *(byte *)&itrm->field_0x74 & 0xf7 | (remote != 0) << 3;
      iVar4 = get_cp_index((uchar *)"ISO-8859-1");
      itrm->title_codepage = iVar4;
      if ((info.system_env & 6U) != 0) {
        *(byte *)&itrm->field_0x74 = *(byte *)&itrm->field_0x74 | 2;
      }
      if (remote == 0) {
        if (-1 < ctl_in) {
          setraw(itrm,1);
        }
        send_init_sequence(std_out,(uint)(*(byte *)&itrm->field_0x74 >> 1) & 1);
        handle_terminal_resize(ctl_in,resize_terminal);
        enable_mouse();
        handle_itrm_stdin(itrm);
      }
      else {
        if (-1 < std_in) {
          handle_itrm_stdin(itrm);
        }
      }
      if (sock_in != std_out) {
        set_handlers(sock_in,in_sock,(select_handler_T *)0x0,free_itrm,itrm);
      }
      get_terminal_name(info.name);
      p = get_cwd();
      if (p != (uchar *)0x0) {
        sVar2 = strlen((char *)p);
        sVar5 = 0x100;
        if ((int)sVar2 < 0x100) {
          sVar5 = sVar2;
        }
        __memcpy_chk(info.cwd,p,sVar5,0x114);
        mem_free(p);
      }
      itrm_queue_event(itrm,(uchar *)&info,0x140);
      itrm_queue_event(itrm,(uchar *)init_string,init_len);
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void resize_terminal(void)

{
  interlink_event ev;
  int local_14;
  int local_10 [3];
  
  get_terminal_size((ditrm->out).std,local_10,&local_14);
  ev.info._8_4_ = 0;
  ev.ev = EVENT_RESIZE;
  ev.info._0_4_ = local_10[0];
  ev.info._4_4_ = local_14;
  itrm_queue_event(ditrm,(uchar *)&ev,0x10);
  return;
}



void dispatch_special(uchar *text)

{
  uchar uVar1;
  itrm *piVar2;
  uchar *puVar3;
  byte bVar4;
  long lVar5;
  char *pcVar6;
  int codepage;
  uchar *__s;
  int iVar7;
  int numbers [4];
  
  piVar2 = ditrm;
  uVar1 = *text;
  if (uVar1 == '\x02') {
    if ((ditrm != (itrm *)0x0) && ((*(byte *)&ditrm->field_0x74 & 8) != 0)) {
      return;
    }
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
    __s = text + 1;
    if ((__s == (uchar *)0x0) || (text[1] == '\0')) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
      errline = 0x1d7;
      elinks_internal((uchar *)"assertion text && *text failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    else {
      assert_failed = 0;
    }
    iVar7 = 0;
    codepage = 0;
    do {
      pcVar6 = strchr((char *)__s,0x2c);
      if (pcVar6 == (char *)0x0) {
        if (codepage != 3) {
          return;
        }
        numbers[3] = strtol((char *)__s,(char **)0x0,10);
LAB_080de881:
        puVar3 = __s;
      }
      else {
        *pcVar6 = '\0';
        lVar5 = strtol((char *)__s,(char **)0x0,10);
        numbers[codepage] = lVar5;
        puVar3 = (uchar *)(pcVar6 + 1);
        if ((uchar *)(pcVar6 + 1) == (uchar *)0x0) goto LAB_080de881;
      }
      __s = puVar3;
      if (iVar7 == 3) {
        resize_window(numbers[0],numbers[1],numbers[2],numbers[3]);
        resize_terminal();
        return;
      }
      iVar7 = iVar7 + 1;
      codepage = codepage + 1;
    } while( true );
  }
  if (uVar1 == '\x03') {
    if (ditrm != (itrm *)0x0) {
      codepage = get_cp_index(text + 1);
      if (codepage == -1) {
        codepage = get_cp_index("US-ASCII");
      }
      ditrm->title_codepage = codepage;
      return;
    }
    return;
  }
  if (uVar1 != '\x01') {
    return;
  }
  if (ditrm != (itrm *)0x0) {
    bVar4 = *(byte *)&ditrm->field_0x74;
    if ((bVar4 & 8) != 0) {
      return;
    }
    if (ditrm->orig_title == (uchar *)0x0) {
      __s = get_window_title();
      piVar2->orig_title = __s;
      bVar4 = *(byte *)&ditrm->field_0x74;
    }
    *(byte *)&ditrm->field_0x74 = bVar4 | 4;
    if (ditrm != (itrm *)0x0) {
      codepage = ditrm->title_codepage;
      goto LAB_080de77f;
    }
  }
  codepage = get_cp_index("US-ASCII");
LAB_080de77f:
  set_window_title(text + 1,codepage);
  return;
}



void unblock_itrm_x(void *h)

{
  close_handle(h);
  if (ditrm != (itrm *)0x0) {
    unblock_itrm();
    resize_terminal();
    return;
  }
  return;
}



void __regparm3 set_kbd_event(itrm *itrm,interlink_event *ev,int key,term_event_modifier_T modifier)

{
  if (itrm->verase == key) {
    key = 0x101;
    goto LAB_080dea00;
  }
  if (key == 0xd) {
LAB_080de9fa:
    key = 0x100;
  }
  else {
    if (key < 0xe) {
      if (key == 9) {
        key = 0x102;
        goto LAB_080dea00;
      }
      if (key == 10) goto LAB_080de9fa;
    }
    else {
      if (key == 0x1b) {
        key = 0x103;
        goto LAB_080dea00;
      }
      if (key == 0x7f) {
        key = 0x109;
        goto LAB_080dea00;
      }
    }
    if (key < 0x20) {
      key = key + 0x40;
      *(undefined4 *)&ev->info = 0;
      *(undefined4 *)((int)&ev->info + 4) = 0;
      *(undefined4 *)((int)&ev->info + 8) = 0;
      ev->ev = EVENT_KBD;
      if (key < -0xff) {
        key = -key;
      }
      *(term_event_modifier_T *)((int)&ev->info + 4) = modifier | KBD_MOD_CTRL;
      *(int *)&ev->info = key;
      return;
    }
  }
LAB_080dea00:
  *(undefined4 *)&ev->info = 0;
  *(undefined4 *)((int)&ev->info + 4) = 0;
  *(undefined4 *)((int)&ev->info + 8) = 0;
  *(term_event_modifier_T *)((int)&ev->info + 4) = modifier;
  ev->ev = EVENT_KBD;
  *(int *)&ev->info = key;
  return;
}



void in_sock(itrm *itrm)

{
  int iVar1;
  int iVar2;
  uchar uVar3;
  size_t size;
  string *psVar4;
  ssize_t sVar5;
  int iVar6;
  size_t datalen;
  int fd;
  int in_GS_OFFSET;
  uchar *local_407c;
  uchar *local_4078;
  int local_4074;
  string delete;
  string path;
  uchar local_4021;
  uchar buf [16384];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  local_4074 = 0x4000;
  local_407c = (uchar *)(itrm->in).sock;
  local_4078 = buf;
  size = read((int)local_407c,buf,0x4000);
  if ((int)size < 1) {
free_and_return:
    free_itrm(itrm);
  }
  else {
    do {
      datalen = 0;
      if (buf[0] == '\0') {
        local_4074 = 0x3fff;
        fd = 1;
      }
      else {
        do {
          datalen = datalen;
          datalen = datalen + 1;
          if ((int)size <= (int)datalen) goto LAB_080deac5;
        } while (buf[datalen] != '\0');
        if (datalen == 0) {
          fd = 1;
          local_4074 = 0x3fff;
        }
        else {
          fd = (itrm->out).std;
          if ((ditrm == (itrm *)0x0) || ((*(byte *)&ditrm->field_0x74 & 1) == 0)) {
            want_draw(local_407c,local_4078,local_4074);
            hard_write(fd,buf,datalen);
            done_draw();
          }
          fd = datalen + 2;
          local_4074 = 0x4000 - fd;
        }
      }
      if ((assert_failed == 0) && (assert_failed = ZEXT14(local_4074 < 1), local_4074 < 1)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
        errline = 0x23d;
        elinks_internal((uchar *)"assertion ITRM_OUT_QUEUE_SIZE - i > 0 failed!");
      }
      iVar6 = size - fd;
      __memmove_chk(buf,buf + fd,local_4074,0x4000);
      if (iVar6 < 1) {
        sVar5 = hard_read((itrm->in).sock,&local_4021,1);
        if (sVar5 < 1) goto free_and_return;
        fd = 0;
      }
      else {
        fd = 1;
        local_4021 = buf[0];
      }
      uVar3 = local_4021;
      psVar4 = init_string(&path);
      if (psVar4 == (string *)0x0) goto free_and_return;
      while( true ) {
        if (fd < iVar6) {
          local_4021 = buf[fd];
          fd = fd + 1;
        }
        else {
          sVar5 = hard_read((itrm->in).sock,&local_4021,1);
          if (sVar5 < 1) goto free_and_return;
        }
        if (local_4021 == '\0') break;
        add_char_to_string(&path,local_4021);
      }
      psVar4 = init_string(&delete);
      if (psVar4 == (string *)0x0) {
        done_string(&path);
        goto free_and_return;
      }
      while( true ) {
        if (fd < iVar6) {
          local_4021 = buf[fd];
          fd = fd + 1;
          local_4074 = delete.length;
          iVar2 = path.length;
        }
        else {
          sVar5 = hard_read((itrm->in).sock,&local_4021,1);
          local_4074 = delete.length;
          iVar2 = path.length;
          if (sVar5 < 1) goto free_and_return;
        }
        delete.length = local_4074;
        path.length = iVar2;
        if (local_4021 == '\0') break;
        add_char_to_string(&delete,local_4021);
      }
      if (*path.source == '\0') {
        dispatch_special(delete.source);
      }
      else {
        if (((ditrm == (itrm *)0x0) || ((*(byte *)&ditrm->field_0x74 & 1) == 0)) || (uVar3 == '\0'))
        {
          size = local_4074 + 3 + iVar2;
          local_4078 = (uchar *)mem_alloc(size);
          if (local_4078 != (uchar *)0x0) {
            *local_4078 = uVar3;
            memcpy(local_4078 + 1,path.source,iVar2 + 1);
            memcpy(local_4078 + iVar2 + 2,delete.source,local_4074 + 1);
            if (uVar3 == '\x01') {
              block_itrm();
            }
            local_4074 = start_thread(exec_thread,local_4078,size);
            mem_free(local_4078);
            if (local_4074 == -1) {
              if (uVar3 == '\x01') {
                unblock_itrm();
              }
            }
            else {
              if (uVar3 == '\x01') {
                set_handlers(local_4074,unblock_itrm_x,(select_handler_T *)0x0,unblock_itrm_x,
                             (void *)local_4074);
              }
              else {
                set_handlers(local_4074,close_handle,(select_handler_T *)0x0,close_handle,
                             (void *)local_4074);
              }
            }
          }
        }
        else {
          if (*delete.source != '\0') {
            unlink((char *)delete.source);
          }
        }
      }
      done_string(&path);
      done_string(&delete);
      if (assert_failed == 0) {
        local_4074 = 0x4000 - fd;
        assert_failed = ZEXT14(local_4074 < 1);
        if (local_4074 < 1) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
          errline = 0x299;
          elinks_internal((uchar *)"assertion ITRM_OUT_QUEUE_SIZE - p > 0 failed!");
        }
      }
      else {
        local_4074 = 0x4000 - fd;
      }
      size = iVar6 - fd;
      local_4078 = buf + fd;
      local_407c = buf;
      __memmove_chk();
    } while (0 < (int)size);
LAB_080deac5:
    fd = (itrm->out).std;
    if ((ditrm == (itrm *)0x0) || ((*(byte *)&ditrm->field_0x74 & 1) == 0)) {
      want_draw(local_407c,local_4078,local_4074);
      hard_write(fd,buf,size);
      done_draw();
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void kbd_ctrl_c(void)

{
  interlink_event ev;
  
  if (ditrm != (itrm *)0x0) {
    ev.info._8_4_ = 0;
    ev.ev = EVENT_KBD;
    ev.info._0_4_ = 0x200;
    ev.info._4_4_ = 0;
    itrm_queue_event(ditrm,(uchar *)&ev,0x10);
  }
  return;
}



int __regparm3 process_queue(itrm *itrm)

{
  uchar *__dest;
  size_t __n;
  int v;
  byte *pbVar1;
  byte bVar2;
  int iVar3;
  byte *pbVar4;
  interlink_event *piVar5;
  bool bVar6;
  byte bVar7;
  int local_34;
  byte local_2d;
  interlink_event ev;
  term_event_keyboard os2xtd [256];
  
  bVar7 = 0;
  local_34 = 0;
  if ((itrm->in).queue.len == 0) goto LAB_080df178;
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  assert_failed = (uint)*(byte *)&itrm->field_0x74 & 1;
  if ((*(byte *)&itrm->field_0x74 & 1) != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
    errline = 0x424;
    elinks_internal((uchar *)"assertion !itrm->blocked failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  ev.info._8_4_ = 0;
  ev.ev = EVENT_KBD;
  ev.info._0_4_ = -1;
  ev.info._4_4_ = 0;
  pbVar1 = (itrm->in).queue.data;
  bVar2 = *pbVar1;
  if (bVar2 != 0x1b) {
    if (bVar2 != 0) {
      local_34 = 1;
      set_kbd_event(itrm,&ev,(uint)bVar2,KBD_MOD_NONE);
      goto LAB_080df125;
    }
    local_34 = -1;
    if (1 < (itrm->in).queue.len) {
      local_34 = 2;
      set_kbd_interlink_event(&ev,os2xtd[pbVar1[1]].key,os2xtd[pbVar1[1]].modifier);
      goto LAB_080df125;
    }
    goto LAB_080df12a;
  }
  v = (itrm->in).queue.len;
  if (v < 2) goto LAB_080df310;
  bVar2 = pbVar1[1];
  if (bVar2 != 0x5b) {
    if (bVar2 == 0x4f) {
      if (assert_failed != 0) {
LAB_080df456:
        assert_failed = 0;
        goto LAB_080df362;
      }
      bVar6 = *(itrm->in).queue.data != '\x1b';
      assert_failed = ZEXT14(bVar6);
      if (bVar6) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
        errline = 0x3a5;
        elinks_internal((uchar *)"assertion itrm->in.queue.data[0] == ASCII_ESC failed!");
        if (assert_failed != 0) goto LAB_080df456;
      }
      bVar6 = (itrm->in).queue.data[1] != 'O';
      assert_failed = ZEXT14(bVar6);
      if (bVar6) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
        errline = 0x3a6;
        elinks_internal((uchar *)"assertion itrm->in.queue.data[1] == 0x4F failed!");
        if (assert_failed != 0) goto LAB_080df456;
      }
      if ((itrm->in).queue.len < 3) goto LAB_080df310;
      bVar7 = (itrm->in).queue.data[2];
      if (0x5d < (byte)(bVar7 - 0x21)) goto LAB_080df362;
      if (bVar7 == 0x4d) {
        v = -0x100;
LAB_080df40e:
        ev.info._4_4_ = 0;
        ev.info._0_4_ = v;
      }
      else {
        if (bVar7 < 0x4e) {
          if (bVar7 == 0x44) {
            v = -0x104;
          }
          else {
            if (bVar7 < 0x45) {
              if (bVar7 == 0x42) {
                v = -0x107;
              }
              else {
                v = -0x105;
                if (bVar7 < 0x43) {
                  if (bVar7 != 0x41) goto LAB_080df418;
                  v = -0x106;
                }
              }
            }
            else {
              if (bVar7 == 0x48) {
                v = -0x10a;
              }
              else {
                if (bVar7 == 0x49) {
                  v = -0x102;
                }
                else {
                  if (bVar7 != 0x46) goto LAB_080df418;
                  v = -0x10b;
                }
              }
            }
          }
          goto LAB_080df40e;
        }
        if (bVar7 == 0x53) {
          v = -0x123;
          goto LAB_080df40e;
        }
        if (bVar7 < 0x54) {
          if (bVar7 == 0x51) {
            v = -0x121;
          }
          else {
            v = -0x122;
            if (bVar7 < 0x52) {
              if (bVar7 != 0x50) goto LAB_080df418;
              v = -0x120;
            }
          }
          goto LAB_080df40e;
        }
        if (bVar7 == 0x58) {
          v = 0x3d;
          goto LAB_080df40e;
        }
        if ((0x57 < bVar7) && ((byte)(bVar7 + 0x96) < 0x10)) {
          v = (uint)bVar7 - 0x40;
          goto LAB_080df40e;
        }
      }
LAB_080df418:
      local_34 = 3;
      goto LAB_080df125;
    }
    if (bVar2 == 0x1b) {
      if (v != 2) {
        if ((pbVar1[2] == 0x4f) || (pbVar1[2] == 0x5b)) {
          local_34 = 1;
          set_kbd_event(itrm,&ev,0x1b,KBD_MOD_NONE);
        }
        else {
          local_34 = 2;
          set_kbd_event(itrm,&ev,0x1b,KBD_MOD_ALT);
        }
        goto LAB_080df125;
      }
      goto LAB_080df310;
    }
    goto LAB_080df2b2;
  }
  if (v == 2) {
LAB_080df310:
    local_34 = -1;
    goto LAB_080df125;
  }
  local_2d = pbVar1[2];
  if (local_2d == 0x5b) {
    if (((v != 3) && (bVar7 = pbVar1[3], 0x40 < bVar7)) && (bVar7 < 0x4d)) {
      local_34 = 4;
      set_kbd_interlink_event(&ev,-0xdf - (uint)bVar7,KBD_MOD_NONE);
      goto LAB_080df125;
    }
    goto LAB_080df310;
  }
  iVar3 = 2;
  bVar2 = local_2d;
  while ((0x2f < bVar2 && (bVar2 < 0x40))) {
    iVar3 = iVar3 + 1;
    if (v <= iVar3) goto LAB_080df35d;
    bVar2 = pbVar1[iVar3];
  }
  if (v <= iVar3) {
LAB_080df35d:
    if (v != 0x40) goto LAB_080df310;
    goto LAB_080df362;
  }
  local_34 = iVar3;
  if ((0x1f < bVar2) && (bVar2 < 0x30)) {
    pbVar4 = pbVar1 + iVar3;
    do {
      local_34 = local_34 + 1;
      if (v <= local_34) goto LAB_080df35d;
      bVar2 = pbVar4[1];
    } while ((0x1f < bVar2) && (pbVar4 = pbVar4 + 1, bVar2 < 0x30));
  }
  if (0x3e < (byte)(bVar2 - 0x40)) goto LAB_080df362;
  v = 0;
  if ((byte)(local_2d - 0x30) < 10) {
    v = 0;
    do {
      v = ((uint)local_2d - 0x30) + v * 10;
      local_2d = pbVar1[3];
      pbVar1 = pbVar1 + 1;
    } while ((byte)(local_2d - 0x30) < 10);
  }
  if (local_2d == 0x3a) {
    v = 0;
  }
  if (iVar3 != local_34) {
    local_34 = local_34 + 1;
    goto switchD_080df581_caseD_45;
  }
  local_34 = iVar3 + 1;
  switch(bVar2) {
  case 0x41:
    ev.info._0_4_ = -0x106;
LAB_080df80a:
    v = 4;
    ev.info._4_4_ = 0;
    ev.info._0_4_ = -(int)ev.info;
    piVar5 = &ev;
    while (v != 0) {
      v = v + -1;
      piVar5->ev = EVENT_INIT;
      piVar5 = (interlink_event *)((int)piVar5 + (uint)bVar7 * -8 + 4);
    }
    break;
  case 0x42:
    ev.info._0_4_ = 0x107;
    ev.info._4_4_ = 0;
    break;
  case 0x43:
    ev.info._0_4_ = 0x105;
    ev.info._4_4_ = 0;
    break;
  case 0x44:
    ev.info._0_4_ = 0x104;
    ev.info._4_4_ = 0;
    break;
  default:
    goto switchD_080df581_caseD_45;
  case 0x46:
  case 0x65:
switchD_080df581_caseD_46:
    ev.info._0_4_ = 0x10b;
    ev.info._4_4_ = 0;
    break;
  case 0x47:
switchD_080df581_caseD_47:
    ev.info._0_4_ = 0x10d;
    ev.info._4_4_ = 0;
    break;
  case 0x48:
switchD_080df581_caseD_48:
    ev.info._0_4_ = 0x10a;
    ev.info._4_4_ = 0;
    break;
  case 0x49:
switchD_080df581_caseD_49:
    ev.info._0_4_ = 0x10c;
    ev.info._4_4_ = 0;
    break;
  case 0x4c:
switchD_080df581_caseD_4c:
    ev.info._0_4_ = 0x108;
    ev.info._4_4_ = 0;
    break;
  case 0x4d:
    local_34 = decode_terminal_mouse_escape_sequence(itrm,&ev,local_34,v);
    goto switchD_080df581_caseD_45;
  case 0x4e:
switchD_080df581_caseD_4e:
    ev.info._0_4_ = 0x121;
    ev.info._4_4_ = 0;
    break;
  case 0x4f:
switchD_080df581_caseD_4f:
    ev.info._0_4_ = 0x122;
    ev.info._4_4_ = 0;
    break;
  case 0x50:
switchD_080df581_caseD_50:
    ev.info._0_4_ = 0x123;
    ev.info._4_4_ = 0;
    break;
  case 0x51:
switchD_080df581_caseD_51:
    ev.info._0_4_ = 0x124;
    ev.info._4_4_ = 0;
    break;
  case 0x52:
    resize_terminal();
    goto switchD_080df581_caseD_45;
  case 0x53:
switchD_080df581_caseD_53:
    ev.info._0_4_ = 0x126;
    ev.info._4_4_ = 0;
    break;
  case 0x54:
switchD_080df581_caseD_54:
    ev.info._0_4_ = 0x127;
    ev.info._4_4_ = 0;
    break;
  case 0x55:
switchD_080df581_caseD_55:
    ev.info._0_4_ = 0x128;
    ev.info._4_4_ = 0;
    break;
  case 0x56:
switchD_080df581_caseD_56:
    ev.info._0_4_ = 0x129;
    ev.info._4_4_ = 0;
    break;
  case 0x57:
switchD_080df581_caseD_57:
    ev.info._0_4_ = 0x12a;
    ev.info._4_4_ = 0;
    break;
  case 0x58:
switchD_080df581_caseD_58:
    ev.info._0_4_ = 299;
    ev.info._4_4_ = 0;
    break;
  case 0x5a:
    ev.info._0_4_ = 0x102;
    ev.info._4_4_ = 1;
    break;
  case 0x7a:
    if (v == 0xdc) goto switchD_080df581_caseD_46;
    if (v < 0xdd) {
      if (v == 0xd6) goto switchD_080df581_caseD_48;
      if (v == 0xd8) goto switchD_080df581_caseD_49;
    }
    else {
      if (v == 0xf7) {
        ev.info._0_4_ = -0x108;
        goto LAB_080df80a;
      }
      if (v == 0xf9) goto switchD_080df5ba_caseD_3;
      if (v == 0xde) goto switchD_080df581_caseD_47;
    }
    goto switchD_080df581_caseD_45;
  case 0x7e:
    switch(v) {
    case 1:
    case 7:
      ev.info._0_4_ = -0x10a;
      goto LAB_080df80a;
    case 3:
switchD_080df5ba_caseD_3:
      ev.info._0_4_ = 0x109;
      ev.info._4_4_ = 0;
      break;
    case 0xb:
      ev.info._0_4_ = 0x120;
      ev.info._4_4_ = 0;
      break;
    case 0x11:
      ev.info._0_4_ = 0x125;
      ev.info._4_4_ = 0;
      break;
    case 0x19:
      ev.info._0_4_ = 0x122;
      ev.info._4_4_ = 1;
      break;
    case 0x1a:
      ev.info._0_4_ = 0x123;
      ev.info._4_4_ = 1;
      break;
    case 0x1c:
      ev.info._0_4_ = 0x124;
      ev.info._4_4_ = 1;
      break;
    case 0x1d:
      ev.info._0_4_ = 0x125;
      ev.info._4_4_ = 1;
      break;
    case 0x1f:
      ev.info._0_4_ = 0x126;
      ev.info._4_4_ = 1;
      break;
    case 0x20:
      ev.info._0_4_ = 0x127;
      ev.info._4_4_ = 1;
      break;
    case 0x21:
      ev.info._0_4_ = 0x128;
      ev.info._4_4_ = 1;
      break;
    case 0x22:
      ev.info._0_4_ = 0x129;
      ev.info._4_4_ = 1;
      break;
    case 0x18:
      goto switchD_080df581_caseD_58;
    case 0x17:
      goto switchD_080df581_caseD_57;
    case 0x15:
      goto switchD_080df581_caseD_56;
    case 0x14:
      goto switchD_080df581_caseD_55;
    case 0x13:
      goto switchD_080df581_caseD_54;
    case 0x12:
      goto switchD_080df581_caseD_53;
    case 0xf:
      goto switchD_080df581_caseD_51;
    case 0xe:
      goto switchD_080df581_caseD_50;
    case 0xd:
      goto switchD_080df581_caseD_4f;
    case 0xc:
      goto switchD_080df581_caseD_4e;
    case 2:
      goto switchD_080df581_caseD_4c;
    case 5:
      goto switchD_080df581_caseD_49;
    case 6:
      goto switchD_080df581_caseD_47;
    case 4:
    case 8:
      goto switchD_080df581_caseD_46;
    default:
      goto switchD_080df581_caseD_45;
    }
  }
  ev.info._8_4_ = 0;
  ev.ev = EVENT_KBD;
switchD_080df581_caseD_45:
  if (local_34 == 0) {
LAB_080df362:
    bVar2 = (itrm->in).queue.data[1];
LAB_080df2b2:
    local_34 = 2;
    set_kbd_event(itrm,&ev,(uint)bVar2,KBD_MOD_ALT);
  }
LAB_080df125:
  if (ev.ev == EVENT_MOUSE) {
LAB_080df130:
    itrm_queue_event(itrm,(uchar *)&ev,0x10);
  }
  else {
LAB_080df12a:
    if ((int)ev.info != -1) goto LAB_080df130;
  }
  if (local_34 == -1) {
    install_timer(&itrm->timer,200,kbd_timeout,itrm);
    return 0;
  }
LAB_080df178:
  if (assert_failed == 0) {
    bVar6 = (itrm->in).queue.len < local_34;
    assert_failed = ZEXT14(bVar6);
    if (bVar6) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
      errline = 0x491;
      elinks_internal((uchar *)"assertion itrm->in.queue.len >= el failed: event queue underflow");
      if (assert_failed != 0) goto LAB_080df1f0;
    }
    __n = (itrm->in).queue.len - local_34;
    (itrm->in).queue.len = __n;
    if ((__n != 0) &&
       (__dest = (itrm->in).queue.data, memmove(__dest,__dest + local_34,__n),
       0x3f < (itrm->in).queue.len)) {
      return local_34;
    }
  }
  else {
LAB_080df1f0:
    assert_failed = 0;
    (itrm->in).queue.len = 0;
  }
  handle_itrm_stdin(itrm);
  return local_34;
}



void in_kbd(itrm *itrm)

{
  int iVar1;
  ssize_t sVar2;
  uchar *fmt;
  
  iVar1 = can_read((itrm->in).std);
  if (iVar1 != 0) {
    kill_timer(&itrm->timer);
    iVar1 = (itrm->in).queue.len;
    if (0x3f < iVar1) {
      unhandle_itrm_stdin(itrm);
      do {
        iVar1 = process_queue(itrm);
      } while (iVar1 != 0);
      return;
    }
    sVar2 = read((itrm->in).std,(itrm->in).queue.data + iVar1,0x40 - iVar1);
    if (sVar2 < 1) {
      free_itrm(itrm);
      return;
    }
    iVar1 = sVar2 + (itrm->in).queue.len;
    (itrm->in).queue.len = iVar1;
    if (0x40 < iVar1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
      errline = 0x4ba;
      fmt = gettext((uchar *)"Too many bytes read from the itrm!");
      elinks_error(fmt);
      (itrm->in).queue.len = 0x40;
    }
    do {
      iVar1 = process_queue(itrm);
      if (iVar1 == 0) {
        return;
      }
      iVar1 = process_queue(itrm);
    } while (iVar1 != 0);
  }
  return;
}



void kbd_timeout(itrm *itrm)

{
  byte *pbVar1;
  uchar *__dest;
  int iVar2;
  size_t __n;
  byte bVar3;
  bool bVar4;
  interlink_event ev;
  
  itrm->timer = (timer_id_T)0x0;
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  bVar4 = (itrm->in).queue.len == 0;
  assert_failed = ZEXT14(bVar4);
  if (bVar4) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
    errline = 0x3fd;
    elinks_internal((uchar *)"assertion itrm->in.queue.len failed: timeout on empty queue");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
    bVar3 = *(byte *)&itrm->field_0x74;
  }
  else {
    bVar3 = *(byte *)&itrm->field_0x74;
  }
  assert_failed = (uint)bVar3 & 1;
  if ((bVar3 & 1) != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
    errline = 0x3fe;
    elinks_internal((uchar *)"assertion !itrm->blocked failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  iVar2 = can_read((itrm->in).std);
  if (iVar2 != 0) {
    in_kbd(itrm);
    return;
  }
  if ((itrm->in).queue.len < 2) {
    bVar3 = *(itrm->in).queue.data;
  }
  else {
    pbVar1 = (itrm->in).queue.data;
    bVar3 = *pbVar1;
    if (bVar3 == 0x1b) {
      iVar2 = 2;
      set_kbd_event(itrm,&ev,(uint)pbVar1[1],KBD_MOD_ALT);
      goto LAB_080dfa92;
    }
  }
  iVar2 = 1;
  set_kbd_event(itrm,&ev,(uint)bVar3,KBD_MOD_NONE);
LAB_080dfa92:
  itrm_queue_event(itrm,(uchar *)&ev,0x10);
  __n = (itrm->in).queue.len - iVar2;
  (itrm->in).queue.len = __n;
  if (__n != 0) {
    __dest = (itrm->in).queue.data;
    memmove(__dest,__dest + iVar2,__n);
  }
  do {
    iVar2 = process_queue(itrm);
  } while (iVar2 != 0);
  return;
}



int decode_terminal_mouse_escape_sequence(itrm *itrm,interlink_event *ev,int el,int v)

{
  byte bVar1;
  uchar *puVar2;
  int xterm_button;
  int iVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  
  iVar3 = (itrm->in).queue.len - el;
  if (iVar3 < 3) {
LAB_080dfc58:
    iVar3 = -1;
  }
  else {
    if (v == 5) {
      if (xterm_button == -1) {
        xterm_button = 0;
      }
      if (iVar3 < 5) goto LAB_080dfc58;
      puVar2 = (itrm->in).queue.data;
      uVar7 = (uint)puVar2[el + 2] * 0x80 + -0x10a1 + (uint)puVar2[el + 1];
      if ((uVar7 & 0x2000) != 0) {
        uVar7 = 0;
      }
      uVar6 = (uint)puVar2[el + 4] * 0x80 + -0x10a1 + (uint)puVar2[el + 3];
      if ((uVar6 & 0x2000) != 0) {
        uVar6 = 0;
      }
      uVar5 = xterm_button ^ (uint)puVar2[el] - 0x20;
      if (uVar5 == 1) {
        uVar4 = 0x20;
        if ((xterm_button & 1U) == 0) {
LAB_080dfd2a:
          uVar4 = 0;
        }
      }
      else {
        if ((int)uVar5 < 2) {
          uVar4 = 0x40;
          if (uVar5 != 0) goto LAB_080dfd2a;
        }
        else {
          if (uVar5 == 2) {
            uVar4 = (-(uint)((xterm_button & 2U) == 0) & 0xffffffe0) + 0x21;
          }
          else {
            if (uVar5 != 4) goto LAB_080dfd2a;
            uVar4 = (-(uint)((xterm_button & 4U) == 0) & 0xffffffe0) + 0x22;
          }
        }
      }
      iVar3 = el + 5;
    }
    else {
      puVar2 = (itrm->in).queue.data;
      bVar1 = puVar2[el];
      uVar4 = (uint)bVar1 & 7;
      if ((uVar4 == 3) && (xterm_button != -1)) {
        uVar4 = xterm_button | 0x20;
      }
      if (((uint)bVar1 & 0x60) == 0x60) {
        uVar4 = 4 - (uint)((bVar1 & 1) == 0);
      }
      iVar3 = el + 3;
      uVar7 = (uint)puVar2[el + 1] - 0x21;
      uVar6 = (uint)puVar2[el + 2] - 0x21;
    }
    ev->ev = EVENT_MOUSE;
    *(uint *)&ev->info = uVar7;
    *(uint *)((int)&ev->info + 4) = uVar6;
    *(uint *)((int)&ev->info + 8) = uVar4;
  }
  return iVar3;
}



void send_mouse_done_sequence(int h)

{
  hard_write(h,"\x1b[?9l",5);
  hard_write(h,"\x1b[?1000l",8);
  return;
}



void disable_mouse(void)

{
  int h;
  int iVar1;
  
  h = get_output_handle();
  if (mouse_enabled == 0) {
    return;
  }
  unhandle_mouse(ditrm->mouse_h);
  iVar1 = is_xterm();
  if (iVar1 != 0) {
    send_mouse_done_sequence(h);
  }
  mouse_enabled = 0;
  return;
}



void send_mouse_init_sequence(int h)

{
  hard_write(h,"\x1b[?9h",5);
  hard_write(h,"\x1b[?1000h",8);
  return;
}



void enable_mouse(void)

{
  itrm *piVar1;
  int h;
  int iVar2;
  void *pvVar3;
  
  h = get_output_handle();
  if (mouse_enabled != 0) {
    return;
  }
  iVar2 = is_xterm();
  if (iVar2 != 0) {
    send_mouse_init_sequence(h);
  }
  piVar1 = ditrm;
  pvVar3 = handle_mouse(0,itrm_queue_event,ditrm);
  piVar1->mouse_h = pvVar3;
  mouse_enabled = 1;
  return;
}



void toggle_mouse(void)

{
  if (mouse_enabled == 0) {
    enable_mouse();
    return;
  }
  disable_mouse();
  return;
}



void done_screen(terminal_screen *screen)

{
  if (screen->image != (screen_char *)0x0) {
    mem_free(screen->image);
  }
  mem_free(screen);
  return;
}



void done_screen_drivers(module *xxx)

{
  list_head_elinks **pplVar1;
  list_head_elinks *p;
  list_head_elinks *plVar2;
  list_head_elinks *plVar3;
  bool bVar4;
  
  plVar3 = (list_head_elinks *)active_screen_drivers.next;
  if ((list_head_elinks *)active_screen_drivers.next != &active_screen_drivers) {
    do {
      plVar3 = (list_head_elinks *)plVar3->next;
    } while (plVar3 != &active_screen_drivers);
  }
  plVar2 = (list_head_elinks *)active_screen_drivers.prev;
  if ((list_head_elinks *)active_screen_drivers.prev != plVar3) {
    do {
      pplVar1 = (list_head_elinks **)&plVar2->prev;
      plVar2 = *pplVar1;
    } while (*pplVar1 != plVar3);
  }
  plVar2 = *(list_head_elinks **)active_screen_drivers.next;
  p = (list_head_elinks *)active_screen_drivers.next;
  if ((list_head_elinks *)active_screen_drivers.next != plVar3) {
    do {
      plVar2->prev = p->prev;
      *(void **)p->prev = p->next;
      mem_free(p);
      bVar4 = plVar2 != plVar3;
      p = plVar2;
      plVar2 = (list_head_elinks *)plVar2->next;
    } while (bVar4);
  }
  return;
}



void resize_screen(terminal *term,int width,int height)

{
  int iVar1;
  screen_char *__s;
  terminal_screen *ptVar2;
  
  if (assert_failed == 0) {
    if ((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c";
      errline = 0x49a;
      elinks_internal((uchar *)"assertion term && term->screen failed!");
      ptVar2 = term->screen;
      if (assert_failed != 0) goto joined_r0x080e00c3;
    }
    else {
      ptVar2 = term->screen;
    }
    assert_failed = -(width >> 0x1f);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c";
      errline = 0x49e;
      elinks_internal((uchar *)"assertion width >= 0 failed!");
      if (assert_failed != 0) goto joined_r0x080e00c3;
    }
    assert_failed = -(height >> 0x1f);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c";
      errline = 0x49f;
      elinks_internal((uchar *)"assertion height >= 0 failed!");
    }
  }
  else {
    ptVar2 = term->screen;
  }
joined_r0x080e00c3:
  if (width * height != 0) {
    iVar1 = width * height;
    __s = (screen_char *)mem_realloc(ptVar2->image,iVar1 * 0x10);
    if (__s != (screen_char *)0x0) {
      ptVar2->image = __s;
      ptVar2->last_image = __s + iVar1;
      memset(__s,0,iVar1 * 8);
      memset(ptVar2->last_image,0xff,iVar1 * 8);
      term->height = height;
      term->width = width;
      if (0 < ptVar2->dirty_from) {
        ptVar2->dirty_from = 0;
      }
      if (ptVar2->dirty_to < height) {
        ptVar2->dirty_to = height;
      }
    }
  }
  return;
}



terminal_screen * init_screen(void)

{
  terminal_screen *ptVar1;
  
  ptVar1 = (terminal_screen *)mem_calloc(1,0x20);
  if (ptVar1 != (terminal_screen *)0x0) {
    ptVar1->lcx = -1;
    ptVar1->lcy = -1;
  }
  return ptVar1;
}



void beep_terminal(terminal *term)

{
  hard_write(term->fdout,"\a",1);
  return;
}



void erase_screen(terminal *term)

{
  int iVar1;
  
  if ((*(byte *)&term->field_0x38 & 1) != 0) {
    iVar1 = is_blocked();
    if (iVar1 != 0) {
      return;
    }
    want_draw();
  }
  hard_write(term->fdout,"\x1b[2J\x1b[1;1H",10);
  if ((*(byte *)&term->field_0x38 & 1) == 0) {
    return;
  }
  done_draw();
  return;
}



void __regparm3 set_screen_driver_opt(screen_driver *driver,option_elinks *term_spec)

{
  byte *pbVar1;
  screen_driver_opt *psVar2;
  uint uVar3;
  term_mode_type tVar4;
  option_elinks *tree;
  int *piVar5;
  option_elinks **ppoVar6;
  uint *puVar7;
  option_elinks *tree_00;
  int iVar8;
  uchar *name;
  uchar *name_00;
  uchar *name_01;
  string *name_02;
  string *extraout_EDX;
  int local_20;
  
  tree = (option_elinks *)get_opt_((option_elinks *)driver,(uchar *)term_spec);
  tree_00 = tree->next;
  piVar5 = get_opt_(tree,name);
  local_20 = *piVar5;
  psVar2 = screen_driver_opts[driver->type];
  (driver->opt).charsets[0] = psVar2->charsets[0];
  (driver->opt).charsets[1] = psVar2->charsets[1];
  (driver->opt).frame = psVar2->frame;
  (driver->opt).frame_seqs = psVar2->frame_seqs;
  (driver->opt).underline = psVar2->underline;
  (driver->opt).color_mode = psVar2->color_mode;
  *(undefined4 *)&(driver->opt).field_0x18 = *(undefined4 *)&psVar2->field_0x18;
  tree = (option_elinks *)is_cp_utf8((int)tree_00);
  if (tree == (option_elinks *)0x0) {
    pbVar1 = (byte *)&(driver->opt).field_0x18;
    *pbVar1 = *pbVar1 & 0xfd;
  }
  else {
    pbVar1 = (byte *)&(driver->opt).field_0x18;
    *pbVar1 = *pbVar1 | 2;
    local_20 = 1;
  }
  ppoVar6 = (option_elinks **)get_opt_(tree,name_00);
  tree = *ppoVar6;
  *(option_elinks **)&(driver->opt).color_mode = tree;
  puVar7 = get_opt_(tree,name_01);
  uVar3 = *puVar7;
  tree = (option_elinks *)
         ((uint)*(byte *)&(driver->opt).field_0x18 & 0xfffffffe | (uint)(uchar *)(uVar3 & 1));
  *(undefined *)&(driver->opt).field_0x18 = (char)tree;
  piVar5 = get_opt_(tree,(uchar *)(uVar3 & 1));
  name_02 = (string *)0x0;
  if (*piVar5 != 0) {
    name_02 = underline_seqs;
  }
  (driver->opt).underline = name_02;
  if (local_20 == 0) {
    tree_00 = (option_elinks *)driver->type;
    (driver->opt).charsets[0] = -1;
    if (tree_00 == (option_elinks *)0x2) {
      tree_00 = (option_elinks *)get_opt_((option_elinks *)0x2,(uchar *)name_02);
      name_02 = extraout_EDX;
      if (tree_00->next != (option_elinks *)0x0) {
        (driver->opt).frame = frame_restrict;
      }
    }
    else {
      if (tree_00 != (option_elinks *)&DAT_00000004) {
        if (tree_00 != (option_elinks *)0x1) {
          return;
        }
        (driver->opt).frame = frame_vt100;
        return;
      }
    }
    piVar5 = get_opt_(tree_00,(uchar *)name_02);
    if (*piVar5 != 0) {
      (driver->opt).frame_seqs = m11_hack_frame_seqs;
    }
    return;
  }
  tVar4 = driver->type;
  *(option_elinks **)(driver->opt).charsets = tree_00;
  (driver->opt).frame_seqs = (string *)0x0;
  if (tVar4 == TERM_LINUX) {
    piVar5 = get_opt_((option_elinks *)0x2,(uchar *)name_02);
    if (*piVar5 != 0) {
      (driver->opt).frame = frame_restrict;
    }
  }
  else {
    if (tVar4 != TERM_FREEBSD) {
      if (tVar4 == TERM_VT100) {
        (driver->opt).frame = frame_vt100_u;
        iVar8 = get_cp_index((uchar *)"cp437");
        (driver->opt).charsets[1] = iVar8;
        return;
      }
      if (tVar4 != TERM_KOI8) {
        if ((*(byte *)&(driver->opt).field_0x18 & 2) == 0) {
          *(option_elinks **)((driver->opt).charsets + 1) = tree_00;
          return;
        }
        iVar8 = get_cp_index("US-ASCII");
        (driver->opt).charsets[1] = iVar8;
        return;
      }
      iVar8 = get_cp_index("koi8-r");
      (driver->opt).charsets[1] = iVar8;
      return;
    }
    (driver->opt).frame = frame_freebsd_u;
  }
  iVar8 = get_cp_index((uchar *)"cp437");
  (driver->opt).charsets[1] = iVar8;
  return;
}



int screen_driver_change_hook(session *ses,option_elinks *term_spec,option_elinks *changed)

{
  term_mode_type tVar1;
  uchar *__s2;
  term_mode_type *ptVar2;
  int iVar3;
  uchar *in_EDX;
  screen_driver *driver;
  
  ptVar2 = get_opt_(term_spec,in_EDX);
  tVar1 = *ptVar2;
  __s2 = term_spec->name;
  driver = (screen_driver *)active_screen_drivers.next;
  if ((list_head_elinks *)active_screen_drivers.next != &active_screen_drivers) {
    do {
      if ((driver->type == tVar1) && (iVar3 = strcmp((char *)driver->name,(char *)__s2), iVar3 == 0)
         ) {
        set_screen_driver_opt(driver,term_spec);
        return 0;
      }
      driver = driver->next;
    } while (driver != (screen_driver *)&active_screen_drivers);
  }
  return 0;
}



string * __regparm3 add_bytes_to_string__(string *string,uchar *bytes,int length)

{
  int iVar1;
  uint uVar2;
  uchar *puVar3;
  uint size;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  if (((bytes == (uchar *)0x0) || (string == (string *)0x0)) || (length < 0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 0xff;
    elinks_internal((uchar *)
                    "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  if (length == 0) {
    return string;
  }
  iVar1 = length + string->length;
  uVar2 = string->length + 0xffU & 0xffffff00;
  size = iVar1 + 0x100U & 0xffffff00;
  if (uVar2 < size) {
    puVar3 = (uchar *)mem_realloc(string->source,size);
    if (puVar3 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar3;
    memset(puVar3 + uVar2,0,size - uVar2);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  memcpy(string->source + string->length,bytes,length);
  string->source[iVar1] = '\0';
  string->length = iVar1;
  return string;
}



// WARNING: Could not reconcile some variable overlaps

void redraw_screen(terminal *term)

{
  uint uVar1;
  uchar **ppuVar2;
  uchar uVar3;
  byte bVar4;
  byte bVar5;
  terminal_screen *ptVar6;
  void *pvVar7;
  undefined *puVar8;
  terminal_screen *ptVar9;
  uint uVar10;
  screen_driver *psVar11;
  void *pvVar12;
  uchar uVar13;
  byte bVar14;
  void **ppvVar15;
  size_t __n;
  string *psVar16;
  uint u;
  int length;
  int iVar17;
  uint size;
  uint size_00;
  uchar *puVar18;
  byte bVar19;
  uint u_00;
  int iVar20;
  byte bVar21;
  byte bVar22;
  uchar *name;
  uchar *extraout_EDX;
  screen_driver *driver;
  screen_char *psVar23;
  screen_driver *psVar24;
  byte bVar25;
  int in_GS_OFFSET;
  bool bVar26;
  byte local_bd;
  uint local_98;
  screen_char *local_88;
  uint local_84;
  byte local_80;
  uchar *local_7c;
  screen_char *local_78;
  screen_char *local_74;
  byte local_6c;
  uint local_64;
  unicode_val_T local_60;
  string image;
  uchar code_1 [6];
  uint local_40;
  uchar code [25];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  name = (uchar *)0x0;
  ptVar6 = term->screen;
  if (((ptVar6 == (terminal_screen *)0x0) || (ptVar6->dirty_to < ptVar6->dirty_from)) ||
     (((*(byte *)&term->field_0x38 & 1) != 0 &&
      (iVar17 = is_blocked(), name = extraout_EDX, iVar17 != 0)))) goto LAB_080e0cb5;
  ppvVar15 = (void **)get_opt_(term->spec,name);
  pvVar7 = *ppvVar15;
  name = term->spec->name;
  __n = strlen((char *)name);
  pvVar12 = active_screen_drivers.next;
  driver = (screen_driver *)active_screen_drivers.next;
  psVar24 = (screen_driver *)active_screen_drivers.next;
  if ((list_head_elinks *)active_screen_drivers.next != &active_screen_drivers) {
    do {
      if ((pvVar7 == (void *)driver->type) &&
         (iVar17 = strcmp((char *)driver->name,(char *)name), iVar17 == 0)) {
        if ((screen_driver *)pvVar12 != driver) {
          driver->next->prev = driver->prev;
          driver->prev->next = driver->next;
          *(list_head_elinks **)&driver->prev = &active_screen_drivers;
          driver->next = active_screen_drivers.next;
          active_screen_drivers.next = driver;
          driver->next->prev = driver;
        }
        bVar4 = *(byte *)&term->field_0x38;
        bVar21 = *(byte *)&(driver->opt).field_0x18 & 2;
        *(byte *)&term->field_0x38 = bVar4 & 0xfd | bVar21;
        *(byte *)&term->field_0x38 = bVar4 & 0xf9 | bVar21 | ((driver->opt).charsets[0] != -1) << 2;
        goto LAB_080e073b;
      }
      driver = driver->next;
      psVar24 = driver;
    } while (driver != (screen_driver *)&active_screen_drivers);
  }
  driver = (screen_driver *)mem_alloc(__n + 0x2c);
  if (driver == (screen_driver *)0x0) goto LAB_080e0cb5;
  psVar11 = psVar24->next;
  driver->prev = psVar24;
  driver->next = psVar11;
  psVar24->next = driver;
  driver->next->prev = driver;
  *(void **)&driver->type = pvVar7;
  set_screen_driver_opt(driver,term->spec);
  memcpy(driver->name,term->spec->name,__n + 1);
  term->spec->change_hook = screen_driver_change_hook;
  bVar4 = *(byte *)&term->field_0x38;
  bVar21 = *(byte *)&(driver->opt).field_0x18 & 2;
  *(byte *)&term->field_0x38 = bVar4 & 0xfd | bVar21;
  *(byte *)&term->field_0x38 = bVar4 & 0xf9 | bVar21 | ((driver->opt).charsets[0] != -1) << 2;
LAB_080e073b:
  psVar16 = init_string(&image);
  if (psVar16 == (string *)0x0) goto LAB_080e0cb5;
  puVar8 = (undefined *)(driver->opt).color_mode;
  if (puVar8 == (undefined *)0x2) {
    ptVar9 = term->screen;
    uVar10 = ptVar9->dirty_from;
    iVar17 = term->width;
    uVar1 = iVar17 - 1;
    u_00 = term->height - 1;
    if ((int)u_00 < ptVar9->dirty_to) {
      ptVar9->dirty_to = u_00;
    }
    if (ptVar9->dirty_to < (int)uVar10) goto LAB_080e26b5;
    u = 0xffffffff;
    local_80 = 0xff;
    local_88 = ptVar9->last_image + iVar17 * uVar10;
    local_74 = ptVar9->image + iVar17 * uVar10;
    psVar23 = (screen_char *)0x0;
    bVar4 = 0;
    bVar21 = 0xff;
    uVar13 = -1;
    do {
      local_98 = uVar10 + 1;
      if ((-1 < (int)uVar1) && ((u_00 != uVar10 || (iVar17 != 1)))) {
        local_84 = 1;
LAB_080e1f18:
        if (local_74->color[1] == local_88->color[1]) {
          if (local_74->color[0] == local_88->color[0]) {
            local_60 = local_74->data;
            if ((local_60 != local_88->data) || (local_74->attr != local_88->attr))
            goto LAB_080e2632;
          }
          else {
            local_60 = local_74->data;
LAB_080e2632:
            if (((0x20 < local_60) || (0x20 < local_88->data)) || (local_74->attr != local_88->attr)
               ) goto LAB_080e1f2e;
          }
        }
        else {
LAB_080e1f2e:
          if ((uVar10 != u) || (psVar23 + 10 <= local_74)) {
            local_40 = 2;
            code[0] = '\x1b';
            code[1] = '[';
            length = elinks_ulongcat(code,&local_40,local_98,'\n',0,10);
            psVar23 = local_74;
            if (-1 < length) {
              code[local_40] = ';';
              local_40 = local_40 + 1;
              length = elinks_ulongcat(code,&local_40,local_84,'\n',0,10);
              if (-1 < length) {
                u = local_40 + 1;
                code[local_40] = 'H';
                local_40 = u;
                add_bytes_to_string__(&image,code,u);
              }
            }
LAB_080e1f58:
            do {
              bVar22 = *(byte *)&(driver->opt).field_0x18;
              bVar14 = psVar23->attr;
              if (((bVar22 & 2) == 0) || (psVar23->data != 0xfffffffd)) {
                bVar5 = bVar4 ^ bVar14;
                if (bVar5 != 0) {
                  if (((char)bVar5 < '\0') &&
                     (psVar16 = (driver->opt).frame_seqs, psVar16 != (string *)0x0)) {
                    local_80 = bVar14 >> 7;
                    psVar16 = psVar16 + local_80;
                    add_bytes_to_string__(&image,psVar16->source,psVar16->length);
                    bVar14 = psVar23->attr;
                  }
                  if (((bVar5 & 0x20) != 0) &&
                     (psVar16 = (driver->opt).underline, psVar16 != (string *)0x0)) {
                    ppuVar2 = (uchar **)((int)&psVar16->source + ((uint)(bVar14 >> 2) & 8));
                    add_bytes_to_string__(&image,*ppuVar2,(int)ppuVar2[1]);
                    bVar14 = psVar23->attr;
                  }
                  bVar4 = bVar14;
                  if ((bVar5 & 8) != 0) {
                    if ((bVar14 & 8) == 0) {
                      bVar21 = psVar23->color[0] + 1;
                    }
                    else {
                      add_bytes_to_string__(&image,"\x1b[1m",4);
                      bVar4 = psVar23->attr;
                    }
                  }
                  bVar22 = *(byte *)&(driver->opt).field_0x18;
                }
                local_6c = bVar22 & 2;
                if ((local_6c != 0) && (psVar23->data == 0xfffffffd)) goto LAB_080e2360;
                bVar14 = psVar23->color[0];
                if (bVar21 == bVar14) {
                  uVar3 = psVar23->color[1];
                  if (uVar3 != uVar13) goto LAB_080e200a;
                  bVar5 = psVar23->attr;
                  u = psVar23->data;
                  uVar13 = uVar3;
                }
                else {
                  uVar3 = psVar23->color[1];
LAB_080e200a:
                  length = 0;
                  do {
                    iVar20 = length;
                    length = iVar20 + 1;
                  } while ((&DAT_081339b1)[iVar20] != '%');
                  add_bytes_to_string__(&image,"\x1b[0;38;5;%dm",iVar20 + 1);
                  if (bVar14 < 10) {
                    local_78 = (screen_char *)(code_1 + 2);
                    length = 1;
                    local_bd = bVar14;
                  }
                  else {
                    if (bVar14 < 100) {
                      local_78 = (screen_char *)(code_1 + 1);
                      length = 2;
                      bVar21 = bVar14;
                    }
                    else {
                      if (bVar14 < 200) {
                        local_78 = (screen_char *)code_1;
                        length = 3;
                        code_1._0_4_ = CONCAT31(code_1._1_3_,0x31);
                        bVar21 = bVar14 + 0x9c;
                      }
                      else {
                        local_78 = (screen_char *)code_1;
                        length = 3;
                        code_1._0_4_ = CONCAT31(code_1._1_3_,0x32);
                        bVar21 = bVar14 + 0x38;
                      }
                    }
                    code_1._0_2_ = CONCAT11(bVar21 / 10 + 0x30,code_1[0]);
                    code_1._0_4_ = code_1._0_4_ & 0xffff0000 | (uint)code_1._0_2_;
                    local_bd = bVar21 % 10;
                  }
                  code_1._0_3_ = CONCAT12(local_bd + 0x30,code_1._0_2_);
                  code_1._0_4_ = code_1._0_4_ & 0xff000000 | (uint)code_1._0_3_;
                  add_bytes_to_string__(&image,(uchar *)local_78,length);
                  add_bytes_to_string__(&image,(uchar *)(";38;5;%dm" + iVar20),0xc - (iVar20 + 3));
                  if ((*(byte *)&(driver->opt).field_0x18 & 1) == 0) {
                    local_bd = psVar23->color[1];
LAB_080e20e2:
                    length = 0;
                    do {
                      iVar20 = length;
                      length = iVar20 + 1;
                    } while ((&DAT_081339be)[iVar20] != '%');
                    add_bytes_to_string__(&image,"\x1b[48;5;%dm",iVar20 + 1);
                    if (local_bd < 10) {
                      local_7c = code_1 + 2;
                      length = 1;
                    }
                    else {
                      length = 2;
                      local_7c = code_1 + 1;
                      if (99 < local_bd) {
                        if (local_bd < 200) {
                          local_bd = local_bd + 0x9c;
                          length = 3;
                          local_7c = code_1;
                          code_1._0_4_ = CONCAT31(code_1._1_3_,0x31);
                        }
                        else {
                          local_7c = code_1;
                          length = 3;
                          code_1._0_4_ = CONCAT31(code_1._1_3_,0x32);
                          local_bd = local_bd + 0x38;
                        }
                      }
                      bVar21 = local_bd / 10;
                      local_bd = local_bd % 10;
                      code_1._0_2_ = CONCAT11(bVar21 + 0x30,code_1[0]);
                      code_1._0_4_ = code_1._0_4_ & 0xffff0000 | (uint)code_1._0_2_;
                    }
                    code_1._0_3_ = CONCAT12(local_bd + 0x30,code_1._0_2_);
                    code_1._0_4_ = code_1._0_4_ & 0xff000000 | (uint)code_1._0_3_;
                    add_bytes_to_string__(&image,local_7c,length);
                    add_bytes_to_string__(&image,(uchar *)("8;5;%dm" + iVar20),10 - (iVar20 + 3));
                  }
                  else {
                    local_bd = psVar23->color[1];
                    if (local_bd != 0) goto LAB_080e20e2;
                  }
                  bVar5 = psVar23->attr;
                  if ((bVar5 & 8) != 0) {
                    add_bytes_to_string__(&image,"\x1b[1m",4);
                    bVar5 = psVar23->attr;
                  }
                  uVar13 = uVar3;
                  bVar21 = bVar14;
                  if ((bVar5 & 0x20) != 0) {
                    psVar16 = (driver->opt).underline;
                    if (psVar16 == (string *)0x0) {
                      u = psVar23->data;
                      bVar22 = *(byte *)&(driver->opt).field_0x18;
                      goto LAB_080e2207;
                    }
                    add_bytes_to_string__(&image,psVar16[1].source,psVar16[1].length);
                    bVar5 = psVar23->attr;
                  }
                  u = psVar23->data;
                  bVar22 = *(byte *)&(driver->opt).field_0x18;
                }
              }
              else {
LAB_080e2360:
                bVar5 = psVar23->attr;
                u = 0xfffffffd;
              }
LAB_080e2207:
              if (((((bVar5 & 0x80) != 0) && (name = (driver->opt).frame, 0xaf < u)) &&
                  (name != (uchar *)0x0)) && (u < 0xe0)) {
                u = (uint)name[u - 0xb0];
              }
              if ((bVar22 & 2) == 0) {
                if ((driver->opt).charsets[0] == -1) {
                  if (((bVar5 & 0x80) == 0) && ((u == 0x7f || (u < 0x20)))) {
                    add_char_to_string(&image,' ');
                  }
                  else {
                    add_char_to_string(&image,(uchar)u);
                  }
                }
                else {
                  if (((bVar5 & 0x80) == 0) && ((u == 0x7f || (u < 0x20)))) {
                    add_char_to_string(&image,' ');
                  }
                  else {
                    name = cp2utf8(*(int *)((int)(driver->opt).charsets +
                                           (~-(uint)((bVar5 & 0x80) == 0) & 4)),u);
                    add_to_string(&image,name);
                  }
                }
              }
              else {
                if ((bVar5 & 0x80) != 0) {
                  u = cp2u((driver->opt).charsets[1],(uchar)u);
                }
                if (u != 0xfffffffd) {
                  if ((0x5e < u - 0x20) && (u < 0xa0)) {
                    u = 0x20;
                  }
                  name = encode_utf8(u);
                  add_to_string(&image,name);
                }
              }
              if (local_74 < psVar23 + 1) goto LAB_080e22e4;
              psVar23 = psVar23 + 1;
            } while( true );
          }
          u = uVar10;
          if (psVar23 <= local_74) goto LAB_080e1f58;
        }
        goto LAB_080e22f1;
      }
LAB_080e232a:
      uVar10 = local_98;
    } while ((int)local_98 <= ptVar9->dirty_to);
  }
  else {
    if ((int)puVar8 < 3) {
      if (puVar8 == (undefined *)0xffffffff) {
LAB_080e0cfe:
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c";
        errline = 0x443;
        elinks_internal((uchar *)"Invalid color mode (%d).",(driver->opt).color_mode);
        goto LAB_080e0cb5;
      }
    }
    else {
      if (puVar8 == (undefined *)0x3) {
        ptVar9 = term->screen;
        iVar17 = term->width;
        uVar10 = ptVar9->dirty_from;
        uVar1 = iVar17 - 1;
        u = term->height - 1;
        u_00 = ptVar9->dirty_to;
        if ((int)u < ptVar9->dirty_to) {
          ptVar9->dirty_to = u;
          u_00 = u;
        }
        if ((int)u_00 < (int)uVar10) goto LAB_080e26b5;
        u_00 = 0xffffffff;
        local_80 = 0xff;
        bVar4 = 0;
        local_88 = ptVar9->last_image + iVar17 * uVar10;
        local_74 = ptVar9->image + iVar17 * uVar10;
        psVar23 = (screen_char *)0x0;
        bVar21 = 0xff;
        uVar13 = -1;
        do {
          local_98 = uVar10 + 1;
          if ((-1 < (int)uVar1) && ((u != uVar10 || (iVar17 != 1)))) {
            local_84 = 1;
LAB_080e16a0:
            if (local_74->color[1] == local_88->color[1]) {
              if (local_74->color[0] == local_88->color[0]) {
                local_60 = local_74->data;
                if ((local_60 != local_88->data) || (local_74->attr != local_88->attr))
                goto LAB_080e1dba;
              }
              else {
                local_60 = local_74->data;
LAB_080e1dba:
                if (((0x20 < local_60) || (0x20 < local_88->data)) ||
                   (local_74->attr != local_88->attr)) goto LAB_080e16b6;
              }
            }
            else {
LAB_080e16b6:
              if ((u_00 != uVar10) || (psVar23 + 10 <= local_74)) {
                local_40 = 2;
                code[0] = '\x1b';
                code[1] = '[';
                length = elinks_ulongcat(code,&local_40,local_98,'\n',0,10);
                psVar23 = local_74;
                if (-1 < length) {
                  code[local_40] = ';';
                  local_40 = local_40 + 1;
                  length = elinks_ulongcat(code,&local_40,local_84,'\n',0,10);
                  if (-1 < length) {
                    u_00 = local_40 + 1;
                    code[local_40] = 'H';
                    local_40 = u_00;
                    add_bytes_to_string__(&image,code,u_00);
                  }
                }
LAB_080e16e0:
                do {
                  bVar22 = *(byte *)&(driver->opt).field_0x18;
                  bVar14 = psVar23->attr;
                  if (((bVar22 & 2) == 0) || (psVar23->data != 0xfffffffd)) {
                    bVar5 = bVar4 ^ bVar14;
                    if (bVar5 != 0) {
                      if (((char)bVar5 < '\0') &&
                         (psVar16 = (driver->opt).frame_seqs, psVar16 != (string *)0x0)) {
                        local_80 = bVar14 >> 7;
                        psVar16 = psVar16 + local_80;
                        add_bytes_to_string__(&image,psVar16->source,psVar16->length);
                        bVar14 = psVar23->attr;
                      }
                      if (((bVar5 & 0x20) != 0) &&
                         (psVar16 = (driver->opt).underline, psVar16 != (string *)0x0)) {
                        ppuVar2 = (uchar **)((int)&psVar16->source + ((uint)(bVar14 >> 2) & 8));
                        add_bytes_to_string__(&image,*ppuVar2,(int)ppuVar2[1]);
                        bVar14 = psVar23->attr;
                      }
                      bVar4 = bVar14;
                      if ((bVar5 & 8) != 0) {
                        if ((bVar14 & 8) == 0) {
                          bVar21 = psVar23->color[0] + 1;
                        }
                        else {
                          add_bytes_to_string__(&image,"\x1b[1m",4);
                          bVar4 = psVar23->attr;
                        }
                      }
                      bVar22 = *(byte *)&(driver->opt).field_0x18;
                    }
                    local_6c = bVar22 & 2;
                    if ((local_6c != 0) && (psVar23->data == 0xfffffffd)) goto LAB_080e1ae8;
                    bVar14 = psVar23->color[0];
                    if (bVar21 == bVar14) {
                      uVar3 = psVar23->color[1];
                      if (uVar3 != uVar13) goto LAB_080e1792;
                      bVar5 = psVar23->attr;
                      u_00 = psVar23->data;
                      uVar13 = uVar3;
                    }
                    else {
                      uVar3 = psVar23->color[1];
LAB_080e1792:
                      length = 0;
                      do {
                        iVar20 = length;
                        length = iVar20 + 1;
                      } while ((&DAT_081339b1)[iVar20] != '%');
                      add_bytes_to_string__(&image,"\x1b[0;38;5;%dm",iVar20 + 1);
                      if (bVar14 < 10) {
                        local_78 = (screen_char *)(code_1 + 2);
                        length = 1;
                        local_bd = bVar14;
                      }
                      else {
                        if (bVar14 < 100) {
                          local_78 = (screen_char *)(code_1 + 1);
                          length = 2;
                          bVar21 = bVar14;
                        }
                        else {
                          if (bVar14 < 200) {
                            local_78 = (screen_char *)code_1;
                            length = 3;
                            code_1._0_4_ = CONCAT31(code_1._1_3_,0x31);
                            bVar21 = bVar14 + 0x9c;
                          }
                          else {
                            local_78 = (screen_char *)code_1;
                            length = 3;
                            code_1._0_4_ = CONCAT31(code_1._1_3_,0x32);
                            bVar21 = bVar14 + 0x38;
                          }
                        }
                        code_1._0_2_ = CONCAT11(bVar21 / 10 + 0x30,code_1[0]);
                        code_1._0_4_ = code_1._0_4_ & 0xffff0000 | (uint)code_1._0_2_;
                        local_bd = bVar21 % 10;
                      }
                      code_1._0_3_ = CONCAT12(local_bd + 0x30,code_1._0_2_);
                      code_1._0_4_ = code_1._0_4_ & 0xff000000 | (uint)code_1._0_3_;
                      add_bytes_to_string__(&image,(uchar *)local_78,length);
                      add_bytes_to_string__
                                (&image,(uchar *)(";38;5;%dm" + iVar20),0xc - (iVar20 + 3));
                      if ((*(byte *)&(driver->opt).field_0x18 & 1) == 0) {
                        local_bd = psVar23->color[1];
LAB_080e186a:
                        length = 0;
                        do {
                          iVar20 = length;
                          length = iVar20 + 1;
                        } while ((&DAT_081339be)[iVar20] != '%');
                        add_bytes_to_string__(&image,"\x1b[48;5;%dm",iVar20 + 1);
                        if (local_bd < 10) {
                          local_7c = code_1 + 2;
                          length = 1;
                        }
                        else {
                          length = 2;
                          local_7c = code_1 + 1;
                          if (99 < local_bd) {
                            if (local_bd < 200) {
                              local_bd = local_bd + 0x9c;
                              length = 3;
                              local_7c = code_1;
                              code_1._0_4_ = CONCAT31(code_1._1_3_,0x31);
                            }
                            else {
                              local_7c = code_1;
                              length = 3;
                              code_1._0_4_ = CONCAT31(code_1._1_3_,0x32);
                              local_bd = local_bd + 0x38;
                            }
                          }
                          bVar21 = local_bd / 10;
                          local_bd = local_bd % 10;
                          code_1._0_2_ = CONCAT11(bVar21 + 0x30,code_1[0]);
                          code_1._0_4_ = code_1._0_4_ & 0xffff0000 | (uint)code_1._0_2_;
                        }
                        code_1._0_3_ = CONCAT12(local_bd + 0x30,code_1._0_2_);
                        code_1._0_4_ = code_1._0_4_ & 0xff000000 | (uint)code_1._0_3_;
                        add_bytes_to_string__(&image,local_7c,length);
                        add_bytes_to_string__
                                  (&image,(uchar *)("8;5;%dm" + iVar20),10 - (iVar20 + 3));
                      }
                      else {
                        local_bd = psVar23->color[1];
                        if (local_bd != 0) goto LAB_080e186a;
                      }
                      bVar5 = psVar23->attr;
                      if ((bVar5 & 8) != 0) {
                        add_bytes_to_string__(&image,"\x1b[1m",4);
                        bVar5 = psVar23->attr;
                      }
                      uVar13 = uVar3;
                      bVar21 = bVar14;
                      if ((bVar5 & 0x20) != 0) {
                        psVar16 = (driver->opt).underline;
                        if (psVar16 == (string *)0x0) {
                          u_00 = psVar23->data;
                          bVar22 = *(byte *)&(driver->opt).field_0x18;
                          goto LAB_080e198f;
                        }
                        add_bytes_to_string__(&image,psVar16[1].source,psVar16[1].length);
                        bVar5 = psVar23->attr;
                      }
                      u_00 = psVar23->data;
                      bVar22 = *(byte *)&(driver->opt).field_0x18;
                    }
                  }
                  else {
LAB_080e1ae8:
                    bVar5 = psVar23->attr;
                    u_00 = 0xfffffffd;
                  }
LAB_080e198f:
                  if (((((bVar5 & 0x80) != 0) && (name = (driver->opt).frame, 0xaf < u_00)) &&
                      (name != (uchar *)0x0)) && (u_00 < 0xe0)) {
                    u_00 = (uint)name[u_00 - 0xb0];
                  }
                  if ((bVar22 & 2) == 0) {
                    if ((driver->opt).charsets[0] == -1) {
                      if (((bVar5 & 0x80) == 0) && ((u_00 == 0x7f || (u_00 < 0x20)))) {
                        add_char_to_string(&image,' ');
                      }
                      else {
                        add_char_to_string(&image,(uchar)u_00);
                      }
                    }
                    else {
                      if (((bVar5 & 0x80) == 0) && ((u_00 == 0x7f || (u_00 < 0x20)))) {
                        add_char_to_string(&image,' ');
                      }
                      else {
                        name = cp2utf8(*(int *)((int)(driver->opt).charsets +
                                               (~-(uint)((bVar5 & 0x80) == 0) & 4)),u_00);
                        add_to_string(&image,name);
                      }
                    }
                  }
                  else {
                    if ((bVar5 & 0x80) != 0) {
                      u_00 = cp2u((driver->opt).charsets[1],(uchar)u_00);
                    }
                    if (u_00 != 0xfffffffd) {
                      if ((0x5e < u_00 - 0x20) && (u_00 < 0xa0)) {
                        u_00 = 0x20;
                      }
                      name = encode_utf8(u_00);
                      add_to_string(&image,name);
                    }
                  }
                  if (local_74 < psVar23 + 1) goto LAB_080e1a6c;
                  psVar23 = psVar23 + 1;
                } while( true );
              }
              if (psVar23 <= local_74) goto LAB_080e16e0;
            }
            goto LAB_080e1a79;
          }
LAB_080e1ab2:
          uVar10 = local_98;
        } while ((int)local_98 <= ptVar9->dirty_to);
        goto LAB_080e0b28;
      }
      if (puVar8 == &DAT_00000005) goto LAB_080e0cfe;
    }
    ptVar9 = term->screen;
    iVar17 = term->width;
    uVar10 = ptVar9->dirty_from;
    uVar1 = iVar17 - 1;
    u_00 = term->height - 1;
    if ((int)u_00 < ptVar9->dirty_to) {
      ptVar9->dirty_to = u_00;
    }
    if (ptVar9->dirty_to < (int)uVar10) {
LAB_080e26b5:
      local_80 = 0xff;
    }
    else {
      local_80 = 0xff;
      local_64 = 0xff;
      local_88 = ptVar9->last_image + iVar17 * uVar10;
      local_78 = ptVar9->image + iVar17 * uVar10;
      psVar23 = (screen_char *)0x0;
      bVar4 = 0xff;
      uVar13 = -1;
      local_60 = 0xffffffff;
      do {
        local_98 = uVar10 + 1;
        if ((-1 < (int)uVar1) && ((uVar10 != u_00 || (iVar17 != 1)))) {
          local_84 = 1;
          do {
            if (((local_78->color[0] ^ local_88->color[0]) >> 4 & 7) != 0) goto LAB_080e08c0;
            if (((local_88->color[0] ^ local_78->color[0]) & 7) == 0) {
              u = local_78->data;
              if ((u != local_88->data) || (local_78->attr != local_88->attr)) goto LAB_080e088b;
            }
            else {
              u = local_78->data;
LAB_080e088b:
              if ((0x20 < u) || ((0x20 < local_88->data || (local_78->attr != local_88->attr)))) {
LAB_080e08c0:
                if ((uVar10 != local_60) || (psVar23 + 10 <= local_78)) {
                  local_40 = 2;
                  code[0] = '\x1b';
                  code[1] = '[';
                  length = elinks_ulongcat(code,&local_40,local_98,'\n',0,10);
                  psVar23 = local_78;
                  if (length < 0) goto LAB_080e093a;
                  code[local_40] = ';';
                  local_40 = local_40 + 1;
                  length = elinks_ulongcat(code,&local_40,local_84,'\n',0,10);
                  if (length < 0) goto LAB_080e093a;
                  code[local_40] = 'H';
                  local_40 = local_40 + 1;
                  add_bytes_to_string__(&image,code,local_40);
                  goto LAB_080e093a;
                }
joined_r0x080e08e7:
                do {
                  local_60 = uVar10;
                  if (local_78 < psVar23) break;
LAB_080e093a:
                  bVar21 = psVar23->attr;
                  bVar25 = bVar21 & 0x80;
                  u = (uint)bVar21;
                  bVar22 = bVar21 & 0x20;
                  bVar5 = bVar21 & 8;
                  bVar14 = *(byte *)&(driver->opt).field_0x18;
                  bVar19 = bVar14 & 2;
                  if (((bVar14 & 2) == 0) || (psVar23->data != 0xfffffffd)) {
                    if (bVar25 == local_80) {
LAB_080e0d5b:
                      local_80 = bVar21 & 0x80;
                    }
                    else {
                      psVar16 = (driver->opt).frame_seqs;
                      if (psVar16 != (string *)0x0) {
                        if (bVar25 != 0) {
                          psVar16 = psVar16 + 1;
                        }
                        __n = psVar16->length;
                        name = psVar16->source;
                        if (assert_failed == 0) {
                          if ((name == (uchar *)0x0) || ((int)__n < 0)) {
                            assert_failed = 1;
                            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                            errline = 0xff;
                            elinks_internal((uchar *)
                                            "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                                           );
                            if (assert_failed != 0) goto LAB_080e0994;
                          }
                          else {
                            assert_failed = 0;
                          }
                          if (__n != 0) {
                            length = image.length + __n;
                            size = length + 0x100U & 0xffffff00;
                            size_00 = image.length + 0xffU & 0xffffff00;
                            if (size_00 < size) {
                              puVar18 = (uchar *)mem_realloc(image.source,size);
                              if (puVar18 == (uchar *)0x0) goto LAB_080e0d50;
                              image.source = puVar18;
                              memset(puVar18 + size_00,0,size - size_00);
                            }
                            if (image.source != (uchar *)0x0) {
                              memcpy(image.source + image.length,name,__n);
                              image.source[length] = '\0';
                              image.length = length;
                            }
                          }
LAB_080e0d50:
                          bVar14 = *(byte *)&(driver->opt).field_0x18;
                          bVar19 = bVar14 & 2;
                          goto LAB_080e0d5b;
                        }
LAB_080e0994:
                        assert_failed = 0;
                        bVar14 = *(byte *)&(driver->opt).field_0x18;
                        local_80 = bVar21 & 0x80;
                        bVar19 = bVar14 & 2;
                      }
                    }
                    if ((bVar19 != 0) && (psVar23->data == 0xfffffffd)) goto LAB_080e0d70;
                    if (bVar22 == (byte)local_64) {
LAB_080e0da6:
                      local_64 = u & 0x20;
                      length = image.length;
                    }
                    else {
                      psVar16 = (driver->opt).underline;
                      length = image.length;
                      if (psVar16 != (string *)0x0) {
                        if (bVar22 != 0) {
                          psVar16 = psVar16 + 1;
                        }
                        __n = psVar16->length;
                        name = psVar16->source;
                        if (assert_failed == 0) {
                          if ((name == (uchar *)0x0) || ((int)__n < 0)) {
                            assert_failed = 1;
                            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                            errline = 0xff;
                            elinks_internal((uchar *)
                                            "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                                           );
                            if (assert_failed != 0) goto LAB_080e09e7;
                          }
                          else {
                            assert_failed = 0;
                          }
                          if (__n != 0) {
                            length = image.length + __n;
                            size = length + 0x100U & 0xffffff00;
                            local_64 = image.length + 0xffU & 0xffffff00;
                            if (local_64 < size) {
                              puVar18 = (uchar *)mem_realloc(image.source,size);
                              if (puVar18 == (uchar *)0x0) goto LAB_080e0da2;
                              image.source = puVar18;
                              memset(puVar18 + local_64,0,size - local_64);
                            }
                            if (image.source != (uchar *)0x0) {
                              memcpy(image.source + image.length,name,__n);
                              image.source[length] = '\0';
                              local_64 = local_64 | u & 0x20;
                              bVar14 = *(byte *)&(driver->opt).field_0x18;
                              goto joined_r0x080e0db0;
                            }
                          }
LAB_080e0da2:
                          bVar14 = *(byte *)&(driver->opt).field_0x18;
                          goto LAB_080e0da6;
                        }
LAB_080e09e7:
                        assert_failed = 0;
                        local_64 = u & 0x20;
                        bVar14 = *(byte *)&(driver->opt).field_0x18;
                        length = image.length;
                      }
                    }
joined_r0x080e0db0:
                    image.length = length;
                    if (((bVar14 & 2) != 0) && (psVar23->data == 0xfffffffd)) goto LAB_080e0d70;
                    if (bVar4 != bVar5) {
                      if (bVar5 == 0) {
                        bVar4 = 0;
                        uVar13 = psVar23->color[0] + '\x01';
                      }
                      else {
                        if (assert_failed == 0) {
                          assert_failed = 0;
                          size_00 = length + 0x104U & 0xffffff00;
                          u = length + 0xffU >> 8;
                          size = length + 0xffU & 0xffffff00;
                          if (size_00 < size || size_00 + u * -0x100 == 0) {
joined_r0x080e1352:
                            if (image.source != (uchar *)0x0) {
                              *(undefined4 *)(image.source + image.length) = 0x6d315b1b;
                              image.source[length + 4] = '\0';
                              bVar4 = bVar21 & 8;
                              bVar14 = *(byte *)&(driver->opt).field_0x18;
                              image.length = length + 4;
                              goto LAB_080e0a27;
                            }
                          }
                          else {
                            name = (uchar *)mem_realloc(image.source,size_00);
                            if (name != (uchar *)0x0) {
                              image.source = name;
                              memset(name + size,0,size_00 + u * -0x100);
                              goto joined_r0x080e1352;
                            }
                          }
                          bVar4 = bVar21 & 8;
                          bVar14 = *(byte *)&(driver->opt).field_0x18;
                        }
                        else {
                          assert_failed = 0;
                          bVar4 = bVar21 & 8;
                          bVar14 = *(byte *)&(driver->opt).field_0x18;
                        }
                      }
                    }
LAB_080e0a27:
                    length = image.length;
                    if (((bVar14 & 2) != 0) && (psVar23->data == 0xfffffffd)) goto LAB_080e0d70;
                    uVar3 = psVar23->color[0];
                    if (uVar13 == uVar3) {
                      u = psVar23->data;
                    }
                    else {
                      if (assert_failed == 0) {
                        assert_failed = 0;
                        iVar20 = image.length + 3;
                        size_00 = image.length + 0x103U & 0xffffff00;
                        u = image.length + 0xffU >> 8;
                        size = image.length + 0xffU & 0xffffff00;
                        if (size_00 < size || size_00 + u * -0x100 == 0) {
LAB_080e0e04:
                          if (image.source != (uchar *)0x0) {
                            *(undefined2 *)(image.source + image.length) = 0x5b1b;
                            (image.source + image.length)[1] = 0x30;
                            image.source[length + 3] = '\0';
                            image.length = iVar20;
                          }
                        }
                        else {
                          name = (uchar *)mem_realloc(image.source,size_00);
                          if (name != (uchar *)0x0) {
                            image.source = name;
                            memset(name + size,0,size_00 + u * -0x100);
                            goto LAB_080e0e04;
                          }
                        }
                        if ((driver->opt).color_mode != COLOR_MODE_MONO) goto LAB_080e0e30;
LAB_080e0f2d:
                        if ((psVar23->attr & 0x40) != 0) {
                          add_bytes_to_string__(&image,";7",2);
                        }
                      }
                      else {
                        assert_failed = 0;
                        if ((driver->opt).color_mode == COLOR_MODE_MONO) goto LAB_080e0f2d;
LAB_080e0e30:
                        code_1._4_2_ = 0x3034;
                        bVar21 = psVar23->color[0] >> 4;
                        code_1._0_3_ = CONCAT12((psVar23->color[0] & 7) + 0x30,0x333b);
                        code_1._0_4_ = CONCAT13(0x3b,code_1._0_3_);
                        if (((bVar21 & 7) == 0) && ((*(byte *)&(driver->opt).field_0x18 & 1) != 0))
                        {
                          add_bytes_to_string__(&image,code_1,3);
                        }
                        else {
                          code_1._4_2_ = CONCAT11((bVar21 & 7) + 0x30,0x34);
                          add_bytes_to_string__(&image,code_1,6);
                        }
                      }
                      length = image.length;
                      if ((bVar22 != 0) && ((driver->opt).underline != (string *)0x0)) {
                        if (assert_failed == 0) {
                          assert_failed = 0;
                          iVar20 = image.length + 2;
                          size_00 = image.length + 0x102U & 0xffffff00;
                          u = image.length + 0xffU >> 8;
                          size = image.length + 0xffU & 0xffffff00;
                          if (size <= size_00 && size_00 + u * -0x100 != 0) {
                            name = (uchar *)mem_realloc(image.source,size_00);
                            if (name == (uchar *)0x0) goto LAB_080e0ed5;
                            image.source = name;
                            memset(name + size,0,size_00 + u * -0x100);
                          }
                          if (image.source != (uchar *)0x0) {
                            *(undefined2 *)(image.source + image.length) = 0x343b;
                            image.source[length + 2] = '\0';
                            image.length = iVar20;
                          }
                        }
                        else {
                          assert_failed = 0;
                        }
                      }
LAB_080e0ed5:
                      if (bVar5 != 0) {
                        add_bytes_to_string__(&image,";1",2);
                      }
                      add_bytes_to_string__(&image,"m",1);
                      u = psVar23->data;
                      bVar14 = *(byte *)&(driver->opt).field_0x18;
                      uVar13 = uVar3;
                    }
                  }
                  else {
LAB_080e0d70:
                    u = 0xfffffffd;
                  }
                  if ((((bVar25 != 0) && (name = (driver->opt).frame, 0xaf < u)) &&
                      (name != (uchar *)0x0)) && (u < 0xe0)) {
                    u = (uint)name[u - 0xb0];
                  }
                  if ((bVar14 & 2) == 0) {
                    if ((driver->opt).charsets[0] == -1) {
                      if ((bVar25 == 0) && ((u == 0x7f || (u < 0x20)))) {
                        add_char_to_string(&image,' ');
                      }
                      else {
                        add_char_to_string(&image,(uchar)u);
                      }
                    }
                    else {
                      if ((bVar25 != 0) || ((u != 0x7f && (0x1f < u)))) {
                        psVar23 = psVar23 + 1;
                        name = cp2utf8(*(int *)((int)(driver->opt).charsets +
                                               (~-(uint)(bVar25 == 0) & 4)),u);
                        add_to_string(&image,name);
                        goto joined_r0x080e08e7;
                      }
                      add_char_to_string(&image,' ');
                    }
                  }
                  else {
                    if (bVar25 != 0) {
                      u = cp2u((driver->opt).charsets[1],(uchar)u);
                    }
                    if (u != 0xfffffffd) {
                      if ((0x5e < u - 0x20) && (u < 0xa0)) {
                        u = 0x20;
                      }
                      name = encode_utf8(u);
                      add_to_string(&image,name);
                    }
                  }
                  psVar23 = psVar23 + 1;
                } while( true );
              }
            }
            local_88 = local_88 + 1;
            local_78 = local_78 + 1;
          } while (((int)local_84 <= (int)uVar1) &&
                  ((u = local_84 + 1, bVar26 = uVar1 != local_84, local_84 = u, bVar26 ||
                   (uVar10 != u_00))));
        }
        uVar10 = local_98;
      } while ((int)local_98 <= ptVar9->dirty_to);
    }
  }
LAB_080e0b28:
  if (image.length == 0) {
LAB_080e1507:
    iVar17 = ptVar6->cx;
    if (iVar17 != ptVar6->lcx) {
      length = ptVar6->cy;
      goto LAB_080e0b7e;
    }
    length = ptVar6->cy;
    if (length != ptVar6->lcy) goto LAB_080e0b7e;
  }
  else {
    if ((driver->opt).color_mode != COLOR_MODE_MONO) {
      add_bytes_to_string__(&image,"\x1b[37;40m",8);
    }
    add_bytes_to_string__(&image,"\x1b[0m",4);
    if ((local_80 != 0) && (psVar16 = (driver->opt).frame_seqs, psVar16 != (string *)0x0)) {
      add_bytes_to_string__(&image,psVar16->source,psVar16->length);
    }
    if (image.length == 0) goto LAB_080e1507;
    iVar17 = ptVar6->cx;
    length = ptVar6->cy;
LAB_080e0b7e:
    ptVar6->lcy = length;
    ptVar6->lcx = iVar17;
    local_40 = 2;
    code[0] = '\x1b';
    code[1] = '[';
    length = elinks_ulongcat(code,&local_40,length + 1,'\n',0,10);
    if (-1 < length) {
      code[local_40] = ';';
      local_40 = local_40 + 1;
      iVar17 = elinks_ulongcat(code,&local_40,iVar17 + 1,'\n',0,10);
      if (-1 < iVar17) {
        code[local_40] = 'H';
        local_40 = local_40 + 1;
        add_bytes_to_string__(&image,code,local_40);
      }
    }
    if (image.length != 0) {
      if ((*(byte *)&term->field_0x38 & 1) != 0) {
        want_draw();
      }
      hard_write(term->fdout,image.source,image.length);
      if ((*(byte *)&term->field_0x38 & 1) != 0) {
        done_draw();
      }
    }
  }
  done_string(&image);
  memcpy(ptVar6->last_image,ptVar6->image,term->height * term->width * 8);
  iVar17 = term->height;
  ptVar6->dirty_to = 0;
  ptVar6->dirty_from = iVar17;
LAB_080e0cb5:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_080e22e4:
  psVar23 = psVar23 + 1;
  u = uVar10;
LAB_080e22f1:
  local_88 = local_88 + 1;
  local_74 = local_74 + 1;
  if (((int)uVar1 < (int)local_84) ||
     ((size = local_84 + 1, bVar26 = uVar1 == local_84, local_84 = size, bVar26 && (u_00 == uVar10))
     )) goto LAB_080e232a;
  goto LAB_080e1f18;
LAB_080e1a6c:
  psVar23 = psVar23 + 1;
  u_00 = uVar10;
LAB_080e1a79:
  local_88 = local_88 + 1;
  local_74 = local_74 + 1;
  if (((int)uVar1 < (int)local_84) ||
     ((size = local_84 + 1, bVar26 = uVar1 == local_84, local_84 = size, bVar26 && (u == uVar10))))
  goto LAB_080e1ab2;
  goto LAB_080e16a0;
}



int number_of_tabs(terminal *term)

{
  list_head_elinks *plVar1;
  list_head_elinks *plVar2;
  int iVar3;
  
  iVar3 = 0;
  plVar2 = (list_head_elinks *)(term->windows).next;
  while (plVar2 != &term->windows) {
    plVar1 = plVar2 + 1;
    plVar2 = (list_head_elinks *)plVar2->next;
    iVar3 = iVar3 + (uint)(plVar1->next == (void *)0x1);
  }
  return iVar3;
}



int get_tab_number(window *window)

{
  int iVar1;
  window *pwVar2;
  window *pwVar3;
  
  pwVar3 = (window *)(window->term->windows).prev;
  pwVar2 = (window *)&window->term->windows;
  if (pwVar3 != pwVar2) {
    iVar1 = 0;
    do {
      while (pwVar3->type != WINDOW_TAB) {
        pwVar3 = pwVar3->prev;
        if (pwVar3 == pwVar2) {
          return 0;
        }
      }
      if (pwVar3 == window) {
        return iVar1;
      }
      pwVar3 = pwVar3->prev;
      iVar1 = iVar1 + 1;
    } while (pwVar3 != pwVar2);
  }
  return 0;
}



int get_tab_number_by_xpos(terminal *term,int xpos)

{
  int iVar1;
  list_head_elinks *plVar2;
  
  plVar2 = (list_head_elinks *)(term->windows).prev;
  if (plVar2 != &term->windows) {
    iVar1 = 0;
    do {
      if (plVar2[1].next == (void *)0x1) {
        if (((int)plVar2[3].next <= xpos) && (xpos < (int)plVar2[3].next + (int)plVar2[3].prev)) {
          return iVar1;
        }
        iVar1 = iVar1 + 1;
      }
      plVar2 = (list_head_elinks *)plVar2->prev;
    } while (&term->windows != plVar2);
  }
  return -1;
}



window * get_tab_by_number(terminal *term,int num)

{
  window *pwVar1;
  window *pwVar2;
  
  pwVar2 = (window *)(term->windows).prev;
  pwVar1 = (window *)&term->windows;
  while (pwVar2 != pwVar1) {
    while (pwVar2->type != WINDOW_TAB) {
      pwVar2 = pwVar2->prev;
      if (pwVar2 == pwVar1) goto LAB_080e2830;
    }
    if (num == 0) break;
    pwVar2 = pwVar2->prev;
    num = num + -1;
  }
LAB_080e2830:
  if (assert_failed == 0) {
    assert_failed = ZEXT14(pwVar2 == pwVar1);
    if (pwVar2 == pwVar1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
      errline = 0x6f;
      elinks_internal((uchar *)
                      "assertion (LIST_OF(struct window) *) win != &term->windows failed: tab number out of range"
                     );
      if (assert_failed != 0) goto LAB_080e2888;
    }
    return pwVar2;
  }
LAB_080e2888:
  assert_failed = 0;
  return (window *)(term->windows).next;
}



void open_uri_in_new_tab(session *ses,uri *uri,int in_background,int based)

{
  window **ppwVar1;
  
  if ((assert_failed == 0) && (assert_failed = ZEXT14(ses == (session *)0x0), ses == (session *)0x0)
     ) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
    errline = 0x105;
    elinks_internal((uchar *)"assertion ses failed!");
  }
  ppwVar1 = &ses->tab;
  if (based == 0) {
    ses = (session *)0x0;
  }
  init_session(ses,(*ppwVar1)->term,uri,in_background);
  return;
}



void open_current_link_in_new_tab(session *ses,int in_background)

{
  int iVar1;
  document_view *doc_view;
  uri *uri;
  link *link;
  
  doc_view = current_frame(ses);
  if (doc_view == (document_view *)0x0) {
LAB_080e2a20:
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
    if (doc_view == (document_view *)0x0) goto LAB_080e2a50;
  }
  else {
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
    if ((doc_view->vs == (view_state *)0x0) || (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
      errline = 0x11d;
      elinks_internal((uchar *)"assertion doc_view->vs && doc_view->document failed!");
      goto LAB_080e2a20;
    }
    assert_failed = 0;
  }
  iVar1 = doc_view->vs->current_link;
  if (((-1 < iVar1) && (iVar1 < doc_view->document->nlinks)) &&
     (link = doc_view->document->links + iVar1, link != (link *)0x0)) {
    uri = get_link_uri(ses,doc_view,link);
    open_uri_in_new_tab(ses,uri,in_background,1);
    if (uri != (uri *)0x0) {
      done_uri(uri);
      return;
    }
    return;
  }
LAB_080e2a50:
  open_uri_in_new_tab(ses,(uri *)0x0,in_background,1);
  return;
}



void delayed_open(void *data)

{
  if ((assert_failed == 0) && (assert_failed = ZEXT14(data == (void *)0x0), data == (void *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
    errline = 0x110;
    elinks_internal((uchar *)"assertion deo failed!");
  }
  open_uri_in_new_tab(*(session **)data,*(uri **)((int)data + 4),0,0);
  done_uri(*(uri **)((int)data + 4));
  mem_free(data);
  return;
}



void really_close_tabs(void *ses_)

{
  terminal *term;
  window *pwVar1;
  window *pwVar2;
  
  term = *(terminal **)(*(int *)((int)ses_ + 8) + 0x14);
  pwVar1 = get_tab_by_number(term,term->current_tab);
  pwVar2 = (window *)(term->windows).next;
  while (pwVar2 != (window *)&term->windows) {
    while (((void *)pwVar2->type != (void *)0x1 || (pwVar2 == pwVar1))) {
      pwVar2 = pwVar2->next;
      if (pwVar2 == (window *)&term->windows) goto LAB_080e2b62;
    }
    if (0 < term->current_tab) {
      term->current_tab = term->current_tab + -1;
    }
    pwVar2 = pwVar2->prev;
    delete_window(pwVar2->next);
    pwVar2 = pwVar2->next;
  }
LAB_080e2b62:
  redraw_terminal(term);
  return;
}



void close_all_tabs_but_current(session *ses)

{
  int *piVar1;
  uchar *in_EDX;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(ses == (session *)0x0);
  if (ses == (session *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
    errline = 0xf0;
    elinks_internal((uchar *)"assertion ses failed!");
    in_EDX = (uchar *)assert_failed;
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  piVar1 = get_opt_(config_options,in_EDX);
  if (*piVar1 == 0) {
    really_close_tabs(ses);
    return;
  }
  msg_box(ses->tab->term,(memory_list *)0x0,0,"Close tab",ALIGN_CENTER,
          (uchar *)"Do you really want to close all except the current tab?",ses,2,&DAT_0812762b,
          really_close_tabs,1,&DAT_08127627,0,2);
  return;
}



void switch_to_tab(terminal *term,int tab,int tabs_count)

{
  list_head_elinks *plVar1;
  terminal_screen *ptVar2;
  int iVar3;
  int *piVar4;
  list_head_elinks *plVar5;
  uchar *in_EDX;
  
  if (tabs_count < 0) {
    plVar5 = (list_head_elinks *)(term->windows).next;
    if (plVar5 != &term->windows) {
      tabs_count = 0;
      do {
        plVar1 = plVar5 + 1;
        plVar5 = (list_head_elinks *)plVar5->next;
        in_EDX = (uchar *)(uint)(plVar1->next == (void *)0x1);
        tabs_count = (int)(in_EDX + tabs_count);
      } while (plVar5 != &term->windows);
      goto LAB_080e2cb6;
    }
LAB_080e2cf8:
    tab = 0;
  }
  else {
LAB_080e2cb6:
    if (tabs_count < 2) goto LAB_080e2cf8;
    piVar4 = get_opt_(config_options,in_EDX);
    if (*piVar4 == 0) {
      if (-1 < tab) {
        if ((int)((uchar *)tabs_count + -1) < tab) {
          tab = (int)((uchar *)tabs_count + -1);
        }
        if ((uchar *)term->current_tab == (uchar *)tab) {
          return;
        }
        goto LAB_080e2d02;
      }
      goto LAB_080e2cf8;
    }
    tab = tab % tabs_count;
    if (tab < 0) {
      tab = (int)((uchar *)tabs_count + tab);
    }
  }
  if ((uchar *)term->current_tab == (uchar *)tab) {
    return;
  }
LAB_080e2d02:
  ptVar2 = term->screen;
  term->current_tab = tab;
  iVar3 = term->height;
  if (0 < ptVar2->dirty_from) {
    ptVar2->dirty_from = 0;
  }
  if (ptVar2->dirty_to < iVar3) {
    ptVar2->dirty_to = iVar3;
  }
  redraw_terminal(term);
  return;
}



void move_current_tab(session *ses,int direction)

{
  list_head_elinks *plVar1;
  terminal *term;
  window *pwVar2;
  list_head_elinks *plVar3;
  window *pwVar4;
  int tab;
  int *piVar5;
  window *pwVar6;
  int iVar7;
  uchar *name;
  int tabs_count;
  char *local_38;
  
  tabs_count = 0;
  term = ses->tab->term;
  plVar3 = (list_head_elinks *)(term->windows).next;
  while (plVar3 != &term->windows) {
    plVar1 = plVar3 + 1;
    plVar3 = (list_head_elinks *)plVar3->next;
    tabs_count = tabs_count + (uint)(plVar1->next == (void *)0x1);
  }
  pwVar4 = get_tab_by_number(term,term->current_tab);
  if ((assert_failed == 0) && (assert_failed = ZEXT14(direction == 0), direction == 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
    errline = 0x131;
    elinks_internal((uchar *)"assertion ses && direction failed!");
  }
  tab = eat_kbd_repeat_count(ses);
  iVar7 = direction * tab;
  if (tab == 0) {
    iVar7 = direction;
  }
  iVar7 = iVar7 + term->current_tab;
  local_38 = "ui.tabs.wraparound";
  piVar5 = get_opt_(config_options,name);
  if (*piVar5 == 0) {
    tab = 0;
    if ((-1 < iVar7) && (tab = tabs_count + -1, iVar7 <= tabs_count + -1)) {
      tab = iVar7;
    }
  }
  else {
    tab = iVar7 % tabs_count;
    if (tab < 0) {
      tab = tab + tabs_count;
    }
  }
  if (assert_failed == 0) {
    if ((tab < 0) || (tabs_count <= tab)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
      errline = 0x13e;
      elinks_internal((uchar *)"assertion 0 <= new_pos && new_pos < tabs failed!",local_38);
    }
    else {
      assert_failed = 0;
    }
  }
  if (term->current_tab != tab) {
    pwVar4->next->prev = pwVar4->prev;
    pwVar4->prev->next = pwVar4->next;
    if (tab == 0) {
      pwVar6 = get_tab_by_number(term,0);
    }
    else {
      pwVar6 = get_tab_by_number(term,tab + -1);
      pwVar6 = pwVar6->prev;
    }
    pwVar2 = pwVar6->next;
    pwVar4->prev = pwVar6;
    pwVar4->next = pwVar2;
    pwVar6->next = pwVar4;
    pwVar4->next->prev = pwVar4;
    switch_to_tab(term,tab,tabs_count);
  }
  return;
}



void really_close_tab(void *ses_)

{
  list_head_elinks *plVar1;
  terminal *term;
  window *pwVar2;
  list_head_elinks *plVar3;
  int tabs_count;
  window *win;
  int iVar4;
  
  term = *(terminal **)(*(int *)((int)ses_ + 8) + 0x14);
  pwVar2 = get_tab_by_number(term,term->current_tab);
  win = *(window **)((int)ses_ + 8);
  if (pwVar2 == win) {
    plVar3 = (list_head_elinks *)(term->windows).next;
    iVar4 = 0;
    tabs_count = -1;
    if (plVar3 != &term->windows) {
      do {
        plVar1 = plVar3 + 1;
        plVar3 = (list_head_elinks *)plVar3->next;
        iVar4 = iVar4 + (uint)(plVar1->next == (void *)0x1);
      } while (plVar3 != &term->windows);
      tabs_count = iVar4 + -1;
    }
    switch_to_tab(term,term->current_tab + -1,tabs_count);
    win = *(window **)((int)ses_ + 8);
  }
  delete_window(win);
  return;
}



void switch_current_tab(session *ses,int direction)

{
  list_head_elinks *plVar1;
  terminal *term;
  list_head_elinks *plVar2;
  int iVar3;
  int tabs_count;
  
  term = ses->tab->term;
  plVar2 = (list_head_elinks *)(term->windows).next;
  if (plVar2 != &term->windows) {
    tabs_count = 0;
    do {
      plVar1 = plVar2 + 1;
      plVar2 = (list_head_elinks *)plVar2->next;
      tabs_count = tabs_count + (uint)(plVar1->next == (void *)0x1);
    } while (plVar2 != &term->windows);
    if (1 < tabs_count) {
      iVar3 = eat_kbd_repeat_count(ses);
      if (iVar3 != 0) {
        direction = direction * iVar3;
      }
      switch_to_tab(term,direction + term->current_tab,tabs_count);
    }
  }
  return;
}



void close_tab(terminal *term,session *ses)

{
  list_head_elinks *plVar1;
  list_head_elinks *plVar2;
  int *piVar3;
  uchar *name;
  
  plVar2 = (list_head_elinks *)(term->windows).next;
  if (plVar2 != &term->windows) {
    name = (uchar *)0x0;
    do {
      plVar1 = plVar2 + 1;
      plVar2 = (list_head_elinks *)plVar2->next;
      name = name + (plVar1->next == (void *)0x1);
    } while (plVar2 != &term->windows);
    if (1 < (int)name) {
      piVar3 = get_opt_(config_options,name);
      if (*piVar3 != 0) {
        msg_box(term,(memory_list *)0x0,0,"Close tab",ALIGN_CENTER,
                (uchar *)"Do you really want to close the current tab?",ses,2,&DAT_0812762b,
                really_close_tab,1,&DAT_08127627,0,2);
        return;
      }
      really_close_tab(ses);
      return;
    }
  }
  query_exit(ses);
  return;
}



window * init_tab(terminal *term,void *data,window_handler_T *handler)

{
  window *pwVar1;
  list_head_elinks *plVar2;
  window *pwVar3;
  window *pwVar4;
  bool bVar5;
  
  pwVar3 = (window *)mem_calloc(1,0x2c);
  if (pwVar3 != (window *)0x0) {
    pwVar3->term = term;
    pwVar3->handler = handler;
    *(byte *)&pwVar3->field_0x28 = *(byte *)&pwVar3->field_0x28 | 1;
    pwVar3->type = WINDOW_TAB;
    pwVar3->data = data;
    plVar2 = (list_head_elinks *)(term->windows).next;
    while (plVar2 != &term->windows) {
      if (plVar2[1].next == (void *)0x1) {
        pwVar4 = (window *)plVar2->prev;
        goto found_pos;
      }
      plVar2 = (list_head_elinks *)plVar2->next;
    }
    if ((assert_failed == 0) &&
       (bVar5 = term->main_menu != (menu *)0x0, assert_failed = ZEXT14(bVar5), bVar5)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
      errline = 0x35;
      elinks_internal((uchar *)"assertion term->main_menu == NULL failed!");
    }
    pwVar4 = (window *)(term->windows).prev;
found_pos:
    pwVar1 = pwVar4->next;
    pwVar3->prev = pwVar4;
    pwVar3->next = pwVar1;
    pwVar4->next = pwVar3;
    pwVar3->next->prev = pwVar3;
  }
  return pwVar3;
}



void close_terminal_pipes(void)

{
  close(terminal_pipe[0]);
  close(terminal_pipe[1]);
  return;
}



int check_terminal_pipes(void)

{
  int iVar1;
  
  iVar1 = c_pipe(terminal_pipe);
  return iVar1;
}



int get_terminal_codepage(terminal *term)

{
  int *piVar1;
  uchar *in_EDX;
  
  piVar1 = get_opt_(term->spec,in_EDX);
  return *piVar1;
}



void close_handle(void *h)

{
  close((int)h);
  set_handlers((int)h,(select_handler_T *)0x0,(select_handler_T *)0x0,(select_handler_T *)0x0,
               (void *)0x0);
  return;
}



void exec_on_terminal(terminal *term,uchar *path,uchar *delete,term_exec fg)

{
  size_t size;
  int fd;
  size_t sVar1;
  size_t sVar2;
  uchar *data;
  
  if (path == (uchar *)0x0) {
    path = "";
  }
  else {
    if (*path == '\0') {
      return;
    }
  }
  if ((*(byte *)&term->field_0x38 & 1) == 0) {
    sVar1 = strlen((char *)delete);
    sVar2 = strlen((char *)path);
    size = sVar1 + 4 + sVar2;
    data = (uchar *)mem_alloc(size);
    if (data != (uchar *)0x0) {
      *data = '\0';
      data[1] = (uchar)fg;
      memcpy(data + 2,path,sVar2 + 1);
      memcpy(data + sVar2 + 3,delete,sVar1 + 1);
      hard_write(term->fdout,data,size);
      mem_free(data);
      return;
    }
  }
  else {
    if (*path == '\0') {
      dispatch_special(delete);
      return;
    }
    if ((fg != TERM_EXEC_BG) && (fd = is_blocked(), fd != 0)) {
      unlink((char *)delete);
      return;
    }
    sVar1 = strlen((char *)delete);
    sVar2 = strlen((char *)path);
    size = sVar1 + 3 + sVar2;
    data = (uchar *)mem_alloc(size);
    if (data != (uchar *)0x0) {
      *data = (uchar)fg;
      memcpy(data + 1,path,sVar2 + 1);
      memcpy(data + sVar2 + 2,delete,sVar1 + 1);
      if (fg == TERM_EXEC_FG) {
        block_itrm();
      }
      fd = start_thread(exec_thread,data,size);
      mem_free(data);
      if (fd == -1) {
        if (fg == TERM_EXEC_FG) {
          unblock_itrm();
          return;
        }
      }
      else {
        if (fg == TERM_EXEC_FG) {
          term->blocked = fd;
          set_handlers(fd,unblock_terminal,(select_handler_T *)0x0,unblock_terminal,term);
          set_handlers(term->fdin,(select_handler_T *)0x0,(select_handler_T *)0x0,destroy_terminal,
                       term);
        }
        else {
          set_handlers(fd,close_handle,(select_handler_T *)0x0,close_handle,(void *)fd);
        }
      }
    }
  }
  return;
}



void do_terminal_function(terminal *term,uchar code,uchar *data)

{
  size_t sVar1;
  uchar *delete;
  
  sVar1 = strlen((char *)data);
  delete = (uchar *)mem_alloc(sVar1 + 2);
  if (delete != (uchar *)0x0) {
    *delete = code;
    memcpy(delete + 1,data,sVar1 + 1);
    exec_on_terminal(term,(uchar *)0x0,delete,TERM_EXEC_BG);
    mem_free(delete);
    return;
  }
  return;
}



int set_terminal_title(terminal *term,uchar *title)

{
  int from;
  int *piVar1;
  uchar *data;
  conv_table *convert_table;
  size_t charslen;
  uchar *name;
  uchar *data_00;
  int local_20;
  
  if ((term->title != (uchar *)0x0) && (from = strcmp((char *)title,(char *)term->title), from == 0)
     ) {
    return 0;
  }
  from = get_terminal_codepage(term);
  piVar1 = get_opt_(term->spec,name);
  if (*piVar1 == 0) {
    piVar1 = get_opt_(term->spec,(uchar *)0x0);
    if (*piVar1 != 0) {
      local_20 = get_cp_index("UTF-8");
      goto LAB_080e36ff;
    }
  }
  else {
    local_20 = get_cp_index((uchar *)"ISO-8859-1");
LAB_080e36ff:
    if (local_20 != from) {
      convert_table = get_translation_table(from,local_20);
      if (convert_table == (conv_table *)0x0) {
        return -1;
      }
      charslen = strlen((char *)title);
      data_00 = convert_string_elinks
                          (convert_table,title,charslen,local_20,CSM_NONE,(int *)0x0,
                           (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
      if (data_00 == (uchar *)0x0) {
        return -1;
      }
      goto LAB_080e3687;
    }
  }
  data_00 = (uchar *)0x0;
  local_20 = from;
LAB_080e3687:
  if (term->title != (uchar *)0x0) {
    mem_free(term->title);
  }
  data = stracpy(title);
  term->title = data;
  data = get_cp_mime_name(local_20);
  do_terminal_function(term,'\x03',data);
  if (data_00 == (uchar *)0x0) {
    do_terminal_function(term,'\x01',title);
  }
  else {
    do_terminal_function(term,'\x01',data_00);
    mem_free(data_00);
  }
  return 0;
}



void exec_shell(terminal *term)

{
  int iVar1;
  uchar *path;
  
  iVar1 = can_open_os_shell(term->environment);
  if (iVar1 != 0) {
    path = get_shell();
    if ((path != (uchar *)0x0) && (*path != '\0')) {
      exec_on_terminal(term,path,"",TERM_EXEC_FG);
      return;
    }
  }
  return;
}



void assert_terminal_ptr_not_dangling(terminal *suspect)

{
  terminal *ptVar1;
  
  if (suspect != (terminal *)0x0) {
    ptVar1 = (terminal *)terminals.next;
    if ((list_head_elinks *)terminals.next != &terminals) {
      do {
        if (suspect == ptVar1) {
          return;
        }
        ptVar1 = ptVar1->next;
      } while (ptVar1 != (terminal *)&terminals);
    }
    if (assert_failed == 0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/terminal.c";
      errline = 0xf2;
      elinks_internal((uchar *)"assertion 0 failed: Dangling pointer to struct terminal");
      return;
    }
  }
  return;
}



void exec_thread(uchar *path,int p)

{
  size_t sVar1;
  
  sVar1 = strlen((char *)(path + 1));
  if (*path == '\x02') {
    setpgid(0,0);
  }
  exe(path + 1);
  if (path[sVar1 + 2] == '\0') {
    return;
  }
  unlink((char *)(path + sVar1 + 2));
  return;
}



void destroy_terminal(terminal *term)

{
  object *poVar1;
  int __fd;
  window *win;
  int *piVar2;
  __pid_t _Var3;
  uchar *name;
  
  bookmark_auto_save_tabs(term);
  detach_downloads_from_terminal(term);
  win = (window *)(term->windows).next;
  term->current_tab = 0;
  while (win != (window *)&term->windows) {
    delete_window(win);
    win = (window *)(term->windows).next;
  }
  if (term->title != (uchar *)0x0) {
    mem_free(term->title);
  }
  if (term->screen != (terminal_screen *)0x0) {
    done_screen(term->screen);
  }
  set_handlers(term->fdin,(select_handler_T *)0x0,(select_handler_T *)0x0,(select_handler_T *)0x0,
               (void *)0x0);
  if (term->interlink != (terminal_interlink *)0x0) {
    mem_free(term->interlink);
  }
  if (term->blocked != -1) {
    close(term->blocked);
    set_handlers(term->blocked,(select_handler_T *)0x0,(select_handler_T *)0x0,
                 (select_handler_T *)0x0,(void *)0x0);
  }
  term->next->prev = term->prev;
  term->prev->next = term->next;
  close(term->fdin);
  __fd = term->fdout;
  if (__fd == 1) {
    unhandle_terminal_signals(term);
    free_all_itrms();
    if (((list_head_elinks *)terminals.next != &terminals) && (_Var3 = fork(), _Var3 != 0)) {
                    // WARNING: Subroutine does not return
      exit(0);
    }
  }
  else {
    if (__fd != term->fdin) {
      close(__fd);
    }
  }
  poVar1 = &term->spec->object;
  poVar1->refcount = poVar1->refcount + -1;
  mem_free(term);
  if (((list_head_elinks *)terminals.next == &terminals) &&
     (piVar2 = get_opt_(config_options,name), *piVar2 == 0)) {
    program.terminate = 1;
    return;
  }
  program.terminate = 0;
  return;
}



void destroy_all_terminals(void)

{
  if ((list_head_elinks *)terminals.next != &terminals) {
    do {
      destroy_terminal((terminal *)terminals.next);
    } while ((list_head_elinks *)terminals.next != &terminals);
  }
  return;
}



void redraw_all_terminals(void)

{
  terminal **pptVar1;
  terminal *term;
  
  term = (terminal *)terminals.next;
  if ((list_head_elinks *)terminals.next != &terminals) {
    do {
      redraw_screen(term);
      pptVar1 = &term->next;
      term = *pptVar1;
    } while (*pptVar1 != (terminal *)&terminals);
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x080e3b40)
// WARNING: Removing unreachable block (ram,0x080e3c28)
// WARNING: Removing unreachable block (ram,0x080e3b4d)
// WARNING: Could not reconcile some variable overlaps

terminal * init_term(int fdin,int fdout)

{
  uint uVar1;
  terminal_screen *ptVar2;
  int iVar3;
  option_elinks *poVar4;
  int *piVar5;
  uchar *name_00;
  terminal *p;
  int in_GS_OFFSET;
  terminal *local_6c;
  code *local_68;
  char *pcVar6;
  uchar name [41];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  name._0_4_ = 0x6d726574;
  name._4_4_ = 0x6c616e69;
  name._8_4_ = 0x2e;
  name[12] = '\0';
  uVar1 = 0;
  do {
    *(undefined4 *)(name + uVar1 + 0xd) = 0;
    uVar1 = uVar1 + 4;
  } while (uVar1 < 0x1c);
  local_68 = (code *)0x158;
  local_6c = (terminal *)0x1;
  p = (terminal *)mem_calloc(1,0x158);
  if (p == (terminal *)0x0) {
    fdin = (int)local_6c;
    if ((list_head_elinks *)terminals.next == &terminals) {
      pcVar6 = "ui.sessions.keep_session_active";
      fdin = (int)config_options;
      piVar5 = get_opt_(config_options,name_00);
      program.terminate = 1;
      local_68 = (code *)pcVar6;
      if (*piVar5 == 0) goto LAB_080e3c0d;
    }
    program.terminate = 0;
  }
  else {
    ptVar2 = init_screen();
    p->screen = ptVar2;
    if (ptVar2 == (terminal_screen *)0x0) {
      fdin = (int)p;
      mem_free(p);
      p = (terminal *)0x0;
    }
    else {
      p->fdout = fdout;
      *(list_head_elinks **)&(p->windows).prev = &p->windows;
      *(list_head_elinks **)&(p->windows).next = &p->windows;
      p->fdin = fdin;
      iVar3 = get_output_handle();
      *(uchar **)&p->blocked = (uchar *)0xffffffff;
      *(byte *)&p->field_0x38 = *(byte *)&p->field_0x38 & 0xfe | fdout == iVar3;
      get_terminal_name(name + 9);
      poVar4 = get_opt_rec(config_options,name);
      p->spec = poVar4;
      (poVar4->object).refcount = (poVar4->object).refcount + 1;
      *(list_head_elinks **)&p->prev = &terminals;
      p->next = terminals.next;
      terminals.next = p;
      p->next->prev = p;
      local_68 = in_term;
      set_handlers(fdin,in_term,(select_handler_T *)0x0,destroy_terminal,p);
    }
  }
LAB_080e3c0d:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return p;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail(fdin,local_68);
}



terminal * attach_terminal(int in,int out,int ctl,void *info,int len)

{
  int iVar1;
  terminal *ptVar2;
  
  iVar1 = set_nonblocking_fd(terminal_pipe[0]);
  if ((-1 < iVar1) && (iVar1 = set_nonblocking_fd(terminal_pipe[1]), -1 < iVar1)) {
    handle_trm(in,out,out,terminal_pipe[1],ctl,info,len,0);
    ptVar2 = init_term(terminal_pipe[0],out);
    if (ptVar2 != (terminal *)0x0) {
      return ptVar2;
    }
    close_terminal_pipes();
    return (terminal *)0x0;
  }
  return (terminal *)0x0;
}



void redraw_terminal(terminal *term)

{
  term_event ev;
  
  ev.info._0_4_ = term->width;
  ev.info._4_4_ = term->height;
  ev.info._8_4_ = 0;
  ev.ev = EVENT_REDRAW;
  term_send_event(term,&ev);
  return;
}



void redraw_terminal_cls(terminal *term)

{
  term_event ev;
  
  ev.info._0_4_ = term->width;
  ev.info._4_4_ = term->height;
  ev.info._8_4_ = 0;
  ev.ev = EVENT_RESIZE;
  term_send_event(term,&ev);
  return;
}



void unblock_terminal(terminal *term)

{
  close_handle((void *)term->blocked);
  term->blocked = -1;
  set_handlers(term->fdin,in_term,(select_handler_T *)0x0,destroy_terminal,term);
  unblock_itrm();
  redraw_terminal_cls(term);
  if (textarea_editor != 0) {
    textarea_edit(1,(terminal *)0x0,(form_state *)0x0,(document_view *)0x0,(link *)0x0);
  }
  return;
}



void cls_redraw_all_terminals(void)

{
  terminal **pptVar1;
  terminal *term;
  
  term = (terminal *)terminals.next;
  if ((list_head_elinks *)terminals.next != &terminals) {
    do {
      redraw_terminal_cls(term);
      pptVar1 = &term->next;
      term = *pptVar1;
    } while (*pptVar1 != (terminal *)&terminals);
  }
  return;
}



void get_parent_ptr(window *win,int *x,int *y)

{
  window *pwVar1;
  
  pwVar1 = win->next;
  if (pwVar1->type == WINDOW_TAB) {
    pwVar1 = get_tab_by_number(win->term,win->term->current_tab);
  }
  if (pwVar1 != (window *)0x0) {
    *x = pwVar1->x;
    *y = pwVar1->y;
    return;
  }
  *x = 0;
  *y = 0;
  return;
}



void redraw_from_window(window *win)

{
  terminal *ptVar1;
  window *pwVar2;
  window *pwVar3;
  term_event ev;
  
  ptVar1 = win->term;
  if (ptVar1->redrawing != TREDRAW_READY) {
    return;
  }
  ev.info._4_4_ = ptVar1->height;
  ev.info._0_4_ = ptVar1->width;
  ev.info._8_4_ = 0;
  ev.ev = EVENT_REDRAW;
  ptVar1->redrawing = TREDRAW_BUSY;
  pwVar3 = win->prev;
  while ((window *)&ptVar1->windows != pwVar3) {
    while ((pwVar3->type != WINDOW_NORMAL &&
           (pwVar2 = get_tab_by_number(pwVar3->term,pwVar3->term->current_tab), pwVar2 != pwVar3)))
    {
      pwVar3 = pwVar3->prev;
      if ((window *)&ptVar1->windows == pwVar3) goto LAB_080e3f68;
    }
    (*pwVar3->handler)(pwVar3,&ev);
    pwVar3 = pwVar3->prev;
  }
LAB_080e3f68:
  ptVar1->redrawing = TREDRAW_READY;
  return;
}



void delete_window(window *win)

{
  term_event ev;
  
  win->next->prev = win->prev;
  win->prev->next = win->next;
  ev.info._0_4_ = 0;
  ev.info._4_4_ = 0;
  ev.info._8_4_ = 0;
  ev.ev = EVENT_ABORT;
  (*win->handler)(win,&ev);
  if (win->data != (void *)0x0) {
    mem_free(win->data);
  }
  redraw_terminal(win->term);
  mem_free(win);
  return;
}



void empty_window_handler(window *win,term_event *ev)

{
  terminal *term;
  code **ppcVar1;
  code *UNRECOVERED_JUMPTABLE;
  code *pcVar2;
  term_event_type tVar3;
  
  term = win->term;
  ppcVar1 = (code **)win->data;
  UNRECOVERED_JUMPTABLE = *ppcVar1;
  pcVar2 = ppcVar1[1];
  if ((*(byte *)(ppcVar1 + 2) & 1) != 0) {
    return;
  }
  tVar3 = ev->ev;
  if (tVar3 < EVENT_ABORT) {
    if ((EVENT_MOUSE < tVar3) || (tVar3 == EVENT_INIT)) {
      get_parent_ptr(win,&win->x,&win->y);
      return;
    }
  }
  else {
    if (tVar3 == EVENT_ABORT) {
                    // WARNING: Could not recover jumptable at 0x080e409a. Too many branches
                    // WARNING: Treating indirect jump as call
      (*UNRECOVERED_JUMPTABLE)();
      return;
    }
  }
  *(byte *)(ppcVar1 + 2) = *(byte *)(ppcVar1 + 2) | 1;
  delete_window(win);
  (*UNRECOVERED_JUMPTABLE)(pcVar2);
  term_send_event(term,ev);
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void delete_window_ev(window *win,term_event *ev)

{
  window *pwVar1;
  window *pwVar2;
  bool bVar3;
  
  pwVar1 = win->next;
  bVar3 = pwVar1 == (window *)&win->term->windows;
  pwVar2 = pwVar1;
  if (bVar3) {
    pwVar2 = (window *)0x0;
  }
  delete_window(win);
  if ((!bVar3 && pwVar1 != (window *)0x0) && (ev != (term_event *)0x0)) {
    if (pwVar2->type == WINDOW_TAB) {
      pwVar2 = get_tab_by_number(pwVar2->term,pwVar2->term->current_tab);
    }
    if (pwVar2 != (window *)0x0) {
                    // WARNING: Could not recover jumptable at 0x080e410b. Too many branches
                    // WARNING: Treating indirect jump as call
      (*pwVar2->handler)();
      return;
    }
  }
  return;
}



void add_window(terminal *term,window_handler_T *handler,void *data)

{
  void *pvVar1;
  void **ppvVar2;
  term_event ev;
  
  ppvVar2 = (void **)mem_calloc(1,0x2c);
  if (ppvVar2 == (void **)0x0) {
    if (data != (void *)0x0) {
      mem_free(data);
      return;
    }
  }
  else {
    ppvVar2[4] = data;
    *(terminal **)(ppvVar2 + 5) = term;
    ppvVar2[2] = (void *)0x0;
    *(window_handler_T **)(ppvVar2 + 3) = handler;
    pvVar1 = (term->windows).next;
    *(list_head_elinks **)(ppvVar2 + 1) = &term->windows;
    *ppvVar2 = pvVar1;
    *(void ***)&(term->windows).next = ppvVar2;
    *(void ***)((int)*ppvVar2 + 4) = ppvVar2;
    ev.info._4_4_ = term->height;
    ev.info._0_4_ = term->width;
    ev.info._8_4_ = 0;
    ev.ev = EVENT_INIT;
    (*(code *)ppvVar2[3])(ppvVar2,&ev);
  }
  return;
}



void add_empty_window(terminal *term,anon_subr_void_void_ptr *fn,void *data)

{
  anon_subr_void_void_ptr **data_00;
  
  data_00 = (anon_subr_void_void_ptr **)mem_alloc(0xc);
  if (data_00 != (anon_subr_void_void_ptr **)0x0) {
    *(byte *)(data_00 + 2) = *(byte *)(data_00 + 2) & 0xfe;
    *data_00 = fn;
    data_00[1] = data;
    add_window(term,empty_window_handler,data_00);
    return;
  }
  return;
}



void redraw_below_window(window *win)

{
  terminal *ptVar1;
  term_redrawing_state tVar2;
  window *pwVar3;
  window *pwVar4;
  term_event ev;
  
  ptVar1 = win->term;
  tVar2 = ptVar1->redrawing;
  if (tVar2 != TREDRAW_DELAYED) {
    ev.info._4_4_ = ptVar1->height;
    ev.info._0_4_ = ptVar1->width;
    ev.info._8_4_ = 0;
    ev.ev = EVENT_REDRAW;
    pwVar4 = (window *)(ptVar1->windows).prev;
    ptVar1->redrawing = TREDRAW_DELAYED;
    while (win != pwVar4) {
      while ((pwVar4->type != WINDOW_NORMAL &&
             (pwVar3 = get_tab_by_number(pwVar4->term,pwVar4->term->current_tab), pwVar3 != pwVar4))
            ) {
        pwVar4 = pwVar4->prev;
        if (win == pwVar4) goto LAB_080e42d0;
      }
      (*pwVar4->handler)(pwVar4,&ev);
      pwVar4 = pwVar4->prev;
    }
LAB_080e42d0:
    ptVar1->redrawing = tVar2;
  }
  return;
}



uchar * base64_encode_bin(uchar *in,int inlen,int *outlen)

{
  byte *pbVar1;
  byte bVar2;
  uchar *puVar3;
  uchar *puVar4;
  
  if (assert_failed == 0) {
    if ((in == (uchar *)0x0) || (*in == '\0')) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/base64.c";
      errline = 0x21;
      elinks_internal((uchar *)"assertion in && *in failed!");
      if (assert_failed != 0) goto LAB_080e4335;
    }
    else {
      assert_failed = 0;
    }
    puVar3 = (uchar *)mem_alloc((inlen / 3) * 4 + 5);
    if (puVar3 != (uchar *)0x0) {
      puVar4 = puVar3;
      if (2 < inlen) {
        do {
          inlen = inlen + -3;
          *puVar4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[*in >> 2];
          puVar4[1] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                      [(uint)(in[1] >> 4) | ((uint)*in & 3) << 4];
          puVar4[2] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                      [(uint)(in[2] >> 6) | ((uint)in[1] & 0xf) << 2];
          pbVar1 = in + 2;
          in = in + 3;
          puVar4[3] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                      [(uint)*pbVar1 & 0x3f];
          puVar4 = puVar4 + 4;
        } while (2 < inlen);
      }
      if (inlen == 1) {
        *puVar4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[*in >> 2];
        bVar2 = *in;
        puVar4[2] = '=';
        puVar4[3] = '=';
        puVar4[1] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                    [((uint)bVar2 & 3) * 0x10];
        puVar4 = puVar4 + 4;
      }
      else {
        if (inlen == 2) {
          *puVar4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[*in >> 2];
          puVar4[1] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                      [(uint)(in[1] >> 4) | ((uint)*in & 3) << 4];
          bVar2 = in[1];
          puVar4[3] = '=';
          puVar4[2] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                      [((uint)bVar2 & 0xf) * 4];
          puVar4 = puVar4 + 4;
        }
      }
      *puVar4 = '\0';
      if (outlen != (int *)0x0) {
        *(uchar **)outlen = puVar4 + -(int)puVar3;
        return puVar3;
      }
    }
  }
  else {
LAB_080e4335:
    assert_failed = 0;
    puVar3 = (uchar *)0x0;
  }
  return puVar3;
}



uchar * base64_decode_bin(uchar *in,int inlen,int *outlen)

{
  byte bVar1;
  int once;
  uchar decode [256];
  uchar is_base64_char [256];
  uchar *p;
  int iVar2;
  uchar *puVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  uchar *puVar7;
  
  if (assert_failed == 0) {
    if ((in == (uchar *)0x0) || (*in == '\0')) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/base64.c";
      errline = 0x61;
      elinks_internal((uchar *)"assertion in && *in failed!");
      if (assert_failed != 0) goto LAB_080e4505;
    }
    else {
      assert_failed = 0;
    }
    if (inlen < 0) {
      inlen = inlen + 3;
    }
    p = (uchar *)mem_alloc((inlen >> 2) * 3 + 1);
    puVar3 = (uchar *)0x0;
    if (p != (uchar *)0x0) {
      if (once == 0) {
        iVar2 = 0x40;
        do {
          bVar1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[iVar2];
          *(undefined *)((uint)bVar1 + 0x815b0a0) = (char)iVar2;
          iVar2 = iVar2 + -1;
          *(undefined *)((uint)bVar1 + 0x815b1a0) = 1;
        } while (iVar2 != -1);
        once = 1;
      }
      bVar1 = *in;
      puVar7 = p;
      if ((bVar1 != 0) && (bVar1 != 0x3d)) {
        uVar4 = (uint)bVar1;
        if (((uchar *)&ram0x0815b1a0)[uVar4] != '\0') {
          uVar6 = 0;
          iVar2 = 0;
          do {
            iVar2 = iVar2 + 1;
            iVar5 = ((uchar *)&ram0x0815b0a0)[uVar4] + uVar6;
            if (iVar2 == 4) {
              uVar6 = 0;
              *puVar7 = (uchar)((uint)iVar5 >> 0x10);
              puVar7[1] = (uchar)((uint)iVar5 >> 8);
              iVar2 = 0;
              puVar7[2] = (uchar)iVar5;
              bVar1 = in[1];
              puVar7 = puVar7 + 3;
            }
            else {
              bVar1 = in[1];
              uVar6 = iVar5 * 0x40;
            }
            if (bVar1 == 0) {
              if (iVar2 == 0) goto LAB_080e45e8;
              break;
            }
            in = in + 1;
            if (bVar1 == 0x3d) {
              if (iVar2 == 2) {
                *puVar7 = (uchar)(uVar6 >> 10);
                puVar7 = puVar7 + 1;
                goto LAB_080e45e8;
              }
              if (iVar2 == 3) {
                *puVar7 = (uchar)(uVar6 >> 0x10);
                puVar7[1] = (uchar)(uVar6 >> 8);
                puVar7 = puVar7 + 2;
                goto LAB_080e45e8;
              }
              if (iVar2 != 1) goto LAB_080e45e8;
              break;
            }
            uVar4 = (uint)bVar1;
          } while (*(char *)(uVar4 + 0x815b1a0) != '\0');
        }
        mem_free(p);
        return (uchar *)0x0;
      }
LAB_080e45e8:
      *puVar7 = '\0';
      puVar3 = p;
      if (outlen != (int *)0x0) {
        *(uchar **)outlen = puVar7 + -(int)p;
        return p;
      }
    }
  }
  else {
LAB_080e4505:
    assert_failed = 0;
    puVar3 = (uchar *)0x0;
  }
  return puVar3;
}



uchar * base64_decode(uchar *in)

{
  size_t inlen;
  uchar *puVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (uchar *)0x0;
  }
  if ((in == (uchar *)0x0) || (*in == '\0')) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/base64.c";
    errline = 0x49;
    elinks_internal((uchar *)"assertion in && *in failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (uchar *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  inlen = strlen((char *)in);
  puVar1 = base64_decode_bin(in,inlen,(int *)0x0);
  return puVar1;
}



uchar * base64_encode(uchar *in)

{
  size_t inlen;
  uchar *puVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (uchar *)0x0;
  }
  if ((in == (uchar *)0x0) || (*in == '\0')) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/base64.c";
    errline = 0x15;
    elinks_internal((uchar *)"assertion in && *in failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (uchar *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  inlen = strlen((char *)in);
  puVar1 = base64_encode_bin(in,inlen,(int *)0x0);
  return puVar1;
}



void colors_list_reset(void)

{
  internal_pointer = color_specs;
  return;
}



fastfind_key_value * colors_list_next(void)

{
  fastfind_key_value kv;
  fastfind_key_value *pfVar1;
  
  pfVar1 = (fastfind_key_value *)0x0;
  if (internal_pointer->name != (char *)0x0) {
    internal_pointer = internal_pointer + 1;
    pfVar1 = (fastfind_key_value *)0x815b2a0;
  }
  return pfVar1;
}



void color_to_string(color_T color,uchar *str)

{
  *str = '#';
  elinks_ulongcat(str + 1,(uint *)0x0,color,'\x06',0x30,0x10);
  return;
}



uchar * get_color_string(color_T color,uchar *hexcolor)

{
  color_spec *pcVar1;
  char *pcVar2;
  color_spec *pcVar3;
  
  pcVar2 = "aliceblue";
  pcVar3 = color_specs;
  if (color != 0xf0f8ff) {
    do {
      pcVar2 = pcVar3[1].name;
      if ((uchar *)pcVar2 == (uchar *)0x0) {
        color_to_string(color,hexcolor);
        return hexcolor;
      }
      pcVar1 = pcVar3 + 1;
      pcVar3 = pcVar3 + 1;
    } while (pcVar1->rgb != color);
  }
  return (uchar *)pcVar2;
}



int decode_color(uchar *str,int slen,color_T *color)

{
  int *piVar1;
  ulong uVar2;
  int iVar3;
  ushort **ppuVar4;
  uchar buffer [7];
  uchar *local_20 [4];
  
  if ((*str == '#') && ((slen == 4 || (slen == 7)))) {
    str = str + 1;
  }
  else {
    piVar1 = (int *)fastfind_search(&ff_colors_index,str,slen);
    if ((piVar1 != (int *)0x0) && (*piVar1 != 0)) {
      uVar2 = piVar1[1];
      goto LAB_080e490e;
    }
    if ((slen != 3) && (slen != 6)) {
      return -1;
    }
    iVar3 = 0;
    if (0 < slen) {
      ppuVar4 = __ctype_b_loc();
      iVar3 = 0;
      do {
        if ((*(byte *)((int)*ppuVar4 + (uint)str[iVar3] * 2 + 1) & 0x10) == 0) break;
        iVar3 = iVar3 + 1;
      } while (iVar3 < slen);
    }
    if (iVar3 != slen) {
      return -1;
    }
  }
  if (slen == 4) {
    buffer[0] = *str;
    buffer[2] = str[1];
    buffer[4] = str[2];
    str = buffer;
    buffer[6] = '\0';
    buffer[1] = buffer[0];
    buffer[3] = buffer[2];
    buffer[5] = buffer[4];
  }
  piVar1 = __errno_location();
  *piVar1 = 0;
  uVar2 = strtoul((char *)str,(char **)local_20,0x10);
  if (((*piVar1 != 0) || (str + 6 != local_20[0])) || (0xffffff < uVar2)) {
    return -1;
  }
LAB_080e490e:
  *color = uVar2;
  return 0;
}



void free_colors_lookup(void)

{
  fastfind_done(&ff_colors_index);
  return;
}



void init_colors_lookup(void)

{
  fastfind_index(&ff_colors_index,FF_COMPRESS|FF_LOCALE_INDEP);
  return;
}



int elinks_ulongcat(uchar *s,uint *slen,uint width,uchar fillchar,uint base,uint upper)

{
  uint uVar1;
  uchar "0123456789abcdef" [17];
  uchar "0123456789ABCDEF" [17];
  int iVar2;
  uchar *puVar3;
  uchar *puVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  undefined3 in_stack_00000011;
  int in_stack_0000001c;
  uint local_1c;
  
  puVar4 = "0123456789abcdef";
  if (in_stack_0000001c != 0) {
    puVar4 = "0123456789ABCDEF";
  }
  uVar7 = 0;
  if (slen != (uint *)0x0) {
    uVar7 = *slen;
  }
  if ((((_fillchar == 0) || (s == (uchar *)0x0)) || (0x10 < upper)) || (upper < 2)) {
    uVar6 = 0xffffffff;
  }
  else {
    local_1c = 1;
    if (upper - 1 < width) {
      local_1c = 1;
      uVar6 = width;
      do {
        local_1c = local_1c + 1;
        uVar6 = uVar6 / upper;
      } while (upper - 1 < uVar6);
    }
    uVar1 = local_1c;
    uVar6 = 0;
    if (_fillchar < local_1c) {
      local_1c = _fillchar;
      uVar6 = uVar1;
    }
    if (slen != (uint *)0x0) {
      *slen = *slen + local_1c;
    }
    if (((uchar)base != '\0') && (iVar2 = _fillchar - local_1c, iVar2 != 0)) {
      if (slen != (uint *)0x0) {
        *slen = *slen + iVar2;
      }
      puVar3 = s + iVar2 + -1 + uVar7;
      iVar5 = iVar2;
      do {
        *puVar3 = (uchar)base;
        puVar3 = puVar3 + -1;
        iVar5 = iVar5 + -1;
      } while (iVar5 != 0);
      uVar7 = uVar7 + iVar2;
    }
    s[uVar7 + local_1c] = '\0';
    if (local_1c != 0) {
      iVar2 = local_1c - 1;
      s = s + iVar2 + uVar7;
      while( true ) {
        *s = puVar4[width % upper];
        s = s + -1;
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        width = width / upper;
      }
    }
  }
  return uVar6;
}



int month2num(uchar *str)

{
  byte bVar1;
  byte bVar2;
  
  bVar1 = str[1] | 0x20;
  bVar2 = str[2] | 0x20;
  switch(*str | 0x20) {
  case 0x61:
    if (bVar1 == 0x70) {
      if (bVar2 == 0x72) {
        return 3;
      }
    }
    else {
      if ((bVar1 == 0x75) && (bVar2 == 0x67)) {
        return 7;
      }
    }
    break;
  case 100:
    if ((bVar1 == 0x65) && (bVar2 == 99)) {
      return 0xb;
    }
    break;
  case 0x66:
    if ((bVar1 == 0x65) && (bVar2 == 0x62)) {
      return 1;
    }
    break;
  case 0x6a:
    if (bVar1 == 0x61) {
      if (bVar2 == 0x6e) {
        return 0;
      }
    }
    else {
      if (bVar1 == 0x75) {
        if (bVar2 == 0x6e) {
          return 5;
        }
        if (bVar2 == 0x6c) {
          return 6;
        }
      }
    }
    break;
  case 0x6d:
    if (bVar1 == 0x61) {
      if (bVar2 == 0x72) {
        return 2;
      }
      if (bVar2 == 0x79) {
        return 4;
      }
    }
    break;
  case 0x6e:
    if ((bVar1 == 0x6f) && (bVar2 == 0x76)) {
      return 10;
    }
    break;
  case 0x6f:
    if ((bVar1 == 99) && (bVar2 == 0x74)) {
      return 9;
    }
    break;
  case 0x73:
    if ((bVar1 == 0x65) && (bVar2 == 0x70)) {
      return 8;
    }
  }
  return -1;
}



int c_tolower(int c)

{
  switch(c) {
  case 0x41:
    return 0x61;
  case 0x42:
    c = 0x62;
    break;
  case 0x43:
    return 99;
  case 0x44:
    return 100;
  case 0x45:
    return 0x65;
  case 0x46:
    return 0x66;
  case 0x47:
    return 0x67;
  case 0x48:
    return 0x68;
  case 0x49:
    return 0x69;
  case 0x4a:
    return 0x6a;
  case 0x4b:
    return 0x6b;
  case 0x4c:
    return 0x6c;
  case 0x4d:
    return 0x6d;
  case 0x4e:
    return 0x6e;
  case 0x4f:
    return 0x6f;
  case 0x50:
    return 0x70;
  case 0x51:
    return 0x71;
  case 0x52:
    return 0x72;
  case 0x53:
    return 0x73;
  case 0x54:
    return 0x74;
  case 0x55:
    return 0x75;
  case 0x56:
    return 0x76;
  case 0x57:
    return 0x77;
  case 0x58:
    return 0x78;
  case 0x59:
    return 0x79;
  case 0x5a:
    return 0x7a;
  }
  return c;
}



int c_toupper(int c)

{
  switch(c) {
  case 0x61:
    return 0x41;
  case 0x62:
    c = 0x42;
    break;
  case 99:
    return 0x43;
  case 100:
    return 0x44;
  case 0x65:
    return 0x45;
  case 0x66:
    return 0x46;
  case 0x67:
    return 0x47;
  case 0x68:
    return 0x48;
  case 0x69:
    return 0x49;
  case 0x6a:
    return 0x4a;
  case 0x6b:
    return 0x4b;
  case 0x6c:
    return 0x4c;
  case 0x6d:
    return 0x4d;
  case 0x6e:
    return 0x4e;
  case 0x6f:
    return 0x4f;
  case 0x70:
    return 0x50;
  case 0x71:
    return 0x51;
  case 0x72:
    return 0x52;
  case 0x73:
    return 0x53;
  case 0x74:
    return 0x54;
  case 0x75:
    return 0x55;
  case 0x76:
    return 0x56;
  case 0x77:
    return 0x57;
  case 0x78:
    return 0x58;
  case 0x79:
    return 0x59;
  case 0x7a:
    return 0x5a;
  }
  return c;
}



int c_isupper(int c)

{
  return (uint)(c - 0x41U < 0x1a);
}



int c_islower(int c)

{
  return (uint)(c - 0x61U < 0x1a);
}



void clr_spaces(uchar *str)

{
  uchar uVar1;
  byte *pbVar2;
  uchar *puVar3;
  byte bVar4;
  uchar *puVar5;
  
  if ((assert_failed == 0) && (assert_failed = ZEXT14(str == (uchar *)0x0), str == (uchar *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/conv.c";
    errline = 0x1df;
    elinks_internal((uchar *)"assertion str failed!");
  }
  bVar4 = *str;
  pbVar2 = str;
  puVar3 = str;
  if (bVar4 != 0) {
    do {
      if (bVar4 < 0x20) {
        *pbVar2 = 0x20;
      }
      bVar4 = pbVar2[1];
      pbVar2 = pbVar2 + 1;
    } while (bVar4 != 0);
    uVar1 = *str;
    puVar5 = str;
    while (uVar1 != '\0') {
      do {
        puVar5 = puVar5 + 1;
        if (uVar1 != ' ') goto LAB_080e50d0;
        if (puVar3 == str) goto LAB_080e50d5;
      } while (*puVar5 == ' ');
      if (*puVar5 == '\0') break;
LAB_080e50d0:
      *puVar3 = uVar1;
      puVar3 = puVar3 + 1;
LAB_080e50d5:
      uVar1 = *puVar5;
    }
  }
  *puVar3 = '\0';
  return;
}



long strtolx(uchar *str,uchar **end)

{
  byte *pbVar1;
  int *piVar2;
  long lVar3;
  int iVar4;
  
  piVar2 = __errno_location();
  *piVar2 = 0;
  lVar3 = strtol((char *)str,(char **)end,10);
  if (*piVar2 != 0) {
    return 0;
  }
  pbVar1 = *end;
  if (pbVar1 == (byte *)0x0) {
    return lVar3;
  }
  iVar4 = c_toupper((uint)*pbVar1);
  if ((char)iVar4 == 'K') {
    *end = pbVar1 + 1;
    if (lVar3 < -0x1fffff) {
      return -0x7fffffff;
    }
    if (lVar3 < 0x200000) {
      return lVar3 << 10;
    }
  }
  else {
    if ((char)iVar4 != 'M') {
      return lVar3;
    }
    *end = pbVar1 + 1;
    if (lVar3 < -0x7ff) {
      return -0x7fffffff;
    }
    if (lVar3 < 0x800) {
      return lVar3 << 0x14;
    }
  }
  return 0x7fffffff;
}



string * add_shell_safe_to_string(string *string,uchar *cmd,int cmdlen)

{
  bool bVar1;
  uchar character;
  byte bVar2;
  int iVar3;
  
  if (cmdlen != 0) {
    iVar3 = 0;
    character = *cmd;
    while( true ) {
      if ((byte)(character + 0x9f) < 0x1a) goto LAB_080e5240;
      if ((byte)(character + 0xbf) < 0x1a) goto LAB_080e5240;
      if ((byte)(character - 0x30) < 10) goto LAB_080e5240;
      if (character == '@') goto LAB_080e5240;
      if (character == '.') goto LAB_080e5240;
      if (character == '+') goto LAB_080e5240;
      if (character == ':') goto LAB_080e5240;
      if (character == '/') goto LAB_080e5240;
      if (character == '_') goto LAB_080e5240;
      add_char_to_string(string,'%');
      bVar2 = cmd[iVar3] >> 4;
      character = bVar2 + 0x30;
      if (9 < bVar2) {
        character = bVar2 + 0x57;
      }
      add_char_to_string(string,character);
      bVar2 = cmd[iVar3] & 0xf;
      character = bVar2 + 0x57;
      if (bVar2 < 10) {
        character = bVar2 + 0x30;
      }
      iVar3 = iVar3 + 1;
      add_char_to_string(string,character);
      bVar1 = false;
      if (cmdlen == iVar3) break;
      while ((character = cmd[iVar3], bVar1 && (character == '-'))) {
LAB_080e5240:
        iVar3 = iVar3 + 1;
        add_char_to_string(string,character);
        bVar1 = true;
        if (cmdlen == iVar3) {
          return string;
        }
      }
    }
  }
  return string;
}



string * add_quoted_to_string(string *string,uchar *src,int len)

{
  uchar character;
  int iVar1;
  
  if (len != 0) {
    iVar1 = 0;
    do {
      character = src[iVar1];
      if (((character == '\'') || (character == '\"')) || (character == '\\')) {
        add_char_to_string(string,'\\');
        character = src[iVar1];
      }
      iVar1 = iVar1 + 1;
      add_char_to_string(string,character);
    } while (iVar1 != len);
  }
  return string;
}



string * add_shell_quoted_to_string(string *string,uchar *src,int len)

{
  uchar *puVar1;
  int iVar2;
  
  add_char_to_string(string,'\'');
  if (len != 0) {
    iVar2 = 0;
    do {
      while (puVar1 = src + iVar2, *puVar1 == '\'') {
        iVar2 = iVar2 + 1;
        add_to_string(string,"\'\\\'\'");
        if (iVar2 == len) goto LAB_080e53e0;
      }
      iVar2 = iVar2 + 1;
      add_char_to_string(string,*puVar1);
    } while (iVar2 != len);
  }
LAB_080e53e0:
  add_char_to_string(string,'\'');
  return string;
}



string * __regparm3 add_bytes_to_string__(string *string,uchar *bytes,int length)

{
  int iVar1;
  uint uVar2;
  uchar *puVar3;
  uint size;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  if (((bytes == (uchar *)0x0) || (string == (string *)0x0)) || (length < 0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 0xff;
    elinks_internal((uchar *)
                    "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  if (length == 0) {
    return string;
  }
  iVar1 = length + string->length;
  uVar2 = string->length + 0xffU & 0xffffff00;
  size = iVar1 + 0x100U & 0xffffff00;
  if (uVar2 < size) {
    puVar3 = (uchar *)mem_realloc(string->source,size);
    if (puVar3 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar3;
    memset(puVar3 + uVar2,0,size - uVar2);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  memcpy(string->source + string->length,bytes,length);
  string->source[iVar1] = '\0';
  string->length = iVar1;
  return string;
}



string * add_date_to_string(string *string,uchar *fmt,time_t *date)

{
  int iVar1;
  tm *__tp;
  size_t sVar2;
  string *psVar3;
  int in_GS_OFFSET;
  time_t local_414;
  uchar buffer [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (date == (time_t *)0x0) {
    local_414 = time((time_t *)0x0);
  }
  else {
    local_414 = *date;
  }
  __tp = localtime(&local_414);
  sVar2 = strftime((char *)buffer,0x400,(char *)fmt,__tp);
  psVar3 = (string *)0x0;
  if (sVar2 != 0) {
    psVar3 = add_to_string(string,buffer);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return psVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int sanitize_url(uchar *url)

{
  uchar uVar1;
  size_t __n;
  size_t sVar2;
  uchar *__src;
  uchar *puVar3;
  
  __n = strlen((char *)url);
  if (__n == 0) {
    return 1;
  }
  __src = url + __n;
  sVar2 = __n;
  do {
    sVar2 = sVar2 - 1;
    if (__src[-1] < 0x20) {
      return 0;
    }
    __src = __src + -1;
  } while (sVar2 != 0);
  __src = url;
  if (*url == ' ') {
    do {
      __src = __src + 1;
      __n = __n - 1;
    } while (*__src == ' ');
    if (__n == 0) {
LAB_080e5677:
      __n = 1;
      goto LAB_080e567c;
    }
  }
  uVar1 = __src[__n - 1];
  puVar3 = __src + __n;
  while (uVar1 == ' ') {
    __n = __n - 1;
    puVar3[-1] = '\0';
    if (__n == 0) goto LAB_080e5677;
    uVar1 = puVar3[-2];
    puVar3 = puVar3 + -1;
  }
  __n = __n + 1;
LAB_080e567c:
  memmove(url,__src,__n);
  return 1;
}



void sanitize_title(uchar *title)

{
  uchar uVar1;
  size_t __n;
  uchar *__src;
  uchar *puVar2;
  
  __n = strlen((char *)title);
  if (__n != 0) {
    __src = title + __n;
    do {
      __n = __n - 1;
      if (__src[-1] < 0x20) {
        __src[-1] = ' ';
      }
      __src = __src + -1;
    } while (__n != 0);
    __n = strlen((char *)title);
    uVar1 = *title;
    __src = title;
    while (uVar1 == ' ') {
      __src = __src + 1;
      __n = __n - 1;
      uVar1 = *__src;
    }
    if (__n == 0) {
LAB_080e572f:
      __n = 1;
    }
    else {
      uVar1 = __src[__n - 1];
      puVar2 = __src + __n;
      while (uVar1 == ' ') {
        __n = __n - 1;
        puVar2[-1] = '\0';
        if (__n == 0) goto LAB_080e572f;
        uVar1 = puVar2[-2];
        puVar2 = puVar2 + -1;
      }
      __n = __n + 1;
    }
    memmove(title,__src,__n);
  }
  return;
}



int elinks_longcat(uchar *s,uint *slen,long number,uint width,uchar fillchar,uint base,uint upper)

{
  uint uVar1;
  uchar *puVar2;
  int iVar3;
  int iVar4;
  uchar *puVar5;
  uint uVar6;
  uint local_20;
  uint local_18;
  
  if ((width != 0) && (number < 0)) {
    if (slen == (uint *)0x0) {
      *s = '-';
      s = s + 1;
    }
    else {
      uVar6 = *slen;
      s[uVar6] = '-';
      *slen = uVar6 + 1;
    }
    width = width - 1;
    number = -number;
  }
  puVar5 = "0123456789abcdef";
  local_18 = 0;
  if (upper != 0) {
    puVar5 = "0123456789ABCDEF";
  }
  if (slen != (uint *)0x0) {
    local_18 = *slen;
  }
  if ((((s == (uchar *)0x0) || (width == 0)) || (0x10 < base)) || (base < 2)) {
    uVar6 = 0xffffffff;
  }
  else {
    local_20 = 1;
    if (base - 1 < (uint)number) {
      local_20 = 1;
      uVar6 = number;
      do {
        local_20 = local_20 + 1;
        uVar6 = uVar6 / base;
      } while (base - 1 < uVar6);
    }
    uVar1 = local_20;
    uVar6 = 0;
    if (width < local_20) {
      local_20 = width;
      uVar6 = uVar1;
    }
    if (slen != (uint *)0x0) {
      *slen = *slen + local_20;
    }
    if ((fillchar != '\0') && (iVar3 = width - local_20, iVar3 != 0)) {
      if (slen != (uint *)0x0) {
        *slen = *slen + iVar3;
      }
      puVar2 = s + iVar3 + -1 + local_18;
      iVar4 = iVar3;
      do {
        *puVar2 = fillchar;
        puVar2 = puVar2 + -1;
        iVar4 = iVar4 + -1;
      } while (iVar4 != 0);
      local_18 = local_18 + iVar3;
    }
    s[local_20 + local_18] = '\0';
    if (local_20 != 0) {
      iVar3 = local_20 - 1;
      s = s + iVar3 + local_18;
      while( true ) {
        *s = puVar5[(uint)number % base];
        s = s + -1;
        if (iVar3 == 0) break;
        iVar3 = iVar3 + -1;
        number = (uint)number / base;
      }
    }
  }
  return uVar6;
}



string * add_knum_to_string(string *string,long num)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int in_GS_OFFSET;
  bool bVar4;
  uint local_58;
  uint local_50;
  uint local_44;
  uchar t [32];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_44 = 0;
  if (num == 0) {
    uVar2 = 0;
    num = 0;
LAB_080e590f:
    local_44 = uVar2 + 1;
    t[uVar2 + 1] = '\0';
    local_50 = 1;
    uVar1 = 0;
    goto LAB_080e5925;
  }
  iVar3 = num + 0xfffff;
  if (-1 < num) {
    iVar3 = num;
  }
  if ((iVar3 >> 0x14) << 0x14 == num) {
    uVar1 = elinks_longcat(t,&local_44,iVar3 >> 0x14,0x1e,'\0',10,0);
    t[local_44] = 'M';
    t[local_44 + 1] = '\0';
    local_44 = local_44 + 1;
LAB_080e5a63:
    if (-1 < (int)uVar1) goto LAB_080e5a80;
  }
  else {
    iVar3 = num + 0x3ff;
    if (-1 < num) {
      iVar3 = num;
    }
    if ((iVar3 >> 10) << 10 == num) {
      uVar1 = elinks_longcat(t,&local_44,iVar3 >> 10,0x1e,'\0',10,0);
      t[local_44] = 'k';
      t[local_44 + 1] = '\0';
      local_44 = local_44 + 1;
      goto LAB_080e5a63;
    }
    bVar4 = num < 0;
    local_58 = 0x1f;
    if (bVar4) {
      t[0] = '-';
      num = -num;
      local_58 = 0x1e;
    }
    local_44 = (uint)bVar4;
    uVar2 = (uint)bVar4;
    if ((uint)num < 10) goto LAB_080e590f;
    local_50 = 1;
    uVar1 = num;
    do {
      local_50 = local_50 + 1;
      uVar1 = uVar1 / 10;
    } while (9 < uVar1);
    if (local_58 < local_50) {
      t[local_58 + uVar2] = '\0';
      uVar1 = local_50;
      local_50 = local_58;
LAB_080e5925:
      iVar3 = (local_50 - 1) + uVar2;
      do {
        t[iVar3] = "0123456789abcdef"[(uint)num % 10];
        iVar3 = iVar3 + -1;
        local_50 = local_50 - 1;
        num = (uint)num / 10;
      } while (local_50 != 0);
      goto LAB_080e5a63;
    }
    t[uVar2 + local_50] = '\0';
    if (local_50 != 0) {
      uVar1 = 0;
      goto LAB_080e5925;
    }
LAB_080e5a80:
    if (local_44 != 0) {
      add_bytes_to_string__(string,t,local_44);
      goto LAB_080e5a69;
    }
  }
  string = (string *)0x0;
LAB_080e5a69:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return string;
}



string * add_string_replace(string *string,uchar *src,int len,uchar replaceable,uchar replacement)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  uint size;
  int iVar4;
  uchar *puVar5;
  uint uVar6;
  
  iVar2 = string->length;
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  if ((src == (uchar *)0x0) || (len < 0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 0xff;
    elinks_internal((uchar *)
                    "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  if (len == 0) {
    return string;
  }
  iVar1 = string->length + len;
  uVar6 = string->length + 0xff;
  uVar3 = uVar6 >> 8;
  uVar6 = uVar6 & 0xffffff00;
  size = iVar1 + 0x100U & 0xffffff00;
  if (uVar6 <= size && size + uVar3 * -0x100 != 0) {
    puVar5 = (uchar *)mem_realloc(string->source,size);
    if (puVar5 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar5;
    memset(puVar5 + uVar6,0,size + uVar3 * -0x100);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  memcpy(string->source + string->length,src,len);
  string->source[iVar1] = '\0';
  iVar4 = 0;
  string->length = iVar1;
  puVar5 = string->source;
  do {
    if ((puVar5 + iVar2)[iVar4] == replaceable) {
      (puVar5 + iVar2)[iVar4] = replacement;
    }
    iVar4 = iVar4 + 1;
  } while (len != iVar4);
  return string;
}



string * add_duration_to_string(string *string,long seconds)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  uchar *puVar5;
  int iVar6;
  uint uVar7;
  int in_GS_OFFSET;
  int local_a0;
  int local_80;
  int local_74;
  undefined4 local_64;
  uchar q [64];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_64 = 0;
  if (seconds < 0) {
    uVar4 = 0;
    uVar7 = 0;
LAB_080e5e92:
    iVar6 = 1;
    local_64 = 1;
    q[1] = '\0';
LAB_080e5d18:
    puVar5 = q + iVar6;
    do {
      puVar5[-1] = "0123456789abcdef"[uVar7 % 10];
      puVar5 = puVar5 + -1;
      iVar6 = iVar6 + -1;
      uVar7 = uVar7 / 10;
    } while (iVar6 != 0);
  }
  else {
    if (seconds < 0x15180) {
      if (seconds < 0xe10) {
        uVar7 = seconds / 0x3c;
        uVar4 = seconds % 0x3c;
        if (uVar7 < 10) goto LAB_080e5e92;
        local_64 = 2;
        iVar6 = 2;
        q[2] = '\0';
        goto LAB_080e5d18;
      }
    }
    else {
      uVar7 = seconds / 0x15180;
      if (uVar7 < 10) {
        local_64 = 1;
        uVar4 = 1;
        q[1] = '\0';
LAB_080e6160:
        puVar5 = q + uVar4;
        do {
          puVar5[-1] = "0123456789abcdef"[uVar7 % 10];
          puVar5 = puVar5 + -1;
          uVar4 = uVar4 - 1;
          uVar7 = uVar7 / 10;
        } while (uVar4 != 0);
      }
      else {
        uVar2 = 1;
        uVar4 = uVar7;
        do {
          uVar2 = uVar2 + 1;
          uVar4 = uVar4 / 10;
        } while (9 < uVar4);
        uVar4 = 5;
        if (uVar2 < 6) {
          uVar4 = uVar2;
        }
        q[uVar4] = '\0';
        if (uVar4 != 0) goto LAB_080e6160;
      }
      q[local_64] = 'd';
      q[local_64 + 1] = ' ';
      local_64 = local_64 + 2;
    }
    iVar6 = local_64;
    iVar3 = seconds % 0x15180;
    uVar7 = iVar3 / 0xe10;
    if (uVar7 < 10) {
      uVar4 = 1;
      q[local_64 + 1] = '\0';
      local_64 = local_64 + 1;
LAB_080e6090:
      puVar5 = (uchar *)((int)&local_64 + uVar4 + iVar6 + 3);
      do {
        *puVar5 = "0123456789abcdef"[uVar7 % 10];
        puVar5 = puVar5 + -1;
        uVar4 = uVar4 - 1;
        uVar7 = uVar7 / 10;
      } while (uVar4 != 0);
    }
    else {
      uVar2 = 1;
      uVar4 = uVar7;
      do {
        uVar2 = uVar2 + 1;
        uVar4 = uVar4 / 10;
      } while (9 < uVar4);
      uVar4 = 4;
      if (uVar2 < 5) {
        uVar4 = uVar2;
      }
      local_64 = uVar4 + local_64;
      q[local_64] = '\0';
      if (uVar4 != 0) goto LAB_080e6090;
    }
    iVar6 = local_64;
    local_80 = local_64 + 1;
    q[local_64] = ':';
    uVar7 = (iVar3 / 0x3c) % 0x3c;
    if (uVar7 < 10) {
      local_64 = local_64 + 2;
      uVar4 = 1;
      local_a0 = 1;
LAB_080e60e7:
      local_64 = local_a0 + local_64;
      local_80 = local_80 + local_a0;
      puVar5 = q + local_a0 + iVar6;
      do {
        *puVar5 = '0';
        puVar5 = puVar5 + -1;
        local_a0 = local_a0 + -1;
      } while (local_a0 != 0);
      iVar1 = local_80 + uVar4;
LAB_080e6128:
      q[iVar1] = '\0';
      if (uVar4 == 0) {
        uVar4 = iVar3 % 0x3c;
        goto LAB_080e5d4d;
      }
    }
    else {
      uVar4 = 1;
      uVar2 = uVar7;
      do {
        uVar4 = uVar4 + 1;
        uVar2 = uVar2 / 10;
      } while (9 < uVar2);
      if (uVar4 < 3) {
        iVar1 = uVar4 + local_80;
        local_a0 = 2 - uVar4;
        local_64 = iVar1;
        if (local_a0 != 0) goto LAB_080e60e7;
        goto LAB_080e6128;
      }
      uVar4 = 2;
      q[local_64 + 3] = '\0';
      local_64 = local_64 + 3;
    }
    puVar5 = (uchar *)((int)&local_64 + local_80 + uVar4 + 3);
    do {
      *puVar5 = "0123456789abcdef"[uVar7 % 10];
      puVar5 = puVar5 + -1;
      uVar4 = uVar4 - 1;
      uVar7 = uVar7 / 10;
    } while (uVar4 != 0);
    uVar4 = iVar3 % 0x3c;
  }
LAB_080e5d4d:
  iVar6 = local_64;
  local_74 = local_64 + 1;
  q[local_64] = ':';
  if (uVar4 < 10) {
    local_64 = local_64 + 2;
    uVar7 = 1;
    local_80 = 1;
LAB_080e6034:
    local_64 = local_80 + local_64;
    local_74 = local_74 + local_80;
    puVar5 = q + local_80 + iVar6;
    do {
      *puVar5 = '0';
      puVar5 = puVar5 + -1;
      local_80 = local_80 + -1;
    } while (local_80 != 0);
    iVar3 = local_74 + uVar7;
LAB_080e6060:
    q[iVar3] = '\0';
    if (uVar7 == 0) goto LAB_080e5dd1;
  }
  else {
    uVar7 = 1;
    uVar2 = uVar4;
    do {
      uVar7 = uVar7 + 1;
      uVar2 = uVar2 / 10;
    } while (9 < uVar2);
    if (uVar7 < 3) {
      iVar3 = local_74 + uVar7;
      local_80 = 2 - uVar7;
      local_64 = iVar3;
      if (local_80 != 0) goto LAB_080e6034;
      goto LAB_080e6060;
    }
    uVar7 = 2;
    q[local_64 + 3] = '\0';
    local_64 = local_64 + 3;
  }
  puVar5 = q + (uVar7 - 1) + local_74;
  do {
    *puVar5 = "0123456789abcdef"[uVar4 % 10];
    puVar5 = puVar5 + -1;
    uVar7 = uVar7 - 1;
    uVar4 = uVar4 / 10;
  } while (uVar7 != 0);
LAB_080e5dd1:
  add_to_string(string,q);
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return string;
}



string * add_timeval_to_string(string *string,timeval_T *timeval)

{
  long seconds;
  string *psVar1;
  
  seconds = timeval_to_seconds(timeval);
  psVar1 = add_duration_to_string(string,seconds);
  return psVar1;
}



string * add_long_to_string(string *string,long number)

{
  string *psVar1;
  int iVar2;
  uchar *puVar3;
  uint uVar4;
  uint uVar5;
  int in_GS_OFFSET;
  uint local_54;
  uint local_50;
  int local_44;
  uchar buffer [32];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if (assert_failed != 0) {
LAB_080e6322:
    assert_failed = 0;
    psVar1 = (string *)0x0;
    goto LAB_080e632e;
  }
  assert_failed = ZEXT14(string == (string *)0x0);
  local_44 = 0;
  iVar2 = 0;
  if (string == (string *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/conv.c";
    errline = 0x8a;
    elinks_internal((uchar *)"assertion string failed!");
    iVar2 = local_44;
    if (assert_failed != 0) goto LAB_080e6322;
  }
  local_50 = 0x1f;
  if (number < 0) {
    buffer[iVar2] = '-';
    number = -number;
    iVar2 = iVar2 + 1;
    local_50 = 0x1e;
  }
  if ((uint)number < 10) {
    local_44 = iVar2 + 1;
    local_50 = 1;
    buffer[iVar2 + 1] = '\0';
    local_54 = 0;
LAB_080e62b8:
    puVar3 = (uchar *)((int)&local_44 + local_50 + iVar2 + 3);
    do {
      *puVar3 = "0123456789abcdef"[(uint)number % 10];
      puVar3 = puVar3 + -1;
      local_50 = local_50 - 1;
      number = (uint)number / 10;
    } while (local_50 != 0);
    if (-1 < (int)local_54) goto LAB_080e62eb;
  }
  else {
    uVar5 = 1;
    uVar4 = number;
    do {
      uVar5 = uVar5 + 1;
      uVar4 = uVar4 / 10;
    } while (9 < uVar4);
    if (local_50 < uVar5) {
      local_44 = local_50 + iVar2;
      buffer[local_44] = '\0';
      local_54 = uVar5;
      goto LAB_080e62b8;
    }
    local_44 = uVar5 + iVar2;
    buffer[local_44] = '\0';
    if (uVar5 != 0) {
      local_54 = 0;
      local_50 = uVar5;
      goto LAB_080e62b8;
    }
LAB_080e62eb:
    if (local_44 != 0) {
      psVar1 = add_bytes_to_string__(string,buffer,local_44);
      goto LAB_080e632e;
    }
  }
  psVar1 = (string *)0x0;
LAB_080e632e:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return psVar1;
}



string * add_cp_html_to_string(string *string,int src_codepage,uchar *src,int len)

{
  uchar *end;
  int iVar1;
  int iVar2;
  uint uVar3;
  string *psVar4;
  unicode_val_T number;
  uchar *puVar5;
  uint uVar6;
  uint size;
  
  end = src + len;
  do {
    while( true ) {
      number = cp_to_unicode(src_codepage,&src,end);
      if (number == 0xfffffffd) {
        return string;
      }
      if (((((0x5e < number - 0x20) || (number == 0x3c)) || (number == 0x26)) ||
          ((number == 0x3e || (number == 0x27)))) || (number == 0x22)) break;
      psVar4 = add_char_to_string(string,(uchar)number);
      if (psVar4 == (string *)0x0) {
        return (string *)0x0;
      }
    }
    iVar2 = string->length;
    if (assert_failed != 0) {
      assert_failed = 0;
      puVar5 = string->source;
      goto LAB_080e6490;
    }
    assert_failed = 0;
    iVar1 = string->length;
    uVar3 = iVar1 + 0xffU >> 8;
    uVar6 = iVar1 + 0xffU & 0xffffff00;
    size = iVar1 + 0x102U & 0xffffff00;
    if (uVar6 <= size && size + uVar3 * -0x100 != 0) {
      puVar5 = (uchar *)mem_realloc(string->source,size);
      if (puVar5 == (uchar *)0x0) {
LAB_080e64e8:
        puVar5 = string->source;
LAB_080e6490:
        string->length = iVar2;
        puVar5[iVar2] = '\0';
        return (string *)0x0;
      }
      string->source = puVar5;
      memset(puVar5 + uVar6,0,size + uVar3 * -0x100);
    }
    puVar5 = string->source;
    if (puVar5 == (uchar *)0x0) goto LAB_080e6490;
    *(undefined2 *)(puVar5 + string->length) = 0x2326;
    string->source[iVar1 + 2] = '\0';
    string->length = iVar1 + 2;
    psVar4 = add_long_to_string(string,number);
    if ((psVar4 == (string *)0x0) ||
       (psVar4 = add_char_to_string(string,';'), psVar4 == (string *)0x0)) goto LAB_080e64e8;
  } while( true );
}



string * add_html_to_string(string *string,uchar *src,int len)

{
  byte character;
  int iVar1;
  int iVar2;
  uint uVar3;
  string *psVar4;
  uchar *puVar5;
  uint uVar6;
  uint size;
  int iVar7;
  
  if (len != 0) {
    iVar7 = 0;
    do {
      character = src[iVar7];
      if (((((character == 0x3c) || (character < 0x20)) || (character == 0x3e)) ||
          ((character == 0x26 || (character == 0x22)))) || (character == 0x27)) {
        iVar2 = string->length;
        if (assert_failed != 0) {
          assert_failed = 0;
          puVar5 = string->source;
          goto LAB_080e660a;
        }
        assert_failed = 0;
        iVar1 = string->length;
        uVar3 = iVar1 + 0xffU >> 8;
        uVar6 = iVar1 + 0xffU & 0xffffff00;
        size = iVar1 + 0x102U & 0xffffff00;
        if (size < uVar6 || size + uVar3 * -0x100 == 0) {
LAB_080e656b:
          puVar5 = string->source;
          if (puVar5 == (uchar *)0x0) goto LAB_080e660a;
          *(undefined2 *)(puVar5 + string->length) = 0x2326;
          string->source[iVar1 + 2] = '\0';
          string->length = iVar1 + 2;
          psVar4 = add_long_to_string(string,(uint)src[iVar7]);
          if ((psVar4 != (string *)0x0) &&
             (psVar4 = add_char_to_string(string,';'), psVar4 != (string *)0x0)) goto LAB_080e65bd;
        }
        else {
          puVar5 = (uchar *)mem_realloc(string->source,size);
          if (puVar5 != (uchar *)0x0) {
            string->source = puVar5;
            memset(puVar5 + uVar6,0,size + uVar3 * -0x100);
            goto LAB_080e656b;
          }
        }
        puVar5 = string->source;
LAB_080e660a:
        string->length = iVar2;
        puVar5[iVar2] = '\0';
        return (string *)0x0;
      }
      psVar4 = add_char_to_string(string,character);
      if (psVar4 == (string *)0x0) {
        return (string *)0x0;
      }
LAB_080e65bd:
      iVar7 = iVar7 + 1;
    } while (iVar7 != len);
  }
  return string;
}



// WARNING: Removing unreachable block (ram,0x080e67c0)
// WARNING: Removing unreachable block (ram,0x080e68ca)
// WARNING: Could not reconcile some variable overlaps

string * add_xnum_to_string(string *string,off_t xnum)

{
  bool bVar1;
  byte bVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  bool bVar6;
  longlong lVar7;
  long local_34;
  uchar suff [3];
  
  suff._0_2_ = 0x6900;
  suff[2] = '\0';
  if (xnum < 0x100000) {
    if (xnum < 0x400) {
      bVar1 = false;
      local_34 = -1;
      goto LAB_080e6751;
    }
    lVar7 = xnum * 10;
    xnum = xnum >> 10;
    suff._0_2_ = 0x694b;
    iVar4 = (int)((ulonglong)lVar7 >> 0x20);
    lVar7 = __moddi3((uint)lVar7 >> 10 | iVar4 * 0x400000,iVar4 >> 10,10,0);
  }
  else {
    lVar7 = (xnum & 0xffffffffU) * 10;
    uVar3 = (uint)lVar7;
    iVar4 = xnum._4_4_ * 10 + (int)((ulonglong)lVar7 >> 0x20);
    uVar5 = iVar4 >> 0x1f & 0xfffff;
    iVar4 = iVar4 + (uint)CARRY4(uVar5,uVar3);
    xnum = xnum >> 0x14;
    suff._0_2_ = 0x694d;
    lVar7 = __moddi3(uVar5 + uVar3 >> 0x14 | iVar4 * 0x1000,iVar4 >> 0x14,10,0);
  }
  local_34 = (long)lVar7;
  bVar2 = 1;
  if (-1 < xnum) {
    if (xnum < 0x100000000) {
      if (9 < (uint)xnum) {
        bVar2 = 0;
      }
    }
    else {
      bVar2 = 0;
    }
  }
  bVar1 = (bool)(lVar7 != -1 & bVar2);
LAB_080e6751:
  if ((assert_failed == 0) &&
     (bVar6 = (int)xnum >> 0x1f != (int)((ulonglong)xnum >> 0x20), assert_failed = ZEXT14(bVar6),
     bVar6)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/conv.c";
    errline = 0xc2;
    elinks_internal((uchar *)"assertion xnum == (long) xnum failed!");
  }
  add_long_to_string(string,(int)xnum);
  if (bVar1) {
    add_char_to_string(string,'.');
    add_long_to_string(string,local_34);
  }
  add_char_to_string(string,' ');
  if (suff[0] != '\0') {
    add_to_string(string,suff);
  }
  add_char_to_string(string,'B');
  return string;
}



int env_set(uchar *name,uchar *value,int length)

{
  size_t sVar1;
  uchar *p;
  int iVar2;
  
  if (((value != (uchar *)0x0) && (name != (uchar *)0x0)) && (*name != '\0')) {
    sVar1 = strlen((char *)value);
    if (((uint)(length < (int)sVar1) & (uint)~length >> 0x1f) == 0) {
      iVar2 = setenv((char *)name,(char *)value,1);
      return iVar2;
    }
    p = memacpy(value,length);
    if (p != (uchar *)0x0) {
      iVar2 = setenv((char *)name,(char *)p,1);
      mem_free(p);
      return iVar2;
    }
  }
  return -1;
}



void do_not_optimize_here(void *p)

{
  return;
}



void dump_backtrace(FILE *f,int trouble)

{
  void **ppvVar1;
  uint uVar2;
  void *__ptr;
  int iVar3;
  uint uVar4;
  void *stack [20];
  
  uVar2 = backtrace(stack,0x14);
  if (trouble == 0) {
    __ptr = (void *)backtrace_symbols(stack,uVar2);
    __fprintf_chk(f,1,"Obtained %d stack frames:\n",uVar2);
    if (uVar2 != 0) {
      uVar4 = 0;
      do {
        iVar3 = uVar4 * 4;
        ppvVar1 = stack + uVar4;
        uVar4 = uVar4 + 1;
        __fprintf_chk(f,1,"[%p] %s\n",*ppvVar1,*(undefined4 *)((int)__ptr + iVar3));
      } while (uVar4 < uVar2);
    }
    free(__ptr);
    fflush((FILE *)f);
    return;
  }
  iVar3 = fileno((FILE *)f);
  backtrace_symbols_fd(stack,uVar2,iVar3);
  return;
}



void usrerror(uchar *fmt,...)

{
  fwrite("ELinks: ",1,8,stderr);
  __vfprintf_chk(stderr,1,fmt,&stack0x00000008);
  fputc(10,stderr);
  fflush(stderr);
  return;
}



void __regparm3 er(int bell,int shall_sleep,uchar *fmt,va_list params)

{
  if (bell != 0) {
    fputc(7,stderr);
  }
  __vfprintf_chk(stderr,1,fmt,params);
  fputc(10,stderr);
  fflush(stderr);
  if (shall_sleep == 0) {
    return;
  }
  sleep(1);
  return;
}



void elinks_internal(uchar *fmt,...)

{
  int iVar1;
  int in_GS_OFFSET;
  uchar errbuf [4096];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __snprintf_chk(errbuf,0x1000,1,0x1000,&DAT_08125598,errfile,errline,fmt);
  er(1,1,errbuf,&stack0x00000008);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void elinks_assertm(int x,uchar *fmt,...)

{
  void *local_10 [3];
  
  local_10[0] = (void *)0x0;
  if ((assert_failed == 0) && (assert_failed = ZEXT14(x == 0), x == 0)) {
    __vasprintf_chk(local_10,1,fmt,&stack0x0000000c);
    elinks_internal((uchar *)"assertion failed: %s",local_10[0]);
    if (local_10[0] != (void *)0x0) {
      free(local_10[0]);
      return;
    }
  }
  return;
}



void elinks_error(uchar *fmt,...)

{
  int iVar1;
  int in_GS_OFFSET;
  uchar errbuf [4096];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __snprintf_chk(errbuf,0x1000,1,0x1000,"ERROR at %s:%d: %s",errfile,errline,fmt);
  er(1,1,errbuf,&stack0x00000008);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void elinks_wdebug(uchar *fmt,...)

{
  int iVar1;
  int in_GS_OFFSET;
  uchar errbuf [4096];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __snprintf_chk(errbuf,0x1000,1,0x1000,"DEBUG MESSAGE at %s:%d: %s",errfile,errline,fmt);
  er(0,1,errbuf,&stack0x00000008);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void elinks_debug(uchar *fmt,...)

{
  int iVar1;
  int in_GS_OFFSET;
  uchar errbuf [4096];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __snprintf_chk(errbuf,0x1000,1,0x1000,"DEBUG MESSAGE at %s:%d: %s",errfile,errline,fmt);
  er(0,0,errbuf,&stack0x00000008);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void fastfind_done(fastfind_index *index)

{
  void **p;
  void *p_00;
  void *pvVar1;
  void *p_01;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(index == (fastfind_index *)0x0);
  if (index == (fastfind_index *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
    errline = 0x283;
    elinks_internal((uchar *)"assertion index failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  p = (void **)index->handle;
  if (p != (void **)0x0) {
    if (*p != (void *)0x0) {
      mem_free(*p);
    }
    pvVar1 = p[8];
    if (pvVar1 == (void *)0x0) {
      p_01 = p[1];
    }
    else {
      p_01 = p[1];
      do {
        p_00 = *(void **)((int)p_01 + (int)pvVar1 * 4);
        if (p_00 != (void *)0x0) {
          mem_free(p_00);
          pvVar1 = p[8];
          p_01 = p[1];
        }
        pvVar1 = (void *)((int)pvVar1 + -1);
        p[8] = pvVar1;
      } while (pvVar1 != (void *)0x0);
    }
    if (p_01 != (void *)0x0) {
      mem_free(p_01);
    }
    mem_free(p);
    index->handle = (void *)0x0;
  }
  return;
}



void * fastfind_search(fastfind_index *index,uchar *key,int key_len)

{
  byte bVar1;
  int *piVar2;
  __int32_t **pp_Var3;
  int iVar4;
  void **ppvVar5;
  int iVar6;
  uint *puVar7;
  uint uVar8;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(index == (fastfind_index *)0x0);
    if (index == (fastfind_index *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
      errline = 0x25a;
      elinks_internal((uchar *)"assertion index failed!");
      if (assert_failed != 0) goto LAB_080e6fe0;
    }
    piVar2 = (int *)index->handle;
    assert_failed = ZEXT14(piVar2 == (int *)0x0);
    if (piVar2 == (int *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
      errline = 0x25f;
      elinks_internal((uchar *)"assertion info != NULL failed: FastFind index %s not initialized",
                      index->comment);
      if (assert_failed != 0) goto LAB_080e6fe0;
    }
    if (((key != (uchar *)0x0) && (key_len <= piVar2[4])) && (piVar2[3] <= key_len)) {
      puVar7 = (uint *)piVar2[2];
      if ((*(byte *)(piVar2 + 9) & 1) == 0) {
        if ((*(byte *)(piVar2 + 9) & 2) == 0) {
          if (0 < key_len) {
            pp_Var3 = __ctype_toupper_loc();
            iVar6 = 0;
            do {
              if (0x7f < (*pp_Var3)[key[iVar6]]) {
                return (void *)0x0;
              }
              uVar8 = piVar2[(*pp_Var3)[key[iVar6]] + 10];
              if ((int)uVar8 < 0) {
                return (void *)0x0;
              }
              bVar1 = *(byte *)puVar7;
              if ((bVar1 & 2) == 0) {
                puVar7 = puVar7 + uVar8;
                bVar1 = *(byte *)puVar7;
              }
              else {
                if ((uint)(*(byte *)((int)puVar7 + 3) >> 1) != uVar8) {
                  return (void *)0x0;
                }
              }
              if (((bVar1 & 1) != 0) &&
                 (ppvVar5 = (void **)(((uint)(*(ushort *)puVar7 >> 2) & 0x3ff) * 8 + *piVar2),
                 ppvVar5[1] == (void *)key_len)) goto LAB_080e71c8;
              if ((*puVar7 & 0x1fff000) == 0) {
                return (void *)0x0;
              }
              iVar6 = iVar6 + 1;
              puVar7 = *(uint **)((*puVar7 >> 10 & 0x7ffc) + piVar2[1]);
            } while (iVar6 < key_len);
          }
        }
        else {
          if (0 < key_len) {
            iVar6 = 0;
            do {
              iVar4 = c_toupper((uint)key[iVar6]);
              if (0x7f < iVar4) {
                return (void *)0x0;
              }
              uVar8 = piVar2[iVar4 + 10];
              if ((int)uVar8 < 0) {
                return (void *)0x0;
              }
              bVar1 = *(byte *)puVar7;
              if ((bVar1 & 2) == 0) {
                puVar7 = puVar7 + uVar8;
                bVar1 = *(byte *)puVar7;
              }
              else {
                if ((uint)(*(byte *)((int)puVar7 + 3) >> 1) != uVar8) {
                  return (void *)0x0;
                }
              }
              if (((bVar1 & 1) != 0) &&
                 (ppvVar5 = (void **)(((uint)(*(ushort *)puVar7 >> 2) & 0x3ff) * 8 + *piVar2),
                 ppvVar5[1] == (void *)key_len)) goto LAB_080e71c8;
              if ((*puVar7 & 0x1fff000) == 0) {
                return (void *)0x0;
              }
              iVar6 = iVar6 + 1;
              puVar7 = *(uint **)((*puVar7 >> 10 & 0x7ffc) + piVar2[1]);
            } while (iVar6 < key_len);
          }
        }
      }
      else {
        if (((0 < key_len) && (*key < 0x80)) && (uVar8 = piVar2[(uint)*key + 10], -1 < (int)uVar8))
        {
          iVar6 = 0;
          while( true ) {
            bVar1 = *(byte *)puVar7;
            if ((bVar1 & 2) == 0) {
              puVar7 = puVar7 + uVar8;
              bVar1 = *(byte *)puVar7;
            }
            else {
              if ((uint)(*(byte *)((int)puVar7 + 3) >> 1) != uVar8) {
                return (void *)0x0;
              }
            }
            if (((bVar1 & 1) != 0) &&
               (ppvVar5 = (void **)(((uint)(*(ushort *)puVar7 >> 2) & 0x3ff) * 8 + *piVar2),
               ppvVar5[1] == (void *)key_len)) break;
            if ((*puVar7 & 0x1fff000) == 0) {
              return (void *)0x0;
            }
            iVar6 = iVar6 + 1;
            puVar7 = *(uint **)((*puVar7 >> 10 & 0x7ffc) + piVar2[1]);
            if (key_len <= iVar6) {
              return (void *)0x0;
            }
            if (0x7f < key[iVar6]) {
              return (void *)0x0;
            }
            uVar8 = piVar2[(uint)key[iVar6] + 10];
            if ((int)uVar8 < 0) {
              return (void *)0x0;
            }
          }
LAB_080e71c8:
          return *ppvVar5;
        }
      }
    }
  }
  else {
LAB_080e6fe0:
    assert_failed = 0;
  }
  return (void *)0x0;
}



int __regparm3 alloc_leafset(fastfind_info *info)

{
  bool bVar1;
  ff_node_c **ppfVar2;
  ff_node_c *pfVar3;
  int iVar4;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  bVar1 = 0x1ffe < info->leafsets_count;
  assert_failed = ZEXT14(bVar1);
  if (bVar1) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
    errline = 0x158;
    elinks_internal((uchar *)"assertion info->leafsets_count < FF_MAX_LEAFSETS failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  ppfVar2 = (ff_node_c **)mem_realloc(info->leafsets,info->leafsets_count * 4 + 8);
  if (ppfVar2 != (ff_node_c **)0x0) {
    info->leafsets = ppfVar2;
    pfVar3 = (ff_node_c *)mem_calloc(info->uniq_chars_count,4);
    if (pfVar3 != (ff_node_c *)0x0) {
      iVar4 = info->leafsets_count + 1;
      info->leafsets_count = iVar4;
      info->leafsets[iVar4] = pfVar3;
      return 1;
    }
  }
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

void __regparm3 compress_tree(ff_node_c *leafset,fastfind_info *info)

{
  byte bVar1;
  ff_node_c fVar2;
  uint *puVar3;
  int iVar4;
  uint **ppuVar5;
  ff_node_c *pfVar6;
  int iVar7;
  int local_20;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(info == (fastfind_info *)0x0);
    if (info == (fastfind_info *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
      errline = 0x19c;
      elinks_internal((uchar *)"assertion info failed!");
      if (assert_failed != 0) goto LAB_080e7420;
    }
    if (0 < info->uniq_chars_count) {
      iVar7 = 0;
      iVar4 = 0;
      local_20 = 0;
      pfVar6 = leafset;
      do {
        if ((*(byte *)pfVar6 & 2) == 0) {
          fVar2 = *pfVar6;
          if (((uint)fVar2 & 0x1fff000) != 0) {
            compress_tree(info->leafsets[(uint)fVar2 >> 0xc & 0x1fff],info);
            fVar2 = *pfVar6;
          }
          if (((uint)fVar2 & 0x1fff001) != 0) {
            iVar4 = iVar4 + 1;
            local_20 = iVar7;
          }
        }
        iVar7 = iVar7 + 1;
        pfVar6 = pfVar6 + 1;
      } while (info->uniq_chars_count != iVar7 && iVar7 <= info->uniq_chars_count);
      if (((iVar4 == 1) && (pfVar6 = leafset + local_20, (*(byte *)pfVar6 & 2) == 0)) &&
         (1 < info->leafsets_count)) {
        iVar4 = 4;
        if (info->leafsets[1] != leafset) {
          iVar7 = 1;
          do {
            iVar7 = iVar7 + 1;
            if (info->leafsets_count <= iVar7) {
              return;
            }
            iVar4 = iVar7 * 4;
          } while (info->leafsets[iVar7] != leafset);
        }
        puVar3 = (uint *)mem_alloc(4);
        if (puVar3 != (uint *)0x0) {
          bVar1 = *(byte *)puVar3;
          *(byte *)puVar3 = bVar1 | 2;
          *(byte *)puVar3 = bVar1 & 0xfe | 2 | *(byte *)pfVar6 & 1;
          *(ushort *)puVar3 = *(ushort *)puVar3 & 0xf003 | *(ushort *)pfVar6 & 0xffc;
          fVar2 = *pfVar6;
          *puVar3 = *puVar3 & 0xfe000fff | (uint)fVar2 & 0x1fff000;
          *(byte *)((int)puVar3 + 3) = (byte)((uint)fVar2 >> 0x18) & 1 | (char)local_20 * '\x02';
          ppuVar5 = (uint **)((int)info->leafsets + iVar4);
          if (*ppuVar5 != (uint *)0x0) {
            mem_free(*ppuVar5);
            ppuVar5 = (uint **)((int)info->leafsets + iVar4);
          }
          *ppuVar5 = puVar3;
        }
      }
    }
  }
  else {
LAB_080e7420:
    assert_failed = 0;
  }
  return;
}



fastfind_index * fastfind_index(fastfind_index *index,fastfind_flags flags)

{
  size_t __n;
  bool bVar1;
  fastfind_info *info;
  fastfind_key_value *pfVar2;
  size_t sVar3;
  void *pvVar4;
  __int32_t **pp_Var5;
  uint uVar6;
  ff_data *pfVar7;
  ff_node_c fVar8;
  void *pvVar9;
  int iVar10;
  uchar *__s;
  ff_node_c *pfVar11;
  int __c;
  
  if (assert_failed != 0) goto LAB_080e76d2;
  if (((index == (fastfind_index *)0x0) || (index->reset == (anon_subr_void_for_reset *)0x0)) ||
     (index->next == (anon_subr_fastfind_key_value_ptr_for_next *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
    errline = 0x1c0;
    elinks_internal((uchar *)"assertion index && index->reset && index->next failed!");
    if (assert_failed != 0) goto LAB_080e76d2;
  }
  else {
    assert_failed = 0;
  }
  info = (fastfind_info *)mem_calloc(1,0x2a8);
  *(fastfind_info **)&index->handle = info;
  if (info == (fastfind_info *)0x0) goto return_error;
  info->min_key_len = 0xff;
  *(byte *)&info->field_0x24 =
       *(byte *)&info->field_0x24 & 0xf8 | (byte)flags & 1 | ((byte)(flags >> 2) & 1) * '\x02' |
       ((byte)(flags >> 1) & 1) * '\x04';
  (*index->reset)();
  __s = info->uniq_chars;
  while (pfVar2 = (*index->next)(), pfVar2 != (fastfind_key_value *)0x0) {
    sVar3 = strlen((char *)pfVar2->key);
    if (assert_failed != 0) goto LAB_080e76d2;
    bVar1 = 0xfe < sVar3 - 1;
    assert_failed = ZEXT14(bVar1);
    if (bVar1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
      errline = 0x1cd;
      elinks_internal((uchar *)"assertion key_len > 0 && key_len <= FF_MAX_KEYLEN failed!");
      if (assert_failed != 0) goto LAB_080e76d2;
    }
    if ((int)sVar3 < info->min_key_len) {
      info->min_key_len = sVar3;
    }
    if (info->max_key_len < (int)sVar3) {
      info->max_key_len = sVar3;
    }
    if (0 < (int)sVar3) {
      __c = 0;
      do {
        while( true ) {
          if ((*(byte *)&info->field_0x24 & 1) == 0) {
            if ((*(byte *)&info->field_0x24 & 2) == 0) {
              pp_Var5 = __ctype_toupper_loc();
              uVar6 = (*pp_Var5)[pfVar2->key[__c]];
            }
            else {
              uVar6 = c_toupper((uint)pfVar2->key[__c]);
            }
          }
          else {
            uVar6 = (uint)pfVar2->key[__c];
          }
          if (assert_failed != 0) goto LAB_080e76d2;
          assert_failed = ZEXT14(0x7f < (int)uVar6);
          if (0x7f < (int)uVar6) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
            errline = 0x1dd;
            elinks_internal((uchar *)"assertion k < FF_MAX_CHARS failed!");
            if (assert_failed != 0) goto LAB_080e76d2;
          }
          __n = info->uniq_chars_count;
          pvVar4 = memchr(__s,uVar6 & 0xff,__n);
          if ((pvVar4 == (void *)0x0) || ((void *)((int)pvVar4 - (int)__s) == (void *)0xffffffff))
          break;
          __c = __c + 1;
          if ((int)sVar3 <= __c) goto LAB_080e7777;
        }
        assert_failed = ZEXT14(0x7f < (int)__n);
        if (0x7f < (int)__n) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
          errline = 0x1e1;
          elinks_internal((uchar *)"assertion info->uniq_chars_count < FF_MAX_CHARS failed!");
          if (assert_failed != 0) goto LAB_080e76d2;
        }
        iVar10 = info->uniq_chars_count;
        __c = __c + 1;
        info->uniq_chars[iVar10] = (uchar)uVar6;
        info->uniq_chars_count = iVar10 + 1;
      } while (__c < (int)sVar3);
    }
LAB_080e7777:
    info->count = info->count + 1;
  }
  __c = 0;
  if (info->count == 0) {
    return (fastfind_index *)0x0;
  }
  do {
    pvVar4 = memchr(__s,__c,info->uniq_chars_count);
    pvVar9 = (void *)((int)pvVar4 - (int)__s);
    if (pvVar4 == (void *)0x0) {
      pvVar9 = (void *)0xffffffff;
    }
    *(void **)(info->idxtab + __c) = pvVar9;
    __c = __c + 1;
  } while (__c != 0x80);
  __c = alloc_leafset(info);
  if (__c == 0) goto return_error;
  info->root_leafset = info->leafsets[info->leafsets_count];
  if (assert_failed == 0) {
    bVar1 = 0x3ff < info->count;
    assert_failed = ZEXT14(bVar1);
    if (bVar1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
      errline = 0x138;
      elinks_internal((uchar *)"assertion info->count < FF_MAX_KEYS failed!");
      if (assert_failed != 0) goto LAB_080e76d2;
    }
    pfVar7 = (ff_data *)mem_calloc(info->count,8);
    if (pfVar7 != (ff_data *)0x0) {
      info->data = pfVar7;
      (*index->reset)();
LAB_080e78d7:
      pfVar2 = (*index->next)();
      if (pfVar2 == (fastfind_key_value *)0x0) {
        if ((*(byte *)&info->field_0x24 & 4) != 0) {
          compress_tree(info->root_leafset,info);
          return index;
        }
        return index;
      }
      __c = 0;
      __s = pfVar2->key;
      sVar3 = strlen((char *)__s);
      iVar10 = 0;
      pfVar11 = info->root_leafset;
      if (0 < (int)(sVar3 - 1)) {
        do {
          if ((*(byte *)&info->field_0x24 & 1) == 0) {
            if ((*(byte *)&info->field_0x24 & 2) != 0) {
              uVar6 = c_toupper((uint)__s[__c]);
              goto LAB_080e791c;
            }
            pp_Var5 = __ctype_toupper_loc();
            pfVar11 = pfVar11 + info->idxtab[(*pp_Var5)[__s[__c]]];
            fVar8 = *pfVar11;
            if (((uint)fVar8 & 0x1fff000) != 0) goto LAB_080e792c;
LAB_080e7977:
            iVar10 = alloc_leafset(info);
            if (iVar10 == 0) goto return_error;
            uVar6 = (uint)*(ushort *)&info->leafsets_count & 0x1fff;
            *(uint *)pfVar11 = (uint)*pfVar11 & 0xfe000fff | uVar6 << 0xc;
          }
          else {
            uVar6 = (uint)__s[__c];
LAB_080e791c:
            pfVar11 = pfVar11 + info->idxtab[uVar6];
            fVar8 = *pfVar11;
            if (((uint)fVar8 & 0x1fff000) == 0) goto LAB_080e7977;
LAB_080e792c:
            uVar6 = (uint)fVar8 >> 0xc & 0x1fff;
          }
          iVar10 = __c + 1;
          pfVar11 = info->leafsets[uVar6];
          if ((int)(sVar3 - 1) <= iVar10) goto LAB_080e79b3;
          __s = pfVar2->key;
          __c = iVar10;
        } while( true );
      }
      goto LAB_080e79bc;
    }
  }
  else {
LAB_080e76d2:
    assert_failed = 0;
  }
return_error:
  fastfind_done(index);
  return (fastfind_index *)0x0;
LAB_080e79b3:
  __s = pfVar2->key;
LAB_080e79bc:
  if ((*(byte *)&info->field_0x24 & 1) == 0) {
    if ((*(byte *)&info->field_0x24 & 2) == 0) {
      pp_Var5 = __ctype_toupper_loc();
      uVar6 = (*pp_Var5)[__s[iVar10]];
    }
    else {
      uVar6 = c_toupper((uint)__s[iVar10]);
    }
  }
  else {
    uVar6 = (uint)__s[iVar10];
  }
  pfVar11 = pfVar11 + info->idxtab[uVar6];
  *(byte *)pfVar11 = *(byte *)pfVar11 | 1;
  *(ushort *)pfVar11 =
       *(ushort *)pfVar11 & 0xf003 | (ushort)((info->pointers_count & 0xffff03ffU) << 2);
  pvVar4 = pfVar2->data;
  __c = info->pointers_count;
  pfVar7 = info->data;
  info->pointers_count = __c + 1;
  pfVar7[__c].pointer = pvVar4;
  pfVar7[__c].keylen = sVar3;
  goto LAB_080e78d7;
}



int mkalldirs(uchar *path)

{
  char cVar1;
  size_t sVar2;
  char *__path;
  int *piVar3;
  char *pcVar4;
  int iVar5;
  char *pcVar6;
  
  if (*path != '\0') {
    sVar2 = strlen((char *)path);
    __path = (char *)mem_alloc(sVar2 + 1);
    if (__path != (char *)0x0) {
      iVar5 = 0;
      memcpy(__path,path,sVar2 + 1);
      cVar1 = __path[1];
      if (cVar1 != '\0') {
        pcVar4 = __path + 1;
        pcVar6 = __path + 2;
        do {
          if (cVar1 == '/') {
            *pcVar4 = '\0';
            iVar5 = mkdir(__path,0x1c0);
            *pcVar4 = '/';
            if (iVar5 < 0) {
              piVar3 = __errno_location();
              if (*piVar3 != 0x11) break;
              iVar5 = 0;
            }
          }
          cVar1 = *pcVar6;
          pcVar4 = pcVar6;
          pcVar6 = pcVar6 + 1;
        } while (cVar1 != '\0');
      }
      mem_free(__path);
      return iVar5;
    }
  }
  return -1;
}



// WARNING: Could not reconcile some variable overlaps

directory_entry * get_directory_entries(uchar *dirname,int get_hidden)

{
  DIR *__dirp;
  dirent64 *pdVar1;
  uchar *p;
  string *psVar2;
  int iVar3;
  uint uVar4;
  passwd *ppVar5;
  group *pgVar6;
  time_t tVar7;
  uchar *fmt;
  uchar character;
  directory_entry *pdVar8;
  int in_GS_OFFSET;
  undefined4 local_f8;
  undefined4 local_f4;
  uint local_e4;
  directory_entry *local_d8;
  size_t local_d4;
  stat st;
  string attrib;
  time_t local_64;
  uchar size [64];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_e4 = 0;
  if (*dirname == '/') {
    local_e4 = (uint)(dirname[1] == '\0');
  }
  __dirp = opendir((char *)dirname);
  local_d4 = 0;
  local_d8 = (directory_entry *)0x0;
  pdVar8 = (directory_entry *)0x0;
  if (__dirp != (DIR *)0x0) {
LAB_080e7bd8:
    pdVar1 = readdir64(__dirp);
    if (pdVar1 != (dirent64 *)0x0) {
      while( true ) {
        if (pdVar1->d_name[0] == '.') {
          if (pdVar1->d_name[1] == '\0') goto LAB_080e7bd8;
          if ((pdVar1->d_name[1] != '.') || (uVar4 = local_e4 ^ 1, pdVar1->d_name[2] != '\0')) {
            uVar4 = get_hidden;
          }
          if (uVar4 == 0) goto LAB_080e7bd8;
        }
        pdVar8 = (directory_entry *)mem_realloc(local_d8,local_d4 * 8 + 0x10);
        if ((pdVar8 == (directory_entry *)0x0) ||
           (p = straconcat(dirname,pdVar1->d_name,0), local_d8 = pdVar8, p == (uchar *)0x0))
        goto LAB_080e7bd8;
        psVar2 = init_string(&attrib);
        if (psVar2 == (string *)0x0) break;
        iVar3 = __lxstat64(3,(char *)p,(stat64 *)&st);
        if (iVar3 == 0) {
          character = 'd';
          uVar4 = st.st_mode & 0xf000;
          if (((((uVar4 != 0x4000) && (character = '-', uVar4 != 0x8000)) &&
               (character = 'b', uVar4 != 0x6000)) &&
              ((character = 'c', uVar4 != 0x2000 && (character = 'p', uVar4 != 0x1000)))) &&
             ((character = 'l', uVar4 != 0xa000 && (character = '?', uVar4 == 0xc000)))) {
            character = 's';
          }
          add_char_to_string(&attrib,character);
          iVar3 = 0;
          size._0_4_ = 0x2d2d2d2d;
          size._4_4_ = 0x2d2d2d2d;
          size._8_2_ = 0x2d;
          do {
            uVar4 = st.st_mode << ((byte)iVar3 & 0x1f);
            if ((uVar4 & 0x100) != 0) {
              size[iVar3] = 'r';
            }
            if ((char)uVar4 < '\0') {
              size[iVar3 + 1] = 'w';
            }
            if ((uVar4 & 0x40) != 0) {
              size[iVar3 + 2] = 'x';
            }
            iVar3 = iVar3 + 3;
          } while (iVar3 != 9);
          if ((st.st_mode & 0x800) != 0) {
            size._0_3_ = CONCAT12((-((st.st_mode & 0x40) == 0) & 0xe0U) + 0x73,size._0_2_);
            size._0_4_ = size._0_4_ & 0xff000000 | (uint)size._0_3_;
          }
          if ((st.st_mode & 0x400) != 0) {
            size._4_2_ = CONCAT11((-((st.st_mode & 8) == 0) & 0xe0U) + 0x73,size[4]);
            size._4_4_ = size._4_4_ & 0xffff0000 | (uint)size._4_2_;
          }
          if ((st.st_mode & 0x200) != 0) {
            size._8_2_ = size._8_2_ & 0xff00 |
                         (ushort)(byte)((-((st.st_mode & 1) == 0) & 0xe0U) + 0x74);
          }
          add_to_string(&attrib,size);
          add_char_to_string(&attrib,' ');
          local_f4 = 0;
          local_f8 = 10;
          elinks_ulongcat(size,(uint *)0x0,st.st_nlink,'\x03',0x20,10);
          add_to_string(&attrib,size);
          add_char_to_string(&attrib,' ');
          if (st.st_uid != last_uid) {
            ppVar5 = getpwuid(st.st_uid);
            if ((ppVar5 == (passwd *)0x0) || (ppVar5->pw_name == (char *)0x0)) {
              __sprintf_chk(last_user,1,0x40,&DAT_08134f9e,st.st_uid,local_f8,local_f4);
            }
            else {
              __sprintf_chk(last_user,1,0x40,"%-8.8s",ppVar5->pw_name,local_f8,local_f4);
            }
            last_uid = st.st_uid;
          }
          add_to_string(&attrib,last_user);
          add_char_to_string(&attrib,' ');
          if (st.st_gid != last_gid) {
            pgVar6 = getgrgid(st.st_gid);
            if ((pgVar6 == (group *)0x0) || (pgVar6->gr_name == (char *)0x0)) {
              __sprintf_chk(last_group,1,0x40,&DAT_08134f9e,st.st_gid);
            }
            else {
              __sprintf_chk(last_group,1,0x40,"%-8.8s",pgVar6->gr_name);
            }
            last_gid = st.st_gid;
          }
          add_to_string(&attrib,last_group);
          add_char_to_string(&attrib,' ');
          if (st.st_size._4_4_ == 0) {
            iVar3 = elinks_ulongcat(size,(uint *)0x0,(uint)st.st_size,'\t',0x20,10);
            if (iVar3 - 1U < 0x3f) {
              elinks_ulongcat(size,(uint *)0x0,(uint)st.st_size,(uchar)iVar3,0x20,10);
            }
            add_to_string(&attrib,size);
            add_char_to_string(&attrib,' ');
          }
          else {
            add_to_string(&attrib,"         ");
          }
          tVar7 = time((time_t *)0x0);
          if ((st.st_mtim.tv_sec + 0xed4e00 < tVar7) ||
             (fmt = "%b %e %H:%M", tVar7 < st.st_mtim.tv_sec + -0xe10)) {
            fmt = "%b %e  %Y";
          }
          local_64 = st.st_mtim.tv_sec;
          add_date_to_string(&attrib,fmt,&local_64);
          add_char_to_string(&attrib,' ');
        }
        else {
          add_char_to_string(&attrib,'?');
          size._0_4_ = 0x2d2d2d2d;
          size._4_4_ = 0x2d2d2d2d;
          size._8_2_ = 0x2d;
          add_to_string(&attrib,size);
          add_char_to_string(&attrib,' ');
          add_to_string(&attrib,"    ");
          add_to_string(&attrib,"         ");
          add_to_string(&attrib,"         ");
          add_to_string(&attrib,"         ");
          add_to_string(&attrib,"             ");
        }
        pdVar8[local_d4].name = p;
        pdVar8[local_d4].attrib = attrib.source;
        local_d4 = local_d4 + 1;
        pdVar1 = readdir64(__dirp);
        if (pdVar1 == (dirent64 *)0x0) goto LAB_080e7f98;
      }
      mem_free(p);
      goto LAB_080e7bd8;
    }
LAB_080e7f98:
    closedir(__dirp);
    pdVar8 = local_d8;
    if (local_d4 == 0) {
      if (local_d8 != (directory_entry *)0x0) {
        pdVar8 = (directory_entry *)0x0;
        mem_free(local_d8);
      }
    }
    else {
      qsort(local_d8,local_d4,8,compare_dir_entries);
      local_d8[local_d4].attrib = (uchar *)0x0;
      local_d8[local_d4].name = (uchar *)0x0;
    }
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return pdVar8;
}



int compare_dir_entries(void *v1,void *v2)

{
  char *__s1;
  char *__s2;
  int iVar1;
  
  __s1 = *(char **)((int)v1 + 4);
  if (((*__s1 == '.') && (__s1[1] == '.')) && (__s1[2] == '\0')) {
LAB_080e82c0:
    iVar1 = -1;
  }
  else {
    __s2 = *(char **)((int)v2 + 4);
    if (((*__s2 != '.') || (__s2[1] != '.')) || (__s2[2] != '\0')) {
      if (**(char **)v1 == 'd') {
        if (**(char **)v2 == 'd') goto LAB_080e829b;
        goto LAB_080e82c0;
      }
      if (**(char **)v2 != 'd') {
LAB_080e829b:
        iVar1 = strcmp(__s1,__s2);
        return iVar1;
      }
    }
    iVar1 = 1;
  }
  return iVar1;
}



int safe_mkstemp(uchar *template)

{
  __mode_t __mask;
  int iVar1;
  
  __mask = umask(0x7f);
  iVar1 = mkstemp64((char *)template);
  umask(__mask);
  return iVar1;
}



uchar * file_read_line(uchar *line,size_t *size,FILE *file,int *lineno)

{
  byte bVar1;
  size_t sVar2;
  char *pcVar3;
  ushort **ppuVar4;
  int __c;
  size_t size_00;
  byte *pbVar5;
  byte *pbVar6;
  
  if (line == (uchar *)0x0) {
    line = (uchar *)mem_alloc(0x400);
    if (line == (byte *)0x0) {
      return (uchar *)0x0;
    }
    *size = 0x400;
    size_00 = 0x400;
  }
  else {
    size_00 = *size;
  }
  pbVar5 = (byte *)0x0;
  while( true ) {
    pcVar3 = fgets((char *)(line + (int)pbVar5),size_00 - (int)pbVar5,(FILE *)file);
    if (pcVar3 == (char *)0x0) break;
    pbVar5 = (byte *)strchr((char *)(line + (int)pbVar5),10);
    if (pbVar5 == (byte *)0x0) {
      __c = _IO_getc((_IO_FILE *)file);
      if (__c == -1) {
        *lineno = *lineno + 1;
        return line;
      }
      ungetc(__c,(FILE *)file);
      sVar2 = *size;
      size_00 = sVar2 + 0x400;
      *size = size_00;
      pbVar6 = (byte *)mem_realloc(line,size_00);
      if (pbVar6 == (byte *)0x0) break;
      pbVar5 = (byte *)(sVar2 - 1);
    }
    else {
      *lineno = *lineno + 1;
      if (line < pbVar5) {
        ppuVar4 = __ctype_b_loc();
        do {
          bVar1 = *pbVar5;
          if ((*(byte *)((int)*ppuVar4 + (uint)bVar1 * 2 + 1) & 0x20) == 0) goto joined_r0x080e83be;
          pbVar5 = pbVar5 + -1;
        } while (line < pbVar5);
      }
      bVar1 = *pbVar5;
joined_r0x080e83be:
      if (bVar1 != 0x5c) {
        pbVar5[1] = 0;
        return line;
      }
      pbVar5 = pbVar5 + ~(uint)line;
      pbVar6 = line;
    }
    size_00 = *size;
    line = pbVar6;
  }
  mem_free(line);
  return (uchar *)0x0;
}



uchar * get_tempdir_filename(uchar *name)

{
  uchar *str;
  
  str = (uchar *)getenv("TMPDIR");
  if ((str == (uchar *)0x0) || (*str == '\0')) {
    str = (uchar *)getenv("TMP");
    if ((str == (uchar *)0x0) || (*str == '\0')) {
      str = (uchar *)getenv("TEMPDIR");
      if ((str == (uchar *)0x0) || (*str == '\0')) {
        str = (uchar *)getenv("TEMP");
        if ((str == (uchar *)0x0) || (*str == '\0')) {
          str = "/tmp";
        }
      }
    }
  }
  str = straconcat(str,&DAT_08132419,name,0);
  return str;
}



uchar * get_filename_position(uchar *filename)

{
  uchar uVar1;
  uchar *puVar2;
  bool bVar3;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(filename == (uchar *)0x0);
    if (filename == (uchar *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/file.c";
      errline = 0x62;
      elinks_internal((uchar *)"assertion filename failed!");
      if (assert_failed != 0) goto LAB_080e8503;
    }
    uVar1 = *filename;
    puVar2 = filename;
    if (uVar1 != '\0') {
      do {
        puVar2 = puVar2 + 1;
        bVar3 = uVar1 == '/';
        uVar1 = *puVar2;
        if (bVar3) {
          filename = puVar2;
        }
      } while (uVar1 != '\0');
      return filename;
    }
  }
  else {
LAB_080e8503:
    assert_failed = 0;
    filename = (uchar *)0x0;
  }
  return filename;
}



uchar * expand_tilde(uchar *filename)

{
  int iVar1;
  string *psVar2;
  uchar *source;
  passwd *ppVar3;
  int iVar4;
  string file;
  
  psVar2 = init_string(&file);
  source = (uchar *)0x0;
  if (psVar2 != (string *)0x0) {
    if (*filename == '~') {
      if ((filename[1] == '\0') || (iVar1 = 0, filename[1] == '/')) {
        source = (uchar *)getenv("HOME");
        if (source != (uchar *)0x0) {
          add_to_string(&file,source);
          filename = filename + 1;
        }
      }
      else {
        do {
          iVar4 = iVar1;
          if (filename[iVar4 + 2] == '\0') break;
          iVar1 = iVar4 + 1;
        } while (filename[iVar4 + 2] != '/');
        source = memacpy(filename + 1,iVar4 + 1);
        if (source != (uchar *)0x0) {
          ppVar3 = getpwnam((char *)source);
          mem_free(source);
          if ((ppVar3 != (passwd *)0x0) && ((uchar *)ppVar3->pw_dir != (uchar *)0x0)) {
            add_to_string(&file,(uchar *)ppVar3->pw_dir);
            filename = filename + iVar4 + 2;
          }
        }
      }
    }
    add_to_string(&file,filename);
    source = file.source;
  }
  return source;
}



int file_is_dir(uchar *filename)

{
  int iVar1;
  uint uVar2;
  stat st;
  
  iVar1 = __xstat64(3,(char *)filename,(stat64 *)&st);
  uVar2 = 0;
  if (iVar1 == 0) {
    uVar2 = (uint)((st.st_mode & 0xf000) == 0x4000);
  }
  return uVar2;
}



int file_can_read(uchar *filename)

{
  uint uVar1;
  
  uVar1 = access((char *)filename,4);
  return ~uVar1 >> 0x1f;
}



int file_exists(uchar *filename)

{
  uint uVar1;
  
  uVar1 = access((char *)filename,0);
  return ~uVar1 >> 0x1f;
}



uchar * get_unique_name(uchar *fileprefix)

{
  size_t __n;
  int iVar1;
  int number;
  uchar *filename;
  int iVar2;
  int local_20;
  
  iVar2 = 0;
  __n = strlen((char *)fileprefix);
  local_20 = 1;
  number = 1;
  filename = fileprefix;
  do {
    iVar1 = file_exists(filename);
    if (iVar1 == 0) {
      return filename;
    }
    if (local_20 <= number) {
      if (9999 < number) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/file.c";
        errline = 0xa2;
        elinks_internal((uchar *)"Too big suffix in get_unique_name().");
      }
      iVar2 = iVar2 + 1;
      if (filename != fileprefix) {
        mem_free(filename);
      }
      filename = (uchar *)mem_alloc(__n + 2 + iVar2);
      if (filename == (uchar *)0x0) {
        return (uchar *)0x0;
      }
      local_20 = local_20 * 10;
      memcpy(filename,fileprefix,__n);
      filename[__n] = '.';
    }
    elinks_longcat(filename + __n + 1,(uint *)0x0,number,iVar2 + 1,'\0',10,0);
    number = number + 1;
  } while( true );
}



hash_value_T strhash(uchar *k,uint length,hash_value_T initval)

{
  hash_value_T hVar1;
  int iVar2;
  uint uVar3;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return initval;
  }
  assert_failed = ZEXT14(length == 0 || k == (uchar *)0x0);
  if (length == 0 || k == (uchar *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/hash.c";
    errline = 0xa2;
    elinks_internal((uchar *)"assertion k && length > 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return initval;
    }
  }
  uVar3 = 0;
  do {
    hVar1 = initval * 0x1f + (uint)k[uVar3];
    if (uVar3 + 1 == length) {
      return hVar1;
    }
    hVar1 = hVar1 * 0x1f + (uint)k[uVar3 + 1];
    if (uVar3 + 2 == length) {
      return hVar1;
    }
    hVar1 = hVar1 * 0x1f + (uint)k[uVar3 + 2];
    if (uVar3 + 3 == length) {
      return hVar1;
    }
    hVar1 = hVar1 * 0x1f + (uint)k[uVar3 + 3];
    if (uVar3 + 4 == length) {
      return hVar1;
    }
    hVar1 = hVar1 * 0x1f + (uint)k[uVar3 + 4];
    if (uVar3 + 5 == length) {
      return hVar1;
    }
    hVar1 = hVar1 * 0x1f + (uint)k[uVar3 + 5];
    if (uVar3 + 6 == length) {
      return hVar1;
    }
    hVar1 = hVar1 * 0x1f + (uint)k[uVar3 + 6];
    if (uVar3 + 7 == length) {
      return hVar1;
    }
    iVar2 = uVar3 + 7;
    uVar3 = uVar3 + 8;
    initval = hVar1 * 0x1f + (uint)k[iVar2];
  } while (length != uVar3);
  return initval;
}



void del_hash_item(hash *hash,hash_item *item)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(item == (hash_item *)0x0);
  if (item == (hash_item *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/hash.c";
    errline = 0x8b;
    elinks_internal((uchar *)"assertion item failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  item->next->prev = item->prev;
  item->prev->next = item->next;
  mem_free(item);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void free_hash(hash **hashp)

{
  hash *p;
  list_head_elinks *p_00;
  list_head_elinks *plVar1;
  list_head_elinks *plVar2;
  bool bVar3;
  uint local_24;
  uint local_20;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if ((hashp == (hash **)0x0) || (*hashp == (hash *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/hash.c";
    errline = 0x43;
    elinks_internal((uchar *)"assertion hashp && *hashp failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  p = *hashp;
  local_24 = p->width;
  plVar1 = p->hash;
  local_20 = 0;
  if (1 << ((byte)local_24 & 0x1f) != 0) {
    do {
      p_00 = (list_head_elinks *)p->hash[local_20].next;
      plVar2 = p_00;
      while (plVar2 != plVar1 + local_20) {
        plVar2 = (list_head_elinks *)plVar2->next;
      }
      plVar2 = (list_head_elinks *)p->hash[local_20].prev;
      while (plVar2 != plVar1 + local_20) {
        plVar2 = (list_head_elinks *)plVar2->prev;
      }
      plVar2 = (list_head_elinks *)p_00->next;
      if (p_00 != plVar1 + local_20) {
        do {
          plVar2->prev = p_00->prev;
          *(void **)p_00->prev = p_00->next;
          mem_free(p_00);
          p = *hashp;
          plVar1 = p->hash;
          bVar3 = plVar1 + local_20 != plVar2;
          p_00 = plVar2;
          plVar2 = (list_head_elinks *)plVar2->next;
        } while (bVar3);
        local_24 = p->width;
      }
      local_20 = local_20 + 1;
    } while (local_20 < (uint)(1 << ((byte)local_24 & 0x1f)));
  }
  mem_free(p);
  *hashp = (hash *)0x0;
  return;
}



hash_item * get_hash_item(hash *hash,uchar *key,uint keylen)

{
  uint *puVar1;
  hash_item *phVar2;
  hash_item *phVar3;
  hash_value_T hVar4;
  uint uVar5;
  uchar *puVar6;
  uchar *puVar7;
  bool bVar8;
  byte bVar9;
  
  bVar9 = 0;
  hVar4 = (*hash->func)(key,keylen,0xdeadbeef);
  uVar5 = hVar4 & (1 << ((byte)hash->width & 0x1f)) - 1U;
  phVar2 = (hash_item *)hash->hash[uVar5].next;
  puVar1 = &hash->width + uVar5 * 2;
  phVar3 = phVar2;
  do {
    if (phVar3 == (hash_item *)(puVar1 + 2)) {
      return (hash_item *)0x0;
    }
    if (phVar3->keylen == keylen) {
      bVar8 = true;
      uVar5 = keylen;
      puVar6 = key;
      puVar7 = phVar3->key;
      do {
        if (uVar5 == 0) break;
        uVar5 = uVar5 - 1;
        bVar8 = *puVar6 == *puVar7;
        puVar6 = puVar6 + (uint)bVar9 * -2 + 1;
        puVar7 = puVar7 + (uint)bVar9 * -2 + 1;
      } while (bVar8);
      if (bVar8) {
        if (phVar3 == phVar2) {
          return phVar3;
        }
        phVar3->next->prev = phVar3->prev;
        phVar3->prev->next = phVar3->next;
        phVar3->next = (hash_item *)puVar1[2];
        phVar3->prev = (hash_item *)(puVar1 + 2);
        *(hash_item **)(puVar1 + 2) = phVar3;
        phVar3->next->prev = phVar3;
        return phVar3;
      }
    }
    phVar3 = phVar3->next;
  } while( true );
}



hash_item * add_hash_item(hash *hash,uchar *key,uint keylen,void *value)

{
  hash_item *phVar1;
  uint uVar2;
  hash_item *phVar3;
  hash_item *phVar4;
  hash_value_T hVar5;
  
  phVar4 = (hash_item *)mem_alloc(0x14);
  if (phVar4 != (hash_item *)0x0) {
    hVar5 = (*hash->func)(key,keylen,0xdeadbeef);
    uVar2 = hash->width;
    phVar4->key = key;
    phVar1 = (hash_item *)(hash->hash + (hVar5 & (1 << ((byte)uVar2 & 0x1f)) - 1U));
    phVar4->keylen = keylen;
    phVar4->value = value;
    phVar3 = phVar1->next;
    phVar4->prev = phVar1;
    phVar4->next = phVar3;
    phVar1->next = phVar4;
    phVar4->next->prev = phVar4;
  }
  return phVar4;
}



hash * init_hash8(void)

{
  int iVar1;
  hash *phVar2;
  int iVar3;
  
  if (assert_failed == 0) {
    assert_failed = 0;
    phVar2 = (hash *)mem_alloc(0x808);
    if (phVar2 != (hash *)0x0) {
      phVar2->width = 8;
      iVar3 = 0;
      phVar2->func = strhash;
      do {
        iVar1 = (int)&phVar2->hash[0].next + iVar3;
        *(int *)((int)&phVar2->hash[0].prev + iVar3) = iVar1;
        *(int *)((int)&phVar2->hash[0].next + iVar3) = iVar1;
        iVar3 = iVar3 + 8;
      } while (iVar3 != 0x800);
    }
    return phVar2;
  }
  assert_failed = 0;
  return (hash *)0x0;
}



void init_md5(md5_context *ctx)

{
  ctx->buf[0] = 0x67452301;
  ctx->buf[1] = 0xefcdab89;
  ctx->buf[2] = 0x98badcfe;
  ctx->buf[3] = 0x10325476;
  ctx->bits[0] = 0;
  ctx->bits[1] = 0;
  return;
}



void __regparm3 transform_md5(uint32_t *buf,uint32_t *in)

{
  uint32_t uVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  uint32_t uVar5;
  uint32_t uVar6;
  uint32_t uVar7;
  uint32_t uVar8;
  uint32_t uVar9;
  uint32_t uVar10;
  uint32_t uVar11;
  uint32_t uVar12;
  uint32_t uVar13;
  uint32_t uVar14;
  uint32_t uVar15;
  uint32_t uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint uVar22;
  
  uVar1 = *in;
  uVar20 = buf[1];
  uVar21 = buf[2];
  uVar18 = buf[3];
  uVar17 = ((uVar18 ^ uVar21) & uVar20 ^ uVar18) + *buf + 0xd76aa478 + uVar1;
  uVar2 = in[1];
  uVar17 = (uVar17 >> 0x19 | uVar17 * 0x80) + uVar20;
  uVar18 = uVar18 + 0xe8c7b756 + uVar2 + ((uVar21 ^ uVar20) & uVar17 ^ uVar21);
  uVar3 = in[2];
  uVar19 = (uVar18 >> 0x14 | uVar18 * 0x1000) + uVar17;
  uVar21 = uVar21 + 0x242070db + uVar3 + ((uVar17 ^ uVar20) & uVar19 ^ uVar20);
  uVar4 = in[3];
  uVar18 = (uVar21 >> 0xf | uVar21 * 0x20000) + uVar19;
  uVar5 = in[4];
  uVar21 = ((uVar19 ^ uVar17) & uVar18 ^ uVar17) + uVar20 + 0xc1bdceee + uVar4;
  uVar22 = (uVar21 >> 10 | uVar21 * 0x400000) + uVar18;
  uVar6 = in[5];
  uVar21 = ((uVar18 ^ uVar19) & uVar22 ^ uVar19) + uVar17 + 0xf57c0faf + uVar5;
  uVar21 = (uVar21 >> 0x19 | uVar21 * 0x80) + uVar22;
  uVar7 = in[6];
  uVar20 = ((uVar22 ^ uVar18) & uVar21 ^ uVar18) + uVar19 + 0x4787c62a + uVar6;
  uVar8 = in[7];
  uVar17 = (uVar20 >> 0x14 | uVar20 * 0x1000) + uVar21;
  uVar20 = ((uVar21 ^ uVar22) & uVar17 ^ uVar22) + uVar18 + 0xa8304613 + uVar7;
  uVar20 = (uVar20 >> 0xf | uVar20 * 0x20000) + uVar17;
  uVar9 = in[8];
  uVar18 = ((uVar17 ^ uVar21) & uVar20 ^ uVar21) + uVar22 + 0xfd469501 + uVar8;
  uVar19 = (uVar18 >> 10 | uVar18 * 0x400000) + uVar20;
  uVar10 = in[9];
  uVar21 = ((uVar20 ^ uVar17) & uVar19 ^ uVar17) + uVar21 + 0x698098d8 + uVar9;
  uVar21 = (uVar21 >> 0x19 | uVar21 * 0x80) + uVar19;
  uVar11 = in[10];
  uVar18 = ((uVar19 ^ uVar20) & uVar21 ^ uVar20) + uVar17 + 0x8b44f7af + uVar10;
  uVar17 = (uVar18 >> 0x14 | uVar18 * 0x1000) + uVar21;
  uVar12 = in[0xb];
  uVar20 = ((uVar21 ^ uVar19) & uVar17 ^ uVar19) + (uVar20 - 0xa44f) + uVar11;
  uVar18 = (uVar20 >> 0xf | uVar20 * 0x20000) + uVar17;
  uVar13 = in[0xc];
  uVar20 = ((uVar17 ^ uVar21) & uVar18 ^ uVar21) + uVar19 + 0x895cd7be + uVar12;
  uVar22 = (uVar20 >> 10 | uVar20 * 0x400000) + uVar18;
  uVar14 = in[0xd];
  uVar21 = ((uVar18 ^ uVar17) & uVar22 ^ uVar17) + uVar21 + 0x6b901122 + uVar13;
  uVar20 = (uVar21 >> 0x19 | uVar21 * 0x80) + uVar22;
  uVar15 = in[0xe];
  uVar21 = ((uVar22 ^ uVar18) & uVar20 ^ uVar18) + uVar17 + 0xfd987193 + uVar14;
  uVar19 = (uVar21 >> 0x14 | uVar21 * 0x1000) + uVar20;
  uVar16 = in[0xf];
  uVar21 = ((uVar20 ^ uVar22) & uVar19 ^ uVar22) + uVar18 + 0xa679438e + uVar15;
  uVar18 = (uVar21 >> 0xf | uVar21 * 0x20000) + uVar19;
  uVar21 = uVar22 + 0x49b40821 + uVar16 + ((uVar19 ^ uVar20) & uVar18 ^ uVar20);
  uVar17 = (uVar21 >> 10 | uVar21 * 0x400000) + uVar18;
  uVar21 = uVar20 + 0xf61e2562 + uVar2 + ((uVar17 ^ uVar18) & uVar19 ^ uVar18);
  uVar20 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar17;
  uVar21 = uVar19 + 0xc040b340 + uVar7 + ((uVar20 ^ uVar17) & uVar18 ^ uVar17);
  uVar19 = (uVar21 >> 0x17 | uVar21 * 0x200) + uVar20;
  uVar21 = uVar18 + 0x265e5a51 + uVar12 + ((uVar19 ^ uVar20) & uVar17 ^ uVar20);
  uVar18 = (uVar21 >> 0x12 | uVar21 * 0x4000) + uVar19;
  uVar21 = uVar17 + 0xe9b6c7aa + uVar1 + ((uVar18 ^ uVar19) & uVar20 ^ uVar19);
  uVar17 = (uVar21 >> 0xc | uVar21 * 0x100000) + uVar18;
  uVar21 = uVar20 + 0xd62f105d + uVar6 + ((uVar17 ^ uVar18) & uVar19 ^ uVar18);
  uVar20 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar17;
  uVar21 = uVar19 + 0x2441453 + uVar11 + ((uVar20 ^ uVar17) & uVar18 ^ uVar17);
  uVar19 = (uVar21 >> 0x17 | uVar21 * 0x200) + uVar20;
  uVar21 = uVar18 + 0xd8a1e681 + uVar16 + ((uVar19 ^ uVar20) & uVar17 ^ uVar20);
  uVar18 = (uVar21 >> 0x12 | uVar21 * 0x4000) + uVar19;
  uVar21 = uVar17 + 0xe7d3fbc8 + uVar5 + ((uVar18 ^ uVar19) & uVar20 ^ uVar19);
  uVar17 = (uVar21 >> 0xc | uVar21 * 0x100000) + uVar18;
  uVar21 = uVar20 + 0x21e1cde6 + uVar10 + ((uVar17 ^ uVar18) & uVar19 ^ uVar18);
  uVar20 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar17;
  uVar21 = uVar19 + 0xc33707d6 + uVar15 + ((uVar20 ^ uVar17) & uVar18 ^ uVar17);
  uVar19 = (uVar21 >> 0x17 | uVar21 * 0x200) + uVar20;
  uVar21 = uVar18 + 0xf4d50d87 + uVar4 + ((uVar19 ^ uVar20) & uVar17 ^ uVar20);
  uVar18 = (uVar21 >> 0x12 | uVar21 * 0x4000) + uVar19;
  uVar21 = uVar17 + 0x455a14ed + uVar9 + ((uVar18 ^ uVar19) & uVar20 ^ uVar19);
  uVar17 = (uVar21 >> 0xc | uVar21 * 0x100000) + uVar18;
  uVar21 = uVar20 + 0xa9e3e905 + uVar14 + ((uVar17 ^ uVar18) & uVar19 ^ uVar18);
  uVar20 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar17;
  uVar21 = uVar19 + 0xfcefa3f8 + uVar3 + ((uVar20 ^ uVar17) & uVar18 ^ uVar17);
  uVar19 = (uVar21 >> 0x17 | uVar21 * 0x200) + uVar20;
  uVar21 = uVar18 + 0x676f02d9 + uVar8 + ((uVar19 ^ uVar20) & uVar17 ^ uVar20);
  uVar18 = (uVar21 >> 0x12 | uVar21 * 0x4000) + uVar19;
  uVar21 = ((uVar18 ^ uVar19) & uVar20 ^ uVar19) + uVar17 + 0x8d2a4c8a + uVar13;
  uVar17 = (uVar21 >> 0xc | uVar21 * 0x100000) + uVar18;
  uVar21 = (uVar20 - 0x5c6be) + uVar6 + (uVar18 ^ uVar19 ^ uVar17);
  uVar20 = (uVar21 >> 0x1c | uVar21 * 0x10) + uVar17;
  uVar21 = uVar19 + 0x8771f681 + uVar9 + (uVar17 ^ uVar18 ^ uVar20);
  uVar19 = (uVar21 >> 0x15 | uVar21 * 0x800) + uVar20;
  uVar21 = uVar18 + 0x6d9d6122 + uVar12 + (uVar20 ^ uVar17 ^ uVar19);
  uVar18 = (uVar21 >> 0x10 | uVar21 * 0x10000) + uVar19;
  uVar21 = uVar17 + 0xfde5380c + uVar15 + (uVar19 ^ uVar20 ^ uVar18);
  uVar17 = (uVar21 >> 9 | uVar21 * 0x800000) + uVar18;
  uVar21 = uVar20 + 0xa4beea44 + uVar2 + (uVar18 ^ uVar19 ^ uVar17);
  uVar20 = (uVar21 >> 0x1c | uVar21 * 0x10) + uVar17;
  uVar21 = uVar19 + 0x4bdecfa9 + uVar5 + (uVar17 ^ uVar18 ^ uVar20);
  uVar19 = (uVar21 >> 0x15 | uVar21 * 0x800) + uVar20;
  uVar21 = uVar18 + 0xf6bb4b60 + uVar8 + (uVar20 ^ uVar17 ^ uVar19);
  uVar18 = (uVar21 >> 0x10 | uVar21 * 0x10000) + uVar19;
  uVar21 = uVar17 + 0xbebfbc70 + uVar11 + (uVar19 ^ uVar20 ^ uVar18);
  uVar17 = (uVar21 >> 9 | uVar21 * 0x800000) + uVar18;
  uVar21 = uVar20 + 0x289b7ec6 + uVar14 + (uVar18 ^ uVar19 ^ uVar17);
  uVar22 = (uVar21 >> 0x1c | uVar21 * 0x10) + uVar17;
  uVar21 = uVar19 + 0xeaa127fa + uVar1 + (uVar17 ^ uVar18 ^ uVar22);
  uVar19 = (uVar21 >> 0x15 | uVar21 * 0x800) + uVar22;
  uVar21 = uVar18 + 0xd4ef3085 + uVar4 + (uVar22 ^ uVar17 ^ uVar19);
  uVar20 = (uVar21 >> 0x10 | uVar21 * 0x10000) + uVar19;
  uVar21 = uVar17 + 0x4881d05 + uVar7 + (uVar19 ^ uVar22 ^ uVar20);
  uVar18 = (uVar21 >> 9 | uVar21 * 0x800000) + uVar20;
  uVar21 = uVar22 + 0xd9d4d039 + uVar10 + (uVar20 ^ uVar19 ^ uVar18);
  uVar22 = (uVar21 >> 0x1c | uVar21 * 0x10) + uVar18;
  uVar21 = uVar19 + 0xe6db99e5 + uVar13 + (uVar18 ^ uVar20 ^ uVar22);
  uVar17 = (uVar21 >> 0x15 | uVar21 * 0x800) + uVar22;
  uVar21 = uVar20 + 0x1fa27cf8 + uVar16 + (uVar22 ^ uVar18 ^ uVar17);
  uVar19 = (uVar21 >> 0x10 | uVar21 * 0x10000) + uVar17;
  uVar21 = uVar18 + 0xc4ac5665 + uVar3 + (uVar17 ^ uVar22 ^ uVar19);
  uVar18 = (uVar21 >> 9 | uVar21 * 0x800000) + uVar19;
  uVar21 = uVar22 + 0xf4292244 + uVar1 + ((~uVar17 | uVar18) ^ uVar19);
  uVar20 = (uVar21 >> 0x1a | uVar21 * 0x40) + uVar18;
  uVar21 = uVar17 + 0x432aff97 + uVar8 + ((~uVar19 | uVar20) ^ uVar18);
  uVar17 = (uVar21 >> 0x16 | uVar21 * 0x400) + uVar20;
  uVar21 = uVar19 + 0xab9423a7 + uVar15 + ((~uVar18 | uVar17) ^ uVar20);
  uVar19 = (uVar21 >> 0x11 | uVar21 * 0x8000) + uVar17;
  uVar21 = uVar18 + 0xfc93a039 + uVar6 + ((~uVar20 | uVar19) ^ uVar17);
  uVar21 = (uVar21 >> 0xb | uVar21 * 0x200000) + uVar19;
  uVar20 = uVar20 + 0x655b59c3 + uVar13 + ((~uVar17 | uVar21) ^ uVar19);
  uVar18 = (uVar20 >> 0x1a | uVar20 * 0x40) + uVar21;
  uVar20 = uVar17 + 0x8f0ccc92 + uVar4 + ((~uVar19 | uVar18) ^ uVar21);
  uVar17 = (uVar20 >> 0x16 | uVar20 * 0x400) + uVar18;
  uVar20 = (uVar19 - 0x100b83) + uVar11 + ((~uVar21 | uVar17) ^ uVar18);
  uVar19 = (uVar20 >> 0x11 | uVar20 * 0x8000) + uVar17;
  uVar21 = uVar21 + 0x85845dd1 + uVar2 + ((~uVar18 | uVar19) ^ uVar17);
  uVar20 = (uVar21 >> 0xb | uVar21 * 0x200000) + uVar19;
  uVar21 = uVar18 + 0x6fa87e4f + uVar9 + ((~uVar17 | uVar20) ^ uVar19);
  uVar18 = (uVar21 >> 0x1a | uVar21 * 0x40) + uVar20;
  uVar21 = uVar17 + 0xfe2ce6e0 + uVar16 + ((~uVar19 | uVar18) ^ uVar20);
  uVar17 = (uVar21 >> 0x16 | uVar21 * 0x400) + uVar18;
  uVar21 = uVar19 + 0xa3014314 + uVar7 + ((~uVar20 | uVar17) ^ uVar18);
  uVar19 = (uVar21 >> 0x11 | uVar21 * 0x8000) + uVar17;
  uVar21 = uVar20 + 0x4e0811a1 + uVar14 + ((~uVar18 | uVar19) ^ uVar17);
  uVar20 = (uVar21 >> 0xb | uVar21 * 0x200000) + uVar19;
  uVar21 = uVar18 + 0xf7537e82 + uVar5 + ((~uVar17 | uVar20) ^ uVar19);
  uVar18 = (uVar21 >> 0x1a | uVar21 * 0x40) + uVar20;
  uVar21 = uVar17 + 0xbd3af235 + uVar12 + ((~uVar19 | uVar18) ^ uVar20);
  uVar22 = (uVar21 >> 0x16 | uVar21 * 0x400) + uVar18;
  uVar21 = uVar19 + 0x2ad7d2bb + uVar3 + ((~uVar20 | uVar22) ^ uVar18);
  uVar17 = (uVar21 >> 0x11 | uVar21 * 0x8000) + uVar22;
  uVar21 = uVar20 + 0xeb86d391 + uVar10 + ((~uVar18 | uVar17) ^ uVar22);
  *buf = uVar18 + *buf;
  buf[2] = buf[2] + uVar17;
  buf[3] = buf[3] + uVar22;
  buf[1] = buf[1] + uVar17 + (uVar21 >> 0xb | uVar21 * 0x200000);
  return;
}



void update_md5(md5_context *ctx,uchar *buf,ulong len)

{
  uint32_t *in;
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint32_t uVar5;
  uchar *local_28;
  uint local_20;
  
  local_20 = len;
  local_28 = buf;
  uVar1 = ctx->bits[0];
  uVar2 = uVar1 + len * 8;
  ctx->bits[0] = uVar2;
  if (uVar2 < uVar1) {
    uVar5 = ctx->bits[1] + 1;
    ctx->bits[1] = uVar5;
  }
  else {
    uVar5 = ctx->bits[1];
  }
  uVar2 = uVar1 >> 3 & 0x3f;
  ctx->bits[1] = uVar5 + (len >> 0x1d);
  in = (uint32_t *)ctx->in;
  if (uVar2 != 0) {
    local_20 = 0x40 - uVar2;
    if (len < local_20) {
      memmove(ctx->in + uVar2,buf,len);
      return;
    }
    memmove(ctx->in + uVar2,buf,local_20);
    iVar3 = 0;
    do {
      *(undefined4 *)((int)in + iVar3) =
           CONCAT22(CONCAT11(ctx->in[iVar3 + 3],ctx->in[iVar3 + 2]),
                    CONCAT11(ctx->in[iVar3 + 1],*(undefined *)((int)in + iVar3)));
      iVar3 = iVar3 + 4;
    } while (iVar3 != 0x40);
    transform_md5((uint32_t *)ctx,in);
    local_28 = buf + local_20;
    local_20 = len - local_20;
  }
  if (0x3f < local_20) {
    iVar3 = 0;
    do {
      memmove(in,local_28 + iVar3,0x40);
      iVar4 = 0;
      do {
        *(undefined4 *)((int)in + iVar4) =
             CONCAT22(CONCAT11(ctx->in[iVar4 + 3],ctx->in[iVar4 + 2]),
                      CONCAT11(ctx->in[iVar4 + 1],*(undefined *)((int)in + iVar4)));
        iVar4 = iVar4 + 4;
      } while (iVar4 != 0x40);
      iVar3 = iVar3 + 0x40;
      transform_md5((uint32_t *)ctx,in);
    } while (0x3f < local_20 - iVar3);
    uVar2 = local_20 - 0x40;
    local_20 = uVar2 & 0x3f;
    local_28 = local_28 + (uVar2 & 0xffffffc0) + 0x40;
  }
  memmove(in,local_28,local_20);
  return;
}



void done_md5(md5_context *ctx,uchar *digest)

{
  uint uVar1;
  int iVar2;
  md5_context *pmVar3;
  uint __n;
  uint32_t *in;
  bool bVar4;
  byte bVar5;
  
  bVar5 = 0;
  uVar1 = ctx->bits[0] >> 3 & 0x3f;
  __n = -uVar1 + 0x3f;
  ctx->in[uVar1] = -0x80;
  if (__n < 8) {
    in = (uint32_t *)ctx->in;
    memset(ctx->in + uVar1 + 1,0,__n);
    iVar2 = 0;
    do {
      *(undefined4 *)((int)in + iVar2) =
           CONCAT22(CONCAT11(ctx->in[iVar2 + 3],ctx->in[iVar2 + 2]),
                    CONCAT11(ctx->in[iVar2 + 1],*(undefined *)((int)in + iVar2)));
      iVar2 = iVar2 + 4;
    } while (iVar2 != 0x40);
    transform_md5((uint32_t *)ctx,in);
    bVar4 = ((uint)in & 1) != 0;
    uVar1 = 0x38;
    if (bVar4) {
      ctx->in[0] = '\0';
      in = (uint32_t *)(ctx->in + 1);
      uVar1 = 0x37;
    }
    if (((uint)in & 2) != 0) {
      *(undefined2 *)in = 0;
      uVar1 = uVar1 - 2;
      in = (uint32_t *)((int)in + 2);
    }
    __n = uVar1 >> 2;
    while (__n != 0) {
      __n = __n - 1;
      *in = 0;
      in = in + (uint)bVar5 * 0x3ffffffe + 1;
    }
    if ((uVar1 & 2) != 0) {
      *(undefined2 *)in = 0;
      in = (uint32_t *)((int)in + 2);
    }
    if (bVar4) {
      *(undefined *)in = 0;
    }
  }
  else {
    memset(ctx->in + uVar1 + 1,0,-uVar1 + 0x37);
  }
  in = (uint32_t *)ctx->in;
  iVar2 = 0;
  do {
    *(undefined4 *)((int)in + iVar2) =
         CONCAT22(CONCAT11(ctx->in[iVar2 + 3],ctx->in[iVar2 + 2]),
                  CONCAT11(ctx->in[iVar2 + 1],*(undefined *)((int)in + iVar2)));
    iVar2 = iVar2 + 4;
  } while (iVar2 != 0x38);
  *(uint32_t *)(ctx->in + 0x38) = ctx->bits[0];
  *(uint32_t *)(ctx->in + 0x3c) = ctx->bits[1];
  transform_md5((uint32_t *)ctx,in);
  pmVar3 = ctx;
  do {
    pmVar3->buf[0] = pmVar3->buf[0];
    pmVar3 = (md5_context *)(pmVar3->buf + 1);
  } while (pmVar3 != (md5_context *)ctx->bits);
  memmove(digest,ctx,0x10);
  iVar2 = 0x16;
  while (iVar2 != 0) {
    iVar2 = iVar2 + -1;
    ctx->buf[0] = 0;
    ctx = (md5_context *)((int)ctx + (uint)bVar5 * -8 + 4);
  }
  return;
}



uchar * digest_md5(uchar *data,ulong length,uchar *digest)

{
  int iVar1;
  int in_GS_OFFSET;
  md5_context ctx;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  ctx.buf[0] = 0x67452301;
  ctx.buf[1] = 0xefcdab89;
  ctx.buf[2] = 0x98badcfe;
  ctx.buf[3] = 0x10325476;
  ctx.bits[0] = 0;
  ctx.bits[1] = 0;
  if (length != 0) {
    update_md5(&ctx,data,length);
  }
  done_md5(&ctx,digest);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return digest;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void freeml(memory_list *ml)

{
  void **ppvVar1;
  int iVar2;
  
  if (ml != (memory_list *)0x0) {
    if (0 < ml->n) {
      iVar2 = 0;
      do {
        ppvVar1 = ml->p + iVar2;
        iVar2 = iVar2 + 1;
        mem_free(*ppvVar1);
      } while (ml->n != iVar2 && iVar2 <= ml->n);
    }
    mem_free(ml);
    return;
  }
  return;
}



void add_one_to_ml(memory_list **ml,void *p)

{
  int iVar1;
  memory_list *p_00;
  
  if (p != (void *)0x0) {
    p_00 = *ml;
    if (p_00 == (memory_list *)0x0) {
      p_00 = (memory_list *)mem_alloc(0xc);
      *ml = p_00;
      if (p_00 == (memory_list *)0x0) {
        return;
      }
      p_00->n = 0;
      p_00 = *ml;
    }
    else {
      p_00 = (memory_list *)mem_realloc(p_00,p_00->n * 4 + 0xc);
      if (p_00 == (memory_list *)0x0) {
        return;
      }
      *ml = p_00;
    }
    iVar1 = p_00->n;
    p_00->p[iVar1] = p;
    p_00->n = iVar1 + 1;
  }
  return;
}



void add_to_ml(memory_list **ml,...)

{
  void **ppvVar1;
  int iVar2;
  memory_list *p;
  void *in_stack_00000008;
  
  if (in_stack_00000008 != (void *)0x0) {
    iVar2 = 0;
    do {
      iVar2 = iVar2 + 1;
    } while ((&stack0x00000008)[iVar2] != 0);
    if (iVar2 != 0) {
      p = *ml;
      if (p == (memory_list *)0x0) {
        p = (memory_list *)mem_alloc(iVar2 * 4 + 8);
        *ml = p;
        if (p == (memory_list *)0x0) {
          return;
        }
        p->n = 0;
      }
      else {
        p = (memory_list *)mem_realloc(p,(iVar2 + p->n) * 4 + 8);
        if (p == (memory_list *)0x0) {
          return;
        }
        *ml = p;
      }
      ppvVar1 = (void **)&stack0x0000000c;
      while (in_stack_00000008 != (void *)0x0) {
        p = *ml;
        iVar2 = p->n;
        p->p[iVar2] = in_stack_00000008;
        p->n = iVar2 + 1;
        in_stack_00000008 = *ppvVar1;
        ppvVar1 = ppvVar1 + 1;
      }
    }
  }
  return;
}



memory_list * getml(void *p,...)

{
  void *pvVar1;
  memory_list *pmVar2;
  int iVar3;
  size_t size;
  int *piVar4;
  memory_list *pmVar5;
  int in_stack_00000008;
  
  pvVar1 = p;
  pmVar2 = (memory_list *)0x0;
  if (p != (void *)0x0) {
    iVar3 = 1;
    size = 0xc;
    if (in_stack_00000008 != 0) {
      do {
        iVar3 = iVar3 + 1;
      } while ((&p)[iVar3] != (void *)0x0);
      size = iVar3 * 4 + 8;
    }
    pmVar2 = (memory_list *)mem_alloc(size);
    if (pmVar2 != (memory_list *)0x0) {
      pmVar2->n = 1;
      pmVar2->p[0] = pvVar1;
      if (in_stack_00000008 != 0) {
        pmVar5 = pmVar2 + 1;
        iVar3 = 1;
        piVar4 = (int *)&stack0x0000000c;
        do {
          iVar3 = iVar3 + 1;
          pmVar5->n = in_stack_00000008;
          pmVar5 = (memory_list *)pmVar5->p;
          pmVar2->n = iVar3;
          in_stack_00000008 = *piVar4;
          piVar4 = piVar4 + 1;
        } while (in_stack_00000008 != 0);
        return pmVar2;
      }
    }
  }
  return pmVar2;
}



size_t __regparm3 round_size(size_t size)

{
  if (page_size == 0) {
    page_size = sysconf(0x1e);
  }
  if (page_size < 1) {
    page_size = 1;
  }
  return (size / (uint)page_size + 1) * page_size;
}



void mem_mmap_free(void *p,size_t size)

{
  size_t __len;
  
  if (p != (void *)0x0) {
    __len = round_size(size);
    munmap(p,__len);
    return;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/memory.c";
  errline = 0xa7;
  elinks_internal((uchar *)"mem_mmap_free(NULL)");
  return;
}



void * mem_mmap_alloc(size_t size)

{
  size_t __len;
  void *pvVar1;
  
  if (size != 0) {
    __len = round_size(size);
    pvVar1 = mmap64((void *)0x0,__len,3,0x21,-1,0);
    if (pvVar1 != (void *)0xffffffff) {
      return pvVar1;
    }
  }
  return (void *)0x0;
}



void * mem_mmap_realloc(void *p,size_t old_size,size_t new_size)

{
  size_t __new_len;
  size_t __old_len;
  void *pvVar1;
  void *pvVar2;
  
  if (p != (void *)0x0) {
    __new_len = round_size(old_size);
    __old_len = round_size(new_size);
    pvVar2 = p;
    if (__new_len != __old_len) {
      if (new_size == 0) {
        pvVar2 = (void *)0x0;
        mem_mmap_free(p,old_size);
      }
      else {
        __new_len = round_size(new_size);
        __old_len = round_size(old_size);
        pvVar1 = mremap(p,__old_len,__new_len,1);
        pvVar2 = (void *)0x0;
        if (pvVar1 != (void *)0xffffffff) {
          pvVar2 = pvVar1;
        }
      }
    }
    return pvVar2;
  }
  pvVar2 = mem_mmap_alloc(new_size);
  return pvVar2;
}



int __regparm3 patience(uchar *of)

{
  alloc_try = alloc_try + 1;
  if (2 < alloc_try) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/memory.c";
    errline = 0x2e;
    elinks_error((uchar *)
                 "Out of memory (%s returned NULL) after %d tries, I give up and try to continue. Pray for me, please."
                 ,of,alloc_try);
    alloc_try = 0;
    return 0;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/memory.c";
  errline = 0x22;
  elinks_error((uchar *)
               "Out of memory (%s returned NULL): retry #%d/%d, I still exercise my patience and retry tirelessly."
               ,of,alloc_try,3);
  sleep(3);
  return alloc_try;
}



void mem_free(void *p)

{
  if (p != (void *)0x0) {
    free(p);
    return;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/memory.c";
  errline = 0x5a;
  elinks_internal((uchar *)"mem_free(NULL)");
  return;
}



void * mem_calloc(size_t count,size_t eltsize)

{
  void *pvVar1;
  int iVar2;
  
  if ((eltsize != 0) && (count != 0)) {
    do {
      pvVar1 = calloc(count,eltsize);
      if (pvVar1 != (void *)0x0) {
        return pvVar1;
      }
      iVar2 = patience((uchar *)"calloc");
    } while (iVar2 != 0);
    return (void *)0x0;
  }
  return (void *)0x0;
}



void * mem_alloc(size_t size)

{
  int iVar1;
  void *pvVar2;
  
  pvVar2 = (void *)0x0;
  if (size != 0) {
    do {
      pvVar2 = malloc(size);
      if (pvVar2 != (void *)0x0) {
        return pvVar2;
      }
      iVar1 = patience((uchar *)"malloc");
    } while (iVar1 != 0);
  }
  return pvVar2;
}



void * mem_realloc(void *p,size_t size)

{
  void *pvVar1;
  int iVar2;
  
  if (p == (void *)0x0) {
    pvVar1 = mem_alloc(size);
    return pvVar1;
  }
  if (size == 0) {
    pvVar1 = (void *)0x0;
    mem_free(p);
  }
  else {
    do {
      pvVar1 = realloc(p,size);
      if (pvVar1 != (void *)0x0) {
        return pvVar1;
      }
      iVar2 = patience((uchar *)"realloc");
    } while (iVar2 != 0);
  }
  return pvVar1;
}



// WARNING: Exceeded maximum restarts with more pending

scanner_token * skip_scanner_tokens(scanner *scanner,int skipto,int precedence)

{
  scanner_token *psVar1;
  int iVar2;
  scanner_token *psVar3;
  scanner_token *psVar4;
  int iVar5;
  
  iVar5 = scanner->tokens;
  if (0 < iVar5) {
    psVar4 = scanner->current;
    iVar2 = iVar5 + 1;
    if ((psVar4 < (scanner_token *)(&scanner->current + iVar2 * 4)) &&
       (psVar4 != (scanner_token *)0x0)) {
      if (psVar4->type == skipto) {
LAB_080e9e3b:
        if (0 < iVar5) {
          psVar3 = scanner->current;
          psVar4 = scanner->table + iVar5;
          if (psVar3 < psVar4) {
            psVar1 = psVar3 + 1;
            scanner->current = psVar1;
            if (psVar4 <= psVar3 + 2) {
                    // WARNING: Could not recover jumptable at 0x080e9e78. Too many branches
                    // WARNING: Treating indirect jump as call
              psVar4 = (*scanner->info->scan)();
              return psVar4;
            }
            if (psVar1 < psVar4) {
              return psVar1;
            }
          }
        }
      }
      else {
        if (psVar4->precedence <= precedence) {
          while (psVar4 < (scanner_token *)(&scanner->current + iVar2 * 4)) {
            psVar3 = psVar4 + 1;
            scanner->current = psVar3;
            if (psVar4 + 2 < scanner->table + iVar5) {
              if (iVar5 < 1) {
                return (scanner_token *)0x0;
              }
              if (scanner->table + iVar5 <= psVar3) {
                return (scanner_token *)0x0;
              }
            }
            else {
              psVar3 = (*scanner->info->scan)(scanner);
            }
            if (psVar3 == (scanner_token *)0x0) {
              return (scanner_token *)0x0;
            }
            if (psVar3->type == skipto) {
LAB_080e9e38:
              iVar5 = scanner->tokens;
              goto LAB_080e9e3b;
            }
            if (psVar3->precedence != precedence && precedence <= psVar3->precedence) {
              if (skipto != psVar3->type) {
                return (scanner_token *)0x0;
              }
              goto LAB_080e9e38;
            }
            iVar5 = scanner->tokens;
            if (iVar5 < 1) {
              return (scanner_token *)0x0;
            }
            psVar4 = scanner->current;
            iVar2 = iVar5 + 1;
          }
        }
      }
    }
  }
  return (scanner_token *)0x0;
}



// WARNING: Exceeded maximum restarts with more pending

void init_scanner(scanner *scanner,scanner_info *scanner_info,uchar *string,uchar *end)

{
  byte *pbVar1;
  int iVar2;
  bool bVar3;
  byte bVar4;
  uint *puVar5;
  size_t sVar6;
  int iVar7;
  anon_enum_32_for_type aVar8;
  scan_table_info *psVar9;
  uint uVar10;
  scanner *psVar11;
  byte bVar12;
  byte local_34;
  uchar *local_2c;
  scan_table_info *local_20;
  
  bVar12 = 0;
  local_2c = end;
  bVar4 = *(byte *)&scanner_info->field_0x40c;
  if ((bVar4 & 1) == 0) {
    psVar9 = scanner_info->scan_table_info;
    if ((psVar9 != (scan_table_info *)0x0) && (aVar8 = psVar9->type, aVar8 != _IScntrl)) {
      local_20 = psVar9 + 1;
      do {
        while (aVar8 != SCAN_RANGE) {
          iVar7 = *(int *)((int)&psVar9->data + 4);
          iVar2 = *(int *)&psVar9->data;
          uVar10 = iVar7 - 1;
          if (assert_failed == 0) {
            assert_failed = (uint)(aVar8 != _ISblank) | uVar10 >> 0x1f;
            if (assert_failed != 0) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.c";
              errline = 0x96;
              elinks_internal((uchar *)"assertion info[i].type == SCAN_STRING && pos >= 0 failed!");
              goto LAB_080ea03f;
            }
          }
          else {
LAB_080ea03f:
            if ((int)uVar10 < 0) goto LAB_080e9f50;
          }
          iVar7 = iVar2 + iVar7;
          do {
            pbVar1 = (byte *)(iVar7 + -1);
            iVar7 = iVar7 + -1;
            scanner_info->scan_table[*pbVar1] = scanner_info->scan_table[*pbVar1] | psVar9->bits;
          } while (iVar7 != iVar2);
          aVar8 = local_20->type;
          psVar9 = local_20;
          local_20 = local_20 + 1;
          if (aVar8 == _IScntrl) goto LAB_080e9f62;
        }
        local_34 = **(byte **)&psVar9->data;
        uVar10 = (uint)local_34;
        if (assert_failed == 0) {
          assert_failed = ZEXT14(local_34 == 0);
          if (local_34 == 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.c";
            errline = 0x8b;
            elinks_internal((uchar *)"assertion index > 0 failed!");
            local_34 = 0;
            if (assert_failed != 0) goto LAB_080e9f30;
          }
          bVar3 = 0xff < *(int *)((int)&psVar9->data + 4);
          assert_failed = ZEXT14(bVar3);
          if (bVar3) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.c";
            errline = 0x8c;
            elinks_internal((uchar *)"assertion data->range.end < SCAN_TABLE_SIZE failed!");
            if (assert_failed != 0) goto LAB_080e9f30;
          }
          bVar3 = *(int *)((int)&psVar9->data + 4) < (int)uVar10;
          assert_failed = ZEXT14(bVar3);
          if (bVar3) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.c";
            errline = 0x8d;
            elinks_internal((uchar *)"assertion index <= data->range.end failed!");
          }
        }
LAB_080e9f30:
        if ((int)uVar10 <= *(int *)((int)&psVar9->data + 4)) {
          puVar5 = (uint *)(scanner_info->scan_table + local_34);
          do {
            uVar10 = uVar10 + 1;
            *puVar5 = *puVar5 | psVar9->bits;
            puVar5 = puVar5 + 1;
          } while ((int)uVar10 <= *(int *)((int)&psVar9->data + 4));
        }
LAB_080e9f50:
        aVar8 = local_20->type;
        psVar9 = local_20;
        local_20 = local_20 + 1;
      } while (aVar8 != _IScntrl);
LAB_080e9f62:
      bVar4 = *(byte *)&scanner_info->field_0x40c;
    }
    *(byte *)&scanner_info->field_0x40c = bVar4 | 1;
  }
  iVar7 = 0x2f;
  psVar11 = scanner;
  while (iVar7 != 0) {
    iVar7 = iVar7 + -1;
    psVar11->string = (uchar *)0x0;
    psVar11 = (scanner *)((int)psVar11 + (uint)bVar12 * -8 + 4);
  }
  scanner->string = string;
  scanner->position = string;
  if (end == (uchar *)0x0) {
    sVar6 = strlen((char *)string);
    local_2c = string + sVar6;
  }
  scanner->info = scanner_info;
  scanner->end = local_2c;
  scanner->current = scanner->table;
                    // WARNING: Could not recover jumptable at 0x080e9fb5. Too many branches
                    // WARNING: Treating indirect jump as call
  (*scanner_info->scan)();
  return;
}



int map_scanner_string(scanner *scanner,uchar *ident,uchar *end,int base_type)

{
  uchar *puVar1;
  int iVar2;
  scanner_string_mapping *psVar3;
  
  psVar3 = scanner->info->mappings;
  puVar1 = psVar3->name;
  do {
    if (puVar1 == (uchar *)0x0) {
      return base_type;
    }
    if (psVar3->base_type == base_type) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.c";
      errline = 0x1c;
      iVar2 = elinks_strlcasecmp(psVar3->name,0xffffffff,ident,(size_t)(end + -(int)ident),1);
      if (iVar2 == 0) {
        return psVar3->type;
      }
    }
    psVar3 = psVar3 + 1;
    puVar1 = psVar3->name;
  } while( true );
}



int secure_fprintf(secure_save_info *ssi,char *format,...)

{
  int *piVar1;
  int iVar2;
  
  if (((ssi == (secure_save_info *)0x0) || (ssi->fp == (FILE *)0x0)) || (ssi->err != 0)) {
    iVar2 = -1;
  }
  else {
    iVar2 = __vfprintf_chk(ssi->fp,1,format,&stack0x0000000c);
    if (iVar2 < 0) {
      piVar1 = __errno_location();
      ssi->err = *piVar1;
    }
  }
  return iVar2;
}



int secure_fputc(secure_save_info *ssi,int c)

{
  int *piVar1;
  int iVar2;
  
  if (((ssi == (secure_save_info *)0x0) || (ssi->fp == (FILE *)0x0)) || (ssi->err != 0)) {
    iVar2 = -1;
  }
  else {
    iVar2 = fputc(c,(FILE *)ssi->fp);
    if (iVar2 == -1) {
      piVar1 = __errno_location();
      ssi->err = *piVar1;
      secsave_errno = SS_ERR_OTHER;
    }
  }
  return iVar2;
}



int secure_fputs(secure_save_info *ssi,char *s)

{
  int *piVar1;
  int iVar2;
  
  if (((ssi == (secure_save_info *)0x0) || (ssi->fp == (FILE *)0x0)) || (ssi->err != 0)) {
    iVar2 = -1;
  }
  else {
    iVar2 = fputs(s,(FILE *)ssi->fp);
    if (iVar2 == -1) {
      secsave_errno = SS_ERR_OTHER;
      piVar1 = __errno_location();
      ssi->err = *piVar1;
    }
  }
  return iVar2;
}



int secure_close(secure_save_info *ssi)

{
  FILE *__stream;
  int __fd;
  uchar *p;
  int *piVar1;
  uchar *name;
  int iVar2;
  
  iVar2 = -1;
  if (ssi == (secure_save_info *)0x0) {
    return -1;
  }
  __stream = ssi->fp;
  if (__stream == (FILE *)0x0) {
free:
    if (ssi->tmp_file_name != (uchar *)0x0) {
      mem_free(ssi->tmp_file_name);
    }
    p = ssi->file_name;
    if (p == (uchar *)0x0) goto LAB_080ea34e;
  }
  else {
    iVar2 = ssi->err;
    if (iVar2 != 0) {
LAB_080ea380:
      fclose((FILE *)__stream);
      goto free;
    }
    if (ssi->secure_save != 0) {
      __fd = fflush((FILE *)__stream);
      if (__fd == -1) {
LAB_080ea36d:
        piVar1 = __errno_location();
        iVar2 = *piVar1;
        secsave_errno = SS_ERR_OTHER;
        __stream = ssi->fp;
        goto LAB_080ea380;
      }
      piVar1 = get_opt_(config_options,name);
      if (*piVar1 == 0) {
        __stream = ssi->fp;
      }
      else {
        __fd = fileno((FILE *)ssi->fp);
        __fd = fsync(__fd);
        if (__fd != 0) goto LAB_080ea36d;
        __stream = ssi->fp;
      }
    }
    __fd = fclose((FILE *)__stream);
    if (__fd == -1) {
      piVar1 = __errno_location();
      iVar2 = *piVar1;
      secsave_errno = SS_ERR_OTHER;
      goto free;
    }
    if ((ssi->secure_save == 0) || (p = ssi->file_name, p == (uchar *)0x0)) goto free;
    if (ssi->tmp_file_name != (uchar *)0x0) {
      __fd = rename((char *)ssi->tmp_file_name,(char *)p);
      if (__fd == -1) {
        piVar1 = __errno_location();
        iVar2 = *piVar1;
        secsave_errno = SS_ERR_RENAME;
      }
      goto free;
    }
  }
  mem_free(p);
LAB_080ea34e:
  mem_free(ssi);
  return iVar2;
}



secure_save_info * secure_open(uchar *file_name)

{
  __mode_t __mask;
  int *piVar1;
  uchar **ppuVar2;
  uchar *name;
  int __fd;
  FILE *pFVar3;
  uchar *name_00;
  uchar *name_01;
  uchar *name_02;
  secure_save_info *p;
  stat st;
  
  __mask = umask(0x7f);
  secsave_errno = SS_ERR_NONE;
  piVar1 = get_opt_(cmdline_options,name_00);
  name = name_01;
  if (*piVar1 == 0) {
    ppuVar2 = (uchar **)get_opt_(cmdline_options,name_01);
    name = *ppuVar2;
    if (name != (uchar *)0x0) goto LAB_080ea570;
  }
  else {
LAB_080ea570:
    piVar1 = get_opt_(cmdline_options,name);
    if (*piVar1 == 0) {
      secsave_errno = SS_ERR_DISABLED;
      p = (secure_save_info *)0x0;
      goto LAB_080ea5d3;
    }
  }
  p = (secure_save_info *)mem_calloc(1,0x14);
  if (p == (secure_save_info *)0x0) {
    secsave_errno = SS_ERR_OUT_OF_MEM;
    goto LAB_080ea5d3;
  }
  piVar1 = get_opt_(config_options,name_02);
  p->secure_save = *piVar1;
  name = stracpy(file_name);
  p->file_name = name;
  if (name == (uchar *)0x0) {
    secsave_errno = SS_ERR_OUT_OF_MEM;
  }
  else {
    __fd = __lxstat64(3,(char *)name,(stat64 *)&st);
    if (__fd == 0) {
      if ((st.st_mode & 0xf000) == 0x8000) {
        __fd = access((char *)p->file_name,6);
        if (-1 < __fd) goto LAB_080ea50c;
        piVar1 = __errno_location();
        p->err = *piVar1;
        secsave_errno = SS_ERR_ACCESS;
      }
      else {
        p->secure_save = 0;
LAB_080ea5b6:
        pFVar3 = (FILE *)fopen64((char *)p->file_name,"wb");
        p->fp = pFVar3;
        if (pFVar3 != (FILE *)0x0) goto LAB_080ea5d3;
        secsave_errno = SS_ERR_OPEN_WRITE;
        piVar1 = __errno_location();
        p->err = *piVar1;
      }
    }
    else {
      piVar1 = __errno_location();
      if (*piVar1 == 2) {
LAB_080ea50c:
        if (p->secure_save == 0) goto LAB_080ea5b6;
        name = straconcat(p->file_name,".tmp_XXXXXX",0);
        if (name == (uchar *)0x0) {
          secsave_errno = SS_ERR_OUT_OF_MEM;
        }
        else {
          __fd = mkstemp64((char *)name);
          if (__fd == -1) {
            secsave_errno = SS_ERR_MKSTEMP;
            mem_free(name);
          }
          else {
            pFVar3 = (FILE *)fdopen(__fd,"w");
            p->fp = pFVar3;
            if (pFVar3 != (FILE *)0x0) {
              p->tmp_file_name = name;
              goto LAB_080ea5d3;
            }
            secsave_errno = SS_ERR_OPEN_WRITE;
            piVar1 = __errno_location();
            p->err = *piVar1;
            mem_free(name);
          }
        }
      }
      else {
        p->err = *piVar1;
        secsave_errno = SS_ERR_STAT;
      }
    }
    mem_free(p->file_name);
    p->file_name = (uchar *)0x0;
  }
  mem_free(p);
  p = (secure_save_info *)0x0;
LAB_080ea5d3:
  umask(__mask);
  return p;
}



// WARNING: Removing unreachable block (ram,0x080ea750)

uchar * secsave_strerror(secsave_errno secsave_error,terminal *term)

{
  int cp_index;
  uchar *codeset;
  
  switch(secsave_error) {
  default:
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Secure file saving error");
    return codeset;
  case SS_ERR_DISABLED:
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"File saving disabled by option");
    return codeset;
  case SS_ERR_OUT_OF_MEM:
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    break;
  case SS_ERR_OPEN_READ:
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Cannot read the file");
    return codeset;
  case SS_ERR_OPEN_WRITE:
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Cannot write the file");
    return codeset;
  case SS_ERR_STAT:
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Cannot get file status");
    return codeset;
  case SS_ERR_ACCESS:
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Cannot access the file");
    return codeset;
  case SS_ERR_MKSTEMP:
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Cannot create temp file");
    return codeset;
  case SS_ERR_RENAME:
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    codeset = gettext((uchar *)"Cannot rename the file");
    return codeset;
  }
  codeset = gettext((uchar *)"Out of memory");
  return codeset;
}



void dummy_snprintf(void)

{
  return;
}



uchar * asprintfa(char *fmt,...)

{
  int iVar1;
  size_t sVar2;
  uchar *__dest;
  char *local_10;
  
  __dest = (uchar *)0x0;
  iVar1 = vasprintf(&local_10,fmt,&stack0x00000008);
  if (-1 < iVar1) {
    sVar2 = strlen(local_10);
    __dest = (uchar *)mem_alloc(sVar2 + 1);
    if (__dest != (uchar *)0x0) {
      memcpy(__dest,local_10,sVar2 + 1);
    }
    free(local_10);
  }
  return __dest;
}



string * init_string(string *string)

{
  uchar *puVar1;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(string == (string *)0x0);
    if (string == (string *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x133;
      elinks_internal((uchar *)"assertion string != NULL failed: [init_string]");
      if (assert_failed != 0) goto LAB_080eab11;
    }
    string->length = 0;
    puVar1 = (uchar *)mem_alloc(0x100);
    string->source = puVar1;
    if (puVar1 != (uchar *)0x0) {
      *puVar1 = '\0';
      return string;
    }
  }
  else {
LAB_080eab11:
    assert_failed = 0;
  }
  return (string *)0x0;
}



// WARNING: Type propagation algorithm not settling

int elinks_strlcmp(uchar *s1,size_t n1,uchar *s2,size_t n2)

{
  int iVar1;
  size_t sVar2;
  int iVar3;
  uint uVar4;
  
  if ((s2 == (uchar *)0x0) || (s1 == (uchar *)0x0)) {
    return 1;
  }
  if (n1 == 0xffffffff) {
    n1 = strlen((char *)s1);
  }
  if (n2 == 0xffffffff) {
    sVar2 = strlen((char *)s2);
    iVar3 = -sVar2;
  }
  else {
    iVar3 = -n2;
  }
  iVar3 = n1 + iVar3;
  if ((((iVar3 == 0) && (n1 != 0)) && (*s1 != 0)) &&
     ((*s2 != 0 && (iVar3 = (uint)*s1 - (uint)*s2, iVar3 == 0)))) {
    uVar4 = 0;
    while ((uVar4 = uVar4 + 1, uVar4 < n1 && (s1[uVar4] != 0))) {
      if (s2[uVar4] == 0) {
        assert_failed = 0;
        return 0;
      }
      iVar1 = (uint)s1[uVar4] - (uint)s2[uVar4];
      if (iVar1 != 0) {
        assert_failed = 0;
        return iVar1;
      }
    }
  }
  assert_failed = 0;
  return iVar3;
}



void done_string(string *string)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(string == (string *)0x0);
  if (string == (string *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
    errline = 0x148;
    elinks_internal((uchar *)"assertion string != NULL failed: [done_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (string->source != (uchar *)0x0) {
    mem_free(string->source);
  }
  string->source = (uchar *)0x0;
  string->length = 0;
  return;
}



void add_to_strn(uchar **dst,uchar *src)

{
  size_t sVar1;
  size_t sVar2;
  uchar *p;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(src == (uchar *)0x0 || *dst == (uchar *)0x0);
    if (src == (uchar *)0x0 || *dst == (uchar *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x6c;
      elinks_internal((uchar *)"assertion *dst && src failed: [add_to_strn]");
      if (assert_failed != 0) goto LAB_080ead66;
    }
    p = *dst;
    sVar1 = strlen((char *)p);
    sVar2 = strlen((char *)src);
    p = (uchar *)mem_realloc(p,sVar2 + 1 + sVar1);
    if (p != (uchar *)0x0) {
      memcpy(p + sVar1,src,sVar2 + 1);
      *dst = p;
    }
  }
  else {
LAB_080ead66:
    assert_failed = 0;
  }
  return;
}



uchar * memacpy(uchar *src,int len)

{
  uchar *__dest;
  size_t size;
  
  if (assert_failed == 0) {
    assert_failed = -(len >> 0x1f);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x4d;
      elinks_internal((uchar *)"assertion len >= 0 failed: [memacpy]");
      if (assert_failed != 0) goto LAB_080eae08;
    }
    size = len + 1;
  }
  else {
LAB_080eae08:
    assert_failed = 0;
    size = 1;
    len = 0;
  }
  __dest = (uchar *)mem_alloc(size);
  if (__dest != (uchar *)0x0) {
    if ((len != 0) && (src != (uchar *)0x0)) {
      memcpy(__dest,src,len);
    }
    __dest[len] = '\0';
  }
  return __dest;
}



uchar * stracpy(uchar *src)

{
  size_t len;
  uchar *puVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (uchar *)0x0;
  }
  assert_failed = ZEXT14(src == (uchar *)0x0);
  if (src == (uchar *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
    errline = 0x5c;
    elinks_internal((uchar *)"assertion src failed: [stracpy]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (uchar *)0x0;
    }
  }
  len = strlen((char *)src);
  puVar1 = memacpy(src,len);
  return puVar1;
}



uchar * straconcat(uchar *str,...)

{
  size_t __n;
  size_t sVar1;
  uchar *puVar2;
  char *__s;
  char **ppcVar3;
  size_t local_24;
  uchar *local_20;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(str == (uchar *)0x0);
    if (str == (uchar *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x90;
      elinks_internal((uchar *)"assertion str != NULL failed: [straconcat]");
      if (assert_failed != 0) goto LAB_080eafde;
    }
    local_24 = strlen((char *)str);
    local_20 = (uchar *)mem_alloc(local_24 + 1);
    if (local_20 != (uchar *)0x0) {
      if (local_24 != 0) {
        memcpy(local_20,str,local_24);
      }
      ppcVar3 = (char **)&stack0x00000008;
      while (__s = *ppcVar3, __s != (char *)0x0) {
        while( true ) {
          ppcVar3 = ppcVar3 + 1;
          __n = strlen(__s);
          if (__n == 0) break;
          sVar1 = local_24 + __n;
          puVar2 = (uchar *)mem_realloc(local_20,sVar1 + 1);
          if (puVar2 == (uchar *)0x0) {
            mem_free(local_20);
            return (uchar *)0x0;
          }
          memcpy(puVar2 + local_24,__s,__n);
          __s = *ppcVar3;
          local_24 = sVar1;
          local_20 = puVar2;
          if (__s == (char *)0x0) goto LAB_080eaf96;
        }
      }
LAB_080eaf96:
      local_20[local_24] = '\0';
      return local_20;
    }
  }
  else {
LAB_080eafde:
    assert_failed = 0;
    local_20 = (uchar *)0x0;
  }
  return local_20;
}



int c_strncasecmp(char *s1,char *s2,size_t n)

{
  int iVar1;
  int iVar2;
  byte bVar3;
  size_t sVar4;
  
  if (n != 0) {
    sVar4 = 0;
    do {
      iVar1 = c_tolower((uint)(byte)s1[sVar4]);
      iVar2 = c_tolower((uint)(byte)s2[sVar4]);
      bVar3 = (byte)iVar1;
      if (bVar3 != (byte)iVar2) {
        return -(uint)(bVar3 < (byte)iVar2) | 1;
      }
    } while ((bVar3 != 0) && (sVar4 = sVar4 + 1, n != sVar4));
  }
  return 0;
}



char * c_strcasestr(char *haystack,char *needle)

{
  size_t sVar1;
  size_t n;
  int iVar2;
  int iVar3;
  
  sVar1 = strlen(haystack);
  n = strlen(needle);
  if ((sVar1 < n) || (iVar3 = (sVar1 + 1) - n, iVar3 == 0)) {
LAB_080eb0dd:
    haystack = (char *)0x0;
  }
  else {
    while (iVar2 = c_strncasecmp(haystack,needle,n), iVar2 != 0) {
      iVar3 = iVar3 + -1;
      if (iVar3 == 0) goto LAB_080eb0dd;
      haystack = haystack + 1;
    }
  }
  return haystack;
}



int c_strcasecmp(char *s1,char *s2)

{
  int iVar1;
  int iVar2;
  byte bVar3;
  int iVar4;
  
  iVar4 = 0;
  do {
    iVar1 = c_tolower((uint)(byte)s1[iVar4]);
    iVar2 = c_tolower((uint)(byte)s2[iVar4]);
    bVar3 = (byte)iVar1;
    if (bVar3 != (byte)iVar2) {
      return -(uint)(bVar3 < (byte)iVar2) | 1;
    }
    iVar4 = iVar4 + 1;
  } while (bVar3 != 0);
  return 0;
}



int elinks_strlcasecmp(uchar *s1,size_t n1,uchar *s2,size_t n2,int locale_indep)

{
  int iVar1;
  int iVar2;
  __int32_t **pp_Var3;
  byte bVar4;
  byte bVar5;
  uint uVar6;
  byte *pbVar7;
  
  if (locale_indep == 0) {
    if ((s2 != (uchar *)0x0) && (s1 != (uchar *)0x0)) {
      if (n1 == 0xffffffff) {
        n1 = strlen((char *)s1);
      }
      if (n2 == 0xffffffff) {
        n2 = strlen((char *)s2);
      }
      assert_failed = 0;
      if (n1 - n2 != 0) {
        assert_failed = 0;
        return n1 - n2;
      }
      if (((n1 != 0) && (bVar4 = *s1, bVar4 != 0)) && (bVar5 = *s2, bVar5 != 0)) {
        pp_Var3 = __ctype_toupper_loc();
        uVar6 = 0;
        do {
          iVar1 = (*pp_Var3)[bVar4] - (*pp_Var3)[bVar5];
          if (iVar1 != 0) {
            return iVar1;
          }
          uVar6 = uVar6 + 1;
        } while (((uVar6 < n1) && (bVar4 = s1[uVar6], bVar4 != 0)) &&
                (bVar5 = s2[uVar6], bVar5 != 0));
      }
      return 0;
    }
  }
  else {
    if ((s2 != (uchar *)0x0) && (s1 != (uchar *)0x0)) {
      if (n1 == 0xffffffff) {
        n1 = strlen((char *)s1);
      }
      if (n2 == 0xffffffff) {
        n2 = strlen((char *)s2);
      }
      assert_failed = 0;
      if (n1 - n2 != 0) {
        assert_failed = 0;
        return n1 - n2;
      }
      if (n1 == 0) {
        assert_failed = 0;
        return 0;
      }
      bVar4 = *s1;
      if (bVar4 == 0) {
        assert_failed = 0;
        return 0;
      }
      if (*s2 == '\0') {
        assert_failed = 0;
        return 0;
      }
      uVar6 = 0;
      pbVar7 = s2;
      do {
        iVar1 = c_toupper((uint)bVar4);
        iVar2 = c_toupper((uint)*pbVar7);
        if ((iVar1 - iVar2 != 0) || (uVar6 = uVar6 + 1, n1 <= uVar6)) {
          return iVar1 - iVar2;
        }
        bVar4 = s1[uVar6];
        if (bVar4 == 0) {
          return 0;
        }
        pbVar7 = s2 + uVar6;
      } while (s2[uVar6] != '\0');
      return 0;
    }
  }
  return 1;
}



uchar * safe_strncpy(uchar *dst,uchar *src,size_t dst_size)

{
  if (assert_failed == 0) {
    if (((src == (uchar *)0x0) || (dst == (uchar *)0x0)) || (dst_size == 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0xbc;
      elinks_internal((uchar *)"assertion dst && src && dst_size > 0 failed: [safe_strncpy]");
      if (assert_failed != 0) goto LAB_080eb372;
    }
    else {
      assert_failed = 0;
    }
    strncpy((char *)dst,(char *)src,dst_size);
    dst[dst_size - 1] = '\0';
  }
  else {
LAB_080eb372:
    assert_failed = 0;
    dst = (uchar *)0x0;
  }
  return dst;
}



int xstrcmp(uchar *s1,uchar *s2)

{
  int iVar1;
  
  if (s1 == (uchar *)0x0) {
    iVar1 = -(uint)(s2 != (uchar *)0x0);
  }
  else {
    iVar1 = 1;
    if (s2 != (uchar *)0x0) {
      iVar1 = strcmp((char *)s1,(char *)s2);
      return iVar1;
    }
  }
  return iVar1;
}



uchar * insert_in_string(uchar **dst,int pos,uchar *seq,int seqlen)

{
  size_t sVar1;
  uchar *p;
  
  p = *dst;
  sVar1 = strlen((char *)p);
  p = (uchar *)mem_realloc(p,seqlen + 1 + sVar1);
  if (p != (uchar *)0x0) {
    memmove(p + seqlen + pos,p + pos,(sVar1 - pos) + 1);
    memcpy(p + pos,seq,seqlen);
    *dst = p;
  }
  return p;
}



void * __regparm3 mem_align_alloc__(void **ptr,size_t old,size_t new)

{
  void *pvVar1;
  uint size;
  uint uVar2;
  
  size = new + 0xff & 0xffffff00;
  uVar2 = old + 0xff & 0xffffff00;
  if (uVar2 < size) {
    pvVar1 = mem_realloc(*ptr,size);
    if (pvVar1 == (void *)0x0) {
      return (void *)0x0;
    }
    *ptr = pvVar1;
    memset((void *)((int)pvVar1 + uVar2),0,size - uVar2);
  }
  return *ptr;
}



string * add_format_to_string(string *string,uchar *format,...)

{
  int iVar1;
  int iVar2;
  void *pvVar3;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(format == (uchar *)0x0 || string == (string *)0x0);
    if (format == (uchar *)0x0 || string == (string *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x1f6;
      elinks_internal((uchar *)"assertion string && format failed: [add_format_to_string]");
      if (assert_failed != 0) goto LAB_080eb5ea;
    }
    iVar1 = __vsnprintf_chk(0,0,1,0xffffffff,format,&stack0x0000000c);
    if (0 < iVar1) {
      iVar2 = iVar1 + string->length;
      pvVar3 = mem_align_alloc__((void **)string,string->length,iVar2 + 1);
      if (pvVar3 != (void *)0x0) {
        __vsnprintf_chk(string->source + string->length,iVar1 + 1,1,0xffffffff,format,
                        &stack0x0000000c);
        string->length = iVar2;
        string->source[iVar2] = '\0';
        return string;
      }
    }
  }
  else {
LAB_080eb5ea:
    assert_failed = 0;
  }
  return (string *)0x0;
}



string * add_xchar_to_string(string *string,uchar character,int times)

{
  int iVar1;
  void *pvVar2;
  
  if (assert_failed == 0) {
    if (((character == '\0') || (string == (string *)0x0)) || (times < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x1dc;
      elinks_internal((uchar *)
                      "assertion string && character && times >= 0 failed: [add_xchar_to_string]");
      if (assert_failed != 0) goto LAB_080eb683;
    }
    else {
      assert_failed = 0;
    }
    if (times != 0) {
      iVar1 = times + string->length;
      pvVar2 = mem_align_alloc__((void **)string,string->length,iVar1 + 1);
      if (pvVar2 == (void *)0x0) {
        string = (string *)0x0;
      }
      else {
        memset(string->source + string->length,(uint)character,times);
        string->length = iVar1;
        string->source[iVar1] = '\0';
      }
    }
  }
  else {
LAB_080eb683:
    assert_failed = 0;
    string = (string *)0x0;
  }
  return string;
}



void free_string_list(list_head_elinks *list)

{
  list_head_elinks *p;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(list == (list_head_elinks *)0x0);
    if (list == (list_head_elinks *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x22d;
      elinks_internal((uchar *)"assertion list != NULL failed: [free_string_list]");
      if (assert_failed != 0) goto LAB_080eb7a0;
    }
    while (p = (list_head_elinks *)list->next, p != list) {
      *(void **)((int)p->next + 4) = p->prev;
      *(void **)p->prev = p->next;
      if (assert_failed == 0) {
        assert_failed = 0;
        if (p[1].next != (void *)0x0) {
          mem_free(p[1].next);
        }
        p[1].next = (void *)0x0;
        p[1].prev = (void *)0x0;
      }
      else {
        assert_failed = 0;
      }
      mem_free(p);
    }
  }
  else {
LAB_080eb7a0:
    assert_failed = 0;
  }
  return;
}



string * add_to_string_list(list_head_elinks *list,uchar *source,int length)

{
  int *p;
  string *string;
  undefined *puVar1;
  int iVar2;
  void *pvVar3;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  assert_failed = ZEXT14(source == (uchar *)0x0 || list == (list_head_elinks *)0x0);
  if (source == (uchar *)0x0 || list == (list_head_elinks *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
    errline = 0x215;
    elinks_internal((uchar *)"assertion list && source failed: [add_to_string_list]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  p = (int *)mem_alloc(0x10);
  if (p == (int *)0x0) {
    return (string *)0x0;
  }
  string = (string *)(p + 2);
  if (length < 0) {
    length = strlen((char *)source);
  }
  if (assert_failed == 0) {
    assert_failed = 0;
    p[3] = 0;
    puVar1 = (undefined *)mem_alloc(0x100);
    *(undefined **)(p + 2) = puVar1;
    if (puVar1 == (undefined *)0x0) goto LAB_080eb9aa;
    *puVar1 = 0;
    if (assert_failed == 0) {
      if ((source == (uchar *)0x0) || (length < 0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) goto LAB_080eb9a0;
      }
      else {
        assert_failed = 0;
      }
      if (length == 0) {
LAB_080eb8fc:
        *p = *(int *)list->prev;
        *(void **)(p + 1) = list->prev;
        *(int **)list->prev = p;
        *(int **)(*p + 4) = p;
        return string;
      }
      iVar2 = length + p[3];
      pvVar3 = mem_align_alloc__((void **)string,p[3],iVar2 + 1);
      if (pvVar3 != (void *)0x0) {
        memcpy((void *)(p[2] + p[3]),source,length);
        *(undefined *)(p[2] + iVar2) = 0;
        p[3] = iVar2;
        goto LAB_080eb8fc;
      }
      goto LAB_080eb9aa;
    }
  }
LAB_080eb9a0:
  assert_failed = 0;
LAB_080eb9aa:
  done_string(string);
  mem_free(p);
  return (string *)0x0;
}



string * string_concat(string *string,...)

{
  char *__s;
  size_t __n;
  int iVar1;
  void *pvVar2;
  char **ppcVar3;
  uint uVar4;
  bool bVar5;
  
  if (assert_failed == 0) {
    bVar5 = string == (string *)0x0;
    uVar4 = (uint)bVar5;
    assert_failed = uVar4;
    if (bVar5) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x1b6;
      elinks_internal((uchar *)"assertion string != NULL failed: [string_concat]");
      if (assert_failed != 0) goto LAB_080eba43;
    }
    ppcVar3 = (char **)&stack0x00000008;
    while (__s = *ppcVar3, __s != (char *)0x0) {
      ppcVar3 = ppcVar3 + 1;
      if (*__s != '\0') {
        if (assert_failed == 0) {
          assert_failed = uVar4;
          if (bVar5) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
            errline = 0x15b;
            elinks_internal((uchar *)"assertion string && source failed: [add_to_string]");
            if (assert_failed != 0) goto LAB_080ebaa0;
          }
          if (*__s != '\0') {
            __n = strlen(__s);
            if ((string == (string *)0x0) || ((int)__n < 0)) {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
              errline = 0xff;
              elinks_internal((uchar *)
                              "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                             );
              if (assert_failed != 0) goto LAB_080ebaa0;
            }
            else {
              assert_failed = 0;
            }
            if (__n != 0) {
              iVar1 = __n + string->length;
              pvVar2 = mem_align_alloc__((void **)string,string->length,iVar1 + 1);
              if (pvVar2 != (void *)0x0) {
                memcpy(string->source + string->length,__s,__n);
                string->source[iVar1] = '\0';
                string->length = iVar1;
              }
            }
          }
        }
        else {
LAB_080ebaa0:
          assert_failed = 0;
        }
      }
    }
  }
  else {
LAB_080eba43:
    assert_failed = 0;
    string = (string *)0x0;
  }
  return string;
}



string * add_crlf_to_string(string *string)

{
  int iVar1;
  uchar *puVar2;
  uint size;
  uint uVar3;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  assert_failed = ZEXT14(string == (string *)0x0);
  if (string == (string *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
    errline = 0x169;
    elinks_internal((uchar *)"assertion string != NULL failed: [add_crlf_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  size = string->length + 0x102U & 0xffffff00;
  uVar3 = string->length + 0xffU & 0xffffff00;
  if (uVar3 < size) {
    puVar2 = (uchar *)mem_realloc(string->source,size);
    if (puVar2 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar2;
    memset(puVar2 + uVar3,0,size - uVar3);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  iVar1 = string->length;
  string->source[iVar1] = '\r';
  string->source[iVar1 + 1] = '\n';
  string->length = iVar1 + 2;
  string->source[iVar1 + 2] = '\0';
  return string;
}



string * add_char_to_string(string *string,uchar character)

{
  int iVar1;
  uchar *puVar2;
  uint size;
  uint uVar3;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  assert_failed = ZEXT14(character == '\0' || string == (string *)0x0);
  if (character == '\0' || string == (string *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
    errline = 0x1c9;
    elinks_internal((uchar *)"assertion string && character failed: [add_char_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  size = string->length + 0x101U & 0xffffff00;
  uVar3 = string->length + 0xffU & 0xffffff00;
  if (uVar3 < size) {
    puVar2 = (uchar *)mem_realloc(string->source,size);
    if (puVar2 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar2;
    memset(puVar2 + uVar3,0,size - uVar3);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  iVar1 = string->length;
  string->source[iVar1] = character;
  string->length = iVar1 + 1;
  string->source[iVar1 + 1] = '\0';
  return string;
}



string * add_to_string(string *string,uchar *source)

{
  int iVar1;
  uchar uVar2;
  size_t __n;
  void *pvVar3;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(source == (uchar *)0x0 || string == (string *)0x0);
    if (source == (uchar *)0x0 || string == (string *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x15b;
      elinks_internal((uchar *)"assertion string && source failed: [add_to_string]");
      if (assert_failed != 0) goto LAB_080ebe3f;
      uVar2 = *source;
    }
    else {
      uVar2 = *source;
    }
    if (uVar2 == '\0') {
      return string;
    }
    __n = strlen((char *)source);
    if ((string == (string *)0x0) || ((int)__n < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080ebe3f;
    }
    else {
      assert_failed = 0;
    }
    if (__n != 0) {
      iVar1 = __n + string->length;
      pvVar3 = mem_align_alloc__((void **)string,string->length,iVar1 + 1);
      if (pvVar3 == (void *)0x0) {
        string = (string *)0x0;
      }
      else {
        memcpy(string->source + string->length,source,__n);
        string->source[iVar1] = '\0';
        string->length = iVar1;
      }
    }
  }
  else {
LAB_080ebe3f:
    assert_failed = 0;
    string = (string *)0x0;
  }
  return string;
}



string * add_string_to_string(string *string,string *from)

{
  int iVar1;
  size_t __n;
  uchar *__src;
  void *pvVar2;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(from == (string *)0x0 || string == (string *)0x0);
    if (from == (string *)0x0 || string == (string *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x17c;
      elinks_internal((uchar *)"assertion string && from failed: [add_string_to_string]");
      if (assert_failed != 0) goto LAB_080ebf9f;
      __n = from->length;
    }
    else {
      __n = from->length;
    }
    if (__n == 0) {
      return string;
    }
    __src = from->source;
    if (((string == (string *)0x0) || (__src == (uchar *)0x0)) || ((int)__n < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080ebf9f;
    }
    else {
      assert_failed = 0;
    }
    iVar1 = string->length + __n;
    pvVar2 = mem_align_alloc__((void **)string,string->length,iVar1 + 1);
    if (pvVar2 == (void *)0x0) {
      string = (string *)0x0;
    }
    else {
      memcpy(string->source + string->length,__src,__n);
      string->source[iVar1] = '\0';
      string->length = iVar1;
    }
  }
  else {
LAB_080ebf9f:
    assert_failed = 0;
    string = (string *)0x0;
  }
  return string;
}



string * add_file_to_string(string *string,uchar *filename)

{
  int iVar1;
  uint uVar2;
  FILE *__stream;
  int iVar3;
  size_t sVar4;
  uchar *puVar5;
  uint uVar6;
  uint size;
  __off64_t _Var7;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  assert_failed = ZEXT14(filename == (uchar *)0x0 || string == (string *)0x0);
  if (filename == (uchar *)0x0 || string == (string *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
    errline = 399;
    elinks_internal((uchar *)"assertion string && filename failed: [add_file_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  __stream = fopen64((char *)filename,"rb");
  if (__stream == (FILE *)0x0) {
    return (string *)0x0;
  }
  iVar3 = fseeko64(__stream,0,2);
  if (iVar3 == 0) {
    _Var7 = ftello64(__stream);
    if ((_Var7 != -1) && (iVar3 = fseeko64(__stream,0,0), iVar3 == 0)) {
      iVar3 = (size_t)_Var7 + string->length;
      uVar6 = string->length + 0xff;
      uVar2 = uVar6 >> 8;
      uVar6 = uVar6 & 0xffffff00;
      size = iVar3 + 0x100U & 0xffffff00;
      if (uVar6 <= size && size + uVar2 * -0x100 != 0) {
        puVar5 = (uchar *)mem_realloc(string->source,size);
        if (puVar5 == (uchar *)0x0) goto err;
        string->source = puVar5;
        memset(puVar5 + uVar6,0,size + uVar2 * -0x100);
      }
      if (string->source != (uchar *)0x0) {
        iVar1 = string->length;
        sVar4 = fread(string->source + iVar1,1,(size_t)_Var7,__stream);
        iVar1 = sVar4 + iVar1;
        string->length = iVar1;
        string->source[iVar1] = '\0';
        fclose(__stream);
        if (string->length == iVar3) {
          return string;
        }
      }
    }
  }
err:
  fclose(__stream);
  return (string *)0x0;
}



timeval_T * timeval_sub_interval(timeval_T *t,timeval_T *interval)

{
  int iVar1;
  int iVar2;
  
  iVar1 = t->sec - interval->sec;
  t->sec = iVar1;
  if (iVar1 < 0) {
LAB_080ec2d8:
    t->sec = 0;
    t->usec = 0;
    return t;
  }
  iVar2 = t->usec - interval->usec;
  t->usec = iVar2;
  if (iVar2 < 0) {
    do {
      iVar1 = iVar1 + -1;
      iVar2 = iVar2 + 1000000;
    } while (iVar2 < 0);
    t->usec = iVar2;
    t->sec = iVar1;
    if (iVar1 < 0) goto LAB_080ec2d8;
  }
  return t;
}



timeval_T * timeval_sub(timeval_T *res,timeval_T *older,timeval_T *newer)

{
  int iVar1;
  int iVar2;
  
  iVar1 = newer->sec - older->sec;
  res->sec = iVar1;
  iVar2 = newer->usec - older->usec;
  res->usec = iVar2;
  if (iVar2 < 0) {
    do {
      iVar1 = iVar1 + -1;
      iVar2 = iVar2 + 1000000;
    } while (iVar2 < 0);
    res->usec = iVar2;
    res->sec = iVar1;
  }
  return res;
}



timeval_T * timeval_add(timeval_T *res,timeval_T *base,timeval_T *t)

{
  int iVar1;
  int iVar2;
  
  iVar1 = t->sec + base->sec;
  res->sec = iVar1;
  iVar2 = t->usec + base->usec;
  res->usec = iVar2;
  if (999999 < iVar2) {
    do {
      iVar2 = iVar2 + -1000000;
      iVar1 = iVar1 + 1;
    } while (999999 < iVar2);
    res->usec = iVar2;
    res->sec = iVar1;
  }
  return res;
}



timeval_T * timeval_add_interval(timeval_T *t,timeval_T *interval)

{
  int iVar1;
  int iVar2;
  
  t->sec = t->sec + interval->sec;
  iVar2 = t->usec + interval->usec;
  t->usec = iVar2;
  if (999999 < iVar2) {
    iVar1 = t->sec;
    do {
      iVar2 = iVar2 + -1000000;
      iVar1 = iVar1 + 1;
    } while (999999 < iVar2);
    t->usec = iVar2;
    t->sec = iVar1;
  }
  return t;
}



timeval_T * timeval_from_double(timeval_T *t,double x)

{
  t->sec = (int)ROUND(x);
  t->usec = (int)ROUND((x - (double)(int)ROUND(x)) * 1000000.00000000);
  return t;
}



timeval_T * timeval_from_milliseconds(timeval_T *t,milliseconds_T milliseconds)

{
  t->sec = milliseconds / 1000;
  t->usec = (milliseconds % 1000) * 1000;
  return t;
}



timeval_T * timeval_from_seconds(timeval_T *t,long seconds)

{
  t->usec = 0;
  t->sec = seconds;
  return t;
}



long timeval_to_seconds(timeval_T *t)

{
  return t->usec / 1000000 + t->sec;
}



int timeval_is_positive(timeval_T *t)

{
  if (0 < t->sec) {
    return 1;
  }
  if (t->sec == 0) {
    return (uint)(0 < t->usec);
  }
  return 0;
}



void timeval_limit_to_zero_or_one(timeval_T *t)

{
  if (t->sec < 0) {
    t->sec = 0;
  }
  if (-1 < t->usec) {
    return;
  }
  t->usec = 0;
  return;
}



int timeval_cmp(timeval_T *t1,timeval_T *t2)

{
  int iVar1;
  int iVar2;
  
  iVar2 = 1;
  iVar1 = t2->sec;
  if (t1->sec == iVar1 || t1->sec < iVar1) {
    if (t1->sec < iVar1) {
      iVar2 = -1;
    }
    else {
      iVar2 = t1->usec - t2->usec;
    }
  }
  return iVar2;
}



int timeval_div_off_t(off_t n,timeval_T *t)

{
  uint uVar1;
  uint uVar2;
  longlong lVar3;
  uint uVar4;
  int iVar5;
  
  uVar2 = t->usec / 1000;
  iVar5 = 0x7fffffff;
  lVar3 = (longlong)t->sec * 1000;
  uVar4 = (uint)lVar3;
  uVar1 = uVar2 + uVar4;
  uVar2 = ((int)uVar2 >> 0x1f) + (int)((ulonglong)lVar3 >> 0x20) + (uint)CARRY4(uVar2,uVar4);
  if ((uVar2 | uVar1) != 0) {
    iVar5 = __divdi3(n * 1000,uVar1,uVar2);
  }
  return iVar5;
}



milliseconds_T mult_ms(milliseconds_T a,long lb)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0x20c49b;
  }
  if (((lb < 0) || (a < 0)) || ((int)(0x7fffffff / (longlong)lb) <= a)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/time.c";
    errline = 0xb7;
    elinks_internal((uchar *)"assertion la >= 0 && lb >= 0 && la < LONG_MAX / lb failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0x20c49b;
    }
  }
  else {
    assert_failed = 0;
  }
  return lb * a;
}



milliseconds_T add_ms_to_ms(milliseconds_T a,milliseconds_T b)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0x20c49b;
  }
  if (((b < 0) || (a < 0)) || (0x7fffffff - a <= b)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/time.c";
    errline = 0xac;
    elinks_internal((uchar *)"assertion la >= 0 && lb >= 0 && lb < LONG_MAX - la failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0x20c49b;
    }
  }
  else {
    assert_failed = 0;
  }
  return b + a;
}



milliseconds_T sec_to_ms(long sec)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0x20c49b;
  }
  assert_failed = ZEXT14(0x20c49aU < (uint)sec);
  if (0x20c49aU < (uint)sec) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/time.c";
    errline = 0xa0;
    elinks_internal((uchar *)"assertion sec >= 0 && sec < LONG_MAX / 1000L failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0x20c49b;
    }
  }
  return sec * 1000;
}



milliseconds_T timeval_to_milliseconds(timeval_T *t)

{
  milliseconds_T a;
  
  a = sec_to_ms(t->sec);
  a = add_ms_to_ms(a,t->usec / 1000);
  return a;
}



timeval_T * timeval_now(timeval_T *t)

{
  timeval tv;
  
  gettimeofday((timeval *)&tv,(__timezone_ptr_t)0x0);
  t->sec = tv.tv_sec;
  t->usec = tv.tv_usec;
  return t;
}



void __regparm3
goto_url_action(session *ses,anon_subr_uchar_ptr_session_ptr_uchar_ptr_size_t *get_url)

{
  int iVar1;
  uchar *puVar2;
  int in_GS_OFFSET;
  uchar url [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (get_url != (anon_subr_uchar_ptr_session_ptr_uchar_ptr_size_t *)0x0) {
    puVar2 = (*get_url)(ses,url,0x400);
    if (puVar2 != (uchar *)0x0) goto LAB_080ec87b;
  }
  url[0] = '\0';
LAB_080ec87b:
  dialog_goto_url(ses,url);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



frame_event_status do_action(session *ses,main_action action_id,int verbose)

{
  terminal *term;
  window *pwVar1;
  insert_mode iVar2;
  document_view *doc_view;
  action *paVar3;
  frame_event_status fVar4;
  int local_54;
  int *piVar5;
  uchar *name;
  int iVar6;
  window *pwVar7;
  uchar *name_00;
  uchar *extraout_EDX;
  link *plVar8;
  bool bVar9;
  option_elinks *local_5c;
  char *local_58;
  link *local_24;
  
  term = ses->tab->term;
  doc_view = current_frame(ses);
  if (action_id == ~ACT_MAIN_NONE) {
    plVar8 = (link *)0x0;
unknown_action:
    fVar4 = FRAME_EVENT_IGNORED;
    bVar9 = false;
    if (verbose != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/action.c";
      errline = 0x27b;
      name = get_action_name(KEYMAP_MAIN,action_id);
      elinks_internal((uchar *)"No action handling defined for \'%s\'.",name);
      fVar4 = FRAME_EVENT_IGNORED;
      bVar9 = false;
    }
    goto LAB_080ec9e9;
  }
  if ((doc_view == (document_view *)0x0) || (doc_view->vs == (view_state *)0x0)) {
    paVar3 = get_action(KEYMAP_MAIN,action_id);
    if ((paVar3 != (action *)0x0) && ((*(byte *)((int)&paVar3->flags + 2) & 2) != 0))
    goto LAB_080eca45;
LAB_080ec926:
    plVar8 = (link *)0x0;
  }
  else {
    paVar3 = get_action(KEYMAP_MAIN,action_id);
    if (((paVar3 != (action *)0x0) && ((*(byte *)((int)&paVar3->flags + 2) & 8) != 0)) &&
       (local_54 = try_jump_to_link_number(ses,doc_view), local_54 == 0)) {
LAB_080eca45:
      bVar9 = false;
      plVar8 = (link *)0x0;
      fVar4 = FRAME_EVENT_OK;
      iVar2 = ses->insert_mode;
      goto joined_r0x080eca57;
    }
    local_54 = doc_view->vs->current_link;
    if ((local_54 < 0) || (doc_view->document->nlinks <= local_54)) goto LAB_080ec926;
    plVar8 = doc_view->document->links + local_54;
  }
  paVar3 = get_action(KEYMAP_MAIN,action_id);
  if (((paVar3 != (action *)0x0) && ((*(byte *)((int)&paVar3->flags + 2) & 4) != 0)) &&
     ((ses->history).current == (location *)0x0)) {
    return FRAME_EVENT_OK;
  }
  paVar3 = get_action(KEYMAP_MAIN,action_id);
  if ((((paVar3 != (action *)0x0) && ((*(byte *)((int)&paVar3->flags + 2) & 0x10) != 0)) &&
      (plVar8 == (link *)0x0)) ||
     (((paVar3 = get_action(KEYMAP_MAIN,action_id), paVar3 != (action *)0x0 &&
       ((*(byte *)((int)&paVar3->flags + 2) & 0x20) != 0)) &&
      ((plVar8 == (link *)0x0 || (plVar8->type < LINK_BUTTON)))))) goto switchD_080ecb10_caseD_10;
  local_5c = (option_elinks *)0x0;
  local_58 = (char *)action_id;
  paVar3 = get_action(KEYMAP_MAIN,action_id);
  if ((paVar3 == (action *)0x0) || (name = name_00, (*(byte *)((int)&paVar3->flags + 2) & 1) != 0))
  {
    local_58 = "anonymous";
    local_5c = cmdline_options;
    piVar5 = get_opt_(cmdline_options,name_00);
    name = extraout_EDX;
    if (*piVar5 != 0) goto switchD_080ecb10_caseD_10;
  }
  switch(action_id) {
  default:
    goto unknown_action;
  case ACT_MAIN_ABORT_CONNECTION:
    abort_loading(ses,1);
    print_screen_status(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_ADD_BOOKMARK:
    launch_bm_add_doc_dialog(term,(dialog_data *)0x0,ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_ADD_BOOKMARK_LINK:
    launch_bm_add_link_dialog(term,(dialog_data *)0x0,ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_ADD_BOOKMARK_TABS:
    bookmark_terminal_tabs_dialog(term);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_AUTH_MANAGER:
    auth_manager(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_BACKSPACE_PREFIX:
    if ((ses->kbdprefix).repeat_count != 0) {
      draw_formatted(ses,0);
      local_54 = (ses->kbdprefix).repeat_count / 10;
      (ses->kbdprefix).repeat_count = local_54;
      if (local_54 != 0) {
        highlight_links_with_prefixes_that_start_with_n(term,doc_view,local_54);
      }
      print_screen_status(ses);
      return FRAME_EVENT_SESSION_DESTROYED;
    }
    goto switchD_080ecb10_caseD_10;
  case ACT_MAIN_BOOKMARK_MANAGER:
    bookmark_manager(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_CACHE_MANAGER:
    cache_manager(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_CACHE_MINIMIZE:
    goto switchD_080ecb10_caseD_a;
  case ACT_MAIN_COOKIE_MANAGER:
    cookie_manager(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_COOKIES_LOAD:
    local_58 = "cookies.save";
    local_5c = config_options;
    piVar5 = get_opt_(config_options,name);
    if (*piVar5 == 0) goto switchD_080ecb10_caseD_10;
    load_cookies(local_5c,local_58);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_COPY_CLIPBOARD:
    fVar4 = copy_current_link_to_clipboard(ses,doc_view,0);
    goto ignore_action;
  case ACT_MAIN_DOCUMENT_INFO:
    document_info_dialog(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_DOWNLOAD_MANAGER:
    download_manager(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_EXMODE:
  case ACT_MAIN_JUMP_TO_LINK:
  case ACT_MAIN_LUA_CONSOLE:
    goto switchD_080ecb10_caseD_10;
  case ACT_MAIN_FILE_MENU:
    activate_bfu_technology(ses,0);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_FIND_NEXT:
    fVar4 = find_next(ses,doc_view,1);
    goto ignore_action;
  case ACT_MAIN_FIND_NEXT_BACK:
    fVar4 = find_next(ses,doc_view,-1);
    goto ignore_action;
  case ACT_MAIN_FORGET_CREDENTIALS:
    free_auth();
    goto switchD_080ecb10_caseD_a;
  case ACT_MAIN_FORMHIST_MANAGER:
    formhist_manager(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_FRAME_EXTERNAL_COMMAND:
    fVar4 = pass_uri_to_command(ses,doc_view,0);
    goto ignore_action;
  case ACT_MAIN_FRAME_MAXIMIZE:
    fVar4 = set_frame(ses,doc_view,0);
    goto ignore_action;
  case ACT_MAIN_FRAME_NEXT:
    local_54 = 1;
    goto LAB_080ed5ee;
  case ACT_MAIN_FRAME_PREV:
    local_54 = -1;
LAB_080ed5ee:
    next_frame(ses,local_54);
    draw_formatted(ses,0);
    goto switchD_080ecb10_caseD_10;
  case ACT_MAIN_GOTO_URL:
    goto_url_action(ses,(anon_subr_uchar_ptr_session_ptr_uchar_ptr_size_t *)0x0);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_GOTO_URL_CURRENT:
    goto_url_action(ses,get_current_url);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_GOTO_URL_CURRENT_LINK:
    goto_url_action(ses,get_current_link_url);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_GOTO_URL_HOME:
    goto_url_home(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_HEADER_INFO:
    protocol_header_dialog(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_HISTORY_MANAGER:
    history_manager(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_HISTORY_MOVE_BACK:
    iVar6 = eat_kbd_repeat_count(ses);
    local_54 = -1;
    if (0 < iVar6) {
      local_54 = -iVar6;
    }
    go_history_by_n(ses,local_54);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_HISTORY_MOVE_FORWARD:
    local_54 = eat_kbd_repeat_count(ses);
    if (local_54 < 1) {
      local_54 = 1;
    }
    go_history_by_n(ses,local_54);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_KEYBINDING_MANAGER:
    keybinding_manager(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_KILL_BACKGROUNDED_CONNECTIONS:
    abort_background_connections();
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_LINK_DOWNLOAD:
  case ACT_MAIN_LINK_DOWNLOAD_IMAGE:
  case ACT_MAIN_LINK_DOWNLOAD_RESUME:
    fVar4 = download_link(ses,doc_view,action_id);
    goto ignore_action;
  case ACT_MAIN_LINK_EXTERNAL_COMMAND:
    fVar4 = pass_uri_to_command(ses,doc_view,1);
    goto ignore_action;
  case ACT_MAIN_LINK_FOLLOW:
    fVar4 = enter(ses,doc_view,0);
    goto ignore_action;
  case ACT_MAIN_LINK_FOLLOW_RELOAD:
    fVar4 = enter(ses,doc_view,1);
    goto ignore_action;
  case ACT_MAIN_LINK_MENU:
    link_menu(term,(void *)0x0,ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_LINK_FORM_MENU:
    link_form_menu(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_MARK_GOTO:
    bVar9 = doc_view != (document_view *)0x0;
    fVar4 = FRAME_EVENT_REFRESH;
    (ses->kbdprefix).mark = KP_MARK_GOTO;
    break;
  case ACT_MAIN_MARK_SET:
    bVar9 = doc_view != (document_view *)0x0;
    fVar4 = FRAME_EVENT_REFRESH;
    (ses->kbdprefix).mark = KP_MARK_SET;
    break;
  case ACT_MAIN_MENU:
    activate_bfu_technology(ses,-1);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_MOVE_CURSOR_DOWN:
    fVar4 = move_cursor_down(ses,doc_view);
    goto ignore_action;
  case ACT_MAIN_MOVE_CURSOR_LEFT:
    fVar4 = move_cursor_left(ses,doc_view);
    goto ignore_action;
  case ACT_MAIN_MOVE_CURSOR_LINE_START:
    fVar4 = move_cursor_line_start(ses,doc_view);
    goto ignore_action;
  case ACT_MAIN_MOVE_CURSOR_RIGHT:
    fVar4 = move_cursor_right(ses,doc_view);
    goto ignore_action;
  case ACT_MAIN_MOVE_CURSOR_UP:
    fVar4 = move_cursor_up(ses,doc_view);
    goto ignore_action;
  case ACT_MAIN_MOVE_DOCUMENT_END:
    fVar4 = move_document_end(ses,doc_view);
    goto ignore_action;
  case ACT_MAIN_MOVE_DOCUMENT_START:
    fVar4 = move_document_start(ses,doc_view);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_DOWN:
    fVar4 = move_link_dir(ses,doc_view,0,1);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_DOWN_LINE:
    fVar4 = move_link_down_line(ses,doc_view);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_LEFT:
    fVar4 = move_link_dir(ses,doc_view,-1,0);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_LEFT_LINE:
    fVar4 = move_link_prev_line(ses,doc_view);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_NEXT:
    fVar4 = move_link(ses,doc_view,1,doc_view->document->nlinks + -1,0);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_PREV:
    fVar4 = move_link(ses,doc_view,-1,0,doc_view->document->nlinks + -1);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_RIGHT:
    fVar4 = move_link_dir(ses,doc_view,1,0);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_RIGHT_LINE:
    fVar4 = move_link_next_line(ses,doc_view);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_UP:
    fVar4 = move_link_dir(ses,doc_view,0,-1);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_UP_LINE:
    fVar4 = move_link_up_line(ses,doc_view);
    goto ignore_action;
  case ACT_MAIN_MOVE_PAGE_DOWN:
    fVar4 = move_page_down(ses,doc_view);
    goto ignore_action;
  case ACT_MAIN_MOVE_PAGE_UP:
    fVar4 = move_page_up(ses,doc_view);
    goto ignore_action;
  case ACT_MAIN_OPEN_LINK_IN_NEW_TAB:
    open_current_link_in_new_tab(ses,0);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_OPEN_LINK_IN_NEW_TAB_IN_BACKGROUND:
    open_current_link_in_new_tab(ses,1);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_OPEN_LINK_IN_NEW_WINDOW:
    open_in_new_window(term,send_open_in_new_window,ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_OPEN_NEW_TAB:
    local_54 = 0;
    goto LAB_080ecac0;
  case ACT_MAIN_OPEN_NEW_TAB_IN_BACKGROUND:
    local_54 = 1;
LAB_080ecac0:
    open_uri_in_new_tab(ses,(uri *)0x0,local_54,1);
switchD_080ecb10_caseD_10:
    bVar9 = false;
    fVar4 = FRAME_EVENT_OK;
    break;
  case ACT_MAIN_OPEN_NEW_WINDOW:
    open_in_new_window(term,send_open_new_window,ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_OPEN_OS_SHELL:
    exec_shell(term);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_OPTIONS_MANAGER:
    options_manager(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_QUIT:
    exit_prog(ses,1);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_REALLY_QUIT:
    exit_prog(ses,0);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_REDRAW:
    redraw_terminal_cls(term);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_RELOAD:
    reload(ses,CACHE_MODE_INCREMENT);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_RERENDER:
    draw_formatted(ses,2);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_RESET_FORM:
    fVar4 = reset_form(ses,doc_view,0);
    goto ignore_action;
  case ACT_MAIN_RESOURCE_INFO:
    resource_info(term);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_SAVE_AS:
    fVar4 = save_as(ses,doc_view,0);
    goto ignore_action;
  case ACT_MAIN_SAVE_FORMATTED:
    fVar4 = save_formatted_dlg(ses,doc_view,0);
    goto ignore_action;
  case ACT_MAIN_SAVE_OPTIONS:
    write_config(term);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_SAVE_URL_AS:
    save_url_as(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_SCROLL_DOWN:
    fVar4 = scroll_down(ses,doc_view);
    goto ignore_action;
  case ACT_MAIN_SCROLL_LEFT:
    fVar4 = scroll_left(ses,doc_view);
    goto ignore_action;
  case ACT_MAIN_SCROLL_RIGHT:
    fVar4 = scroll_right(ses,doc_view);
    goto ignore_action;
  case ACT_MAIN_SCROLL_UP:
    fVar4 = scroll_up(ses,doc_view);
    goto ignore_action;
  case ACT_MAIN_SEARCH:
    fVar4 = search_dlg(ses,doc_view,1);
    goto ignore_action;
  case ACT_MAIN_SEARCH_BACK:
    fVar4 = search_dlg(ses,doc_view,-1);
    goto ignore_action;
  case ACT_MAIN_SEARCH_TYPEAHEAD:
  case ACT_MAIN_SEARCH_TYPEAHEAD_LINK:
  case ACT_MAIN_SEARCH_TYPEAHEAD_TEXT:
  case ACT_MAIN_SEARCH_TYPEAHEAD_TEXT_BACK:
    fVar4 = search_typeahead(ses,doc_view,action_id);
    goto ignore_action;
  case ACT_MAIN_SHOW_TERM_OPTIONS:
    terminal_options(term,(void *)0x0,ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_SUBMIT_FORM:
    fVar4 = submit_form(ses,doc_view,0);
    goto ignore_action;
  case ACT_MAIN_SUBMIT_FORM_RELOAD:
    fVar4 = submit_form(ses,doc_view,1);
    goto ignore_action;
  case ACT_MAIN_TAB_CLOSE:
    close_tab(term,ses);
    return FRAME_EVENT_SESSION_DESTROYED;
  case ACT_MAIN_TAB_CLOSE_ALL_BUT_CURRENT:
    close_all_tabs_but_current(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_TAB_EXTERNAL_COMMAND:
    fVar4 = pass_uri_to_command(ses,doc_view,2);
    goto ignore_action;
  case ACT_MAIN_TAB_MENU:
    if (assert_failed == 0) {
      pwVar1 = ses->tab;
      pwVar7 = get_tab_by_number(term,term->current_tab);
      bVar9 = pwVar1 != pwVar7;
      assert_failed = ZEXT14(bVar9);
      if (bVar9) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/action.c";
        errline = 0x231;
        elinks_internal((uchar *)"assertion ses->tab == get_current_tab(term) failed!");
      }
    }
    if ((*(byte *)&ses->status & 1) == 0) {
      tab_menu(ses,0,0,0);
      fVar4 = FRAME_EVENT_OK;
      bVar9 = false;
    }
    else {
      tab_menu(ses,ses->tab->xpos,(term->height + -1) - ((uint)(*(byte *)&ses->status >> 1) & 1),1);
      fVar4 = FRAME_EVENT_OK;
      bVar9 = false;
    }
    break;
  case ACT_MAIN_TAB_MOVE_LEFT:
    move_current_tab(ses,-1);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_TAB_MOVE_RIGHT:
    move_current_tab(ses,1);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_TAB_NEXT:
    switch_current_tab(ses,1);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_TAB_PREV:
    switch_current_tab(ses,-1);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_TERMINAL_RESIZE:
    resize_terminal_dialog(term);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_TOGGLE_CSS:
    toggle_document_option(ses,(uchar *)"document.css.enable");
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_TOGGLE_DISPLAY_IMAGES:
    toggle_document_option(ses,(uchar *)"document.browse.images.show_as_links");
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_TOGGLE_DISPLAY_TABLES:
    toggle_document_option(ses,(uchar *)"document.html.display_tables");
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_TOGGLE_DOCUMENT_COLORS:
    toggle_document_option(ses,(uchar *)"document.colors.use_document_colors");
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_TOGGLE_HTML_PLAIN:
    toggle_plain_html(ses,ses->doc_view,0);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_TOGGLE_MOUSE:
    toggle_mouse(local_5c,local_58);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_TOGGLE_NUMBERED_LINKS:
    toggle_document_option(ses,(uchar *)"document.browse.links.numbering");
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_TOGGLE_PLAIN_COMPRESS_EMPTY_LINES:
    toggle_document_option(ses,(uchar *)"document.plain.compress_empty_lines");
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_TOGGLE_WRAP_TEXT:
    toggle_wrap_text(ses,ses->doc_view,0);
    fVar4 = FRAME_EVENT_OK;
    bVar9 = false;
    break;
  case ACT_MAIN_VIEW_IMAGE:
    fVar4 = view_image(ses,doc_view,0);
ignore_action:
    if (fVar4 == FRAME_EVENT_SESSION_DESTROYED) {
      return FRAME_EVENT_SESSION_DESTROYED;
    }
    bVar9 = fVar4 == FRAME_EVENT_REFRESH && doc_view != (document_view *)0x0;
  }
LAB_080ec9e9:
  iVar2 = ses->insert_mode;
joined_r0x080eca57:
  if (iVar2 == INSERT_MODE_ON) {
    if (((doc_view == (document_view *)0x0) || (local_54 = doc_view->vs->current_link, local_54 < 0)
        ) || (doc_view->document->nlinks <= local_54)) {
      local_24 = (link *)0x0;
    }
    else {
      local_24 = doc_view->document->links + local_54;
    }
    if (local_24 != plVar8) {
      ses->insert_mode = INSERT_MODE_OFF;
    }
  }
  if (bVar9) {
    refresh_view(ses,doc_view,0);
    fVar4 = FRAME_EVENT_REFRESH;
  }
  return fVar4;
switchD_080ecb10_caseD_a:
  shrink_memory(1);
  goto switchD_080ecb10_caseD_10;
}



int get_timer_duration(void)

{
  return timer_duration;
}



void done_timer(module *module)

{
  kill_timer(&countdown);
  return;
}



void reset_timer(void)

{
  int *piVar1;
  uchar *name;
  uchar *name_00;
  
  kill_timer(&countdown);
  piVar1 = get_opt_(config_options,name);
  if (*piVar1 == 0) {
    return;
  }
  piVar1 = get_opt_(config_options,name_00);
  timer_duration = *piVar1;
  install_timer(&countdown,1000,count_down,(void *)0x0);
  return;
}



void init_timer(module *module)

{
  reset_timer();
  return;
}



void count_down(void *xxx)

{
  uchar **ppuVar1;
  keybinding *pkVar2;
  uchar *in_EDX;
  terminal *term;
  term_event ev;
  
  timer_duration = timer_duration + -1;
  if (timer_duration == 0) {
    countdown = (timer_id_T)0x0;
    ppuVar1 = (uchar **)get_opt_(config_options,in_EDX);
    pkVar2 = kbd_nm_lookup(KEYMAP_MAIN,*ppuVar1);
    if (pkVar2 != (keybinding *)0x0) {
      ev.info._4_4_ = (pkVar2->kbd).modifier;
      ev.info._0_4_ = (pkVar2->kbd).key;
      ev.info._8_4_ = 0;
      ev.ev = EVENT_KBD;
      if ((list_head_elinks *)terminals.next != &terminals) {
        term = (terminal *)terminals.next;
        do {
          term_send_event(term,&ev);
          term = term->next;
        } while (term != (terminal *)&terminals);
      }
    }
    reset_timer();
    return;
  }
  install_timer(&countdown,1000,count_down,(void *)0x0);
  return;
}



dump_output * __regparm3 dump_output_alloc(int fd,string *string)

{
  bool bVar1;
  dump_output *pdVar2;
  
  if (assert_failed == 0) {
    bVar1 = (string == (string *)0x0) != (fd != -1);
    assert_failed = ZEXT14(bVar1);
    if (bVar1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/dump/dump.c";
      errline = 0x5e;
      elinks_internal((uchar *)"assertion (fd == -1) ^ (string == NULL) failed!");
      if (assert_failed != 0) goto LAB_080ed99a;
    }
    pdVar2 = (dump_output *)mem_alloc(0x1000c);
    if (pdVar2 != (dump_output *)0x0) {
      pdVar2->fd = fd;
      pdVar2->string = string;
      pdVar2->bufpos = 0;
      return pdVar2;
    }
  }
  else {
LAB_080ed99a:
    assert_failed = 0;
    pdVar2 = (dump_output *)0x0;
  }
  return pdVar2;
}



int __regparm3 dump_output_flush(dump_output *out)

{
  int iVar1;
  string *psVar2;
  size_t __n;
  uint uVar3;
  size_t sVar4;
  uchar *puVar5;
  uint size;
  
  psVar2 = out->string;
  if (psVar2 == (string *)0x0) {
    sVar4 = hard_write(out->fd,out->buf,out->bufpos);
    if (sVar4 != out->bufpos) {
      return -1;
    }
  }
  else {
    __n = out->bufpos;
    if (assert_failed != 0) {
      assert_failed = 0;
      return -1;
    }
    if ((int)__n < 0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) {
        assert_failed = 0;
        return -1;
      }
    }
    else {
      assert_failed = 0;
      if (__n == 0) goto LAB_080eda5c;
    }
    iVar1 = __n + psVar2->length;
    uVar3 = psVar2->length + 0xffU & 0xffffff00;
    size = iVar1 + 0x100U & 0xffffff00;
    if (uVar3 < size) {
      puVar5 = (uchar *)mem_realloc(psVar2->source,size);
      if (puVar5 == (uchar *)0x0) {
        return -1;
      }
      psVar2->source = puVar5;
      memset(puVar5 + uVar3,0,size - uVar3);
    }
    if (psVar2->source == (uchar *)0x0) {
      return -1;
    }
    memcpy(psVar2->source + psVar2->length,out->buf,__n);
    psVar2->source[iVar1] = '\0';
    psVar2->length = iVar1;
  }
LAB_080eda5c:
  out->bufpos = 0;
  return 0;
}



int __regparm3 write_char(uchar c,dump_output *out)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = out->bufpos;
  if (0xffff < uVar1) {
    iVar2 = dump_output_flush(out);
    if (iVar2 != 0) {
      return -1;
    }
    uVar1 = out->bufpos;
  }
  out->buf[uVar1] = c;
  out->bufpos = uVar1 + 1;
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int __regparm3 write_color_16(uchar color,dump_output *out)

{
  int iVar1;
  int iVar2;
  uchar *puVar3;
  int in_GS_OFFSET;
  uchar bufor [11];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  bufor._4_2_ = CONCAT11((color & 7) + 0x30,0x33);
  bufor._4_4_ = CONCAT22(0x343b,bufor._4_2_);
  bufor._0_4_ = 0x3b305b1b;
  bufor._8_2_ = 0x6d30;
  bufor[10] = '\0';
  if ((color >> 4 & 7) == 0) {
    bufor._4_4_ = (uint)CONCAT12(0x6d,bufor._4_2_);
  }
  else {
    bufor._8_2_ = CONCAT11(0x6d,(color >> 4 & 7) + 0x30);
  }
  puVar3 = bufor;
  do {
    if (*puVar3 == '\0') {
      iVar2 = 0;
LAB_080edc45:
      if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
        return iVar2;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    iVar2 = write_char(*puVar3,out);
    if (iVar2 != 0) {
      iVar2 = -1;
      goto LAB_080edc45;
    }
    puVar3 = puVar3 + 1;
  } while( true );
}



int __regparm3 dump_nocolor(document *document,dump_output *out)

{
  int iVar1;
  line *plVar2;
  int iVar3;
  uchar *puVar4;
  byte c;
  uint u;
  int local_2c;
  int local_20;
  
  iVar1 = is_cp_utf8((document->options).cp);
  if (iVar1 == 0) {
    local_2c = 0;
    if (0 < document->height) {
      do {
        iVar1 = 0;
        plVar2 = document->data + local_2c;
        local_20 = 0;
        if (0 < plVar2->length) {
          do {
            c = *(byte *)&plVar2->chars[local_20].data;
            if (((c < 0xb0) || (-1 < (char)plVar2->chars[local_20].attr)) || (0xdf < c)) {
              if (c != 0x7f) goto LAB_080edd58;
LAB_080edcf9:
              iVar1 = iVar1 + 1;
            }
            else {
              c = *(byte *)((int)&os2xtd[0xea].key + (uint)c);
              if (c == 0x7f) goto LAB_080edcf9;
LAB_080edd58:
              if ((c < 0x20) || (c == 0x20)) goto LAB_080edcf9;
              while (iVar1 != 0) {
                iVar3 = write_char(' ',out);
                if (iVar3 != 0) goto LAB_080edd8a;
                iVar1 = iVar1 + -1;
              }
              iVar1 = write_char(c,out);
              if (iVar1 != 0) goto LAB_080edd8a;
              iVar1 = 0;
            }
            local_20 = local_20 + 1;
            plVar2 = document->data + local_2c;
          } while (local_20 < plVar2->length);
        }
        iVar1 = write_char('\n',out);
        if (iVar1 != 0) goto LAB_080edd8a;
        local_2c = local_2c + 1;
      } while (local_2c < document->height);
    }
  }
  else {
    local_2c = 0;
    if (0 < document->height) {
      do {
        iVar1 = 0;
        plVar2 = document->data + local_2c;
        local_20 = 0;
        if (0 < plVar2->length) {
          do {
            u = plVar2->chars[local_20].data;
            if (u != 0xfffffffd) {
              if ((((char)plVar2->chars[local_20].attr < '\0') && (0xaf < u)) && (u < 0xe0)) {
                u = (uint)*(byte *)((int)&os2xtd[0xea].key + u);
              }
              if (((u - 0x20 < 0x5f) || (0x9f < u)) && (u != 0x20)) {
                while (iVar1 != 0) {
                  iVar3 = write_char(' ',out);
                  if (iVar3 != 0) goto LAB_080edd8a;
                  iVar1 = iVar1 + -1;
                }
                puVar4 = encode_utf8(u);
                while (*puVar4 != '\0') {
                  iVar1 = write_char(*puVar4,out);
                  if (iVar1 != 0) goto LAB_080edd8a;
                  puVar4 = puVar4 + 1;
                }
                iVar1 = 0;
              }
              else {
                iVar1 = iVar1 + 1;
              }
            }
            local_20 = local_20 + 1;
            plVar2 = document->data + local_2c;
          } while (local_20 < plVar2->length);
        }
        iVar1 = write_char('\n',out);
        if (iVar1 != 0) goto LAB_080edd8a;
        local_2c = local_2c + 1;
      } while (local_2c < document->height);
    }
  }
  iVar3 = dump_output_flush(out);
  iVar1 = 0;
  if (iVar3 != 0) {
LAB_080edd8a:
    iVar1 = -1;
  }
  return iVar1;
}



string * add_document_to_string(string *string,document *document)

{
  dump_output *out;
  int iVar1;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(document == (document *)0x0 || string == (string *)0x0);
    if (document == (document *)0x0 || string == (string *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/dump/dump.c";
      errline = 0x262;
      elinks_internal((uchar *)"assertion string && document failed!");
      if (assert_failed != 0) goto LAB_080edfb2;
    }
    out = dump_output_alloc(-1,string);
    if (out != (dump_output *)0x0) {
      iVar1 = dump_nocolor(document,out);
      mem_free(out);
      if (iVar1 == 0) {
        return string;
      }
    }
  }
  else {
LAB_080edfb2:
    assert_failed = 0;
  }
  return (string *)0x0;
}



int __regparm3 write_color_256(uchar *str,uchar color,dump_output *out)

{
  int iVar1;
  int iVar2;
  uchar *puVar3;
  int in_GS_OFFSET;
  uchar bufor [16];
  
  puVar3 = bufor;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __snprintf_chk(puVar3,0x10,1,0x10,&DAT_08135123,str,(uint)color);
  do {
    if (*puVar3 == '\0') {
      iVar2 = 0;
LAB_080ee03d:
      if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
        return iVar2;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    iVar2 = write_char(*puVar3,out);
    if (iVar2 != 0) {
      iVar2 = -1;
      goto LAB_080ee03d;
    }
    puVar3 = puVar3 + 1;
  } while( true );
}



int __regparm3 dump_256color(document *document,dump_output *out)

{
  uchar color;
  int iVar1;
  int *piVar2;
  screen_char *psVar3;
  int iVar4;
  uchar *puVar5;
  line *plVar6;
  uchar color_00;
  uchar *name;
  int iVar7;
  uint u;
  uchar color_01;
  uchar color_02;
  int local_38;
  byte local_24;
  uchar local_1d;
  
  iVar1 = is_cp_utf8((document->options).cp);
  if (iVar1 == 0) {
    piVar2 = get_opt_(config_options,name);
    iVar1 = *piVar2;
    if (0 < document->height) {
      local_38 = 0;
      color_01 = '\0';
      color_02 = '\0';
      do {
        write_color_256("38",color_02,out);
        write_color_256("48",color_01,out);
        plVar6 = document->data + local_38;
        if (plVar6->length < 1) {
          iVar7 = 0;
        }
        else {
          iVar7 = 0;
          color_00 = color_02;
          local_1d = color_01;
          do {
            psVar3 = plVar6->chars + iVar7;
            color = psVar3->attr;
            color_02 = psVar3->color[0];
            color_01 = psVar3->color[1];
            u = psVar3->data;
            if (((color_02 != color_00) && (iVar4 = write_color_256("38",color_02,out), iVar4 != 0))
               || ((color_01 != local_1d && (iVar4 = write_color_256("48",color_01,out), iVar4 != 0)
                   ))) goto LAB_080ee1c0;
            local_24 = (byte)u;
            if (((0xaf < local_24) && ((char)color < '\0')) && (local_24 < 0xe0)) {
              local_24 = *(byte *)((int)&os2xtd[0xea].key + (u & 0xff));
            }
            if ((local_24 == 0x7f) || (local_24 < 0x20)) {
              iVar4 = write_char(' ',out);
            }
            else {
              iVar4 = write_char(local_24,out);
            }
            if (iVar4 != 0) goto LAB_080ee1c0;
            iVar7 = iVar7 + 1;
            plVar6 = document->data + local_38;
            color_00 = color_02;
            local_1d = color_01;
          } while (iVar7 < plVar6->length);
        }
        while (iVar7 < iVar1) {
          iVar4 = write_char(' ',out);
          if (iVar4 != 0) goto LAB_080ee1c0;
          iVar7 = iVar7 + 1;
        }
        iVar7 = write_char('\n',out);
        if (iVar7 != 0) goto LAB_080ee1c0;
        local_38 = local_38 + 1;
      } while (local_38 < document->height);
    }
  }
  else {
    piVar2 = get_opt_(config_options,name);
    iVar1 = *piVar2;
    if (0 < document->height) {
      local_38 = 0;
      color_02 = '\0';
      local_1d = '\0';
      do {
        write_color_256("38",local_1d,out);
        write_color_256("48",color_02,out);
        plVar6 = document->data + local_38;
        if (plVar6->length < 1) {
          iVar7 = 0;
        }
        else {
          iVar7 = 0;
          do {
            psVar3 = plVar6->chars + iVar7;
            color_01 = psVar3->attr;
            color_00 = psVar3->color[0];
            u = psVar3->data;
            color = psVar3->color[1];
            if (u != 0xfffffffd) {
              if (((color_00 != local_1d) &&
                  (iVar4 = write_color_256("38",color_00,out), iVar4 != 0)) ||
                 ((color != color_02 && (iVar4 = write_color_256("48",color,out), iVar4 != 0))))
              goto LAB_080ee1c0;
              if ((((char)color_01 < '\0') && (0xaf < u)) && (u < 0xe0)) {
                u = (uint)*(byte *)((int)&os2xtd[0xea].key + u);
              }
              if ((0x5e < u - 0x20) && (u < 0xa0)) {
                u = 0x20;
              }
              puVar5 = encode_utf8(u);
              while (color_02 = color, local_1d = color_00, *puVar5 != '\0') {
                iVar4 = write_char(*puVar5,out);
                if (iVar4 != 0) goto LAB_080ee1c0;
                puVar5 = puVar5 + 1;
              }
            }
            iVar7 = iVar7 + 1;
            plVar6 = document->data + local_38;
          } while (iVar7 < plVar6->length);
        }
        while (iVar7 < iVar1) {
          iVar4 = write_char(' ',out);
          if (iVar4 != 0) goto LAB_080ee1c0;
          iVar7 = iVar7 + 1;
        }
        iVar7 = write_char('\n',out);
        if (iVar7 != 0) goto LAB_080ee1c0;
        local_38 = local_38 + 1;
      } while (local_38 < document->height);
    }
  }
  iVar7 = dump_output_flush(out);
  iVar1 = 0;
  if (iVar7 != 0) {
LAB_080ee1c0:
    iVar1 = -1;
  }
  return iVar1;
}



int __regparm3 dump_references(document *document,int fd,uchar *buf)

{
  int iVar1;
  bool bVar2;
  int *piVar3;
  ssize_t sVar4;
  size_t datalen;
  size_t sVar5;
  int iVar6;
  int iVar7;
  char *pcVar8;
  bool bVar9;
  char *local_3c;
  char *local_38;
  
  if ((document->nlinks != 0) && (piVar3 = get_opt_(config_options,(uchar *)fd), *piVar3 != 0)) {
    sVar4 = hard_write(fd,(uchar *)"\nReferences\n\n   Visible links\n",0x1e);
    if (sVar4 != 0x1e) {
      return -1;
    }
    if (0 < document->nlinks) {
      iVar7 = 0;
      pcVar8 = (char *)0x1;
      do {
        iVar6 = (int)&document->links->accesskey + iVar7;
        iVar1 = *(int *)(iVar6 + 8);
        if (iVar1 != 0) {
          if ((*(byte *)&(document->options).field_0x45 & 0x10) == 0) {
            local_38 = *(char **)(iVar6 + 0x14);
            if ((local_38 != (char *)0x0) && (*local_38 != '\0')) {
              local_3c = "   . %s\n\t%s\n";
              goto LAB_080ee549;
            }
            __snprintf_chk(buf,0x10000,1,0xffffffff,"   . %s\n",iVar1);
          }
          else {
            local_38 = *(char **)(iVar6 + 0x14);
            if ((local_38 == (char *)0x0) || (*local_38 == '\0')) {
              local_3c = "%4d. %s\n";
              local_38 = pcVar8;
LAB_080ee549:
              __snprintf_chk(buf,0x10000,1,0xffffffff,local_3c,local_38,iVar1);
            }
            else {
              __snprintf_chk(buf,0x10000,1,0xffffffff,"%4d. %s\n\t%s\n",pcVar8,local_38,iVar1);
            }
          }
          datalen = strlen((char *)buf);
          sVar5 = hard_write(fd,buf,datalen);
          if (sVar5 != datalen) {
            return -1;
          }
        }
        iVar7 = iVar7 + 0x34;
        bVar9 = (char *)document->nlinks != pcVar8;
        bVar2 = (int)pcVar8 <= (int)document->nlinks;
        pcVar8 = pcVar8 + 1;
      } while (bVar9 && bVar2);
    }
  }
  return 0;
}



int dump_to_file(document *document,int fd)

{
  dump_output *out;
  int iVar1;
  
  out = dump_output_alloc(fd,(string *)0x0);
  iVar1 = -1;
  if (out != (dump_output *)0x0) {
    iVar1 = dump_nocolor(document,out);
    if (iVar1 == 0) {
      iVar1 = dump_references(document,fd,out->buf);
    }
    mem_free(out);
  }
  return iVar1;
}



void __regparm3 dump_print(uchar *option_elinks,string *url)

{
  byte bVar1;
  uint uVar2;
  string **ppsVar3;
  string *psVar4;
  string *psVar5;
  uchar *p;
  size_t __n;
  int iVar6;
  char cVar7;
  string *size;
  string *__src;
  string string;
  
  ppsVar3 = (string **)get_opt_(config_options,(uchar *)url);
  __src = *ppsVar3;
  if ((__src == (string *)0x0) || (psVar4 = init_string(&string), psVar4 == (string *)0x0)) {
    return;
  }
LAB_080ee6f0:
  cVar7 = *(char *)&__src->source;
  do {
    if (cVar7 == '\0') goto LAB_080ee763;
    if ((cVar7 == '%') || (__n = 0, cVar7 == '\\')) {
      __n = 0;
      psVar4 = __src;
    }
    else {
      do {
        __n = __n + 1;
        cVar7 = *(char *)((int)&__src->source + __n);
        psVar4 = (string *)((int)&__src->source + __n);
        if ((cVar7 == '%') || (cVar7 == '\0')) break;
      } while (cVar7 != '\\');
    }
    if (assert_failed == 0) {
      if ((int)__n < 0) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]",
                        option_elinks);
        if (assert_failed != 0) goto LAB_080ee737;
      }
      else {
        assert_failed = 0;
      }
      if (__n != 0) {
        iVar6 = __n + string.length;
        uVar2 = string.length + 0xffU >> 8;
        psVar5 = (string *)(string.length + 0xffU & 0xffffff00);
        size = (string *)(iVar6 + 0x100U & 0xffffff00);
        if (psVar5 <= size && size + uVar2 * 0x1fffffe0 != (string *)0x0) {
          option_elinks = (uchar *)size;
          p = (uchar *)mem_realloc(string.source,(size_t)size);
          if (p == (uchar *)0x0) goto LAB_080ee748;
          option_elinks = (uchar *)0x0;
          string.source = p;
          memset(p + (int)psVar5,0,(size_t)(size + uVar2 * 0x1fffffe0));
        }
        if (string.source != (uchar *)0x0) {
          memcpy(string.source + string.length,__src,__n);
          string.source[iVar6] = '\0';
          option_elinks = (uchar *)__src;
          string.length = iVar6;
        }
      }
    }
    else {
LAB_080ee737:
      assert_failed = 0;
    }
LAB_080ee748:
    if (*(char *)&psVar4->source != '\\') break;
    bVar1 = *(byte *)((int)&psVar4->source + 1);
    if (bVar1 == 0x6e) {
      option_elinks = (uchar *)0xa;
    }
    else {
      if (bVar1 == 0x74) {
        option_elinks = &DAT_00000009;
      }
      else {
        if (bVar1 == 0x66) {
          option_elinks = &DAT_0000000c;
        }
        else {
          if (bVar1 == 0) goto LAB_080ee763;
          option_elinks = (uchar *)(uint)bVar1;
        }
      }
    }
    __src = (string *)((int)&psVar4->source + 2);
    add_char_to_string(&string,(uchar)option_elinks);
    cVar7 = *(char *)&__src->source;
  } while( true );
  if (*(char *)&psVar4->source != '%') {
LAB_080ee763:
    p = string.source;
    if (string.source == (uchar *)0x0) {
      return;
    }
    __printf_chk(1,0x8133695,string.source);
    fflush(stdout);
    mem_free(p);
    return;
  }
  cVar7 = *(char *)((int)&psVar4->source + 1);
  if (cVar7 == 'u') {
    if (url == (string *)0x0) goto LAB_080ee7a0;
    option_elinks = (uchar *)url;
    add_string_to_string(&string,url);
    cVar7 = *(char *)((int)&psVar4->source + 1);
  }
  if (cVar7 == '\0') goto LAB_080ee763;
LAB_080ee7a0:
  __src = (string *)((int)&psVar4->source + 2);
  goto LAB_080ee6f0;
}



void dump_next(list_head_elinks *url_list)

{
  list_head_elinks *plVar1;
  uchar *uristring;
  list_head_elinks done_list;
  list_head_elinks todo_list;
  uchar *cwd;
  uri *uri;
  protocol_external_handler_T *ppVar2;
  int iVar3;
  int first;
  
  if (url_list != (list_head_elinks *)0x0) {
    while (plVar1 = (list_head_elinks *)url_list->next, plVar1 != url_list) {
      *(void **)((int)plVar1->next + 4) = plVar1->prev;
      *(void **)plVar1->prev = plVar1->next;
      plVar1->next = *(void **)todo_list.prev;
      plVar1->prev = todo_list.prev;
      *(list_head_elinks **)todo_list.prev = plVar1;
      *(list_head_elinks **)((int)plVar1->next + 4) = plVar1;
    }
  }
  if (todo_list.next == (void *)0x8148b94) {
    free_string_list((list_head_elinks *)0x8148b8c);
    program.terminate = 1;
    return;
  }
  program.terminate = 0;
  *(undefined4 *)(*(int *)todo_list.next + 4) = *(undefined4 *)((int)todo_list.next + 4);
  **(undefined4 **)((int)todo_list.next + 4) = *(undefined4 *)todo_list.next;
  *(undefined4 *)((int)todo_list.next + 4) = 0x8148b8c;
  *(void **)todo_list.next = done_list.next;
  *(void **)(*(int *)todo_list.next + 4) = todo_list.next;
  if (first == 0) {
    dump_print((uchar *)"document.dump.separator",(string *)0x0);
  }
  else {
    first = 0;
  }
  dump_print((uchar *)"document.dump.header",(string *)((int)todo_list.next + 8));
  uristring = *(uchar **)((int)todo_list.next + 8);
  cwd = get_cwd();
  uri = get_translated_uri(uristring,cwd);
  if (cwd != (uchar *)0x0) {
    mem_free(cwd);
  }
  if ((uri == (uri *)0x0) ||
     (ppVar2 = get_protocol_external_handler((terminal *)0x0,uri),
     ppVar2 != (protocol_external_handler_T *)0x0)) {
    cwd = gettext((uchar *)"URL protocol not supported (%s).");
    usrerror(cwd,uristring);
    dump_next((list_head_elinks *)0x0);
    program.terminate = 1;
    program.retval = RET_SYNTAX;
    if (uri == (uri *)0x0) goto LAB_080eea75;
  }
  else {
    dump_download.callback = dump_loading_callback;
    dump_pos = 0;
    iVar3 = load_uri(uri,(uri *)0x0,&dump_download,PRI_MAIN,CACHE_MODE_ALWAYS,-1);
    if (iVar3 != 0) {
      dump_next((list_head_elinks *)0x0);
      program.terminate = 1;
      program.retval = RET_SYNTAX;
    }
  }
  done_uri(uri);
LAB_080eea75:
  dump_print((uchar *)"document.dump.footer",(string *)((int)todo_list.next + 8));
  return;
}



void dump_loading_callback(download *download,void *p)

{
  uchar color;
  cache_entry *pcVar1;
  uri *uri;
  bool bVar2;
  document *pdVar3;
  uchar uVar4;
  int fd;
  int *piVar5;
  color_mode *pcVar6;
  uint *puVar7;
  dump_output *out;
  uchar *name;
  int iVar8;
  connection_basic_state cVar9;
  list_head_elinks *plVar10;
  int iVar11;
  char *pcVar12;
  int iVar13;
  void *pvVar14;
  line *plVar15;
  uchar *extraout_EDX;
  uchar *name_00;
  uchar *name_01;
  uchar *name_02;
  uchar *name_03;
  screen_char *psVar16;
  uint u;
  void *pvVar17;
  uchar color_00;
  document_view *pdVar18;
  void *datalen;
  byte c;
  int local_130;
  int local_124;
  document_options o;
  document_view formatted;
  view_state vs;
  
  c = 0;
  pcVar1 = download->cached;
  fd = get_output_handle();
  if (fd == -1) {
    return;
  }
  name = extraout_EDX;
  if (((pcVar1 != (cache_entry *)0x0) && (pcVar1->redirect != (uri *)0x0)) &&
     (name = (uchar *)(dump_redir_count + 1), bVar2 = dump_redir_count < 10,
     dump_redir_count = (int)name, bVar2)) {
    uri = pcVar1->redirect;
    cancel_download(download,0);
    load_uri(uri,pcVar1->uri,download,PRI_MAIN,CACHE_MODE_ALWAYS,-1);
    return;
  }
  if ((uint)(download->state).basic < 8) {
    return;
  }
  piVar5 = get_opt_(cmdline_options,name);
  if (*piVar5 == 0) {
    if (pcVar1 != (cache_entry *)0x0) {
LAB_080eef27:
      plVar10 = (list_head_elinks *)(pcVar1->frag).next;
      if (plVar10 != &pcVar1->frag) {
        do {
          pvVar14 = (void *)(dump_pos - (int)plVar10[1].next);
          if (-1 < (int)pvVar14) {
            pvVar17 = (void *)((int)pvVar14 >> 0x1f);
            datalen = plVar10[2].prev;
            if ((plVar10[2].prev != pvVar17 && (int)pvVar17 <= (int)datalen) ||
               (((int)pvVar17 <= (int)datalen && (pvVar14 < plVar10[2].next)))) goto LAB_080eef56;
          }
          plVar10 = (list_head_elinks *)plVar10->next;
          if (plVar10 == &pcVar1->frag) break;
        } while( true );
      }
    }
    cVar9 = (download->state).basic;
    if (-1 < cVar9) {
      return;
    }
    goto LAB_080eee5f;
  }
  cVar9 = (download->state).basic;
  if (7 < cVar9) {
    return;
  }
  if (pcVar1 == (cache_entry *)0x0) goto LAB_080eee5f;
  iVar13 = 0xf;
  pdVar18 = &formatted;
  while (iVar13 != 0) {
    iVar13 = iVar13 + -1;
    pdVar18->next = (document_view *)0x0;
    pdVar18 = (document_view *)((int)pdVar18 + (uint)c * -8 + 4);
  }
  init_document_options(&o);
  piVar5 = get_opt_(config_options,name_00);
  o.box.x = 0;
  o.box.y = 1;
  o.box.height = 0x19;
  o.box.width = *piVar5;
  if (*piVar5 < 0) {
    o.box.width = 0;
  }
  piVar5 = get_opt_(config_options,(uchar *)0x0);
  o.cp = *piVar5;
  pcVar6 = get_opt_(config_options,name_01);
  o.color_mode = *pcVar6;
  o._69_1_ = o._69_1_ & 0xbf;
  o._68_1_ = o._68_1_ & 0xef;
  puVar7 = get_opt_(config_options,name_02);
  o._69_1_ = o._69_1_ & 0xef | (byte)((*puVar7 & 1) << 4);
  init_vs(&vs,pcVar1->uri,-1);
  render_document(&vs,&formatted,&o);
  out = dump_output_alloc(fd,(string *)0x0);
  pdVar3 = formatted.document;
  if (out != (dump_output *)0x0) {
    if (o.color_mode == COLOR_MODE_88) {
LAB_080eefd9:
      iVar13 = dump_256color(formatted.document,out);
    }
    else {
      if (o.color_mode < 3) {
        if (o.color_mode + 1U < 2) {
          iVar13 = dump_nocolor(formatted.document,out);
          goto joined_r0x080eefe7;
        }
      }
      else {
        if (o.color_mode == COLOR_MODE_256) goto LAB_080eefd9;
      }
      iVar13 = is_cp_utf8(((formatted.document)->options).cp);
      if (iVar13 == 0) {
        piVar5 = get_opt_(config_options,name_03);
        iVar13 = *piVar5;
        if (0 < pdVar3->height) {
          local_130 = 0;
          color_00 = '\0';
          do {
            write_color_16(color_00,out);
            plVar15 = pdVar3->data + local_130;
            if (plVar15->length < 1) {
              iVar8 = 0;
            }
            else {
              iVar8 = 0;
              uVar4 = color_00;
              do {
                psVar16 = plVar15->chars + iVar8;
                color_00 = psVar16->color[0];
                color = psVar16->attr;
                u = psVar16->data;
                if ((color_00 != uVar4) && (iVar11 = write_color_16(color_00,out), iVar11 != 0))
                goto LAB_080eee30;
                c = (byte)u;
                if ((0xaf < c) && (((char)color < '\0' && (c < 0xe0)))) {
                  c = *(byte *)((int)&os2xtd[0xea].key + (u & 0xff));
                }
                if ((c == 0x7f) || (c < 0x20)) {
                  c = 0x20;
                }
                iVar11 = write_char(c,out);
                if (iVar11 != 0) goto LAB_080eee30;
                iVar8 = iVar8 + 1;
                plVar15 = pdVar3->data + local_130;
                uVar4 = color_00;
              } while (iVar8 < plVar15->length);
            }
            while (iVar8 < iVar13) {
              iVar11 = write_char(' ',out);
              if (iVar11 != 0) goto LAB_080eee30;
              iVar8 = iVar8 + 1;
            }
            iVar8 = write_char('\n',out);
            if (iVar8 != 0) goto LAB_080eee30;
            local_130 = local_130 + 1;
          } while (local_130 < pdVar3->height);
        }
      }
      else {
        piVar5 = get_opt_(config_options,name_03);
        iVar13 = *piVar5;
        if (0 < pdVar3->height) {
          local_130 = 0;
          color_00 = '\0';
          do {
            write_color_16(color_00,out);
            plVar15 = pdVar3->data + local_130;
            if (plVar15->length < 1) {
              local_124 = 0;
            }
            else {
              local_124 = 0;
              do {
                psVar16 = plVar15->chars + local_124;
                u = psVar16->data;
                uVar4 = psVar16->attr;
                color = psVar16->color[0];
                if (u != 0xfffffffd) {
                  if ((color != color_00) && (iVar8 = write_color_16(color,out), iVar8 != 0))
                  goto LAB_080eee30;
                  if (((char)uVar4 < '\0') && ((0xaf < u && (u < 0xe0)))) {
                    u = (uint)*(byte *)((int)&os2xtd[0xea].key + u);
                  }
                  if ((0x5e < u - 0x20) && (u < 0xa0)) {
                    u = 0x20;
                  }
                  name = encode_utf8(u);
                  while (color_00 = color, *name != '\0') {
                    iVar8 = write_char(*name,out);
                    if (iVar8 != 0) goto LAB_080eee30;
                    name = name + 1;
                  }
                }
                local_124 = local_124 + 1;
                plVar15 = pdVar3->data + local_130;
              } while (local_124 < plVar15->length);
            }
            while (local_124 < iVar13) {
              iVar8 = write_char(' ',out);
              if (iVar8 != 0) goto LAB_080eee30;
              local_124 = local_124 + 1;
            }
            iVar8 = write_char('\n',out);
            if (iVar8 != 0) goto LAB_080eee30;
            local_130 = local_130 + 1;
          } while (local_130 < pdVar3->height);
        }
      }
      iVar13 = dump_output_flush(out);
    }
joined_r0x080eefe7:
    if (iVar13 == 0) {
      dump_references(formatted.document,fd,out->buf);
    }
LAB_080eee30:
    mem_free(out);
  }
  detach_formatted(&formatted);
  destroy_vs(&vs,1);
  cVar9 = (download->state).basic;
LAB_080eee5f:
  if (cVar9 != S_OK) {
    name = get_state_message(download->state,(terminal *)0x0);
    usrerror(name);
LAB_080eee8b:
    program.retval = RET_ERROR;
  }
  program.terminate = 1;
  dump_next((list_head_elinks *)0x0);
  return;
LAB_080eef56:
  datalen = (void *)((int)plVar10[2].next - (int)pvVar14);
  pvVar14 = (void *)hard_write(fd,(uchar *)((int)pvVar14 + 0x20U + (int)plVar10),(size_t)datalen);
  if (datalen != pvVar14) {
    detach_connection(download,(longlong)dump_pos);
    if ((int)pvVar14 < 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/dump/dump.c";
      errline = 0x191;
      piVar5 = __errno_location();
      pcVar12 = strerror(*piVar5);
      name = gettext((uchar *)"Can\'t write to stdout: %s");
      elinks_error(name,pcVar12);
    }
    else {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/dump/dump.c";
      errline = 0x194;
      name = gettext((uchar *)"Can\'t write to stdout.");
      elinks_error(name);
    }
    goto LAB_080eee8b;
  }
  dump_pos = (int)datalen + dump_pos;
  detach_connection(download,(longlong)dump_pos);
  goto LAB_080eef27;
}



void __regparm3
draw_frame_lines(terminal *term,frameset_desc *frameset_desc,int xp,int yp,color_pair *colors)

{
  int *piVar1;
  int y;
  int iVar2;
  int iVar3;
  int x;
  int x_00;
  frameset_desc *pfVar4;
  int iVar5;
  frame_desc *pfVar6;
  int local_4c;
  int local_44;
  int local_3c;
  int local_38;
  frameset_desc *local_30;
  box box;
  
  if (assert_failed == 0) {
    if ((frameset_desc == (frameset_desc *)0x0) || (term == (terminal *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
      errline = 0x61;
      elinks_internal((uchar *)
                      "assertion term && frameset_desc && frameset_desc->frame_desc failed!");
      if (assert_failed != 0) goto LAB_080ef3a5;
    }
    else {
      assert_failed = 0;
    }
    if (0 < (frameset_desc->box).height) {
      local_4c = yp + -1;
      x_00 = (frameset_desc->box).width;
      local_38 = 0;
      local_3c = local_4c;
LAB_080ef3f0:
      iVar2 = frameset_desc->frame_desc[local_38 * x_00].height;
      if (0 < x_00) {
        iVar5 = 0;
        y = local_3c + 1 + iVar2;
        x_00 = xp + -1;
        local_30 = frameset_desc;
        do {
          iVar3 = local_30->frame_desc[0].width;
          if (iVar5 == 0) {
            x = x_00 + 1 + iVar3;
            if (local_38 == 0) goto LAB_080ef4d4;
            if (-1 < x_00) {
              draw_border_cross(term,x_00,local_3c,BORDER_X_RIGHT,colors);
            }
LAB_080ef52b:
            box.x = x_00 + 1;
            if (box.x < 0) {
              box.x = 0;
            }
            box.height = 1;
            box.y = local_3c;
            if (local_3c < 0) {
              box.y = 0;
            }
            box.width = 0;
            if (-1 < iVar3) {
              box.width = iVar3;
            }
            draw_box(term,&box,-0x3c,SCREEN_ATTR_FRAME,colors);
            x = x_00 + 1 + iVar3;
            if (((frameset_desc->box).width + -1 == iVar5) && (x < term->width)) {
              draw_border_cross(term,x,local_3c,BORDER_X_LEFT,colors);
            }
            if ((iVar5 == 0) || (local_38 == 0)) goto LAB_080ef4d4;
            draw_border_char(term,x_00,local_3c,BORDER_SCROSS,colors);
            piVar1 = &(frameset_desc->box).width;
            if (*piVar1 == iVar5 + 1 || *piVar1 < iVar5 + 1) goto LAB_080ef5e0;
          }
          else {
            box.x = 0;
            if (-1 < x_00) {
              box.x = x_00;
            }
            box.width = 1;
            box.y = local_3c + 1;
            if (local_3c + 1 < 0) {
              box.y = 0;
            }
            box.height = 0;
            if (-1 < iVar2) {
              box.height = iVar2;
            }
            draw_box(term,&box,-0x4d,SCREEN_ATTR_FRAME,colors);
            if ((frameset_desc->box).height + -1 == local_38) {
              draw_border_cross(term,x_00,y,BORDER_X_UP,colors);
            }
            if (local_38 != 0) goto LAB_080ef52b;
            draw_border_cross(term,x_00,local_3c,BORDER_X_DOWN,colors);
            x = x_00 + 1 + iVar3;
LAB_080ef4d4:
            piVar1 = &(frameset_desc->box).width;
            if (*piVar1 == iVar5 + 1 || *piVar1 < iVar5 + 1) goto LAB_080ef5e0;
          }
          local_30 = (frameset_desc *)local_30->frame_desc;
          iVar5 = iVar5 + 1;
          x_00 = x;
        } while( true );
      }
      local_3c = local_3c + 1 + iVar2;
      x_00 = (frameset_desc->box).height;
      if (local_38 + 1 < x_00) goto LAB_080ef5f9;
LAB_080ef68f:
      if (0 < x_00) {
        x_00 = (frameset_desc->box).width;
        local_44 = 0;
        while( true ) {
          iVar2 = frameset_desc->frame_desc[local_44 * x_00].height;
          if (0 < x_00) {
            local_30 = (frameset_desc *)0x0;
            pfVar6 = frameset_desc->frame_desc + local_44 * x_00;
            x_00 = xp + -1;
            pfVar4 = frameset_desc;
            while( true ) {
              y = pfVar4->frame_desc[0].width;
              if (pfVar6->subframe != (frameset_desc *)0x0) {
                draw_frame_lines(term,pfVar6->subframe,x_00 + 1,local_4c + 1,colors);
              }
              pfVar4 = (frameset_desc *)pfVar4->frame_desc;
              pfVar6 = pfVar6 + 1;
              local_30 = (frameset_desc *)((int)local_30 + 1);
              piVar1 = &(frameset_desc->box).width;
              if ((frameset_desc *)*piVar1 == local_30 || *piVar1 < (int)local_30) break;
              x_00 = y + 1 + x_00;
            }
          }
          local_44 = local_44 + 1;
          piVar1 = &(frameset_desc->box).height;
          if (*piVar1 == local_44 || *piVar1 < local_44) break;
          local_4c = local_4c + 1 + iVar2;
          x_00 = (frameset_desc->box).width;
        }
      }
    }
  }
  else {
LAB_080ef3a5:
    assert_failed = 0;
  }
  return;
LAB_080ef5e0:
  x_00 = (frameset_desc->box).height;
  local_3c = y;
  if (x_00 <= local_38 + 1) goto LAB_080ef68f;
LAB_080ef5f9:
  local_38 = local_38 + 1;
  x_00 = (frameset_desc->box).width;
  goto LAB_080ef3f0;
}



void __regparm3 draw_view_status(session *ses,document_view *doc_view,int active)

{
  terminal *term;
  
  term = ses->tab->term;
  draw_forms(term,doc_view);
  if (active != 0) {
    draw_searched(term,doc_view);
    draw_current_link(ses,doc_view);
  }
  return;
}



void __regparm3 draw_doc(session *ses,document_view *doc_view,int active)

{
  box *box;
  terminal *term;
  view_state *pvVar1;
  uri *uri;
  cache_entry *pcVar2;
  color_T *pcVar3;
  string *psVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  link *plVar10;
  int *piVar11;
  uchar *text;
  window *name;
  document *document;
  window *extraout_EDX;
  int iVar12;
  bool bVar13;
  char *local_78;
  link *local_38;
  string fragment;
  color_pair color;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if ((((ses == (session *)0x0) || (ses->tab == (window *)0x0)) ||
      (doc_view == (document_view *)0x0)) || (ses->tab->term == (terminal *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
    errline = 0xd0;
    elinks_internal((uchar *)"assertion ses && ses->tab && ses->tab->term && doc_view failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  iVar5 = (doc_view->box).width;
  name = ses->tab;
  term = name->term;
  if (iVar5 < 2) {
    return;
  }
  iVar6 = (doc_view->box).height;
  if (iVar6 < 2) {
    return;
  }
  if (active != 0) {
    if (ses->navigate_mode == NAVIGATE_CURSOR_ROUTING) {
      set_cursor(term,name->x,name->y,0);
      name = extraout_EDX;
    }
    else {
      set_cursor(term,iVar5 + (doc_view->box).x + -1,iVar6 + (doc_view->box).y + -1,1);
      ses->tab->x = (doc_view->box).x;
      name = (window *)(doc_view->box).y;
      *(window **)&ses->tab->y = name;
    }
  }
  local_78 = "document.colors.text";
  pcVar3 = get_opt_(config_options,(uchar *)name);
  color.foreground = *pcVar3;
  if (doc_view->document->height == 0) {
    local_78 = "document.colors.background";
    pcVar3 = get_opt_(config_options,(uchar *)0x0);
    color.background = *pcVar3;
  }
  else {
    color.background = doc_view->document->bgcolor;
  }
  pvVar1 = doc_view->vs;
  box = &doc_view->box;
  if (pvVar1 == (view_state *)0x0) {
    draw_box(term,box,' ',0,&color);
    return;
  }
  if ((doc_view->document != (document *)0x0) &&
     (doc_view->document->frame_desc != (frameset_desc *)0x0)) {
    draw_box(term,box,' ',0,&color);
    draw_frame_lines(term,doc_view->document->frame_desc,(doc_view->box).x,(doc_view->box).y,&color)
    ;
    if (pvVar1->current_link == -1) {
      pvVar1->current_link = 0;
      return;
    }
    return;
  }
  if (ses->navigate_mode == NAVIGATE_LINKWISE) {
    check_vs(doc_view);
  }
  else {
    local_78 = (char *)(ses->tab->x - (doc_view->box).x);
    plVar10 = get_link_at_coordinates(doc_view,(int)local_78,ses->tab->y - (doc_view->box).y);
    if (plVar10 != (link *)0x0) {
      iVar5 = doc_view->vs->current_link;
      if (iVar5 < 0) {
        local_38 = doc_view->document->links;
      }
      else {
        document = doc_view->document;
        if (iVar5 < document->nlinks) {
          local_38 = document->links;
          if (plVar10 == local_38 + iVar5) goto LAB_080ef979;
        }
        else {
          local_38 = document->links;
        }
      }
      doc_view->vs->current_link = ((int)((int)plVar10 - (int)local_38) >> 2) * -0x3b13b13b;
    }
  }
LAB_080ef979:
  if ((*(byte *)&pvVar1->field_0x2c & 2) != 0) goto LAB_080efa71;
  document = doc_view->document;
  uri = doc_view->vs->uri;
  if ((assert_failed == 0) &&
     (bVar13 = *(short *)&uri->field_0x34 == 0, assert_failed = ZEXT14(bVar13), bVar13)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
    errline = 0x35;
    elinks_internal((uchar *)"assertion uri->fragmentlen failed!",local_78);
  }
  psVar4 = init_string(&fragment);
  if (psVar4 == (string *)0x0) goto LAB_080efa71;
  psVar4 = add_uri_to_string(&fragment,uri,URI_FRAGMENT);
  if (psVar4 == (string *)0x0) {
    done_string(&fragment);
    goto LAB_080efa71;
  }
  decode_uri_string(&fragment);
  if (assert_failed == 0) {
    assert_failed = ZEXT14(fragment.length == 0);
    if (fragment.length == 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
      errline = 0x3d;
      elinks_internal((uchar *)"assertion fragment.length failed!");
      if (assert_failed != 0) goto LAB_080efa05;
    }
    assert_failed = ZEXT14(*fragment.source == '\0');
    if (*fragment.source == '\0') {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
      errline = 0x3e;
      elinks_internal((uchar *)"assertion *fragment.source failed!");
    }
  }
LAB_080efa05:
  iVar5 = find_tag(document,fragment.source + 1,fragment.length + -1);
  if (iVar5 == -1) {
    pcVar2 = document->cached;
    if ((assert_failed == 0) &&
       (assert_failed = ZEXT14(pcVar2 == (cache_entry *)0x0), pcVar2 == (cache_entry *)0x0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
      errline = 0x45;
      elinks_internal((uchar *)"assertion cached failed!");
    }
    if (((*(byte *)&pcVar2->field_0x5c & 8) != 0) || (pcVar2->cache_id != document->cache_id)) {
      done_string(&fragment);
      goto LAB_080efa71;
    }
    piVar11 = get_opt_(config_options,(uchar *)0xffffffff);
    if (*piVar11 != 0) {
      text = msg_text(ses->tab->term,(uchar *)"The requested fragment \"%s\" doesn\'t exist.",
                      fragment.source);
      info_box(ses->tab->term,MSGBOX_FREE_TEXT,(uchar *)"Missing fragment",ALIGN_CENTER,text);
    }
LAB_080efe6c:
    done_string(&fragment);
  }
  else {
    if (iVar5 < 0) {
      iVar5 = 0;
      goto LAB_080efe6c;
    }
    iVar6 = document->height + -1;
    if (iVar6 < iVar5) {
      iVar5 = iVar6;
    }
    done_string(&fragment);
    if (iVar5 == -2) goto LAB_080efa71;
  }
  *(byte *)&pvVar1->field_0x2c = *(byte *)&pvVar1->field_0x2c | 2;
  if (-1 < iVar5) {
    doc_view->vs->y = iVar5;
    set_link(doc_view);
  }
LAB_080efa71:
  iVar5 = pvVar1->x;
  iVar6 = pvVar1->y;
  if ((((doc_view->last_x == -1) || (iVar5 != doc_view->last_x)) || (doc_view->last_y != iVar6)) ||
     (((doc_view->search_word != (uchar **)0x0 &&
       (text = *doc_view->search_word, text != (uchar *)0x0)) && (*text != '\0')))) {
    doc_view->last_y = iVar6;
    doc_view->last_x = iVar5;
    draw_box(term,box,' ',0,&color);
    iVar12 = doc_view->document->height;
    if (iVar12 != 0) {
      iVar7 = pvVar1->y;
      if (iVar12 <= iVar7) {
        do {
          iVar7 = iVar7 - (doc_view->box).height;
          pvVar1->y = iVar7;
          piVar11 = &doc_view->document->height;
        } while (*piVar11 == iVar7 || *piVar11 < iVar7);
      }
      if (iVar7 < 0) {
        pvVar1->y = 0;
        iVar12 = 0;
        local_38 = (link *)0x0;
      }
      else {
        local_38 = (link *)pvVar1->y;
        iVar12 = 0;
        if (-1 < (int)local_38) {
          iVar12 = (int)local_38;
        }
      }
      if (((link *)iVar6 != local_38) && (ses->navigate_mode == NAVIGATE_LINKWISE)) {
        check_vs(doc_view);
      }
      document = doc_view->document;
      iVar6 = (int)local_38 + (doc_view->box).height;
      if (document->height < iVar6) {
        iVar6 = document->height;
      }
      if (iVar12 < iVar6) {
        iVar6 = iVar12 * 8;
        iVar7 = 0;
        if (-1 < iVar5) {
          iVar7 = iVar5;
        }
        do {
          iVar8 = iVar5 + (doc_view->box).width;
          piVar11 = (int *)((int)&document->data->chars + iVar6);
          iVar9 = piVar11[1];
          if (iVar8 <= iVar9) {
            iVar9 = iVar8;
          }
          if (0 < iVar9 - iVar7) {
            draw_line(term,(iVar7 - iVar5) + (doc_view->box).x,
                      (iVar12 - (int)local_38) + (doc_view->box).y,iVar9 - iVar7,
                      (screen_char *)(iVar7 * 8 + *piVar11));
            document = doc_view->document;
          }
          iVar12 = iVar12 + 1;
          iVar6 = iVar6 + 8;
          iVar8 = (int)local_38 + (doc_view->box).height;
          iVar9 = document->height;
          if (iVar8 <= document->height) {
            iVar9 = iVar8;
          }
        } while (iVar12 < iVar9);
      }
      draw_view_status(ses,doc_view,active);
      if (((doc_view->search_word != (uchar **)0x0) &&
          (text = *doc_view->search_word, text != (uchar *)0x0)) && (*text != '\0')) {
        doc_view->last_y = -1;
        doc_view->last_x = -1;
      }
    }
  }
  else {
    clear_link(term,doc_view);
    draw_view_status(ses,doc_view,active);
  }
  return;
}



void refresh_view(session *ses,document_view *doc_view,int frames)

{
  int *piVar1;
  window *pwVar2;
  terminal *term;
  document *pdVar3;
  location *plVar4;
  bool bVar5;
  window *pwVar6;
  int iVar7;
  document_view *pdVar8;
  int iVar9;
  document_view *doc_view_00;
  int iVar10;
  bool bVar11;
  document_view *local_20;
  
  pwVar2 = ses->tab;
  term = pwVar2->term;
  pwVar6 = get_tab_by_number(term,term->current_tab);
  if ((pwVar2 != pwVar6) || (draw_doc(ses,doc_view,1), frames == 0)) goto LAB_080effb1;
  if (assert_failed == 0) {
    if ((ses->doc_view == (document_view *)0x0) || (ses->doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
      errline = 0x135;
      elinks_internal((uchar *)"assertion ses && ses->doc_view && ses->doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080f010c;
    }
    else {
      assert_failed = 0;
    }
    pdVar3 = ses->doc_view->document;
    if ((pdVar3 != (document *)0x0) && (pdVar3->frame_desc != (frameset_desc *)0x0)) {
      local_20 = (document_view *)(ses->scrn_frames).next;
      iVar7 = 0;
      iVar10 = 1;
      if (local_20 != (document_view *)&ses->scrn_frames) {
        do {
          local_20->last_y = -1;
          iVar7 = iVar7 + 1;
          local_20->last_x = -1;
          local_20 = local_20->next;
        } while (local_20 != (document_view *)&ses->scrn_frames);
        iVar10 = 1;
        if (0 < iVar7) {
          iVar10 = iVar7;
        }
      }
      plVar4 = (ses->history).current;
      iVar7 = (plVar4->vs).current_link;
      iVar9 = 0;
      if (-1 < iVar7) {
        iVar9 = iVar7;
      }
      (plVar4->vs).current_link = iVar9 % iVar10;
      pdVar8 = current_frame(ses);
      iVar10 = 0;
      while (doc_view_00 = (document_view *)(ses->scrn_frames).next, doc_view_00 != local_20) {
        bVar5 = false;
        do {
          while( true ) {
            piVar1 = &doc_view_00->depth;
            bVar11 = *piVar1 != iVar10;
            if (bVar11) break;
            draw_doc(ses,doc_view_00,(uint)(pdVar8 == doc_view_00));
            doc_view_00 = doc_view_00->next;
            if (doc_view_00 == local_20) goto LAB_080f00c0;
          }
          doc_view_00 = doc_view_00->next;
          if (bVar11 && iVar10 <= *piVar1) {
            bVar5 = true;
          }
        } while (doc_view_00 != local_20);
LAB_080f00c0:
        if (!bVar5) break;
        iVar10 = iVar10 + 1;
      }
    }
  }
  else {
LAB_080f010c:
    assert_failed = 0;
  }
LAB_080effb1:
  print_screen_status(ses);
  return;
}



void draw_formatted(session *ses,int rerender)

{
  window *pwVar1;
  terminal *term;
  location *plVar2;
  window *pwVar3;
  document_view *pdVar4;
  int iVar5;
  uint no_cache;
  box box;
  
  if (assert_failed == 0) {
    if ((ses == (session *)0x0) || (ses->tab == (window *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
      errline = 0x157;
      elinks_internal((uchar *)"assertion ses && ses->tab failed!");
      if (assert_failed != 0) goto LAB_080f0228;
    }
    else {
      assert_failed = 0;
    }
    if (rerender != 0) {
      no_cache = rerender - 1;
      if ((no_cache & 2) == 0) {
        iVar5 = session_is_loading(ses);
        if (iVar5 != 0) {
          no_cache = no_cache | 2;
        }
      }
      render_document_frames(ses,no_cache);
      start_document_refreshes(ses);
    }
    pwVar1 = ses->tab;
    term = pwVar1->term;
    pwVar3 = get_tab_by_number(term,term->current_tab);
    if (pwVar1 == pwVar3) {
      pdVar4 = ses->doc_view;
      if ((pdVar4 != (document_view *)0x0) && (pdVar4->document != (document *)0x0)) {
        if ((pdVar4->vs == (view_state *)0x0) &&
           (plVar2 = (ses->history).current, plVar2 != (location *)0x0)) {
          pdVar4->vs = &plVar2->vs;
          pdVar4 = ses->doc_view;
        }
        pdVar4->last_y = -1;
        pdVar4->last_x = -1;
        refresh_view(ses,ses->doc_view,1);
        return;
      }
      term = ses->tab->term;
      box.width = term->width;
      box.x = 0;
      box.y = 1;
      if (box.width < 0) {
        box.width = 0;
      }
      iVar5 = term->height + -2;
      box.height = 0;
      if (-1 < iVar5) {
        box.height = iVar5;
      }
      draw_box(ses->tab->term,&box,' ',0,(color_pair *)0x0);
    }
  }
  else {
LAB_080f0228:
    assert_failed = 0;
  }
  return;
}



form_control * find_form_control(document *document,form_state *fs)

{
  void *pvVar1;
  form_control *pfVar2;
  list_head_elinks *plVar3;
  
  plVar3 = (list_head_elinks *)(document->forms).next;
  if (plVar3 == &document->forms) {
LAB_080f0318:
    plVar3 = (list_head_elinks *)0x0;
  }
  else {
    pvVar1 = plVar3[1].next;
    while (pvVar1 != (void *)fs->form_view->form_num) {
      plVar3 = (list_head_elinks *)plVar3->next;
      if (plVar3 == &document->forms) goto LAB_080f0318;
      pvVar1 = plVar3[1].next;
    }
  }
  pfVar2 = (form_control *)plVar3[4].prev;
  if (pfVar2 != (form_control *)&plVar3[4].prev) {
    do {
      if (((pfVar2->g_ctrl_num == fs->g_ctrl_num) && (fs->position == pfVar2->position)) &&
         (fs->type == pfVar2->type)) {
        return pfVar2;
      }
      pfVar2 = pfVar2->next;
    } while (pfVar2 != (form_control *)&plVar3[4].prev);
  }
  return (form_control *)0x0;
}



form * find_form_by_form_view(document *document,form_view *fv)

{
  int iVar1;
  form *pfVar2;
  
  pfVar2 = (form *)(document->forms).next;
  if (pfVar2 == (form *)&document->forms) {
LAB_080f0383:
    pfVar2 = (form *)0x0;
  }
  else {
    iVar1 = pfVar2->form_num;
    while (iVar1 != fv->form_num) {
      pfVar2 = pfVar2->next;
      if (pfVar2 == (form *)&document->forms) goto LAB_080f0383;
      iVar1 = pfVar2->form_num;
    }
  }
  return pfVar2;
}



uchar * __regparm3 get_form_label(form_control *fc)

{
  form_type fVar1;
  uchar *puVar2;
  bool bVar3;
  
  if ((assert_failed == 0) &&
     (bVar3 = fc->form == (form *)0x0, assert_failed = ZEXT14(bVar3), bVar3)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x751;
    elinks_internal((uchar *)"assertion fc->form failed!");
    fVar1 = fc->type;
  }
  else {
    fVar1 = fc->type;
  }
  if (FC_BUTTON < fVar1) {
    return (uchar *)0x0;
  }
                    // WARNING: Could not recover jumptable at 0x080f03c3. Too many branches
                    // WARNING: Treating indirect jump as call
  puVar2 = (uchar *)(*(code *)(&PTR_LAB_0810f7a0)[fc->type])();
  return puVar2;
}



uchar * __regparm3 _(uchar *msg,terminal *term)

{
  int cp_index;
  uchar *codeset;
  
  if ((msg != (uchar *)0x0) && (*msg != '\0')) {
    if (term != (terminal *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    msg = gettext(msg);
  }
  return msg;
}



void done_form_view(form_view *fv)

{
  mem_free(fv);
  return;
}



void done_form_state(form_state *fs)

{
  if (fs->value != (uchar *)0x0) {
    mem_free(fs->value);
    return;
  }
  return;
}



void done_submitted_value(submitted_value *sv)

{
  if (sv != (submitted_value *)0x0) {
    if (sv->value != (uchar *)0x0) {
      mem_free(sv->value);
    }
    if (sv->name != (uchar *)0x0) {
      mem_free(sv->name);
    }
    mem_free(sv);
    return;
  }
  return;
}



void done_submitted_value_list(list_head_elinks *list)

{
  submitted_value *psVar1;
  submitted_value *sv;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(list == (list_head_elinks *)0x0);
  if (list == (list_head_elinks *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x299;
    elinks_internal((uchar *)"assertion list failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  sv = (submitted_value *)list->next;
  while (sv != (submitted_value *)list) {
    psVar1 = sv->prev;
    sv->next->prev = psVar1;
    sv->prev->next = sv->next;
    done_submitted_value(sv);
    sv = psVar1->next;
  }
  return;
}



void link_form_menu_func(terminal *term,void *link_number_,void *ses_)

{
  int n;
  document_view *doc_view;
  
  n = *(int *)link_number_;
  mem_free(link_number_);
  if (assert_failed == 0) {
    assert_failed = ZEXT14(ses_ == (void *)0x0 || term == (terminal *)0x0);
    if (ses_ == (void *)0x0 || term == (terminal *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x80c;
      elinks_internal((uchar *)"assertion term && ses failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    doc_view = current_frame((session *)ses_);
    if (doc_view == (document_view *)0x0) {
      return;
    }
    if (assert_failed == 0) {
      if ((doc_view->vs == (view_state *)0x0) || (doc_view->document == (document *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
        errline = 0x812;
        elinks_internal((uchar *)"assertion doc_view->vs && doc_view->document failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
      }
      else {
        assert_failed = 0;
      }
      jump_to_link_number((session *)ses_,doc_view,n);
      refresh_view((session *)ses_,doc_view,0);
      return;
    }
  }
  assert_failed = 0;
  return;
}



frame_event_status submit_form(session *ses,document_view *doc_view,int do_reload)

{
  goto_current_link(ses,doc_view,do_reload);
  return FRAME_EVENT_OK;
}



void file_form_menu(terminal *term,void *path_,void *fs_)

{
  auto_complete_file(term,0,(uchar *)path_,set_file_form_state,file_form_menu,fs_);
  return;
}



void set_file_form_state(terminal *term,void *filename_,void *fs_)

{
  size_t sVar1;
  
  if (*(void **)((int)fs_ + 0x10) != (void *)0x0) {
    mem_free(*(void **)((int)fs_ + 0x10));
  }
  *(void **)((int)fs_ + 0x10) = filename_;
  sVar1 = strlen((char *)filename_);
  *(size_t *)((int)fs_ + 0x14) = sVar1;
  redraw_terminal(term);
  return;
}



void __regparm3 fixup_select_state(form_control *fc,form_state *fs)

{
  uchar **ppuVar1;
  int iVar2;
  uchar *src;
  int iVar3;
  int iVar4;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(fs == (form_state *)0x0 || fc == (form_control *)0x0);
  if (fs == (form_state *)0x0 || fc == (form_control *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x65;
    elinks_internal((uchar *)"assertion fc && fs failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  iVar3 = fs->state;
  if (iVar3 < 0) {
    src = fs->value;
    iVar4 = fc->nvalues;
  }
  else {
    iVar4 = fc->nvalues;
    if (iVar3 < iVar4) {
      src = fs->value;
      iVar3 = strcmp((char *)fc->values[iVar3],(char *)src);
      if (iVar3 == 0) {
        return;
      }
    }
    else {
      src = fs->value;
    }
  }
  if (0 < iVar4) {
    iVar3 = 0;
    ppuVar1 = fc->values;
    do {
      iVar2 = strcmp((char *)ppuVar1[iVar3],(char *)src);
      if (iVar2 == 0) {
        fs->state = iVar3;
        return;
      }
      iVar3 = iVar3 + 1;
    } while (iVar3 < iVar4);
  }
  fs->state = 0;
  if (src != (uchar *)0x0) {
    mem_free(src);
  }
  src = "";
  if (fc->nvalues != 0) {
    src = *fc->values;
  }
  src = stracpy(src);
  fs->value = src;
  return;
}



submitted_value *
init_submitted_value(uchar *name,uchar *value,form_type type,form_control *fc,int position)

{
  submitted_value *p;
  uchar *puVar1;
  submitted_value *psVar2;
  
  p = (submitted_value *)mem_alloc(0x1c);
  psVar2 = p;
  if (p != (submitted_value *)0x0) {
    puVar1 = stracpy(value);
    p->value = puVar1;
    if (puVar1 != (uchar *)0x0) {
      puVar1 = stracpy(name);
      p->name = puVar1;
      if (puVar1 != (uchar *)0x0) {
        p->type = type;
        p->form_control = fc;
        p->position = position;
        return p;
      }
      mem_free(p->value);
    }
    psVar2 = (submitted_value *)0x0;
    mem_free(p);
  }
  return psVar2;
}



uchar * encode_crlf(submitted_value *sv)

{
  uchar character;
  string *psVar1;
  uchar *puVar2;
  int iVar3;
  string newtext;
  
  if (assert_failed == 0) {
    if ((sv == (submitted_value *)0x0) || (sv->value == (uchar *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x324;
      elinks_internal((uchar *)"assertion sv && sv->value failed!");
      if (assert_failed != 0) goto LAB_080f0ae0;
    }
    else {
      assert_failed = 0;
    }
    psVar1 = init_string(&newtext);
    if (psVar1 != (string *)0x0) {
      puVar2 = sv->value;
      character = *puVar2;
      if (character != '\0') {
        iVar3 = 0;
        do {
          while (character == '\r') {
            if (puVar2[iVar3 + 1] == '\n') goto LAB_080f0a66;
LAB_080f0a7e:
            iVar3 = iVar3 + 1;
            add_crlf_to_string(&newtext);
            puVar2 = sv->value;
            character = puVar2[iVar3];
            if (character == '\0') {
              return newtext.source;
            }
          }
          if (character == '\n') goto LAB_080f0a7e;
          add_char_to_string(&newtext,character);
          puVar2 = sv->value;
LAB_080f0a66:
          iVar3 = iVar3 + 1;
          character = puVar2[iVar3];
        } while (character != '\0');
      }
      return newtext.source;
    }
  }
  else {
LAB_080f0ae0:
    assert_failed = 0;
  }
  return (uchar *)0x0;
}



void * __regparm3 mem_align_alloc__(void **ptr,size_t old,size_t new,size_t objsize,size_t mask)

{
  void *pvVar1;
  uint uVar2;
  size_t size;
  uint uVar3;
  int iVar4;
  
  uVar2 = mask + new & ~mask;
  uVar3 = mask + old & ~mask;
  if (uVar3 < uVar2) {
    size = uVar2 * objsize;
    pvVar1 = mem_realloc(*ptr,size);
    if (pvVar1 == (void *)0x0) {
      return (void *)0x0;
    }
    iVar4 = uVar3 * objsize;
    *ptr = pvVar1;
    memset((void *)((int)pvVar1 + iVar4),0,size - iVar4);
  }
  return *ptr;
}



string * __regparm3 add_bytes_to_string__(string *string,uchar *bytes,int length)

{
  int iVar1;
  void *pvVar2;
  
  if (assert_failed == 0) {
    if (((bytes == (uchar *)0x0) || (string == (string *)0x0)) || (length < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080f0b9e;
    }
    else {
      assert_failed = 0;
    }
    if (length != 0) {
      iVar1 = length + string->length;
      pvVar2 = mem_align_alloc__((void **)string,string->length,iVar1 + 1,1,0xff);
      if (pvVar2 == (void *)0x0) {
        string = (string *)0x0;
      }
      else {
        memcpy(string->source + string->length,bytes,length);
        string->source[iVar1] = '\0';
        string->length = iVar1;
      }
    }
  }
  else {
LAB_080f0b9e:
    assert_failed = 0;
    string = (string *)0x0;
  }
  return string;
}



void __regparm3 init_form_state(document_view *doc_view,form_control *fc,form_state *fs)

{
  int from;
  int to;
  uchar *chars;
  size_t charslen;
  conv_table *convert_table;
  uchar *__s;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(fs == (form_state *)0x0 || fc == (form_control *)0x0);
  if (fs == (form_state *)0x0 || fc == (form_control *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0xa3;
    elinks_internal((uchar *)"assertion fc && fs failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  from = doc_view->document->cp;
  to = get_terminal_codepage(doc_view->session->tab->term);
  if (fs->value != (uchar *)0x0) {
    mem_free(fs->value);
  }
  fs->value = (uchar *)0x0;
  if (FC_HIDDEN < fc->type) {
    return;
  }
  switch(fc->type) {
  case FC_TEXT:
  case FC_PASSWORD:
    chars = get_form_history_value(fc->form->action,fc->name);
    __s = (uchar *)0x0;
    if (chars != (uchar *)0x0) {
      chars = get_form_history_value(fc->form->action,fc->name);
      __s = stracpy(chars);
    }
    fs->value = __s;
    if (__s == (uchar *)0x0) goto switchD_080f0d43_caseD_3;
LAB_080f0e51:
    __s = (uchar *)strlen((char *)__s);
    break;
  case FC_FILE:
    chars = stracpy("");
    fs->state = 0;
    fs->value = chars;
    goto LAB_080f0dfe;
  case FC_TEXTAREA:
switchD_080f0d43_caseD_3:
    chars = fc->default_value;
    charslen = strlen((char *)chars);
    convert_table = get_translation_table(from,to);
    __s = convert_string_elinks
                    (convert_table,chars,charslen,to,CSM_FORM,&fs->state,
                     (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
    fs->value = __s;
    if (__s != (uchar *)0x0) goto LAB_080f0e51;
    break;
  case FC_CHECKBOX:
  case FC_RADIO:
    fs->state = fc->default_state;
  default:
    chars = stracpy(fc->default_value);
    fs->value = chars;
    return;
  case FC_SELECT:
    chars = fc->default_value;
    charslen = strlen((char *)chars);
    convert_table = get_translation_table(from,to);
    chars = convert_string_elinks
                      (convert_table,chars,charslen,to,CSM_FORM,&fs->state,
                       (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
    fs->value = chars;
    fs->state = fc->default_state;
    fixup_select_state(fc,fs);
    return;
  }
  *(uchar **)&fs->state = __s;
  if (fc->type == FC_TEXTAREA) {
    fs->state_cell = 0;
  }
LAB_080f0dfe:
  fs->vpos = 0;
  return;
}



form_view * find_form_view_in_vs(view_state *vs,int form_num)

{
  form_view *pfVar1;
  form_view *pfVar2;
  
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(vs == (view_state *)0x0), vs == (view_state *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x134;
    elinks_internal((uchar *)"assertion vs failed!");
  }
  pfVar1 = (form_view *)(vs->forms).next;
  while( true ) {
    if ((form_view *)&vs->forms == pfVar1) {
      pfVar2 = (form_view *)mem_calloc(1,0xc);
      pfVar2->form_num = form_num;
      pfVar1 = (form_view *)(vs->forms).next;
      pfVar2->prev = (form_view *)&vs->forms;
      pfVar2->next = pfVar1;
      *(form_view **)&(vs->forms).next = pfVar2;
      pfVar2->next->prev = pfVar2;
      return pfVar2;
    }
    if (pfVar1->form_num == form_num) break;
    pfVar1 = pfVar1->next;
  }
  return pfVar1;
}



form_view * find_form_view(document_view *doc_view,form *form)

{
  form_view *pfVar1;
  
  pfVar1 = find_form_view_in_vs(doc_view->vs,form->form_num);
  return pfVar1;
}



form_state * find_form_state(document_view *doc_view,form_control *fc)

{
  view_state *pvVar1;
  form_view *pfVar2;
  int iVar3;
  form_state *fs;
  form_state *pfVar4;
  byte bVar5;
  
  bVar5 = 0;
  if (assert_failed == 0) {
    if (((doc_view == (document_view *)0x0) || (fc == (form_control *)0x0)) ||
       (doc_view->vs == (view_state *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0xeb;
      elinks_internal((uchar *)"assertion doc_view && doc_view->vs && fc failed!");
      if (assert_failed != 0) goto LAB_080f0fc6;
    }
    else {
      assert_failed = 0;
    }
    pvVar1 = doc_view->vs;
    iVar3 = fc->g_ctrl_num;
    if (iVar3 < pvVar1->form_info_len) {
      fs = pvVar1->form_info;
    }
    else {
      fs = (form_state *)
           mem_align_alloc__(&pvVar1->form_info,pvVar1->form_info_len,iVar3 + 1U,0x24,0);
      if (fs == (form_state *)0x0) {
        return (form_state *)0x0;
      }
      pvVar1->form_info = fs;
      pvVar1->form_info_len = iVar3 + 1U;
    }
    fs = fs + iVar3;
    if (((fs->form_view == (form_view *)0x0) || (fs->form_view->form_num != fc->form->form_num)) ||
       ((fs->g_ctrl_num != fc->g_ctrl_num ||
        ((fs->position != fc->position || (fs->type != fc->type)))))) {
      if (fs->value != (uchar *)0x0) {
        mem_free(fs->value);
      }
      iVar3 = 9;
      pfVar4 = fs;
      while (iVar3 != 0) {
        iVar3 = iVar3 + -1;
        pfVar4->form_view = (form_view *)0x0;
        pfVar4 = (form_state *)((int)pfVar4 + (uint)bVar5 * -8 + 4);
      }
      pfVar2 = find_form_view_in_vs(doc_view->vs,fc->form->form_num);
      fs->form_view = pfVar2;
      fs->g_ctrl_num = fc->g_ctrl_num;
      fs->position = fc->position;
      fs->type = fc->type;
      init_form_state(doc_view,fc,fs);
      return fs;
    }
  }
  else {
LAB_080f0fc6:
    assert_failed = 0;
    fs = (form_state *)0x0;
  }
  return fs;
}



frame_event_status field_op(session *ses,document_view *doc_view,link *link,term_event *ev)

{
  char cVar1;
  uchar uVar2;
  ushort uVar3;
  action_id_T aVar4;
  form_state *fs;
  frame_event_status fVar5;
  size_t __n;
  ushort **ppuVar6;
  char *pcVar7;
  byte *pbVar8;
  byte *__dest;
  int *piVar9;
  link *plVar10;
  int to;
  uchar *seq;
  uchar *end;
  ushort *puVar11;
  uint uVar12;
  byte bVar13;
  uint utf8;
  size_t sVar14;
  char *__src;
  uchar *name;
  form_control *fc;
  byte *start;
  byte *__src_00;
  uchar *puVar15;
  byte bVar16;
  byte *local_20 [4];
  
  bVar16 = 0;
  bVar13 = *(byte *)&ses->tab->term->field_0x38;
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  if (((doc_view == (document_view *)0x0) || (ev == (term_event *)0x0)) || (link == (link *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x5b7;
    elinks_internal((uchar *)"assertion ses && doc_view && link && ev failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  bVar13 = bVar13 >> 1 & 1;
  if (link->type < LINK_BUTTON) {
    assert_failed = 1;
    fc = (form_control *)0x0;
LAB_080f11fc:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x5bb;
    elinks_internal((uchar *)"assertion fc != NULL failed: link has no form control");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  else {
    fc = (form_control *)link->data;
    assert_failed = ZEXT14(fc == (form_control *)0x0);
    if (fc == (form_control *)0x0) goto LAB_080f11fc;
  }
  if (fc->mode == FORM_MODE_DISABLED) {
    return FRAME_EVENT_IGNORED;
  }
  if (ev->ev != EVENT_KBD) {
    return FRAME_EVENT_IGNORED;
  }
  if (ses->insert_mode == INSERT_MODE_OFF) {
    return FRAME_EVENT_IGNORED;
  }
  aVar4 = kbd_action(KEYMAP_EDIT,ev,(int *)0x0);
  fs = find_form_state(doc_view,fc);
  if ((fs == (form_state *)0x0) || (start = fs->value, start == (byte *)0x0)) {
    return FRAME_EVENT_OK;
  }
  utf8 = (uint)bVar13;
  switch(aVar4) {
  default:
    if ((0x1f < *(int *)&ev->info) && (*(int *)((int)&ev->info + 4) == 0)) {
      if (fc->mode != FORM_MODE_NORMAL) {
        return FRAME_EVENT_OK;
      }
      to = get_terminal_codepage(ses->tab->term);
      seq = u2cp_(*(unicode_val_T *)&ev->info,to,NBSP_MODE_ASCII);
      utf8 = 0xffffffff;
      end = seq;
      do {
        if (utf8 == 0) break;
        utf8 = utf8 - 1;
        uVar2 = *end;
        end = end + (uint)bVar16 * -2 + 1;
      } while (uVar2 != '\0');
      to = ~utf8 - 1;
      uVar12 = 0xffffffff;
      end = fs->value;
      do {
        if (uVar12 == 0) break;
        uVar12 = uVar12 - 1;
        uVar2 = *end;
        end = end + (uint)bVar16 * -2 + 1;
      } while (uVar2 != '\0');
      utf8 = (~utf8 - 2) + ~uVar12;
      if ((uint)fc->maxlength <= utf8 && utf8 != fc->maxlength) {
        return FRAME_EVENT_OK;
      }
      end = insert_in_string(&fs->value,fs->state,seq,to);
      if (end == (uchar *)0x0) {
        return FRAME_EVENT_OK;
      }
      fs->state = fs->state + to;
      if (fc->type != FC_TEXTAREA) {
        return FRAME_EVENT_REFRESH;
      }
      fs->state_cell = 0;
      return FRAME_EVENT_REFRESH;
    }
    break;
  case 2:
    if ((fc->type == FC_FILE) && (fc->mode == FORM_MODE_NORMAL)) {
      file_form_menu(ses->tab->term,start,fs);
      return FRAME_EVENT_REFRESH;
    }
    break;
  case 5:
    if (fc->mode == FORM_MODE_NORMAL) {
      end = (uchar *)fs->state;
      if (end == (uchar *)0x0) {
        return FRAME_EVENT_OK;
      }
      if (bVar13 == 0) {
        end = end + (int)start;
        utf8 = 0xffffffff;
        seq = end;
        do {
          if (utf8 == 0) break;
          utf8 = utf8 - 1;
          uVar2 = *seq;
          seq = seq + (uint)bVar16 * -2 + 1;
        } while (uVar2 != '\0');
        memmove(end + -1,end,~utf8);
        fs->state = fs->state + -1;
        return FRAME_EVENT_REFRESH;
      }
      seq = utf8_prevchar(start + (int)end,1,start);
      *(uchar **)&fs->state = seq + -(int)fs->value;
      if (end == seq + -(int)fs->value) {
        return FRAME_EVENT_REFRESH;
      }
      if (fc->type == FC_TEXTAREA) {
        fs->state_cell = 0;
      }
      utf8 = 0xffffffff;
      puVar15 = end + (int)fs->value;
      do {
        if (utf8 == 0) break;
        utf8 = utf8 - 1;
        uVar2 = *puVar15;
        puVar15 = puVar15 + (uint)bVar16 * -2 + 1;
      } while (uVar2 != '\0');
      memmove(seq,end + (int)fs->value,~utf8);
      return FRAME_EVENT_REFRESH;
    }
    break;
  case 6:
    if (fc->type == FC_TEXTAREA) {
      fVar5 = textarea_op_bob(fs,fc,utf8);
      fs->state_cell = 0;
      return fVar5;
    }
    fs->state = 0;
    return FRAME_EVENT_REFRESH;
  case 7:
    if (ses->insert_mode == INSERT_MODE_ON) {
      ses->insert_mode = INSERT_MODE_OFF;
      return FRAME_EVENT_REFRESH;
    }
    break;
  case 8:
    set_clipboard_text(start);
    return FRAME_EVENT_OK;
  case 9:
    set_clipboard_text(start);
    if (fc->mode == FORM_MODE_NORMAL) {
      *fs->value = '\0';
    }
    fs->state = 0;
    if (fc->type != FC_TEXTAREA) {
      return FRAME_EVENT_REFRESH;
    }
    fs->state_cell = 0;
    return FRAME_EVENT_REFRESH;
  case 10:
    if (fc->mode == FORM_MODE_NORMAL) {
      __n = strlen((char *)start);
      to = fs->state;
      if ((int)__n <= to) {
        return FRAME_EVENT_OK;
      }
      if (bVar13 != 0) {
        __src_00 = start + to;
        local_20[0] = __src_00;
        utf8_to_unicode(local_20,start + __n);
        if (__src_00 == local_20[0]) {
          return FRAME_EVENT_REFRESH;
        }
        memmove(__src_00,local_20[0],(size_t)(start + __n + (1 - (int)local_20[0])));
        return FRAME_EVENT_REFRESH;
      }
      memmove(start + to,start + to + 1,__n - to);
      return FRAME_EVENT_REFRESH;
    }
    break;
  case 0xb:
    if (fc->type == FC_TEXTAREA) {
      fVar5 = textarea_op_down(fs,fc,utf8);
      return fVar5;
    }
    break;
  case 0xc:
    if (fc->type == FC_TEXTAREA) {
      fVar5 = textarea_op_end(fs,fc,utf8);
      return fVar5;
    }
    __n = strlen((char *)start);
    fs->state = __n;
    return FRAME_EVENT_REFRESH;
  case 0xd:
    if (fc->type == FC_TEXTAREA) {
      fVar5 = textarea_op_eob(fs,fc,utf8);
      return fVar5;
    }
    __n = strlen((char *)start);
    fs->state = __n;
    return FRAME_EVENT_REFRESH;
  case 0xe:
    if (fc->type == FC_TEXTAREA) {
      fVar5 = textarea_op_enter(fs,fc,utf8);
      return fVar5;
    }
    to = has_form_submit(fc->form);
    if (((to == 0) || (piVar9 = get_opt_(config_options,name), *piVar9 != 0)) &&
       (plVar10 = goto_current_link(ses,doc_view,0), plVar10 == (link *)0x0)) {
      return FRAME_EVENT_REFRESH;
    }
    if (ses->insert_mode != INSERT_MODE_ON) {
      return FRAME_EVENT_OK;
    }
    ses->insert_mode = INSERT_MODE_OFF;
    return FRAME_EVENT_OK;
  case 0xf:
    if (fc->type == FC_TEXTAREA) {
      fVar5 = textarea_op_home(fs,fc,utf8);
      return fVar5;
    }
    fs->state = 0;
    return FRAME_EVENT_REFRESH;
  case 0x10:
    if (fc->mode == FORM_MODE_NORMAL) {
      __n = fs->state;
      if ((int)__n < 1) {
        return FRAME_EVENT_OK;
      }
      pbVar8 = (byte *)memrchr(start,10,__n);
      __src_00 = start;
      if (pbVar8 != (byte *)0x0) {
        __src_00 = start + (__n - 1);
        if (start + (__n - 1) != pbVar8) {
          __src_00 = pbVar8 + 1;
        }
      }
      sVar14 = strlen((char *)(start + __n));
      memmove(__src_00,start + __n,sVar14 + 1);
      *(byte **)&fs->state = __src_00 + -(int)fs->value;
      if (bVar13 == 0) {
        return FRAME_EVENT_REFRESH;
      }
      if (fc->type != FC_TEXTAREA) {
        return FRAME_EVENT_REFRESH;
      }
      fs->state_cell = 0;
      return FRAME_EVENT_REFRESH;
    }
    break;
  case 0x11:
    if (fc->mode == FORM_MODE_NORMAL) {
      start = start + fs->state;
      bVar13 = *start;
      if (bVar13 == 0) {
        return FRAME_EVENT_OK;
      }
      pcVar7 = strchr((char *)start,10);
      if (pcVar7 == (char *)0x0) {
        *start = 0;
        return FRAME_EVENT_REFRESH;
      }
      __src = pcVar7 + 1;
      if (bVar13 != 10) {
        __src = pcVar7;
      }
      utf8 = 0xffffffff;
      pcVar7 = __src;
      do {
        if (utf8 == 0) break;
        utf8 = utf8 - 1;
        cVar1 = *pcVar7;
        pcVar7 = pcVar7 + (uint)bVar16 * -2 + 1;
      } while (cVar1 != '\0');
      memmove(start,__src,~utf8);
      return FRAME_EVENT_REFRESH;
    }
    break;
  case 0x12:
    if (fc->mode == FORM_MODE_NORMAL) {
      to = fs->state;
      if (to < 1) {
        return FRAME_EVENT_OK;
      }
      __src_00 = start + to;
      if (start < __src_00) {
        ppuVar6 = __ctype_b_loc();
        __dest = __src_00;
        do {
          bVar13 = __dest[-1];
          pbVar8 = __dest + -1;
          uVar3 = (*ppuVar6)[bVar13];
          if ((uVar3 & 0x2000) == 0) {
            if (start < __dest) goto LAB_080f1792;
            goto LAB_080f1797;
          }
          __dest = pbVar8;
        } while (start < pbVar8);
      }
      else {
        bVar13 = *__src_00;
        pbVar8 = __src_00;
      }
LAB_080f179a:
      __dest = pbVar8;
      if (bVar13 == 10) {
        __dest = start + to + -1;
        if (start + to + -1 != pbVar8) {
          __dest = pbVar8 + 1;
        }
      }
      __n = strlen((char *)__src_00);
      memmove(__dest,__src_00,__n + 1);
      *(byte **)&fs->state = __dest + -(int)fs->value;
      return FRAME_EVENT_REFRESH;
    }
    break;
  case 0x13:
    if (fc->type == FC_TEXTAREA) {
      fVar5 = textarea_op_left(fs,fc,utf8);
      return fVar5;
    }
    if (bVar13 != 0) {
      end = utf8_prevchar(start + fs->state,1,start);
      *(uchar **)&fs->state = end + -(int)fs->value;
      return FRAME_EVENT_REFRESH;
    }
    uVar12 = fs->state - 1;
    if (-1 < (int)uVar12) {
      utf8 = uVar12;
    }
    fs->state = utf8;
    return FRAME_EVENT_REFRESH;
  case 0x14:
    to = fs->state;
    if (to < 1) {
      return FRAME_EVENT_REFRESH;
    }
    ppuVar6 = __ctype_b_loc();
    do {
      to = to + -1;
      puVar11 = *ppuVar6;
      if ((*(byte *)((int)puVar11 + (uint)start[to] * 2 + 1) & 0x20) == 0) {
        to = fs->state;
        if (to < 1) {
          return FRAME_EVENT_REFRESH;
        }
        while( true ) {
          to = to + -1;
          if ((*(byte *)((int)puVar11 + (uint)start[to] * 2 + 1) & 0x20) != 0) {
            return FRAME_EVENT_REFRESH;
          }
          fs->state = to;
          if (to < 1) break;
          puVar11 = *ppuVar6;
        }
        return FRAME_EVENT_REFRESH;
      }
      fs->state = to;
    } while (0 < to);
    return FRAME_EVENT_REFRESH;
  case 0x15:
    ppuVar6 = __ctype_b_loc();
    to = fs->state;
    while( true ) {
      if ((*(byte *)((int)*ppuVar6 + (uint)start[to] * 2 + 1) & 0x20) == 0) break;
      fs->state = to + 1;
      to = to + 1;
    }
    if (start[to] == 0) {
      return FRAME_EVENT_REFRESH;
    }
    end = fs->value + to;
    do {
      to = to + 1;
      fs->state = to;
      start = end + 1;
      if (*start == 0) {
        if ((*(byte *)((int)*ppuVar6 + 1) & 0x20) == 0) {
          return FRAME_EVENT_REFRESH;
        }
        break;
      }
      end = end + 1;
    } while ((*(byte *)((int)*ppuVar6 + (uint)*start * 2 + 1) & 0x20) == 0);
    end = fs->value + to;
    do {
      to = to + 1;
      fs->state = to;
      start = end + 1;
      end = end + 1;
    } while ((*(byte *)((int)*ppuVar6 + (uint)*start * 2 + 1) & 0x20) != 0);
    return FRAME_EVENT_REFRESH;
  case 0x17:
    if (fc->mode == FORM_MODE_NORMAL) {
      if (fc->type != FC_TEXTAREA) {
        return FRAME_EVENT_REFRESH;
      }
      textarea_edit(0,ses->tab->term,fs,doc_view,link);
      return FRAME_EVENT_REFRESH;
    }
    break;
  case 0x18:
    if ((fc->mode != FORM_MODE_NORMAL) || (end = get_clipboard_text(), end == (uchar *)0x0)) {
      return FRAME_EVENT_REFRESH;
    }
    __n = strlen((char *)end);
    if ((int)__n <= fc->maxlength) {
      seq = (uchar *)mem_realloc(fs->value,__n + 1);
      if (seq != (uchar *)0x0) {
        fs->value = seq;
        memmove(seq,end,__n + 1);
        utf8 = 0xffffffff;
        seq = fs->value;
        do {
          if (utf8 == 0) break;
          utf8 = utf8 - 1;
          uVar2 = *seq;
          seq = seq + (uint)bVar16 * -2 + 1;
        } while (uVar2 != '\0');
        fs->state = ~utf8 - 1;
        if ((bVar13 != 0) && (fc->type == FC_TEXTAREA)) {
          fs->state_cell = 0;
        }
      }
    }
    mem_free(end);
    return FRAME_EVENT_REFRESH;
  case 0x1a:
    redraw_terminal_cls(ses->tab->term);
    return FRAME_EVENT_OK;
  case 0x1b:
    if (fc->type == FC_TEXTAREA) {
      fVar5 = textarea_op_right(fs,fc,utf8);
      return fVar5;
    }
    if (bVar13 != 0) {
      local_20[0] = start + fs->state;
      end = (uchar *)__rawmemchr(local_20[0],0);
      utf8_to_unicode(local_20,end);
      *(byte **)&fs->state = local_20[0] + -(int)fs->value;
      return FRAME_EVENT_REFRESH;
    }
    __n = strlen((char *)start);
    sVar14 = fs->state + 1;
    if ((int)sVar14 < (int)__n) {
      __n = sVar14;
    }
    fs->state = __n;
    return FRAME_EVENT_REFRESH;
  case 0x1d:
    if (fc->type == FC_TEXTAREA) {
      fVar5 = textarea_op_up(fs,fc,utf8);
      return fVar5;
    }
  }
  return FRAME_EVENT_IGNORED;
LAB_080f1792:
  if ((uVar3 & 0x2000) != 0) goto LAB_080f1797;
  pbVar8 = __dest + -1;
  if (pbVar8 <= start) goto LAB_080f179a;
  bVar13 = __dest[-2];
  uVar3 = (*ppuVar6)[bVar13];
  __dest = pbVar8;
  goto LAB_080f1792;
LAB_080f1797:
  bVar13 = *__dest;
  pbVar8 = __dest;
  goto LAB_080f179a;
}



void do_reset_form(document_view *doc_view,form *form)

{
  form_state *fs;
  form_control *fc;
  
  if (assert_failed == 0) {
    if ((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x4ac;
      elinks_internal((uchar *)"assertion doc_view && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080f1d78;
    }
    else {
      assert_failed = 0;
    }
    fc = (form_control *)(form->items).next;
    if (fc != (form_control *)&form->items) {
      do {
        fs = find_form_state(doc_view,fc);
        if (fs != (form_state *)0x0) {
          init_form_state(doc_view,fc,fs);
        }
        fc = fc->next;
      } while (fc != (form_control *)&form->items);
      return;
    }
  }
  else {
LAB_080f1d78:
    assert_failed = 0;
  }
  return;
}



void draw_form_entry(terminal *term,document_view *doc_view,link *link)

{
  uchar uVar1;
  form_type fVar2;
  uchar *puVar3;
  form_state *fs;
  int x;
  size_t sVar4;
  int iVar5;
  uint uVar6;
  int y;
  size_t sVar7;
  int y_00;
  unicode_val_T c;
  size_t sVar8;
  int x_00;
  int x_01;
  int y_01;
  uchar *end;
  int iVar9;
  int iVar10;
  byte bVar11;
  size_t local_40;
  uchar *local_3c;
  form_control *local_38;
  int local_34;
  int local_30;
  uchar *local_28;
  uchar *local_24;
  uchar *local_20 [4];
  
  bVar11 = 0;
  if (assert_failed == 0) {
    if ((((doc_view == (document_view *)0x0) || (term == (terminal *)0x0)) ||
        (doc_view->document == (document *)0x0)) ||
       ((link == (link *)0x0 || (doc_view->vs == (view_state *)0x0)))) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x18a;
      elinks_internal((uchar *)
                      "assertion term && doc_view && doc_view->document && doc_view->vs && link failed!"
                     );
      if (assert_failed != 0) goto LAB_080f1ec8;
    }
    if (link->type < LINK_BUTTON) {
      assert_failed = 1;
      local_38 = (form_control *)0x0;
LAB_080f1e81:
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x18e;
      elinks_internal((uchar *)"assertion fc != NULL failed: link %d has no form control",
                      ((int)((int)link - (int)doc_view->document->links) >> 2) * -0x3b13b13b);
      if (assert_failed != 0) goto LAB_080f1ec8;
    }
    else {
      local_38 = (form_control *)link->data;
      assert_failed = ZEXT14(local_38 == (form_control *)0x0);
      if (local_38 == (form_control *)0x0) goto LAB_080f1e81;
    }
    fs = find_form_state(doc_view,local_38);
    if (fs != (form_state *)0x0) {
      iVar9 = (doc_view->box).x;
      x_01 = iVar9 - doc_view->vs->x;
      iVar5 = (doc_view->box).y;
      y_01 = iVar5 - doc_view->vs->y;
      if (local_38->type < FC_SUBMIT) {
        switch(local_38->type) {
        default:
          if (link->npoints != 0) {
            y_01 = y_01 + link->points->y;
            if ((iVar5 <= y_01) && (y_01 < iVar5 + (doc_view->box).height)) {
              x_01 = x_01 + link->points->x;
              if ((*(byte *)&term->field_0x38 & 2) != 0) {
                do {
                  local_24 = fs->value;
                  if (local_24 == (uchar *)0x0) {
                    local_24 = "";
                  }
                  sVar4 = strlen((char *)local_24);
                  sVar7 = fs->state;
                  if ((int)sVar7 < 0) {
                    fs->state = 0;
                    sVar7 = 0;
                  }
                  else {
                    if ((int)sVar4 < (int)sVar7) {
                      fs->state = sVar4;
                      sVar7 = sVar4;
                    }
                  }
                  sVar8 = fs->vpos;
                  if ((int)sVar8 < 0) {
                    fs->vpos = 0;
                    sVar8 = 0;
                  }
                  else {
                    if ((int)sVar7 < (int)sVar8) {
                      fs->vpos = sVar7;
                      sVar8 = sVar7;
                    }
                  }
                  end = local_24 + sVar4;
                  local_34 = local_38->size;
                  local_30 = 0;
                  local_3c = (uchar *)0x0;
                  iVar9 = local_30;
                  local_24 = local_24 + sVar8;
                  while (local_30 = iVar9, puVar3 = local_24, local_30 < local_34) {
                    c = utf8_to_unicode(&local_24,end);
                    if (c == 0xfffffffd) {
                      c = 0x5f;
                    }
                    else {
                      if (local_38->type == FC_PASSWORD) {
                        c = 0x2a;
                      }
                    }
                    iVar5 = unicode_to_cell(c);
                    iVar9 = local_30 + iVar5;
                    local_34 = local_38->size;
                    if (local_34 < iVar9) {
LAB_080f234e:
                      if (0 < iVar5) {
                        x = 0;
                        do {
                          y = (doc_view->box).x;
                          x_00 = x + local_30 + x_01;
                          if (((y <= x_00) && (x_00 < y + (doc_view->box).width)) &&
                             (local_30 + x < local_34)) {
                            draw_char_data(term,x_00,y_01,0x20);
                            local_34 = local_38->size;
                          }
                          x = x + 1;
                        } while (x < iVar5);
                      }
                    }
                    else {
                      x_00 = local_30 + x_01;
                      x = (doc_view->box).x;
                      if ((x_00 < x) || (x + (doc_view->box).width < iVar5 + x_00)) {
                        local_3c = puVar3;
                        goto LAB_080f234e;
                      }
                      draw_char_data(term,x_00,y_01,c);
                      if (iVar5 < 2) {
                        local_3c = puVar3;
                        local_34 = local_38->size;
                      }
                      else {
                        x = 1;
                        do {
                          y = x + x_00;
                          x = x + 1;
                          draw_char_data(term,y,y_01,0xfffffffd);
                        } while (x < iVar5);
                        local_34 = local_38->size;
                        local_3c = puVar3;
                      }
                    }
                  }
                  if (local_3c == (uchar *)0x0) {
                    return;
                  }
                  if (fs->value == (uchar *)0x0) {
                    return;
                  }
                  local_28 = fs->value + fs->state;
                  if (local_28 <= local_3c) {
                    return;
                  }
                  iVar9 = local_38->size;
                  fVar2 = local_38->type;
                  c = utf8_to_unicode(&local_28,end);
                  local_28 = utf8_step_backward(local_28,fs->value,iVar9 - (uint)(c == 0xfffffffd),
                                                (uint)(fVar2 != FC_PASSWORD),(int *)0x0);
                  if ((uchar *)fs->vpos == local_28 + -(int)fs->value) {
                    return;
                  }
                  *(uchar **)&fs->vpos = local_28 + -(int)fs->value;
                } while( true );
              }
              iVar9 = fs->state;
              x = local_38->size;
              iVar5 = fs->vpos;
              x_00 = (iVar9 + 1) - x;
              if (iVar5 < x_00) {
                fs->vpos = x_00;
                x = local_38->size;
                iVar5 = x_00;
              }
              else {
                if (iVar9 < iVar5) {
                  fs->vpos = iVar9;
                  x = local_38->size;
                  iVar5 = iVar9;
                }
              }
              uVar6 = 0xffffffff;
              end = fs->value;
              do {
                if (uVar6 == 0) break;
                uVar6 = uVar6 - 1;
                uVar1 = *end;
                end = end + (uint)bVar11 * -2 + 1;
              } while (uVar1 != '\0');
              if (0 < x) {
                iVar9 = 0;
                while( true ) {
                  x = (doc_view->box).x;
                  if ((x <= x_01) && (x_01 < x + (doc_view->box).width)) {
                    if ((fs->value == (uchar *)0x0) ||
                       ((x = fs->vpos, (int)((~uVar6 - 1) - iVar5) <= iVar9 ||
                        (-iVar9 != x && iVar9 <= -x)))) {
                      c = 0x5f;
                    }
                    else {
                      c = 0x2a;
                      if (local_38->type != FC_PASSWORD) {
                        c = (unicode_val_T)fs->value[iVar9 + x];
                      }
                    }
                    draw_char_data(term,x_01,y_01,c);
                  }
                  iVar9 = iVar9 + 1;
                  if (local_38->size == iVar9 || local_38->size < iVar9) break;
                  x_01 = x_01 + 1;
                }
              }
            }
          }
          break;
        case FC_TEXTAREA:
          draw_textarea(term,fs,doc_view,link);
          return;
        case FC_CHECKBOX:
        case FC_RADIO:
          if (1 < link->npoints) {
            x_01 = x_01 + link->points[1].x;
            if (((iVar9 <= x_01) && (y_01 = link->points[1].y + y_01, iVar5 <= y_01)) &&
               ((x_01 < iVar9 + (doc_view->box).width && (y_01 < iVar5 + (doc_view->box).height))))
            {
              draw_char_data(term,x_01,y_01,(-(uint)(fs->state == 0) & 0xffffffc8) + 0x58);
            }
          }
          break;
        case FC_SELECT:
          fixup_select_state(local_38,fs);
          if (fs->state < local_38->nvalues) {
            local_20[0] = local_38->labels[fs->state];
          }
          else {
            local_20[0] = "";
          }
          if ((*(byte *)&term->field_0x38 & 2) == 0) {
            local_40 = 0;
            if (local_20[0] != (uchar *)0x0) {
              local_40 = strlen((char *)local_20[0]);
            }
            if (0 < link->npoints) {
              iVar9 = 0;
              do {
                x = x_01 + link->points[iVar9].x;
                iVar5 = (doc_view->box).x;
                if (iVar5 <= x) {
                  y = link->points[iVar9].y + y_01;
                  x_00 = (doc_view->box).y;
                  if (((x_00 <= y) && (x < iVar5 + (doc_view->box).width)) &&
                     (y < (doc_view->box).height + x_00)) {
                    c = 0x5f;
                    if (iVar9 < (int)local_40) {
                      c = (unicode_val_T)local_20[0][iVar9];
                    }
                    draw_char_data(term,x,y,c);
                  }
                }
                iVar9 = iVar9 + 1;
              } while (link->npoints != iVar9 && iVar9 <= link->npoints);
            }
          }
          else {
            local_24 = local_20[0];
            end = (uchar *)__rawmemchr(local_20[0],0);
            iVar9 = utf8_ptr2cells(local_24,end);
            if (0 < link->npoints) {
              iVar5 = 0;
              do {
                x_00 = x_01 + link->points[iVar5].x;
                x = (doc_view->box).x;
                if (x_00 < x) {
LAB_080f24a1:
                  iVar10 = iVar5 + 1;
                }
                else {
                  y_00 = link->points[iVar5].y + y_01;
                  y = (doc_view->box).y;
                  if (((y_00 < y) || (x + (doc_view->box).width <= x_00)) ||
                     (y + (doc_view->box).height <= y_00)) goto LAB_080f24a1;
                  x = x_00;
                  if (iVar5 < iVar9) {
                    iVar10 = iVar5 + 1;
                    c = utf8_to_unicode(local_20,end);
                    y = unicode_to_cell(c);
                    if (y == 2) {
                      if (iVar10 < iVar9) {
                        x = x_00 + 1;
                        iVar10 = iVar5 + 2;
                        draw_char_data(term,x_00,y_00,c);
                        c = 0xfffffffd;
                      }
                      else {
                        c = 0x20;
                      }
                    }
                  }
                  else {
                    iVar10 = iVar5 + 1;
                    c = 0x5f;
                  }
                  draw_char_data(term,x,y_00,c);
                }
                iVar5 = iVar10;
              } while (iVar10 < link->npoints);
            }
          }
        }
      }
    }
  }
  else {
LAB_080f1ec8:
    assert_failed = 0;
  }
  return;
}



void draw_forms(terminal *term,document_view *doc_view)

{
  link *link;
  link *plVar1;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(doc_view == (document_view *)0x0 || term == (terminal *)0x0);
    if (doc_view == (document_view *)0x0 || term == (terminal *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x27e;
      elinks_internal((uchar *)"assertion term && doc_view failed!");
      if (assert_failed != 0) goto LAB_080f261d;
    }
    link = get_first_link(doc_view);
    plVar1 = get_last_link(doc_view);
    if ((plVar1 != (link *)0x0) && (link != (link *)0x0)) {
      while( true ) {
        if ((LINK_MAP < link->type) && (link->data != 0)) {
          draw_form_entry(term,doc_view,link);
        }
        if (plVar1 <= link) break;
        link = link + 1;
      }
      return;
    }
    if ((assert_failed == 0) &&
       (assert_failed = ZEXT14(plVar1 != (link *)0x0 || link != (link *)0x0),
       plVar1 != (link *)0x0 || link != (link *)0x0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x285;
      elinks_internal((uchar *)
                      "assertion !l1 && !l2 failed: get_first_link == %p, get_last_link == %p",link,
                      plVar1);
    }
  }
  else {
LAB_080f261d:
    assert_failed = 0;
  }
  return;
}



frame_event_status reset_form(session *ses,document_view *doc_view,int a)

{
  link *plVar1;
  int iVar2;
  
  if ((((doc_view != (document_view *)0x0) && (iVar2 = doc_view->vs->current_link, -1 < iVar2)) &&
      (iVar2 < doc_view->document->nlinks)) &&
     (plVar1 = doc_view->document->links + iVar2, plVar1 != (link *)0x0)) {
    iVar2 = 0;
    if (LINK_MAP < plVar1->type) {
      iVar2 = plVar1->data;
    }
    do_reset_form(doc_view,*(form **)(iVar2 + 8));
    draw_forms(ses->tab->term,doc_view);
  }
  return FRAME_EVENT_OK;
}



int get_current_state(session *ses)

{
  int iVar1;
  document_view *doc_view;
  form_state *pfVar2;
  link *plVar3;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(ses == (session *)0x0);
    if (ses == (session *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x171;
      elinks_internal((uchar *)"assertion ses failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return -1;
      }
    }
    doc_view = current_frame(ses);
    if (assert_failed == 0) {
      if (((doc_view == (document_view *)0x0) || (doc_view->vs == (view_state *)0x0)) ||
         (doc_view->document == (document *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
        errline = 0x175;
        elinks_internal((uchar *)"assertion doc_view && doc_view->vs && doc_view->document failed!")
        ;
        if (assert_failed != 0) {
          assert_failed = 0;
          return -1;
        }
        if (doc_view == (document_view *)0x0) {
          return -1;
        }
      }
      else {
        assert_failed = 0;
      }
      iVar1 = doc_view->vs->current_link;
      if (((-1 < iVar1) && (iVar1 < doc_view->document->nlinks)) &&
         ((plVar3 = doc_view->document->links + iVar1, plVar3 != (link *)0x0 &&
          ((plVar3->type == LINK_SELECT &&
           (pfVar2 = find_form_state(doc_view,(form_control *)plVar3->data),
           pfVar2 != (form_state *)0x0)))))) {
        return pfVar2->state;
      }
      return -1;
    }
  }
  assert_failed = 0;
  return -1;
}



void selected_item(terminal *term,void *item_,void *ses_)

{
  int iVar1;
  form_control *fc;
  document_view *doc_view;
  link *plVar2;
  form_state *fs;
  uchar *puVar3;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(ses_ == (void *)0x0 || term == (terminal *)0x0);
    if (ses_ == (void *)0x0 || term == (terminal *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x85;
      elinks_internal((uchar *)"assertion term && ses failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    doc_view = current_frame((session *)ses_);
    if (assert_failed == 0) {
      if (((doc_view == (document_view *)0x0) || (doc_view->vs == (view_state *)0x0)) ||
         (doc_view->document == (document *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
        errline = 0x89;
        elinks_internal((uchar *)"assertion doc_view && doc_view->vs && doc_view->document failed!")
        ;
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
        if (doc_view == (document_view *)0x0) {
          return;
        }
      }
      else {
        assert_failed = 0;
      }
      iVar1 = doc_view->vs->current_link;
      if (iVar1 < 0) {
        return;
      }
      if (iVar1 < doc_view->document->nlinks) {
        plVar2 = doc_view->document->links + iVar1;
        if (plVar2 == (link *)0x0) {
          return;
        }
        if (plVar2->type == LINK_SELECT) {
          fc = (form_control *)plVar2->data;
          fs = find_form_state(doc_view,fc);
          if (fs != (form_state *)0x0) {
            if ((-1 < (int)item_) && ((int)item_ < fc->nvalues)) {
              *(void **)&fs->state = item_;
              if (fs->value != (uchar *)0x0) {
                mem_free(fs->value);
              }
              puVar3 = stracpy(fc->values[(int)item_]);
              fs->value = puVar3;
            }
            fixup_select_state(fc,fs);
          }
          refresh_view((session *)ses_,doc_view,0);
          return;
        }
        return;
      }
      return;
    }
  }
  assert_failed = 0;
  return;
}



void __regparm3 add_form_attr_to_string(string *string,terminal *term,uchar *name,uchar *value)

{
  int cp_index;
  uchar *codeset;
  
  add_to_string(string,", ");
  if ((name != (uchar *)0x0) && (*name != '\0')) {
    if (term != (terminal *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    name = gettext(name);
  }
  add_to_string(string,name);
  if (value != (uchar *)0x0) {
    add_char_to_string(string,' ');
    add_to_string(string,value);
  }
  return;
}



void link_form_menu(session *ses)

{
  int iVar1;
  form_control *fc;
  terminal *term;
  form_type fVar2;
  bool bVar3;
  document_view *pdVar4;
  int iVar5;
  string *psVar6;
  int cp_index;
  uchar *codeset;
  int *data;
  link *plVar7;
  char *msgid;
  string str;
  menu_item *local_20 [4];
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(ses == (session *)0x0);
    if (ses == (session *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x822;
      elinks_internal((uchar *)"assertion ses failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    pdVar4 = current_frame(ses);
    if (pdVar4 == (document_view *)0x0) {
      return;
    }
    if (assert_failed == 0) {
      if ((pdVar4->vs == (view_state *)0x0) || (pdVar4->document == (document *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
        errline = 0x828;
        elinks_internal((uchar *)"assertion doc_view->vs && doc_view->document failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
      }
      else {
        assert_failed = 0;
      }
      iVar1 = pdVar4->vs->current_link;
      if (iVar1 < 0) {
        return;
      }
      if (pdVar4->document->nlinks <= iVar1) {
        return;
      }
      plVar7 = pdVar4->document->links + iVar1;
      if (plVar7 == (link *)0x0) {
        return;
      }
      bVar3 = plVar7->type < LINK_BUTTON;
      assert_failed = ZEXT14(bVar3);
      if (bVar3) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
        errline = 0x82e;
        elinks_internal((uchar *)"assertion link_is_form(link) failed!");
      }
      if (plVar7->type < LINK_BUTTON) {
        return;
      }
      if (plVar7->data == 0) {
        return;
      }
      iVar1 = *(int *)(plVar7->data + 8);
      local_20[0] = new_menu(FREE_LIST|FREE_TEXT|NO_INTL);
      if (local_20[0] == (menu_item *)0x0) {
        return;
      }
      fc = *(form_control **)(iVar1 + 0x24);
      do {
        while( true ) {
          if ((form_control *)(iVar1 + 0x24) == fc) {
            do_menu(ses->tab->term,local_20[0],ses,1);
            return;
          }
          fVar2 = fc->type;
          if (FC_SELECT < fVar2) break;
LAB_080f2bc8:
          msgid = (char *)get_form_label(fc);
LAB_080f2bd1:
          iVar5 = get_form_control_link(pdVar4->document,fc);
          if ((-1 < iVar5) && (psVar6 = init_string(&str), psVar6 != (string *)0x0)) {
            if ((assert_failed == 0) &&
               (assert_failed = ZEXT14((uchar *)msgid == (uchar *)0x0),
               (uchar *)msgid == (uchar *)0x0)) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
              errline = 0x853;
              elinks_internal((uchar *)"assertion text failed!");
            }
            term = ses->tab->term;
            if (((uchar *)msgid != (uchar *)0x0) && (*msgid != '\0')) {
              if ((term != (terminal *)0x0) &&
                 (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
                codeset = get_cp_mime_name(cp_index);
                bind_textdomain_codeset("elinks",codeset);
                current_charset = cp_index;
              }
              msgid = (char *)gettext((uchar *)msgid);
            }
            add_to_string(&str,(uchar *)msgid);
            codeset = fc->name;
            if (codeset == (uchar *)0x0) {
              codeset = fc->alt;
            }
            data = (int *)mem_alloc(4);
            if (data != (int *)0x0) {
              *data = iVar5;
            }
            add_to_menu(local_20,str.source,codeset,ACT_MAIN_NONE,link_form_menu_func,data,FREE_DATA
                       );
          }
          fc = fc->next;
        }
        if (fVar2 < FC_RESET) {
          msgid = "Useless button";
          if (*(int *)(iVar1 + 0x10) != 0) {
            msgid = "Submit button";
          }
          goto LAB_080f2bd1;
        }
        if (fVar2 != FC_HIDDEN) goto LAB_080f2bc8;
        fc = fc->next;
      } while( true );
    }
  }
  assert_failed = 0;
  return;
}



void __regparm3
encode_multipart(session *ses,list_head_elinks *l,string *data,boundary_info *boundary,int cp_from,
                int cp_to)

{
  int *piVar1;
  byte *pbVar2;
  byte bVar3;
  int iVar4;
  size_t __n;
  uchar *source;
  int *p;
  char *pcVar5;
  void *pvVar6;
  int fd;
  undefined4 *puVar7;
  int iVar8;
  uint size;
  uchar *name;
  byte *pbVar9;
  list_head_elinks *plVar10;
  uint size_00;
  byte *pbVar11;
  boundary_info *pbVar12;
  uint uVar13;
  undefined4 *puVar14;
  size_t size_01;
  int in_GS_OFFSET;
  bool bVar15;
  bool bVar16;
  byte bVar17;
  conv_table *local_440;
  int local_43c;
  uchar buffer [1024];
  
  bVar17 = 0;
  iVar4 = *(int *)(in_GS_OFFSET + 0x14);
  if (assert_failed != 0) {
LAB_080f3170:
    assert_failed = 0;
    goto LAB_080f317a;
  }
  if ((((l == (list_head_elinks *)0x0) || (ses == (session *)0x0)) ||
      (boundary == (boundary_info *)0x0)) || (data == (string *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x3d9;
    elinks_internal((uchar *)"assertion ses && l && data && boundary failed!");
    if (assert_failed != 0) goto LAB_080f3170;
  }
  else {
    assert_failed = 0;
  }
  fd = 10;
  pbVar12 = boundary;
  while (fd != 0) {
    fd = fd + -1;
    pbVar12->count = 0;
    pbVar12 = (boundary_info *)((int)pbVar12 + (uint)bVar17 * -8 + 4);
  }
  puVar7 = (undefined4 *)boundary->string;
  *(undefined4 *)boundary->string = 0x30303030;
  *(undefined4 *)(boundary->string + 4) = 0x30303030;
  *(undefined4 *)(boundary->string + 8) = 0x30303030;
  *(undefined4 *)(boundary->string + 0xc) = 0x30303030;
  *(undefined4 *)(boundary->string + 0x10) = 0x30303030;
  *(undefined4 *)(boundary->string + 0x14) = 0x30303030;
  *(undefined4 *)(boundary->string + 0x18) = 0x30303030;
  *(undefined4 *)(boundary->string + 0x1c) = 0x30303030;
  plVar10 = (list_head_elinks *)l->next;
  if (plVar10 != l) {
    local_440 = (conv_table *)0x0;
LAB_080f3052:
    add_to_string(data,"--");
    size_00 = boundary->count + 0x100;
    size = boundary->count + 0xff;
    uVar13 = size_00 & 0xffffff00;
    if (uVar13 < (size & 0xffffff00) || uVar13 + (size >> 8) * -0x100 == 0) {
LAB_080f3082:
      if (boundary->offsets != (int *)0x0) {
        fd = boundary->count;
        boundary->offsets[fd] = data->length;
        boundary->count = fd + 1;
      }
    }
    else {
      size_01 = (size_00 >> 8) * 0x400;
      p = (int *)mem_realloc(boundary->offsets,size_01);
      if (p != (int *)0x0) {
        boundary->offsets = p;
        memset(p + (size & 0xffffff00),0,size_01 + (size >> 8) * -0x400);
        goto LAB_080f3082;
      }
    }
    if (assert_failed == 0) {
      if (data == (string *)0x0) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) goto LAB_080f2f48;
      }
      else {
        assert_failed = 0;
      }
      fd = data->length;
      size_00 = fd + 0xffU >> 8;
      uVar13 = fd + 0xffU & 0xffffff00;
      size = fd + 0x120U & 0xffffff00;
      if (uVar13 <= size && size + size_00 * -0x100 != 0) {
        source = (uchar *)mem_realloc(data->source,size);
        if (source == (uchar *)0x0) goto LAB_080f2f58;
        data->source = source;
        memset(source + uVar13,0,size + size_00 * -0x100);
      }
      if (data->source != (uchar *)0x0) {
        puVar14 = (undefined4 *)(data->source + data->length);
        *puVar14 = *puVar7;
        puVar14[1] = *(undefined4 *)(boundary->string + 4);
        puVar14[2] = *(undefined4 *)(boundary->string + 8);
        puVar14[3] = *(undefined4 *)(boundary->string + 0xc);
        puVar14[4] = *(undefined4 *)(boundary->string + 0x10);
        puVar14[5] = *(undefined4 *)(boundary->string + 0x14);
        puVar14[6] = *(undefined4 *)(boundary->string + 0x18);
        puVar14[7] = *(undefined4 *)(boundary->string + 0x1c);
        data->source[fd + 0x20] = '\0';
        data->length = fd + 0x20;
      }
    }
    else {
LAB_080f2f48:
      assert_failed = 0;
    }
LAB_080f2f58:
    add_crlf_to_string(data);
    add_to_string(data,(uchar *)"Content-Disposition: form-data; name=\"");
    add_to_string(data,(uchar *)plVar10[1].next);
    add_char_to_string(data,'\"');
    if (plVar10[2].prev != (void *)0x2) {
      add_crlf_to_string(data);
      add_crlf_to_string(data);
      if ((plVar10[2].prev == (void *)0x3) || (plVar10[2].prev < (void *)0x2)) {
        if (local_440 == (conv_table *)0x0) {
          local_440 = get_translation_table(cp_from,cp_to);
        }
        source = (uchar *)plVar10[1].prev;
        __n = strlen((char *)source);
        source = convert_string_elinks
                           (local_440,source,__n,-1,CSM_FORM,(int *)0x0,
                            (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
        if (source != (uchar *)0x0) {
          add_to_string(data,source);
          mem_free(source);
        }
      }
      else {
        add_to_string(data,(uchar *)plVar10[1].prev);
      }
      goto LAB_080f303c;
    }
    add_to_string(data,(uchar *)"; filename=\"");
    source = get_filename_position((uchar *)plVar10[1].prev);
    add_to_string(data,source);
    add_char_to_string(data,'\"');
    source = (uchar *)strrchr((char *)plVar10[1].prev,0x2e);
    if ((source != (uchar *)0x0) &&
       (source = get_extension_content_type(source), source != (uchar *)0x0)) {
      add_crlf_to_string(data);
      add_to_string(data,"Content-Type: ");
      add_to_string(data,source);
      mem_free(source);
    }
    add_crlf_to_string(data);
    add_crlf_to_string(data);
    if (*(char *)plVar10[1].prev != '\0') {
      p = get_opt_(cmdline_options,name);
      if (*p == 0) {
        source = expand_tilde((uchar *)plVar10[1].prev);
        if (source != (uchar *)0x0) {
          fd = open64((char *)source,0);
          mem_free(source);
          if (fd != -1) {
            set_bin(fd);
LAB_080f32ff:
            do {
              while (__n = read(fd,buffer,0x400), __n == 0xffffffff) {
                p = __errno_location();
                if (*p != 4) {
                  close(fd);
                  goto encode_error;
                }
              }
              if (__n == 0) goto LAB_080f35c0;
              if (assert_failed == 0) {
                if ((data == (string *)0x0) || ((int)__n < 0)) {
                  assert_failed = 1;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                  errline = 0xff;
                  elinks_internal((uchar *)
                                  "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                                 );
                  if (assert_failed != 0) goto LAB_080f333c;
                }
                else {
                  assert_failed = 0;
                }
                iVar8 = __n + data->length;
                uVar13 = data->length + 0xffU & 0xffffff00;
                size_00 = iVar8 + 0x100U & 0xffffff00;
                if (uVar13 < size_00) {
                  source = (uchar *)mem_realloc(data->source,size_00);
                  if (source == (uchar *)0x0) goto LAB_080f32ff;
                  data->source = source;
                  memset(source + uVar13,0,size_00 - uVar13);
                }
                if (data->source != (uchar *)0x0) {
                  memcpy(data->source + data->length,buffer,__n);
                  data->source[iVar8] = '\0';
                  data->length = iVar8;
                }
                goto LAB_080f32ff;
              }
LAB_080f333c:
              assert_failed = 0;
            } while( true );
          }
        }
        p = __errno_location();
      }
      else {
        p = __errno_location();
        *p = 1;
      }
encode_error:
      if (boundary->offsets != (int *)0x0) {
        mem_free(boundary->offsets);
      }
      done_string(data);
      pcVar5 = strerror(*p);
      source = msg_text(ses->tab->term,(uchar *)"Could not load file %s: %s",plVar10[1].prev,pcVar5)
      ;
      info_box(ses->tab->term,MSGBOX_FREE_TEXT,(uchar *)"Error while posting form",ALIGN_CENTER,
               source);
      goto LAB_080f317a;
    }
LAB_080f303c:
    add_crlf_to_string(data);
    plVar10 = (list_head_elinks *)plVar10->next;
    if (plVar10 == l) goto LAB_080f35fd;
    goto LAB_080f3052;
  }
LAB_080f35fd:
  add_to_string(data,"--");
  uVar13 = boundary->count + 0x100U & 0xffffff00;
  size_00 = boundary->count + 0xffU & 0xffffff00;
  if (size_00 < uVar13) {
    size_01 = uVar13 * 4;
    p = (int *)mem_realloc(boundary->offsets,size_01);
    if (p != (int *)0x0) {
      boundary->offsets = p;
      memset(p + size_00,0,size_01 + size_00 * -4);
      goto LAB_080f3635;
    }
  }
  else {
LAB_080f3635:
    if (boundary->offsets != (int *)0x0) {
      fd = boundary->count;
      boundary->offsets[fd] = data->length;
      boundary->count = fd + 1;
    }
  }
  if (assert_failed == 0) {
    if (data == (string *)0x0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080f365d;
    }
    else {
      assert_failed = 0;
    }
    size_01 = data->length;
    pvVar6 = mem_align_alloc__((void **)data,size_01,size_01 + 0x21,1,0xff);
    if (pvVar6 != (void *)0x0) {
      puVar14 = (undefined4 *)(data->source + data->length);
      *puVar14 = *(undefined4 *)boundary->string;
      puVar14[1] = *(undefined4 *)(boundary->string + 4);
      puVar14[2] = *(undefined4 *)(boundary->string + 8);
      puVar14[3] = *(undefined4 *)(boundary->string + 0xc);
      puVar14[4] = *(undefined4 *)(boundary->string + 0x10);
      puVar14[5] = *(undefined4 *)(boundary->string + 0x14);
      puVar14[6] = *(undefined4 *)(boundary->string + 0x18);
      puVar14[7] = *(undefined4 *)(boundary->string + 0x1c);
      data->source[size_01 + 0x20] = '\0';
      data->length = size_01 + 0x20;
    }
  }
  else {
LAB_080f365d:
    assert_failed = 0;
  }
  add_to_string(data,"--\r\n");
  local_43c = boundary->count;
  if (local_43c != 1 && -1 < local_43c + -1) {
    p = boundary->offsets;
    fd = 0;
LAB_080f36b0:
    piVar1 = p + fd;
    fd = fd + 1;
    pbVar9 = data->source + *piVar1 + 0x48;
    pbVar2 = data->source + p[fd] + -0x22;
    bVar15 = pbVar9 < pbVar2;
    if (pbVar9 <= pbVar2) {
      do {
        bVar16 = pbVar9 == pbVar2;
        iVar8 = 0x20;
        pbVar11 = pbVar9;
        puVar14 = puVar7;
        do {
          if (iVar8 == 0) break;
          iVar8 = iVar8 + -1;
          bVar15 = *pbVar11 < *(byte *)puVar14;
          bVar16 = *pbVar11 == *(byte *)puVar14;
          pbVar11 = pbVar11 + (uint)bVar17 * -2 + 1;
          puVar14 = (undefined4 *)((int)puVar14 + (uint)bVar17 * -2 + 1);
        } while (bVar16);
        if ((!bVar15 && !bVar16) == bVar15) {
          fd = 0x1f;
          goto LAB_080f37c5;
        }
        pbVar9 = pbVar9 + 1;
        bVar15 = pbVar2 < pbVar9;
      } while (!bVar15);
    }
    goto LAB_080f3720;
  }
  p = boundary->offsets;
LAB_080f3735:
  if (0 < local_43c) {
    fd = 0;
    while( true ) {
      puVar14 = (undefined4 *)(data->source + p[fd]);
      fd = fd + 1;
      *puVar14 = *puVar7;
      puVar14[1] = *(undefined4 *)(boundary->string + 4);
      puVar14[2] = *(undefined4 *)(boundary->string + 8);
      puVar14[3] = *(undefined4 *)(boundary->string + 0xc);
      puVar14[4] = *(undefined4 *)(boundary->string + 0x10);
      puVar14[5] = *(undefined4 *)(boundary->string + 0x14);
      puVar14[6] = *(undefined4 *)(boundary->string + 0x18);
      puVar14[7] = *(undefined4 *)(boundary->string + 0x1c);
      if (boundary->count <= fd) break;
      p = boundary->offsets;
    }
    p = boundary->offsets;
  }
LAB_080f3798:
  if (p != (int *)0x0) {
    mem_free(p);
  }
LAB_080f317a:
  if (iVar4 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
LAB_080f35c0:
  close(fd);
  goto LAB_080f303c;
LAB_080f37c5:
  bVar3 = boundary->string[fd];
  boundary->string[fd] = bVar3 + 1;
  if (bVar3 < 0x39) goto code_r0x080f37d6;
  boundary->string[fd] = '0';
  fd = fd + -1;
  if (fd == -1) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x39d;
    elinks_internal((uchar *)"Form data boundary counter overflow");
    p = boundary->offsets;
    goto LAB_080f3798;
  }
  goto LAB_080f37c5;
code_r0x080f37d6:
  local_43c = boundary->count;
  fd = 1;
  p = boundary->offsets;
LAB_080f3720:
  if (local_43c + -1 <= fd) goto LAB_080f3735;
  goto LAB_080f36b0;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Restarted to delay deadcode elimination for space: stack

uri * get_form_uri(session *ses,document_view *doc_view,form_control *fc)

{
  form *form;
  form_method fVar1;
  submitted_value *psVar2;
  form_type fVar3;
  uint uVar4;
  bool bVar5;
  byte character;
  uri *puVar6;
  string *psVar7;
  form_state *fs;
  int cp_from;
  int *piVar8;
  char *pcVar9;
  uchar *name;
  submitted_value *psVar10;
  submitted_value *sv;
  uchar *str;
  conv_table *convert_table;
  size_t namelen;
  uint uVar11;
  uchar uVar12;
  submitted_value *psVar13;
  uint size;
  form *pfVar14;
  form_control *fc_00;
  int position;
  byte *p_00;
  int in_GS_OFFSET;
  byte *local_74;
  conv_table *local_70;
  string go;
  string data;
  list_head_elinks submit;
  uchar p [3];
  boundary_info boundary;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  submit.next = (submitted_value *)&submit;
  submit.prev = (submitted_value *)&submit;
  if (assert_failed != 0) {
LAB_080f39fa:
    assert_failed = 0;
    puVar6 = (uri *)0x0;
    goto LAB_080f3a08;
  }
  if (((ses == (session *)0x0) || (ses->tab == (window *)0x0)) ||
     (ses->tab->term == (terminal *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x4d1;
    elinks_internal((uchar *)"assertion ses && ses->tab && ses->tab->term failed!");
    if (assert_failed != 0) goto LAB_080f39fa;
  }
  if (((doc_view == (document_view *)0x0) || (fc == (form_control *)0x0)) ||
     ((doc_view->document == (document *)0x0 || (fc->form == (form *)0x0)))) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x4d3;
    elinks_internal((uchar *)"assertion doc_view && doc_view->document && fc && fc->form failed!");
    if (assert_failed != 0) goto LAB_080f39fa;
    form = fc->form;
    fVar3 = fc->type;
  }
  else {
    assert_failed = 0;
    form = fc->form;
    fVar3 = fc->type;
  }
  if (fVar3 == FC_RESET) {
    do_reset_form(doc_view,form);
    puVar6 = (uri *)0x0;
    goto LAB_080f3a08;
  }
  if ((form->action == (uchar *)0x0) || (psVar7 = init_string(&data), psVar7 == (string *)0x0)) {
    puVar6 = (uri *)0x0;
    goto LAB_080f3a08;
  }
  if (assert_failed == 0) {
    if ((doc_view == (document_view *)0x0) || (fc->form == (form *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x30a;
      elinks_internal((uchar *)"assertion doc_view && fc && fc->form && list failed!");
      if (assert_failed != 0) goto LAB_080f3c38;
    }
    else {
      assert_failed = 0;
    }
    pfVar14 = fc->form;
    fc_00 = (form_control *)(pfVar14->items).next;
    if (fc_00 != (form_control *)&pfVar14->items) {
      do {
        if ((((fc == fc_00) || (3 < fc_00->type + ~FC_SELECT)) && (fc_00->name != (uchar *)0x0)) &&
           (*fc_00->name != '\0')) {
          fs = find_form_state(doc_view,fc_00);
          if (fs != (form_state *)0x0) {
            if (assert_failed == 0) {
              assert_failed = 0;
            }
            str = fc_00->name;
            position = fc_00->position;
            switch(fc_00->type) {
            case FC_TEXT:
            case FC_PASSWORD:
            case FC_FILE:
            case FC_TEXTAREA:
            case FC_SUBMIT:
            case FC_RESET:
            case FC_BUTTON:
            case FC_HIDDEN:
switchD_080f3bb4_caseD_0:
              sv = init_submitted_value(str,fs->value,fc_00->type,fc_00,position);
              if (sv != (submitted_value *)0x0) {
LAB_080f3fa1:
                sv->prev = (submitted_value *)&submit;
                sv->next = submit.next;
                sv->next->prev = sv;
                pfVar14 = fc->form;
                submit.next = sv;
                goto LAB_080f3b48;
              }
              break;
            case FC_CHECKBOX:
            case FC_RADIO:
              if (fs->state != 0) goto switchD_080f3bb4_caseD_0;
              break;
            case FC_SELECT:
              if (fc_00->nvalues != 0) {
                fixup_select_state(fc_00,fs);
                sv = init_submitted_value(str,fs->value,FC_SELECT,fc_00,position);
                if (sv == (submitted_value *)0x0) break;
                goto LAB_080f3fa1;
              }
              break;
            case FC_IMAGE:
              str = straconcat(str,&DAT_0813532c,0);
              if (str != (uchar *)0x0) {
                sv = init_submitted_value(str,"0",FC_IMAGE,fc_00,position);
                mem_free(str);
                if (sv != (submitted_value *)0x0) {
                  sv->prev = (submitted_value *)&submit;
                  sv->next = submit.next;
                  sv->next->prev = sv;
                  submit.next = sv;
                }
                str = straconcat(fc_00->name,&DAT_0813532f,0);
                if (str != (uchar *)0x0) {
                  sv = init_submitted_value(str,"0",FC_IMAGE,fc_00,position);
                  mem_free(str);
                  if (sv != (submitted_value *)0x0) {
                    sv->prev = (submitted_value *)&submit;
                    sv->next = submit.next;
                    sv->next->prev = sv;
                    submit.next = sv;
                  }
                }
              }
            }
          }
          pfVar14 = fc->form;
        }
LAB_080f3b48:
        fc_00 = fc_00->next;
      } while (fc_00 != (form_control *)&pfVar14->items);
    }
    do {
      bVar5 = false;
      sv = (submitted_value *)submit.next;
      while (psVar10 = sv, psVar13 = (submitted_value *)submit.prev,
            psVar10 != (submitted_value *)&submit) {
        while ((sv = psVar10->next, (submitted_value *)&submit != sv &&
               ((int)sv->position < (int)psVar10->position))) {
          bVar5 = true;
          sv->prev = psVar10->prev;
          psVar10->prev->next = psVar10->next;
          psVar2 = sv->next;
          psVar10->prev = sv;
          psVar10->next = psVar2;
          sv->next = psVar10;
          psVar10->next->prev = psVar10;
          psVar10 = sv->next;
          if (psVar10 == (submitted_value *)&submit) goto joined_r0x080f3f25;
        }
      }
joined_r0x080f3f25:
      while (psVar13 != psVar10) {
        sv = psVar13->next;
        if (((submitted_value *)&submit != sv) && ((int)sv->position < (int)psVar13->position)) {
          sv->prev = psVar13->prev;
          psVar13->prev->next = psVar13->next;
          psVar2 = sv->next;
          bVar5 = true;
          psVar13->prev = sv;
          psVar13->next = psVar2;
          sv->next = psVar13;
          psVar13->next->prev = psVar13;
          psVar13 = sv;
        }
        psVar13 = psVar13->prev;
      }
    } while (bVar5);
  }
  else {
LAB_080f3c38:
    assert_failed = 0;
  }
  cp_from = get_terminal_codepage(ses->tab->term);
  position = doc_view->document->cp;
  fVar1 = form->method;
  if (fVar1 == FORM_METHOD_POST_MP) {
    encode_multipart(ses,(list_head_elinks *)(submitted_value *)&submit,&data,&boundary,cp_from,
                     position);
  }
  else {
    if (fVar1 < FORM_METHOD_POST_MP) {
      if (assert_failed == 0) {
        assert_failed = 0;
        local_70 = (conv_table *)0x0;
        sv = (submitted_value *)submit.next;
        if ((submitted_value *)&submit != (submitted_value *)submit.next) {
          do {
            str = sv->name;
            namelen = strlen((char *)str);
            encode_uri_string(&data,str,namelen,1);
            add_char_to_string(&data,'=');
            fVar3 = sv->type;
            if (fVar3 == FC_TEXTAREA) {
              str = encode_textarea(sv);
              if (str != (uchar *)0x0) {
                if (local_70 == (conv_table *)0x0) {
                  local_70 = get_translation_table(cp_from,position);
                }
                namelen = strlen((char *)str);
                name = convert_string_elinks
                                 (local_70,str,namelen,-1,CSM_FORM,(int *)0x0,
                                  (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
                mem_free(str);
                goto LAB_080f3dde;
              }
            }
            else {
              if (fVar3 < FC_FILE) {
                if (local_70 == (conv_table *)0x0) {
                  local_70 = get_translation_table(cp_from,position);
                }
                str = sv->value;
                namelen = strlen((char *)str);
                name = convert_string_elinks
                                 (local_70,str,namelen,-1,CSM_FORM,(int *)0x0,
                                  (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
              }
              else {
                if (fVar3 == FC_HIDDEN) {
                  name = encode_crlf(sv);
                }
                else {
                  name = stracpy(sv->value);
                }
              }
LAB_080f3dde:
              if (name != (uchar *)0x0) {
                namelen = strlen((char *)name);
                encode_uri_string(&data,name,namelen,1);
                mem_free(name);
              }
            }
            sv = sv->next;
            if ((submitted_value *)&submit == sv) break;
            add_char_to_string(&data,'&');
          } while( true );
        }
      }
      else {
LAB_080f4276:
        assert_failed = 0;
      }
    }
    else {
      if (fVar1 == FORM_METHOD_POST_TEXT_PLAIN) {
        convert_table = get_translation_table(cp_from,position);
        if (assert_failed != 0) goto LAB_080f4276;
        assert_failed = 0;
        uVar12 = p[1];
        sv = (submitted_value *)submit.next;
        while (p[1] = uVar12, sv != (submitted_value *)&submit) {
          p._0_2_ = CONCAT11(uVar12,p[0]);
          local_74 = sv->value;
          add_to_string(&data,sv->name);
          p._0_2_ = CONCAT11(uVar12,p[0]);
          add_char_to_string(&data,'=');
          p._0_2_ = CONCAT11(uVar12,p[0]);
          fVar3 = sv->type;
          if (fVar3 == FC_TEXTAREA) {
            p_00 = encode_textarea(sv);
            local_74 = p_00;
            if (p_00 != (byte *)0x0) goto LAB_080f4321;
          }
          else {
            if (fVar3 < FC_CHECKBOX) {
              if (fVar3 < FC_FILE) {
                p_00 = (byte *)0x0;
LAB_080f4321:
                uVar12 = p[1];
                namelen = strlen((char *)local_74);
                p._0_2_ = CONCAT11(uVar12,p[0]);
                local_74 = convert_string_elinks
                                     (convert_table,local_74,namelen,-1,CSM_FORM,(int *)0x0,
                                      (anon_subr_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
                p._0_2_ = CONCAT11(uVar12,p[0]);
                if (p_00 != (byte *)0x0) {
                  mem_free(p_00);
                }
              }
            }
            else {
              if (fVar3 == FC_HIDDEN) {
                p_00 = encode_crlf(sv);
                local_74 = p_00;
                if (p_00 == (byte *)0x0) goto LAB_080f4487;
                goto LAB_080f4321;
              }
            }
            if (local_74 != (byte *)0x0) {
              character = *local_74;
              p_00 = local_74;
              position = data.length;
              while (data.length = position, character != 0) {
                while( true ) {
                  if ((character != 0xd) && (character != 10)) {
                    add_char_to_string(&data,character);
                    goto LAB_080f4403;
                  }
                  p[0] = '%';
                  character = *p_00 >> 4;
                  uVar12 = character + 0x57;
                  if (character < 10) {
                    uVar12 = character + 0x30;
                  }
                  p._0_2_ = CONCAT11(uVar12,0x25);
                  character = *p_00 & 0xf;
                  p[2] = character + 0x57;
                  if (character < 10) {
                    p[2] = character + 0x30;
                  }
                  p[1] = uVar12;
                  if (assert_failed == 0) break;
                  p_00 = p_00 + 1;
                  assert_failed = 0;
                  character = *p_00;
                  if (character == 0) goto LAB_080f4468;
                }
                assert_failed = 0;
                size = position + 0x103U & 0xffffff00;
                uVar4 = position + 0xffU >> 8;
                uVar11 = position + 0xffU & 0xffffff00;
                if (size < uVar11 || size + uVar4 * -0x100 == 0) {
LAB_080f43de:
                  if (data.source != (uchar *)0x0) {
                    *(undefined2 *)(data.source + data.length) = p._0_2_;
                    (data.source + data.length)[1] = p[2];
                    data.source[position + 3] = '\0';
                    data.length = position + 3;
                  }
                }
                else {
                  str = (uchar *)mem_realloc(data.source,size);
                  p._0_2_ = CONCAT11(uVar12,p[0]);
                  if (str != (uchar *)0x0) {
                    data.source = str;
                    memset(str + uVar11,0,size + uVar4 * -0x100);
                    goto LAB_080f43de;
                  }
                }
LAB_080f4403:
                p_00 = p_00 + 1;
                character = *p_00;
                position = data.length;
              }
LAB_080f4468:
              if (local_74 != sv->value) {
                mem_free(local_74);
              }
            }
          }
LAB_080f4487:
          uVar12 = p[1];
          add_crlf_to_string(&data);
          p._0_2_ = CONCAT11(uVar12,p[0]);
          sv = sv->next;
          uVar12 = p[1];
        }
      }
    }
  }
  uVar12 = p[1];
  if (data.source != (uchar *)0x0) {
    piVar8 = get_opt_(config_options,data.source);
    p._0_2_ = CONCAT11(uVar12,p[0]);
    if (*piVar8 != 0) {
      memorize_form(ses,(list_head_elinks *)(submitted_value *)&submit,form);
    }
  }
  uVar12 = p[1];
  done_submitted_value_list((list_head_elinks *)(submitted_value *)&submit);
  p._0_2_ = CONCAT11(uVar12,p[0]);
  if (data.source != (uchar *)0x0) {
    psVar7 = init_string(&go);
    p._0_2_ = CONCAT11(uVar12,p[0]);
    if (psVar7 != (string *)0x0) {
      if (form->method == FORM_METHOD_GET) {
        str = form->action;
        name = (uchar *)strchr((char *)str,0x23);
        p._0_2_ = CONCAT11(uVar12,p[0]);
        if (name == (uchar *)0x0) {
          add_to_string(&go,str);
        }
        else {
          add_bytes_to_string__(&go,str,(int)(name + -(int)str));
        }
        uVar12 = p[1];
        pcVar9 = strchr((char *)go.source,0x3f);
        p._0_2_ = CONCAT11(uVar12,p[0]);
        if (pcVar9 == (char *)0x0) {
          add_char_to_string(&go,'?');
        }
        else {
          add_char_to_string(&go,'&');
        }
        uVar12 = p[1];
        add_string_to_string(&go,&data);
        p._0_2_ = CONCAT11(uVar12,p[0]);
        if (name != (uchar *)0x0) {
          add_to_string(&go,name);
        }
      }
      else {
        if (form->method < 4) {
          add_to_string(&go,form->action);
          p._0_2_ = CONCAT11(uVar12,p[0]);
          add_char_to_string(&go,'\x01');
          p._0_2_ = CONCAT11(uVar12,p[0]);
          if (form->method == FORM_METHOD_POST) {
            add_to_string(&go,(uchar *)"application/x-www-form-urlencoded\n");
          }
          else {
            if (form->method == FORM_METHOD_POST_TEXT_PLAIN) {
              add_to_string(&go,(uchar *)"text/plain\n");
              p._0_2_ = CONCAT11(uVar12,p[0]);
              add_to_string(&go,data.source);
              goto LAB_080f3d54;
            }
            add_to_string(&go,(uchar *)"multipart/form-data; boundary=");
            p._0_2_ = CONCAT11(uVar12,p[0]);
            add_bytes_to_string__(&go,boundary.string,0x20);
            p._0_2_ = CONCAT11(uVar12,p[0]);
            add_char_to_string(&go,'\n');
          }
          if (0 < data.length) {
            position = 0;
            do {
              uVar12 = p[1];
              p_00 = data.source + position;
              position = position + 1;
              elinks_ulongcat(p,(uint *)0x0,(uint)*p_00,'\x02',0x30,0x10);
              p._0_2_ = CONCAT11(uVar12,p[0]);
              add_to_string(&go,p);
            } while (position < data.length);
          }
        }
      }
LAB_080f3d54:
      uVar12 = p[1];
      done_string(&data);
      p._0_2_ = CONCAT11(uVar12,p[0]);
      puVar6 = get_uri(go.source,0);
      p._0_2_ = CONCAT11(uVar12,p[0]);
      done_string(&go);
      if (puVar6 != (uri *)0x0) {
        *(byte *)&puVar6->field_0x36 = *(byte *)&puVar6->field_0x36 | 2;
      }
      goto LAB_080f3a08;
    }
  }
  done_string(&data);
  puVar6 = (uri *)0x0;
LAB_080f3a08:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return puVar6;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void submit_given_form(session *ses,document_view *doc_view,form *form,int do_reload)

{
  form_control *fc;
  uri *uri;
  
  fc = (form_control *)(form->items).next;
  if ((fc != (form_control *)&form->items) && (fc != (form_control *)0x0)) {
    uri = get_form_uri(ses,doc_view,fc);
    if (uri != (uri *)0x0) {
      goto_uri_frame(ses,uri,form->target,(-(uint)(do_reload == 0) & 0xfffffffe) + 3);
      done_uri(uri);
      return;
    }
  }
  return;
}



void auto_submit_form(session *ses)

{
  document *pdVar1;
  form *form;
  
  pdVar1 = ses->doc_view->document;
  form = (form *)(pdVar1->forms).next;
  if (form != (form *)&pdVar1->forms) {
    submit_given_form(ses,ses->doc_view,form,0);
  }
  return;
}



uchar * get_form_info(session *ses,document_view *doc_view)

{
  terminal *term;
  uchar *msgid;
  string *psVar1;
  int cp_index;
  uchar *codeset;
  uint uVar2;
  int *piVar3;
  uri *uri;
  uchar *format;
  form_state *pfVar4;
  uchar *extraout_EDX;
  uchar *name;
  uchar *extraout_EDX_00;
  uchar *extraout_EDX_01;
  uchar *extraout_EDX_02;
  uchar *extraout_EDX_03;
  uchar *extraout_EDX_04;
  uchar *extraout_EDX_05;
  uchar *extraout_EDX_06;
  uchar *extraout_EDX_07;
  uchar *extraout_EDX_08;
  uchar *extraout_EDX_09;
  uchar *extraout_EDX_10;
  uchar *extraout_EDX_11;
  link *plVar5;
  form_control *fc;
  char *msg;
  bool bVar6;
  term_event_keyboard kbd;
  string str;
  
  term = ses->tab->term;
  if (((doc_view == (document_view *)0x0) || (cp_index = doc_view->vs->current_link, cp_index < 0))
     || (doc_view->document->nlinks <= cp_index)) {
    plVar5 = (link *)0x0;
  }
  else {
    plVar5 = doc_view->document->links + cp_index;
  }
  if ((assert_failed == 0) && (assert_failed = ZEXT14(plVar5 == (link *)0x0), plVar5 == (link *)0x0)
     ) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x788;
    elinks_internal((uchar *)"assertion link failed!");
  }
  fc = (form_control *)0x0;
  if (LINK_MAP < plVar5->type) {
    fc = (form_control *)plVar5->data;
  }
  msgid = get_form_label(fc);
  if ((msgid == (uchar *)0x0) || (psVar1 = init_string(&str), psVar1 == (string *)0x0)) {
    str.source = (uchar *)0x0;
  }
  else {
    if (*msgid != '\0') {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      msgid = gettext(msgid);
    }
    add_to_string(&str,msgid);
    msgid = extraout_EDX;
    if (((plVar5->type != LINK_BUTTON) && (codeset = fc->name, codeset != (uchar *)0x0)) &&
       (*codeset != '\0')) {
      add_form_attr_to_string(&str,term,"name",codeset);
      msgid = extraout_EDX_07;
    }
    if (fc->type < FC_RESET) {
      uVar2 = 1 << ((byte)fc->type & 0x1f);
      if ((uVar2 & 0x180) == 0) {
        if ((uVar2 & 0x30) == 0) {
          if ((uVar2 & 0xf) != 0) {
            if (fc->mode != FORM_MODE_NORMAL) {
              add_form_attr_to_string(&str,term,(uchar *)"read only",(uchar *)0x0);
              msgid = extraout_EDX_08;
            }
            if (ses->insert_mode == INSERT_MODE_OFF) {
              codeset = get_keystroke(0xe,KEYMAP_EDIT);
              msgid = extraout_EDX_09;
              if (codeset != (uchar *)0x0) {
                msg = "press %s to navigate";
                if (fc->mode == FORM_MODE_NORMAL) {
                  msg = "press %s to edit";
                }
                add_to_string(&str," (");
                msgid = _((uchar *)msg,term);
                add_format_to_string(&str,msgid,codeset);
                add_char_to_string(&str,')');
                mem_free(codeset);
                msgid = extraout_EDX_10;
              }
            }
            else {
              if (fc->type != FC_TEXTAREA) {
                if ((assert_failed == 0) &&
                   (bVar6 = fc->form == (form *)0x0, assert_failed = ZEXT14(bVar6), bVar6)) {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
                  errline = 0x7c6;
                  elinks_internal((uchar *)"assertion fc->form failed!");
                }
                msgid = fc->form->action;
                if ((msgid != (uchar *)0x0) &&
                   (((cp_index = has_form_submit(fc->form), cp_index == 0 ||
                     (piVar3 = get_opt_(config_options,name), msgid = extraout_EDX_00, *piVar3 != 0)
                     ) && (uri = get_uri(fc->form->action,0), msgid = extraout_EDX_01,
                          uri != (uri *)0x0)))) {
                  codeset = get_uri_string(uri,URI_PUBLIC);
                  done_uri(uri);
                  msgid = extraout_EDX_02;
                  if (codeset != (uchar *)0x0) {
                    msgid = get_keystroke(0xe,KEYMAP_EDIT);
                    if (msgid == (uchar *)0x0) {
                      mem_free(codeset);
                      msgid = extraout_EDX_11;
                    }
                    else {
                      msg = "press %s to submit to %s";
                      if (fc->form->method != FORM_METHOD_GET) {
                        msg = "press %s to post to %s";
                      }
                      add_to_string(&str," (");
                      format = _((uchar *)msg,term);
                      add_format_to_string(&str,format,msgid,codeset);
                      mem_free(codeset);
                      mem_free(msgid);
                      add_char_to_string(&str,')');
                      msgid = extraout_EDX_03;
                    }
                  }
                }
              }
            }
          }
        }
        else {
          pfVar4 = find_form_state(doc_view,fc);
          codeset = pfVar4->value;
          msgid = extraout_EDX_05;
          if ((codeset != (uchar *)0x0) && (*codeset != '\0')) {
            add_form_attr_to_string(&str,term,(uchar *)"value",codeset);
            msgid = extraout_EDX_06;
          }
        }
      }
      else {
        add_char_to_string(&str,' ');
        if ((assert_failed == 0) &&
           (bVar6 = fc->form == (form *)0x0, assert_failed = ZEXT14(bVar6), bVar6)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
          errline = 0x7ed;
          elinks_internal((uchar *)"assertion fc->form failed!");
        }
        add_string_uri_to_string(&str,fc->form->action,URI_PUBLIC);
        msgid = extraout_EDX_04;
      }
    }
    if ((plVar5->accesskey != 0) && (piVar3 = get_opt_(config_options,msgid), *piVar3 != 0)) {
      add_to_string(&str," (");
      kbd.key = plVar5->accesskey;
      kbd.modifier = KBD_MOD_ALT;
      add_keystroke_to_string(&str,&kbd,0);
      add_char_to_string(&str,')');
    }
  }
  return str.source;
}



void get_link_x_bounds(link *link,int y,int *min_x,int *max_x)

{
  int iVar1;
  int iVar2;
  int iVar3;
  
  if (min_x != (int *)0x0) {
    *min_x = 0x7fffffff;
  }
  if (max_x != (int *)0x0) {
    *max_x = 0;
  }
  if (link->npoints < 1) {
    return;
  }
  iVar2 = 0;
  iVar3 = 0;
  do {
    while ((-1 < y && (*(int *)((int)&link->points->y + iVar2) != y))) {
LAB_080f4cb9:
      iVar3 = iVar3 + 1;
      iVar2 = iVar2 + 8;
      if (link->npoints == iVar3 || link->npoints < iVar3) {
        return;
      }
    }
    if ((min_x != (int *)0x0) && (iVar1 = *(int *)((int)&link->points->x + iVar2), iVar1 < *min_x))
    {
      *min_x = iVar1;
    }
    if ((max_x == (int *)0x0) || (iVar1 = *(int *)((int)&link->points->x + iVar2), iVar1 <= *max_x))
    goto LAB_080f4cb9;
    *max_x = iVar1;
    iVar3 = iVar3 + 1;
    iVar2 = iVar2 + 8;
    if (link->npoints == iVar3 || link->npoints < iVar3) {
      return;
    }
  } while( true );
}



link * get_link_at_coordinates(document_view *doc_view,int x,int y)

{
  document *pdVar1;
  int iVar2;
  link *plVar3;
  link *plVar4;
  int iVar5;
  link *plVar6;
  int iVar7;
  int local_28;
  link *local_24;
  
  if (assert_failed == 0) {
    if (((doc_view == (document_view *)0x0) || (doc_view->vs == (view_state *)0x0)) ||
       (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x44f;
      elinks_internal((uchar *)"assertion doc_view && doc_view->vs && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080f4d98;
    }
    else {
      assert_failed = 0;
    }
    pdVar1 = doc_view->document;
    if (((pdVar1->nlinks != 0) && (-1 < x)) &&
       ((x < (doc_view->box).width && ((-1 < y && (iVar5 = (doc_view->box).height, y < iVar5)))))) {
      plVar6 = pdVar1->links;
      local_24 = plVar6 + pdVar1->nlinks;
      iVar2 = doc_view->vs->y;
      iVar5 = iVar2 + iVar5;
      iVar7 = pdVar1->height;
      if (iVar5 <= pdVar1->height) {
        iVar7 = iVar5;
      }
      iVar5 = iVar2 * 4;
      local_28 = iVar2;
      while (local_28 < iVar7) {
        plVar3 = *(link **)((int)pdVar1->lines1 + iVar5);
        plVar4 = local_24;
        if ((plVar3 != (link *)0x0) && (plVar4 = plVar3, local_24 <= plVar3)) {
          plVar4 = local_24;
        }
        local_24 = plVar4;
        plVar3 = *(link **)((int)pdVar1->lines2 + iVar5);
        if ((plVar3 != (link *)0x0) && (plVar6 < plVar3)) {
          plVar6 = plVar3;
        }
        local_28 = local_28 + 1;
        iVar5 = iVar5 + 4;
      }
      while (local_24 <= plVar6) {
        if (0 < local_24->npoints) {
          iVar5 = 0;
          do {
            if ((local_24->points[iVar5].x == x + doc_view->vs->x) &&
               (local_24->points[iVar5].y == iVar2 + y)) {
              return local_24;
            }
            iVar5 = iVar5 + 1;
          } while (iVar5 < local_24->npoints);
        }
        local_24 = local_24 + 1;
      }
    }
  }
  else {
LAB_080f4d98:
    assert_failed = 0;
  }
  return (link *)0x0;
}



void set_pos_y(document_view *doc_view,link *link)

{
  int iVar1;
  view_state *pvVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  
  if (assert_failed == 0) {
    if ((((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) ||
        (link == (link *)0x0)) || (doc_view->vs == (view_state *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x300;
      elinks_internal((uchar *)
                      "assertion doc_view && doc_view->document && doc_view->vs && link failed!");
      if (assert_failed != 0) goto LAB_080f4f80;
    }
    else {
      assert_failed = 0;
    }
    iVar4 = 0;
    iVar5 = doc_view->document->height;
    if (0 < link->npoints) {
      iVar3 = 0;
      do {
        iVar1 = link->points[iVar3].y;
        if (iVar4 < iVar1 + 1) {
          iVar4 = iVar1 + 1;
        }
        if (iVar1 < iVar5) {
          iVar5 = iVar1;
        }
        iVar3 = iVar3 + 1;
      } while (iVar3 != link->npoints);
    }
    doc_view->vs->y = ((iVar5 + iVar4) - (doc_view->box).height) / 2;
    pvVar2 = doc_view->vs;
    if (pvVar2->y < 0) {
      pvVar2->y = 0;
      return;
    }
    iVar5 = doc_view->document->height - (doc_view->box).height;
    if (iVar5 < pvVar2->y) {
      pvVar2->y = iVar5;
      return;
    }
  }
  else {
LAB_080f4f80:
    assert_failed = 0;
  }
  return;
}



void set_pos_x(document_view *doc_view,link *link)

{
  view_state *pvVar1;
  point *ppVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(link == (link *)0x0 || doc_view == (document_view *)0x0);
  if (link == (link *)0x0 || doc_view == (document_view *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x2e9;
    elinks_internal((uchar *)"assertion doc_view && link failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (0 < link->npoints) {
    pvVar1 = doc_view->vs;
    iVar6 = 0;
    ppVar2 = link->points;
    iVar4 = 0x7fffffff;
    iVar3 = 0;
    iVar5 = ppVar2->y - pvVar1->y;
    while( true ) {
      if ((-1 < iVar5) && (iVar5 < (doc_view->box).height)) {
        iVar5 = ppVar2[iVar3].x;
        if (iVar6 < iVar5 + 1) {
          iVar6 = iVar5 + 1;
        }
        if (iVar5 < iVar4) {
          iVar4 = iVar5;
        }
      }
      iVar3 = iVar3 + 1;
      if (iVar3 == link->npoints) break;
      iVar5 = ppVar2[iVar3].y - pvVar1->y;
    }
    if (iVar4 != 0x7fffffff) {
      iVar6 = iVar6 - (doc_view->box).width;
      if (pvVar1->x < iVar6) {
        pvVar1->x = iVar6;
        return;
      }
      if (iVar4 < pvVar1->x) {
        pvVar1->x = iVar4;
      }
    }
  }
  return;
}



int next_link_in_dir(document_view *doc_view,int dir_x,int dir_y)

{
  document *pdVar1;
  view_state *pvVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  link *plVar6;
  int y;
  link *link;
  int iVar7;
  bool bVar8;
  int local_58;
  int local_54;
  link **local_50;
  int local_38;
  link *local_30;
  int local_2c;
  int local_28;
  int local_24;
  int local_20 [4];
  
  if (assert_failed == 0) {
    local_20[0] = 0x7fffffff;
    local_24 = 0;
    if (((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) ||
       (doc_view->vs == (view_state *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x261;
      elinks_internal((uchar *)"assertion doc_view && doc_view->document && doc_view->vs failed!");
      if (assert_failed != 0) goto LAB_080f5198;
    }
    bVar8 = (dir_y | dir_x) == 0;
    assert_failed = ZEXT14(bVar8);
    if (bVar8) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x263;
      elinks_internal((uchar *)"assertion dir_x || dir_y failed!");
      if (assert_failed != 0) goto LAB_080f5198;
    }
    pdVar1 = doc_view->document;
    pvVar2 = doc_view->vs;
    y = pvVar2->current_link;
    if (((-1 < y) && (y < pdVar1->nlinks)) && (link = pdVar1->links + y, link != (link *)0x0)) {
      get_link_x_bounds(link,-1,local_20,&local_24);
      y = link->points->y;
      iVar7 = link->points[link->npoints + -1].y;
      if (dir_y != 0) {
        if (0 < dir_y) {
          y = iVar7;
        }
        y = dir_y + y;
        iVar7 = y * 4;
        iVar3 = doc_view->vs->y;
        iVar4 = 0;
        if (-1 < iVar3) {
          iVar4 = iVar3;
        }
        iVar3 = iVar3 + (doc_view->box).height;
        iVar5 = pdVar1->height;
        if (iVar3 <= pdVar1->height) {
          iVar5 = iVar3;
        }
        if (dir_y < 1) goto LAB_080f52e3;
LAB_080f523f:
        bVar8 = y < iVar5;
        do {
          if (!bVar8) {
            if (y == 0) {
              return 0;
            }
            if (pdVar1->height == y) {
              return 0;
            }
            pvVar2->current_link = -1;
            return 0;
          }
          link = *(link **)((int)pdVar1->lines1 + iVar7);
          if ((link != (link *)0x0) &&
             (plVar6 = (link *)pdVar1->lines2,
             link < *(link **)((int)plVar6 + iVar7) || link == *(link **)((int)plVar6 + iVar7))) {
            local_30 = (link *)0x0;
            do {
              while ((y < link->points->y || (link->points[link->npoints + -1].y < y))) {
LAB_080f5278:
                link = link + 1;
                if (*(link **)((int)plVar6 + iVar7) < link) goto LAB_080f52cb;
              }
              get_link_x_bounds(link,y,&local_28,&local_2c);
              if (local_28 <= local_24) {
                local_30 = link;
                if (local_2c < local_20[0]) {
LAB_080f52f6:
                  plVar6 = (link *)pdVar1->lines2;
                  local_30 = link;
                  goto LAB_080f5278;
                }
                goto chose_link;
              }
              if (local_30 == (link *)0x0) goto LAB_080f52f6;
              link = link + 1;
              plVar6 = (link *)pdVar1->lines2;
            } while (link <= *(link **)((int)&plVar6->accesskey + iVar7));
LAB_080f52cb:
            if (local_30 != (link *)0x0) {
chose_link:
              pvVar2->current_link = ((int)((int)local_30 - (int)pdVar1->links) >> 2) * -0x3b13b13b;
              set_pos_x(doc_view,local_30);
              return 1;
            }
          }
          y = y + dir_y;
          iVar7 = iVar7 + dir_y * 4;
          if (0 < dir_y) goto LAB_080f523f;
LAB_080f52e3:
          bVar8 = iVar4 <= y;
        } while( true );
      }
      iVar3 = local_20[0];
      if (0 < dir_x) {
        iVar3 = local_24;
      }
      local_38 = 0;
      iVar3 = iVar3 + dir_x * 2;
      while ((local_38 < (iVar7 + 1) - y && (-1 < iVar3))) {
        local_38 = 0;
        if (y <= iVar7) {
          local_50 = pdVar1->lines1 + y;
          local_58 = y * 4;
          local_54 = y;
          do {
            local_30 = *local_50;
            if (local_30 != (link *)0x0) {
              link = *(link **)((int)pdVar1->lines2 + local_58);
              while (local_30 <= link) {
                if (0 < local_30->npoints) {
                  iVar4 = 0;
                  do {
                    if (((local_30->points[iVar4].x == iVar3) &&
                        (iVar5 = local_30->points[iVar4].y, y <= iVar5)) && (iVar5 <= iVar7)) {
                      if (iVar5 != -1) goto chose_link;
                      break;
                    }
                    iVar4 = iVar4 + 1;
                  } while (iVar4 < local_30->npoints);
                }
                local_30 = local_30 + 1;
              }
              if (0 < link->npoints) {
                iVar4 = 0;
                do {
                  if ((local_54 == link->points[iVar4].y) &&
                     (iVar5 = link->points[iVar4].x, iVar3 <= iVar5)) {
                    if (iVar5 != -1) goto LAB_080f5459;
                    break;
                  }
                  iVar4 = iVar4 + 1;
                } while (iVar4 < link->npoints);
              }
              local_38 = local_38 + 1;
            }
LAB_080f5459:
            local_54 = local_54 + 1;
            local_50 = local_50 + 1;
            local_58 = local_58 + 4;
          } while (local_54 <= iVar7);
        }
        iVar3 = iVar3 + dir_x;
      }
    }
  }
  else {
LAB_080f5198:
    assert_failed = 0;
  }
  return 0;
}



int __regparm3
next_link_in_view_(document_view *doc_view,int current,int direction,
                  anon_subr_int_document_view_ptr_link_ptr *fn,
                  anon_subr_void_document_view_ptr_link_ptr *cntr)

{
  view_state *pvVar1;
  document *pdVar2;
  int iVar3;
  link **pplVar4;
  int iVar5;
  int iVar6;
  link **pplVar7;
  int iVar8;
  int local_24;
  int local_20;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  if ((((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) ||
      (fn == (anon_subr_int_document_view_ptr_link_ptr *)0x0)) ||
     (doc_view->vs == (view_state *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x1fc;
    elinks_internal((uchar *)
                    "assertion doc_view && doc_view->document && doc_view->vs && fn failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  else {
    assert_failed = 0;
  }
  pvVar1 = doc_view->vs;
  pdVar2 = doc_view->document;
  iVar8 = pvVar1->y;
  iVar3 = (doc_view->box).height + iVar8;
  iVar6 = pdVar2->height;
  if (iVar3 <= pdVar2->height) {
    iVar6 = iVar3;
  }
  local_20 = pdVar2->nlinks + -1;
  iVar3 = 0;
  if (-1 < iVar8) {
    iVar3 = iVar8;
  }
  iVar8 = 0;
  if (iVar3 < iVar6) {
    pplVar7 = pdVar2->lines1 + iVar3;
    pplVar4 = pdVar2->lines2 + iVar3;
    do {
      iVar5 = local_20;
      if ((*pplVar7 != (link *)0x0) &&
         (iVar5 = ((int)((int)*pplVar7 - (int)pdVar2->links) >> 2) * -0x3b13b13b, local_20 <= iVar5)
         ) {
        iVar5 = local_20;
      }
      local_20 = iVar5;
      if ((*pplVar4 != (link *)0x0) &&
         (iVar5 = ((int)((int)*pplVar4 - (int)pdVar2->links) >> 2) * -0x3b13b13b, iVar8 < iVar5)) {
        iVar8 = iVar5;
      }
      iVar3 = iVar3 + 1;
      pplVar7 = pplVar7 + 1;
      pplVar4 = pplVar4 + 1;
    } while (iVar3 < iVar6);
  }
  if ((local_20 <= current) && (current <= iVar8)) {
    iVar6 = current * 0x34;
    iVar3 = direction + current;
    local_24 = current;
    do {
      iVar5 = (*fn)(doc_view,(link *)((int)&pdVar2->links->accesskey + iVar6));
      if (iVar5 != 0) {
        pvVar1->current_link = local_24;
        if (cntr != (anon_subr_void_document_view_ptr_link_ptr *)0x0) {
          (*cntr)(doc_view,(link *)((int)&pdVar2->links->accesskey + iVar6));
          return 1;
        }
        return 1;
      }
      local_24 = local_24 + direction;
      if (iVar3 < local_20) break;
      iVar3 = iVar3 + direction;
      iVar6 = iVar6 + direction * 0x34;
    } while (iVar3 - direction <= iVar8);
  }
  pvVar1->current_link = -1;
  return 0;
}



int next_link_in_view_y(document_view *doc_view,int current,int direction)

{
  int iVar1;
  
  iVar1 = next_link_in_view_(doc_view,current,direction,link_in_view_y,set_pos_x);
  return iVar1;
}



int next_link_in_view(document_view *doc_view,int current,int direction)

{
  int iVar1;
  
  iVar1 = next_link_in_view_(doc_view,current,direction,link_in_view,
                             (anon_subr_void_document_view_ptr_link_ptr *)0x0);
  return iVar1;
}



void __regparm3 find_link(document_view *doc_view,int direction,int page_mode)

{
  link *plVar1;
  int iVar2;
  int current;
  int iVar3;
  link *link;
  int iVar4;
  link **pplVar5;
  int iVar6;
  view_state *local_28;
  document *local_20;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if (((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) ||
     (doc_view->vs == (view_state *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x318;
    elinks_internal((uchar *)"assertion doc_view && doc_view->document && doc_view->vs failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  if (direction == -1) {
    local_20 = doc_view->document;
    if (local_20->lines2 == (link **)0x0) goto LAB_080f58d3;
    local_28 = doc_view->vs;
    current = local_28->y;
    iVar2 = local_20->height;
    iVar4 = (doc_view->box).height + current;
    iVar3 = iVar4 + -1;
    if (iVar2 + -1 < iVar4 + -1) {
      iVar3 = iVar2 + -1;
    }
    if (iVar3 < 0) goto LAB_080f58d9;
    iVar6 = 0;
    if (-1 < current) {
      iVar6 = current;
    }
    if (iVar4 <= iVar2) {
      iVar2 = iVar4;
    }
    link = (link *)0x0;
    pplVar5 = local_20->lines2 + iVar3;
    do {
      plVar1 = *pplVar5;
      iVar3 = iVar3 + -1;
      if ((plVar1 != (link *)0x0) && ((link < plVar1 || (link == (link *)0x0)))) {
        link = plVar1;
      }
    } while ((iVar6 <= iVar3) && (pplVar5 = pplVar5 + -1, iVar3 < iVar2));
  }
  else {
    local_20 = doc_view->document;
    if (local_20->lines1 == (link **)0x0) {
LAB_080f58d3:
      local_28 = doc_view->vs;
      goto LAB_080f58d9;
    }
    local_28 = doc_view->vs;
    current = local_28->y;
    iVar2 = local_20->height;
    iVar3 = 0;
    if (-1 < current) {
      iVar3 = current;
    }
    if (iVar2 <= iVar3) goto LAB_080f58d9;
    current = current + (doc_view->box).height;
    pplVar5 = local_20->lines1 + iVar3;
    if (current <= iVar2) {
      iVar2 = current;
    }
    link = (link *)0x0;
    current = iVar3;
    do {
      plVar1 = *pplVar5;
      current = current + 1;
      if ((plVar1 != (link *)0x0) && ((plVar1 < link || (link == (link *)0x0)))) {
        link = plVar1;
      }
    } while ((iVar3 <= current) && (pplVar5 = pplVar5 + 1, current < iVar2));
  }
  if (link != (link *)0x0) {
    current = ((int)((int)link - (int)local_20->links) >> 2) * -0x3b13b13b;
    if (page_mode != 0) {
      next_link_in_view(doc_view,current,direction);
      return;
    }
    local_28->current_link = current;
    set_pos_x(doc_view,link);
    return;
  }
LAB_080f58d9:
  local_28->current_link = -1;
  return;
}



void find_link_page_down(document_view *doc_view)

{
  find_link(doc_view,1,1);
  return;
}



void find_link_down(document_view *doc_view)

{
  find_link(doc_view,1,0);
  return;
}



void find_link_page_up(document_view *doc_view)

{
  find_link(doc_view,-1,1);
  return;
}



void find_link_up(document_view *doc_view)

{
  find_link(doc_view,-1,0);
  return;
}



int link_in_view_y(document_view *doc_view,link *link)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(link == (link *)0x0 || doc_view == (document_view *)0x0);
    if (link == (link *)0x0 || doc_view == (document_view *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x1b7;
      elinks_internal((uchar *)"assertion doc_view && link failed!");
      if (assert_failed != 0) goto LAB_080f5aa8;
    }
    iVar3 = (doc_view->box).height;
    iVar1 = doc_view->vs->y;
    if (link->npoints < 1) {
      return 0;
    }
    iVar2 = link->points->y - iVar1;
    if ((iVar3 <= iVar2) || (iVar2 < 0)) {
      iVar2 = 0;
      do {
        iVar2 = iVar2 + 1;
        if (link->npoints <= iVar2) {
          return 0;
        }
        iVar4 = link->points[iVar2].y - iVar1;
      } while ((iVar3 <= iVar4) || (iVar4 < 0));
    }
    iVar3 = 1;
  }
  else {
LAB_080f5aa8:
    assert_failed = 0;
    iVar3 = 0;
  }
  return iVar3;
}



int link_in_view(document_view *doc_view,link *link)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  bool bVar6;
  bool bVar7;
  
  if (assert_failed == 0) {
    bVar6 = link == (link *)0x0;
    bVar7 = doc_view == (document_view *)0x0;
    uVar5 = (uint)(bVar7 || bVar6);
    assert_failed = uVar5;
    if (bVar7 || bVar6) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x1ca;
      elinks_internal((uchar *)"assertion doc_view && link failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return 0;
      }
    }
    iVar2 = link_in_view_y(doc_view,link);
    if (iVar2 == 0) {
      return 0;
    }
    if (assert_failed == 0) {
      assert_failed = uVar5;
      if (bVar7 || bVar6) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
        errline = 0x1a2;
        elinks_internal((uchar *)"assertion doc_view && link failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return 0;
        }
      }
      iVar2 = (doc_view->box).width;
      iVar1 = doc_view->vs->x;
      if (0 < link->npoints) {
        iVar3 = link->points->x - iVar1;
        if ((iVar2 <= iVar3) || (iVar3 < 0)) {
          iVar3 = 0;
          do {
            iVar3 = iVar3 + 1;
            if (link->npoints <= iVar3) {
              return 0;
            }
            iVar4 = link->points[iVar3].x - iVar1;
          } while ((iVar2 <= iVar4) || (iVar4 < 0));
        }
        return 1;
      }
      return 0;
    }
  }
  assert_failed = 0;
  return 0;
}



int current_link_is_visible(document_view *doc_view)

{
  link *link;
  int iVar1;
  
  if (assert_failed == 0) {
    if ((doc_view == (document_view *)0x0) || (doc_view->vs == (view_state *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x1d4;
      elinks_internal((uchar *)"assertion doc_view && doc_view->vs failed!");
      if (assert_failed != 0) goto LAB_080f5c78;
      if (doc_view == (document_view *)0x0) {
        return 0;
      }
    }
    else {
      assert_failed = 0;
    }
    iVar1 = doc_view->vs->current_link;
    if (((-1 < iVar1) && (iVar1 < doc_view->document->nlinks)) &&
       (link = doc_view->document->links + iVar1, link != (link *)0x0)) {
      iVar1 = link_in_view(doc_view,link);
      return (uint)(iVar1 != 0);
    }
  }
  else {
LAB_080f5c78:
    assert_failed = 0;
  }
  return 0;
}



link * get_last_link(document_view *doc_view)

{
  int iVar1;
  link *plVar2;
  link **pplVar3;
  int iVar4;
  int iVar5;
  
  if (assert_failed == 0) {
    if ((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x18b;
      elinks_internal((uchar *)"assertion doc_view && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080f5dc0;
    }
    else {
      assert_failed = 0;
    }
    pplVar3 = doc_view->document->lines2;
    if (pplVar3 != (link **)0x0) {
      iVar1 = doc_view->vs->y;
      iVar5 = (doc_view->box).height + iVar1;
      iVar4 = 0;
      if (-1 < iVar1) {
        iVar4 = iVar1;
      }
      iVar1 = doc_view->document->height;
      if (iVar1 < iVar5) {
        iVar5 = iVar1;
      }
      if (iVar4 < iVar5) {
        pplVar3 = pplVar3 + iVar4;
        plVar2 = (link *)0x0;
        do {
          if (plVar2 < *pplVar3) {
            plVar2 = *pplVar3;
          }
          iVar4 = iVar4 + 1;
          pplVar3 = pplVar3 + 1;
        } while (iVar4 < iVar5);
        return plVar2;
      }
    }
  }
  else {
LAB_080f5dc0:
    assert_failed = 0;
  }
  return (link *)0x0;
}



link * get_first_link(document_view *doc_view)

{
  document *pdVar1;
  int iVar2;
  link *plVar3;
  link *plVar4;
  int iVar5;
  link **pplVar6;
  int iVar7;
  
  if (assert_failed == 0) {
    if ((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x16e;
      elinks_internal((uchar *)"assertion doc_view && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080f5eb0;
    }
    else {
      assert_failed = 0;
    }
    pdVar1 = doc_view->document;
    if (pdVar1->lines1 != (link **)0x0) {
      iVar2 = doc_view->vs->y;
      iVar7 = iVar2 + (doc_view->box).height;
      iVar5 = 0;
      if (-1 < iVar2) {
        iVar5 = iVar2;
      }
      if (pdVar1->height < iVar7) {
        iVar7 = pdVar1->height;
      }
      if (iVar5 < iVar7) {
        pplVar6 = pdVar1->lines1 + iVar5;
        plVar4 = pdVar1->links + pdVar1->nlinks;
        do {
          plVar3 = *pplVar6;
          if ((plVar3 != (link *)0x0) && (plVar3 < plVar4)) {
            plVar4 = plVar3;
          }
          iVar5 = iVar5 + 1;
          pplVar6 = pplVar6 + 1;
        } while (iVar5 < iVar7);
        if (plVar4 != pdVar1->links + pdVar1->nlinks) {
          return plVar4;
        }
      }
    }
  }
  else {
LAB_080f5eb0:
    assert_failed = 0;
  }
  return (link *)0x0;
}



void set_link(document_view *doc_view)

{
  int iVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(doc_view == (document_view *)0x0);
  if (doc_view == (document_view *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x68;
    elinks_internal((uchar *)"assertion doc_view failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  iVar1 = current_link_is_visible(doc_view);
  if (iVar1 == 0) {
    find_link_page_down(doc_view);
    return;
  }
  return;
}



uchar * __regparm3 _(uchar *msg,terminal *term)

{
  int cp_index;
  uchar *codeset;
  
  if ((msg != (uchar *)0x0) && (*msg != '\0')) {
    if (term != (terminal *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    msg = gettext(msg);
  }
  return msg;
}



uchar * get_current_link_info(session *ses,document_view *doc_view)

{
  document *pdVar1;
  int iVar2;
  terminal *term;
  uchar *source;
  string *psVar3;
  int *piVar4;
  uchar *name;
  link *plVar5;
  uchar *local_30;
  term_event_keyboard kbd;
  string str;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (uchar *)0x0;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (doc_view->document == (document *)0x0)) || (doc_view->vs == (view_state *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x5a0;
    elinks_internal((uchar *)
                    "assertion ses && doc_view && doc_view->document && doc_view->vs failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (uchar *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  pdVar1 = doc_view->document;
  if (((pdVar1->frame_desc == (frameset_desc *)0x0) &&
      (iVar2 = doc_view->vs->current_link, -1 < iVar2)) &&
     ((iVar2 < pdVar1->nlinks && (plVar5 = pdVar1->links + iVar2, plVar5 != (link *)0x0)))) {
    if (plVar5->type < LINK_BUTTON) {
      term = ses->tab->term;
      local_30 = plVar5->where;
      psVar3 = init_string(&str);
      if (psVar3 != (string *)0x0) {
        if ((plVar5->where == (uchar *)0x0) && (plVar5->where_img != (uchar *)0x0)) {
          source = _((uchar *)"Image",term);
          add_to_string(&str,source);
          add_char_to_string(&str,' ');
          local_30 = plVar5->where_img;
        }
        else {
          if (plVar5->type == LINK_MAP) {
            source = _((uchar *)"Usemap",term);
            add_to_string(&str,source);
            add_char_to_string(&str,' ');
          }
        }
        add_string_uri_to_string(&str,local_30,URI_PUBLIC);
        if ((plVar5->accesskey != 0) && (piVar4 = get_opt_(config_options,name), *piVar4 != 0)) {
          add_to_string(&str," (");
          kbd.key = plVar5->accesskey;
          kbd.modifier = KBD_MOD_ALT;
          add_keystroke_to_string(&str,&kbd,0);
          add_char_to_string(&str,')');
        }
        if ((*(byte *)&term->field_0x38 & 2) == 0) {
          decode_uri_string_for_display(&str);
          return str.source;
        }
        decode_uri_string(&str);
        return str.source;
      }
    }
    else {
      if (plVar5->data != 0) {
        source = get_form_info(ses,doc_view);
        return source;
      }
    }
  }
  return (uchar *)0x0;
}



uchar * get_current_link_title(document_view *doc_view)

{
  uchar uVar1;
  document *pdVar2;
  int iVar3;
  conv_table *convert_table;
  ushort **ppuVar4;
  uint uVar5;
  byte *pbVar6;
  byte *pbVar7;
  link *plVar8;
  uchar *puVar9;
  byte bVar10;
  
  bVar10 = 0;
  if (assert_failed == 0) {
    if (((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) ||
       (doc_view->vs == (view_state *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x57a;
      elinks_internal((uchar *)"assertion doc_view && doc_view->document && doc_view->vs failed!");
      if (assert_failed != 0) goto LAB_080f6278;
    }
    else {
      assert_failed = 0;
    }
    pdVar2 = doc_view->document;
    if ((((pdVar2->frame_desc == (frameset_desc *)0x0) &&
         (iVar3 = doc_view->vs->current_link, -1 < iVar3)) &&
        ((iVar3 < pdVar2->nlinks &&
         ((plVar8 = pdVar2->links + iVar3, plVar8 != (link *)0x0 && (plVar8->title != (uchar *)0x0))
         )))) && (*plVar8->title != '\0')) {
      convert_table = get_translation_table(pdVar2->cp,(pdVar2->options).cp);
      uVar5 = 0xffffffff;
      puVar9 = plVar8->title;
      do {
        if (uVar5 == 0) break;
        uVar5 = uVar5 - 1;
        uVar1 = *puVar9;
        puVar9 = puVar9 + (uint)bVar10 * -2 + 1;
      } while (uVar1 != '\0');
      pbVar7 = convert_string_elinks
                         (convert_table,plVar8->title,~uVar5 - 1,(doc_view->document->options).cp,
                          CSM_DEFAULT,(int *)0x0,(anon_subr_void_void_ptr_uchar_ptr_int *)0x0,
                          (void *)0x0);
      if (((pbVar7 != (byte *)0x0) &&
          ((*(byte *)&(doc_view->document->options).field_0x5c & 0x10) == 0)) &&
         (bVar10 = *pbVar7, bVar10 != 0)) {
        ppuVar4 = __ctype_b_loc();
        pbVar6 = pbVar7;
        do {
          if (((*ppuVar4)[bVar10] & 0x4002) != 0x4000) {
            *pbVar6 = 0x2a;
          }
          pbVar6 = pbVar6 + 1;
          bVar10 = *pbVar6;
        } while (bVar10 != 0);
      }
    }
    else {
      pbVar7 = (byte *)0x0;
    }
  }
  else {
LAB_080f6278:
    assert_failed = 0;
    pbVar7 = (byte *)0x0;
  }
  return pbVar7;
}



void link_menu(terminal *term,void *xxx,void *ses_)

{
  int iVar1;
  document_view *pdVar2;
  int *piVar3;
  string *psVar4;
  uchar *name;
  uchar *name_00;
  uchar *name_01;
  uchar *extraout_EDX;
  link *plVar5;
  string keystroke;
  menu_item *local_20 [4];
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(ses_ == (void *)0x0 || term == (terminal *)0x0);
  if (ses_ == (void *)0x0 || term == (terminal *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x4f7;
    elinks_internal((uchar *)"assertion term && ses failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  pdVar2 = current_frame((session *)ses_);
  local_20[0] = new_menu(FREE_LIST);
  if (local_20[0] == (menu_item *)0x0) {
    return;
  }
  if (pdVar2 == (document_view *)0x0) goto end;
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if ((pdVar2->vs == (view_state *)0x0) || (pdVar2->document == (document *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x4ff;
    elinks_internal((uchar *)"assertion doc_view->vs && doc_view->document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  iVar1 = pdVar2->vs->current_link;
  if (((iVar1 < 0) || (pdVar2->document->nlinks <= iVar1)) ||
     (plVar5 = pdVar2->document->links + iVar1, plVar5 == (link *)0x0)) goto end;
  if (plVar5->where == (uchar *)0x0) {
LAB_080f6898:
    if (LINK_MAP < plVar5->type) goto LAB_080f6451;
  }
  else {
    if (plVar5->type < LINK_BUTTON) {
      if (plVar5->type == LINK_MAP) {
        add_to_menu(local_20,(uchar *)"Display ~usemap",(uchar *)0x0,ACT_MAIN_LINK_FOLLOW,
                    (menu_func_T *)0x0,(void *)0x0,SUBMENU);
      }
      else {
        add_to_menu(local_20,(uchar *)"~Follow link",(uchar *)0x0,ACT_MAIN_LINK_FOLLOW,
                    (menu_func_T *)0x0,(void *)0x0,NO_FLAG);
        add_to_menu(local_20,(uchar *)"Follow link and r~eload",(uchar *)0x0,
                    ACT_MAIN_LINK_FOLLOW_RELOAD,(menu_func_T *)0x0,(void *)0x0,NO_FLAG);
        add_to_menu(local_20,"",(uchar *)0x0,ACT_MAIN_NONE,(menu_func_T *)0x0,(void *)0x0,NO_SELECT)
        ;
        add_new_win_to_menu(local_20,(uchar *)"Open in new ~window",term);
        add_to_menu(local_20,(uchar *)"Open in new ~tab",(uchar *)0x0,ACT_MAIN_OPEN_LINK_IN_NEW_TAB,
                    (menu_func_T *)0x0,(void *)0x0,NO_FLAG);
        add_to_menu(local_20,(uchar *)"Open in new tab in ~background",(uchar *)0x0,
                    ACT_MAIN_OPEN_LINK_IN_NEW_TAB_IN_BACKGROUND,(menu_func_T *)0x0,(void *)0x0,
                    NO_FLAG);
        piVar3 = get_opt_(cmdline_options,name_01);
        if (*piVar3 == 0) {
          add_to_menu(local_20,"",(uchar *)0x0,ACT_MAIN_NONE,(menu_func_T *)0x0,(void *)0x0,
                      NO_SELECT);
          add_to_menu(local_20,(uchar *)"~Download link",(uchar *)0x0,ACT_MAIN_LINK_DOWNLOAD,
                      (menu_func_T *)0x0,(void *)0x0,NO_FLAG);
          add_to_menu(local_20,(uchar *)"~Add link to bookmarks",(uchar *)0x0,
                      ACT_MAIN_ADD_BOOKMARK_LINK,(menu_func_T *)0x0,(void *)0x0,NO_FLAG);
          add_uri_command_to_menu
                    (local_20,PASS_URI_LINK,(uchar *)"Pass link URI to e~xternal command");
        }
      }
      goto LAB_080f6898;
    }
LAB_080f6451:
    name = (uchar *)plVar5->data;
    if (name != (uchar *)0x0) {
      if (*(int *)(name + 0x14) == 3) {
        if (*(int *)(name + 0x18) == 0) {
          psVar4 = init_string(&keystroke);
          if (psVar4 != (string *)0x0) {
            add_keystroke_action_to_string(&keystroke,0x17,KEYMAP_EDIT);
          }
          add_to_menu(local_20,(uchar *)"Open in ~external editor",keystroke.source,ACT_MAIN_NONE,
                      menu_textarea_edit,(void *)0x0,FREE_RTEXT);
        }
LAB_080f6474:
        add_to_menu(local_20,(uchar *)"~Submit form",(uchar *)0x0,ACT_MAIN_SUBMIT_FORM,
                    (menu_func_T *)0x0,(void *)0x0,NO_FLAG);
        add_to_menu(local_20,(uchar *)"Submit form and rel~oad",(uchar *)0x0,
                    ACT_MAIN_SUBMIT_FORM_RELOAD,(menu_func_T *)0x0,(void *)0x0,NO_FLAG);
        if ((assert_failed == 0) &&
           (assert_failed = ZEXT14(*(int *)(name + 8) == 0), *(int *)(name + 8) == 0)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
          errline = 0x548;
          elinks_internal((uchar *)"assertion fc->form failed!");
        }
        if (*(int *)(*(int *)(name + 8) + 0x20) == 0) {
          add_new_win_to_menu(local_20,(uchar *)"Submit form and open in new ~window",term);
          add_to_menu(local_20,(uchar *)"Submit form and open in new ~tab",(uchar *)0x0,
                      ACT_MAIN_OPEN_LINK_IN_NEW_TAB,(menu_func_T *)0x0,(void *)0x0,NO_FLAG);
          add_to_menu(local_20,(uchar *)"Submit form and open in new tab in ~background",
                      (uchar *)0x0,ACT_MAIN_OPEN_LINK_IN_NEW_TAB_IN_BACKGROUND,(menu_func_T *)0x0,
                      (void *)0x0,NO_FLAG);
          name = extraout_EDX;
        }
        piVar3 = get_opt_(cmdline_options,name);
        if (*piVar3 == 0) {
          add_to_menu(local_20,(uchar *)"Submit form and ~download",(uchar *)0x0,
                      ACT_MAIN_LINK_DOWNLOAD,(menu_func_T *)0x0,(void *)0x0,NO_FLAG);
        }
      }
      else {
        if (*(int *)(name + 0x14) != 9) goto LAB_080f6474;
      }
      add_to_menu(local_20,(uchar *)"~Reset form",(uchar *)0x0,ACT_MAIN_RESET_FORM,
                  (menu_func_T *)0x0,(void *)0x0,NO_FLAG);
      add_to_menu(local_20,(uchar *)"Form f~ields",(uchar *)0x0,ACT_MAIN_LINK_FORM_MENU,
                  (menu_func_T *)0x0,(void *)0x0,SUBMENU);
    }
  }
  if (plVar5->where_img != (uchar *)0x0) {
    add_to_menu(local_20,(uchar *)"V~iew image",(uchar *)0x0,ACT_MAIN_VIEW_IMAGE,(menu_func_T *)0x0,
                (void *)0x0,NO_FLAG);
    piVar3 = get_opt_(cmdline_options,name_00);
    if (*piVar3 == 0) {
      add_to_menu(local_20,(uchar *)"Download ima~ge",(uchar *)0x0,ACT_MAIN_LINK_DOWNLOAD_IMAGE,
                  (menu_func_T *)0x0,(void *)0x0,NO_FLAG);
    }
  }
end:
  if (local_20[0]->text == (uchar *)0x0) {
    add_to_menu(local_20,(uchar *)"No link selected",(uchar *)0x0,ACT_MAIN_NONE,(menu_func_T *)0x0,
                (void *)0x0,NO_SELECT);
  }
  do_menu(term,local_20[0],ses_,1);
  return;
}



void jump_to_link_number(session *ses,document_view *doc_view,int n)

{
  link_type lVar1;
  form_control *fc;
  uchar *puVar2;
  int iVar3;
  form_state *fs;
  byte bVar4;
  link *plVar5;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x480;
    elinks_internal((uchar *)
                    "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  if (n < 0) {
    return;
  }
  if (doc_view->document->nlinks <= n) {
    return;
  }
  doc_view->vs->current_link = n;
  if (ses->navigate_mode != NAVIGATE_CURSOR_ROUTING) goto LAB_080f6bda;
  iVar3 = doc_view->vs->current_link;
  if ((iVar3 < 0) || (doc_view->document->nlinks <= iVar3)) {
    plVar5 = (link *)0x0;
  }
  else {
    plVar5 = doc_view->document->links + iVar3;
  }
  lVar1 = plVar5->type;
  iVar3 = 1;
  bVar4 = *(byte *)&doc_view->session->tab->term->field_0x38 >> 1;
  if (lVar1 != LINK_CHECKBOX) {
    if (lVar1 < LINK_SELECT) {
      iVar3 = 2;
      if (lVar1 != LINK_BUTTON) {
        iVar3 = 0;
      }
    }
    else {
      if (lVar1 == LINK_FIELD) {
        fs = find_form_state(doc_view,(form_control *)plVar5->data);
        if ((fs != (form_state *)0x0) && (puVar2 = fs->value, puVar2 != (uchar *)0x0)) {
          if ((bVar4 & 1) == 0) {
            iVar3 = fs->state - fs->vpos;
          }
          else {
            if (fs->type == FC_PASSWORD) {
              iVar3 = utf8_ptr2chars(puVar2 + fs->vpos,puVar2 + fs->state);
            }
            else {
              iVar3 = utf8_ptr2cells(puVar2 + fs->vpos,puVar2 + fs->state);
            }
          }
          goto LAB_080f6c40;
        }
      }
      else {
        if (lVar1 == LINK_AREA) {
          fc = (form_control *)plVar5->data;
          fs = find_form_state(doc_view,fc);
          if (fs != (form_state *)0x0) {
            iVar3 = area_cursor(fc,fs,(uint)bVar4 & 1);
            goto LAB_080f6c40;
          }
        }
      }
      iVar3 = 0;
    }
  }
LAB_080f6c40:
  if (plVar5->npoints != iVar3 && iVar3 <= plVar5->npoints) {
    move_cursor(ses,doc_view,((doc_view->box).x + plVar5->points[iVar3].x) - doc_view->vs->x,
                ((doc_view->box).y + plVar5->points[iVar3].y) - doc_view->vs->y);
  }
LAB_080f6bda:
  check_vs(doc_view);
  return;
}



uri * get_link_uri(session *ses,document_view *doc_view,link *link)

{
  link_type lVar1;
  uchar *string;
  uri *puVar2;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (uri *)0x0;
  }
  if (((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) || (link == (link *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x371;
    elinks_internal((uchar *)"assertion ses && doc_view && link failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (uri *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  lVar1 = link->type;
  if (lVar1 != LINK_BUTTON) {
    if (lVar1 < LINK_BUTTON) {
      string = link->where;
      if (string == (uchar *)0x0) {
        string = link->where_img;
      }
      puVar2 = get_uri(string,0);
      return puVar2;
    }
    if (lVar1 != LINK_FIELD) {
      return (uri *)0x0;
    }
  }
  puVar2 = get_form_uri(ses,doc_view,(form_control *)link->data);
  return puVar2;
}



link * goto_current_link(session *ses,document_view *doc_view,int do_reload)

{
  int iVar1;
  form_control *fc;
  uri *uri;
  uchar *target;
  link *link;
  bool bVar2;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(doc_view == (document_view *)0x0 || ses == (session *)0x0);
    if (doc_view == (document_view *)0x0 || ses == (session *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x3c2;
      elinks_internal((uchar *)"assertion doc_view && ses failed!");
      if (assert_failed != 0) goto LAB_080f6f78;
    }
    if (doc_view == (document_view *)0x0) {
      return (link *)0x0;
    }
    iVar1 = doc_view->vs->current_link;
    if (iVar1 < 0) {
      return (link *)0x0;
    }
    if (doc_view->document->nlinks <= iVar1) {
      return (link *)0x0;
    }
    link = doc_view->document->links + iVar1;
    if (link == (link *)0x0) {
      return (link *)0x0;
    }
    if (link->type < LINK_BUTTON) {
      uri = get_link_uri(ses,doc_view,link);
      if (uri == (uri *)0x0) {
        return (link *)0x0;
      }
      if (link->type == LINK_MAP) {
        target = (uchar *)0x0;
        if (link->target != (uchar *)0x0) {
          target = stracpy(link->target);
        }
        goto_imgmap(ses,uri,target);
      }
      else {
        goto_uri_frame(ses,uri,link->target,(-(uint)(do_reload == 0) & 0xfffffffe) + 3);
      }
      done_uri(uri);
      return link;
    }
    fc = (form_control *)link->data;
    if (fc->type == FC_BUTTON) {
      return link;
    }
    bVar2 = fc->form == (form *)0x0;
    assert_failed = ZEXT14(bVar2);
    if (bVar2) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x38b;
      elinks_internal((uchar *)"assertion fc->form failed!");
      if (assert_failed != 0) goto LAB_080f6f78;
    }
    uri = get_form_uri(ses,doc_view,fc);
    if (uri != (uri *)0x0) {
      goto_uri_frame(ses,uri,fc->form->target,(-(uint)(do_reload == 0) & 0xfffffffe) + 3);
      done_uri(uri);
      return link;
    }
  }
  else {
LAB_080f6f78:
    assert_failed = 0;
  }
  return (link *)0x0;
}



frame_event_status enter(session *ses,document_view *doc_view,int do_reload)

{
  form_control *fc;
  frame_event_status fVar1;
  link *plVar2;
  form_state *pfVar3;
  document *pdVar4;
  int iVar5;
  uint uVar6;
  form_control *fc_00;
  form *pfVar7;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_REFRESH;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x438;
    elinks_internal((uchar *)
                    "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_REFRESH;
    }
  }
  else {
    assert_failed = 0;
  }
  if (((doc_view == (document_view *)0x0) || (iVar5 = doc_view->vs->current_link, iVar5 < 0)) ||
     ((pdVar4 = doc_view->document, pdVar4->nlinks <= iVar5 ||
      (plVar2 = pdVar4->links + iVar5, plVar2 == (link *)0x0)))) {
LAB_080f70fd:
    fVar1 = FRAME_EVENT_REFRESH;
  }
  else {
    if (LINK_AREA < plVar2->type) {
LAB_080f7119:
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x42d;
      elinks_internal((uchar *)"bad link type %d",plVar2->type);
      return FRAME_EVENT_REFRESH;
    }
    uVar6 = 1 << ((byte)plVar2->type & 0x1f);
    if ((uVar6 & 0x67) == 0) {
      if ((uVar6 & 0x10) == 0) {
        if ((uVar6 & 8) == 0) goto LAB_080f7119;
        fc = (form_control *)plVar2->data;
        if ((fc->mode == FORM_MODE_NORMAL) &&
           (pfVar3 = find_form_state(doc_view,fc), pfVar3 != (form_state *)0x0)) {
          if (fc->type == FC_CHECKBOX) {
            pfVar3->state = (uint)(pfVar3->state == 0);
            return FRAME_EVENT_REFRESH;
          }
          pfVar3->state = 1;
          pdVar4 = doc_view->document;
          pfVar7 = (form *)(pdVar4->forms).next;
          if (pfVar7 != (form *)&pdVar4->forms) {
            do {
              if (fc->form == pfVar7) {
                fc_00 = (form_control *)(pfVar7->items).next;
                if (fc_00 != (form_control *)&pfVar7->items) {
                  do {
                    if ((((fc_00->type == FC_RADIO) &&
                         (iVar5 = xstrcmp(fc_00->name,fc->name), iVar5 == 0)) && (fc != fc_00)) &&
                       (pfVar3 = find_form_state(doc_view,fc_00), pfVar3 != (form_state *)0x0)) {
                      pfVar3->state = 0;
                    }
                    fc_00 = fc_00->next;
                  } while (fc_00 != (form_control *)&pfVar7->items);
                  pdVar4 = doc_view->document;
                }
              }
              pfVar7 = pfVar7->next;
            } while (pfVar7 != (form *)&pdVar4->forms);
          }
          goto LAB_080f70fd;
        }
      }
      else {
        iVar5 = plVar2->data;
        if (*(int *)(iVar5 + 0x18) == 0) {
          (pdVar4->object).refcount = (pdVar4->object).refcount + 1;
          add_empty_window(ses->tab->term,release_document,doc_view->document);
          do_select_submenu(ses->tab->term,*(void **)(iVar5 + 0x50),ses);
          return FRAME_EVENT_REFRESH;
        }
      }
    }
    else {
      plVar2 = goto_current_link(ses,doc_view,do_reload);
      if (plVar2 == (link *)0x0) goto LAB_080f70fd;
    }
    fVar1 = FRAME_EVENT_OK;
  }
  return fVar1;
}



void __regparm3 goto_link_number_do(session *ses,document_view *doc_view,int n)

{
  int *piVar1;
  uchar *name;
  
  if (assert_failed == 0) {
    if (((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
       (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x49d;
      elinks_internal((uchar *)"assertion ses && doc_view && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080f7338;
    }
    else {
      assert_failed = 0;
    }
    if ((-1 < n) && (n < doc_view->document->nlinks)) {
      jump_to_link_number(ses,doc_view,n);
      if (1 < doc_view->document->links[n].type + ~LINK_SELECT) {
        piVar1 = get_opt_(config_options,name);
        if (*piVar1 != 0) {
          enter(ses,doc_view,0);
        }
      }
    }
  }
  else {
LAB_080f7338:
    assert_failed = 0;
  }
  return;
}



frame_event_status try_document_key(session *ses,document_view *doc_view,term_event *ev)

{
  unicode_val_T uVar1;
  int iVar2;
  document *pdVar3;
  unicode_val_T uVar4;
  unicode_val_T *puVar5;
  link *plVar6;
  int n;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_IGNORED;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (doc_view->document == (document *)0x0)) ||
     ((ev == (term_event *)0x0 || (doc_view->vs == (view_state *)0x0)))) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x4bd;
    elinks_internal((uchar *)
                    "assertion ses && doc_view && doc_view->document && doc_view->vs && ev failed!")
    ;
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_IGNORED;
    }
    n = *(int *)((int)&ev->info + 4);
  }
  else {
    assert_failed = 0;
    n = *(int *)((int)&ev->info + 4);
  }
  if ((n == 4) && (uVar1 = *(unicode_val_T *)&ev->info, -1 < (int)uVar1)) {
    iVar2 = doc_view->vs->current_link;
    pdVar3 = doc_view->document;
    n = iVar2 + 1;
    if (n < pdVar3->nlinks) {
      if (pdVar3->links[n].accesskey != uVar1) {
        plVar6 = pdVar3->links + iVar2 + 2;
        do {
          n = n + 1;
          if (pdVar3->nlinks <= n) goto LAB_080f74d0;
          puVar5 = &plVar6->accesskey;
          plVar6 = plVar6 + 1;
        } while (*puVar5 != uVar1);
      }
      (ses->kbdprefix).repeat_count = 0;
      goto_link_number_do(ses,doc_view,n);
      return FRAME_EVENT_REFRESH;
    }
LAB_080f74d0:
    if (-1 < iVar2) {
      n = 0;
      plVar6 = pdVar3->links;
      uVar4 = plVar6->accesskey;
      while( true ) {
        if (uVar4 == uVar1) {
          (ses->kbdprefix).repeat_count = 0;
          goto_link_number_do(ses,doc_view,n);
          return FRAME_EVENT_REFRESH;
        }
        n = n + 1;
        if (iVar2 < n) break;
        uVar4 = plVar6[1].accesskey;
        plVar6 = plVar6 + 1;
      }
      return FRAME_EVENT_IGNORED;
    }
  }
  return FRAME_EVENT_IGNORED;
}



void goto_link_number(session *ses,uchar *num)

{
  document_view *doc_view;
  long lVar1;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(num == (uchar *)0x0 || ses == (session *)0x0);
    if (num == (uchar *)0x0 || ses == (session *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x4ad;
      elinks_internal((uchar *)"assertion ses && num failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    doc_view = current_frame(ses);
    if (assert_failed == 0) {
      assert_failed = ZEXT14(doc_view == (document_view *)0x0);
      if (doc_view == (document_view *)0x0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
        errline = 0x4b0;
        elinks_internal((uchar *)"assertion doc_view failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
      }
      lVar1 = strtol((char *)num,(char **)0x0,10);
      goto_link_number_do(ses,doc_view,lVar1 + -1);
      return;
    }
  }
  assert_failed = 0;
  return;
}



void highlight_links_with_prefixes_that_start_with_n(terminal *term,document_view *doc_view,int n)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  document *pdVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  color_pair *color;
  int x;
  int y;
  int iVar9;
  link *plVar10;
  int local_38;
  int local_30;
  int local_2c;
  
  color = get_bfu_color(term,"searched");
  iVar1 = (doc_view->box).x;
  iVar2 = doc_view->vs->x;
  iVar3 = doc_view->vs->y;
  iVar4 = (doc_view->box).y;
  pdVar5 = doc_view->document;
  iVar9 = pdVar5->nlinks;
  if (n <= iVar9) {
    local_38 = n + 1;
    local_2c = n;
    while( true ) {
      iVar8 = local_2c;
      if ((local_2c < local_38) && (local_2c <= iVar9)) {
        plVar10 = pdVar5->links + local_2c + -1;
        local_30 = local_2c * 0x34;
        while( true ) {
          if (0 < plVar10->npoints) {
            iVar9 = 0;
            do {
              x = (iVar1 - iVar2) + plVar10->points[iVar9].x;
              iVar6 = (doc_view->box).x;
              if (iVar6 <= x) {
                y = plVar10->points[iVar9].y + (iVar4 - iVar3);
                iVar7 = (doc_view->box).y;
                if (((iVar7 <= y) && (x < iVar6 + (doc_view->box).width)) &&
                   (y < iVar7 + (doc_view->box).height)) {
                  draw_char_color(term,x,y,color);
                }
              }
              iVar9 = iVar9 + 1;
            } while (plVar10->npoints != iVar9 && iVar9 <= plVar10->npoints);
            iVar9 = pdVar5->nlinks;
          }
          local_2c = local_2c + 1;
          if ((local_38 <= local_2c) || (iVar9 < local_2c)) break;
          plVar10 = (link *)((int)&pdVar5->links->accesskey + local_30);
          local_30 = local_30 + 0x34;
        }
      }
      local_2c = iVar8 * 10;
      if (iVar9 < local_2c) break;
      local_38 = local_38 * 10;
    }
  }
  return;
}



void clear_link(terminal *term,document_view *doc_view)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  screen_char *psVar6;
  undefined4 uVar7;
  terminal_screen *ptVar8;
  int y;
  screen_char *psVar9;
  int x;
  int iVar10;
  view_state *pvVar11;
  int iVar12;
  int iVar13;
  link *plVar14;
  link *plVar15;
  
  if (doc_view != (document_view *)0x0) {
    pvVar11 = doc_view->vs;
    iVar13 = pvVar11->current_link;
    if ((iVar13 < 0) || (doc_view->document->nlinks <= iVar13)) {
      plVar14 = (link *)0x0;
    }
    else {
      plVar14 = doc_view->document->links + iVar13;
    }
    iVar10 = pvVar11->old_current_link;
    if ((((iVar10 < 0) || (doc_view->document->nlinks <= iVar10)) ||
        (plVar15 = doc_view->document->links + iVar10, plVar14 == plVar15)) ||
       (plVar15 == (link *)0x0)) goto LAB_080f7941;
    iVar10 = (doc_view->box).x;
    iVar12 = iVar10 - pvVar11->x;
    iVar1 = (doc_view->box).y;
    iVar2 = pvVar11->y;
    if (plVar15->npoints < 1) goto LAB_080f7941;
    iVar13 = 0;
    while( true ) {
      iVar3 = plVar15->points[iVar13].x;
      iVar4 = plVar15->points[iVar13].y;
      x = iVar12 + iVar3;
      if (iVar10 <= x) {
        y = (iVar1 - iVar2) + iVar4;
        iVar5 = (doc_view->box).y;
        if (((iVar5 <= y) && (x < iVar10 + (doc_view->box).width)) &&
           (y < iVar5 + (doc_view->box).height)) {
          psVar9 = get_char(term,x,y);
          psVar6 = doc_view->document->data[iVar4].chars;
          uVar7 = *(undefined4 *)&psVar6[iVar3].attr;
          psVar9->data = psVar6[iVar3].data;
          *(undefined4 *)&psVar9->attr = uVar7;
          ptVar8 = term->screen;
          if (y < ptVar8->dirty_from) {
            ptVar8->dirty_from = y;
          }
          if (ptVar8->dirty_to < y) {
            ptVar8->dirty_to = y;
          }
        }
      }
      iVar13 = iVar13 + 1;
      if (plVar15->npoints <= iVar13) break;
      iVar10 = (doc_view->box).x;
    }
  }
  pvVar11 = doc_view->vs;
  iVar13 = pvVar11->current_link;
LAB_080f7941:
  pvVar11->old_current_link = iVar13;
  return;
}



void draw_current_link(session *ses,document_view *doc_view)

{
  terminal *term;
  window *pwVar1;
  int iVar2;
  document *pdVar3;
  color_flags cVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  link_type lVar8;
  form_control *fc;
  int iVar9;
  int iVar10;
  terminal_screen *ptVar11;
  color_T cVar12;
  color_T cVar13;
  uchar *puVar14;
  uint uVar15;
  byte bVar16;
  window *pwVar17;
  form_state *fs;
  screen_char *psVar18;
  color_flags flags;
  int y;
  int iVar19;
  link *plVar20;
  int x;
  bool bVar21;
  int local_50;
  color_pair colors;
  
  term = ses->tab->term;
  if (assert_failed == 0) {
    if (((doc_view == (document_view *)0x0) || (term == (terminal *)0x0)) ||
       (doc_view->vs == (view_state *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0xee;
      elinks_internal((uchar *)"assertion term && doc_view && doc_view->vs failed!");
      if (assert_failed != 0) goto LAB_080f79c0;
    }
    else {
      assert_failed = 0;
    }
    pwVar1 = ses->tab;
    pwVar17 = get_tab_by_number(term,term->current_tab);
    bVar21 = pwVar1 != pwVar17;
    assert_failed = ZEXT14(bVar21);
    if (bVar21) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0xf1;
      elinks_internal((uchar *)"assertion ses->tab == get_current_tab(term) failed!");
      if (assert_failed != 0) goto LAB_080f79c0;
    }
    uVar15 = template._4_4_;
    if (((doc_view != (document_view *)0x0) && (iVar2 = doc_view->vs->current_link, -1 < iVar2)) &&
       ((iVar2 < doc_view->document->nlinks &&
        (plVar20 = doc_view->document->links + iVar2, plVar20 != (link *)0x0)))) {
      bVar21 = true;
      if (plVar20->type + ~LINK_SELECT < 2) {
        bVar21 = ses->insert_mode == INSERT_MODE_OFF;
      }
      template._4_4_ = CONCAT31(template._5_3_,0x40);
      pdVar3 = doc_view->document;
      cVar4 = (pdVar3->options).color_flags;
      bVar16 = *(byte *)&(pdVar3->options).active_link;
      flags = cVar4 | COLOR_DECREASE_LIGHTNESS;
      if ((bVar16 & 2) != 0) {
        template._4_4_ = uVar15 & 0xffffff00 | 0x60;
        bVar16 = *(byte *)&(pdVar3->options).active_link;
      }
      if ((bVar16 & 4) != 0) {
        template._4_4_ = template._4_4_ | 8;
        bVar16 = *(byte *)&(pdVar3->options).active_link;
      }
      if ((bVar16 & 1) == 0) {
        colors.foreground = (plVar20->color).foreground;
        colors.background = (plVar20->color).background;
      }
      else {
        colors.foreground = (pdVar3->options).active_link.fg;
        colors.background = (pdVar3->options).active_link.bg;
      }
      cVar13 = colors.background;
      if ((bVar21) && ((*(byte *)&(pdVar3->options).active_link & 8) != 0)) {
        cVar12 = colors.foreground;
        colors.background = colors.foreground;
        colors.foreground = cVar13;
        if (plVar20->type + ~LINK_SELECT < 2) {
          flags = cVar4 & ~COLOR_INCREASE_CONTRAST |
                  (COLOR_DECREASE_LIGHTNESS|COLOR_ENSURE_INVERTED_CONTRAST);
        }
      }
      set_term_color(&template,&colors,flags,(pdVar3->options).color_mode);
      iVar2 = (doc_view->box).x;
      iVar5 = doc_view->vs->x;
      iVar6 = doc_view->vs->y;
      iVar7 = (doc_view->box).y;
      if ((ses->insert_mode != INSERT_MODE_OFF) ||
         (local_50 = -1, ses->navigate_mode != NAVIGATE_CURSOR_ROUTING)) {
        bVar16 = *(byte *)&doc_view->session->tab->term->field_0x38 >> 1;
        lVar8 = plVar20->type;
        local_50 = 1;
        if (lVar8 != LINK_CHECKBOX) {
          if (lVar8 < LINK_SELECT) {
            local_50 = 2;
            if (lVar8 == LINK_BUTTON) goto LAB_080f7b70;
          }
          else {
            if (lVar8 == LINK_FIELD) {
              fs = find_form_state(doc_view,(form_control *)plVar20->data);
              if ((fs != (form_state *)0x0) && (puVar14 = fs->value, puVar14 != (uchar *)0x0)) {
                if ((bVar16 & 1) == 0) {
                  local_50 = fs->state - fs->vpos;
                }
                else {
                  if (fs->type == FC_PASSWORD) {
                    local_50 = utf8_ptr2chars(puVar14 + fs->vpos,puVar14 + fs->state);
                  }
                  else {
                    local_50 = utf8_ptr2cells(puVar14 + fs->vpos,puVar14 + fs->state);
                  }
                }
                goto LAB_080f7b70;
              }
            }
            else {
              if (lVar8 == LINK_AREA) {
                fc = (form_control *)plVar20->data;
                fs = find_form_state(doc_view,fc);
                if (fs != (form_state *)0x0) {
                  local_50 = area_cursor(fc,fs,(uint)bVar16 & 1);
                  goto LAB_080f7b70;
                }
              }
            }
          }
          local_50 = 0;
        }
      }
LAB_080f7b70:
      if (0 < plVar20->npoints) {
        iVar19 = 0;
        do {
          x = (iVar2 - iVar5) + plVar20->points[iVar19].x;
          iVar9 = (doc_view->box).x;
          if (iVar9 <= x) {
            y = plVar20->points[iVar19].y + (iVar7 - iVar6);
            iVar10 = (doc_view->box).y;
            if (((iVar10 <= y) && (x < iVar9 + (doc_view->box).width)) &&
               (y < (doc_view->box).height + iVar10)) {
              psVar18 = get_char(term,x,y);
              if (iVar19 == local_50) {
                set_cursor(term,x,y,(uint)(psVar18 != &template && 1 < plVar20->type + ~LINK_SELECT)
                          );
                ses->tab->x = x;
                ses->tab->y = y;
              }
              template.data = psVar18->data;
              *(uint *)&psVar18->attr = template._4_4_;
              psVar18->data = psVar18->data;
              ptVar11 = term->screen;
              if (y < ptVar11->dirty_from) {
                ptVar11->dirty_from = y;
              }
              if (ptVar11->dirty_to < y) {
                ptVar11->dirty_to = y;
              }
            }
          }
          iVar19 = iVar19 + 1;
        } while (plVar20->npoints != iVar19 && iVar19 <= plVar20->npoints);
      }
      doc_view->vs->old_current_link = doc_view->vs->current_link;
      return;
    }
  }
  else {
LAB_080f79c0:
    assert_failed = 0;
  }
  return;
}



void __regparm3 free_mark_by_index(int i)

{
  if ((assert_failed == 0) && (assert_failed = ZEXT14(0x33U < (uint)i), 0x33U < (uint)i)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/marks.c";
    errline = 0x76;
    elinks_internal((uchar *)"assertion is_valid_mark_index(i) failed!");
  }
  if (marks[i] != (view_state *)0x0) {
    destroy_vs(marks[i],1);
    if (marks[i] != (view_state *)0x0) {
      mem_free(marks[i]);
    }
    marks[i] = (view_state *)0x0;
  }
  return;
}



void done_marks(module *xxx)

{
  int i;
  int iVar1;
  
  i = 0;
  do {
    iVar1 = i + 1;
    free_mark_by_index(i);
    i = iVar1;
  } while (iVar1 != 0x34);
  return;
}



void goto_mark(uchar mark,view_state *vs)

{
  document_view *pdVar1;
  int iVar2;
  byte bVar3;
  byte bVar4;
  uint uVar5;
  
  iVar2 = assert_failed;
  bVar4 = mark + 0x9f;
  bVar3 = mark + 0xbf;
  if ((0x19 < bVar4) && (0x19 < bVar3)) {
    return;
  }
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(0x19 < bVar3 && 0x19 < bVar4), 0x19 < bVar3 && 0x19 < bVar4)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/marks.c";
    errline = 0x43;
    elinks_internal((uchar *)"assertion is_valid_mark_char(mark) failed!");
  }
  else {
    if (bVar3 < 0x1a) {
      uVar5 = (uint)mark - 0x41;
      goto LAB_080f7f10;
    }
  }
  uVar5 = (uint)mark - 0x47;
  iVar2 = assert_failed;
LAB_080f7f10:
  if ((iVar2 == 0) && (assert_failed = ZEXT14(0x33 < uVar5), 0x33 < uVar5)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/marks.c";
    errline = 0x5a;
    elinks_internal((uchar *)"assertion is_valid_mark_index(i) failed!");
  }
  if ((marks[uVar5] != (view_state *)0x0) &&
     (iVar2 = compare_uri(marks[uVar5]->uri,vs->uri,0), iVar2 != 0)) {
    iVar2 = vs->current_link;
    pdVar1 = vs->doc_view;
    destroy_vs(vs,0);
    copy_vs(vs,marks[uVar5]);
    vs->doc_view = pdVar1;
    pdVar1->vs = vs;
    vs->old_current_link = iVar2;
  }
  return;
}



void set_mark(uchar mark,view_state *mark_vs)

{
  view_state *dst;
  byte bVar1;
  byte bVar2;
  int i;
  
  bVar2 = mark + 0x9f;
  bVar1 = mark + 0xbf;
  if ((0x19 < bVar2) && (0x19 < bVar1)) {
    return;
  }
  if ((assert_failed == 0) &&
     (assert_failed = ZEXT14(0x19 < bVar1 && 0x19 < bVar2), 0x19 < bVar1 && 0x19 < bVar2)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/marks.c";
    errline = 0x43;
    elinks_internal((uchar *)"assertion is_valid_mark_char(mark) failed!");
  }
  else {
    if (bVar1 < 0x1a) {
      i = (uint)mark - 0x41;
      goto LAB_080f8056;
    }
  }
  i = (uint)mark - 0x47;
LAB_080f8056:
  free_mark_by_index(i);
  if ((mark_vs != (view_state *)0x0) &&
     (dst = (view_state *)mem_calloc(1,0x30), dst != (view_state *)0x0)) {
    copy_vs(dst,mark_vs);
    marks[i] = dst;
  }
  return;
}



evhook_status search_history_write_hook(va_list ap,void *data)

{
  save_input_history(&search_history,(uchar *)"searchhist");
  return EVENT_HOOK_STATUS_NEXT;
}



void done_search_history(module *module)

{
  input_history *p;
  input_history *piVar1;
  input_history *piVar2;
  input_history *piVar3;
  
  save_input_history(&search_history,(uchar *)"searchhist");
  piVar3 = (input_history *)search_history.entries.next;
  p = (input_history *)search_history.entries.prev;
  if ((input_history *)search_history.entries.next != &search_history) {
    do {
      piVar3 = (input_history *)(piVar3->entries).next;
    } while (piVar3 != &search_history);
  }
  while (p != piVar3) {
    p = (input_history *)(p->entries).prev;
  }
  piVar2 = *(input_history **)search_history.entries.next;
  p = (input_history *)search_history.entries.next;
  while (piVar1 = piVar2, p != piVar3) {
    (piVar1->entries).prev = (p->entries).prev;
    *(void **)(p->entries).prev = (p->entries).next;
    mem_free(p);
    piVar2 = (input_history *)(piVar1->entries).next;
    p = piVar1;
  }
  return;
}



void init_search_history(module *module)

{
  load_input_history(&search_history,(uchar *)"searchhist");
  return;
}



int __regparm3 get_range(document *document,int y,int height,int l,search **s1,search **s2)

{
  int iVar1;
  int iVar2;
  search *psVar3;
  
  if (assert_failed == 0) {
    if (((s1 == (search **)0x0) || (document == (document *)0x0)) || (s2 == (search **)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
      errline = 0xf4;
      elinks_internal((uchar *)"assertion document && s1 && s2 failed!");
      if (assert_failed != 0) goto LAB_080f8188;
    }
    else {
      assert_failed = 0;
    }
    *s2 = (search *)0x0;
    iVar1 = 0;
    if (-1 < y) {
      iVar1 = y;
    }
    height = iVar1 + height;
    *s1 = (search *)0x0;
    if ((iVar1 < height) && (document->height != iVar1 && iVar1 <= document->height)) {
      iVar2 = iVar1 * 4;
      do {
        psVar3 = *(search **)((int)document->slines1 + iVar2);
        if ((psVar3 != (search *)0x0) && ((*s1 == (search *)0x0 || (psVar3 < *s1)))) {
          *s1 = psVar3;
        }
        psVar3 = *(search **)((int)document->slines2 + iVar2);
        if ((psVar3 != (search *)0x0) && ((*s2 == (search *)0x0 || (*s2 < psVar3)))) {
          *s2 = psVar3;
        }
        iVar1 = iVar1 + 1;
      } while ((iVar1 < height) &&
              (iVar2 = iVar2 + 4, document->height != iVar1 && iVar1 <= document->height));
      if ((*s1 != (search *)0x0) && (*s2 != (search *)0x0)) {
        psVar3 = *s1 + l * 0xfffffff;
        *s1 = psVar3;
        if (psVar3 < document->search) {
          psVar3 = document->search;
        }
        *s1 = psVar3;
        psVar3 = document->search + ((document->nsearch + 1) - l);
        if (*s2 < psVar3 || *s2 == psVar3) {
          psVar3 = *s2;
        }
        *s2 = psVar3;
        if (psVar3 < *s1) {
          *s2 = (search *)0x0;
          *s1 = (search *)0x0;
          return 1;
        }
        if (*s1 != (search *)0x0) {
          return (uint)(psVar3 == (search *)0x0);
        }
      }
    }
    iVar1 = 1;
  }
  else {
LAB_080f8188:
    assert_failed = 0;
    iVar1 = -1;
  }
  return iVar1;
}



widget_handler_status_T search_dlg_cancel(dialog_data *dlg_data,widget_data *widget_data)

{
  code *pcVar1;
  widget_handler_status_T wVar2;
  
  pcVar1 = (code *)widget_data->widget->data;
  if (pcVar1 != (code *)0x0) {
    (*pcVar1)(*(undefined4 *)dlg_data->dlg->udata2);
  }
  wVar2 = cancel_dialog(dlg_data,widget_data);
  return wVar2;
}



widget_handler_status_T search_dlg_ok(dialog_data *dlg_data,widget_data *widget_data)

{
  code *pcVar1;
  undefined4 *puVar2;
  undefined4 uVar3;
  uchar *data;
  option_elinks *root;
  int iVar4;
  widget_handler_status_T wVar5;
  
  pcVar1 = (code *)widget_data->widget->data;
  puVar2 = (undefined4 *)dlg_data->dlg->udata2;
  uVar3 = *puVar2;
  data = dlg_data->widgets_data[0].cdata;
  update_dialog_data(dlg_data);
  root = get_opt_rec(config_options,(uchar *)"document.browse.search");
  commit_option_values(resolvers,root,puVar2 + 1,1);
  iVar4 = check_dialog(dlg_data);
  if (iVar4 != 0) {
    return EVENT_NOT_PROCESSED;
  }
  add_to_input_history(*(input_history **)(dlg_data->dlg->widgets[0].info + 8),data,1);
  if (pcVar1 != (code *)0x0) {
    (*pcVar1)(uVar3,data);
  }
  wVar5 = cancel_dialog(dlg_data,widget_data);
  return wVar5;
}



int __regparm3 strlen_u(uchar *text,int utf8)

{
  size_t sVar1;
  int iVar2;
  uchar *local_10 [3];
  
  local_10[0] = text;
  if (utf8 == 0) {
    sVar1 = strlen((char *)text);
    return sVar1;
  }
  iVar2 = strlen_utf8(local_10);
  return iVar2;
}



unicode_val_T * __regparm3 memacpy_u(uchar *text,int textlen,int utf8)

{
  unicode_val_T *puVar1;
  unicode_val_T uVar2;
  int iVar3;
  uchar *local_20 [4];
  
  local_20[0] = text;
  puVar1 = (unicode_val_T *)mem_alloc(textlen * 4 + 4);
  if (puVar1 != (unicode_val_T *)0x0) {
    if (utf8 == 0) {
      iVar3 = 0;
      if (0 < textlen) {
        do {
          puVar1[iVar3] = (uint)local_20[0][iVar3];
          iVar3 = iVar3 + 1;
        } while (iVar3 != textlen);
        puVar1[textlen] = 0;
        return puVar1;
      }
    }
    else {
      if (0 < textlen) {
        iVar3 = 0;
        do {
          uVar2 = utf8_to_unicode(local_20,local_20[0] + 7);
          puVar1[iVar3] = uVar2;
          iVar3 = iVar3 + 1;
        } while (iVar3 < textlen);
      }
    }
    puVar1[textlen] = 0;
  }
  return puVar1;
}



unicode_val_T * __regparm3 lowered_string(uchar *text,int textlen,int utf8)

{
  unicode_val_T *puVar1;
  wint_t wVar2;
  __int32_t **pp_Var3;
  wint_t *pwVar4;
  
  if (textlen < 0) {
    textlen = strlen_u(text,utf8);
  }
  puVar1 = memacpy_u(text,textlen,utf8);
  if ((textlen != 0) && (puVar1 != (unicode_val_T *)0x0)) {
    pwVar4 = puVar1 + textlen;
    while( true ) {
      if (utf8 == 0) {
        wVar2 = *pwVar4;
        if (wVar2 + 0x80 < 0x180) {
          pp_Var3 = __ctype_tolower_loc();
          wVar2 = (*pp_Var3)[wVar2];
        }
        *pwVar4 = wVar2;
      }
      else {
        wVar2 = towlower(*pwVar4);
        *pwVar4 = wVar2;
      }
      if (textlen == 0) break;
      pwVar4 = pwVar4 + -1;
      textlen = textlen + -1;
    }
  }
  return puVar1;
}



void __regparm3
print_find_error_not_found(session *ses,uchar *title,uchar *message,uchar *search_string)

{
  int *piVar1;
  uchar *text;
  
  piVar1 = get_opt_(config_options,title);
  if (*piVar1 != 1) {
    if (*piVar1 == 2) {
      text = msg_text(ses->tab->term,message,search_string);
      info_box(ses->tab->term,MSGBOX_FREE_TEXT,title,ALIGN_CENTER,text);
    }
    return;
  }
  beep_terminal(ses->tab->term);
  return;
}



void __regparm3 print_find_error(session *ses,find_error find_error)

{
  bool bVar1;
  int *piVar2;
  char *text;
  
  switch(find_error) {
  default:
    goto switchD_080f8653_caseD_0;
  case FIND_ERROR_NO_PREVIOUS_SEARCH:
    text = "No previous search";
    goto LAB_080f8665;
  case FIND_ERROR_HIT_TOP:
    bVar1 = true;
    break;
  case FIND_ERROR_HIT_BOTTOM:
    bVar1 = false;
    break;
  case FIND_ERROR_NOT_FOUND:
    print_find_error_not_found
              (ses,"Search",(uchar *)"Search string \'%s\' not found",ses->search_word);
    return;
  case FIND_ERROR_REGEX:
    print_find_error_not_found
              (ses,"Search",(uchar *)"Could not compile regular expression \'%s\'",ses->search_word)
    ;
    return;
  }
  piVar2 = get_opt_(config_options,(uchar *)find_error);
  if (*piVar2 != 0) {
    text = "Search hit bottom, continuing at top.";
    if (bVar1) {
      text = "Search hit top, continuing at bottom.";
    }
    if ((uchar *)text != (uchar *)0x0) {
LAB_080f8665:
      info_box(ses->tab->term,0,"Search",ALIGN_CENTER,(uchar *)text);
    }
  }
switchD_080f8653_caseD_0:
  return;
}



frame_event_status search_typeahead(session *ses,document_view *doc_view,action_id_T action_id)

{
  code *handler;
  uchar *text;
  uchar *data;
  
  text = "#";
  if (action_id == 0x5f) {
    data = "/";
    handler = text_typeahead_handler;
    text = "/";
  }
  else {
    if (action_id == 0x60) {
      text = "?";
      handler = text_typeahead_handler;
      data = text;
    }
    else {
      data = (uchar *)0x0;
      if (action_id == 0x5e) {
        data = "#";
      }
      handler = link_typeahead_handler;
      if (doc_view->document->nlinks == 0) {
        text = msg_text(ses->tab->term,(uchar *)"No links in current document");
        info_box(ses->tab->term,MSGBOX_FREE_TEXT,(uchar *)"Typeahead",ALIGN_CENTER,text);
        return FRAME_EVENT_OK;
      }
    }
  }
  input_field_line(ses,text,data,&search_history,handler);
  return FRAME_EVENT_OK;
}



int __regparm3 match_link_text(link *link,uchar *text,int textlen,int case_sensitive)

{
  size_t sVar1;
  char *pcVar2;
  uchar *__s;
  
  if ((LINK_MAP < link->type) || (__s = (uchar *)link->data, __s == (uchar *)0x0)) {
    __s = link->where;
    if ((__s == (uchar *)0x0) && (__s = link->where_img, __s == (uchar *)0x0)) {
      __s = "";
    }
    if (LINK_MAP < link->type) {
      return -1;
    }
  }
  sVar1 = strlen((char *)__s);
  if ((uint)textlen <= sVar1) {
    if (case_sensitive == 0) {
      pcVar2 = strcasestr((char *)__s,(char *)text);
    }
    else {
      pcVar2 = strstr((char *)__s,(char *)text);
    }
    if (pcVar2 != (char *)0x0) {
      return (int)(pcVar2 + -(int)__s);
    }
  }
  return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __regparm3 draw_typeahead_match(terminal *term,document_view *doc_view,int chars,int offset)

{
  view_state *pvVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  link_type lVar8;
  color_pair *color;
  byte bVar9;
  int iVar10;
  byte *pbVar11;
  line *plVar12;
  link *local_2c;
  int local_20;
  
  color = get_bfu_color(term,"searched");
  pvVar1 = doc_view->vs;
  iVar2 = (doc_view->box).x;
  iVar3 = pvVar1->x;
  iVar4 = (doc_view->box).y;
  iVar5 = pvVar1->y;
  iVar10 = pvVar1->current_link;
  if ((iVar10 < 0) || (doc_view->document->nlinks <= iVar10)) {
    local_2c = (link *)0x0;
    lVar8 = _DAT_00000004;
  }
  else {
    local_2c = doc_view->document->links + iVar10;
    lVar8 = local_2c->type;
  }
  if ((((LINK_MAP < lVar8) || (pbVar11 = (byte *)local_2c->data, pbVar11 == (byte *)0x0)) &&
      (pbVar11 = local_2c->where, pbVar11 == (byte *)0x0)) &&
     (pbVar11 = local_2c->where_img, pbVar11 == (byte *)0x0)) {
    pbVar11 = &DAT_0812e3d8;
  }
  local_20 = chars + offset;
  bVar9 = *pbVar11;
  if ((bVar9 != 0) && (0 < local_20)) {
    iVar10 = 0;
    do {
      iVar6 = local_2c->points[iVar10].x;
      iVar7 = local_2c->points[iVar10].y;
      if (((iVar7 < doc_view->document->height) &&
          (plVar12 = doc_view->document->data + iVar7, iVar6 < plVar12->length)) &&
         ((uint)bVar9 == plVar12->chars[iVar6].data)) {
        if (offset <= iVar10) {
          draw_char_color(term,(iVar2 - iVar3) + iVar6,iVar7 + (iVar4 - iVar5),color);
        }
        iVar10 = iVar10 + 1;
        bVar9 = pbVar11[1];
        if (local_20 <= iVar10) {
          return;
        }
      }
      else {
        local_20 = local_20 + -1;
        offset = offset + -1;
        bVar9 = pbVar11[1];
        if (local_20 <= iVar10) {
          return;
        }
      }
      pbVar11 = pbVar11 + 1;
    } while (bVar9 != 0);
  }
  return;
}



input_line_code link_typeahead_handler(input_line *line,int action_id)

{
  uchar *text;
  session *ses;
  document *name;
  int case_sensitive;
  byte bVar1;
  document_view *doc_view;
  int *piVar2;
  size_t textlen;
  int iVar3;
  int offset;
  int offset_00;
  uchar *name_00;
  document *extraout_EDX;
  uchar *name_01;
  document *name_02;
  document *extraout_EDX_00;
  int iVar4;
  link *link;
  int iVar5;
  bool bVar6;
  char *local_68;
  int local_28;
  int local_20;
  
  ses = line->ses;
  doc_view = current_frame(ses);
  if (assert_failed != 0) {
    assert_failed = 0;
    return INPUT_LINE_CANCEL;
  }
  assert_failed = ZEXT14(doc_view == (document_view *)0x0);
  if (doc_view == (document_view *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
    errline = 0x5be;
    elinks_internal((uchar *)"assertion doc_view != NULL failed: document not formatted");
    if (assert_failed != 0) {
      assert_failed = 0;
      return INPUT_LINE_CANCEL;
    }
  }
  if (line->buffer[0] == '\0') {
    if (line->data == (void *)0x0) {
      return INPUT_LINE_PROCEED;
    }
    draw_formatted(ses,0);
    return INPUT_LINE_PROCEED;
  }
  text = line->buffer;
  if (action_id == 0x1a) {
    offset_00 = doc_view->vs->current_link;
    if (offset_00 < 0) {
      return INPUT_LINE_PROCEED;
    }
    textlen = strlen((char *)text);
    piVar2 = get_opt_(config_options,name_01);
    offset_00 = match_link_text(doc_view->document->links + offset_00,text,textlen,*piVar2);
    if (offset_00 < 0) {
      return INPUT_LINE_PROCEED;
    }
    draw_typeahead_match(ses->tab->term,doc_view,textlen,offset_00);
    return INPUT_LINE_PROCEED;
  }
  if (line->data == (void *)0x0) {
    bVar1 = line->buffer[0] - 0x23;
    if ((bVar1 < 0x1d) && (*(int *)(CSWTCH_247 + (uint)bVar1 * 4) != 0)) {
      search_typeahead(ses,doc_view,*(int *)(CSWTCH_247 + (uint)bVar1 * 4));
      return INPUT_LINE_CANCEL;
    }
    *(undefined **)&line->data = &DAT_0812cc9a;
  }
  offset_00 = doc_view->vs->current_link;
  if (offset_00 < 0) {
    offset_00 = 0;
  }
  name = doc_view->document;
  name_02 = name;
  switch(action_id) {
  case 0xb:
  case 0x16:
    bVar6 = true;
    local_20 = 1;
    iVar4 = offset_00 + 1;
    if (iVar4 < name->nlinks) break;
    piVar2 = get_opt_(config_options,(uchar *)name);
    name_02 = extraout_EDX;
    if (*piVar2 != 0) {
      local_20 = 1;
      bVar6 = offset_00 != 0;
      iVar4 = 0;
      break;
    }
search_hit_boundary:
    offset = 0;
    piVar2 = get_opt_(config_options,(uchar *)name_02);
    textlen = strlen((char *)text);
    offset_00 = match_link_text(name->links + offset_00,text,textlen,*piVar2);
    if (offset_00 < 0) goto LAB_080f8f36;
    goto LAB_080f8efa;
  default:
    bVar6 = false;
    local_20 = 1;
    iVar4 = offset_00;
    break;
  case 0xe:
    goto_current_link(ses,doc_view,0);
    return INPUT_LINE_CANCEL;
  case 0x19:
  case 0x1d:
    iVar4 = offset_00 + -1;
    if (iVar4 == -1) {
      piVar2 = get_opt_(config_options,(uchar *)name);
      name_02 = extraout_EDX_00;
      if (*piVar2 == 0) goto search_hit_boundary;
      iVar4 = doc_view->document->nlinks + -1;
    }
    bVar6 = offset_00 != iVar4;
    local_20 = -1;
  }
  piVar2 = get_opt_(config_options,(uchar *)name_02);
  case_sensitive = *piVar2;
  local_68 = "document.browse.search.wraparound";
  piVar2 = get_opt_(config_options,name_00);
  iVar5 = *piVar2;
  textlen = strlen((char *)text);
  if (assert_failed == 0) {
    if ((textlen == 0) || (local_20 == 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
      errline = 0x4c0;
      elinks_internal((uchar *)"assertion textlen && direction && offset failed!",local_68);
    }
    else {
      assert_failed = 0;
    }
  }
  if (local_20 == 1) {
    local_28 = iVar4 + -1;
    iVar3 = name->nlinks;
  }
  else {
    iVar3 = iVar4 + 1;
    local_28 = -1;
  }
  if ((local_28 < iVar4) && (iVar4 < iVar3)) {
    link = name->links;
    do {
      offset = match_link_text(link + iVar4,text,textlen,case_sensitive);
      if (-1 < offset) goto LAB_080f8d5a;
      if (iVar5 != 0) {
        if (local_20 == 1) {
          if (iVar4 == iVar3 + -1) {
            iVar5 = 0;
            iVar4 = -1;
            local_28 = -1;
            iVar3 = offset_00 + 1;
          }
        }
        else {
          if (iVar4 == local_28 + 1) {
            iVar5 = 0;
            iVar4 = name->nlinks;
            iVar3 = iVar4;
            local_28 = offset_00 + -1;
          }
        }
      }
      iVar4 = iVar4 + local_20;
    } while ((iVar4 < iVar3) && (local_28 < iVar4));
  }
  offset = 0;
  iVar4 = -1;
LAB_080f8d5a:
  if ((offset_00 != iVar4) || (!bVar6)) {
    if (-1 < iVar4) {
      if (assert_failed == 0) {
        if (iVar4 < doc_view->document->nlinks) {
          assert_failed = 0;
        }
        else {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
          errline = 0x565;
          elinks_internal((uchar *)
                          "assertion match >= 0 && match < doc_view->document->nlinks failed!");
        }
      }
      doc_view->vs->current_link = iVar4;
      link = doc_view->document->links + doc_view->vs->current_link;
      piVar2 = &(doc_view->box).height;
      *piVar2 = *piVar2 + -1;
      set_pos_x(doc_view,link);
      set_pos_y(doc_view,link);
      piVar2 = &(doc_view->box).height;
      *piVar2 = *piVar2 + 1;
      draw_formatted(ses,0);
      goto LAB_080f8dff;
    }
    if (!bVar6) {
LAB_080f8f36:
      print_find_error_not_found
                (ses,(uchar *)"Typeahead",(uchar *)"Could not find a link with the text \'%s\'.",
                 text);
      return INPUT_LINE_REWIND;
    }
  }
LAB_080f8efa:
  print_find_error_not_found
            (ses,(uchar *)"Typeahead",(uchar *)"No further matches for \'%s\'.",text);
LAB_080f8dff:
  textlen = strlen((char *)text);
  draw_typeahead_match(ses->tab->term,doc_view,textlen,offset);
  return INPUT_LINE_PROCEED;
}



int __regparm3 get_srch(document *document)

{
  search *psVar1;
  list_head_elinks *plVar2;
  int iVar3;
  void *pvVar4;
  int *piVar5;
  uint uVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  uint *puVar10;
  int local_2c;
  void *local_28;
  int local_24;
  
  if (assert_failed == 0) {
    if ((document == (document *)0x0) || (document->nsearch != 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
      errline = 0x99;
      elinks_internal((uchar *)"assertion document && document->nsearch == 0 failed!");
      if (assert_failed != 0) goto LAB_080f91a6;
    }
    else {
      assert_failed = 0;
    }
    plVar2 = (list_head_elinks *)(document->nodes).prev;
    while (plVar2 != &document->nodes) {
      local_28 = plVar2[1].prev;
      iVar8 = (int)plVar2[2].prev + (int)local_28;
      iVar3 = document->height;
      if (iVar8 <= document->height) {
        iVar3 = iVar8;
      }
      if ((int)local_28 < iVar3) {
        local_24 = (int)local_28 << 3;
        do {
          piVar5 = (int *)((int)&document->data->chars + local_24);
          pvVar4 = plVar2[1].next;
          iVar8 = piVar5[1];
          iVar9 = (int)plVar2[2].next + (int)pvVar4;
          if (iVar9 <= iVar8) {
            iVar8 = iVar9;
          }
          if ((int)pvVar4 < iVar8) {
            iVar9 = *piVar5;
            uVar6 = *(uint *)(iVar9 + (int)pvVar4 * 8);
            if (0x20 < uVar6) {
LAB_080f9282:
              do {
                if (((*(byte *)(iVar9 + 4 + (int)pvVar4 * 8) & 1) == 0) && (uVar6 != 0xfffffffd)) {
                  if (uVar6 < 0x21) {
                    iVar7 = (int)pvVar4 + 1;
                    if (iVar7 < iVar8) {
                      puVar10 = (uint *)(iVar9 + 0x10 + (int)pvVar4 * 8);
                      uVar6 = *(uint *)(iVar9 + iVar7 * 8);
                      while (uVar6 < 0x20) {
                        iVar7 = iVar7 + 1;
                        if (iVar8 <= iVar7) goto LAB_080f9376;
                        uVar6 = *puVar10;
                        puVar10 = puVar10 + 2;
                      }
                      local_2c = iVar7 - (int)pvVar4;
                    }
                    else {
LAB_080f9376:
                      local_2c = 0;
                    }
                    if (assert_failed == 0) {
                      assert_failed = 0;
                      iVar9 = document->nsearch;
                      if (iVar9 != 0) {
                        psVar1 = document->search;
                        if (psVar1 != (search *)0x0) {
                          if (psVar1[iVar9 + -1].c == 0x20) goto LAB_080f925e;
                          psVar1[iVar9].c = 0x20;
                          *(void **)&document->search[iVar9].x = pvVar4;
                          *(void **)&document->search[iVar9].y = local_28;
                          document->search[iVar9].n = local_2c;
                          iVar9 = document->nsearch;
                        }
                        document->nsearch = iVar9 + 1;
                      }
                    }
                    else {
                      assert_failed = 0;
                    }
LAB_080f925e:
                    pvVar4 = (void *)(iVar7 + -1);
                  }
                  else {
                    if (assert_failed == 0) {
                      assert_failed = 0;
                      if (document->search != (search *)0x0) {
                        iVar9 = document->nsearch;
                        document->search[iVar9].c = uVar6;
                        *(void **)&document->search[iVar9].x = pvVar4;
                        *(void **)&document->search[iVar9].y = local_28;
                        document->search[iVar9].n = 1;
                      }
                      document->nsearch = document->nsearch + 1;
                    }
                    else {
                      assert_failed = 0;
                    }
                  }
                }
                pvVar4 = (void *)((int)pvVar4 + 1);
                if (iVar8 <= (int)pvVar4) goto LAB_080f9105;
                iVar9 = *(int *)((int)&document->data->chars + local_24);
                uVar6 = *(uint *)(iVar9 + (int)pvVar4 * 8);
              } while( true );
            }
            pvVar4 = (void *)((int)pvVar4 + 1);
            puVar10 = (uint *)(iVar9 + (int)pvVar4 * 8);
            while ((int)pvVar4 < iVar8) {
              uVar6 = *puVar10;
              puVar10 = puVar10 + 2;
              if (0x20 < uVar6) goto LAB_080f9282;
              pvVar4 = (void *)((int)pvVar4 + 1);
            }
          }
LAB_080f9105:
          if (assert_failed == 0) {
            assert_failed = 0;
            iVar8 = document->nsearch;
            if (iVar8 != 0) {
              psVar1 = document->search;
              if (psVar1 != (search *)0x0) {
                if (psVar1[iVar8 + -1].c == 0x20) goto LAB_080f9176;
                psVar1[iVar8].c = 0x20;
                *(void **)&document->search[iVar8].x = pvVar4;
                *(void **)&document->search[iVar8].y = local_28;
                document->search[iVar8].n = 0;
                iVar8 = document->nsearch;
              }
              document->nsearch = iVar8 + 1;
            }
          }
          else {
            assert_failed = 0;
          }
LAB_080f9176:
          local_28 = (void *)((int)local_28 + 1);
          local_24 = local_24 + 8;
        } while ((int)local_28 < iVar3);
      }
      plVar2 = (list_head_elinks *)plVar2->prev;
    }
    iVar3 = document->nsearch;
  }
  else {
LAB_080f91a6:
    assert_failed = 0;
    iVar3 = 0;
  }
  return iVar3;
}



void __regparm3 get_search_data(document *document)

{
  int *piVar1;
  int iVar2;
  search **ppsVar3;
  void *p;
  void *p_00;
  search *psVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(document == (document *)0x0);
    if (document == (document *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
      errline = 0xd3;
      elinks_internal((uchar *)"assertion document failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    if (document->search != (search *)0x0) {
      return;
    }
    iVar2 = get_srch(document);
    if (iVar2 == 0) {
      return;
    }
    document->nsearch = 0;
    psVar4 = (search *)mem_alloc(iVar2 << 4);
    document->search = psVar4;
    if (psVar4 == (search *)0x0) {
      return;
    }
    get_srch(document);
    iVar2 = document->nsearch;
    iVar7 = (iVar2 + -1) * 0x10;
    do {
      if (iVar2 == 0) break;
      iVar2 = iVar2 + -1;
      document->nsearch = iVar2;
      piVar1 = (int *)((int)&document->search->c + iVar7);
      iVar7 = iVar7 + -0x10;
    } while (*piVar1 == 0x20);
    if (assert_failed == 0) {
      assert_failed = 0;
      ppsVar3 = (search **)mem_calloc(document->height,4);
      document->slines1 = ppsVar3;
      if (ppsVar3 == (search **)0x0) {
        return;
      }
      ppsVar3 = (search **)mem_calloc(document->height,4);
      document->slines2 = ppsVar3;
      if (ppsVar3 == (search **)0x0) {
        mem_free(document->slines1);
        return;
      }
      p = mem_calloc(document->height,4);
      if (p == (void *)0x0) {
        mem_free(document->slines1);
        mem_free(document->slines2);
        return;
      }
      p_00 = mem_calloc(document->height,4);
      if (p_00 == (void *)0x0) {
        mem_free(document->slines1);
        mem_free(document->slines2);
        mem_free(p);
        return;
      }
      iVar2 = 0;
      if (0 < document->height) {
        do {
          *(undefined4 *)((int)p + iVar2 * 4) = 0x7fffffff;
          *(undefined4 *)((int)p_00 + iVar2 * 4) = 0;
          iVar2 = iVar2 + 1;
        } while (iVar2 < document->height);
      }
      if (0 < document->nsearch) {
        iVar2 = 0;
        do {
          psVar4 = document->search + iVar2;
          iVar7 = psVar4->x;
          iVar5 = psVar4->n + iVar7;
          iVar6 = psVar4->y * 4;
          if (iVar7 < *(int *)((int)p + iVar6)) {
            *(int *)((int)p + iVar6) = iVar7;
            document->slines1[psVar4->y] = psVar4;
            iVar6 = psVar4->y << 2;
          }
          if (*(int *)(iVar6 + (int)p_00) < iVar5) {
            *(int *)(iVar6 + (int)p_00) = iVar5;
            document->slines2[psVar4->y] = psVar4;
          }
          iVar2 = iVar2 + 1;
        } while (iVar2 < document->nsearch);
      }
      mem_free(p);
      mem_free(p_00);
      return;
    }
  }
  assert_failed = 0;
  return;
}



void __regparm3 get_searched(document_view *doc_view,point **pt,int *pl,int utf8)

{
  uchar *puVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int l;
  int iVar6;
  int *piVar7;
  wint_t wVar8;
  int iVar9;
  uint uVar10;
  uint uVar11;
  int iVar12;
  unicode_val_T uVar13;
  __int32_t **pp_Var14;
  size_t size;
  point *ppVar15;
  uchar *name;
  search *psVar16;
  int iVar17;
  int iVar18;
  int iVar19;
  int local_54;
  unicode_val_T *local_30;
  point *local_28;
  search *local_24;
  search *local_20 [4];
  
  if (assert_failed == 0) {
    if ((((doc_view == (document_view *)0x0) || (pt == (point **)0x0)) ||
        (doc_view->vs == (view_state *)0x0)) || (pl == (int *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
      errline = 0x2fe;
      elinks_internal((uchar *)"assertion doc_view && doc_view->vs && pt && pl failed!");
      if (assert_failed != 0) goto LAB_080f9708;
    }
    else {
      assert_failed = 0;
    }
    if (((doc_view->search_word != (uchar **)0x0) &&
        (puVar1 = *doc_view->search_word, puVar1 != (uchar *)0x0)) && (*puVar1 != '\0')) {
      get_search_data(doc_view->document);
      l = strlen_u(*doc_view->search_word,utf8);
      iVar6 = get_range(doc_view->document,doc_view->vs->y,(doc_view->box).height,l,local_20,
                        &local_24);
      if (iVar6 != 0) {
        *pt = (point *)0x0;
        *pl = 0;
        return;
      }
      local_28 = (point *)0x0;
      piVar7 = get_opt_(config_options,name);
      iVar6 = *piVar7;
      if (iVar6 == 0) {
        local_30 = lowered_string(*doc_view->search_word,l,utf8);
      }
      else {
        local_30 = memacpy_u(*doc_view->search_word,l,utf8);
      }
      if (local_30 != (unicode_val_T *)0x0) {
        iVar18 = 0;
        iVar2 = (doc_view->box).x;
        iVar3 = doc_view->vs->x;
        iVar4 = (doc_view->box).y;
        iVar5 = doc_view->vs->y;
        if (local_24 < local_20[0]) {
LAB_080f9920:
          mem_free(local_30);
          *pt = local_28;
          *pl = iVar18;
          return;
        }
        iVar18 = 0;
        if (iVar6 == 0) goto LAB_080f97e1;
        iVar18 = 0;
LAB_080f97c0:
        uVar13 = local_20[0]->c;
LAB_080f97c3:
        if (*local_30 == uVar13) goto LAB_080f97fe;
LAB_080f97cc:
        do {
          local_20[0] = local_20[0] + 1;
          if (local_24 < local_20[0]) goto LAB_080f9920;
          if (iVar6 != 0) goto LAB_080f97c0;
LAB_080f97e1:
          if (utf8 == 0) goto LAB_080f98d8;
          wVar8 = towlower(local_20[0]->c);
          if (*local_30 == wVar8) {
LAB_080f97fe:
            if (l < 2) {
              if (l < 1) goto LAB_080f97cc;
            }
            else {
              iVar19 = 1;
              psVar16 = local_20[0];
              do {
                if (iVar6 == 0) {
                  if (utf8 == 0) {
                    uVar13 = psVar16[1].c;
                    if (uVar13 + 0x80 < 0x180) {
                      pp_Var14 = __ctype_tolower_loc();
                      uVar13 = (*pp_Var14)[uVar13];
                    }
                  }
                  else {
                    uVar13 = towlower(psVar16[1].c);
                  }
                }
                else {
                  uVar13 = psVar16[1].c;
                }
                if (local_30[iVar19] != uVar13) goto LAB_080f97cc;
                iVar19 = iVar19 + 1;
                psVar16 = psVar16 + 1;
              } while (iVar19 < l);
            }
            local_54 = 0;
            psVar16 = local_20[0];
            do {
              iVar9 = (iVar4 - iVar5) + psVar16->y;
              iVar19 = (doc_view->box).y;
              if (((iVar19 <= iVar9) && (iVar9 < iVar19 + (doc_view->box).height)) &&
                 (0 < psVar16->n)) {
                iVar19 = 0;
                do {
                  iVar17 = psVar16->x + iVar19;
                  iVar12 = (iVar2 - iVar3) + iVar17;
                  iVar9 = (doc_view->box).x;
                  if ((iVar9 <= iVar12) && (iVar12 < iVar9 + (doc_view->box).width)) {
                    uVar10 = iVar18 + 0x100U & 0xffffff00;
                    uVar11 = iVar18 + 0xffU & 0xffffff00;
                    if (uVar11 < uVar10) {
                      size = uVar10 * 8;
                      ppVar15 = (point *)mem_realloc(local_28,size);
                      if (ppVar15 == (point *)0x0) goto LAB_080f98ae;
                      memset(ppVar15 + uVar11,0,size + uVar11 * -8);
                      local_28 = ppVar15;
                    }
                    if (local_28 != (point *)0x0) {
                      local_28[iVar18].x = iVar17;
                      local_28[iVar18].y = psVar16->y;
                      iVar18 = iVar18 + 1;
                    }
                  }
LAB_080f98ae:
                  iVar19 = iVar19 + 1;
                } while (iVar19 < psVar16->n);
              }
              local_54 = local_54 + 1;
              psVar16 = psVar16 + 1;
            } while (local_54 < l);
          }
        } while( true );
      }
    }
  }
  else {
LAB_080f9708:
    assert_failed = 0;
  }
  return;
LAB_080f98d8:
  uVar13 = local_20[0]->c;
  if (uVar13 + 0x80 < 0x180) {
    pp_Var14 = __ctype_tolower_loc();
    uVar13 = (*pp_Var14)[uVar13];
  }
  goto LAB_080f97c3;
}



int __regparm3 find_next_link_in_search(document_view *doc_view,int direction)

{
  point *ppVar1;
  byte bVar2;
  point *ppVar3;
  point *ppVar4;
  point *ppVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  link *plVar10;
  undefined4 *puVar11;
  byte bVar12;
  int local_34;
  int local_24;
  point *local_20 [4];
  
  bVar12 = 0;
  bVar2 = *(byte *)&(doc_view->document->options).field_0x5c;
  if (assert_failed == 0) {
    if (doc_view->vs == (view_state *)0x0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
      errline = 0x3be;
      elinks_internal((uchar *)"assertion doc_view && doc_view->vs failed!");
      if (assert_failed != 0) goto LAB_080f9c10;
    }
    else {
      assert_failed = 0;
    }
    if ((direction != 2) && (local_34 = direction, direction != -2)) goto LAB_080f9c3e;
    local_34 = direction / 2;
    if (local_34 < 0) {
      find_link_page_up(doc_view);
    }
    else {
      find_link_page_down(doc_view);
    }
    iVar9 = doc_view->vs->current_link;
    iVar6 = 1;
    if (iVar9 != -1) {
      do {
        plVar10 = doc_view->document->links + iVar9;
        get_searched(doc_view,local_20,&local_24,(uint)(bVar2 >> 4 & 1));
        ppVar5 = local_20[0];
        iVar9 = local_24;
        iVar6 = plVar10->npoints;
        ppVar3 = plVar10->points;
        if (assert_failed == 0) {
          assert_failed = ZEXT14(ppVar3 == (point *)0x0);
          if (ppVar3 == (point *)0x0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
            errline = 0x394;
            elinks_internal((uchar *)"assertion p2 failed!");
            if (assert_failed != 0) goto LAB_080f9c28;
          }
          if (first_time != 0) {
            iVar8 = 0x400;
            puVar11 = (undefined4 *)hash;
            while (iVar8 != 0) {
              iVar8 = iVar8 + -1;
              *puVar11 = 0;
              puVar11 = puVar11 + (uint)bVar12 * 0x3ffffffe + 1;
            }
            first_time = 0;
          }
          if (0 < iVar9) {
            iVar8 = 0;
            do {
              ppVar4 = ppVar5 + iVar8;
              ppVar1 = ppVar5 + iVar8;
              iVar8 = iVar8 + 1;
              hash[ppVar4->y * 0x40 + ppVar1->x & 0xfff] = '\x01';
            } while (iVar8 != iVar9);
          }
          if (0 < iVar6) {
            iVar8 = 0;
            do {
              if ((hash[ppVar3[iVar8].y * 0x40 + ppVar3[iVar8].x & 0xfff] != '\0') && (0 < iVar9)) {
                iVar7 = 0;
                do {
                  if ((ppVar3[iVar8].x == ppVar5[iVar7].x) && (ppVar3[iVar8].y == ppVar5[iVar7].y))
                  {
                    iVar6 = 0;
                    do {
                      ppVar1 = ppVar5 + iVar6;
                      ppVar3 = ppVar5 + iVar6;
                      iVar6 = iVar6 + 1;
                      hash[ppVar1->y * 0x40 + ppVar3->x & 0xfff] = '\0';
                    } while (iVar6 != iVar9);
                    mem_free(local_20[0]);
                    return 0;
                  }
                  iVar7 = iVar7 + 1;
                } while (iVar7 < iVar9);
              }
              iVar8 = iVar8 + 1;
            } while (iVar8 < iVar6);
          }
          iVar6 = 0;
          if (0 < iVar9) {
            do {
              ppVar1 = ppVar5 + iVar6;
              ppVar3 = ppVar5 + iVar6;
              iVar6 = iVar6 + 1;
              hash[ppVar1->y * 0x40 + ppVar3->x & 0xfff] = '\0';
            } while (iVar6 != iVar9);
          }
        }
        else {
LAB_080f9c28:
          assert_failed = 0;
        }
        if (local_20[0] != (point *)0x0) {
          mem_free(local_20[0]);
        }
LAB_080f9c3e:
        iVar6 = doc_view->vs->current_link;
        if ((iVar6 == -1) ||
           (iVar6 = next_link_in_view(doc_view,iVar6 + local_34,local_34), iVar6 == 0)) {
          if (local_34 < 0) {
            find_link_page_up(doc_view);
            return 1;
          }
          find_link_page_down(doc_view);
          return 1;
        }
        local_20[0] = (point *)0x0;
        iVar9 = doc_view->vs->current_link;
      } while( true );
    }
  }
  else {
LAB_080f9c10:
    assert_failed = 0;
    iVar6 = 0;
  }
  return iVar6;
}



void draw_searched(terminal *term,document_view *doc_view)

{
  uchar *puVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  color_pair *color;
  int iVar6;
  int iVar7;
  int local_24;
  point *local_20 [4];
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(doc_view == (document_view *)0x0 || term == (terminal *)0x0);
    local_20[0] = (point *)0x0;
    local_24 = 0;
    if (doc_view == (document_view *)0x0 || term == (terminal *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
      errline = 0x31e;
      elinks_internal((uchar *)"assertion term && doc_view failed!");
      if (assert_failed != 0) goto LAB_080f9e30;
    }
    if (((doc_view->search_word != (uchar **)0x0) &&
        (puVar1 = *doc_view->search_word, puVar1 != (uchar *)0x0)) && (*puVar1 != '\0')) {
      get_searched(doc_view,local_20,&local_24,
                   (uint)(*(byte *)&(doc_view->document->options).field_0x5c >> 4) & 1);
      if (local_24 != 0) {
        color = get_bfu_color(term,"searched");
        iVar2 = (doc_view->box).x;
        iVar3 = (doc_view->box).y;
        iVar4 = doc_view->vs->x;
        iVar5 = doc_view->vs->y;
        if (0 < local_24) {
          iVar6 = 0;
          do {
            iVar7 = iVar6 + 1;
            draw_char_color(term,(iVar2 - iVar4) + local_20[0][iVar6].x,
                            (iVar3 - iVar5) + local_20[0][iVar6].y,color);
            iVar6 = iVar7;
          } while (iVar7 < local_24);
        }
      }
      if (local_20[0] != (point *)0x0) {
        mem_free(local_20[0]);
      }
    }
  }
  else {
LAB_080f9e30:
    assert_failed = 0;
  }
  return;
}



// WARNING: Type propagation algorithm not settling

find_error __regparm3 find_next_do(session *ses,document_view *doc_view,int direction)

{
  int height;
  unicode_val_T uVar1;
  int iVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  search *psVar6;
  byte bVar7;
  int l;
  int iVar8;
  int *piVar9;
  unicode_val_T *p;
  unicode_val_T uVar10;
  int iVar11;
  wint_t wVar12;
  __int32_t **pp_Var13;
  uchar *text;
  int iVar14;
  uint utf8;
  uchar *name;
  search *psVar15;
  search *psVar16;
  document *document;
  search *psVar17;
  int iVar18;
  int iVar19;
  int local_74;
  int local_44;
  int local_34;
  search *local_24;
  search *local_20 [4];
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FIND_ERROR_NONE;
  }
  if (((((ses == (session *)0x0) || (ses->tab == (window *)0x0)) ||
       (doc_view == (document_view *)0x0)) ||
      ((ses->tab->term == (terminal *)0x0 || (direction == 0)))) ||
     (doc_view->vs == (view_state *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
    errline = 0x3ed;
    elinks_internal((uchar *)
                    "assertion ses && ses->tab && ses->tab->term && doc_view && doc_view->vs && direction failed!"
                   );
    if (assert_failed != 0) {
      assert_failed = 0;
      return FIND_ERROR_NONE;
    }
  }
  else {
    assert_failed = 0;
  }
  direction = direction * ses->search_direction;
  local_34 = doc_view->vs->y;
  height = (doc_view->box).height;
  if (ses->search_word != (uchar *)0x0) {
    l = find_next_link_in_search(doc_view,direction);
    if (l == 0) {
      return FIND_ERROR_NONE;
    }
    local_34 = local_34 + direction * height;
    if (ses->search_word != (uchar *)0x0) goto LAB_080f9f98;
  }
  if (ses->last_search_word == (uchar *)0x0) {
    return FIND_ERROR_NO_PREVIOUS_SEARCH;
  }
  text = stracpy(ses->last_search_word);
  ses->search_word = text;
  if (text == (uchar *)0x0) {
    return FIND_ERROR_NONE;
  }
LAB_080f9f98:
  get_search_data(doc_view->document);
  document = doc_view->document;
  bVar4 = false;
  bVar5 = false;
  local_44 = 0;
  do {
    text = ses->search_word;
    if (assert_failed != 0) {
      assert_failed = 0;
      return FIND_ERROR_MEMORY;
    }
    if ((document == (document *)0x0) || (text == (uchar *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
      errline = 599;
      elinks_internal((uchar *)"assertion document && text && min && max failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return FIND_ERROR_MEMORY;
      }
    }
    else {
      assert_failed = 0;
    }
    bVar7 = *(byte *)&(document->options).field_0x5c >> 4;
    utf8 = (uint)bVar7 & 1;
    l = strlen_u(text,utf8);
    iVar8 = get_range(document,local_34,height,l,local_20,&local_24);
    psVar17 = local_20[0];
    psVar6 = local_24;
    if (iVar8 == 0) {
      piVar9 = get_opt_(config_options,name);
      iVar8 = *piVar9;
      if (iVar8 == 0) {
        p = lowered_string(text,l,utf8);
      }
      else {
        p = memacpy_u(text,l,utf8);
      }
      if (p == (unicode_val_T *)0x0) {
        return FIND_ERROR_MEMORY;
      }
      if (psVar17 <= psVar6) {
        uVar1 = *p;
        local_74 = 0x7fffffff;
        bVar3 = false;
        iVar18 = 0;
        if (iVar8 == 0) goto LAB_080fa16c;
        do {
          uVar10 = psVar17->c;
joined_r0x080fa156:
          if (uVar10 == uVar1) {
            iVar14 = 1;
            iVar11 = 0x10;
            psVar15 = psVar17;
            if (1 < l) {
              do {
                if (iVar8 == 0) {
                  if ((bVar7 & 1) == 0) {
                    uVar10 = psVar15[1].c;
                    if (uVar10 + 0x80 < 0x180) {
                      pp_Var13 = __ctype_tolower_loc();
                      uVar10 = (*pp_Var13)[uVar10];
                    }
                    goto LAB_080fa1a3;
                  }
                  wVar12 = towlower(psVar15[1].c);
                  if (p[iVar14] != wVar12) goto LAB_080fa15a;
                }
                else {
                  uVar10 = psVar15[1].c;
LAB_080fa1a3:
                  if (p[iVar14] != uVar10) goto LAB_080fa15a;
                }
                iVar14 = iVar14 + 1;
                psVar15 = psVar15 + 1;
              } while (iVar14 < l);
              iVar11 = iVar14 * 0x10;
            }
            iVar11 = *(int *)((int)&psVar17->y + iVar11);
            if ((local_34 <= iVar11) && (iVar11 < local_34 + height)) {
              iVar11 = 0;
              bVar3 = true;
              if (0 < l) {
                iVar14 = psVar17->n;
                psVar15 = psVar17;
                iVar19 = iVar18;
                if (iVar14 == 0) goto LAB_080fa27e;
                do {
                  iVar2 = psVar15->x;
                  iVar18 = iVar2 + iVar14;
                  if (iVar2 < local_74) {
                    local_74 = iVar2;
                  }
                  psVar16 = psVar15;
                  if (iVar18 <= iVar19) goto LAB_080fa27e;
                  while( true ) {
                    iVar11 = iVar11 + 1;
                    psVar15 = psVar16 + 1;
                    if (iVar11 == l) {
                      bVar3 = true;
                      goto LAB_080fa15a;
                    }
                    iVar14 = psVar16[1].n;
                    iVar19 = iVar18;
                    if (iVar14 != 0) break;
LAB_080fa27e:
                    iVar18 = iVar19;
                    psVar16 = psVar15;
                  }
                } while( true );
              }
            }
          }
LAB_080fa15a:
          psVar17 = psVar17 + 1;
          if (psVar6 < psVar17) {
            mem_free(p);
            if (bVar3) {
              doc_view->vs->y = local_34;
              if (local_74 <= iVar18) {
                iVar18 = iVar18 - (doc_view->box).width;
                height = doc_view->vs->x;
                if (iVar18 < height) {
                  iVar18 = height;
                }
                if (local_74 < iVar18) {
                  iVar18 = local_74;
                }
                doc_view->vs->x = iVar18;
              }
              set_link(doc_view);
              find_next_link_in_search(doc_view,direction * 2);
              if (!bVar4) {
                if (!bVar5) {
                  return FIND_ERROR_NONE;
                }
                return FIND_ERROR_HIT_BOTTOM;
              }
              return FIND_ERROR_HIT_TOP;
            }
            goto LAB_080fa060;
          }
        } while (iVar8 != 0);
LAB_080fa16c:
        if ((bVar7 & 1) == 0) {
          uVar10 = psVar17->c;
          if (uVar10 + 0x80 < 0x180) {
            pp_Var13 = __ctype_tolower_loc();
            uVar10 = (*pp_Var13)[uVar10];
          }
        }
        else {
          uVar10 = towlower(psVar17->c);
        }
        goto joined_r0x080fa156;
      }
      mem_free(p);
    }
LAB_080fa060:
    local_34 = local_34 + direction * height;
    document = doc_view->document;
    l = document->height;
    if (l < local_34) {
      bVar5 = true;
      local_34 = 0;
    }
    else {
      if (local_34 < 0) {
        local_34 = 0;
        iVar8 = height;
        if (0 < l) {
          do {
            local_34 = iVar8;
            iVar8 = local_34 + height;
          } while ((local_34 + height) - height < l);
        }
        local_34 = local_34 - height;
        bVar4 = true;
      }
    }
    local_44 = local_44 + height;
    if (l + height <= local_44) {
      return FIND_ERROR_NOT_FOUND;
    }
  } while( true );
}



find_error __regparm3 search_for_do(session *ses,uchar *str,int direction,int report_errors)

{
  document_view *doc_view;
  uchar *puVar1;
  find_error find_error;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(str == (uchar *)0x0 || ses == (session *)0x0);
    if (str == (uchar *)0x0 || ses == (session *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
      errline = 0x35a;
      elinks_internal((uchar *)"assertion ses && str failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return FIND_ERROR_NOT_FOUND;
      }
    }
    doc_view = current_frame(ses);
    if (assert_failed == 0) {
      assert_failed = ZEXT14(doc_view == (document_view *)0x0);
      if (doc_view == (document_view *)0x0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
        errline = 0x35f;
        elinks_internal((uchar *)"assertion doc_view failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return FIND_ERROR_NOT_FOUND;
        }
      }
      if (ses->search_word != (uchar *)0x0) {
        mem_free(ses->search_word);
      }
      ses->search_word = (uchar *)0x0;
      if (ses->last_search_word != (uchar *)0x0) {
        mem_free(ses->last_search_word);
      }
      ses->last_search_word = (uchar *)0x0;
      if (*str != '\0') {
        puVar1 = stracpy(str);
        ses->last_search_word = puVar1;
        if (puVar1 != (uchar *)0x0) {
          ses->search_direction = direction;
          find_error = find_next_do(ses,doc_view,1);
          if (report_errors != 0) {
            print_find_error(ses,find_error);
            return find_error;
          }
          return find_error;
        }
      }
      return FIND_ERROR_NOT_FOUND;
    }
  }
  assert_failed = 0;
  return FIND_ERROR_NOT_FOUND;
}



void search_for_back(session *ses,uchar *str)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(str == (uchar *)0x0 || ses == (session *)0x0);
  if (str == (uchar *)0x0 || ses == (session *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
    errline = 0x37a;
    elinks_internal((uchar *)"assertion ses && str failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  search_for_do(ses,str,-1,1);
  return;
}



void search_for(session *ses,uchar *str)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(str == (uchar *)0x0 || ses == (session *)0x0);
  if (str == (uchar *)0x0 || ses == (session *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
    errline = 899;
    elinks_internal((uchar *)"assertion ses && str failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  search_for_do(ses,str,1,1);
  return;
}



frame_event_status find_next(session *ses,document_view *doc_view,int direction)

{
  find_error find_error;
  
  find_error = find_next_do(ses,doc_view,direction);
  print_find_error(ses,find_error);
  return FRAME_EVENT_REFRESH;
}



input_line_code text_typeahead_handler(input_line *line,int action_id)

{
  int direction;
  session *ses;
  document_view *doc_view;
  find_error find_error;
  option_elinks *option_elinks;
  
  ses = line->ses;
  doc_view = current_frame(ses);
  direction = (uint)(*(char *)line->data == '/') * 2 + -1;
  if (assert_failed != 0) {
    assert_failed = 0;
    return INPUT_LINE_CANCEL;
  }
  assert_failed = ZEXT14(doc_view == (document_view *)0x0);
  if (doc_view == (document_view *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
    errline = 0x57b;
    elinks_internal((uchar *)"assertion doc_view != NULL failed: document not formatted");
    if (assert_failed != 0) {
      assert_failed = 0;
      return INPUT_LINE_CANCEL;
    }
  }
  switch(action_id) {
  case 0xe:
    if (line->buffer[0] == '\0') {
      search_for_do(ses,line->buffer,direction,0);
      return INPUT_LINE_CANCEL;
    }
    return INPUT_LINE_CANCEL;
  case 0x16:
    find_next(ses,doc_view,1);
    break;
  case 0x19:
    find_next(ses,doc_view,-1);
    break;
  case 0x1a:
    goto switchD_080fa820_caseD_1a;
  case 0x1c:
    option_elinks = get_opt_rec(config_options,(uchar *)"document.browse.search.regex");
    if (option_elinks != (option_elinks *)0x0) {
      option_elinks->value = (option_elinks->value + 1) % (option_elinks->max + 1);
      option_changed(ses,option_elinks);
    }
  default:
    find_error = search_for_do(ses,line->buffer,direction,0);
    if (find_error != FIND_ERROR_REGEX) {
      if (action_id == -1) {
        print_find_error(ses,find_error);
      }
      if (((1 < find_error + ~FIND_ERROR_NO_PREVIOUS_SEARCH) && (find_error != FIND_ERROR_NONE)) &&
         (line->buffer[0] != '\0')) {
        return INPUT_LINE_REWIND;
      }
    }
  }
  draw_formatted(ses,0);
switchD_080fa820_caseD_1a:
  return INPUT_LINE_PROCEED;
}



// WARNING: Type propagation algorithm not settling

frame_event_status search_dlg(session *ses,document_view *doc_view,int direction)

{
  terminal *term;
  code *data;
  int cp_index;
  uchar *codeset;
  session *p;
  option_elinks *root;
  dialog *dlg;
  uchar *codeset_00;
  session **values;
  char *msgid;
  bool bVar1;
  memory_list *local_20 [4];
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  assert_failed = ZEXT14(direction == 0);
  if (direction == 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
    errline = 0x6bd;
    elinks_internal((uchar *)"assertion direction failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  msgid = "Search";
  if (direction < 1) {
    msgid = "Search backward";
  }
  data = search_for_back;
  if (0 < direction) {
    data = search_for;
  }
  term = ses->tab->term;
  local_20[0] = (memory_list *)0x0;
  if ((term != (terminal *)0x0) &&
     (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
    codeset = get_cp_mime_name(cp_index);
    bind_textdomain_codeset("elinks",codeset);
    current_charset = cp_index;
  }
  codeset = gettext((uchar *)"Search for text");
  p = (session *)mem_calloc(1,8);
  if (p != (session *)0x0) {
    root = get_opt_rec(config_options,(uchar *)"document.browse.search");
    values = &p->prev;
    checkout_option_values(resolvers,root,values,1);
    p->next = ses;
    dlg = (dialog *)mem_calloc(1,0x514);
    if (dlg == (dialog *)0x0) {
      mem_free(p);
    }
    else {
      if (*msgid != '\0') {
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset_00 = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset_00);
          current_charset = cp_index;
        }
        msgid = (char *)gettext((uchar *)msgid);
      }
      *(byte *)&dlg->layout = *(byte *)&dlg->layout | 0xc;
      *(char **)&dlg->title = msgid;
      dlg->layouter = generic_dialog_layouter;
      *(uchar **)&dlg->udata = codeset;
      *(session **)&dlg->udata2 = p;
      add_to_ml(local_20,p,0);
      add_dlg_field_do(dlg,WIDGET_FIELD,codeset,0,0,(widget_handler_T *)0x0,0x400,&dlg[3].abort,
                       &search_history,INPFIELD_NONE);
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext((uchar *)"Case sensitive");
      add_dlg_radio_do(dlg,codeset,2,1,(int *)values);
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext((uchar *)"Case insensitive");
      add_dlg_radio_do(dlg,codeset,2,0,(int *)values);
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext("~OK");
      add_dlg_button_do(dlg,codeset,1,search_dlg_ok,data,(done_handler_T *)0x0,(void *)0x0);
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      codeset = gettext((uchar *)"~Cancel");
      add_dlg_button_do(dlg,codeset,2,search_dlg_cancel,(void *)0x0,(done_handler_T *)0x0,
                        (void *)0x0);
      if ((assert_failed == 0) &&
         (bVar1 = dlg->number_of_widgets != 5, assert_failed = ZEXT14(bVar1), bVar1)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
        errline = 0x6b1;
        elinks_internal((uchar *)"assertion 5 == (dlg)->number_of_widgets failed!");
      }
      add_to_ml(local_20,dlg,0);
      do_dialog(term,dlg,local_20[0]);
    }
  }
  return FRAME_EVENT_OK;
}



int __regparm3 get_textarea_line_number(line_info *line,int cursor_position)

{
  int iVar1;
  int iVar2;
  line_info *plVar3;
  line_info *local_14;
  
  iVar1 = line->start;
  if (iVar1 != -1) {
    iVar2 = 0;
    plVar3 = line;
    local_14 = line + 1;
    do {
      if ((iVar1 <= cursor_position) &&
         (cursor_position < (int)((uint)(line[iVar2 + 1].start != plVar3->end) + plVar3->end))) {
        return iVar2;
      }
      iVar2 = iVar2 + 1;
      iVar1 = local_14->start;
      plVar3 = local_14;
      local_14 = local_14 + 1;
    } while (iVar1 != -1);
  }
  return -1;
}



int do_op_home(form_state *fs,line_info *line,int current,int utf8)

{
  if (current != -1) {
    if (utf8 != 0) {
      fs->state = line[current - (uint)(fs->state_cell != 0)].start;
      return 0;
    }
    fs->state = line[current].start;
  }
  return 0;
}



int do_op_bob(form_state *fs,line_info *line,int current,int utf8)

{
  int iVar1;
  
  if (current != -1) {
    iVar1 = fs->state - line[current].start;
    fs->state = iVar1;
    if (line->end < iVar1) {
      fs->state = line->end;
    }
  }
  return 0;
}



int do_op_eob(form_state *fs,line_info *line,int current,int utf8)

{
  size_t cursor_position;
  int iVar1;
  int iVar2;
  
  if (current == -1) {
    cursor_position = strlen((char *)fs->value);
    fs->state = cursor_position;
  }
  else {
    cursor_position = strlen((char *)fs->value);
    iVar1 = get_textarea_line_number(line,cursor_position);
    if ((assert_failed == 0) && (assert_failed = ZEXT14(iVar1 == -1), iVar1 == -1)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0x3da;
      elinks_internal((uchar *)"assertion last != -1 failed: line info corrupt");
    }
    iVar2 = (line[iVar1].start + fs->state) - line[current].start;
    fs->state = iVar2;
    iVar1 = line[iVar1].end;
    if (iVar1 < iVar2) {
      fs->state = iVar1;
    }
  }
  return 0;
}



int do_op_right(form_state *fs,line_info *line,int current,int utf8)

{
  size_t sVar1;
  uchar *end;
  size_t sVar2;
  uchar *puVar3;
  uchar *local_20 [4];
  
  if (utf8 == 0) {
    sVar1 = strlen((char *)fs->value);
    sVar2 = fs->state + 1;
    if ((int)sVar1 <= (int)sVar2) {
      sVar2 = sVar1;
    }
    fs->state = sVar2;
    return 0;
  }
  if (fs->state_cell == 0) {
    local_20[0] = fs->value + fs->state;
    end = (uchar *)__rawmemchr(local_20[0],0);
    puVar3 = (uchar *)fs->state;
    utf8_to_unicode(local_20,end);
    local_20[0] = local_20[0] + -(int)fs->value;
    *(uchar **)&fs->state = local_20[0];
    if (puVar3 == local_20[0]) {
      if ((*(byte *)&line[current].field_0xc & 2) != 0) {
        return 0;
      }
    }
    else {
      if ((*(byte *)&line[current].field_0xc & 2) != 0) {
        if (local_20[0] != (uchar *)line[current].end) {
          puVar3 = (uchar *)0x0;
        }
        *(uchar **)&fs->state_cell = puVar3;
        return 0;
      }
    }
  }
  fs->state_cell = 0;
  return 0;
}



int do_op_left(form_state *fs,line_info *line,int current,int utf8)

{
  uchar *puVar1;
  uchar *puVar2;
  int iVar3;
  
  if (utf8 == 0) {
    iVar3 = fs->state + -1;
    if (-1 < iVar3) {
      utf8 = iVar3;
    }
    fs->state = utf8;
  }
  else {
    if (fs->state_cell != 0) {
      fs->state = fs->state_cell;
      fs->state_cell = 0;
      return 0;
    }
    puVar1 = (uchar *)fs->state;
    puVar2 = utf8_prevchar(fs->value + (int)puVar1,1,fs->value);
    puVar2 = puVar2 + -(int)fs->value;
    if (puVar1 != puVar2) {
      if (((uchar *)line[current].start != puVar1) || ((*(byte *)&line[current].field_0xc & 1) == 0)
         ) {
        *(uchar **)&fs->state = puVar2;
        return 0;
      }
      *(uchar **)&fs->state_cell = puVar2;
    }
  }
  return 0;
}



int do_op_end(form_state *fs,line_info *line,int current,int utf8)

{
  size_t sVar1;
  uchar *puVar2;
  int iVar3;
  
  if (current == -1) {
    sVar1 = strlen((char *)fs->value);
    fs->state = sVar1;
    return 0;
  }
  if (utf8 != 0) {
    iVar3 = line[current - (uint)(fs->state_cell != 0)].end;
    fs->state = iVar3;
    if ((*(byte *)&line[current - (uint)(fs->state_cell != 0)].field_0xc & 2) == 0) {
      fs->state_cell = 0;
    }
    else {
      puVar2 = utf8_prevchar(fs->value + iVar3,1,fs->value);
      *(uchar **)&fs->state_cell = puVar2 + -(int)fs->value;
    }
    return 0;
  }
  iVar3 = line[current].end - (uint)(line[current + 1].start == line[current].end);
  if (-1 < iVar3) {
    utf8 = iVar3;
  }
  fs->state = utf8;
  return 0;
}



frame_event_status textarea_op_enter(form_state *fs,form_control *fc,int utf8)

{
  size_t sVar1;
  uchar *puVar2;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  if (((fs == (form_state *)0x0) || (fc == (form_control *)0x0)) || (fs->value == (uchar *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 0x443;
    elinks_internal((uchar *)"assertion fs && fs->value && fc failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  else {
    assert_failed = 0;
  }
  if (((fc->mode == FORM_MODE_NORMAL) &&
      (sVar1 = strlen((char *)fs->value), sVar1 < (uint)fc->maxlength)) &&
     (puVar2 = insert_in_string(&fs->value,fs->state,"\n",1), puVar2 != (uchar *)0x0)) {
    fs->state = fs->state + 1;
    return FRAME_EVENT_REFRESH;
  }
  return FRAME_EVENT_OK;
}



void new_pos(form_state *fs,line_info *line,int current,int max_cells)

{
  int iVar1;
  int iVar2;
  unicode_val_T c;
  uchar *puVar3;
  int iVar4;
  uchar *local_20 [4];
  
  puVar3 = fs->value;
  local_20[0] = puVar3 + line[current].start;
  iVar1 = line[current].end;
  if (0 < max_cells) {
    iVar4 = 0;
    do {
      c = utf8_to_unicode(local_20,puVar3 + iVar1);
      if (c == 0xfffffffd) break;
      iVar2 = unicode_to_cell(c);
      iVar4 = iVar4 + iVar2;
    } while (iVar4 < max_cells);
    puVar3 = fs->value;
  }
  *(uchar **)&fs->state = local_20[0] + -(int)puVar3;
  return;
}



int do_op_down(form_state *fs,line_info *line,int current,int utf8)

{
  int current_00;
  int iVar1;
  int max_cells;
  uchar *puVar2;
  
  if (current != -1) {
    current_00 = current + 1;
    max_cells = fs->state_cell;
    if (line[current_00 - (uint)(max_cells != 0)].start == -1) {
      return 1;
    }
    if (utf8 == 0) {
      max_cells = (line[current_00].start + fs->state) - line[current].start;
      fs->state = max_cells;
      current_00 = line[current_00].end;
      if (current_00 < max_cells) {
        fs->state = current_00;
        return 0;
      }
    }
    else {
      iVar1 = fs->state;
      if (max_cells == 0) {
        max_cells = utf8_ptr2cells(fs->value + line[current].start,fs->value + iVar1);
        new_pos(fs,line,current_00,max_cells);
      }
      else {
        max_cells = utf8_ptr2cells(fs->value + line[current + -1].start,fs->value + max_cells);
        new_pos(fs,line,current,max_cells + line[current + -1].last_char_width);
      }
      max_cells = fs->state;
      if (max_cells != iVar1) {
        if ((fs->state_cell != 0) && (max_cells == line[current_00].start)) {
          puVar2 = utf8_prevchar(fs->value + max_cells,1,fs->value);
          *(uchar **)&fs->state_cell = puVar2 + -(int)fs->value;
          return 0;
        }
        fs->state_cell = 0;
        return 0;
      }
    }
  }
  return 0;
}



int do_op_up(form_state *fs,line_info *line,int current,int utf8)

{
  int iVar1;
  int local_40;
  uchar *puVar2;
  int current_00;
  int local_30;
  
  if (current != -1) {
    local_40 = fs->state_cell;
    if ((uint)(local_40 != 0) == current) {
      return 1;
    }
    if (utf8 == 0) {
      iVar1 = (line[current + -1].start + fs->state) - line[current].start;
      fs->state = iVar1;
      local_40 = line[current + -1].end;
      if (local_40 < iVar1) {
        fs->state = local_40;
        return 0;
      }
    }
    else {
      iVar1 = fs->state;
      if (local_40 == 0) {
        current_00 = current + -1;
        local_40 = utf8_ptr2cells(fs->value + line[current].start,fs->value + iVar1);
      }
      else {
        current_00 = current + -2;
        local_40 = utf8_ptr2cells(fs->value + line[current + -1].start,fs->value + local_40);
        local_40 = local_40 + line[current + -1].last_char_width;
      }
      local_30 = current + -1;
      new_pos(fs,line,current_00,local_40);
      local_40 = fs->state;
      if (local_40 != iVar1) {
        if ((fs->state_cell != 0) && (local_40 == line[local_30].start)) {
          puVar2 = utf8_prevchar(fs->value + local_40,1,fs->value);
          *(uchar **)&fs->state_cell = puVar2 + -(int)fs->value;
          return 0;
        }
        fs->state_cell = 0;
        return 0;
      }
    }
  }
  return 0;
}



void textarea_edit(int op,terminal *term_,form_state *fs_,document_view *doc_view_,link *link_)

{
  uchar *__ptr;
  bool bVar1;
  uchar *fn;
  link *link;
  document_view *doc_view;
  terminal *term;
  form_state *fs;
  size_t fc_maxlength;
  string *psVar2;
  int *piVar3;
  uchar **ppuVar4;
  int __fd;
  size_t __size;
  uchar *name;
  FILE *__s;
  int iVar5;
  uint in_EDX;
  uchar *extraout_EDX;
  char *local_4c;
  uchar *local_30;
  string file;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(1U < (uint)op);
  if (1U < (uint)op) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 0x241;
    elinks_internal((uchar *)"assertion op == 0 || op == 1 failed!");
    in_EDX = assert_failed;
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  name = (uchar *)(in_EDX & 0xffffff00 | (uint)(term_ == (terminal *)0x0));
  bVar1 = term_ == (terminal *)0x0 && op != 1;
  assert_failed = ZEXT14(bVar1);
  if (bVar1) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 0x243;
    elinks_internal((uchar *)"assertion op == 1 || term_ failed!");
    name = extraout_EDX;
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (op == 0) {
    piVar3 = get_opt_(cmdline_options,name);
    if (*piVar3 == 0) {
      if ((*(byte *)&term_->field_0x38 & 1) != 0) {
        if (textarea_editor != 0) {
          return;
        }
        ppuVar4 = (uchar **)get_opt_(config_options,(uchar *)0x0);
        name = *ppuVar4;
        __ptr = fs_->value;
        fn = get_tempdir_filename((uchar *)"elinks-area-XXXXXX");
        if (fn == (uchar *)0x0) {
          return;
        }
        __fd = safe_mkstemp(fn);
        if (__fd < 0) {
          mem_free(fn);
          return;
        }
        __size = strlen((char *)__ptr);
        if (__size != 0) {
          __s = fdopen(__fd,"w");
          if (__s == (FILE *)0x0) {
error:
            unlink((char *)fn);
            mem_free(fn);
            close(__fd);
            return;
          }
          __size = fwrite(__ptr,__size,1,__s);
          if (__size != 1) {
            fclose(__s);
            goto error;
          }
          iVar5 = fclose(__s);
          if (iVar5 != 0) goto error;
        }
        if ((name == (uchar *)0x0) || (local_30 = fn, *name == '\0')) {
          name = (uchar *)getenv("EDITOR");
          if ((name == (uchar *)0x0) || (*name == '\0')) {
            name = "vi";
          }
          local_30 = fn;
        }
        fn = local_30;
        name = straconcat(name,&DAT_08134f9c,local_30,0);
        if (name != (uchar *)0x0) {
          fs = fs_;
          if (doc_view_ != (document_view *)0x0) {
            doc_view = doc_view_;
          }
          if (link_ != (link *)0x0) {
            link = link_;
            __fd = 0;
            if (LINK_MAP < link_->type) {
              __fd = link_->data;
            }
            fc_maxlength = *(size_t *)(__fd + 0x40);
          }
          term = term_;
          exec_on_terminal(term_,name,"",TERM_EXEC_FG);
          mem_free(name);
          textarea_editor = 1;
          return;
        }
        unlink((char *)fn);
        goto free_and_return;
      }
      local_4c = "You can do this only on the master terminal";
    }
    else {
      local_4c = "You cannot launch an external editor in the anonymous mode.";
    }
    info_box(term_,0,"Error",ALIGN_CENTER,(uchar *)local_4c);
  }
  else {
    if (op != 1) {
      return;
    }
    if (fs == (form_state *)0x0) {
      return;
    }
    psVar2 = init_string(&file);
    if ((psVar2 != (string *)0x0) &&
       (psVar2 = add_file_to_string(&file,fn), psVar2 != (string *)0x0)) {
      if (fc_maxlength < (uint)file.length) {
        file.source[fc_maxlength] = '\0';
        name = msg_text(term,(uchar *)
                             "You have exceeded the textarea\'s size limit: your input is %d bytes, but the maximum is %u bytes.\n\nYour input has been truncated, but you can still recover the text that you entered from this file: %s"
                        ,file.length,fc_maxlength,fn);
        info_box(term,MSGBOX_FREE_TEXT,(uchar *)"Warning",ALIGN_CENTER,name);
      }
      else {
        unlink((char *)fn);
      }
      mem_free(fs->value);
      fs->value = file.source;
      fs->state = file.length;
      if ((doc_view != (document_view *)0x0) && (link != (link *)0x0)) {
        draw_form_entry(term,doc_view,link);
      }
    }
    textarea_editor = 0;
free_and_return:
    if (fn != (uchar *)0x0) {
      mem_free(fn);
    }
  }
  return;
}



void menu_textarea_edit(terminal *term,void *xxx,void *ses_)

{
  int iVar1;
  document_view *doc_view;
  form_control *fc;
  form_state *fs_;
  link *link_;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(ses_ == (void *)0x0 || term == (terminal *)0x0);
    if (ses_ == (void *)0x0 || term == (terminal *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0x2ad;
      elinks_internal((uchar *)"assertion term && ses failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    doc_view = current_frame((session *)ses_);
    if (assert_failed == 0) {
      if (((doc_view == (document_view *)0x0) || (doc_view->vs == (view_state *)0x0)) ||
         (doc_view->document == (document *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
        errline = 0x2b2;
        elinks_internal((uchar *)"assertion doc_view && doc_view->vs && doc_view->document failed!")
        ;
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
        if (doc_view == (document_view *)0x0) {
          return;
        }
      }
      else {
        assert_failed = 0;
      }
      iVar1 = doc_view->vs->current_link;
      if (iVar1 < 0) {
        return;
      }
      if (iVar1 < doc_view->document->nlinks) {
        link_ = doc_view->document->links + iVar1;
        if (link_ == (link *)0x0) {
          return;
        }
        fc = (form_control *)0x0;
        if (LINK_MAP < link_->type) {
          fc = (form_control *)link_->data;
        }
        if (fc->mode == FORM_MODE_NORMAL) {
          fs_ = find_form_state(doc_view,fc);
          if (fs_ != (form_state *)0x0) {
            textarea_edit(0,term,fs_,doc_view,link_);
            return;
          }
          return;
        }
        return;
      }
      return;
    }
  }
  assert_failed = 0;
  return;
}



line_info * __regparm3 format_textutf8(uchar *text,int width,form_wrap wrap)

{
  uchar uVar1;
  uchar *puVar2;
  size_t sVar3;
  int iVar4;
  uint uVar5;
  size_t size;
  uint uVar6;
  uint uVar7;
  uchar *utf8_char;
  uchar *puVar8;
  line_info *p;
  int iVar9;
  bool bVar10;
  byte bVar11;
  uchar *local_44;
  uchar *local_34;
  int local_30;
  line_info *local_20;
  
  bVar11 = 0;
  if (assert_failed == 0) {
    assert_failed = ZEXT14(text == (uchar *)0x0);
    if (text == (uchar *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0x4e;
      elinks_internal((uchar *)"assertion text failed!");
      if (assert_failed != 0) goto LAB_080fbdd6;
    }
    local_20 = (line_info *)mem_realloc((void *)0x0,0x1000);
    if (local_20 != (line_info *)0x0) {
      bVar10 = ((uint)local_20 & 1) != 0;
      uVar7 = 0x1000;
      p = local_20;
      if (bVar10) {
        *(undefined *)&local_20->start = 0;
        p = (line_info *)((int)&local_20->start + 1);
        uVar7 = 0xfff;
      }
      if (((uint)p & 2) != 0) {
        *(undefined2 *)&p->start = 0;
        uVar7 = uVar7 - 2;
        p = (line_info *)((int)&p->start + 2);
      }
      uVar6 = uVar7 >> 2;
      while (uVar6 != 0) {
        uVar6 = uVar6 - 1;
        p->start = 0;
        p = (line_info *)((int)p + (uint)bVar11 * -8 + 4);
      }
      if ((uVar7 & 2) != 0) {
        *(undefined2 *)&p->start = 0;
        p = (line_info *)((int)&p->start + 2);
      }
      if (bVar10) {
        *(undefined *)&p->start = 0;
      }
      if (local_20 != (line_info *)0x0) {
        puVar8 = (uchar *)0x0;
        iVar9 = 0;
        sVar3 = strlen((char *)text);
        local_30 = 0;
        local_34 = (uchar *)0x0;
        local_44 = (uchar *)0x0;
LAB_080fbc60:
        utf8_char = text + (int)puVar8;
        uVar1 = *utf8_char;
        puVar2 = local_34;
        p = local_20;
        do {
          if (uVar1 == '\0') {
            *(byte *)&p[iVar9].field_0xc = *(byte *)&p[iVar9].field_0xc & 0xfd;
            *(uchar **)&p[iVar9].start = local_44;
            *(uchar **)&p[iVar9].end = puVar8;
            p[iVar9 + 1].end = -1;
            p[iVar9 + 1].start = -1;
            *(byte *)&p[iVar9 + 1].field_0xc = *(byte *)&p[iVar9 + 1].field_0xc & 0xfc;
            *(byte *)&p->field_0xc = *(byte *)&p->field_0xc & 0xfe;
            return p;
          }
          iVar4 = utf8_char2cells(utf8_char,text + sVar3);
          local_34 = utf8_char;
          local_20 = p;
          if ((*utf8_char == ' ') || (uVar7 = 1, local_34 = puVar2, *utf8_char != '\n')) {
            if ((wrap == FORM_WRAP_NONE) || (local_30 + iVar4 < width)) goto LAB_080fbdfb;
            if (local_34 != (uchar *)0x0) {
              puVar8 = local_34 + -(int)text;
            }
            uVar7 = (uint)(local_34 != (uchar *)0x0);
          }
          uVar6 = iVar9 + 0xff;
          uVar5 = iVar9 + 0x102U & 0xffffff00;
          if ((uVar6 & 0xffffff00) <= uVar5 && uVar5 + (uVar6 >> 8) * -0x100 != 0) {
            size = (iVar9 + 0x102U >> 8) * 0x1000;
            local_20 = (line_info *)mem_realloc(p,size);
            if (local_20 == (line_info *)0x0) {
              if (p == (line_info *)0x0) {
                return (line_info *)0x0;
              }
              mem_free(p);
              return (line_info *)0x0;
            }
            memset(local_20 + (uVar6 & 0xffffff00),0,size + (uVar6 >> 8) * -0x1000);
          }
          if (local_20 == (line_info *)0x0) {
            return (line_info *)0x0;
          }
          local_20[iVar9].last_char_width = iVar4;
          iVar4 = iVar9 + 1;
          *(byte *)&local_20[iVar9].field_0xc =
               *(byte *)&local_20[iVar9].field_0xc & 0xfd | (uVar7 == 0) * '\x02';
          *(uchar **)&local_20[iVar9].start = local_44;
          *(uchar **)&local_20[iVar9].end = puVar8;
          puVar8 = puVar8 + uVar7;
          *(byte *)&local_20[iVar4].field_0xc =
               *(byte *)&local_20[iVar4].field_0xc & 0xfe | uVar7 == 0;
          local_30 = 0;
          local_34 = (uchar *)0x0;
          utf8_char = text + (int)puVar8;
          uVar1 = *utf8_char;
          iVar9 = iVar4;
          local_44 = puVar8;
          puVar2 = local_34;
          p = local_20;
        } while( true );
      }
    }
  }
  else {
LAB_080fbdd6:
    assert_failed = 0;
  }
  return (line_info *)0x0;
LAB_080fbdfb:
  local_30 = local_30 + iVar4;
  iVar4 = utf8charlen(utf8_char);
  puVar8 = puVar8 + iVar4;
  goto LAB_080fbc60;
}



line_info * __regparm3 format_text(uchar *text,int width,form_wrap wrap,int format)

{
  uchar uVar1;
  undefined *puVar2;
  uint uVar3;
  size_t size;
  uint uVar4;
  uint uVar5;
  undefined *puVar6;
  line_info *p;
  int iVar7;
  bool bVar8;
  byte bVar9;
  undefined *local_30;
  line_info *local_20;
  
  bVar9 = 0;
  if (assert_failed == 0) {
    assert_failed = ZEXT14(text == (uchar *)0x0);
    if (text == (uchar *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0xa2;
      elinks_internal((uchar *)"assertion text failed!");
      if (assert_failed != 0) goto LAB_080fc08e;
    }
    local_20 = (line_info *)mem_realloc((void *)0x0,0x1000);
    if (local_20 != (line_info *)0x0) {
      bVar8 = ((uint)local_20 & 1) != 0;
      uVar5 = 0x1000;
      p = local_20;
      if (bVar8) {
        *(undefined *)&local_20->start = 0;
        p = (line_info *)((int)&local_20->start + 1);
        uVar5 = 0xfff;
      }
      if (((uint)p & 2) != 0) {
        *(undefined2 *)&p->start = 0;
        uVar5 = uVar5 - 2;
        p = (line_info *)((int)&p->start + 2);
      }
      uVar4 = uVar5 >> 2;
      while (uVar4 != 0) {
        uVar4 = uVar4 - 1;
        p->start = 0;
        p = (line_info *)((int)p + (uint)bVar9 * -8 + 4);
      }
      if ((uVar5 & 2) != 0) {
        *(undefined2 *)&p->start = 0;
        p = (line_info *)((int)&p->start + 2);
      }
      if (bVar8) {
        *(undefined *)&p->start = 0;
      }
      if (local_20 != (line_info *)0x0) {
        iVar7 = 0;
        local_30 = (undefined *)0x0;
        puVar6 = (undefined *)0x0;
LAB_080fbf60:
        uVar1 = text[(int)puVar6];
        p = local_20;
        do {
          if (uVar1 == '\0') {
            *(undefined **)&p[iVar7].start = local_30;
            *(undefined **)&p[iVar7].end = puVar6;
            p[iVar7 + 1].end = -1;
            p[iVar7 + 1].start = -1;
            return p;
          }
          uVar5 = 1;
          local_20 = p;
          if (uVar1 != '\n') {
            if ((wrap == FORM_WRAP_NONE) || ((int)(puVar6 + -(int)local_30) < width))
            goto LAB_080fc0b8;
            puVar2 = (undefined *)
                     memrchr(text + (int)local_30,0x20,(size_t)(puVar6 + -(int)local_30));
            if (puVar2 != (undefined *)0x0) {
              if ((format != 0) && (wrap == FORM_WRAP_HARD)) {
                *puVar2 = 10;
              }
              puVar6 = puVar2 + -(int)text;
            }
            uVar5 = (uint)(puVar2 != (undefined *)0x0);
          }
          uVar4 = iVar7 + 0xff;
          uVar3 = iVar7 + 0x102U & 0xffffff00;
          if ((uVar4 & 0xffffff00) <= uVar3 && uVar3 + (uVar4 >> 8) * -0x100 != 0) {
            size = (iVar7 + 0x102U >> 8) * 0x1000;
            local_20 = (line_info *)mem_realloc(p,size);
            if (local_20 == (line_info *)0x0) {
              if (p == (line_info *)0x0) {
                return (line_info *)0x0;
              }
              mem_free(p);
              return (line_info *)0x0;
            }
            memset(local_20 + (uVar4 & 0xffffff00),0,size + (uVar4 >> 8) * -0x1000);
          }
          if (local_20 == (line_info *)0x0) {
            return (line_info *)0x0;
          }
          *(undefined **)&local_20[iVar7].start = local_30;
          *(undefined **)&local_20[iVar7].end = puVar6;
          puVar6 = puVar6 + uVar5;
          uVar1 = text[(int)puVar6];
          iVar7 = iVar7 + 1;
          local_30 = puVar6;
          p = local_20;
        } while( true );
      }
    }
  }
  else {
LAB_080fc08e:
    assert_failed = 0;
  }
  return (line_info *)0x0;
LAB_080fc0b8:
  puVar6 = puVar6 + 1;
  goto LAB_080fbf60;
}



frame_event_status __regparm3
textarea_op(form_state *fs,form_control *fc,int utf8,
           anon_subr_int_form_state_ptr_line_info_ptr_int_int *do_op)

{
  int iVar1;
  int iVar2;
  line_info *line;
  int iVar3;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  if (((fs == (form_state *)0x0) || (fc == (form_control *)0x0)) || (fs->value == (uchar *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 0x2cb;
    elinks_internal((uchar *)"assertion fs && fs->value && fc failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  else {
    assert_failed = 0;
  }
  if (utf8 == 0) {
    line = format_text(fs->value,fc->cols,fc->wrap,0);
  }
  else {
    line = format_textutf8(fs->value,fc->cols,fc->wrap);
  }
  if (line != (line_info *)0x0) {
    iVar3 = get_textarea_line_number(line,fs->state);
    iVar1 = fs->state;
    iVar2 = fs->state_cell;
    iVar3 = (*do_op)(fs,line,iVar3,utf8);
    if (iVar3 != 0) {
      mem_free(line);
      return FRAME_EVENT_IGNORED;
    }
    mem_free(line);
    if ((fs->state != iVar1) || (fs->state_cell != iVar2)) {
      return FRAME_EVENT_REFRESH;
    }
  }
  return FRAME_EVENT_OK;
}



frame_event_status textarea_op_right(form_state *fs,form_control *fc,int utf8)

{
  frame_event_status fVar1;
  
  fVar1 = textarea_op(fs,fc,utf8,do_op_right);
  return fVar1;
}



frame_event_status textarea_op_left(form_state *fs,form_control *fc,int utf8)

{
  frame_event_status fVar1;
  
  fVar1 = textarea_op(fs,fc,utf8,do_op_left);
  return fVar1;
}



frame_event_status textarea_op_eob(form_state *fs,form_control *fc,int utf8)

{
  frame_event_status fVar1;
  
  fVar1 = textarea_op(fs,fc,utf8,do_op_eob);
  return fVar1;
}



frame_event_status textarea_op_bob(form_state *fs,form_control *fc,int utf8)

{
  frame_event_status fVar1;
  
  fVar1 = textarea_op(fs,fc,utf8,do_op_bob);
  return fVar1;
}



void set_textarea(document_view *doc_view,int direction)

{
  byte bVar1;
  int iVar2;
  form_control *fc;
  bool bVar3;
  form_state *fs;
  link *plVar4;
  uint utf8;
  
  bVar1 = *(byte *)&(doc_view->document->options).field_0x5c;
  if (assert_failed == 0) {
    if (doc_view->vs == (view_state *)0x0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0x4a9;
      elinks_internal((uchar *)"assertion doc_view && doc_view->vs && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080fc430;
    }
    bVar3 = direction != -1 && direction != 1;
    assert_failed = ZEXT14(bVar3);
    if (bVar3) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0x4aa;
      elinks_internal((uchar *)"assertion direction == 1 || direction == -1 failed!");
      if (assert_failed != 0) goto LAB_080fc430;
    }
    iVar2 = doc_view->vs->current_link;
    if (iVar2 < 0) {
      return;
    }
    if (doc_view->document->nlinks <= iVar2) {
      return;
    }
    plVar4 = doc_view->document->links + iVar2;
    if (plVar4 == (link *)0x0) {
      return;
    }
    if (plVar4->type != LINK_AREA) {
      return;
    }
    fc = (form_control *)plVar4->data;
    assert_failed = ZEXT14(fc == (form_control *)0x0);
    if (fc == (form_control *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0x4b2;
      elinks_internal((uchar *)"assertion fc != NULL failed: link has no form control");
      if (assert_failed != 0) goto LAB_080fc430;
    }
    if (((fc->mode != FORM_MODE_DISABLED) &&
        (fs = find_form_state(doc_view,fc), fs != (form_state *)0x0)) && (fs->value != (uchar *)0x0)
       ) {
      utf8 = (uint)(bVar1 >> 4 & 1);
      if (direction == 1) {
        textarea_op_eob(fs,fc,utf8);
      }
      else {
        textarea_op_bob(fs,fc,utf8);
      }
    }
  }
  else {
LAB_080fc430:
    assert_failed = 0;
  }
  return;
}



frame_event_status textarea_op_end(form_state *fs,form_control *fc,int utf8)

{
  frame_event_status fVar1;
  
  fVar1 = textarea_op(fs,fc,utf8,do_op_end);
  return fVar1;
}



frame_event_status textarea_op_down(form_state *fs,form_control *fc,int utf8)

{
  frame_event_status fVar1;
  
  fVar1 = textarea_op(fs,fc,utf8,do_op_down);
  return fVar1;
}



frame_event_status textarea_op_up(form_state *fs,form_control *fc,int utf8)

{
  frame_event_status fVar1;
  
  fVar1 = textarea_op(fs,fc,utf8,do_op_up);
  return fVar1;
}



frame_event_status textarea_op_home(form_state *fs,form_control *fc,int utf8)

{
  frame_event_status fVar1;
  
  fVar1 = textarea_op(fs,fc,utf8,do_op_home);
  return fVar1;
}



int area_cursor(form_control *fc,form_state *fs,int utf8)

{
  line_info *line;
  int cursor_position;
  int iVar1;
  int iVar2;
  int iVar3;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  assert_failed = ZEXT14(fs == (form_state *)0x0 || fc == (form_control *)0x0);
  if (fs == (form_state *)0x0 || fc == (form_control *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 0xf3;
    elinks_internal((uchar *)"assertion fc && fs failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  if (utf8 == 0) {
    line = format_text(fs->value,fc->cols,fc->wrap,0);
  }
  else {
    line = format_textutf8(fs->value,fc->cols,fc->wrap);
  }
  if (line == (line_info *)0x0) {
    return 0;
  }
  cursor_position = fs->state_cell;
  if (cursor_position == 0) {
    cursor_position = fs->state;
  }
  cursor_position = get_textarea_line_number(line,cursor_position);
  if (cursor_position == -1) {
    mem_free(line);
    return 0;
  }
  if (utf8 == 0) {
    iVar1 = fs->state - line[cursor_position].start;
    if (fc->wrap != FORM_WRAP_NONE) {
      iVar1 = iVar1 - (uint)(fc->cols == iVar1);
    }
  }
  else {
    if (fs->state_cell == 0) {
      iVar1 = utf8_ptr2cells(fs->value + line[cursor_position].start,fs->value + fs->state);
    }
    else {
      iVar1 = utf8_ptr2cells(fs->value + line[cursor_position].start,fs->value + fs->state_cell);
      iVar1 = iVar1 + line[cursor_position].last_char_width;
    }
  }
  mem_free(line);
  iVar3 = (iVar1 - fc->cols) + 1;
  if (fs->vpos < iVar3) {
    fs->vpos = iVar3;
LAB_080fc64c:
    iVar3 = fs->vypos;
    iVar2 = (cursor_position - fc->rows) + 1;
    if (iVar2 <= iVar3) {
LAB_080fc71e:
      if (cursor_position < iVar3) {
        fs->vypos = cursor_position;
        cursor_position = 0;
      }
      else {
        cursor_position = (cursor_position - iVar3) * fc->cols;
      }
      goto LAB_080fc668;
    }
  }
  else {
    if (fs->vpos <= iVar1) goto LAB_080fc64c;
    fs->vpos = iVar1;
    iVar3 = fs->vypos;
    iVar2 = (cursor_position - fc->rows) + 1;
    if (iVar2 <= iVar3) goto LAB_080fc71e;
  }
  fs->vypos = iVar2;
  cursor_position = (cursor_position - iVar2) * fc->cols;
LAB_080fc668:
  return (iVar1 - fs->vpos) + cursor_position;
}



uchar * encode_textarea(submitted_value *sv)

{
  line_info *p;
  uchar *puVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (uchar *)0x0;
  }
  if ((sv == (submitted_value *)0x0) || (sv->value == (uchar *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 0x1ef;
    elinks_internal((uchar *)"assertion sv && sv->value failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (uchar *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  p = format_text(sv->value,sv->form_control->cols,sv->form_control->wrap,1);
  if (p != (line_info *)0x0) {
    mem_free(p);
  }
  puVar1 = encode_crlf(sv);
  return puVar1;
}



// WARNING: Type propagation algorithm not settling

void draw_textarea(terminal *term,form_state *fs,document_view *doc_view,link *link)

{
  line_info *p;
  int x;
  int x_00;
  int iVar1;
  int iVar2;
  uchar *end;
  unicode_val_T c;
  unicode_val_T data;
  uchar *string;
  int y;
  int x_01;
  bool bVar3;
  line_info *local_40;
  form_control *local_3c;
  int local_38;
  form_control *local_34;
  line_info *local_30;
  uchar *local_20 [4];
  
  if (assert_failed == 0) {
    if ((((doc_view == (document_view *)0x0) || (term == (terminal *)0x0)) ||
        (doc_view->document == (document *)0x0)) ||
       ((link == (link *)0x0 || (doc_view->vs == (view_state *)0x0)))) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0x1a1;
      elinks_internal((uchar *)
                      "assertion term && doc_view && doc_view->document && doc_view->vs && link failed!"
                     );
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    if ((*(byte *)&term->field_0x38 & 2) == 0) {
      if (link->type < LINK_BUTTON) {
        assert_failed = 1;
        local_34 = (form_control *)0x0;
      }
      else {
        local_34 = (form_control *)link->data;
        assert_failed = ZEXT14(local_34 == (form_control *)0x0);
        if (local_34 != (form_control *)0x0) goto LAB_080fc8e0;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0x1ab;
      elinks_internal((uchar *)"assertion fc != NULL failed: link %d has no form control",
                      ((int)((int)link - (int)doc_view->document->links) >> 2) * -0x3b13b13b);
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
LAB_080fc8e0:
      iVar2 = doc_view->vs->x;
      y = doc_view->vs->y;
      if (link->npoints == 0) {
        return;
      }
      area_cursor(local_34,fs,0);
      p = format_text(fs->value,local_34->cols,local_34->wrap,0);
      if (p == (line_info *)0x0) {
        return;
      }
      x = fs->vypos;
      x_01 = p->start;
      local_30 = p;
      while ((x != 0 && (x_01 != -1))) {
        local_30 = local_30 + 1;
        x_01 = local_30->start;
        x = x + -1;
      }
      x = (doc_view->box).y;
      iVar2 = ((doc_view->box).x + link->points->x) - iVar2;
      y = (link->points->y + x) - y;
      x_00 = local_34->rows + y;
      if ((x_01 != -1) && (y < x_00)) {
        while( true ) {
          if ((x <= y) && ((y < x + (doc_view->box).height && (0 < local_34->cols)))) {
            x = 0;
            do {
              iVar1 = (doc_view->box).x;
              x_01 = x + iVar2;
              if ((iVar1 <= x_01) && (x_01 < iVar1 + (doc_view->box).width)) {
                iVar1 = fs->vpos;
                if ((-x == iVar1 || -iVar1 < x) && (iVar1 + x < local_30->end - local_30->start)) {
                  local_3c = (form_control *)(uint)fs->value[local_30->start + x + iVar1];
                }
                else {
                  local_3c = (form_control *)0x5f;
                }
                draw_char_data(term,x_01,y,(unicode_val_T)local_3c);
              }
              x = x + 1;
            } while (local_34->cols != x && x <= local_34->cols);
          }
          local_30 = local_30 + 1;
          y = y + 1;
          if (x_00 <= y) goto LAB_080fcb87;
          if (local_30->start == -1) break;
          x = (doc_view->box).y;
        }
      }
      while (y < x_00) {
        x = (doc_view->box).y;
        if (((x <= y) && (y < x + (doc_view->box).height)) && (0 < local_34->cols)) {
          x = 0;
          do {
            iVar1 = (doc_view->box).x;
            x_01 = x + iVar2;
            if ((iVar1 <= x_01) && (x_01 < iVar1 + (doc_view->box).width)) {
              draw_char_data(term,x_01,y,0x5f);
            }
            x = x + 1;
          } while (local_34->cols != x && x <= local_34->cols);
        }
        y = y + 1;
      }
LAB_080fcb87:
      mem_free(p);
      return;
    }
    if (((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) ||
       ((link == (link *)0x0 || (doc_view->vs == (view_state *)0x0)))) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0x14f;
      elinks_internal((uchar *)
                      "assertion term && doc_view && doc_view->document && doc_view->vs && link failed!"
                     );
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    if (link->type < LINK_BUTTON) {
      assert_failed = 1;
      local_3c = (form_control *)0x0;
    }
    else {
      local_3c = (form_control *)link->data;
      assert_failed = ZEXT14(local_3c == (form_control *)0x0);
      if (local_3c != (form_control *)0x0) goto LAB_080fcc4f;
    }
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 0x152;
    elinks_internal((uchar *)"assertion fc != NULL failed: link %d has no form control",
                    ((int)((int)link - (int)doc_view->document->links) >> 2) * -0x3b13b13b);
    if (assert_failed == 0) {
LAB_080fcc4f:
      iVar2 = doc_view->vs->x;
      local_38 = doc_view->vs->y;
      if (link->npoints == 0) {
        return;
      }
      area_cursor(local_3c,fs,1);
      p = format_textutf8(fs->value,local_3c->cols,local_3c->wrap);
      if (p == (line_info *)0x0) {
        return;
      }
      y = fs->vypos;
      x = p->start;
      bVar3 = x != -1;
      local_40 = p;
      if ((bVar3) && (y != 0)) {
        do {
          local_40 = local_40 + 1;
          x = local_40->start;
          bVar3 = x != -1;
          y = y + -1;
          if (y == 0) break;
        } while (bVar3);
      }
      iVar2 = ((doc_view->box).x + link->points->x) - iVar2;
      local_38 = ((doc_view->box).y + link->points->y) - local_38;
      y = local_38 + local_3c->rows;
      if ((bVar3) && (local_38 < y)) {
        do {
          string = fs->value + x;
          end = fs->value + local_40->end;
          local_20[0] = string;
          x = utf8_cells2bytes(string,fs->vpos,end);
          local_20[0] = string + x;
          x = (doc_view->box).y;
          if ((x <= local_38) && ((local_38 < x + (doc_view->box).height && (0 < local_3c->cols))))
          {
            x_01 = 0;
            x = iVar2;
            do {
              if ((local_20[0] < end) && (-x_01 == fs->vpos || -fs->vpos < x_01)) {
                c = utf8_to_unicode(local_20,end);
              }
              else {
                c = 0x5f;
              }
              iVar1 = (doc_view->box).x;
              x_00 = x;
              if ((x < iVar1) || (iVar1 + (doc_view->box).width <= x)) {
                x_01 = x_01 + 1;
                if (local_3c->cols <= x_01) break;
              }
              else {
                iVar1 = unicode_to_cell(c);
                data = c;
                if (iVar1 == 2) {
                  x_00 = x + 1;
                  x_01 = x_01 + 1;
                  data = 0xfffffffd;
                  draw_char_data(term,x,local_38,c);
                }
                x_01 = x_01 + 1;
                draw_char_data(term,x_00,local_38,data);
                if (local_3c->cols <= x_01) break;
              }
              x = x_00 + 1;
            } while( true );
          }
          local_40 = local_40 + 1;
          local_38 = local_38 + 1;
          x = local_40->start;
          if (y <= local_38) goto LAB_080fcea8;
        } while (x != -1);
      }
      while (local_38 < y) {
        x = (doc_view->box).y;
        if (((x <= local_38) && (local_38 < x + (doc_view->box).height)) && (0 < local_3c->cols)) {
          x_01 = 0;
          x = iVar2;
          while( true ) {
            x_00 = (doc_view->box).x;
            if ((x_00 <= x) && (x < x_00 + (doc_view->box).width)) {
              draw_char_data(term,x,local_38,0x5f);
            }
            x_01 = x_01 + 1;
            if (local_3c->cols <= x_01) break;
            x = x + 1;
          }
        }
        local_38 = local_38 + 1;
      }
LAB_080fcea8:
      mem_free(p);
      return;
    }
  }
  assert_failed = 0;
  return;
}



frame_event_status save_formatted_dlg(session *ses,document_view *doc_view,int xxxx)

{
  query_file(ses,doc_view->vs->uri,ses,save_formatted,(anon_subr_void_void_ptr *)0x0,1);
  return FRAME_EVENT_OK;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

document_view * current_frame(session *ses)

{
  location *plVar1;
  document_view *pdVar2;
  int iVar3;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(ses == (session *)0x0);
    if (ses == (session *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x4e5;
      elinks_internal((uchar *)"assertion ses failed!");
      plVar1 = _DAT_00000014;
      if (assert_failed != 0) goto LAB_080fd0c0;
    }
    else {
      plVar1 = (ses->history).current;
    }
    if (plVar1 == (location *)0x0) {
      return (document_view *)0x0;
    }
    iVar3 = (plVar1->vs).current_link;
    if (iVar3 == -1) {
      iVar3 = 0;
    }
    pdVar2 = (document_view *)(ses->scrn_frames).next;
    while (pdVar2 != (document_view *)&ses->scrn_frames) {
      while ((pdVar2->document == (document *)0x0 ||
             (pdVar2->document->frame_desc == (frameset_desc *)0x0))) {
        if (iVar3 == 0) {
          return pdVar2;
        }
        pdVar2 = pdVar2->next;
        iVar3 = iVar3 + -1;
        if ((document_view *)&ses->scrn_frames == pdVar2) goto LAB_080fd058;
      }
      pdVar2 = pdVar2->next;
    }
LAB_080fd058:
    pdVar2 = ses->doc_view;
    if ((pdVar2 == (document_view *)0x0) || (pdVar2->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x4f4;
      elinks_internal((uchar *)"assertion doc_view && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080fd0c0;
    }
    else {
      assert_failed = 0;
    }
    if (pdVar2->document == (document *)0x0) {
      return pdVar2;
    }
    if (pdVar2->document->frame_desc == (frameset_desc *)0x0) {
      return pdVar2;
    }
  }
  else {
LAB_080fd0c0:
    assert_failed = 0;
  }
  return (document_view *)0x0;
}



void save_formatted(void *data,uchar *file)

{
  document_view *pdVar1;
  
  if (assert_failed == 0) {
    if ((((data == (void *)0x0) || (*(int *)((int)data + 8) == 0)) || (file == (uchar *)0x0)) ||
       (*(int *)(*(int *)((int)data + 8) + 0x14) == 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x668;
      elinks_internal((uchar *)"assertion ses && ses->tab && ses->tab->term && file failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    else {
      assert_failed = 0;
    }
    pdVar1 = current_frame((session *)data);
    if (assert_failed == 0) {
      if ((pdVar1 == (document_view *)0x0) || (pdVar1->document == (document *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
        errline = 0x66b;
        elinks_internal((uchar *)"assertion doc_view && doc_view->document failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
      }
      else {
        assert_failed = 0;
      }
      create_download_file
                (*(terminal **)(*(int *)((int)data + 8) + 0x14),file,(uchar **)0x0,0,0,
                 save_formatted_finish,pdVar1->document);
      return;
    }
  }
  assert_failed = 0;
  return;
}



void save_formatted_finish(terminal *term,int h,void *data,int resume)

{
  int iVar1;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(data == (void *)0x0 || term == (terminal *)0x0);
    if (data == (void *)0x0 || term == (terminal *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x657;
      elinks_internal((uchar *)"assertion term && document failed!");
      if (assert_failed != 0) goto LAB_080fd2f8;
    }
    if (h != -1) {
      iVar1 = dump_to_file((document *)data,h);
      if (iVar1 != 0) {
        info_box(term,0,(uchar *)"Save error",ALIGN_CENTER,(uchar *)"Error writing to file");
      }
      close(h);
      return;
    }
  }
  else {
LAB_080fd2f8:
    assert_failed = 0;
  }
  return;
}



// WARNING: Type propagation algorithm not settling

frame_event_status save_as(session *ses,document_view *doc_view,int magic)

{
  object *poVar1;
  uri *puVar2;
  location *plVar3;
  
  if (assert_failed == 0) {
    assert_failed = ZEXT14(ses == (session *)0x0);
    if (ses == (session *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x641;
      elinks_internal((uchar *)"assertion ses failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return FRAME_EVENT_OK;
      }
    }
    plVar3 = (ses->history).current;
    if (plVar3 == (location *)0x0) {
      return FRAME_EVENT_OK;
    }
    if (ses->download_uri != (uri *)0x0) {
      done_uri(ses->download_uri);
      plVar3 = (ses->history).current;
    }
    puVar2 = (plVar3->vs).uri;
    poVar1 = &puVar2->object;
    poVar1->refcount = poVar1->refcount + 1;
    ses->download_uri = puVar2;
    if (assert_failed == 0) {
      if (((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) ||
         (doc_view->document->uri == (uri *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
        errline = 0x649;
        elinks_internal((uchar *)
                        "assertion doc_view && doc_view->document && doc_view->document->uri failed!"
                       );
        if (assert_failed != 0) {
          assert_failed = 0;
          return FRAME_EVENT_OK;
        }
      }
      else {
        assert_failed = 0;
      }
      set_session_referrer(ses,doc_view->document->uri);
      query_file(ses,ses->download_uri,ses,start_download,(anon_subr_void_void_ptr *)0x0,1);
      return FRAME_EVENT_OK;
    }
  }
  assert_failed = 0;
  return FRAME_EVENT_OK;
}



frame_event_status view_image(session *ses,document_view *doc_view,int xxxx)

{
  int iVar1;
  uchar *url;
  link *plVar2;
  
  if ((((doc_view != (document_view *)0x0) && (iVar1 = doc_view->vs->current_link, -1 < iVar1)) &&
      (iVar1 < doc_view->document->nlinks)) &&
     ((plVar2 = doc_view->document->links + iVar1, plVar2 != (link *)0x0 &&
      (url = plVar2->where_img, url != (uchar *)0x0)))) {
    goto_url(ses,url);
  }
  return FRAME_EVENT_OK;
}



frame_event_status download_link(session *ses,document_view *doc_view,action_id_T action_id)

{
  int iVar1;
  link *link;
  uri *puVar2;
  code *std;
  
  if ((((doc_view != (document_view *)0x0) && (iVar1 = doc_view->vs->current_link, -1 < iVar1)) &&
      (iVar1 < doc_view->document->nlinks)) &&
     (link = doc_view->document->links + iVar1, link != (link *)0x0)) {
    if (ses->download_uri != (uri *)0x0) {
      done_uri(ses->download_uri);
      ses->download_uri = (uri *)0x0;
    }
    if (action_id == 0x26) {
      if (link->where_img == (uchar *)0x0) {
        puVar2 = ses->download_uri;
        std = start_download;
      }
      else {
        std = start_download;
        puVar2 = get_uri(link->where_img,0);
        ses->download_uri = puVar2;
      }
    }
    else {
      if (action_id == 0x27) {
        std = resume_download;
      }
      else {
        if (action_id != 0x25) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
          errline = 0x627;
          elinks_internal((uchar *)"I think you forgot to take your medication, mental boy!");
          return FRAME_EVENT_OK;
        }
        std = start_download;
      }
      puVar2 = get_link_uri(ses,doc_view,link);
      ses->download_uri = puVar2;
    }
    if (puVar2 != (uri *)0x0) {
      set_session_referrer(ses,doc_view->document->uri);
      query_file(ses,ses->download_uri,ses,std,(anon_subr_void_void_ptr *)0x0,1);
    }
  }
  return FRAME_EVENT_OK;
}



frame_event_status __regparm3 horizontal_scroll(session *ses,document_view *doc_view,int steps)

{
  frame_event_status fVar1;
  int *piVar2;
  int iVar3;
  int iVar4;
  uchar *extraout_EDX;
  uchar *name;
  int iVar5;
  view_state *pvVar6;
  
  name = (uchar *)assert_failed;
  if (assert_failed == 0) {
    if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
        (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x132;
      elinks_internal((uchar *)
                      "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
      name = extraout_EDX;
      if (assert_failed != 0) goto LAB_080fd690;
    }
    else {
      assert_failed = 0;
    }
    steps = doc_view->vs->x + steps;
    piVar2 = get_opt_(config_options,name);
    if (*piVar2 == 0) {
      pvVar6 = doc_view->vs;
      iVar3 = pvVar6->x;
      iVar4 = doc_view->document->width - (doc_view->box).width;
      if (iVar4 < iVar3) {
        iVar4 = iVar3;
      }
    }
    else {
      pvVar6 = doc_view->vs;
      iVar3 = pvVar6->x;
      iVar4 = doc_view->document->width + -1;
    }
    iVar5 = 0;
    if ((-1 < steps) && (iVar5 = steps, iVar4 <= steps)) {
      iVar5 = iVar4;
    }
    fVar1 = FRAME_EVENT_OK;
    if (iVar5 != iVar3) {
      pvVar6->x = iVar5;
      iVar3 = current_link_is_visible(doc_view);
      fVar1 = FRAME_EVENT_REFRESH;
      if (iVar3 == 0) {
        find_link_page_down(doc_view);
        fVar1 = FRAME_EVENT_REFRESH;
      }
    }
  }
  else {
LAB_080fd690:
    assert_failed = 0;
    fVar1 = FRAME_EVENT_OK;
  }
  return fVar1;
}



frame_event_status __regparm3 vertical_scroll(session *ses,document_view *doc_view,int steps)

{
  int iVar1;
  int iVar2;
  int iVar3;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x10f;
    elinks_internal((uchar *)
                    "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  else {
    assert_failed = 0;
  }
  iVar1 = doc_view->vs->y;
  iVar2 = steps + iVar1;
  if (0 < steps) {
    iVar3 = doc_view->document->height - (doc_view->box).height;
    if (iVar3 <= iVar1) {
      return FRAME_EVENT_OK;
    }
    if (iVar3 < iVar2) {
      iVar2 = iVar3;
    }
  }
  iVar3 = 0;
  if (-1 < iVar2) {
    iVar3 = iVar2;
  }
  if (iVar1 == iVar3) {
    return FRAME_EVENT_OK;
  }
  doc_view->vs->y = iVar3;
  iVar2 = current_link_is_visible(doc_view);
  if (iVar2 != 0) {
    return FRAME_EVENT_REFRESH;
  }
  if (steps < 1) {
    find_link_page_up(doc_view);
    return FRAME_EVENT_REFRESH;
  }
  find_link_page_down(doc_view);
  return FRAME_EVENT_REFRESH;
}



frame_event_status __regparm3 scroll_mouse_up(session *ses,document_view *doc_view)

{
  int *piVar1;
  frame_event_status fVar2;
  
  piVar1 = get_opt_(config_options,(uchar *)doc_view);
  fVar2 = vertical_scroll(ses,doc_view,-*piVar1);
  return fVar2;
}



frame_event_status __regparm3 scroll_mouse_down(session *ses,document_view *doc_view)

{
  int *piVar1;
  frame_event_status fVar2;
  
  piVar1 = get_opt_(config_options,(uchar *)doc_view);
  fVar2 = vertical_scroll(ses,doc_view,*piVar1);
  return fVar2;
}



frame_event_status try_mark_key(session *ses,document_view *doc_view,term_event *ev)

{
  anon_enum_32_for_mark aVar1;
  uchar mark;
  
  aVar1 = (ses->kbdprefix).mark;
  mark = '\0';
  if (*(uint *)&ev->info < 0x80) {
    mark = (uchar)*(uint *)&ev->info;
  }
  if (aVar1 == KP_MARK_SET) {
    set_mark(mark,doc_view->vs);
  }
  else {
    if (aVar1 == KP_MARK_NOTHING) {
      return FRAME_EVENT_IGNORED;
    }
    if (aVar1 == KP_MARK_GOTO) {
      goto_mark(mark,doc_view->vs);
    }
  }
  (ses->kbdprefix).repeat_count = 0;
  (ses->kbdprefix).mark = KP_MARK_NOTHING;
  return FRAME_EVENT_REFRESH;
}



frame_event_status __regparm3 send_to_frame(session *ses,document_view *doc_view,term_event *ev)

{
  document *pdVar1;
  int iVar2;
  terminal *ptVar3;
  uchar *name;
  frame_event_status fVar4;
  uint uVar5;
  frame_event_status fVar6;
  uint n;
  link *link;
  action_id_T aVar7;
  int *piVar8;
  int x;
  uchar *name_00;
  uchar *name_01;
  link *plVar9;
  int l;
  uchar local_30;
  uchar d [2];
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_IGNORED;
  }
  if ((((ses == (session *)0x0) || (ses->tab == (window *)0x0)) || (ev == (term_event *)0x0)) ||
     (ses->tab->term == (terminal *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x501;
    elinks_internal((uchar *)"assertion ses && ses->tab && ses->tab->term && ev failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_IGNORED;
    }
  }
  if ((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x4ca;
    elinks_internal((uchar *)
                    "assertion doc_view && doc_view->document failed: document not formatted");
    if (assert_failed == 0) goto LAB_080fda3d;
LAB_080fdc34:
    assert_failed = 0;
  }
  else {
LAB_080fda3d:
    assert_failed = ZEXT14(ev == (term_event *)0x0 || ses == (session *)0x0);
    if (ev == (term_event *)0x0 || ses == (session *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x4cd;
      elinks_internal((uchar *)"assertion ses && ev failed!");
      if (assert_failed != 0) goto LAB_080fdc34;
    }
    if (doc_view->vs != (view_state *)0x0) {
      if (ev->ev == EVENT_KBD) {
        x = doc_view->vs->current_link;
        if (((-1 < x) && (x < doc_view->document->nlinks)) &&
           (link = doc_view->document->links + x, link != (link *)0x0)) {
          if (link->type + ~LINK_SELECT < 2) {
            aVar7 = kbd_action(KEYMAP_EDIT,ev,(int *)0x0);
            if ((ses->insert_mode == INSERT_MODE_OFF) && (aVar7 == 0xe)) {
              ses->insert_mode = INSERT_MODE_ON;
              fVar4 = FRAME_EVENT_REFRESH;
              goto LAB_080fdbe0;
            }
            if (assert_failed == 0) goto LAB_080fdb03;
          }
          else {
LAB_080fdb03:
            assert_failed = 0;
          }
          if ((link->type + ~LINK_SELECT < 2) &&
             (fVar4 = field_op(ses,doc_view,link,ev), fVar4 != FRAME_EVENT_IGNORED)) {
            if ((ses->insert_mode == INSERT_MODE_ON) && (assert_failed == 0)) {
              x = doc_view->vs->current_link;
              if ((x < 0) || (doc_view->document->nlinks <= x)) {
                plVar9 = (link *)0x0;
              }
              else {
                plVar9 = doc_view->document->links + x;
              }
              assert_failed = ZEXT14(link != plVar9);
              if (link != plVar9) {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
                errline = 0x442;
                elinks_internal((uchar *)"assertion link == get_current_link(doc_view) failed!");
              }
            }
            goto LAB_080fdbd7;
          }
        }
        fVar6 = try_mark_key(ses,doc_view,ev);
        fVar4 = fVar6;
        if (fVar6 == FRAME_EVENT_IGNORED) {
          piVar8 = get_opt_(config_options,name_00);
          x = *piVar8;
          if ((x < 2) || (fVar4 = try_document_key(ses,doc_view,ev), fVar4 == FRAME_EVENT_IGNORED))
          {
            pdVar1 = doc_view->document;
            n = *(int *)&ev->info - 0x30;
            if (n < 10) {
              if (*(int *)((int)&ev->info + 4) == 0) {
                if ((ses->kbdprefix).repeat_count == 0) {
                  l = (pdVar1->options).num_links_key;
                  if ((l == 0) ||
                     ((l == 1 && ((*(byte *)&(pdVar1->options).field_0x45 & 0x10) == 0))))
                  goto LAB_080fdefa;
                  if (n != 0) {
                    local_30 = (uchar)*(int *)&ev->info;
                    d[0] = local_30;
                    x = pdVar1->nlinks;
                    d[1] = '\0';
                    (ses->kbdprefix).repeat_count = 0;
                    if (x != 0) {
                      l = 1;
                      do {
                        l = l + 1;
                        x = x / 10;
                      } while (x != 0);
                      input_dialog(ses->tab->term,(memory_list *)0x0,(uchar *)"Go to link",
                                   (uchar *)"Enter link number",ses,(input_history *)0x0,l,d,1,
                                   pdVar1->nlinks,check_number,goto_link_number,
                                   (done_handler_T *)0x0);
                    }
                    goto LAB_080fdab6;
                  }
                  goto LAB_080fdece;
                }
LAB_080fdf86:
                draw_formatted(ses,0);
                n = n + (ses->kbdprefix).repeat_count * 10;
                (ses->kbdprefix).repeat_count = n;
                if (99999 < (int)n) {
                  (ses->kbdprefix).repeat_count = 0;
                  goto LAB_080fdab6;
                }
              }
              else {
                if ((ses->kbdprefix).repeat_count != 0) goto LAB_080fdf86;
LAB_080fdefa:
                (ses->kbdprefix).repeat_count = n;
              }
              if (n != 0) {
                highlight_links_with_prefixes_that_start_with_n(ses->tab->term,doc_view,n);
              }
              goto LAB_080fdab6;
            }
LAB_080fdece:
            fVar4 = fVar6;
            if (x == 1) {
              fVar4 = try_document_key(ses,doc_view,ev);
            }
          }
        }
      }
      else {
        if (ev->ev != EVENT_MOUSE) goto LAB_080fda6c;
        x = *(int *)&ev->info;
        n = *(uint *)((int)&ev->info + 8);
        l = *(int *)((int)&ev->info + 4);
        uVar5 = n & 7;
        if (uVar5 < 3) {
          link = get_link_at_coordinates(doc_view,x,l);
          if (link == (link *)0x0) {
            fVar4 = FRAME_EVENT_IGNORED;
            if ((*(byte *)((int)&ev->info + 8) & 7) != 0) goto LAB_080fda6e;
            piVar8 = get_opt_(config_options,name_01);
            iVar2 = *piVar8;
            if (l < iVar2) goto LAB_080fdf50;
            if ((doc_view->box).height - iVar2 <= l) goto LAB_080fdec0;
            name = (uchar *)(iVar2 * 2);
            if (x < (int)name) {
              piVar8 = get_opt_(config_options,name);
              fVar4 = horizontal_scroll(ses,doc_view,-*piVar8);
            }
            else {
              if (x < iVar2 * -2 + (doc_view->box).width) goto LAB_080fdab6;
              piVar8 = get_opt_(config_options,name);
              fVar4 = horizontal_scroll(ses,doc_view,*piVar8);
            }
          }
          else {
            doc_view->vs->current_link =
                 ((int)((int)link - (int)doc_view->document->links) >> 2) * -0x3b13b13b;
            ses->navigate_mode = NAVIGATE_LINKWISE;
            fVar4 = FRAME_EVENT_REFRESH;
            if (link->type + ~LINK_SELECT < 2) goto LAB_080fdbe0;
            refresh_view(ses,doc_view,0);
            n = *(uint *)((int)&ev->info + 8);
            uVar5 = n & 7;
            if (1 < uVar5) {
              link_menu(ses->tab->term,(void *)0x0,ses);
              fVar4 = FRAME_EVENT_OK;
              goto LAB_080fda6e;
            }
            if ((n & 0x20) == 0) {
              ptVar3 = ses->tab->term;
              (ptVar3->prev_mouse_event).x = 0;
              (ptVar3->prev_mouse_event).y = 0;
              (ptVar3->prev_mouse_event).button = 0;
              fVar4 = FRAME_EVENT_OK;
              goto LAB_080fda6e;
            }
            if (uVar5 != 0) {
              open_current_link_in_new_tab(ses,1);
              fVar4 = FRAME_EVENT_OK;
              goto LAB_080fda6e;
            }
            fVar4 = enter(ses,doc_view,0);
          }
        }
        else {
          if ((n & 0x20) != 0) {
LAB_080fdab6:
            fVar4 = FRAME_EVENT_OK;
            goto LAB_080fda6e;
          }
          if (uVar5 == 3) {
LAB_080fdf50:
            fVar4 = scroll_mouse_up(ses,doc_view);
          }
          else {
            if (uVar5 != 4) goto LAB_080fdab6;
LAB_080fdec0:
            fVar4 = scroll_mouse_down(ses,doc_view);
          }
        }
      }
LAB_080fdbd7:
      if (fVar4 == FRAME_EVENT_REFRESH) {
LAB_080fdbe0:
        refresh_view(ses,doc_view,0);
        return fVar4;
      }
      goto LAB_080fda6e;
    }
  }
LAB_080fda6c:
  fVar4 = FRAME_EVENT_IGNORED;
LAB_080fda6e:
  print_screen_status(ses);
  return fVar4;
}



frame_event_status scroll_right(session *ses,document_view *doc_view)

{
  int steps;
  int *piVar1;
  frame_event_status fVar2;
  uchar *name;
  
  steps = eat_kbd_repeat_count(ses);
  if (steps == 0) {
    piVar1 = get_opt_(config_options,name);
    steps = *piVar1;
  }
  fVar2 = horizontal_scroll(ses,doc_view,steps);
  return fVar2;
}



frame_event_status scroll_left(session *ses,document_view *doc_view)

{
  int iVar1;
  int *piVar2;
  frame_event_status fVar3;
  uchar *name;
  
  iVar1 = eat_kbd_repeat_count(ses);
  if (iVar1 == 0) {
    piVar2 = get_opt_(config_options,name);
    iVar1 = *piVar2;
  }
  fVar3 = horizontal_scroll(ses,doc_view,-iVar1);
  return fVar3;
}



frame_event_status scroll_down(session *ses,document_view *doc_view)

{
  int steps;
  int *piVar1;
  frame_event_status fVar2;
  uchar *name;
  
  steps = eat_kbd_repeat_count(ses);
  if (steps == 0) {
    piVar1 = get_opt_(config_options,name);
    steps = *piVar1;
  }
  fVar2 = vertical_scroll(ses,doc_view,steps);
  return fVar2;
}



frame_event_status scroll_up(session *ses,document_view *doc_view)

{
  int iVar1;
  int *piVar2;
  frame_event_status fVar3;
  uchar *name;
  
  iVar1 = eat_kbd_repeat_count(ses);
  if (iVar1 == 0) {
    piVar2 = get_opt_(config_options,name);
    iVar1 = *piVar2;
  }
  fVar3 = vertical_scroll(ses,doc_view,-iVar1);
  return fVar3;
}



int try_jump_to_link_number(session *ses,document_view *doc_view)

{
  int n;
  int iVar1;
  
  n = eat_kbd_repeat_count(ses);
  iVar1 = 1;
  n = n + -1;
  if (-1 < n) {
    if ((doc_view != (document_view *)0x0) && (n < doc_view->document->nlinks)) {
      jump_to_link_number(ses,doc_view,n);
      refresh_view(ses,doc_view,0);
      return 1;
    }
    iVar1 = 0;
  }
  return iVar1;
}



frame_event_status copy_current_link_to_clipboard(session *ses,document_view *doc_view,int xxx)

{
  int iVar1;
  uri *uri;
  uchar *data;
  link *link;
  
  if ((((doc_view != (document_view *)0x0) && (iVar1 = doc_view->vs->current_link, -1 < iVar1)) &&
      (iVar1 < doc_view->document->nlinks)) &&
     (link = doc_view->document->links + iVar1, link != (link *)0x0)) {
    uri = get_link_uri(ses,doc_view,link);
    if (uri != (uri *)0x0) {
      data = get_uri_string(uri,URI_ORIGINAL);
      done_uri(uri);
      if (data != (uchar *)0x0) {
        set_clipboard_text(data);
        mem_free(data);
      }
    }
  }
  return FRAME_EVENT_OK;
}



frame_event_status move_cursor(session *ses,document_view *doc_view,int x,int y)

{
  terminal *term;
  frame_event_status fVar1;
  int iVar2;
  int x_00;
  link *plVar3;
  int iVar4;
  int y_00;
  int iVar5;
  int local_40;
  int local_24;
  
  term = ses->tab->term;
  iVar2 = (doc_view->box).x;
  if (x < iVar2) {
    iVar4 = (doc_view->box).y;
    if (iVar4 <= y) {
      x_00 = doc_view->document->height - doc_view->vs->y;
      iVar5 = doc_view->document->width - doc_view->vs->x;
      local_24 = (doc_view->box).height + iVar4;
      y_00 = iVar4;
      goto joined_r0x080fe3b5;
    }
LAB_080fe33e:
    fVar1 = vertical_scroll(ses,doc_view,y - iVar4);
LAB_080fe34e:
    if (fVar1 != FRAME_EVENT_REFRESH) {
      return fVar1;
    }
    x_00 = (doc_view->box).x;
    if (x_00 <= x) {
      y_00 = (doc_view->box).y;
      x_00 = (doc_view->box).width + -1 + x_00;
      local_24 = (doc_view->box).height + y_00;
      goto LAB_080fe3d2;
    }
    y_00 = (doc_view->box).y;
    local_24 = (doc_view->box).height + y_00;
  }
  else {
    iVar4 = (doc_view->box).y;
    if (y < iVar4) goto LAB_080fe33e;
    if (x < (doc_view->box).width + iVar2) {
      local_40 = (doc_view->box).height + iVar4;
      y_00 = y;
      x_00 = x;
      if (y < local_40) goto LAB_080fe3f8;
    }
    else {
      local_40 = (doc_view->box).height + iVar4;
    }
    x_00 = doc_view->document->height - doc_view->vs->y;
    iVar5 = doc_view->document->width - doc_view->vs->x;
    y_00 = iVar4;
    local_24 = local_40;
joined_r0x080fe3b5:
    if ((local_24 <= y) && (y <= x_00)) {
      fVar1 = vertical_scroll(ses,doc_view,(y + 1) - local_24);
      goto LAB_080fe34e;
    }
    if (x < iVar2) {
      fVar1 = horizontal_scroll(ses,doc_view,x - iVar2);
      goto LAB_080fe34e;
    }
    iVar2 = iVar2 + (doc_view->box).width;
    if ((x <= iVar5) && (iVar2 <= x)) {
      fVar1 = horizontal_scroll(ses,doc_view,(x - iVar2) + 1);
      goto LAB_080fe34e;
    }
    x_00 = iVar2 + -1;
LAB_080fe3d2:
    if (x < x_00) {
      x_00 = x;
    }
  }
  if ((y_00 <= y) && (y_00 = local_24 + -1, y <= y_00)) {
    y_00 = y;
  }
LAB_080fe3f8:
  ses->navigate_mode = NAVIGATE_CURSOR_ROUTING;
  plVar3 = get_link_at_coordinates(doc_view,x_00 - (doc_view->box).x,y_00 - (doc_view->box).y);
  if (plVar3 == (link *)0x0) {
    doc_view->vs->current_link = -1;
  }
  else {
    doc_view->vs->current_link =
         ((int)((int)plVar3 - (int)doc_view->document->links) >> 2) * -0x3b13b13b;
  }
  set_cursor(term,x_00,y_00,0);
  ses->tab->x = x_00;
  ses->tab->y = y_00;
  return FRAME_EVENT_REFRESH;
}



frame_event_status __regparm3 move_cursor_rel(session *ses,document_view *view,int rx,int ry)

{
  int iVar1;
  frame_event_status fVar2;
  
  iVar1 = eat_kbd_repeat_count(ses);
  if (iVar1 < 1) {
    iVar1 = 1;
  }
  fVar2 = move_cursor(ses,view,rx * iVar1 + ses->tab->x,ry * iVar1 + ses->tab->y);
  return fVar2;
}



frame_event_status move_cursor_line_start(session *ses,document_view *doc_view)

{
  frame_event_status fVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  if (((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
     (doc_view->vs == (view_state *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x37f;
    elinks_internal((uchar *)"assertion ses && doc_view && doc_view->vs failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  else {
    assert_failed = 0;
  }
  fVar1 = move_cursor_rel(ses,doc_view,-((ses->tab->x + doc_view->vs->x) - (doc_view->box).x),0);
  return fVar1;
}



frame_event_status move_cursor_down(session *ses,document_view *view)

{
  frame_event_status fVar1;
  
  fVar1 = move_cursor_rel(ses,view,0,1);
  return fVar1;
}



frame_event_status move_cursor_up(session *ses,document_view *view)

{
  frame_event_status fVar1;
  
  fVar1 = move_cursor_rel(ses,view,0,-1);
  return fVar1;
}



frame_event_status move_cursor_right(session *ses,document_view *view)

{
  frame_event_status fVar1;
  
  fVar1 = move_cursor_rel(ses,view,1,0);
  return fVar1;
}



frame_event_status move_cursor_left(session *ses,document_view *view)

{
  frame_event_status fVar1;
  
  fVar1 = move_cursor_rel(ses,view,-1,0);
  return fVar1;
}



frame_event_status move_link_next_line(session *ses,document_view *doc_view)

{
  view_state *pvVar1;
  document *pdVar2;
  int iVar3;
  link *plVar4;
  uint uVar5;
  int iVar6;
  link *plVar7;
  int iVar8;
  point *ppVar9;
  frame_event_status fVar10;
  int iVar11;
  int iVar12;
  link *plVar13;
  link *plVar14;
  int iVar15;
  int iVar16;
  int y;
  int local_30;
  int local_24;
  int local_20 [4];
  
  if (assert_failed == 0) {
    if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
        (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x333;
      elinks_internal((uchar *)
                      "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080fe76d;
    }
    else {
      assert_failed = 0;
    }
    pvVar1 = doc_view->vs;
    pdVar2 = doc_view->document;
    if (pdVar2->lines1 == (link **)0x0) {
      iVar12 = (doc_view->box).height + pvVar1->y;
      if (iVar12 < pdVar2->height) {
        pvVar1->y = iVar12;
        return FRAME_EVENT_REFRESH;
      }
    }
    else {
      y = (ses->tab->y + pvVar1->y) - (doc_view->box).y;
      iVar6 = (ses->tab->x + pvVar1->x) - (doc_view->box).x;
      iVar12 = pvVar1->current_link;
      iVar8 = iVar6;
      iVar16 = iVar6;
      if (((-1 < iVar12) && (iVar12 < pdVar2->nlinks)) && (pdVar2->links + iVar12 != (link *)0x0)) {
        get_link_x_bounds(pdVar2->links + iVar12,y,local_20,&local_24);
        iVar8 = local_24;
        iVar16 = local_20[0];
      }
      local_20[0] = iVar16;
      local_24 = iVar8;
      iVar16 = pdVar2->height;
      iVar15 = pvVar1->y;
      iVar12 = iVar16 + -1;
      iVar3 = (doc_view->box).height;
      iVar8 = iVar15 + -1 + iVar3 * 2;
      iVar11 = y;
      if (iVar12 < y) {
        iVar11 = iVar12;
      }
      if (iVar8 <= iVar12) {
        iVar12 = iVar8;
      }
      if (iVar11 <= iVar12) {
        local_30 = iVar11 * 4;
        do {
          plVar7 = *(link **)((int)pdVar2->lines1 + local_30);
          if ((plVar7 != (link *)0x0) &&
             (plVar4 = *(link **)((int)pdVar2->lines2 + local_30), plVar7 <= plVar4)) {
            plVar13 = (link *)0x0;
            do {
              while (((plVar14 = plVar7, plVar14->points->y != iVar11 ||
                      (iVar8 = plVar14->points->x, iVar8 <= local_20[0])) ||
                     ((plVar13 != (link *)0x0 && (plVar13->points->x <= iVar8))))) {
                plVar7 = plVar14 + 1;
                plVar14 = plVar13;
                if (plVar4 < plVar7) goto LAB_080fe8e8;
              }
              plVar7 = plVar14 + 1;
              plVar13 = plVar14;
            } while (plVar14 + 1 <= plVar4);
LAB_080fe8e8:
            if (plVar14 != (link *)0x0) {
              ppVar9 = plVar14->points;
              uVar5 = pvVar1->y;
              iVar12 = ppVar9->y;
              if ((int)(iVar3 + uVar5) <= iVar12) {
                iVar8 = ~uVar5 + pdVar2->height;
                if (iVar3 < iVar8) {
                  iVar8 = iVar3;
                }
                iVar12 = iVar12 - iVar8;
                pvVar1->y = iVar8 + uVar5;
                ppVar9 = plVar14->points;
              }
              fVar10 = move_cursor(ses,doc_view,(ses->tab->x + ppVar9->x) - iVar6,
                                   (iVar12 - y) + ses->tab->y);
              iVar12 = doc_view->vs->current_link;
              if (iVar12 < 0) {
                return fVar10;
              }
              if (doc_view->document->nlinks <= iVar12) {
                return fVar10;
              }
              if (doc_view->document->links + iVar12 == plVar14) {
                ses->navigate_mode = NAVIGATE_LINKWISE;
                return fVar10;
              }
              return fVar10;
            }
          }
          iVar11 = iVar11 + 1;
          local_30 = local_30 + 4;
          local_20[0] = -1;
        } while (iVar11 <= iVar12);
        iVar15 = pvVar1->y;
        iVar16 = pdVar2->height;
      }
      if (iVar15 + iVar3 < iVar16) {
        pvVar1->y = iVar15 + iVar3;
        ses->navigate_mode = NAVIGATE_CURSOR_ROUTING;
        return FRAME_EVENT_REFRESH;
      }
    }
  }
  else {
LAB_080fe76d:
    assert_failed = 0;
  }
  return FRAME_EVENT_OK;
}



frame_event_status move_link_prev_line(session *ses,document_view *doc_view)

{
  view_state *pvVar1;
  document *pdVar2;
  link *plVar3;
  int iVar4;
  link *plVar5;
  int iVar6;
  point *ppVar7;
  frame_event_status fVar8;
  int y;
  int iVar9;
  int iVar10;
  link *plVar11;
  link *plVar12;
  int local_30;
  int local_24;
  int local_20 [4];
  
  if (assert_failed == 0) {
    if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
        (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x2e3;
      elinks_internal((uchar *)
                      "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080fea6d;
    }
    else {
      assert_failed = 0;
    }
    pvVar1 = doc_view->vs;
    pdVar2 = doc_view->document;
    if (pdVar2->lines1 == (link **)0x0) {
      if (pvVar1->y != 0) {
        iVar6 = pvVar1->y - (doc_view->box).height;
        pvVar1->y = iVar6;
        if (iVar6 < 0) {
          pvVar1->y = 0;
          return FRAME_EVENT_REFRESH;
        }
        return FRAME_EVENT_REFRESH;
      }
    }
    else {
      y = (ses->tab->y + pvVar1->y) - (doc_view->box).y;
      iVar4 = (ses->tab->x + pvVar1->x) - (doc_view->box).x;
      iVar6 = pvVar1->current_link;
      iVar10 = iVar4;
      iVar9 = iVar4;
      if (((-1 < iVar6) && (iVar6 < pdVar2->nlinks)) && (pdVar2->links + iVar6 != (link *)0x0)) {
        get_link_x_bounds(pdVar2->links + iVar6,y,local_20,&local_24);
        iVar10 = local_24;
        iVar9 = local_20[0];
      }
      local_20[0] = iVar9;
      local_24 = iVar10;
      iVar6 = pvVar1->y;
      iVar10 = pdVar2->height + -1;
      if (y <= iVar10) {
        iVar10 = y;
      }
      iVar9 = iVar6 - (doc_view->box).height;
      if (iVar9 < 0) {
        iVar9 = 0;
      }
      if (iVar9 <= iVar10) {
        local_30 = iVar10 * 4;
        do {
          plVar5 = *(link **)((int)pdVar2->lines1 + local_30);
          if ((plVar5 != (link *)0x0) &&
             (plVar3 = *(link **)((int)pdVar2->lines2 + local_30), plVar5 <= plVar3)) {
            plVar11 = (link *)0x0;
            do {
              while (((plVar12 = plVar5, plVar12->points->y != iVar10 ||
                      (iVar6 = plVar12->points->x, local_20[0] <= iVar6)) ||
                     ((plVar11 != (link *)0x0 && (iVar6 <= plVar11->points->x))))) {
                plVar5 = plVar12 + 1;
                plVar12 = plVar11;
                if (plVar3 < plVar5) goto LAB_080febe8;
              }
              plVar5 = plVar12 + 1;
              plVar11 = plVar12;
            } while (plVar12 + 1 <= plVar3);
LAB_080febe8:
            if (plVar12 != (link *)0x0) {
              ppVar7 = plVar12->points;
              iVar6 = ppVar7->y;
              iVar10 = pvVar1->y;
              if (iVar6 < iVar10) {
                iVar9 = (doc_view->box).height;
                if (iVar10 < iVar9) {
                  iVar9 = iVar10;
                }
                iVar6 = iVar6 + iVar9;
                pvVar1->y = iVar10 - iVar9;
                ppVar7 = plVar12->points;
              }
              fVar8 = move_cursor(ses,doc_view,(ses->tab->x + ppVar7->x) - iVar4,
                                  (iVar6 - y) + ses->tab->y);
              iVar6 = doc_view->vs->current_link;
              if (iVar6 < 0) {
                return fVar8;
              }
              if (doc_view->document->nlinks <= iVar6) {
                return fVar8;
              }
              if (doc_view->document->links + iVar6 == plVar12) {
                ses->navigate_mode = NAVIGATE_LINKWISE;
                return fVar8;
              }
              return fVar8;
            }
          }
          iVar10 = iVar10 + -1;
          local_30 = local_30 + -4;
          local_20[0] = 0x7fffffff;
        } while (iVar9 <= iVar10);
        iVar6 = pvVar1->y;
      }
      if (iVar6 != 0) {
        iVar6 = iVar6 - (doc_view->box).height;
        iVar10 = 0;
        if (-1 < iVar6) {
          iVar10 = iVar6;
        }
        pvVar1->y = iVar10;
        ses->navigate_mode = NAVIGATE_CURSOR_ROUTING;
        return FRAME_EVENT_REFRESH;
      }
    }
  }
  else {
LAB_080fea6d:
    assert_failed = 0;
  }
  return FRAME_EVENT_OK;
}



frame_event_status move_link_down_line(session *ses,document_view *doc_view)

{
  view_state *pvVar1;
  document *pdVar2;
  int iVar3;
  int iVar4;
  link *plVar5;
  int iVar6;
  int iVar7;
  frame_event_status fVar8;
  int iVar9;
  link *plVar10;
  int iVar11;
  int iVar12;
  window *pwVar13;
  link **local_40;
  int local_38;
  int local_30;
  
  if (assert_failed == 0) {
    if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
        (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x2a4;
      elinks_internal((uchar *)
                      "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080fed70;
    }
    else {
      assert_failed = 0;
    }
    pvVar1 = doc_view->vs;
    pdVar2 = doc_view->document;
    if (pdVar2->lines1 == (link **)0x0) {
      iVar9 = (doc_view->box).height + pvVar1->y;
      if (iVar9 < pdVar2->height) {
        pvVar1->y = iVar9;
        return FRAME_EVENT_REFRESH;
      }
    }
    else {
      iVar3 = pvVar1->y;
      iVar4 = (doc_view->box).height;
      iVar9 = iVar3 + -1 + iVar4 * 2;
      iVar11 = pdVar2->height + -1;
      if (iVar11 < iVar9) {
        iVar9 = iVar11;
      }
      pwVar13 = ses->tab;
      local_38 = pwVar13->y;
      iVar12 = (local_38 + iVar3) - (doc_view->box).y;
      iVar7 = iVar12 + 1;
      if (iVar7 <= iVar9) {
        local_30 = iVar7 * 4;
        local_40 = pdVar2->lines1 + iVar7;
        do {
          plVar5 = *local_40;
          if ((plVar5 != (link *)0x0) &&
             (plVar10 = *(link **)((int)pdVar2->lines2 + local_30), plVar5 <= plVar10)) {
            iVar6 = plVar5->points->y;
            while( true ) {
              if (iVar6 == iVar7) {
                if (iVar4 + iVar3 <= iVar6) {
                  iVar9 = iVar11 - iVar3;
                  if (iVar4 < iVar11 - iVar3) {
                    iVar9 = iVar4;
                  }
                  iVar7 = iVar6 - iVar9;
                  pvVar1->y = iVar9 + iVar3;
                  pwVar13 = ses->tab;
                  local_38 = pwVar13->y;
                }
                fVar8 = move_cursor(ses,doc_view,pwVar13->x,(iVar7 + local_38) - iVar12);
                iVar9 = doc_view->vs->current_link;
                if ((iVar9 < 0) || (doc_view->document->nlinks <= iVar9)) {
                  plVar10 = (link *)0x0;
                }
                else {
                  plVar10 = doc_view->document->links + iVar9;
                }
                if (plVar10 == plVar5) {
                  ses->navigate_mode = NAVIGATE_LINKWISE;
                  return fVar8;
                }
                return fVar8;
              }
              if (plVar10 < plVar5 + 1) break;
              iVar6 = (plVar5[1].points)->y;
              plVar5 = plVar5 + 1;
            }
          }
          iVar7 = iVar7 + 1;
          local_40 = local_40 + 1;
          local_30 = local_30 + 4;
        } while (iVar7 <= iVar9);
      }
      if (iVar4 + iVar3 < pdVar2->height) {
        pvVar1->y = iVar4 + iVar3;
        ses->navigate_mode = NAVIGATE_CURSOR_ROUTING;
        return FRAME_EVENT_REFRESH;
      }
    }
  }
  else {
LAB_080fed70:
    assert_failed = 0;
  }
  return FRAME_EVENT_OK;
}



frame_event_status move_link_up_line(session *ses,document_view *doc_view)

{
  view_state *pvVar1;
  document *pdVar2;
  int iVar3;
  link *plVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  frame_event_status fVar8;
  int iVar9;
  link *plVar10;
  int iVar11;
  int iVar12;
  link **local_40;
  int local_3c;
  int local_34;
  window *local_30;
  
  if (assert_failed == 0) {
    if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
        (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x263;
      elinks_internal((uchar *)
                      "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080fefd0;
    }
    else {
      assert_failed = 0;
    }
    pvVar1 = doc_view->vs;
    pdVar2 = doc_view->document;
    if (pdVar2->lines1 == (link **)0x0) {
      if (pvVar1->y != 0) {
        iVar11 = pvVar1->y - (doc_view->box).height;
        pvVar1->y = iVar11;
        if (iVar11 < 0) {
          pvVar1->y = 0;
          return FRAME_EVENT_REFRESH;
        }
        return FRAME_EVENT_REFRESH;
      }
    }
    else {
      iVar11 = pvVar1->y;
      iVar3 = (doc_view->box).height;
      iVar6 = iVar11 - iVar3;
      iVar12 = 0;
      if (-1 < iVar6) {
        iVar12 = iVar6;
      }
      local_30 = ses->tab;
      local_3c = local_30->y;
      iVar9 = (local_3c + iVar11) - (doc_view->box).y;
      iVar7 = pdVar2->height + -1;
      if (iVar9 <= iVar7) {
        iVar7 = iVar9;
      }
      iVar7 = iVar7 + -1;
      if (iVar12 <= iVar7) {
        local_34 = iVar7 * 4;
        local_40 = pdVar2->lines1 + iVar7;
        do {
          plVar4 = *local_40;
          if ((plVar4 != (link *)0x0) &&
             (plVar10 = *(link **)((int)pdVar2->lines2 + local_34), plVar4 <= plVar10)) {
            iVar5 = plVar4->points->y;
            while( true ) {
              if (iVar5 == iVar7) {
                if (iVar5 < iVar11) {
                  iVar7 = iVar11;
                  if (iVar3 <= iVar11) {
                    iVar7 = iVar3;
                  }
                  pvVar1->y = iVar11 - iVar7;
                  iVar7 = iVar5 + iVar7;
                  local_30 = ses->tab;
                  local_3c = local_30->y;
                }
                fVar8 = move_cursor(ses,doc_view,local_30->x,(iVar7 + local_3c) - iVar9);
                iVar11 = doc_view->vs->current_link;
                if ((iVar11 < 0) || (doc_view->document->nlinks <= iVar11)) {
                  plVar10 = (link *)0x0;
                }
                else {
                  plVar10 = doc_view->document->links + iVar11;
                }
                if (plVar10 == plVar4) {
                  ses->navigate_mode = NAVIGATE_LINKWISE;
                  return fVar8;
                }
                return fVar8;
              }
              if (plVar10 < plVar4 + 1) break;
              iVar5 = (plVar4[1].points)->y;
              plVar4 = plVar4 + 1;
            }
          }
          iVar7 = iVar7 + -1;
          local_40 = local_40 + -1;
          local_34 = local_34 + -4;
        } while (iVar12 <= iVar7);
      }
      if (iVar11 != 0) {
        iVar11 = 0;
        if (-1 < iVar6) {
          iVar11 = iVar6;
        }
        pvVar1->y = iVar11;
        ses->navigate_mode = NAVIGATE_CURSOR_ROUTING;
        return FRAME_EVENT_REFRESH;
      }
    }
  }
  else {
LAB_080fefd0:
    assert_failed = 0;
  }
  return FRAME_EVENT_OK;
}



frame_event_status move_document_end(session *ses,document_view *doc_view)

{
  int iVar1;
  int iVar2;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x1b0;
    elinks_internal((uchar *)
                    "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  else {
    assert_failed = 0;
  }
  iVar1 = doc_view->document->height - (doc_view->box).height;
  doc_view->vs->x = 0;
  iVar2 = 0;
  if (-1 < iVar1) {
    iVar2 = iVar1;
  }
  if (doc_view->vs->y < iVar2) {
    doc_view->vs->y = iVar2;
  }
  if (ses->navigate_mode == NAVIGATE_CURSOR_ROUTING) {
    move_cursor(ses,doc_view,ses->tab->x,doc_view->document->height - doc_view->vs->y);
    return FRAME_EVENT_REFRESH;
  }
  find_link_page_up(doc_view);
  return FRAME_EVENT_REFRESH;
}



frame_event_status move_document_start(session *ses,document_view *doc_view)

{
  view_state *pvVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  if (((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
     (doc_view->vs == (view_state *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x19c;
    elinks_internal((uchar *)"assertion ses && doc_view && doc_view->vs failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  else {
    assert_failed = 0;
  }
  pvVar1 = doc_view->vs;
  pvVar1->x = 0;
  pvVar1->y = 0;
  if (ses->navigate_mode != NAVIGATE_CURSOR_ROUTING) {
    find_link_page_down(doc_view);
    return FRAME_EVENT_REFRESH;
  }
  move_cursor(ses,doc_view,(doc_view->box).x,(doc_view->box).y);
  return FRAME_EVENT_REFRESH;
}



void toggle_wrap_text(session *ses,document_view *doc_view,int xxxx)

{
  view_state *pvVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (ses->tab == (window *)0x0)) || (ses->tab->term == (terminal *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x1e5;
    elinks_internal((uchar *)"assertion ses && doc_view && ses->tab && ses->tab->term failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  pvVar1 = doc_view->vs;
  if (pvVar1 != (view_state *)0x0) {
    *(byte *)&pvVar1->field_0x2c =
         *(byte *)&pvVar1->field_0x2c & 0xfe | (*(byte *)&pvVar1->field_0x2c ^ 1) & 1;
    draw_formatted(ses,1);
    return;
  }
  nowhere_box(ses->tab->term,(uchar *)0x0);
  return;
}



void toggle_plain_html(session *ses,document_view *doc_view,int xxxx)

{
  view_state *pvVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (ses->tab == (window *)0x0)) || (ses->tab->term == (terminal *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x1d6;
    elinks_internal((uchar *)"assertion ses && doc_view && ses->tab && ses->tab->term failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  pvVar1 = doc_view->vs;
  if (pvVar1 != (view_state *)0x0) {
    pvVar1->plain = (uint)(pvVar1->plain == 0);
    draw_formatted(ses,1);
    return;
  }
  nowhere_box(ses->tab->term,(uchar *)0x0);
  return;
}



frame_event_status set_frame(session *ses,document_view *doc_view,int xxxx)

{
  if (assert_failed == 0) {
    if ((((ses == (session *)0x0) || (doc_view == (document_view *)0x0)) ||
        (ses->doc_view == (document_view *)0x0)) || (doc_view->vs == (view_state *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x1c8;
      elinks_internal((uchar *)"assertion ses && ses->doc_view && doc_view && doc_view->vs failed!")
      ;
      if (assert_failed != 0) goto LAB_080ff630;
    }
    else {
      assert_failed = 0;
    }
    if (ses->doc_view != doc_view) {
      goto_uri(ses,doc_view->vs->uri);
      ses->navigate_mode = NAVIGATE_LINKWISE;
    }
  }
  else {
LAB_080ff630:
    assert_failed = 0;
  }
  return FRAME_EVENT_OK;
}



void __regparm3 move_down(session *ses,document_view *doc_view,int type)

{
  int iVar1;
  bool bVar2;
  
  if (assert_failed == 0) {
    if (((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
       (doc_view->vs == (view_state *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x5c;
      elinks_internal((uchar *)"assertion ses && doc_view && doc_view->vs failed!");
      if (assert_failed != 0) goto LAB_080ff6c8;
    }
    bVar2 = ses->navigate_mode != NAVIGATE_LINKWISE;
    assert_failed = ZEXT14(bVar2);
    if (bVar2) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x5f;
      elinks_internal((uchar *)"assertion ses->navigate_mode == NAVIGATE_LINKWISE failed!");
    }
    iVar1 = (doc_view->box).height + doc_view->vs->y;
    if (iVar1 < doc_view->document->height) {
      doc_view->vs->y = iVar1;
    }
    iVar1 = current_link_is_visible(doc_view);
    if (iVar1 == 0) {
      if (type != 0) {
        find_link_down(doc_view);
        return;
      }
      find_link_page_down(doc_view);
      return;
    }
  }
  else {
LAB_080ff6c8:
    assert_failed = 0;
  }
  return;
}



frame_event_status move_page_down(session *ses,document_view *doc_view)

{
  int iVar1;
  int iVar2;
  
  iVar1 = doc_view->vs->y;
  iVar2 = eat_kbd_repeat_count(ses);
  ses->navigate_mode = NAVIGATE_LINKWISE;
  do {
    iVar2 = iVar2 + -1;
    move_down(ses,doc_view,0);
  } while (0 < iVar2);
  return (uint)(doc_view->vs->y == iVar1) + FRAME_EVENT_REFRESH;
}



void __regparm3 move_up(session *ses,document_view *doc_view,int type)

{
  int iVar1;
  bool bVar2;
  
  if (assert_failed == 0) {
    if (((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
       (doc_view->vs == (view_state *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x82;
      elinks_internal((uchar *)"assertion ses && doc_view && doc_view->vs failed!");
      if (assert_failed != 0) goto LAB_080ff838;
    }
    bVar2 = ses->navigate_mode != NAVIGATE_LINKWISE;
    assert_failed = ZEXT14(bVar2);
    if (bVar2) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x85;
      elinks_internal((uchar *)"assertion ses->navigate_mode == NAVIGATE_LINKWISE failed!");
    }
    iVar1 = doc_view->vs->y;
    if (iVar1 != 0) {
      doc_view->vs->y = iVar1 - (doc_view->box).height;
      if (doc_view->vs->y < 0) {
        doc_view->vs->y = 0;
      }
      iVar1 = current_link_is_visible(doc_view);
      if (iVar1 == 0) {
        if (type != 0) {
          find_link_up(doc_view);
          return;
        }
        find_link_page_up(doc_view);
        return;
      }
    }
  }
  else {
LAB_080ff838:
    assert_failed = 0;
  }
  return;
}



frame_event_status move_link_dir(session *ses,document_view *doc_view,int dir_x,int dir_y)

{
  int iVar1;
  int iVar2;
  int iVar3;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0xee;
    elinks_internal((uchar *)
                    "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  else {
    assert_failed = 0;
  }
  ses->navigate_mode = NAVIGATE_LINKWISE;
  iVar2 = eat_kbd_repeat_count(ses);
  do {
    iVar1 = doc_view->vs->current_link;
    iVar3 = next_link_in_dir(doc_view,dir_x,dir_y);
    if (iVar3 == 0) {
      if (dir_y < 1) {
        if (dir_y == 0) goto LAB_080ff9e0;
        move_up(ses,doc_view,1);
      }
      else {
        move_down(ses,doc_view,1);
      }
      if (doc_view->vs->current_link != iVar1) {
        set_textarea(doc_view,-dir_y);
      }
    }
LAB_080ff9e0:
    iVar2 = iVar2 + -1;
    if (iVar2 < 1) {
      return FRAME_EVENT_REFRESH;
    }
  } while( true );
}



frame_event_status move_page_up(session *ses,document_view *doc_view)

{
  int iVar1;
  int iVar2;
  
  iVar1 = doc_view->vs->y;
  iVar2 = eat_kbd_repeat_count(ses);
  ses->navigate_mode = NAVIGATE_LINKWISE;
  do {
    iVar2 = iVar2 + -1;
    move_up(ses,doc_view,0);
  } while (0 < iVar2);
  return (uint)(doc_view->vs->y == iVar1) + FRAME_EVENT_REFRESH;
}



frame_event_status
move_link(session *ses,document_view *doc_view,int direction,int wraparound_bound,
         int wraparound_link)

{
  int iVar1;
  int *piVar2;
  int iVar3;
  int iVar4;
  uchar *extraout_EDX;
  uchar *name;
  int local_20;
  
  name = (uchar *)assert_failed;
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0xac;
    elinks_internal((uchar *)
                    "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
    name = extraout_EDX;
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  else {
    assert_failed = 0;
  }
  ses->navigate_mode = NAVIGATE_LINKWISE;
  if (doc_view->document->nlinks < 2) {
    local_20 = 0;
    wraparound_bound = -1;
  }
  else {
    piVar2 = get_opt_(config_options,name);
    local_20 = *piVar2;
  }
  iVar3 = eat_kbd_repeat_count(ses);
  do {
    while( true ) {
      iVar1 = doc_view->vs->current_link;
      if (iVar1 == wraparound_bound) break;
      iVar4 = next_link_in_view_y(doc_view,direction + iVar1,direction);
      if (iVar4 == 0) {
        doc_view->vs->current_link = iVar1;
        if (direction < 1) goto LAB_080ffbf0;
LAB_080ffb8d:
        move_down(ses,doc_view,1);
LAB_080ffb9c:
        if ((iVar1 != wraparound_bound) && (doc_view->vs->current_link != iVar1)) {
          set_textarea(doc_view,-direction);
        }
      }
      iVar3 = iVar3 + -1;
      if (iVar3 < 1) {
        return FRAME_EVENT_REFRESH;
      }
    }
    if (local_20 == 0) {
      doc_view->vs->current_link = iVar1;
      if (0 < direction) goto LAB_080ffb8d;
LAB_080ffbf0:
      move_up(ses,doc_view,1);
      goto LAB_080ffb9c;
    }
    iVar3 = iVar3 + -1;
    jump_to_link_number(ses,doc_view,wraparound_link);
    if (iVar3 < 1) {
      return FRAME_EVENT_REFRESH;
    }
  } while( true );
}



void detach_formatted(document_view *doc_view)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(doc_view == (document_view *)0x0);
  if (doc_view == (document_view *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x42;
    elinks_internal((uchar *)"assertion doc_view failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (doc_view->document != (document *)0x0) {
    release_document(doc_view->document);
    doc_view->document = (document *)0x0;
  }
  if (doc_view->vs != (view_state *)0x0) {
    doc_view->vs->doc_view = (document_view *)0x0;
    doc_view->vs = (view_state *)0x0;
  }
  if (doc_view->name != (uchar *)0x0) {
    mem_free(doc_view->name);
  }
  doc_view->name = (uchar *)0x0;
  return;
}



void send_event(session *ses,term_event *ev)

{
  uint *puVar1;
  byte bVar2;
  terminal *term;
  void *pvVar3;
  int *piVar4;
  document_view *doc_view;
  int tab;
  window *pwVar5;
  int iVar6;
  frame_event_status fVar7;
  document_view *doc_view_00;
  window *pwVar8;
  uint uVar9;
  uint uVar10;
  window *name;
  uchar *name_00;
  term_event_mouse *ptVar11;
  byte bVar12;
  char *local_78;
  int local_48;
  int local_44;
  term_event evv;
  int local_20 [4];
  
  bVar12 = 0;
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = ZEXT14(ev == (term_event *)0x0 || ses == (session *)0x0);
  if (ev == (term_event *)0x0 || ses == (session *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x5f8;
    elinks_internal((uchar *)"assertion ses && ev failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (ev->ev == EVENT_KBD) {
    doc_view = current_frame(ses);
    if ((doc_view != (document_view *)0x0) &&
       (fVar7 = send_to_frame(ses,doc_view,ev), fVar7 != FRAME_EVENT_IGNORED)) {
      return;
    }
    name_00 = (uchar *)kbd_action(KEYMAP_MAIN,ev,local_20);
    if ((name_00 == (uchar *)0x4c) && (*(int *)&ev->info == -0x200)) {
      name_00 = (uchar *)0x4d;
    }
    while( true ) {
      fVar7 = do_action(ses,(main_action)name_00,0);
      if (fVar7 != FRAME_EVENT_IGNORED) {
        if (fVar7 < FRAME_EVENT_SESSION_DESTROYED) goto LAB_080ffd46;
        if (fVar7 == FRAME_EVENT_SESSION_DESTROYED) {
          return;
        }
      }
      if (name_00 == (uchar *)0x1) {
        trigger_event(local_20[0],ses);
        return;
      }
      if (*(int *)&ev->info != -0x200) break;
      name_00 = (uchar *)0x4d;
    }
    uVar10 = *(uint *)((int)&ev->info + 4);
    if (uVar10 != 4) {
      if ((uVar10 & 2) != 0) {
        return;
      }
      if (doc_view != (document_view *)0x0) {
        local_78 = "document.browse.search.typeahead";
        piVar4 = get_opt_(config_options,name_00);
        tab = *piVar4;
        if (tab == 1) {
          name_00 = (uchar *)0x5e;
        }
        else {
          if (tab == 2) {
            name_00 = (uchar *)0x5f;
          }
          else {
            if (tab == 0) {
              return;
            }
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
            errline = 0x59f;
            elinks_internal((uchar *)"invalid value for document.browse.search.typeahead",local_78);
          }
        }
        search_typeahead(ses,doc_view,(action_id_T)name_00);
        term_send_event(ses->tab->term,ev);
        return;
      }
      return;
    }
    *(undefined4 *)((int)&ev->info + 4) = 0;
    activate_bfu_technology(ses,-1);
    pwVar5 = (window *)(ses->tab->term->windows).next;
    (*pwVar5->handler)(pwVar5,ev);
    name = ses->tab;
    pwVar8 = (window *)(name->term->windows).next;
    if (pwVar5 == pwVar8) {
      deselect_mainmenu(pwVar8->term,(menu *)pwVar8->data);
      print_screen_status(ses);
      name = ses->tab;
      pwVar8 = (window *)(name->term->windows).next;
    }
    if (name != pwVar8) {
      return;
    }
    puVar1 = (uint *)((int)&ev->info + 4);
    *puVar1 = *puVar1 | 4;
    if (((doc_view != (document_view *)0x0) &&
        (piVar4 = get_opt_(config_options,(uchar *)name), *piVar4 < 1)) &&
       (fVar7 = try_document_key(ses,doc_view,ev), fVar7 == FRAME_EVENT_REFRESH)) {
      refresh_view(ses,doc_view,0);
      return;
    }
LAB_080ffd46:
    if (ses != (session *)0x0) {
      (ses->kbdprefix).repeat_count = 0;
    }
    return;
  }
  if (ev->ev != EVENT_MOUSE) goto LAB_080ffd46;
  doc_view = current_frame(ses);
  term = ses->tab->term;
  uVar10 = *(uint *)((int)&ev->info + 4);
  if (((uVar10 == 0) && (uVar9 = *(uint *)((int)&ev->info + 8), (uVar9 & 0x20) == 0)) &&
     ((uVar9 & 7) < 3)) {
    activate_bfu_technology(ses,-1);
    pvVar3 = (term->windows).next;
    (**(code **)((int)pvVar3 + 0xc))(pvVar3,ev);
    goto LAB_080ffd46;
  }
  bVar2 = *(byte *)&ses->status;
  if ((bVar2 & 1) != 0) {
    if ((*(byte *)&(ses->status).field_0x34 & 4) == 0) {
      uVar9 = (term->height + -1) - ((uint)(bVar2 >> 1) & 1);
    }
    else {
      uVar9 = (uint)(bVar2 >> 2) & 1;
    }
    if (uVar10 == uVar9) {
      tab = get_tab_number_by_xpos(term,*(int *)&ev->info);
      pwVar5 = get_tab_by_number(term,term->current_tab);
      uVar10 = *(uint *)((int)&ev->info + 8);
      if ((uVar10 & 0x20) == 0) {
        if ((uVar10 & 7) == 3) {
          switch_current_tab(ses,-1);
        }
        else {
          if ((uVar10 & 7) == 4) {
            switch_current_tab(ses,1);
          }
          else {
            if (tab != -1) {
              switch_to_tab(term,tab,-1);
              uVar10 = *(uint *)((int)&ev->info + 8) & 7;
              if (uVar10 == 1) {
                tab = 3;
                ptVar11 = &term->prev_mouse_event;
                while (tab != 0) {
                  tab = tab + -1;
                  ptVar11->x = 0;
                  ptVar11 = (term_event_mouse *)((int)ptVar11 + (uint)bVar12 * -8 + 4);
                }
              }
              else {
                if (uVar10 == 2) {
                  tab_menu((session *)pwVar5->data,*(int *)&ev->info,*(int *)((int)&ev->info + 4),1)
                  ;
                }
              }
            }
          }
        }
      }
      else {
        if ((((uVar10 & 7) == 1) && (tab == term->current_tab)) &&
           (*(int *)((int)&ev->info + 4) == (term->prev_mouse_event).y)) {
          if (ses == (session *)pwVar5->data) {
            ses = (session *)0x0;
          }
          close_tab(term,(session *)pwVar5->data);
        }
      }
      goto LAB_080ffd46;
    }
  }
  if (assert_failed == 0) {
    assert_failed = 0;
    doc_view_00 = doc_view;
    if (doc_view == (document_view *)0x0) goto LAB_08100117;
    do {
      if ((doc_view_00 == (document_view *)0x0) || (doc_view_00->document == (document *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
        errline = 0x51c;
        elinks_internal((uchar *)"assertion doc_view && doc_view->document failed!");
        if (assert_failed != 0) break;
      }
      if (((doc_view_00->document->options).box.x == (doc_view_00->box).x) &&
         ((doc_view_00->document->options).box.y == (doc_view_00->box).y)) {
        assert_failed = 0;
      }
      else {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
        errline = 0x521;
        elinks_internal((uchar *)
                        "assertion doc_view->document->options.box.x == doc_view->box.x && doc_view->document->options.box.y == doc_view->box.y failed: Jonas\' 1.565 -> 1.566 patch sucks"
                       );
        if (assert_failed != 0) break;
      }
      local_48 = *(int *)((int)&ev->info + 4);
      tab = *(int *)&ev->info;
      iVar6 = (doc_view_00->box).x;
      if ((((iVar6 <= tab) && (local_44 = (doc_view_00->box).y, local_44 <= local_48)) &&
          (tab < (doc_view_00->box).width + iVar6)) &&
         (local_48 < local_44 + (doc_view_00->box).height)) {
        if (doc_view != doc_view_00) {
          draw_formatted(ses,0);
          local_48 = *(int *)((int)&ev->info + 4);
          local_44 = (doc_view_00->box).y;
          tab = *(int *)&ev->info;
          iVar6 = (doc_view_00->box).x;
        }
        evv.info._0_4_ = tab - iVar6;
        evv.info._4_4_ = local_48 - local_44;
        evv.ev = EVENT_MOUSE;
        evv.info._8_4_ = *(undefined4 *)((int)&ev->info + 8);
        fVar7 = send_to_frame(ses,doc_view_00,&evv);
        if (fVar7 == FRAME_EVENT_IGNORED) goto LAB_08100117;
        goto LAB_08100126;
      }
      next_frame(ses,1);
      doc_view_00 = current_frame(ses);
      if (doc_view == doc_view_00) goto LAB_08100117;
    } while (assert_failed == 0);
  }
  assert_failed = 0;
LAB_08100117:
  if ((*(uint *)((int)&ev->info + 8) & 7) == 2) {
    tab_menu(ses,*(int *)&ev->info,*(int *)((int)&ev->info + 4),0);
    return;
  }
LAB_08100126:
  if ((*(byte *)&(ses->status).field_0x8 & 1) == 0) {
    return;
  }
  if (*(int *)((int)&ev->info + 4) == term->height + -1) {
    if (term->width + -9 <= *(int *)&ev->info) {
      menu_leds_info(term,(void *)0x0,(void *)0x0);
      return;
    }
    return;
  }
  return;
}



void next_frame(session *ses,int p)

{
  document *pdVar1;
  location *plVar2;
  int iVar3;
  list_head_elinks *plVar4;
  int iVar5;
  list_head_elinks *plVar6;
  
  if (((ses->history).current != (location *)0x0) &&
     ((ses->doc_view == (document_view *)0x0 ||
      ((pdVar1 = ses->doc_view->document, pdVar1 != (document *)0x0 &&
       (pdVar1->frame_desc != (frameset_desc *)0x0)))))) {
    plVar4 = (list_head_elinks *)(ses->scrn_frames).next;
    ses->navigate_mode = NAVIGATE_LINKWISE;
    plVar2 = (ses->history).current;
    plVar6 = &ses->scrn_frames;
    if (plVar6 == plVar4) {
      p = p + (plVar2->vs).current_link;
      iVar5 = 1;
      (plVar2->vs).current_link = p;
    }
    else {
      iVar5 = 0;
      do {
        while ((plVar4[2].prev == (void *)0x0 || (*(int *)((int)plVar4[2].prev + 200) == 0))) {
          plVar4 = (list_head_elinks *)plVar4->next;
          iVar5 = iVar5 + 1;
          if (plVar6 == plVar4) goto LAB_08100470;
        }
        plVar4 = (list_head_elinks *)plVar4->next;
      } while (plVar6 != plVar4);
LAB_08100470:
      p = p + (plVar2->vs).current_link;
      if (iVar5 == 0) {
        iVar5 = 1;
      }
      (plVar2->vs).current_link = p;
    }
    if (p < 0) {
      iVar3 = p + iVar5;
      do {
        p = iVar3;
        iVar3 = p + iVar5;
      } while ((p + iVar5) - iVar5 < 0);
      (plVar2->vs).current_link = p;
    }
    (plVar2->vs).current_link = p % iVar5;
  }
  return;
}



void check_vs(document_view *doc_view)

{
  view_state *pvVar1;
  link *plVar2;
  int iVar3;
  int iVar4;
  
  pvVar1 = doc_view->vs;
  iVar4 = doc_view->document->nlinks + -1;
  iVar3 = pvVar1->current_link;
  if (iVar4 < pvVar1->current_link) {
    pvVar1->current_link = iVar4;
    iVar3 = iVar4;
  }
  if (iVar3 != -1) {
    iVar3 = current_link_is_visible(doc_view);
    if (iVar3 == 0) {
      plVar2 = doc_view->document->links;
      set_pos_x(doc_view,plVar2 + pvVar1->current_link);
      set_pos_y(doc_view,plVar2 + pvVar1->current_link);
    }
    return;
  }
  find_link_page_down(doc_view);
  return;
}



void copy_vs(view_state *dst,view_state *src)

{
  object *poVar1;
  list_head_elinks *plVar2;
  undefined4 uVar3;
  uri *puVar4;
  void *pvVar5;
  uchar *src_00;
  int iVar6;
  list_head_elinks *plVar7;
  void **ppvVar8;
  form_state *__dest;
  form_view **ppfVar9;
  form_view *pfVar10;
  int iVar11;
  int *piVar12;
  int iVar13;
  
  dst->doc_view = src->doc_view;
  dst->uri = src->uri;
  (dst->forms).next = (src->forms).next;
  (dst->forms).prev = (src->forms).prev;
  dst->form_info = src->form_info;
  dst->form_info_len = src->form_info_len;
  dst->x = src->x;
  dst->y = src->y;
  dst->current_link = src->current_link;
  dst->old_current_link = src->old_current_link;
  dst->plain = src->plain;
  uVar3 = *(undefined4 *)&src->field_0x2c;
  dst->form_info = (form_state *)0x0;
  dst->doc_view = (document_view *)0x0;
  *(undefined4 *)&dst->field_0x2c = uVar3;
  puVar4 = src->uri;
  poVar1 = &puVar4->object;
  poVar1->refcount = poVar1->refcount + 1;
  dst->uri = puVar4;
  plVar2 = &dst->forms;
  *(byte *)&dst->field_0x2c =
       *(byte *)&dst->field_0x2c & 0xfd | (*(short *)&src->uri->field_0x34 == 0) * '\x02';
  *(list_head_elinks **)&(dst->forms).prev = plVar2;
  *(list_head_elinks **)&(dst->forms).next = plVar2;
  plVar7 = (list_head_elinks *)(src->forms).next;
  while (plVar7 != &src->forms) {
    ppvVar8 = (void **)mem_calloc(1,0xc);
    if (ppvVar8 != (void **)0x0) {
      ppvVar8[2] = plVar7[1].next;
      pvVar5 = plVar2->next;
      *(list_head_elinks **)(ppvVar8 + 1) = plVar2;
      *ppvVar8 = pvVar5;
      *(void ***)&plVar2->next = ppvVar8;
      *(void ***)((int)*ppvVar8 + 4) = ppvVar8;
    }
    plVar7 = (list_head_elinks *)plVar7->next;
  }
  if (src->form_info_len != 0) {
    __dest = (form_state *)mem_alloc(src->form_info_len * 0x24);
    dst->form_info = __dest;
    if ((__dest != (form_state *)0x0) &&
       (memcpy(__dest,src->form_info,src->form_info_len * 0x24), 0 < src->form_info_len)) {
      iVar13 = 0;
      iVar11 = 0;
      do {
        piVar12 = (int *)((int)&src->form_info->form_view + iVar13);
        ppfVar9 = (form_view **)((int)&dst->form_info->form_view + iVar13);
        src_00 = (uchar *)piVar12[4];
        if (src_00 != (uchar *)0x0) {
          pfVar10 = (form_view *)stracpy(src_00);
          ppfVar9[4] = pfVar10;
        }
        iVar6 = *piVar12;
        pfVar10 = (form_view *)0x0;
        if (iVar6 != 0) {
          pfVar10 = find_form_view_in_vs(dst,*(int *)(iVar6 + 8));
        }
        iVar11 = iVar11 + 1;
        iVar13 = iVar13 + 0x24;
        *ppfVar9 = pfVar10;
      } while (src->form_info_len != iVar11 && iVar11 <= src->form_info_len);
      return;
    }
  }
  return;
}



void destroy_vs(view_state *vs,int blast_ecmascript)

{
  form_view *pfVar1;
  form_view *fv;
  form_view *pfVar2;
  int iVar3;
  
  iVar3 = vs->form_info_len;
  while (0 < iVar3) {
    done_form_state((form_state *)(&vs->form_info->form_view + iVar3 * 9 + -9));
    iVar3 = vs->form_info_len + -1;
    vs->form_info_len = iVar3;
  }
  if (vs->form_info != (form_state *)0x0) {
    mem_free(vs->form_info);
  }
  fv = (form_view *)(vs->forms).next;
  vs->form_info = (form_state *)0x0;
  pfVar2 = fv->next;
  while (pfVar1 = pfVar2, fv != (form_view *)&vs->forms) {
    pfVar1->prev = fv->prev;
    fv->prev->next = fv->next;
    done_form_view(fv);
    pfVar2 = pfVar1->next;
    fv = pfVar1;
  }
  if (vs->uri != (uri *)0x0) {
    done_uri(vs->uri);
  }
  if (vs->doc_view != (document_view *)0x0) {
    vs->doc_view->vs = (view_state *)0x0;
    vs->doc_view = (document_view *)0x0;
  }
  return;
}



void init_vs(view_state *vs,uri *uri,int plain)

{
  uri *puVar1;
  int iVar2;
  view_state *pvVar3;
  
  iVar2 = 0xc;
  pvVar3 = vs;
  while (iVar2 != 0) {
    iVar2 = iVar2 + -1;
    pvVar3->doc_view = (document_view *)0x0;
    pvVar3 = (view_state *)&pvVar3->uri;
  }
  vs->current_link = -1;
  vs->old_current_link = -1;
  vs->plain = plain;
  puVar1 = (uri *)0x0;
  if (uri != (uri *)0x0) {
    (uri->object).refcount = (uri->object).refcount + 1;
    puVar1 = uri;
  }
  vs->uri = puVar1;
  *(byte *)&vs->field_0x2c =
       *(byte *)&vs->field_0x2c & 0xfd | (*(short *)&uri->field_0x34 == 0) * '\x02';
  *(list_head_elinks **)&(vs->forms).prev = &vs->forms;
  *(list_head_elinks **)&(vs->forms).next = &vs->forms;
  return;
}



undefined8 __divdi3(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  ulonglong uVar2;
  ulonglong uVar3;
  longlong lVar4;
  int iVar5;
  byte bVar6;
  uint uVar7;
  uint uVar8;
  bool bVar9;
  byte local_1c;
  uint local_18;
  uint local_14;
  uint local_10;
  
  local_14 = param_3;
  local_10 = param_4;
  local_18 = 0;
  if ((int)param_2 < 0) {
    bVar9 = param_1 != 0;
    param_1 = -param_1;
    param_2 = -(param_2 + bVar9);
    local_18 = 0xffffffff;
  }
  if ((int)param_4 < 0) {
    local_14 = -param_3;
    local_18 = ~local_18;
    local_10 = -(param_4 + (param_3 != 0));
  }
  if (local_10 == 0) {
    if (param_2 < local_14) {
      uVar8 = 0;
      iVar5 = (int)(CONCAT44(param_2,param_1) / (ulonglong)local_14);
    }
    else {
      if (local_14 == 0) {
        local_14 = (uint)(1 / 0);
      }
      uVar8 = param_2 / local_14;
      iVar5 = (int)(((ulonglong)param_2 % (ulonglong)local_14 << 0x20 | (ulonglong)param_1) /
                   (ulonglong)local_14);
    }
    goto LAB_08100860;
  }
  if (local_10 <= param_2) {
    uVar8 = 0x1f;
    if (local_10 != 0) {
      while (local_10 >> uVar8 == 0) {
        uVar8 = uVar8 - 1;
      }
    }
    if ((uVar8 ^ 0x1f) != 0) {
      local_1c = (byte)(uVar8 ^ 0x1f);
      bVar6 = 0x20 - local_1c;
      uVar1 = (ulonglong)(local_14 >> (bVar6 & 0x1f) | local_10 << (local_1c & 0x1f));
      uVar2 = CONCAT44(param_2 >> (bVar6 & 0x1f),
                       param_2 << (local_1c & 0x1f) | param_1 >> (bVar6 & 0x1f));
      uVar3 = uVar2 / uVar1;
      iVar5 = (int)uVar3;
      uVar8 = (uint)(uVar2 % uVar1);
      lVar4 = (uVar3 & 0xffffffff) * (ulonglong)(local_14 << (local_1c & 0x1f));
      uVar7 = (uint)((ulonglong)lVar4 >> 0x20);
      if ((uVar8 < uVar7) || ((param_1 << (local_1c & 0x1f) < (uint)lVar4 && (uVar8 == uVar7)))) {
        iVar5 = iVar5 + -1;
        uVar8 = 0;
      }
      else {
        uVar8 = 0;
      }
      goto LAB_08100860;
    }
    if ((local_14 <= param_1) || (local_10 < param_2)) {
      uVar8 = 0;
      iVar5 = 1;
      goto LAB_08100860;
    }
  }
  uVar8 = 0;
  iVar5 = 0;
LAB_08100860:
  if (local_18 != 0) {
    bVar9 = iVar5 != 0;
    iVar5 = -iVar5;
    uVar8 = -(uVar8 + bVar9);
  }
  return CONCAT44(uVar8,iVar5);
}



// WARNING: Could not reconcile some variable overlaps

undefined8 __moddi3(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  bool bVar7;
  int local_30;
  byte local_2c;
  uint local_28;
  uint local_24;
  uint local_20;
  uint local_10;
  
  local_24 = param_3;
  local_20 = param_4;
  local_30 = 0;
  if ((int)param_2 < 0) {
    bVar7 = param_1 != 0;
    param_1 = -param_1;
    param_2 = -(param_2 + bVar7);
    local_30 = -1;
  }
  if ((int)param_4 < 0) {
    local_24 = -param_3;
    local_20 = -(param_4 + (param_3 != 0));
  }
  local_28 = local_24;
  if (local_20 == 0) {
    if (param_2 < local_24) {
      param_1 = (uint)(CONCAT44(param_2,param_1) % (ulonglong)local_24);
    }
    else {
      if (local_24 == 0) {
        local_28 = (uint)(1 / 0);
      }
      param_1 = (uint)(((ulonglong)param_2 % (ulonglong)local_28 << 0x20 | (ulonglong)param_1) %
                      (ulonglong)local_28);
    }
    local_10 = 0;
  }
  else {
    local_10 = param_2;
    if (local_20 <= param_2) {
      uVar3 = 0x1f;
      if (local_20 != 0) {
        while (local_20 >> uVar3 == 0) {
          uVar3 = uVar3 - 1;
        }
      }
      if ((uVar3 ^ 0x1f) == 0) {
        if ((local_24 <= param_1) || (local_20 < param_2)) {
          bVar7 = param_1 < local_24;
          param_1 = param_1 - local_24;
          local_10 = (param_2 - local_20) - (uint)bVar7;
        }
      }
      else {
        local_24._0_1_ = (byte)(uVar3 ^ 0x1f);
        local_2c = 0x20 - (byte)local_24;
        uVar3 = local_24 >> (local_2c & 0x1f) | local_20 << ((byte)local_24 & 0x1f);
        local_24 = local_24 << ((byte)local_24 & 0x1f);
        uVar1 = CONCAT44(param_2 >> (local_2c & 0x1f),
                         param_1 >> (local_2c & 0x1f) | param_2 << ((byte)local_24 & 0x1f));
        uVar5 = (uint)(uVar1 % (ulonglong)uVar3);
        param_1 = param_1 << ((byte)local_24 & 0x1f);
        lVar2 = (uVar1 / (ulonglong)uVar3 & 0xffffffff) * (ulonglong)local_24;
        uVar6 = (uint)((ulonglong)lVar2 >> 0x20);
        uVar4 = (uint)lVar2;
        if ((uVar5 < uVar6) || ((param_1 < uVar4 && (uVar5 == uVar6)))) {
          bVar7 = uVar4 < local_24;
          uVar4 = uVar4 - local_24;
          uVar6 = (uVar6 - uVar3) - (uint)bVar7;
        }
        local_10 = (uVar5 - uVar6) - (uint)(param_1 < uVar4);
        param_1 = local_10 << (local_2c & 0x1f) | param_1 - uVar4 >> ((byte)local_24 & 0x1f);
        local_10 = local_10 >> ((byte)local_24 & 0x1f);
      }
    }
  }
  if (local_30 == 0) {
    return CONCAT44(local_10,param_1);
  }
  return CONCAT44(-(local_10 + (param_1 != 0)),-param_1);
}



ulonglong __udivdi3(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  ulonglong uVar2;
  ulonglong uVar3;
  longlong lVar4;
  byte bVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  byte local_10;
  
  if (param_4 == 0) {
    if (param_2 < param_3) {
      return CONCAT44(param_2,param_1) / (ulonglong)param_3 & 0xffffffff;
    }
    if (param_3 == 0) {
      param_3 = (uint)(1 / 0);
    }
    return ((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
           (ulonglong)param_3 & 0xffffffff | (ulonglong)param_2 / (ulonglong)param_3 << 0x20;
  }
  if (param_4 <= param_2) {
    uVar6 = 0x1f;
    if (param_4 != 0) {
      while (param_4 >> uVar6 == 0) {
        uVar6 = uVar6 - 1;
      }
    }
    if ((uVar6 ^ 0x1f) != 0) {
      local_10 = (byte)(uVar6 ^ 0x1f);
      bVar5 = 0x20 - local_10;
      uVar1 = (ulonglong)(param_3 >> (bVar5 & 0x1f) | param_4 << (local_10 & 0x1f));
      uVar2 = CONCAT44(param_2 >> (bVar5 & 0x1f),
                       param_2 << (local_10 & 0x1f) | param_1 >> (bVar5 & 0x1f));
      uVar3 = uVar2 / uVar1;
      uVar6 = (uint)uVar3;
      uVar7 = (uint)(uVar2 % uVar1);
      lVar4 = (uVar3 & 0xffffffff) * (ulonglong)(param_3 << (local_10 & 0x1f));
      uVar8 = (uint)((ulonglong)lVar4 >> 0x20);
      if ((uVar7 < uVar8) || ((param_1 << (local_10 & 0x1f) < (uint)lVar4 && (uVar7 == uVar8)))) {
        return (ulonglong)(uVar6 - 1);
      }
      goto LAB_08100bc4;
    }
    if ((param_3 <= param_1) || (param_4 < param_2)) {
      uVar6 = 1;
      goto LAB_08100bc4;
    }
  }
  uVar6 = 0;
LAB_08100bc4:
  return (ulonglong)uVar6;
}



void __libc_csu_fini(void)

{
  return;
}



// WARNING: Function: __i686.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx
// WARNING: Removing unreachable block (ram,0x08100cbe)
// WARNING: Removing unreachable block (ram,0x08100cc0)

void __libc_csu_init(void)

{
  _init();
  return;
}



// WARNING: This is an inlined function

void __i686_get_pc_thunk_bx(void)

{
  return;
}



void __do_global_ctors_aux(void)

{
  code *pcVar1;
  code **ppcVar2;
  
  if (__CTOR_LIST__ != (code *)0xffffffff) {
    ppcVar2 = (code **)&__CTOR_LIST__;
    pcVar1 = __CTOR_LIST__;
    do {
      ppcVar2 = ppcVar2 + -1;
      (*pcVar1)();
      pcVar1 = *ppcVar2;
    } while (pcVar1 != (code *)0xffffffff);
  }
  return;
}



void _fini(void)

{
  __do_global_dtors_aux();
  return;
}


