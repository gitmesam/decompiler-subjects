//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <dirent.h>
#include <dlfcn.h>
#include <errno.h>
#include <libintl.h>
#include <math.h>
#include <netdb.h>
#include <pwd.h>
#include <regex.h>
#include <setjmp.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <time.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int3_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float80_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF___sigset_t {
    int32_t e0[1];
};

struct _TYPEDEF_regmatch_t {
    int32_t e0;
    int32_t e1;
};

struct __dirstream {
    int32_t e0;
};

struct __jmp_buf_tag {
    int32_t e0[8];
    int32_t e1;
    struct _TYPEDEF___sigset_t e2;
};

struct dirent {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

struct hostent {
    char * e0;
    char ** e1;
    int32_t e2;
    int32_t e3;
    char ** e4;
};

struct passwd {
    char * e0;
    char * e1;
    int32_t e2;
    int32_t e3;
    char * e4;
    char * e5;
    char * e6;
};

struct re_pattern_buffer {
    char * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    char * e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
};

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

struct tm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char * e10;
};

// ------------------- Function Prototypes --------------------

int32_t __i686_get_pc_thunk_bx(int32_t a1, int32_t a2);
char __r_delete(int32_t node, int32_t query);
void __r_destroy_tree(int32_t node);
void __r_insert_node(int32_t node, int32_t query, int32_t manage, char force);
int32_t __r_search(int32_t node, int32_t query, int32_t arg);
void AddObjectToFlagUndoList(int32_t Type, char * Ptr1, char * Ptr2, char * Ptr3);
void AddTextToElement(int32_t Text, int32_t PCBFont, int32_t X, int32_t Y, char Direction, char * TextString, int32_t Scale, int32_t Flags);
void adjust_bounds(int32_t node);
void AdjustAttachedLine(void);
void AdjustAttachedObjects(void);
int32_t AdjustInsertPoint(void);
void AdjustTwoLine(int32_t way);
char * alloc_buf(int32_t len);
void apply_default_hid(int32_t d, int32_t s);
char * c_dtostr(float64_t d);
float64_t c_strtod(char * s);
int32_t ChangeGroupVisibility(int32_t Layer2, char On, char ChangeStackOrder);
void ChangePCBSize(int32_t Width, int32_t Height);
void ClearFromPolygon(int32_t Data, int32_t type, char * ptr1, char * ptr2);
int32_t clearPoly(int32_t Data, int32_t Layer2, int32_t polygon, int32_t here, int32_t expand);
void ClearUndoList(char Force);
char * common_flags_to_string(int32_t flags, int32_t object_type, uint32_t flagbits, int32_t n_flagbits);
int32_t common_string_to_flags(char * flagstring, int32_t (*error)(char *), int32_t flagbits, int32_t n_flagbits);
char * Concat(char * first, ...);
void copyright(void);
void CreateDefaultFont(void);
int32_t CreateNewArcInElement(int32_t Element, int32_t X, int32_t Y, int32_t Width, int32_t Height, int32_t Angle, int32_t Delta, int32_t Thickness);
int32_t CreateNewArcOnLayer(int32_t Layer2, int32_t X1, int32_t Y1, int32_t width, int32_t height, int32_t sa, int32_t dir, int32_t Thickness, int32_t Clearance, int32_t Flags);
int32_t CreateNewAttribute(int32_t list, char * name, char * value);
int32_t CreateNewBuffer(void);
int32_t CreateNewConnection(int32_t net, char * conn);
int32_t CreateNewElement(int32_t Data, int32_t Element, int32_t PCBFont, int32_t Flags, char * Description, char * NameOnPCB, char * Value, int32_t TextX, int32_t TextY, char Direction, int32_t TextScale, int32_t TextFlags, char uniqueName);
int32_t CreateNewLineInElement(int32_t Element, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Thickness);
int32_t CreateNewLineInSymbol(int32_t Symbol2, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Thickness);
int32_t CreateNewLineOnLayer(int32_t Layer2, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Thickness, int32_t Clearance, int32_t Flags);
int32_t CreateNewNet(int32_t lib, char * name, char * style);
int32_t CreateNewPad(int32_t Element, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Thickness, int32_t Clearance, int32_t Mask, char * Name, char * Number, int32_t Flags);
int32_t CreateNewPCB(char SetDefaultNames);
int32_t CreateNewPCBPost(int32_t pcb, int32_t use_defaults);
int32_t CreateNewPin(int32_t Element, int32_t X, int32_t Y, int32_t Thickness, int32_t Clearance, int32_t Mask, int32_t DrillingHole, char * Name, char * Number, int32_t Flags);
int32_t CreateNewPointInPolygon(int32_t Polygon2, int32_t X, int32_t Y);
int32_t CreateNewPolygon(int32_t Layer2, int32_t Flags);
int32_t CreateNewPolygonFromRectangle(int32_t Layer2, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Flags);
int32_t CreateNewRat(int32_t Data, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t group1, int32_t group2, int32_t Thickness, int32_t Flags);
int32_t CreateNewText(int32_t Layer2, int32_t PCBFont, int32_t X, int32_t Y, char Direction, int32_t Scale, char * TextString, int32_t Flags);
int32_t CreateNewVia(int32_t Data, uint32_t X, uint32_t Y, int32_t Thickness, int32_t Clearance, int32_t Mask, int32_t DrillingHole, char * Name, int32_t Flags);
void CreateQuotedString(int32_t DS, char * S);
void CrosshairOff(char BlockToo);
void CrosshairOn(char BlockToo);
char * DestroyObject(int32_t Target, int32_t Type, char * Ptr1, char * Ptr2, char * Ptr3);
void Draw(void);
void DrawArc(int32_t Layer2, int32_t Arc, int32_t unused);
void DrawArcLowLevel(int32_t Arc);
void DrawAttached(char BlockToo);
void DrawLine(int32_t Layer2, int32_t Line, int32_t unused);
void DrawLineLowLevel(int32_t Line, char HaveGathered);
void DrawMark(char ifvis);
void DrawPad(int32_t Pad, int32_t unused);
void DrawPadLowLevel(int32_t gc, int32_t Pad, char clear, char mask);
void DrawPadNameLowLevel(int32_t Pad);
void DrawPin(int32_t Pin, int32_t unused);
void DrawPinOrViaLowLevel(int32_t Ptr, char drawHole);
void DrawPinOrViaNameLowLevel(int32_t Ptr);
void DrawPolygon(int32_t Layer2, int32_t Polygon2, int32_t unused);
void DrawRat(int32_t Line, int32_t unused);
void DrawSpecialPolygon(int32_t hid, int32_t DrawGC, int32_t X, int32_t Y, int32_t Thickness);
void DrawTextLowLevel(int32_t Text, int32_t min_line_width);
void DrawVia(int32_t Via, int32_t unused);
float32_t drc_lines(int32_t end, char way);
void DSAddCharacter(int32_t Ptr, char Char);
void DSAddString(int32_t Ptr, char * S);
void DSClearString(int32_t Ptr);
void dump_actions(void);
void dump_string(char prefix, char * str);
void EmergencySave(void);
void EnableAutosave(void);
void EnforceLineDRC(void);
char * EvaluateFilename(char * Template, char * Path, char * Filename, char * Parameter);
int32_t find_clusters(int32_t node);
void FitCrosshairIntoGrid(int32_t X, int32_t Y);
char * flags_to_string(int32_t flags, int32_t object_type);
void FortyFiveLine(int32_t Line);
void FreeAttributeListMemory(int32_t list);
void FreeDataMemory(int32_t Data);
void FreeElementMemory(int32_t Element);
void FreeLibraryMemory(int32_t lib);
void FreePCBMemory(int32_t PCBPtr);
void FreePolygonMemory(int32_t Polygon2);
int32_t function_805e978(int32_t a1);
int32_t function_805ecf8(void);
int32_t function_805edd8(int32_t * a1);
int32_t function_805ef38(int32_t a1, char * a2, int32_t * a3);
int32_t function_805efc8(int32_t a1, int32_t * a2);
int32_t function_805eff8(int32_t * a1);
int32_t function_805f098(int32_t a1);
int32_t function_805f2b8(int32_t a1, char * a2, int32_t a3, int32_t * a4);
int32_t function_805f448(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_805fc48(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_805fcf8(int32_t a1, char * a2, int32_t * a3, int32_t a4);
int32_t function_80600e8(int32_t a1);
int32_t function_8060118(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_8060718(int32_t * a1);
int32_t function_80607f8(int32_t a1, char * a2, int32_t * a3, float80_t a4);
int32_t function_8060908(int32_t a1, char * a2);
int32_t function_8060d88(float80_t a1);
int32_t GetArcEnds(int32_t Arc);
int32_t GetArcMemory(int32_t Layer2);
int32_t GetDataBoundingBox(int32_t Data);
int32_t GetElementMemory(int32_t Data);
int32_t GetGroupOfLayer(int32_t result);
int32_t GetLayerGroupNumberByNumber(int32_t a1);
int32_t GetLayerNumber(int32_t a1, int32_t a2);
int32_t GetLibraryEntryMemory(int32_t Menu2);
int32_t GetLibraryMenuMemory(int32_t lib);
int32_t GetLineMemory(int32_t Layer2);
void GetNum(char ** s, int32_t * num);
int32_t GetPadMemory(int32_t Element);
int32_t GetPinMemory(int32_t Element);
int32_t GetPointMemoryInPolygon(int32_t Polygon2);
int32_t GetPolygonMemory(int32_t Layer2);
int32_t GetRatMemory(int32_t Data);
int32_t GetTextMemory(int32_t Layer2);
int32_t GetUndoSlot(int32_t CommandType, int32_t ID2, int32_t Kind);
int32_t GetViaMemory(int32_t Data);
char * GetWorkingDirectory(char * path);
void grow_layer_list(int32_t num);
int32_t hid_action(char * name);
int32_t hid_actionl(char * name, ...);
int32_t hid_actionv(char * name, uint32_t argc, char ** argv);
void hid_bom_init(void);
int32_t hid_enumerate(void);
void hid_eps_init(void);
int32_t hid_find_action(char * name, char ** context);
int32_t hid_find_exporter(char * which);
int32_t hid_find_flag(char * name);
int32_t hid_find_gui(void);
int32_t hid_find_printer(void);
void hid_gerber_init(void);
int32_t hid_get_flag(char * name);
void hid_gtk_init(void);
void hid_init(void);
void hid_load_dir(char * dirname);
void hid_load_settings(void);
void hid_load_settings_1(char * fname);
void hid_lpr_init(void);
void hid_nelma_init(void);
int32_t hid_parse_actions(char * rstr, int32_t (*function)(char *, int32_t, char **));
void hid_png_init(void);
void hid_ps_init(void);
void hid_register_actions(int32_t a, int32_t n);
void hid_register_actions_context(int32_t a, int32_t n, char * context, int32_t dynamic);
void hid_register_attributes(int32_t a, int32_t n);
void hid_register_flags(int32_t a, int32_t n);
void hid_register_hid(int32_t hid);
void HideCrosshair(char BlockToo);
void IncrementUndoSerialNumber(void);
void InitBuffers(void);
int32_t InitClip(int32_t Data, int32_t layer, int32_t p);
void InitCrosshair(void);
char IsDataEmpty(int32_t Data);
char * LayerGroupsToString(int32_t lg);
void LayerStringToLayerStack(char * s);
int32_t LoadPCB(char * Filename);
char * lrealpath(char * filename);
char * make_edge_tree(int32_t pb);
int32_t MakeFlags(int32_t flags);
int32_t mem_any_set(char * ptr, int32_t bytes);
void Message(char * Format, ...);
void MoveCrosshairRelative(int32_t DeltaX, int32_t DeltaY);
void MoveElementLowLevel(int32_t Data, int32_t Element, int32_t DX, int32_t DY);
char * MyCalloc(int32_t Number, int32_t Size, char * Text);
void MyFatal(char * Format, ...);
char * MyRealloc(char * Ptr, int32_t Size, char * Text);
char * MyStrdup(char * S, char * Text);
char * ObjectOperation(int32_t F, int32_t Type, char * Ptr1, char * Ptr2, char * Ptr3);
int32_t OldFlags(int32_t flags);
void OpendirErrorMessage(char * DirName);
void OpenErrorMessage(char * Filename);
int32_t original_poly(int32_t p);
int32_t Parse(char * Executable, char * Path, char * Filename, char * Parameter);
int32_t parse_number(float64_t scale);
int32_t ParseFont(int32_t Ptr, char * Filename);
int32_t ParseGroupString(char * s, int32_t LayerGroup, int32_t LayerN);
int32_t ParseLibraryTree(void);
int32_t ParsePCB(int32_t Ptr, char * Filename);
int32_t ParseRouteString(char * s, int32_t routeStyle, int32_t scale);
void pcb_colors_from_settings(int32_t ptr);
void pcb_dbus_connection_finish_with_mainloop(int32_t connection);
void pcb_dbus_connection_setup_with_mainloop(int32_t connection);
void pcb_dbus_finish(void);
void pcb_dbus_setup(void);
char * pcbflags_to_string(int32_t flags);
int32_t PlowsPolygon(int32_t Data, int32_t type, char * ptr1, char * ptr2, int32_t call_back);
int32_t poly_Create(void);
int32_t poly_CreateNode(int32_t * v);
void poly_DelContour(int32_t c);
void poly_ExclVertex(int32_t node);
void poly_Free(int32_t p);
void poly_FreeContours(int32_t pline);
int32_t poly_InclContour(int32_t p, int32_t c);
void poly_InclVertex(int32_t after, int32_t node);
void poly_InvContour(int32_t c);
int32_t poly_NewContour(int32_t * v);
void poly_PreContour(int32_t C, int32_t optimize);
void PopenErrorMessage(char * Filename);
void PostLoadElementPCB(void);
void PreLoadElementPCB(void);
void print_actions(void);
void print_defaults_1(int32_t a, char * value);
void print_version(void);
void PrintQuotedString(struct _IO_FILE * FP, char * S);
int32_t r_create_tree(int32_t boxlist, int32_t N, int32_t manage);
char r_delete_entry(int32_t rtree, int32_t box);
void r_destroy_tree(int32_t rtree);
void r_insert_entry(int32_t rtree, int32_t which, int32_t man);
int32_t r_search(int32_t rtree, int32_t query, int32_t check_region, int32_t found_rectangle, char * cl);
int32_t ReadLibraryContents(void);
void register_action_action_list(void);
void register_command_action_list(void);
void register_djopt_action_list(void);
void register_djopt_flag_list(void);
void register_eps_attribute_list(void);
void register_flags_flag_list(void);
void register_fontmode_action_list(void);
void register_ghid_attribute_list(void);
void register_ghid_main_action_list(void);
void register_ghid_main_flag_list(void);
void register_ghid_menu_action_list(void);
void register_ghid_netlist_action_list(void);
void register_gtk_topwindow_action_list(void);
void register_main_attribute_list(void);
void register_move_action_list(void);
void register_nelma_attribute_list(void);
void register_netlist_action_list(void);
void register_pcbmenu_attr(void);
void register_png_attribute_list(void);
void register_ps_attribute_list(void);
void register_puller_action_list(void);
void register_report_action_list(void);
void register_rotate_action_list(void);
void register_toporouter_action_list(void);
void register_vendor_action_list(void);
void register_vendor_flag_list(void);
char rematch(char * re, char * s);
void RemovePCB(int32_t Ptr);
void RemoveTMPData(void);
void ResetFoundLinesAndPolygons(char AndDraw);
void ResetFoundPinsViasAndPads(char AndDraw);
void ResetStackAndVisibility(void);
void RestoreCrosshair(char BlockToo);
void RestoreToPolygon(int32_t Data, int32_t type, char * ptr1, char * ptr2);
void RestoreUndoSerialNumber(void);
void RightAngles(int32_t Angle, float32_t * cosa, float32_t * sina);
void RotateBoxLowLevel(int32_t Box, int32_t X, int32_t Y, unsigned char Number);
void RotateLineLowLevel(int32_t Line, int32_t X, int32_t Y, unsigned char Number);
void SaveFree(char * Ptr);
void SaveInTMP(void);
void SaveTMPData(void);
void SaveUndoSerialNumber(void);
char SearchArcByLocation(int32_t locked, int32_t Layer2, int32_t Arc, int32_t Dummy);
char SearchElementByLocation(int32_t locked, int32_t Element, int32_t Dummy1, int32_t Dummy2, char BackToo);
char SearchElementNameByLocation(int32_t locked, int32_t Element, int32_t Text, int32_t Dummy, char BackToo);
char SearchLineByLocation(int32_t locked, int32_t Layer2, int32_t Line, int32_t Dummy);
int32_t SearchObjectByID(int32_t Base, char ** Result1, char ** Result2, char ** Result3, int32_t ID2, int32_t type);
int32_t SearchObjectByLocation(int32_t Type, char ** Result1, char ** Result2, char ** Result3, int32_t X, int32_t Y, int32_t Radius);
char SearchPadByLocation(int32_t locked, int32_t Element, int32_t Pad, int32_t Dummy, char BackToo);
char SearchPinByLocation(int32_t locked, int32_t Element, int32_t Pin, int32_t Dummy);
char SearchPolygonByLocation(int32_t locked, int32_t Layer2, int32_t Polygon2, int32_t Dummy);
char SearchRatLineByLocation(int32_t locked, int32_t Line, int32_t Dummy1, int32_t Dummy2);
int32_t SearchScreen(int32_t X, int32_t Y, int32_t Type, char ** Result1, char ** Result2, char ** Result3);
char SearchTextByLocation(int32_t locked, int32_t Layer2, int32_t Text, int32_t Dummy);
char SearchViaByLocation(int32_t locked, int32_t Via, int32_t Dummy1, int32_t Dummy2);
void SetArcBoundingBox(int32_t Arc);
void SetBufferBoundingBox(int32_t Buffer);
void SetChangedFlag(char New);
void SetCrosshairRange(int32_t MinX, int32_t MinY, int32_t MaxX, int32_t MaxY);
void SetCrosshairRangeToBuffer(void);
void SetElementBoundingBox(int32_t Data, int32_t Element, int32_t Font);
void SetFontInfo(int32_t Ptr);
void SetKeepawayWidth(uint32_t Width);
void SetLineBoundingBox(int32_t Line);
void SetLineSize(int32_t Size);
void SetLocalRef(int32_t X, int32_t Y, char Showing);
void SetMode(int32_t Mode);
void SetPadBoundingBox(int32_t Pad);
void SetPinBoundingBox(int32_t Pin);
void SetPolygonBoundingBox(int32_t Polygon2);
void SetPVColor(int32_t Pin, int32_t Type);
void SetTextBoundingBox(int32_t FontPtr, int32_t Text);
void SetViaDrillingHole(uint32_t Size, char Force);
void SetViaSize(int32_t Size, char Force);
void sort_library(int32_t lib);
int32_t string_to_flags(char * flagstring, int32_t (*error)(char *));
int32_t string_to_pcbflags(char * flagstring, int32_t (*error)(char *));
void u(char * fmt, ...);
char * UniqueElementName(int32_t Data, char * Name);
void usage(void);
void usage_attr(int32_t a);
void usage_hid(int32_t h);
int32_t vendorDrillMap(int32_t in);
char vendorIsElementMappable(int32_t element);
void WriteElementData(struct _IO_FILE * FP, int32_t Data);
void WriteLayerData(struct _IO_FILE * FP, int32_t Number, int32_t layer);
int32_t WritePCB(struct _IO_FILE * FP);
int32_t WritePCBFile(char * Filename);
void WritePCBInfoHeader(struct _IO_FILE * FP);
void WriteViaData(struct _IO_FILE * FP, int32_t Data);
void XORDrawAttachedArc(int32_t thick);
void XORDrawAttachedLine(int32_t x1, int32_t y1, int32_t x2, int32_t y2, int32_t thick);
void XORDrawElement(int32_t Element, int32_t DX, int32_t DY);
void XORPolygon(int32_t polygon, int32_t dx, int32_t dy);
int32_t yy_create_buffer(struct _IO_FILE * file, int32_t size);
void yy_delete_buffer(int32_t b);
void yy_fatal_error(char * msg);
void yy_flush_buffer(int32_t b);
void yy_init_buffer(int32_t b, struct _IO_FILE * file);
int32_t yylex(void);
int32_t yyparse(void);
void yyrestart(struct _IO_FILE * input_file);
int32_t yywrap(void);

// --------------------- Global Variables ---------------------

int32_t Block = 0; // 0x816b988
int32_t Buffers = 0; // 0x8195780
char Bumped = 0; // 0x81958c0
int32_t Crosshair = 0; // 0x81958e0
char CrosshairStack[16]; // 0x816b874
int32_t CrosshairStackLocation = 0; // 0x816b870
int32_t DestroyFunctions = 0x80c1420; // 0x8167f00
int32_t DestroyTarget = 0; // 0x817ced8
char Gathering = 1; // 0x8164470
int32_t ID = 1; // 0x8164410
int32_t InsertedPoint = 0; // 0x816b500
int32_t Layer = 0; // 0x817cb74
char LayerFlag[18]; // 0x817cb88
int32_t LayerStack[16]; // 0x8195880
int32_t Library = 0; // 0x8195824
char Locked = 0; // 0x818d040
int32_t Marked = 0; // 0x81958c4
int32_t Menu = 0; // 0x817cb84
int32_t Output = 0; // 0x8195840
int32_t PCB = 0; // 0x8195834
int32_t Polygon = 0; // 0x817cb78
float32_t PosX = 0.0f; // 0x818cf40
float32_t PosY = 0.0f; // 0x818cf44
int32_t Progname = 0; // 0x819580c
int32_t RedoN = 0; // 0x818d054
int32_t RemoveList = 0; // 0x818d048
int32_t SavedSerial = 0; // 0x818d04c
int32_t SearchBox = 0; // 0x818cf4c
int32_t SearchLayer = 0; // 0x818cf5c
int32_t SearchRadius = 0; // 0x818cf48
int32_t Serial = 1; // 0x81682d0
int32_t Settings = 0; // 0x8194fe0
int32_t Symbol = 0; // 0x817cb7c
char TMPFilename[80]; // 0x816c100
int32_t TheFlag = 4; // 0x81660f4
int32_t UndoList = 0; // 0x818d044
int32_t UndoMax = 0; // 0x818d058
int32_t UndoN = 0; // 0x818d050
int32_t Xorig = 0; // 0x8195778
int32_t Yorig = 0; // 0x8195810
float64_t Zoom_Multiplier = 0.01; // 0x8164418
int32_t action_action_list = 0x813a183; // 0x8163a00
int32_t addedLines = 0; // 0x8194fc8
int32_t all_actions = 0; // 0x818d0a0
int32_t all_flags = 0; // 0x818d0c8
int32_t attr_list = 0; // 0x817cba0
int32_t backup_timer = 0; // 0x816c150
int32_t bindir = 0; // 0x816c740
int32_t bom_hid = 208; // 0x816a420
int32_t buffers = 0; // 0x818cfe0
int32_t bufptr = 0; // 0x818cfc0
int32_t cached_drill = -1; // 0x8168364
int32_t cached_map = -1; // 0x8168368
int32_t command_action_list = 0x81486b9; // 0x8164300
int32_t command_line_pcb = 0; // 0x816c848
int32_t djopt_action_list = 0x813ee77; // 0x8164440
int32_t djopt_flag_list = 0x813ee6b; // 0x8164420
int32_t do_dump_actions = 0; // 0x816c77c
int32_t doing_pinout = 0; // 0x816b920
char dont_save_any_more = 0; // 0x816c0d8
int32_t empty_flags = 0; // 0x818d030
int32_t eps_attribute_list = 0x815f5ec; // 0x816b3a0
int32_t eps_hid = 208; // 0x816b2c0
int32_t exec_prefix = 0; // 0x816c744
int32_t exporter = 0; // 0x818d0d8
int32_t flags_flag_list = 0x814762e; // 0x8166100
int32_t fontmode_action_list = 0x81483b7; // 0x8166460
int32_t gerber_hid = 208; // 0x816a5a0
int32_t ghid_attribute_list = 0x81560fa; // 0x81695a0
int32_t ghid_extents = 208; // 0x8168680
int32_t ghid_hid = 208; // 0x81685a0
int32_t ghid_main_action_list = 0x8152372; // 0x8168760
int32_t ghid_main_flag_list = 0x8152441; // 0x8168940
int32_t ghid_menu_action_list = 0x81556dc; // 0x8169640
int32_t ghid_netlist_action_list = 0x8139f65; // 0x8168cc0
float64_t * g1 = NULL; // 0x813f1e0
float64_t * g2 = (float64_t *)-0x66699f09; // 0x813f1e8
int32_t g3 = 0x20230073; // 0x814736c
char * g4 = "\t"; // 0x814741a
char * g5; // 0x814741b
char * g6 = "<"; // 0x8148545
int32_t g7 = 0x2d2d007c; // 0x8148547
char * g8 = "p"; // 0x81486bf
char * g9 = "\tTemplate: \x1b[33m%s\x1b[0m\n"; // 0x8149e51
char * g10 = "\tPath: \x1b[33m%s\x1b[0m\n"; // 0x8149e69
char * g11 = "\tFilename: \x1b[33m%s\x1b[0m\n"; // 0x8149e7d
char * g12 = "\tParameter: \x1b[33m%s\x1b[0m\n"; // 0x8149e95
char * g13 = "EvaluateFilename: \x1b[32m%s\x1b[0m\n"; // 0x814a2b8
char * g14; // 0x814aa80
int32_t g15 = 0xb30000; // 0x814ae80
char * g16; // 0x814b000
int32_t g17 = 0; // 0x814b0e0
int32_t g18 = 0x10000; // 0x814b260
int32_t g19 = 0x40000; // 0x814b4a0
int32_t g20 = 0x10000; // 0x814b6e0
int32_t g21 = 0x20001; // 0x814b6e2
int32_t g22 = 0x260000; // 0x814b860
int32_t g23 = -0x1a7fff5; // 0x814bf00
char * g24; // 0x814c3e0
int32_t g25 = 0xc30034; // 0x814c520
int32_t g26 = 0xf0004e; // 0x814c9c0
char * g27; // 0x814ce60
char * g28; // 0x814d0e0
char * g29; // 0x814d1c0
int32_t g30 = -0x1a701a8; // 0x814d2a0
int32_t g31 = 0x2ffff; // 0x814d380
char * g32 = "Action: \x1b[34m%s("; // 0x815012d
char * g33 = ")\x1b[0m\n"; // 0x815013e
int32_t g34 = 0x6370002c; // 0x815ca28
char ** g35 = (char **)0x2f0a002f; // 0x815d1de
int32_t g36 = 0x7573002e; // 0x815d403
int32_t g37 = 0; // 0x81664f8
char g38 = 1; // 0x8167eac
int32_t g39 = 1; // 0x8167eb0
int32_t g40 = 0x100000; // 0x81682d4
char g41 = 0; // 0x816838c
int32_t g42 = 0x80d8020; // 0x8168408
struct _IO_FILE * g43 = NULL; // 0x816b4a0
int32_t g44 = 0; // 0x816b4a4
int32_t g45 = 0; // 0x816b4c0
int32_t g46 = 0; // 0x816b504
int32_t g47 = 0; // 0x816b508
int32_t g48 = 0; // 0x816b50c
int32_t g49 = 0; // 0x816b510
char g50 = 0; // 0x816b873
int32_t g51 = 0; // 0x816b940
int32_t g52 = 0; // 0x816b960
int32_t g53 = 0; // 0x816b980
int32_t g54 = 0; // 0x816b98c
int32_t g55 = 0; // 0x816b990
int32_t g56 = 0; // 0x816b994
int32_t g57 = 0; // 0x816c0c8
int32_t g58 = 0; // 0x816c0cc
char * g59; // 0x816c0d0
int32_t g60 = 0; // 0x816c0d4
int32_t g61 = 0; // 0x816c718
int32_t g62 = 0; // 0x816c71c
char * g63; // 0x816c780
char * g64; // 0x816c880
int32_t g65 = 0; // 0x816c881
char * g66; // 0x816c900
char * g67; // 0x816c960
int32_t g68 = 0; // 0x816ca60
int32_t g69 = 0; // 0x816ca64
int32_t g70 = 0; // 0x816ca68
int32_t g71 = 0; // 0x816ca6c
int32_t g72 = 0; // 0x816ca74
int32_t g73 = 0; // 0x816ca80
char * g74; // 0x816ca84
int32_t g75 = 0; // 0x816ca88
int32_t g76 = 0; // 0x816ca8c
int32_t g77 = 0; // 0x816ca90
int32_t g78 = 0; // 0x816ca94
struct _IO_FILE * g79 = NULL; // 0x816cb28
int32_t g80 = 0; // 0x816cb2c
int32_t g81 = 0; // 0x816cb30
int32_t g82 = 0; // 0x816cb34
char g83 = 0; // 0x816cb38
int32_t g84 = 0; // 0x816cb3c
int32_t g85 = 0; // 0x816cb40
int32_t g86 = 0; // 0x816cb60
int32_t g87 = 0; // 0x816cb64
struct _IO_FILE * g88 = NULL; // 0x817cb68
int32_t g89 = 0; // 0x817cb6c
int32_t g90 = 0; // 0x817cb70
char * g91; // 0x817cb87
int32_t g92 = 0; // 0x817cb89
int32_t g93 = 0; // 0x818cf50
int32_t g94 = 0; // 0x818cf54
int32_t g95 = 0; // 0x818cf58
int32_t g96 = 0; // 0x818cf60
int32_t g97 = 0; // 0x818cf64
int32_t g98 = 0; // 0x818cf68
int32_t g99 = 0; // 0x818cf6c
char g100 = 0; // 0x818cf70
int32_t g101 = 0; // 0x818cfd0
char * g102; // 0x818cfd4
int32_t g103 = 0; // 0x818cfe4
int32_t g104 = 0; // 0x818d034
int32_t g105 = 0; // 0x818d038
int32_t g106 = 0; // 0x818d0c0
char * g107; // 0x818d0c4
int32_t g108 = 0; // 0x8194fe4
int32_t g109 = 0; // 0x8194ffc
int32_t g110 = 0; // 0x8195000
int32_t g111 = 0; // 0x8195004
int32_t g112 = 0; // 0x8195008
int32_t g113 = 0; // 0x819500c
int32_t g114 = 0; // 0x8195010
int32_t g115 = 0; // 0x8195014
int32_t g116 = 0; // 0x8195018
int32_t g117 = 0; // 0x819501c
int32_t g118 = 0; // 0x8195020
int32_t g119 = 0; // 0x8195024
int32_t g120 = 0; // 0x8195028
char * g121; // 0x8195030
int32_t g122 = 0; // 0x8195034
int32_t g123 = 0; // 0x8195070
int32_t g124 = 0; // 0x8195074
int32_t g125 = 0; // 0x81950b4
int32_t g126 = 0; // 0x81950b8
int32_t g127 = 0; // 0x81950bc
char * g128; // 0x81950c0
int32_t g129 = 0; // 0x81950c4
int32_t g130 = 0; // 0x81950c8
int32_t g131 = 0; // 0x81950cc
int32_t g132 = 0; // 0x81950d0
int32_t g133 = 0; // 0x81950d4
int32_t g134 = 0; // 0x81950e0
int32_t g135 = 0; // 0x81950e4
int32_t g136 = 0; // 0x81950e8
int32_t g137 = 0; // 0x81950ec
int32_t g138 = 0; // 0x81950f0
int32_t g139 = 0; // 0x81950f4
float64_t g140 = 0.0; // 0x8195148
int32_t g141 = 0; // 0x8195164
int64_t g142 = 0; // 0x8195168
int32_t g143 = 0; // 0x8195170
int32_t g144 = 0; // 0x8195174
int32_t g145 = 0; // 0x81951c4
char * g146; // 0x81951c8
char * g147; // 0x81951cc
char * g148; // 0x81951d0
char * g149; // 0x81951d8
char * g150; // 0x81951dc
int32_t g151 = 0; // 0x81951e0
int32_t g152 = 0; // 0x81951e4
char * g153; // 0x81951f4
char * g154; // 0x8195200
char * g155; // 0x8195214
char * g156; // 0x8195218
char * g157; // 0x8195220
int32_t g158 = 0; // 0x8195230
int32_t g159 = 0; // 0x8195234
int32_t g160 = 0; // 0x8195238
int32_t g161 = 0; // 0x819523c
int32_t g162 = 0; // 0x8195240
int32_t g163 = 0; // 0x8195244
int32_t g164 = 0; // 0x8195248
char * g165; // 0x8195298
char g166 = 0; // 0x8195758
char g167 = 0; // 0x8195759
char g168 = 0; // 0x819575a
char g169 = 0; // 0x819575b
char g170 = 0; // 0x819575c
char g171 = 0; // 0x819575f
char g172 = 0; // 0x8195762
char g173 = 0; // 0x8195763
char g174 = 0; // 0x8195764
char g175 = 0; // 0x8195765
char g176 = 0; // 0x8195766
char g177 = 0; // 0x8195767
char g178 = 0; // 0x8195768
char g179 = 0; // 0x819576a
int32_t g180 = 0; // 0x8195774
int32_t g181 = 0; // 0x8195798
int32_t g182 = 0; // 0x81957b4
int32_t g183 = 0; // 0x81957d0
int32_t g184 = 0; // 0x81957ec
int32_t g185 = 0; // 0x8195808
char * g186; // 0x8195844
char * g187; // 0x8195848
char * g188; // 0x819584c
int32_t g189 = 0; // 0x8195850
int64_t g190 = 0; // 0x8195854
int32_t g191 = 0; // 0x81958c8
int32_t g192 = 0; // 0x81958cc
int32_t g193 = 0; // 0x81958e8
int32_t g194 = 0; // 0x81958ec
int32_t g195 = 0; // 0x81958f0
int32_t g196 = 0; // 0x81958f4
int32_t g197 = 0; // 0x81958f8
int32_t g198 = 0; // 0x81958fc
char g199 = 0; // 0x8195900
char * g200; // 0x8195904
int32_t g201 = 0; // 0x8195908
char * g202; // 0x8195918
int32_t g203 = 0; // 0x819591c
int32_t g204 = 0; // 0x819592c
char g205 = 0; // 0x8195930
char * g206; // 0x8195934
int32_t g207 = 0; // 0x8195938
char * g208; // 0x8195948
int32_t g209 = 0; // 0x819594c
int32_t g210 = 0; // 0x819595c
char g211 = 0; // 0x8195960
int32_t g212 = 0; // 0x8195988
int32_t g213 = 0; // 0x81959a4
int32_t g214 = 0; // 0x81959b8
int32_t g215 = 0; // 0x81959bc
char * g216; // 0x81959c0
int32_t g217 = 0; // 0x81959c4
int32_t g218 = 0; // 0x81959c8
int32_t g219 = 0; // 0x81959cc
char * g220; // 0x81959d4
int32_t g221 = 0; // 0x81959d8
int32_t g222 = 0; // 0x8195a30
int32_t g223 = 0; // 0x8195a34
int32_t gtk_topwindow_action_list = 0x813e434; // 0x8169600
int32_t gui = 0x8168380; // 0x816836c
int32_t hid_action_nodes = 0; // 0x818d098
int32_t hid_attr_nodes = 0; // 0x818d0dc
int32_t hid_flag_nodes = 0; // 0x818d0a8
int32_t hid_list = 0; // 0x818d0d0
int32_t hid_nogui = 208; // 0x8168380
int32_t hid_num_hids = 0; // 0x818d0d4
int32_t homedir = 0; // 0x816c758
char ** ignore_descr = NULL; // 0x818d074
char ** ignore_refdes = NULL; // 0x818d064
char ** ignore_value = NULL; // 0x818d06c
char inhibit = 0; // 0x817cba4
int32_t layer_group_string = 0; // 0x817cb9c
int32_t layers = 0; // 0x818cfc4
int32_t lpr_hid = 208; // 0x816a300
int32_t main_attribute_list = 0x814873e; // 0x81664e0
int32_t max_layers = 0; // 0x818cfc8
int32_t move_action_list = 0x814a3e0; // 0x8167de0
int32_t n_actions = 0; // 0x818d0a4
int32_t n_descr = 0; // 0x818d078
int32_t n_flags = 0; // 0x818d0cc
int32_t n_refdes = 0; // 0x818d068
int32_t n_value = 0; // 0x818d070
int32_t n_vendor_drills = 0; // 0x818d07c
int32_t nelma_attribute_list = 0x815d391; // 0x816a720
int32_t nelma_hid = 208; // 0x816a820
int32_t netlist_action_list = 0x8154952; // 0x8167e80
int32_t netlist_sort_offset = 0; // 0x816c0c4
int32_t num_layers = 0; // 0x818cfcc
int32_t object_flagbits = 1; // 0x8168160
int32_t pcb_dbus_conn = 0; // 0x818d938
int32_t pcb_flagbits = 1; // 0x8168000
int32_t pcblibdir = 0; // 0x816c748
int32_t pcblibpath = 0; // 0x816c74c
int32_t pcbmenu_attr = 0x815615e; // 0x8169680
int32_t pcbtreedir = 0; // 0x816c750
int32_t pcbtreepath = 0; // 0x816c754
int32_t pin_num = 0; // 0x817cb80
int32_t pixel_slop = 1; // 0x8168370
int32_t png_attribute_list = 0x815d8ef; // 0x816a920
int32_t png_hid = 208; // 0x816ac60
int32_t program_basename = 0; // 0x816c760
int32_t program_directory = 0; // 0x816c764
int32_t program_name = 0; // 0x816c75c
int32_t ps_attribute_list = 0x815ea08; // 0x816ad60
int32_t ps_hid = 208; // 0x816b100
int32_t puller_action_list = 0x814d844; // 0x8167ec0
char render = 0; // 0x81959ec
int32_t report_action_list = 0x814e04d; // 0x8167f80
int32_t rotate_action_list = 0x813e1db; // 0x8163ea0
int32_t rounding_method = 0; // 0x818d084
int32_t show_actions = 0; // 0x816c778
int32_t show_copyright = 0; // 0x816c770
int32_t show_defaults = 0; // 0x816c774
int32_t show_help = 0; // 0x816c768
int32_t show_version = 0; // 0x816c76c
int32_t toporouter_action_list = 0x813a463; // 0x8168540
int32_t g224;
int32_t g225;
uint32_t g226;
int32_t g227;
int32_t g228;
int32_t g229;
int32_t g230;
int32_t g231;
char vendorMapEnable = 0; // 0x818d060
int32_t vendor_action_list = 0x814fece; // 0x81682e0
int32_t * vendor_drills = NULL; // 0x818d080
int32_t vendor_flag_list = 0x814ff1e; // 0x8168358
int32_t yyData = 0; // 0x8195a20
int32_t yyElement = 0; // 0x8195a1c
int32_t yyFont = 0; // 0x8195a18
int32_t yyPCB = 0; // 0x8195a0c
int32_t yychar = 0; // 0x8195a28
int32_t yyfilename = 0; // 0x8195a24
int32_t yyin = 0; // 0x816cb20
int32_t yyleng = 0; // 0x8195a10
int32_t yylineno = 1; // 0x8167ea8
int32_t yylval = 0; // 0x8195a2c
int32_t yynerrs = 0; // 0x8195a38
int32_t yyout = 0; // 0x816cb24
int32_t yytext = 0; // 0x8195a14

// ------------------------ Functions -------------------------

// Address range: 0x805e978 - 0x805e97e
int32_t function_805e978(int32_t a1) {
    // 0x805e978
    return dbus_connection_unref();
}

// Address range: 0x805ecf8 - 0x805ecfe
int32_t function_805ecf8(void) {
    // 0x805ecf8
    return dbus_shutdown();
}

// Address range: 0x805edd8 - 0x805edde
int32_t function_805edd8(int32_t * a1) {
    // 0x805edd8
    return dbus_error_init();
}

// Address range: 0x805ef38 - 0x805ef3e
int32_t function_805ef38(int32_t a1, char * a2, int32_t * a3) {
    // 0x805ef38
    return dbus_bus_release_name();
}

// Address range: 0x805efc8 - 0x805efce
int32_t function_805efc8(int32_t a1, int32_t * a2) {
    // 0x805efc8
    return dbus_bus_get_private();
}

// Address range: 0x805eff8 - 0x805effe
int32_t function_805eff8(int32_t * a1) {
    // 0x805eff8
    return dbus_error_is_set();
}

// Address range: 0x805f098 - 0x805f09e
int32_t function_805f098(int32_t a1) {
    // 0x805f098
    return dbus_connection_flush();
}

// Address range: 0x805f2b8 - 0x805f2be
int32_t function_805f2b8(int32_t a1, char * a2, int32_t a3, int32_t * a4) {
    // 0x805f2b8
    return dbus_bus_request_name();
}

// Address range: 0x805f448 - 0x805f44e
int32_t function_805f448(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x805f448
    return dbus_connection_set_dispatch_status_function();
}

// Address range: 0x805fc48 - 0x805fc4e
int32_t function_805fc48(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x805fc48
    return dbus_connection_set_watch_functions();
}

// Address range: 0x805fcf8 - 0x805fcfe
int32_t function_805fcf8(int32_t a1, char * a2, int32_t * a3, int32_t a4) {
    // 0x805fcf8
    return dbus_connection_register_object_path();
}

// Address range: 0x80600e8 - 0x80600ee
int32_t function_80600e8(int32_t a1) {
    // 0x80600e8
    return dbus_connection_close();
}

// Address range: 0x8060118 - 0x806011e
int32_t function_8060118(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x8060118
    return dbus_connection_set_timeout_functions();
}

// Address range: 0x8060718 - 0x806071e
int32_t function_8060718(int32_t * a1) {
    // 0x8060718
    return dbus_error_free();
}

// Address range: 0x80607f8 - 0x80607fe
int32_t function_80607f8(int32_t a1, char * a2, int32_t * a3, float80_t a4) {
    // 0x80607f8
    return sscanf2();
}

// Address range: 0x8060908 - 0x806090e
int32_t function_8060908(int32_t a1, char * a2) {
    // 0x8060908
    return dbus_connection_unregister_object_path();
}

// Address range: 0x8060d88 - 0x8060d8e
int32_t function_8060d88(float80_t a1) {
    // 0x8060d88
    return sincos();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/action.c
// Address range: 0x8067930 - 0x806794c
// Line range:    6974 - 6974
void register_action_action_list(void) {
    // 0x8067930
    hid_register_actions((int32_t)&action_action_list, 58);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/action.c
// Address range: 0x8067c50 - 0x8067d3f
// Line range:    811 - 852
void AdjustAttachedObjects(void) {
    // 0x8067c50
    if (g141 == 4) {
        // 0x8067cd2
        AdjustAttachedLine();
        return;
    }
    if (g141 > 4) {
        switch (g141) {
            case 109: {
                // 0x8067d30
                g211 = &hid_nogui;
                return;
            }
            case 110: {
                goto lab_0x8067c9a;
            }
            case 106: {
                int32_t v1 = AdjustInsertPoint(); // 0x8067ce8
                if (v1 == 0) {
                    // 0x8067c77
                    return;
                }
                // 0x8067cf2
                InsertedPoint = *(int32_t *)v1;
                g46 = *(int32_t *)(v1 + 4);
                g47 = *(int32_t *)(v1 + 8);
                g48 = *(int32_t *)(v1 + 12);
                g49 = *(int32_t *)(v1 + 16);
                return;
            }
            default: {
                return;
            }
        }
    } else {
        if (g141 == 2) {
            // 0x8067cc0
            if (*(char *)(PCB + 40) != 0) {
                // 0x8067cd2
                AdjustAttachedLine();
                return;
            }
            int32_t v2 = *(int32_t *)(PCB + 108); // 0x8067ccb
            if (v2 != 0) {
                // 0x8067d20
                AdjustTwoLine(v2 - 1);
                return;
            }
            // 0x8067cd2
            AdjustAttachedLine();
            return;
        }
        if (g141 > 2) {
            // 0x8067cdd
            if (g210 != 1) {
                // 0x8067c77
                return;
            }
            // 0x8067ca4
            g208 = (char *)g193;
            g209 = g194;
            return;
        }
        if (g141 != 0) {
            // 0x8067c77
            return;
        }
        goto lab_0x8067c9a;
    }
  lab_0x8067c9a:
    // 0x8067c9a
    if (g210 == 0) {
        // 0x8067c77
        return;
    }
    // 0x8067ca4
    g208 = (char *)g193;
    g209 = g194;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/buffer.c
// Address range: 0x8075460 - 0x807547c
// Line range:    1375 - 1375
void register_rotate_action_list(void) {
    // 0x8075460
    hid_register_actions((int32_t)&rotate_action_list, 1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/buffer.c
// Address range: 0x8076d00 - 0x8076d3a
// Line range:    1138 - 1144
void InitBuffers(void) {
    // 0x8076d00
    g181 = CreateNewBuffer();
    g182 = CreateNewBuffer();
    g183 = CreateNewBuffer();
    g184 = CreateNewBuffer();
    g185 = CreateNewBuffer();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/buffer.c
// Address range: 0x8077820 - 0x8077856
// Line range:    493 - 499
void SetBufferBoundingBox(int32_t Buffer) {
    int32_t v1 = GetDataBoundingBox(*(int32_t *)(Buffer + 24)); // 0x8077830
    if (v1 != 0) {
        // 0x8077839
        *(int32_t *)(Buffer + 8) = *(int32_t *)v1;
        *(int32_t *)(Buffer + 12) = *(int32_t *)(v1 + 4);
        *(int32_t *)(Buffer + 16) = *(int32_t *)(v1 + 8);
        *(int32_t *)(Buffer + 20) = *(int32_t *)(v1 + 12);
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/change.c
// Address range: 0x8079900 - 0x80799b4
// Line range:    2263 - 2272
void ChangePCBSize(int32_t Width, int32_t Height) {
    // 0x8079900
    *(int32_t *)(PCB + 144) = Width;
    *(int32_t *)(PCB + 148) = Height;
    if (g141 == 5) {
        int32_t v1 = 28 * (int32_t)g142; // 0x8079968
        int32_t v2 = *(int32_t *)(v1 + (int32_t)&Buffers); // 0x8079975
        int32_t v3 = *(int32_t *)(v1 + (int32_t)&Buffers + 4); // 0x807997b
        int32_t v4 = v3 - *(int32_t *)(v1 + (int32_t)&Buffers + 20) + Height; // 0x8079988
        int32_t v5 = v2 - *(int32_t *)(v1 + (int32_t)&Buffers + 16) + Width; // 0x8079997
        int32_t v6 = *(int32_t *)(v1 + (int32_t)&Buffers + 12); // 0x80799a0
        int32_t v7 = *(int32_t *)(v1 + (int32_t)&Buffers + 8); // 0x80799a7
        SetCrosshairRange(v2 - v7, v3 - v6, v5 > 0 ? v5 : 0, v4 > 0 ? v4 : 0);
    } else {
        // 0x8079930
        SetCrosshairRange(0, 0, Width, Height);
    }
    // 0x807994c
    hid_action("PCBChanged");
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/command.c
// Address range: 0x807db80 - 0x807db9c
// Line range:    417 - 417
void register_command_action_list(void) {
    // 0x807db80
    hid_register_actions((int32_t)&command_action_list, 10);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807ea50 - 0x807eb76
// Line range:    93 - 120
void pcb_colors_from_settings(int32_t ptr) {
    // 0x807ea50
    *(int32_t *)(ptr + 88) = g120;
    *(int32_t *)(ptr + 64) = g114;
    *(int32_t *)(ptr + 68) = g115;
    *(int32_t *)(ptr + 72) = g116;
    *(int32_t *)(ptr + 76) = g117;
    *(int32_t *)(ptr + 80) = g118;
    *(int32_t *)(ptr + 84) = g119;
    *(int32_t *)(ptr + 52) = g111;
    *(int32_t *)(ptr + 56) = g112;
    *(int32_t *)(ptr + 60) = g113;
    *(int32_t *)(ptr + 44) = g109;
    *(int32_t *)(ptr + 48) = g110;
    *(int32_t *)(ptr + 92) = g125;
    *(int32_t *)(ptr + 96) = g126;
    int32_t v1 = *(int32_t *)(ptr + 0x220c); // 0x807eadd
    int32_t v2 = v1 + 148;
    int32_t v3 = v1 + 152;
    int32_t v4 = 0; // 0x807eae7
    int32_t v5 = 0; // 0x807eae7
    int32_t v6 = 4 * v4; // 0x807eae8
    int32_t v7 = *(int32_t *)(v6 + (int32_t)&g122); // 0x807eae8
    *(int32_t *)(v5 + v2) = v7;
    int32_t v8 = *(int32_t *)(v6 + (int32_t)&g124); // 0x807eaf6
    v4++;
    *(int32_t *)(v5 + v3) = v8;
    v5 += 92;
    while (v4 != 16) {
        // 0x807eae8
        v6 = 4 * v4;
        v7 = *(int32_t *)(v6 + (int32_t)&g122);
        *(int32_t *)(v5 + v2) = v7;
        v8 = *(int32_t *)(v6 + (int32_t)&g124);
        v4++;
        *(int32_t *)(v5 + v3) = v8;
        v5 += 92;
    }
    int32_t * v9 = (int32_t *)(*(int32_t *)(PCB + 0x220c) + 24); // 0x807eb1a
    int32_t v10 = 92 * *v9;
    int32_t v11 = v10 + v1;
    int32_t * v12 = (int32_t *)(v11 + 240);
    int32_t v13; // 0x807ea50
    if (g170 == 0) {
        // 0x807eb60
        *v12 = g114;
        *(int32_t *)(v11 + 244) = g118;
        v13 = g116;
    } else {
        // 0x807eb2c
        *v12 = g116;
        *(int32_t *)(v11 + 244) = g118;
        v13 = g114;
    }
    // 0x807eb40
    *(int32_t *)(v10 + v2) = v13;
    *(int32_t *)(92 * *v9 + v3) = g118;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807eb80 - 0x807ec19
// Line range:    981 - 986
int32_t CreateNewAttribute(int32_t list, char * name, char * value) {
    int32_t * v1 = (int32_t *)list; // 0x807eb92
    int32_t v2 = *v1; // 0x807eb92
    int32_t * v3 = (int32_t *)(list + 4); // 0x807eb94
    int32_t v4 = *v3; // 0x807eb94
    char * v5; // 0x807eb80
    int32_t * v6; // 0x807eb80
    int32_t v7; // 0x807eb80
    int32_t v8; // 0x807eb80
    if (v2 < v4) {
        int32_t * v9 = (int32_t *)(list + 8);
        v6 = v9;
        v5 = name;
        v8 = v2;
        v7 = *v9;
    } else {
        int32_t v10 = v4 + 10; // 0x807ebf0
        *v3 = v10;
        int32_t * v11 = (int32_t *)(list + 8);
        int32_t v12 = (int32_t)MyRealloc((char *)*v11, 8 * v10, "CreateNewAttribute"); // 0x807ec0b
        *v11 = v12;
        v6 = v11;
        v5 = name;
        v8 = *v1;
        v7 = v12;
    }
    char * v13 = MyStrdup(v5, "CreateNewAttribute"); // 0x807ebac
    *(int32_t *)(v7 + 8 * v8) = (int32_t)v13;
    char * v14 = MyStrdup(value, "CreateNewAttribute"); // 0x807ebca
    *(int32_t *)((8 * *v1 | 4) + *v6) = (int32_t)v14;
    int32_t v15 = *v1; // 0x807ebd2
    *v1 = v15 + 1;
    return *v6 + 8 * v15;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807ec20 - 0x807ec51
// Line range:    969 - 975
int32_t CreateNewConnection(int32_t net, char * conn) {
    int32_t result = GetLibraryEntryMemory(net); // 0x807ec2d
    *(int32_t *)result = (int32_t)MyStrdup(conn, "CreateNewConnection()");
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807ec60 - 0x807ed30
// Line range:    949 - 963
int32_t CreateNewNet(int32_t lib, char * name, char * style) {
    int32_t v1 = __readgsdword(20); // 0x807ec69
    int32_t v2; // bp-96, 0x807ec60
    __sprintf_chk((char *)&v2, 1, 64, "  %s", name);
    int32_t result = GetLibraryMenuMemory(lib); // 0x807ecb3
    char * v3 = MyStrdup((char *)&v2, "CreateNewNet()"); // 0x807ecc5
    *(char *)(result + 24) = 1;
    *(int32_t *)result = (int32_t)v3;
    if (style != NULL) {
        // 0x807ecd7
        bool v4; // 0x807ec60
        int32_t v5 = v4 ? -1 : 1; // 0x807ece3
        int32_t v6 = (int32_t)style; // 0x807ec60
        int32_t v7 = (int32_t)"(unknown)"; // 0x807ec60
        int32_t v8 = 10; // 0x807ece3
        while (*(char *)v7 == *(char *)v6) {
            v8--;
            v6 += v5;
            v7 += v5;
            if (v8 == 0) {
                // 0x807ed18
                *(int32_t *)(result + 8) = 0;
                goto lab_0x807ecfa;
            }
        }
    }
    // 0x807ece7
    *(int32_t *)(result + 8) = (int32_t)MyStrdup(style, "CreateNewNet()");
    goto lab_0x807ecfa;
  lab_0x807ecfa:
    // 0x807ecfa
    if (v1 == __readgsdword(20)) {
        // 0x807ed08
        return result;
    }
    // 0x807ed21
    __stack_chk_fail();
    return &g231;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807ed60 - 0x807ed9f
// Line range:    920 - 924
void CreateDefaultFont(void) {
    // 0x807ed60
    if (ParseFont(PCB + 184, g150) == 0) {
        // 0x807ed85
        return;
    }
    // 0x807ed88
    Message("Can't find font-symbol-file '%s'\n", g150);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807eda0 - 0x807ee94
// Line range:    888 - 86
int32_t CreateNewLineInSymbol(int32_t Symbol2, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Thickness) {
    int32_t * v1 = (int32_t *)(Symbol2 + 8); // 0x807edb2
    uint32_t v2 = *v1; // 0x807edb2
    int32_t * v3 = (int32_t *)(Symbol2 + 12); // 0x807edb5
    uint32_t v4 = *v3; // 0x807edb5
    int32_t * v5 = (int32_t *)Symbol2; // 0x807edb8
    int32_t v6 = *v5; // 0x807edb8
    int32_t v7 = v2; // 0x807edbc
    int32_t v8 = v6; // 0x807edbc
    int32_t v9; // 0x807eda0
    int32_t v10; // 0x807ee15
    if (v2 >= v4) {
        int32_t v11 = v4 + 10; // 0x807edf8
        *v3 = v11;
        v10 = (int32_t)MyRealloc((char *)v6, 88 * v11, "CreateNewLineInSymbol()");
        int32_t v12 = 88 * *v1 + v10; // 0x807ee1e
        *v5 = v10;
        int32_t v13 = 880; // 0x807ee2b
        int32_t v14 = v12; // 0x807ee2b
        if (v12 % 2 != 0) {
            // 0x807ee88
            *(char *)v12 = 0;
            v13 = 879;
            v14 = v12 + 1;
        }
        int32_t v15 = v13; // 0x807ee33
        int32_t v16 = v14; // 0x807ee33
        if ((v14 & 2) != 0) {
            // 0x807ee78
            *(int16_t *)v14 = 0;
            v15 = v13 - 2;
            v16 = v14 + 2;
        }
        uint32_t v17 = v15 / 4; // 0x807ee39
        __asm_rep_stosd_memset((char *)v16, 0, v17);
        bool v18; // 0x807eda0
        int32_t v19 = v17 * (v18 ? -4 : 4) + v16; // 0x807ee42
        if ((v15 & 2) != 0) {
            // 0x807ee68
            *(int16_t *)v19 = 0;
            v9 = v19 + 2;
            if (v15 % 2 == 0) {
                goto lab_0x807ee4b;
            } else {
                goto lab_0x807ee58;
            }
        } else {
            // 0x807ee46
            v9 = v19;
            if (v15 % 2 != 0) {
                goto lab_0x807ee58;
            } else {
                goto lab_0x807ee4b;
            }
        }
    } else {
        goto lab_0x807edbe;
    }
  lab_0x807edbe:
    // 0x807edbe
    *v1 = v7 + 1;
    int32_t result = v8 + 88 * v7; // 0x807edc7
    *(int32_t *)(result + 44) = X1;
    *(int32_t *)(result + 48) = Y1;
    *(int32_t *)(result + 64) = X2;
    *(int32_t *)(result + 68) = Y2;
    *(int32_t *)(result + 36) = Thickness;
    return result;
  lab_0x807ee4b:
    // 0x807ee4b
    v7 = *v1;
    v8 = v10;
    goto lab_0x807edbe;
  lab_0x807ee58:
    // 0x807ee58
    *(char *)v9 = 0;
    v7 = *v1;
    v8 = v10;
    goto lab_0x807edbe;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807eea0 - 0x807f042
// Line range:    671 - 86
int32_t CreateNewArcInElement(int32_t Element, int32_t X, int32_t Y, int32_t Width, int32_t Height, int32_t Angle, int32_t Delta, int32_t Thickness) {
    int32_t * v1 = (int32_t *)(Element + 268); // 0x807eeac
    int32_t * v2 = (int32_t *)(Element + 248); // 0x807eeb2
    uint32_t v3 = *v2; // 0x807eeb2
    char * v4 = (char *)*v1; // bp-32, 0x807eeb8
    int32_t * v5 = (int32_t *)(Element + 252); // 0x807eebb
    uint32_t v6 = *v5; // 0x807eebb
    int32_t v7 = v3; // 0x807eec3
    int32_t v8; // 0x807eea0
    if (v3 >= v6) {
        int32_t v9 = v6 + 5; // 0x807ef90
        *v5 = v9;
        char * v10 = MyRealloc(v4, 68 * v9, "CreateNewArcInElement()"); // 0x807efb3
        int32_t v11 = (int32_t)v10; // 0x807efb3
        v4 = v10;
        *v1 = v11;
        int32_t v12 = 68 * *v2 + v11; // 0x807efd4
        int32_t v13 = 340; // 0x807efdd
        int32_t v14 = v12; // 0x807efdd
        if (v12 % 2 != 0) {
            // 0x807f038
            *(char *)v12 = 0;
            v13 = 339;
            v14 = v12 + 1;
        }
        int32_t v15 = v13; // 0x807efe5
        int32_t v16 = v14; // 0x807efe5
        if ((v14 & 2) != 0) {
            // 0x807f028
            *(int16_t *)v14 = 0;
            v15 = v13 - 2;
            v16 = v14 + 2;
        }
        uint32_t v17 = v15 / 4; // 0x807efeb
        __asm_rep_stosd_memset((char *)v16, 0, v17);
        bool v18; // 0x807eea0
        int32_t v19 = v17 * (v18 ? -4 : 4) + v16; // 0x807eff1
        if ((v15 & 2) != 0) {
            // 0x807f018
            *(int16_t *)v19 = 0;
            v8 = v19 + 2;
            if (v15 % 2 == 0) {
                // 0x807effa
                v7 = *v2;
                goto lab_0x807eec9;
            } else {
                goto lab_0x807f008;
            }
        } else {
            // 0x807eff5
            v8 = v19;
            if (v15 % 2 != 0) {
                goto lab_0x807f008;
            } else {
                // 0x807effa
                v7 = *v2;
                goto lab_0x807eec9;
            }
        }
    } else {
        goto lab_0x807eec9;
    }
  lab_0x807eec9:;
    int32_t v20 = -360 * Delta / 94 + Delta; // 0x807eeed
    int32_t v21; // 0x807eea0
    int32_t v22; // 0x807eea0
    if (v20 != 0) {
        // 0x807ef80
        v22 = Angle;
        v21 = v20;
        if (v20 < 0) {
            // 0x807ef86
            v22 = v20 + Angle;
            v21 = -v20;
        }
    } else {
        // 0x807eefa
        v22 = Angle;
        v21 = v20 & -0x10000 | 360;
    }
    int32_t v23 = v22;
    int32_t v24 = -360 * ((v23 + (int32_t)(-0x49f49f49 * (int64_t)v23 / 0x100000000)) / 256 - (v23 >> 31)) + v23; // 0x807ef1f
    *v2 = v7 + 1;
    int32_t result = 68 * v7 + (int32_t)v4; // 0x807ef3f
    *(int32_t *)(result + 52) = X;
    *(int32_t *)(result + 60) = v24 >= 0 ? v24 : v24 + 360;
    *(int32_t *)(result + 64) = v21;
    *(int32_t *)(result + 56) = Y;
    *(int32_t *)(result + 44) = Width;
    *(int32_t *)(result + 36) = Thickness;
    *(int32_t *)(result + 48) = Height;
    *(int32_t *)(result + 16) = ID;
    ID++;
    return result;
  lab_0x807f008:
    // 0x807f008
    *(char *)v8 = 0;
    v7 = *v2;
    goto lab_0x807eec9;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807f050 - 0x807f183
// Line range:    827 - 859
int32_t CreateNewPad(int32_t Element, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Thickness, int32_t Clearance, int32_t Mask, char * Name, char * Number, int32_t Flags) {
    int32_t result = GetPadMemory(Element); // 0x807f097
    if (X1 > X2) {
        goto lab_0x807f0d0;
    } else {
        if (Y1 <= Y2 || X1 != X2) {
            // 0x807f0ae
            *(int32_t *)(result + 44) = X1;
            *(int32_t *)(result + 48) = Y1;
            *(int32_t *)(result + 64) = X2;
            *(int32_t *)(result + 68) = Y2;
            goto lab_0x807f0e8;
        } else {
            goto lab_0x807f0d0;
        }
    }
  lab_0x807f0d0:
    // 0x807f0d0
    *(int32_t *)(result + 44) = X2;
    *(int32_t *)(result + 48) = Y2;
    *(int32_t *)(result + 64) = X1;
    *(int32_t *)(result + 68) = Y1;
    goto lab_0x807f0e8;
  lab_0x807f0e8:
    // 0x807f0e8
    *(int32_t *)(result + 36) = Thickness;
    *(int32_t *)(result + 40) = Clearance;
    *(int32_t *)(result + 84) = Mask;
    *(int32_t *)(result + 88) = (int32_t)MyStrdup(Name, "CreateNewPad()");
    *(int32_t *)(result + 92) = (int32_t)MyStrdup(Number, "CreateNewPad()");
    *(int32_t *)(result + 20) = Flags & -513;
    *(int32_t *)(result + 16) = ID;
    ID++;
    *(int32_t *)(result + 96) = Element;
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807f190 - 0x807f46e
// Line range:    751 - 821
int32_t CreateNewPin(int32_t Element, int32_t X, int32_t Y, int32_t Thickness, int32_t Clearance, int32_t Mask, int32_t DrillingHole, char * Name, char * Number, int32_t Flags) {
    int32_t result = GetPinMemory(Element); // 0x807f1e0
    *(int32_t *)(result + 52) = X;
    *(int32_t *)(result + 56) = Y;
    int32_t * v1 = (int32_t *)(result + 36); // 0x807f1f6
    *v1 = Thickness;
    *(int32_t *)(result + 40) = Clearance;
    *(int32_t *)(result + 44) = Mask;
    *(int32_t *)(result + 60) = (int32_t)MyStrdup(Name, "CreateNewPin()");
    char * v2 = MyStrdup(Number, "CreateNewPin()"); // 0x807f229
    *(int32_t *)(result + 68) = Element;
    *(int32_t *)(result + 64) = (int32_t)v2;
    int32_t v3 = result + 20; // 0x807f275
    *(int32_t *)v3 = Flags & -514 | 1;
    *(int32_t *)(result + 16) = ID;
    ID++;
    int32_t v4 = vendorDrillMap(DrillingHole); // 0x807f28b
    int32_t * v5 = (int32_t *)(result + 48); // 0x807f290
    *v5 = v4;
    if (vendorIsElementMappable(Element) == 0) {
        // 0x807f310
        *v5 = DrillingHole;
        // 0x807f313
        return result;
    }
    int32_t v6 = (int32_t)Number;
    int32_t v7 = (int32_t)Name;
    int32_t v8 = *v5; // 0x807f29f
    int32_t v9; // 0x807f190
    int32_t v10; // 0x807f190
    int32_t v11; // 0x807f190
    if (v8 > 1999) {
        if (v8 < 0x989681) {
            // 0x807f390
            if ((*(char *)v3 & 8) != 0) {
                goto lab_0x807f430;
            } else {
                // 0x807f39a
                if (v8 < *v1 - 399) {
                    goto lab_0x807f430;
                } else {
                    if (Name == NULL) {
                        // 0x807f3ba
                        v11 = (int32_t)"(unknown)";
                        goto lab_0x807f3c1;
                    } else {
                        // 0x807f3b2
                        v11 = v7;
                        if (*Name != 0) {
                            goto lab_0x807f3c1;
                        } else {
                            // 0x807f3ba
                            v11 = (int32_t)"(unknown)";
                            goto lab_0x807f3c1;
                        }
                    }
                }
            }
        } else {
            if (Name == NULL) {
                // 0x807f336
                v10 = (int32_t)"(unknown)";
                goto lab_0x807f33d;
            } else {
                // 0x807f32e
                v10 = v7;
                if (*Name != 0) {
                    goto lab_0x807f33d;
                } else {
                    // 0x807f336
                    v10 = (int32_t)"(unknown)";
                    goto lab_0x807f33d;
                }
            }
        }
    } else {
        if (Name == NULL) {
            // 0x807f420
            v9 = (int32_t)"(unknown)";
            goto lab_0x807f2c0;
        } else {
            // 0x807f2b4
            v9 = v7;
            if (*Name == 0) {
                // 0x807f420
                v9 = (int32_t)"(unknown)";
                goto lab_0x807f2c0;
            } else {
                goto lab_0x807f2c0;
            }
        }
    }
  lab_0x807f430:
    if (v8 != DrillingHole) {
        // 0x807f438
        Message("Mapped pin drill hole to %.2f mils from %.2f mils per vendor table\n", (float64_t)(0.01L * (float80_t)v8), (float64_t)(0.01L * (float80_t)DrillingHole));
        return result;
    }
    // 0x807f313
    return result;
  lab_0x807f2c0:
    // 0x807f2c0
    if (Number != NULL) {
        // 0x807f2cb
        if (*Number != 0) {
            // 0x807f2d7
            Message("Did not map pin #%s (%s) drill hole because %6.2f mil is below the minimum allowed size\n", (char *)v6, (char *)v9, (float64_t)(0.01L * (float80_t)v8));
            *v5 = DrillingHole;
            return result;
        }
    }
    // 0x807f2d7
    Message("Did not map pin #%s (%s) drill hole because %6.2f mil is below the minimum allowed size\n", (char *)(int32_t)"(unknown)", (char *)v9, (float64_t)(0.01L * (float80_t)v8));
    *v5 = DrillingHole;
    return result;
  lab_0x807f33d:
    // 0x807f33d
    if (Number != NULL) {
        // 0x807f344
        if (*Number != 0) {
            // 0x807f353
            Message("Did not map pin #%s (%s) drill hole because %6.2f mil is above the maximum allowed size\n", (char *)v6, (char *)v10, (float64_t)(0.01L * (float80_t)v8));
            *v5 = DrillingHole;
            return result;
        }
    }
    // 0x807f353
    Message("Did not map pin #%s (%s) drill hole because %6.2f mil is above the maximum allowed size\n", (char *)(int32_t)"(unknown)", (char *)v10, (float64_t)(0.01L * (float80_t)v8));
    *v5 = DrillingHole;
    return result;
  lab_0x807f3c1:
    // 0x807f3c1
    if (Number != NULL) {
        // 0x807f3c8
        if (*Number != 0) {
            // 0x807f3d7
            Message("Did not map pin #%s (%s) drill hole because %6.2f mil does not leave enough copper\n", (char *)v6, (char *)v11, (float64_t)(0.01L * (float80_t)v8));
            *v5 = DrillingHole;
            // 0x807f313
            return result;
        }
    }
    // 0x807f3d7
    Message("Did not map pin #%s (%s) drill hole because %6.2f mil does not leave enough copper\n", (char *)(int32_t)"(unknown)", (char *)v11, (float64_t)(0.01L * (float80_t)v8));
    *v5 = DrillingHole;
    // 0x807f313
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807f470 - 0x807f5ae
// Line range:    716 - 86
int32_t CreateNewLineInElement(int32_t Element, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Thickness) {
    int32_t * v1 = (int32_t *)(Element + 264); // 0x807f489
    int32_t v2 = *v1; // 0x807f489
    if (Thickness == 0) {
        // 0x807f503
        return 0;
    }
    int32_t * v3 = (int32_t *)(Element + 240); // 0x807f491
    uint32_t v4 = *v3; // 0x807f491
    int32_t * v5 = (int32_t *)(Element + 244); // 0x807f497
    uint32_t v6 = *v5; // 0x807f497
    int32_t v7 = v4; // 0x807f49f
    int32_t v8 = v2; // 0x807f49f
    if (v4 >= v6) {
        int32_t v9 = v6 + 10; // 0x807f518
        *v5 = v9;
        v8 = (int32_t)MyRealloc((char *)v2, 88 * v9, "CreateNewLineInElement()");
        int32_t v10 = 88 * *v3 + v8; // 0x807f546
        *v1 = v8;
        char v11 = 112; // 0x807f557
        int32_t v12 = v10; // 0x807f557
        if (v10 % 2 != 0) {
            // 0x807f590
            *(char *)v10 = 0;
            v11 = 111;
            v12 = v10 + 1;
        }
        char v13 = v11; // 0x807f55f
        int32_t v14 = v12; // 0x807f55f
        if ((v12 & 2) != 0) {
            // 0x807f5a0
            *(int16_t *)v12 = 0;
            v13 = v11 - 2;
            v14 = v12 + 2;
        }
        uint32_t v15 = (int32_t)v13 / 4; // 0x807f566
        __asm_rep_stosd_memset((char *)v14, 0, v15);
        bool v16; // 0x807f470
        int32_t v17 = v15 * (v16 ? -4 : 4) + v14; // 0x807f569
        int32_t v18 = v17; // 0x807f56f
        if ((v13 & 2) != 0) {
            // 0x807f571
            *(int16_t *)v17 = 0;
            v18 = v17 + 2;
        }
        if (v13 % 2 != 0) {
            // 0x807f57f
            *(char *)v18 = 0;
        }
        // 0x807f582
        v7 = *v3;
    }
    // 0x807f4a1
    *v3 = v7 + 1;
    int32_t result = v8 + 88 * v7; // 0x807f4b0
    *(int32_t *)(result + 44) = X1;
    *(int32_t *)(result + 48) = Y1;
    *(int32_t *)(result + 64) = X2;
    *(int32_t *)(result + 36) = Thickness;
    *(int32_t *)(result + 68) = Y2;
    int32_t v19; // bp-44, 0x807f470
    MakeFlags((int32_t)&v19);
    *(int32_t *)(result + 20) = v19;
    *(int32_t *)(result + 16) = ID;
    ID++;
    // 0x807f503
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807f5b0 - 0x807f6ba
// Line range:    866 - 876
void AddTextToElement(int32_t Text, int32_t PCBFont, int32_t X, int32_t Y, char Direction, char * TextString, int32_t Scale, int32_t Flags) {
    // 0x807f5b0
    int32_t v1; // 0x807f5b0
    int32_t * v2 = (int32_t *)(v1 + 52); // 0x807f602
    SaveFree((char *)*v2);
    *v2 = 0;
    *(char *)(v1 + 48) = (char)PCBFont;
    *(int32_t *)(v1 + 44) = Text;
    *(char *)(v1 + 26) = (char)Flags;
    *(char *)(v1 + 25) = (char)Scale;
    *(char *)(v1 + 24) = (char)(int32_t)TextString;
    *(int32_t *)(v1 + 20) = (int32_t)Direction;
    *(int32_t *)(v1 + 36) = Y;
    int32_t v3 = 0; // 0x807f66e
    if (X != 0) {
        char * v4 = (char *)X; // 0x807f670
        v3 = 0;
        if (*v4 != 0) {
            // 0x807f6a8
            v3 = (int32_t)MyStrdup(v4, "AddTextToElement()");
        }
    }
    // 0x807f677
    *v2 = v3;
    SetTextBoundingBox(v1, v1);
    *(int32_t *)(v1 + 16) = ID;
    ID++;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807f6c0 - 0x807f879
// Line range:    639 - 647
int32_t CreateNewElement(int32_t Data, int32_t Element, int32_t PCBFont, int32_t Flags, char * Description, char * NameOnPCB, char * Value, int32_t TextX, int32_t TextY, char Direction, int32_t TextScale, int32_t TextFlags, char uniqueName) {
    // 0x807f6c0
    int32_t v1; // 0x807f6c0
    int32_t v2 = v1;
    int32_t v3 = Element; // 0x807f71a
    if (Element == 0) {
        // 0x807f860
        v3 = GetElementMemory(Data);
    }
    // 0x807f720
    char v4; // 0x807f6c0
    int32_t v5 = v4; // 0x807f6d3
    int32_t result = v3;
    int32_t v6 = v2 < 10 == (9 - v2 & v2) < 0 ? v2 : 10; // 0x807f72b
    char * v7; // 0x807f6c0
    AddTextToElement(v1, v5, (int32_t)uniqueName, v6, v4, v7, v1, (int32_t)&g231);
    char * v8; // 0x807f6c0
    if (v4 != 0) {
        // 0x807f76c
        v8 = UniqueElementName(Data, v7);
    }
    // 0x807f781
    AddTextToElement(v1, v5, (int32_t)v8, v6, v4, v7, v1, (int32_t)&g231);
    AddTextToElement(v1, v5, v1, v6, v4, v7, v1, (int32_t)&g231);
    *(int32_t *)(result + 92) = result;
    *(int32_t *)(result + 152) = result;
    *(int32_t *)(result + 212) = result;
    *(char *)(result + 31) = (char)TextFlags;
    *(char *)(result + 30) = (char)TextScale;
    *(char *)(result + 29) = Direction;
    *(char *)(result + 28) = (char)TextY;
    *(char *)(result + 27) = (char)TextX;
    *(char *)(result + 26) = (char)(int32_t)Value;
    *(char *)(result + 25) = (char)(int32_t)NameOnPCB;
    *(char *)(result + 24) = (char)(int32_t)Description;
    *(int32_t *)(result + 20) = Flags;
    *(int32_t *)(result + 16) = ID;
    ID++;
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807f880 - 0x807f8b0
// Line range:    622 - 632
int32_t CreateNewPointInPolygon(int32_t Polygon2, int32_t X, int32_t Y) {
    int32_t result = GetPointMemoryInPolygon(Polygon2); // 0x807f88c
    *(int32_t *)result = X;
    *(int32_t *)(result + 4) = Y;
    *(int32_t *)(result + 16) = ID;
    ID++;
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807f8b0 - 0x807f969
// Line range:    605 - 616
int32_t CreateNewPolygon(int32_t Layer2, int32_t Flags) {
    int32_t result = GetPolygonMemory(Layer2); // 0x807f8fa
    *(int32_t *)(result + 44) = 0;
    *(int32_t *)(result + 48) = 0;
    *(int32_t *)(result + 20) = Flags;
    *(int32_t *)(result + 16) = ID;
    ID++;
    *(int32_t *)(result + 52) = 0;
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807f970 - 0x807faa1
// Line range:    574 - 596
int32_t CreateNewText(int32_t Layer2, int32_t PCBFont, int32_t X, int32_t Y, char Direction, int32_t Scale, char * TextString, int32_t Flags) {
    int32_t result = GetTextMemory(Layer2); // 0x807f9c0
    if (result == 0) {
        // 0x807fa74
        return result;
    }
    // 0x807f9cf
    *(int32_t *)(result + 40) = X;
    *(int32_t *)(result + 44) = Y;
    *(char *)(result + 48) = Direction;
    *(int32_t *)(result + 20) = Flags;
    *(int32_t *)(result + 36) = Scale;
    *(int32_t *)(result + 52) = (int32_t)MyStrdup(TextString, "CreateNewText()");
    SetTextBoundingBox(PCBFont, result);
    *(int32_t *)(result + 16) = ID;
    ID++;
    int32_t * v1 = (int32_t *)(Layer2 + 56); // 0x807fa59
    int32_t v2 = *v1; // 0x807fa59
    int32_t v3 = v2; // 0x807fa5e
    if (v2 == 0) {
        // 0x807fa80
        v3 = r_create_tree(0, 0, 0);
        *v1 = v3;
    }
    // 0x807fa60
    r_insert_entry(v3, result, 0);
    // 0x807fa74
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807fab0 - 0x807fb91
// Line range:    550 - 565
int32_t CreateNewPolygonFromRectangle(int32_t Layer2, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Flags) {
    int32_t result = CreateNewPolygon(Layer2, Flags); // 0x807fadd
    if (result == 0) {
        // 0x807fb5d
        return result;
    }
    // 0x807fae8
    CreateNewPointInPolygon(result, X1, Y1);
    CreateNewPointInPolygon(result, X2, Y1);
    CreateNewPointInPolygon(result, X2, Y2);
    CreateNewPointInPolygon(result, X1, Y2);
    SetPolygonBoundingBox(result);
    int32_t * v1 = (int32_t *)(Layer2 + 60); // 0x807fb42
    int32_t v2 = *v1; // 0x807fb42
    int32_t v3 = v2; // 0x807fb47
    if (v2 == 0) {
        // 0x807fb70
        v3 = r_create_tree(0, 0, 0);
        *v1 = v3;
    }
    // 0x807fb49
    r_insert_entry(v3, result, 0);
    // 0x807fb5d
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807fba0 - 0x807fd89
// Line range:    506 - 540
int32_t CreateNewArcOnLayer(int32_t Layer2, int32_t X1, int32_t Y1, int32_t width, int32_t height, int32_t sa, int32_t dir, int32_t Thickness, int32_t Clearance, int32_t Flags) {
    int32_t v1 = *(int32_t *)(Layer2 + 16); // 0x807fbed
    if (v1 != 0) {
        int32_t v2 = sa + 360; // 0x807fc0c
        int32_t v3 = -360 * ((v2 + (int32_t)(-0x49f49f49 * (int64_t)v2 / 0x100000000)) / 256 - (v2 >> 31)) + v2; // 0x807fc2b
        int32_t v4 = v1; // 0x807fc43
        int32_t v5 = 68 * v1 - 16 + *(int32_t *)(Layer2 + 48);
        int32_t v6; // 0x807fc67
        if (*(int32_t *)v5 == X1) {
            // 0x807fc57
            if (*(int32_t *)(v5 + 4) == Y1) {
                // 0x807fc5c
                if (*(int32_t *)(v5 - 8) == width) {
                    // 0x807fc64
                    v6 = *(int32_t *)(v5 + 8) + 360;
                    if (-360 * ((v6 + (int32_t)(-0x49f49f49 * (int64_t)v6 / 0x100000000)) / 256 - (v6 >> 31)) + v6 == v3) {
                        // 0x807fc95
                        if (*(int32_t *)(v5 + 12) == dir) {
                            // 0x807fd5b
                            return 0;
                        }
                    }
                }
            }
        }
        // 0x807fc48
        v4--;
        int32_t v7 = v5 - 68; // 0x807fc51
        while (v4 != 0) {
            // 0x807fc53
            v5 = v7;
            if (*(int32_t *)v5 == X1) {
                // 0x807fc57
                if (*(int32_t *)(v5 + 4) == Y1) {
                    // 0x807fc5c
                    if (*(int32_t *)(v5 - 8) == width) {
                        // 0x807fc64
                        v6 = *(int32_t *)(v5 + 8) + 360;
                        if (-360 * ((v6 + (int32_t)(-0x49f49f49 * (int64_t)v6 / 0x100000000)) / 256 - (v6 >> 31)) + v6 == v3) {
                            // 0x807fc95
                            if (*(int32_t *)(v5 + 12) == dir) {
                                // 0x807fd5b
                                return 0;
                            }
                        }
                    }
                }
            }
            // 0x807fc48
            v4--;
            v7 = v5 - 68;
        }
    }
    int32_t result = GetArcMemory(Layer2); // 0x807fcae
    if (result == 0) {
        // 0x807fd5b
        return 0;
    }
    // 0x807fcbd
    *(int32_t *)(result + 16) = ID;
    ID++;
    *(int32_t *)(result + 36) = Thickness;
    *(int32_t *)(result + 20) = Flags;
    *(int32_t *)(result + 52) = X1;
    *(int32_t *)(result + 56) = Y1;
    *(int32_t *)(result + 40) = Clearance;
    *(int32_t *)(result + 60) = sa;
    *(int32_t *)(result + 44) = width;
    *(int32_t *)(result + 48) = height;
    *(int32_t *)(result + 64) = dir;
    SetArcBoundingBox(result);
    int32_t * v8 = (int32_t *)(Layer2 + 64); // 0x807fd40
    int32_t v9 = *v8; // 0x807fd40
    int32_t v10 = v9; // 0x807fd45
    if (v9 == 0) {
        // 0x807fd65
        v10 = r_create_tree(0, 0, 0);
        *v8 = v10;
    }
    // 0x807fd47
    r_insert_entry(v10, result, 0);
    // 0x807fd5b
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807fd90 - 0x807fec1
// Line range:    474 - 497
int32_t CreateNewRat(int32_t Data, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t group1, int32_t group2, int32_t Thickness, int32_t Flags) {
    int32_t result = GetRatMemory(Data); // 0x807fdda
    if (result == 0) {
        // 0x807fe91
        return result;
    }
    // 0x807fde9
    *(int32_t *)(result + 16) = ID;
    *(int32_t *)(result + 60) = ID + 1;
    *(int32_t *)(result + 80) = ID + 2;
    *(int32_t *)(result + 20) = Flags | 16;
    *(int32_t *)(result + 36) = Thickness;
    *(int32_t *)(result + 44) = X1;
    *(int32_t *)(result + 48) = Y1;
    *(int32_t *)(result + 64) = X2;
    *(int32_t *)(result + 68) = Y2;
    ID += 3;
    *(int32_t *)(result + 84) = group1;
    *(int32_t *)(result + 88) = group2;
    SetLineBoundingBox(result);
    int32_t * v1 = (int32_t *)(Data + 68); // 0x807fe76
    int32_t v2 = *v1; // 0x807fe76
    int32_t v3 = v2; // 0x807fe7b
    if (v2 == 0) {
        // 0x807fea0
        v3 = r_create_tree(0, 0, 0);
        *v1 = v3;
    }
    // 0x807fe7d
    r_insert_entry(v3, result, 0);
    // 0x807fe91
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x807fed0 - 0x807fff9
// Line range:    441 - 465
int32_t CreateNewLineOnLayer(int32_t Layer2, int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, int32_t Thickness, int32_t Clearance, int32_t Flags) {
    int32_t result = GetLineMemory(Layer2); // 0x807ff1a
    if (result == 0) {
        // 0x807ffcb
        return result;
    }
    // 0x807ff29
    *(int32_t *)(result + 16) = ID;
    *(int32_t *)(result + 60) = ID + 1;
    *(int32_t *)(result + 80) = ID + 2;
    *(int32_t *)(result + 20) = Flags & -17;
    *(int32_t *)(result + 36) = Thickness;
    *(int32_t *)(result + 40) = Clearance;
    *(int32_t *)(result + 44) = X1;
    *(int32_t *)(result + 48) = Y1;
    *(int32_t *)(result + 64) = X2;
    *(int32_t *)(result + 68) = Y2;
    ID += 3;
    SetLineBoundingBox(result);
    int32_t * v1 = (int32_t *)(Layer2 + 52); // 0x807ffb0
    int32_t v2 = *v1; // 0x807ffb0
    int32_t v3 = v2; // 0x807ffb5
    if (v2 == 0) {
        // 0x807ffd8
        v3 = r_create_tree(0, 0, 0);
        *v1 = v3;
    }
    // 0x807ffb7
    r_insert_entry(v3, result, 0);
    // 0x807ffcb
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x8080400 - 0x80806ad
// Line range:    225 - 283
int32_t CreateNewVia(int32_t Data, uint32_t X, uint32_t Y, int32_t Thickness, int32_t Clearance, int32_t Mask, int32_t DrillingHole, char * Name, int32_t Flags) {
    uint32_t v1 = *(int32_t *)Data; // 0x8080447
    int3_t v2; // 0x8080400
    if (v1 != 0) {
        int32_t v3 = ((int32_t)(Thickness < 0) + Thickness) / 2; // 0x8080463
        int3_t v4 = v2 - 1; // 0x808048d
        int3_t v5 = v2 - 2;
        int3_t v6 = v2 - 3;
        int32_t v7 = *(int32_t *)(Data + 28); // 0x808046d
        int32_t v8 = 0; // 0x808046d
        uint32_t v9 = *(int32_t *)(v7 + 52); // 0x808047f
        uint32_t v10 = *(int32_t *)(v7 + 56); // 0x808048a
        __frontend_reg_store_fpr(v4, (float80_t)(v9 - X));
        int32_t v11 = *(int32_t *)(v7 + 36); // 0x8080498
        __frontend_reg_store_fpr(v5, (float80_t)(v10 - Y));
        __frontend_reg_store_fpr(v6, (float80_t)((v11 + (int32_t)(v11 < 0)) / 2 + v3));
        float80_t v12 = __frontend_reg_load_fpr(v6); // 0x80804b1
        __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v4));
        __frontend_reg_store_fpr(v4, v12);
        __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v6) * __frontend_reg_load_fpr(v6));
        float80_t v13 = __frontend_reg_load_fpr(v6); // 0x80804b5
        __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v5));
        __frontend_reg_store_fpr(v5, v13);
        __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v6) * __frontend_reg_load_fpr(v6));
        __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v6) + __frontend_reg_load_fpr(v5));
        float80_t v14 = __frontend_reg_load_fpr(v5); // 0x80804bb
        __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v4));
        __frontend_reg_store_fpr(v4, v14);
        __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v5) * __frontend_reg_load_fpr(v5));
        float80_t v15 = __frontend_reg_load_fpr(v5); // 0x80804bf
        float80_t v16 = __frontend_reg_load_fpr(v4); // 0x80804bf
        while (v15 <= v16) {
            // 0x808047f
            __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v4));
            if (v15 == v16) {
                // 0x80804c5
                Message("Dropping via at (%d, %d) because it would overlap with the viaat (%d, %d)\n", X / 100, Y / 100, v9 / 100, v10 / 100);
                return 0;
            }
            // 0x8080470
            v8++;
            v7 += 76;
            if (v1 <= v8) {
                goto lab_0x8080530;
            }
            v9 = *(int32_t *)(v7 + 52);
            v10 = *(int32_t *)(v7 + 56);
            __frontend_reg_store_fpr(v4, (float80_t)(v9 - X));
            v11 = *(int32_t *)(v7 + 36);
            __frontend_reg_store_fpr(v5, (float80_t)(v10 - Y));
            __frontend_reg_store_fpr(v6, (float80_t)((v11 + (int32_t)(v11 < 0)) / 2 + v3));
            v12 = __frontend_reg_load_fpr(v6);
            __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v4));
            __frontend_reg_store_fpr(v4, v12);
            __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v6) * __frontend_reg_load_fpr(v6));
            v13 = __frontend_reg_load_fpr(v6);
            __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v5));
            __frontend_reg_store_fpr(v5, v13);
            __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v6) * __frontend_reg_load_fpr(v6));
            __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v6) + __frontend_reg_load_fpr(v5));
            v14 = __frontend_reg_load_fpr(v5);
            __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v4));
            __frontend_reg_store_fpr(v4, v14);
            __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v5) * __frontend_reg_load_fpr(v5));
            v15 = __frontend_reg_load_fpr(v5);
            v16 = __frontend_reg_load_fpr(v4);
        }
        // 0x80804c5
        __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v4));
        // 0x80804c5
        Message("Dropping via at (%d, %d) because it would overlap with the viaat (%d, %d)\n", X / 100, Y / 100, v9 / 100, v10 / 100);
        return 0;
    }
  lab_0x8080530:;
    int32_t result = GetViaMemory(Data); // 0x8080536
    if (result == 0) {
        // 0x8080643
        return result;
    }
    int32_t * v17 = (int32_t *)(result + 52); // 0x808054b
    *v17 = X;
    int32_t * v18 = (int32_t *)(result + 56); // 0x8080551
    *v18 = Y;
    int32_t * v19 = (int32_t *)(result + 36); // 0x8080557
    *v19 = Thickness;
    *(int32_t *)(result + 40) = Clearance;
    *(int32_t *)(result + 44) = Mask;
    int32_t v20 = vendorDrillMap(DrillingHole); // 0x8080569
    int32_t * v21 = (int32_t *)(result + 48); // 0x8080571
    *v21 = v20;
    if (v20 != DrillingHole) {
        int3_t v22 = v2 - 1; // 0x8080576
        __frontend_reg_store_fpr(v22, (float80_t)DrillingHole);
        int3_t v23 = v2 - 2; // 0x8080579
        __frontend_reg_store_fpr(v23, 0.01L);
        __frontend_reg_store_fpr(v22, __frontend_reg_load_fpr(v22) * __frontend_reg_load_fpr(v23));
        float80_t v24 = __frontend_reg_load_fpr(v23); // 0x8080581
        __frontend_reg_store_fpr(v23, __frontend_reg_load_fpr(v22));
        __frontend_reg_store_fpr(v22, v24);
        __frontend_reg_load_fpr(v23);
        __frontend_reg_store_fpr(v23, (float80_t)v20);
        __frontend_reg_store_fpr(v22, __frontend_reg_load_fpr(v23) * __frontend_reg_load_fpr(v22));
        Message((char *)(int32_t)(float32_t)__frontend_reg_load_fpr(v22));
    }
    // 0x808059f
    *(int32_t *)(result + 60) = (int32_t)MyStrdup(Name, "CreateNewVia()");
    *(int32_t *)(result + 16) = ID;
    *(int32_t *)(result + 20) = Flags & -515 | 2;
    ID++;
    if ((Flags & 8) == 0) {
        int32_t v25 = *v21; // 0x808060f
        if (v25 + 399 >= *v19) {
            int3_t v26 = v2 - 1; // 0x808064d
            __frontend_reg_store_fpr(v26, (float80_t)*v18);
            int32_t v27 = v25 + 400; // 0x8080650
            int3_t v28 = v2 - 2; // 0x8080655
            __frontend_reg_store_fpr(v28, 0.01L);
            __frontend_reg_store_fpr(v26, __frontend_reg_load_fpr(v26) * __frontend_reg_load_fpr(v28));
            float80_t v29 = __frontend_reg_load_fpr(v28); // 0x808065d
            __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v26));
            __frontend_reg_store_fpr(v26, v29);
            *v19 = v27;
            __frontend_reg_load_fpr(v28);
            __frontend_reg_store_fpr(v28, (float80_t)*v17);
            __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v28) * __frontend_reg_load_fpr(v26));
            __frontend_reg_load_fpr(v28);
            __frontend_reg_store_fpr(v28, (float80_t)v27);
            __frontend_reg_store_fpr(v26, __frontend_reg_load_fpr(v28) * __frontend_reg_load_fpr(v26));
            Message((char *)(int32_t)(float32_t)__frontend_reg_load_fpr(v26));
        }
    }
    // 0x808061d
    SetPinBoundingBox(result);
    int32_t * v30 = (int32_t *)(Data + 40); // 0x8080628
    int32_t v31 = *v30; // 0x8080628
    int32_t v32 = v31; // 0x808062d
    if (v31 == 0) {
        int32_t v33 = r_create_tree(0, 0, 0); // 0x80806a0
        *v30 = v33;
        v32 = v33;
    }
    // 0x808062f
    r_insert_entry(v32, result, 0);
    // 0x8080643
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x80806b0 - 0x8080772
// Line range:    203 - 215
int32_t CreateNewPCBPost(int32_t pcb, int32_t use_defaults) {
    // 0x80806b0
    pcb_colors_from_settings(pcb);
    if (use_defaults == 0) {
        // 0x80806d3
        return 0;
    }
    int32_t result = 1; // 0x8080708
    if (ParseGroupString((char *)g151, pcb + 0x1cd4, 8) == 0) {
        int32_t * v1 = (int32_t *)(pcb + 0x220c); // 0x808070f
        int32_t v2 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24); // 0x808071b
        char * v3 = MyStrdup("silk", "CreateNewPCB()"); // 0x808072d
        int32_t v4 = *v1; // 0x8080732
        *(int32_t *)(*v1 + 168 + 92 * v2) = (int32_t)v3;
        int32_t v5 = *(int32_t *)(PCB + 0x220c); // 0x8080747
        char * v6 = MyStrdup("silk", "CreateNewPCB()"); // 0x808075f
        *(int32_t *)(v4 + 76 + 92 * *(int32_t *)(v5 + 24)) = (int32_t)v6;
        result = 0;
    }
    // 0x80806d3
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x8080780 - 0x80807ad
// Line range:    80 - 86
int32_t CreateNewBuffer(void) {
    int32_t result = (int32_t)MyCalloc(1, 1732, "CreateNewBuffer()"); // 0x808079d
    *(int32_t *)(result + 72) = PCB;
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/create.c
// Address range: 0x80807b0 - 0x80809f6
// Line range:    133 - 200
int32_t CreateNewPCB(char SetDefaultNames) {
    char * v1 = MyCalloc(1, 0x2210, "CreateNewPCB()"); // 0x80807d0
    int32_t result = (int32_t)v1; // 0x80807d0
    int32_t v2 = CreateNewBuffer(); // 0x80807d7
    *(int32_t *)(v2 + 72) = result;
    int32_t * v3 = (int32_t *)(result + 0x220c); // 0x80807e5
    *v3 = v2;
    int32_t * v4 = (int32_t *)(result + 4); // 0x80807eb
    int32_t v5 = *v4; // 0x80807eb
    *(char *)(result + 32) = 4;
    *(float64_t *)(result + 168) = 2.0e+8;
    int32_t v6 = v5 | 64; // 0x80807fa
    *(char *)(result + 39) = 0;
    *(char *)(result + 40) = 0;
    *v4 = v6;
    int32_t v7 = v6; // 0x808080f
    if (g177 != 0) {
        // 0x8080811
        v7 = v5 | 65;
        *v4 = v7;
    }
    // 0x8080817
    if (g172 != 0) {
        // 0x8080820
        *v4 = v7 | 256;
    }
    // 0x8080827
    *(int32_t *)(result + 108) = 1;
    if (g173 != 0) {
        // 0x8080837
        *v4 = *v4 | 16;
    }
    // 0x808083b
    if (g174 != 0) {
        // 0x8080844
        *v4 = *v4 | 512;
    }
    // 0x808084b
    if (g168 != 0) {
        // 0x8080854
        *v4 = *v4 | 1024;
    }
    // 0x808085b
    if (g169 != 0) {
        // 0x8080864
        *v4 = *v4 | 0x1000;
    }
    // 0x808086b
    if (g166 != 0) {
        // 0x8080874
        *v4 = *v4 | 2048;
    }
    // 0x808087b
    if (g167 != 0) {
        // 0x8080884
        *v4 = *v4 | 0x100000;
    }
    // 0x808088b
    if (g178 != 0) {
        // 0x8080894
        *v4 = *v4 | 0x8000;
    }
    // 0x808089b
    if (g179 != 0) {
        // 0x80808a4
        *v4 = *v4 | 0x10000;
    }
    // 0x80808ab
    if (g175 != 0) {
        // 0x80808b4
        *v4 = *v4 | 8;
    }
    // 0x80808b8
    if (g176 != 0) {
        // 0x80808c1
        *v4 = *v4 | 128;
    }
    // 0x80808c8
    __asm_rep_movsd_memcpy((char *)(result + 0x1cd4), (char *)&g165, 304);
    float80_t v8; // 0x80807b0
    *(float64_t *)(result + 152) = (float64_t)v8;
    int32_t v9 = 0; // 0x80808e8
    int32_t v10 = 0; // 0x80808e8
    int32_t v11 = *(int32_t *)(v9 + (int32_t)&g160); // 0x80808ea
    int32_t v12 = v9 + result;
    *(int32_t *)(v12 + 0x2194) = v11;
    int32_t v13 = *(int32_t *)(v9 + (int32_t)&g161); // 0x80808f7
    *(int32_t *)(v12 + 0x2198) = v13;
    int32_t v14 = *(int32_t *)(v9 + (int32_t)&g162); // 0x8080904
    *(int32_t *)(v12 + 0x219c) = v14;
    int32_t v15 = *(int32_t *)(v9 + (int32_t)&g163); // 0x8080911
    *(int32_t *)(v12 + 0x21a0) = v15;
    int32_t v16 = *(int32_t *)(v9 + (int32_t)&g164); // 0x808091e
    *(int32_t *)(v12 + 0x21a8) = v10;
    v10++;
    *(int32_t *)(v12 + 0x21a4) = v16;
    v9 += 24;
    while (v10 != 4) {
        // 0x80808ea
        v11 = *(int32_t *)(v9 + (int32_t)&g160);
        v12 = v9 + result;
        *(int32_t *)(v12 + 0x2194) = v11;
        v13 = *(int32_t *)(v9 + (int32_t)&g161);
        *(int32_t *)(v12 + 0x2198) = v13;
        v14 = *(int32_t *)(v9 + (int32_t)&g162);
        *(int32_t *)(v12 + 0x219c) = v14;
        v15 = *(int32_t *)(v9 + (int32_t)&g163);
        *(int32_t *)(v12 + 0x21a0) = v15;
        v16 = *(int32_t *)(v9 + (int32_t)&g164);
        *(int32_t *)(v12 + 0x21a8) = v10;
        v10++;
        *(int32_t *)(v12 + 0x21a4) = v16;
        v9 += 24;
    }
    // 0x808093d
    hid_action("RouteStylesChanged");
    *(int32_t *)(result + 144) = g132;
    *(float64_t *)(result + 160) = g140;
    *(int32_t *)(result + 148) = g133;
    *(float64_t *)(result + 176) = 0.5;
    *(int32_t *)v1 = ID;
    ID++;
    *(int32_t *)(result + 112) = g134;
    *(int32_t *)(result + 116) = g135;
    *(int32_t *)(result + 120) = g136;
    *(int32_t *)(result + 124) = g137;
    *(int32_t *)(result + 128) = g138;
    *(int32_t *)(result + 132) = g139;
    int32_t v17 = 0;
    int32_t v18 = *(int32_t *)(4 * v17 + (int32_t)&g144); // 0x80809c0
    char * v19 = MyStrdup((char *)v18, "CreateNewPCB()"); // 0x80809d8
    int32_t v20 = v17 + 1; // 0x80809e0
    *(int32_t *)(92 * v17 + 76 + *v3) = (int32_t)v19;
    while (v20 != 16) {
        // 0x80809c0
        v17 = v20;
        v18 = *(int32_t *)(4 * v17 + (int32_t)&g144);
        v19 = MyStrdup((char *)v18, "CreateNewPCB()");
        v20 = v17 + 1;
        *(int32_t *)(92 * v17 + 76 + *v3) = (int32_t)v19;
    }
    // 0x80809ec
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8080a00 - 0x8080abd
// Line range:    93 - 105
void XORPolygon(int32_t polygon, int32_t dx, int32_t dy) {
    // 0x8080a00
    return;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8080ac0 - 0x8080fe9
// Line range:    198 - 201
void XORDrawElement(int32_t Element, int32_t DX, int32_t DY) {
    // 0x8080ac0
    int32_t v1; // 0x8080ac0
    int32_t v2 = *(int32_t *)(v1 + 248); // 0x8080acf
    int32_t v3 = *(int32_t *)(v1 + 240);
    if ((v3 || v2) != 0) {
        // 0x8080aeb
        if (v3 != 0) {
            int32_t v4 = v3 - 1;
            int32_t v5 = v4; // 0x8080b57
            while (v4 != 0) {
                // 0x8080b08
                v4 = v5 - 1;
                v5 = v4;
            }
        }
        // 0x8080b66
        if (v2 != 0) {
            int32_t v6 = v2 - 1;
            int32_t v7 = v6; // 0x8080bdc
            while (v6 != 0) {
                // 0x8080b88
                v6 = v7 - 1;
                v7 = v6;
            }
        }
    }
    uint32_t v8 = *(int32_t *)(v1 + 232); // 0x8080c6e
    uint32_t v9 = 0; // 0x8080c88
    while (v8 != 0 && v9 < v8) {
        // 0x8080d90
        v9++;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8080ff0 - 0x808108e
// Line range:    1021 - 1034
void DrawMark(char ifvis) {
    // 0x8080ff0
    return;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8081090 - 0x808115b
// Line range:    1042 - 1066
void InitCrosshair(void) {
    // 0x8081090
    Crosshair = &hid_nogui;
    CrosshairStack[0] = 1;
    g199 = 0;
    g196 = 0;
    g195 = 0;
    CrosshairStackLocation = 1;
    g221 = 0;
    g197 = *(int32_t *)(PCB + 144);
    *(char *)&Marked = 0;
    g198 = *(int32_t *)(PCB + 148);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8081160 - 0x80818d1
// Line range:    782 - 953
void FitCrosshairIntoGrid(int32_t X, int32_t Y) {
    int32_t v1 = *(int32_t *)(PCB + 144); // 0x8081175
    int32_t v2 = *(int32_t *)(PCB + 148); // 0x808117b
    int32_t v3 = g195; // 0x8081184
    int32_t v4 = X - v3; // 0x808118c
    int32_t v5 = v4 < 0 == ((v4 ^ X) & (v3 ^ X)) < 0 ? X : v3; // 0x808118e
    int32_t v6 = g197; // 0x8081191
    int32_t v7 = v5 - v6; // 0x8081196
    int32_t v8 = v7 < 0 == ((v7 ^ v5) & (v5 ^ v6)) < 0 == (v7 != 0) ? v6 : v5; // 0x8081198
    int32_t v9 = g196; // 0x808119b
    g193 = v8;
    int32_t v10 = Y - v9; // 0x80811a6
    int32_t v11 = v10 < 0 == ((v10 ^ Y) & (v9 ^ Y)) < 0 ? Y : v9; // 0x80811a8
    int32_t v12 = g198; // 0x80811ab
    int32_t v13 = v11 - v12; // 0x80811b0
    int32_t v14 = v13 < 0 == ((v13 ^ v11) & (v11 ^ v12)) < 0 == (v13 != 0) ? v12 : v11; // 0x80811b2
    g194 = v14;
    int32_t v15; // 0x8081160
    char v16; // 0x8081160
    int32_t v17; // 0x8081160
    if (*(char *)(PCB + 40) != 0) {
        goto lab_0x8081418;
    } else {
        // 0x80811c5
        v15 = 0;
        v17 = PCB;
        v16 = 0;
        if ((*(char *)(PCB + 5) & 16) != 0) {
            goto lab_0x8081418;
        } else {
            goto lab_0x80811d3;
        }
    }
  lab_0x8081418:;
    // 0x8081418
    int32_t v18; // bp-32, 0x8081160
    int32_t v19; // bp-36, 0x8081160
    int32_t v20; // bp-40, 0x8081160
    int32_t v21 = SearchScreen(v8, v14, 768, (char **)&v18, (char **)&v19, (char **)&v20); // 0x808143c
    int32_t v22 = v21; // 0x8081443
    if (v21 != 0) {
        goto lab_0x80814d5;
    } else {
        char v23 = *(char *)(PCB + 40); // 0x808144f
        v15 = v21;
        v17 = PCB;
        v16 = v23;
        if (v23 != 0) {
            goto lab_0x80811d3;
        } else {
            int32_t v24 = SearchScreen(g193, g194, 0x1001, (char **)&v18, (char **)&v19, (char **)&v20); // 0x8081488
            v22 = v24;
            if (v24 != 0) {
                goto lab_0x80814d5;
            } else {
                char v25 = *(char *)(PCB + 40); // 0x8081497
                v15 = v24;
                v17 = PCB;
                v16 = v25;
                if (v25 != 0) {
                    goto lab_0x80811d3;
                } else {
                    int32_t v26 = SearchScreen(g193, g194, 2, (char **)&v18, (char **)&v19, (char **)&v20); // 0x80814d0
                    v22 = v26;
                    goto lab_0x80814d5;
                }
            }
        }
    }
  lab_0x80814d5:;
    int32_t v27 = (int32_t)*(char *)(PCB + 40); // 0x80814e4
    int32_t v28 = v22; // 0x80814e8
    int32_t v29 = g141; // 0x80814e8
    int32_t v30 = PCB; // 0x80814e8
    int32_t v31 = v27; // 0x80814e8
    int32_t v32 = v22; // 0x80814e8
    int32_t v33 = g141; // 0x80814e8
    int32_t v34 = PCB; // 0x80814e8
    int32_t v35 = v27; // 0x80814e8
    if (g141 != 104) {
        goto lab_0x80811e2;
    } else {
        goto lab_0x80814ee;
    }
  lab_0x80811d3:;
    int32_t v36 = v16;
    v28 = v15;
    v29 = g141;
    v30 = v17;
    v31 = v36;
    v32 = v15;
    v33 = 104;
    v34 = v17;
    v35 = v36;
    if (g141 == 104) {
        goto lab_0x80814ee;
    } else {
        goto lab_0x80811e2;
    }
  lab_0x80811e2:;
    int32_t v37 = v28 & 512; // 0x80811ea
    int32_t v38 = v28; // 0x80811ea
    int32_t v39 = v29; // 0x80811ea
    int32_t v40 = v30; // 0x80811ea
    int32_t v41 = v31; // 0x80811ea
    goto lab_0x80811ed;
  lab_0x80814ee:
    // 0x80814ee
    if (g214 == 1) {
        // 0x80817d8
        v28 = v32;
        v29 = v33;
        v30 = v34;
        v31 = v35;
        v37 = 0;
        v38 = 0;
        v39 = v33;
        v40 = v34;
        v41 = v35;
        if ((v32 & 257) != 0) {
            goto lab_0x80811ed;
        } else {
            goto lab_0x80811e2;
        }
    } else {
        // 0x80814fd
        v28 = v32;
        v29 = v33;
        v30 = v34;
        v31 = v35;
        if ((v32 & 768) == 0 || g214 != 2) {
            goto lab_0x80811e2;
        } else {
            // 0x808150f
            v28 = v32;
            v29 = v33;
            v30 = v34;
            v31 = v35;
            v37 = 0;
            v38 = 0;
            v39 = v33;
            v40 = v34;
            v41 = v35;
            if (v18 != (int32_t)g216) {
                goto lab_0x80811e2;
            } else {
                goto lab_0x80811ed;
            }
        }
    }
  lab_0x80811ed:;
    int32_t v42 = -600; // 0x80811fd
    int32_t v43 = -600; // 0x80811fd
    int3_t v44; // 0x8081160
    int3_t v45; // 0x8081160
    int3_t v46; // 0x8081160
    int32_t v47; // 0x8081160
    int32_t v48; // 0x8081160
    int32_t v49; // 0x8081160
    int32_t v50; // 0x8081203
    int32_t v51; // 0x8081160
    int32_t v52; // 0x8081160
    if ((char)v41 != 0) {
        goto lab_0x8081338;
    } else {
        // 0x8081203
        v50 = g193;
        int3_t v53; // 0x8081160
        if (v50 < 0 || v1 < v50) {
            int3_t v54 = v53 - 1; // 0x808161b
            __frontend_reg_store_fpr(v54, (float80_t)*(float64_t *)(v40 + 152));
            int3_t v55 = v53 - 2; // 0x8081627
            __frontend_reg_store_fpr(v55, (float80_t)(v1 + 1));
            if (__frontend_reg_load_fpr(v55) < __frontend_reg_load_fpr(v54)) {
                // 0x80817a0
                v47 = (v1 + (int32_t)(v1 < 0)) / 2;
                v44 = v54;
                goto lab_0x8081274;
            } else {
                // 0x8081632
                __frontend_reg_store_fpr(v55, (float80_t)*(int32_t *)(v40 + 136));
                int3_t v56 = v53 - 3; // 0x8081638
                __frontend_reg_store_fpr(v56, __frontend_reg_load_fpr(v54));
                __frontend_reg_store_fpr(v56, __frontend_reg_load_fpr(v56) - __frontend_reg_load_fpr(v55));
                int3_t v57 = v53 ^ -4; // 0x808163f
                __frontend_reg_store_fpr(v57, 0.5L);
                int3_t v58 = v53 + 3; // 0x8081645
                __frontend_reg_store_fpr(v58, __frontend_reg_load_fpr(v54));
                __frontend_reg_store_fpr(v58, __frontend_reg_load_fpr(v58) * __frontend_reg_load_fpr(v57));
                __frontend_reg_store_fpr(v56, __frontend_reg_load_fpr(v58) + __frontend_reg_load_fpr(v56));
                float80_t v59 = __frontend_reg_load_fpr(v57); // 0x8081655
                __frontend_reg_store_fpr(v57, __frontend_reg_load_fpr(v56));
                __frontend_reg_store_fpr(v56, v59);
                __frontend_reg_store_fpr(v57, __frontend_reg_load_fpr(v57) / __frontend_reg_load_fpr(v54));
                __frontend_reg_store_fpr(v57, __frontend_reg_load_fpr(v57));
                __frontend_reg_store_fpr(v57, __frontend_reg_load_fpr(v57) * __frontend_reg_load_fpr(v54));
                __frontend_reg_store_fpr(v56, __frontend_reg_load_fpr(v57) + __frontend_reg_load_fpr(v56));
                __frontend_reg_store_fpr(v55, __frontend_reg_load_fpr(v56) + __frontend_reg_load_fpr(v55));
                int32_t v60 = __frontend_reg_load_fpr(v55); // 0x808167f
                v51 = g194;
                v48 = v60;
                v45 = v54;
                v52 = g194;
                v49 = v60;
                v46 = v54;
                if (g194 >= 0) {
                    goto lab_0x8081285;
                } else {
                    goto lab_0x8081690;
                }
            }
        } else {
            int32_t v61 = *(int32_t *)(v40 + 136); // 0x808121a
            int3_t v62 = v53 - 1; // 0x8081222
            __frontend_reg_store_fpr(v62, (float80_t)*(float64_t *)(v40 + 152));
            int3_t v63 = v53 - 2; // 0x8081234
            __frontend_reg_store_fpr(v63, (float80_t)(v50 - v61));
            int3_t v64 = v53 - 3; // 0x8081237
            __frontend_reg_store_fpr(v64, 0.5L);
            int3_t v65 = v53 ^ -4; // 0x808123d
            __frontend_reg_store_fpr(v65, __frontend_reg_load_fpr(v62));
            __frontend_reg_store_fpr(v65, __frontend_reg_load_fpr(v65) * __frontend_reg_load_fpr(v64));
            __frontend_reg_store_fpr(v63, __frontend_reg_load_fpr(v65) + __frontend_reg_load_fpr(v63));
            float80_t v66 = __frontend_reg_load_fpr(v64); // 0x8081249
            __frontend_reg_store_fpr(v64, __frontend_reg_load_fpr(v63));
            __frontend_reg_store_fpr(v63, v66);
            __frontend_reg_store_fpr(v64, __frontend_reg_load_fpr(v64) / __frontend_reg_load_fpr(v62));
            __frontend_reg_store_fpr(v64, __frontend_reg_load_fpr(v64));
            __frontend_reg_store_fpr(v64, __frontend_reg_load_fpr(v64) * __frontend_reg_load_fpr(v62));
            __frontend_reg_store_fpr(v63, __frontend_reg_load_fpr(v64) + __frontend_reg_load_fpr(v63));
            __frontend_reg_store_fpr(v64, (float80_t)v61);
            __frontend_reg_store_fpr(v63, __frontend_reg_load_fpr(v64) + __frontend_reg_load_fpr(v63));
            v47 = __frontend_reg_load_fpr(v63);
            v44 = v62;
            goto lab_0x8081274;
        }
    }
  lab_0x8081338:;
    // 0x8081338
    int32_t v67; // 0x8081160
    int32_t v68; // 0x8081160
    int32_t v69; // 0x8081160
    int32_t v70; // 0x8081160
    int3_t v71; // 0x8081160
    int32_t v72; // 0x8081875
    int32_t v73; // 0x8081882
    int3_t v74; // 0x8081885
    if (v37 == 0) {
        if ((v38 & 257) != 0) {
            // 0x80817b8
            __frontend_reg_store_fpr(v71 - 1, (float80_t)(v43 - g193));
            v72 = *(int32_t *)(v19 + 52);
            __frontend_reg_store_fpr(v71 - 2, (float80_t)(v42 - g194));
            v73 = *(int32_t *)(v19 + 56);
            v74 = v71 - 3;
            __frontend_reg_store_fpr(v74, (float80_t)(v72 - g193));
            v67 = v73 - g194;
            goto lab_0x80815e6;
        } else {
            if ((v38 & 0x1000) == 0) {
                if ((v38 & 2) == 0) {
                    goto lab_0x80815a7;
                } else {
                    int3_t v75 = v71 - 1; // 0x8081751
                    __frontend_reg_store_fpr(v75, (float80_t)(v43 - g193));
                    int32_t v76 = *(int32_t *)(v18 + 216); // 0x8081757
                    int3_t v77 = v71 - 2; // 0x808175d
                    __frontend_reg_store_fpr(v77, (float80_t)(v42 - g194));
                    int32_t v78 = *(int32_t *)(v18 + 220); // 0x8081767
                    int3_t v79 = v71 - 3; // 0x808176d
                    __frontend_reg_store_fpr(v79, (float80_t)(v76 - g193));
                    int3_t v80 = v71 ^ -4; // 0x808177b
                    __frontend_reg_store_fpr(v80, (float80_t)(v78 - g194));
                    float80_t v81 = __frontend_reg_load_fpr(v80); // 0x808177e
                    __frontend_reg_store_fpr(v80, __frontend_reg_load_fpr(v75));
                    __frontend_reg_store_fpr(v75, v81);
                    __frontend_reg_store_fpr(v80, __frontend_reg_load_fpr(v80) * __frontend_reg_load_fpr(v80));
                    float80_t v82 = __frontend_reg_load_fpr(v80); // 0x8081782
                    __frontend_reg_store_fpr(v80, __frontend_reg_load_fpr(v77));
                    __frontend_reg_store_fpr(v77, v82);
                    __frontend_reg_store_fpr(v80, __frontend_reg_load_fpr(v80) * __frontend_reg_load_fpr(v80));
                    __frontend_reg_store_fpr(v77, __frontend_reg_load_fpr(v80) + __frontend_reg_load_fpr(v77));
                    __frontend_reg_store_fpr(v79, __frontend_reg_load_fpr(v79) * __frontend_reg_load_fpr(v79));
                    float80_t v83 = __frontend_reg_load_fpr(v79); // 0x808178a
                    __frontend_reg_store_fpr(v79, __frontend_reg_load_fpr(v75));
                    __frontend_reg_store_fpr(v75, v83);
                    __frontend_reg_store_fpr(v79, __frontend_reg_load_fpr(v79) * __frontend_reg_load_fpr(v79));
                    __frontend_reg_store_fpr(v75, __frontend_reg_load_fpr(v79) + __frontend_reg_load_fpr(v75));
                    float80_t v84 = __frontend_reg_load_fpr(v77); // 0x8081790
                    float80_t v85 = __frontend_reg_load_fpr(v75); // 0x8081790
                    bool v86 = false; // 0x8081790
                    bool v87 = false; // 0x8081790
                    if (v84 <= v85) {
                        v86 = true;
                        v87 = false;
                        if (v84 >= v85) {
                            v86 = v84 != v85;
                            v87 = true;
                        }
                    }
                    __frontend_reg_store_fpr(v75, __frontend_reg_load_fpr(v75));
                    v68 = v39;
                    v70 = v76;
                    v69 = v78;
                    if (v86 || v87) {
                        goto lab_0x80815a7;
                    } else {
                        goto lab_0x80813c4;
                    }
                }
            } else {
                int32_t v88 = v43 - g193; // 0x808154b
                int32_t v89 = v42 - g194; // 0x8081554
                int32_t v90 = *(int32_t *)v20; // 0x808155a
                int32_t v91 = *(int32_t *)(v20 + 4); // 0x808155c
                int32_t v92 = v90 - g193; // 0x8081567
                int32_t v93 = v91 - g194; // 0x8081572
                v68 = v39;
                v70 = v90;
                v69 = v91;
                if (v89 * v89 + v88 * v88 > v93 * v93 + v92 * v92) {
                    goto lab_0x80813c4;
                } else {
                    goto lab_0x80815a7;
                }
            }
        }
    } else {
        int32_t v94 = *(int32_t *)(v19 + 44); // 0x8081346
        int32_t v95 = *(int32_t *)(v19 + 48); // 0x8081354
        int3_t v96 = v71 - 1; // 0x8081357
        __frontend_reg_store_fpr(v96, (float80_t)(v94 - g193));
        int32_t v97 = *(int32_t *)(v19 + 64); // 0x8081365
        int32_t v98 = *(int32_t *)(v19 + 68); // 0x8081368
        int3_t v99 = v71 - 2; // 0x808136b
        __frontend_reg_store_fpr(v99, (float80_t)(v95 - g194));
        int3_t v100 = v71 - 3; // 0x8081381
        __frontend_reg_store_fpr(v100, (float80_t)(v97 - g193));
        int3_t v101 = v71 ^ -4; // 0x8081387
        __frontend_reg_store_fpr(v101, (float80_t)(v98 - g194));
        float80_t v102 = __frontend_reg_load_fpr(v101); // 0x808138a
        __frontend_reg_store_fpr(v101, __frontend_reg_load_fpr(v96));
        __frontend_reg_store_fpr(v96, v102);
        __frontend_reg_store_fpr(v101, __frontend_reg_load_fpr(v101) * __frontend_reg_load_fpr(v101));
        float80_t v103 = __frontend_reg_load_fpr(v101); // 0x808138e
        __frontend_reg_store_fpr(v101, __frontend_reg_load_fpr(v99));
        __frontend_reg_store_fpr(v99, v103);
        __frontend_reg_store_fpr(v101, __frontend_reg_load_fpr(v101) * __frontend_reg_load_fpr(v101));
        __frontend_reg_store_fpr(v99, __frontend_reg_load_fpr(v101) + __frontend_reg_load_fpr(v99));
        __frontend_reg_store_fpr(v100, __frontend_reg_load_fpr(v100) * __frontend_reg_load_fpr(v100));
        float80_t v104 = __frontend_reg_load_fpr(v100); // 0x8081396
        __frontend_reg_store_fpr(v100, __frontend_reg_load_fpr(v96));
        __frontend_reg_store_fpr(v96, v104);
        __frontend_reg_store_fpr(v100, __frontend_reg_load_fpr(v100) * __frontend_reg_load_fpr(v100));
        __frontend_reg_store_fpr(v96, __frontend_reg_load_fpr(v100) + __frontend_reg_load_fpr(v96));
        float80_t v105 = __frontend_reg_load_fpr(v99); // 0x808139c
        __frontend_reg_store_fpr(v99, __frontend_reg_load_fpr(v96));
        __frontend_reg_store_fpr(v96, v105);
        float80_t v106 = __frontend_reg_load_fpr(v99); // 0x808139e
        float80_t v107 = __frontend_reg_load_fpr(v96); // 0x808139e
        bool v108 = false; // 0x808139e
        bool v109 = false; // 0x808139e
        if (v106 <= v107) {
            v108 = true;
            v109 = false;
            if (v106 >= v107) {
                v108 = v106 != v107;
                v109 = true;
            }
        }
        // 0x80815b8
        __frontend_reg_store_fpr(v96, __frontend_reg_load_fpr(v96));
        bool v110 = v108 | v109; // 0x80813a2
        int32_t v111 = v110 ? v98 : v95; // 0x80813a2
        int32_t v112 = v110 ? v97 : v94; // 0x80813aa
        __frontend_reg_store_fpr(v96, (float80_t)(v43 - g193));
        __frontend_reg_store_fpr(v99, (float80_t)(v42 - g194));
        __frontend_reg_store_fpr(v100, (float80_t)(v112 - g193));
        v74 = v100;
        v67 = v111 - g194;
        v72 = v112;
        v73 = v111;
        goto lab_0x80815e6;
    }
  lab_0x80815e6:;
    int3_t v113 = v74;
    int3_t v114 = v113 - 1; // 0x80815e9
    __frontend_reg_store_fpr(v114, (float80_t)v67);
    int3_t v115 = v113 + 2; // 0x80815ec
    float80_t v116 = __frontend_reg_load_fpr(v114); // 0x80815ec
    __frontend_reg_store_fpr(v114, __frontend_reg_load_fpr(v115));
    __frontend_reg_store_fpr(v115, v116);
    __frontend_reg_store_fpr(v114, __frontend_reg_load_fpr(v114) * __frontend_reg_load_fpr(v114));
    int3_t v117 = v113 + 1; // 0x80815f0
    float80_t v118 = __frontend_reg_load_fpr(v114); // 0x80815f0
    __frontend_reg_store_fpr(v114, __frontend_reg_load_fpr(v117));
    __frontend_reg_store_fpr(v117, v118);
    __frontend_reg_store_fpr(v114, __frontend_reg_load_fpr(v114) * __frontend_reg_load_fpr(v114));
    __frontend_reg_store_fpr(v117, __frontend_reg_load_fpr(v114) + __frontend_reg_load_fpr(v117));
    float80_t v119 = __frontend_reg_load_fpr(v113); // 0x80815f6
    __frontend_reg_store_fpr(v113, v119 * __frontend_reg_load_fpr(v113));
    float80_t v120 = __frontend_reg_load_fpr(v113); // 0x80815f8
    __frontend_reg_store_fpr(v113, __frontend_reg_load_fpr(v115));
    __frontend_reg_store_fpr(v115, v120);
    float80_t v121 = __frontend_reg_load_fpr(v113); // 0x80815fa
    __frontend_reg_store_fpr(v113, v121 * __frontend_reg_load_fpr(v113));
    __frontend_reg_store_fpr(v115, __frontend_reg_load_fpr(v113) + __frontend_reg_load_fpr(v115));
    float80_t v122 = __frontend_reg_load_fpr(v117); // 0x80815fe
    float80_t v123 = __frontend_reg_load_fpr(v115); // 0x80815fe
    bool v124 = false; // 0x80815fe
    bool v125 = false; // 0x80815fe
    if (v122 <= v123) {
        v124 = true;
        v125 = false;
        if (v122 >= v123) {
            v124 = v122 != v123;
            v125 = true;
        }
    }
    __frontend_reg_store_fpr(v115, __frontend_reg_load_fpr(v115));
    bool v126 = v124 | v125; // 0x8081602
    v68 = g141;
    v70 = v126 ? v43 : v72;
    v69 = v126 ? v42 : v73;
    goto lab_0x80813c4;
  lab_0x8081274:
    // 0x8081274
    v51 = g194;
    v48 = v47;
    v45 = v44;
    v52 = g194;
    v49 = v47;
    v46 = v44;
    if (g194 < 0) {
        goto lab_0x8081690;
    } else {
        goto lab_0x8081285;
    }
  lab_0x80813c4:
    // 0x80813c4
    if (v70 >= 0 && v69 >= 0) {
        // 0x80813cc
        g193 = v70;
        g194 = v69;
    }
    int32_t v127 = v68; // 0x80813db
    if (v68 == 110) {
        int32_t v128 = SearchScreen(g193, g194, 0x1000, (char **)&v18, (char **)&v19, (char **)&v20); // 0x8081836
        if (v128 == 0) {
            // 0x8081898
            hid_action("PointCursor");
            v127 = g141;
        } else {
            // 0x808183f
            if ((*(char *)(v19 + 20) & 64) == 0) {
                // 0x80818b0
                hid_actionl("PointCursor");
            }
            // 0x8081848
            v127 = g141;
        }
    }
    // 0x80813e1
    if (v127 != 2 || g204 == 0) {
        // 0x80813ea
        return;
    }
    // 0x8081715
    if (*(char *)(PCB + 4) < 0) {
        // 0x8081724
        EnforceLineDRC();
    }
  lab_0x8081285:;
    int3_t v129 = v45;
    v52 = v51;
    v49 = v48;
    v46 = v129;
    int3_t v130; // 0x8081160
    int32_t v131; // 0x8081160
    int32_t v132; // 0x8081160
    int32_t v133; // 0x8081160
    if (v2 < v51) {
        goto lab_0x8081690;
    } else {
        int32_t v134 = *(int32_t *)(v40 + 140); // 0x808128e
        int3_t v135 = v129 - 1; // 0x80812a3
        __frontend_reg_store_fpr(v135, (float80_t)(v51 - v134));
        int3_t v136 = v129 - 2; // 0x80812a6
        __frontend_reg_store_fpr(v136, 0.5L);
        float80_t v137 = __frontend_reg_load_fpr(v129); // 0x80812ac
        int3_t v138 = v129 - 3; // 0x80812ac
        __frontend_reg_store_fpr(v138, v137);
        __frontend_reg_store_fpr(v138, __frontend_reg_load_fpr(v138) * __frontend_reg_load_fpr(v136));
        __frontend_reg_store_fpr(v135, __frontend_reg_load_fpr(v138) + __frontend_reg_load_fpr(v135));
        float80_t v139 = __frontend_reg_load_fpr(v136); // 0x80812b8
        __frontend_reg_store_fpr(v136, __frontend_reg_load_fpr(v135));
        __frontend_reg_store_fpr(v135, v139);
        __frontend_reg_store_fpr(v136, __frontend_reg_load_fpr(v136) / __frontend_reg_load_fpr(v129));
        __frontend_reg_store_fpr(v136, __frontend_reg_load_fpr(v136));
        float80_t v140 = __frontend_reg_load_fpr(v136); // 0x80812ce
        __frontend_reg_store_fpr(v129, v140 * __frontend_reg_load_fpr(v129));
        float80_t v141 = __frontend_reg_load_fpr(v135); // 0x80812d3
        __frontend_reg_store_fpr(v129, v141 + __frontend_reg_load_fpr(v129));
        __frontend_reg_store_fpr(v135, (float80_t)v134);
        float80_t v142 = __frontend_reg_load_fpr(v135); // 0x80812d8
        __frontend_reg_store_fpr(v129, v142 + __frontend_reg_load_fpr(v129));
        v132 = v51;
        v133 = __frontend_reg_load_fpr(v129);
        v131 = v48;
        v130 = v129;
        goto lab_0x80812e3;
    }
  lab_0x8081690:;
    int3_t v143 = v46;
    int3_t v144 = v143 - 1; // 0x8081699
    __frontend_reg_store_fpr(v144, (float80_t)(v2 + 1));
    int3_t v145; // 0x8081160
    int32_t v146; // 0x8081160
    int32_t v147; // 0x8081160
    int32_t v148; // 0x8081160
    if (__frontend_reg_load_fpr(v144) < __frontend_reg_load_fpr(v143)) {
        // 0x80817f0
        __frontend_reg_store_fpr(v143, __frontend_reg_load_fpr(v143));
        v132 = v52;
        v133 = (v2 + (int32_t)(v2 < 0)) / 2;
        v131 = v49;
        v130 = v143;
        goto lab_0x80812e3;
    } else {
        // 0x80816a4
        __frontend_reg_store_fpr(v144, (float80_t)*(int32_t *)(v40 + 140));
        float80_t v149 = __frontend_reg_load_fpr(v143); // 0x80816aa
        int3_t v150 = v143 - 2; // 0x80816aa
        __frontend_reg_store_fpr(v150, v149);
        __frontend_reg_store_fpr(v150, __frontend_reg_load_fpr(v150) - __frontend_reg_load_fpr(v144));
        int3_t v151 = v143 - 3; // 0x80816b8
        __frontend_reg_store_fpr(v151, 0.5L);
        float80_t v152 = __frontend_reg_load_fpr(v143); // 0x80816be
        int3_t v153 = v143 ^ -4; // 0x80816be
        __frontend_reg_store_fpr(v153, v152);
        __frontend_reg_store_fpr(v153, __frontend_reg_load_fpr(v153) * __frontend_reg_load_fpr(v151));
        __frontend_reg_store_fpr(v150, __frontend_reg_load_fpr(v153) + __frontend_reg_load_fpr(v150));
        float80_t v154 = __frontend_reg_load_fpr(v151); // 0x80816ce
        __frontend_reg_store_fpr(v151, __frontend_reg_load_fpr(v150));
        __frontend_reg_store_fpr(v150, v154);
        __frontend_reg_store_fpr(v151, __frontend_reg_load_fpr(v151) / __frontend_reg_load_fpr(v143));
        __frontend_reg_store_fpr(v151, __frontend_reg_load_fpr(v151));
        float80_t v155 = __frontend_reg_load_fpr(v151); // 0x80816e4
        __frontend_reg_store_fpr(v143, v155 * __frontend_reg_load_fpr(v143));
        float80_t v156 = __frontend_reg_load_fpr(v150); // 0x80816e6
        __frontend_reg_store_fpr(v143, v156 + __frontend_reg_load_fpr(v143));
        float80_t v157 = __frontend_reg_load_fpr(v144); // 0x80816e8
        __frontend_reg_store_fpr(v143, v157 + __frontend_reg_load_fpr(v143));
        int32_t v158 = __frontend_reg_load_fpr(v143); // 0x80816ed
        int3_t v159 = v143 + 1; // 0x80816ed
        v147 = v52;
        v148 = v158;
        v146 = v49;
        v145 = v159;
        v42 = v158;
        v71 = v159;
        v43 = v49;
        if (*(char *)&Marked != 0) {
            goto lab_0x80812f0;
        } else {
            goto lab_0x8081338;
        }
    }
  lab_0x80815a7:
    // 0x80815a7
    v68 = v39;
    v70 = v43;
    v69 = v42;
    goto lab_0x80813c4;
  lab_0x80812e3:;
    int3_t v160 = v130 + 1;
    v147 = v132;
    v148 = v133;
    v146 = v131;
    v145 = v160;
    v42 = v133;
    v71 = v160;
    v43 = v131;
    if (*(char *)&Marked == 0) {
        goto lab_0x8081338;
    } else {
        goto lab_0x80812f0;
    }
  lab_0x80812f0:
    // 0x80812f0
    v42 = v148;
    v71 = v145;
    v43 = v146;
    if (*(int16_t *)(v40 + 4) < 0) {
        int32_t v161 = v50 - g191; // 0x8081307
        int32_t v162 = v161 < 0 ? -v161 : v161; // 0x8081313
        int32_t v163 = v147 - g192; // 0x8081318
        int32_t v164 = v163 < 0 ? -v163 : v163; // 0x8081322
        int32_t v165 = v162 - v164; // 0x8081327
        int32_t v166 = v165 < 0 == ((v165 ^ v162) & (v164 ^ v162)) < 0 == (v165 != 0) ? g192 : v148; // 0x8081329
        int32_t v167 = v165 < 0 == ((v165 ^ v162) & (v164 ^ v162)) < 0 == (v165 != 0) ? v146 : g191; // 0x808132d
        v42 = v166;
        v71 = v145;
        v43 = v167;
    }
    goto lab_0x8081338;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x80818e0 - 0x8081904
// Line range:    967 - 969
void MoveCrosshairRelative(int32_t DeltaX, int32_t DeltaY) {
    // 0x80818e0
    FitCrosshairIntoGrid(g193 + DeltaX, g194 + DeltaY);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8081910 - 0x8081974
// Line range:    1004 - 1013
void SetCrosshairRange(int32_t MinX, int32_t MinY, int32_t MaxX, int32_t MaxY) {
    // 0x8081910
    g196 = MinY >= 0 ? MinY : 0;
    g195 = MinX > 0 ? MinX : 0;
    int32_t v1 = *(int32_t *)(PCB + 144); // 0x808193d
    int32_t v2 = MaxX - v1; // 0x8081943
    g197 = v2 == 0 | v2 < 0 != ((v2 ^ MaxX) & (v1 ^ MaxX)) < 0 ? MaxX : v1;
    int32_t v3 = *(int32_t *)(PCB + 148); // 0x808194e
    int32_t v4 = MaxY - v3; // 0x8081954
    g198 = v4 == 0 | v4 < 0 != ((v4 ^ MaxY) & (v3 ^ MaxY)) < 0 ? MaxY : v3;
    MoveCrosshairRelative(0, 0);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8081980 - 0x8081cb0
// Line range:    111 - 163
void XORDrawAttachedArc(int32_t thick) {
    int32_t v1 = __readgsdword(20); // 0x8081992
    if (g194 != g207 || g193 != (int32_t)g206) {
        // 0x80819bd
        int32_t v2; // bp-100, 0x8081980
        GetArcEnds((int32_t)&v2);
    }
    // 0x8081a9b
    if (v1 == __readgsdword(20)) {
        // 0x8081aab
        return;
    }
    // 0x8081ca5
    __stack_chk_fail();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8081cb0 - 0x8081f06
// Line range:    169 - 181
void XORDrawAttachedLine(int32_t x1, int32_t y1, int32_t x2, int32_t y2, int32_t thick) {
    int32_t v1 = 0; // 0x8081cc2
    int32_t v2; // 0x8081cb0
    int32_t v3 = x1 - v2; // 0x8081cc7
    float80_t v4 = 0.0L; // 0x8081cc9
    float80_t v5 = 0.0L; // 0x8081cc9
    float80_t v6 = 0.0L; // 0x8081cc9
    float80_t v7 = 0.0L; // 0x8081cc9
    if ((v1 || v3) != 0) {
        // 0x8081cf0
        v7 = v1;
        float80_t v8 = v3; // 0x8081cfc
        v5 = 0.5L * (float80_t)y1 / sqrtl(v8 * v8 + v7 * v7);
        v6 = v3 < 1 ? v3 == 0 ? 0.0L : -0.5L : 0.5L;
        v4 = v5 * v8;
    }
    int32_t v9 = v4 + v6; // 0x8081d43
    if ((v9 < 0 ? -v9 : v9) >= pixel_slop) {
        // 0x8081dea
        atan2((float64_t)v7, (float64_t)(int64_t)(v2 + v9));
        // 0x8081ec4
        return;
    }
    int32_t v10 = -(((v1 < 1 ? v1 != 0 ? -0.5L : 0.0L : 0.5L) + v5 * v7)); // 0x8081d66
    if (pixel_slop > (v10 < 0 ? -v10 : v10)) {
        // 0x8081ec4
        return;
    }
    // 0x8081dea
    atan2((float64_t)v7, (float64_t)(int64_t)(v2 + v9));
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8081f10 - 0x8082a86
// Line range:    580 - 484
void DrawAttached(char BlockToo) {
    // 0x8081f10
    int32_t v1; // 0x8081f10
    int32_t v2; // 0x8081f10
    int32_t v3; // 0x8081f10
    int32_t v4; // 0x8081f10
    int32_t * v5; // 0x80825eb
    if (g141 == 5) {
        int32_t v6 = 28 * (int32_t)g142; // 0x80823a0
        int32_t v7 = *(int32_t *)(PCB + 0x220c); // 0x80823cb
        int32_t v8 = PCB; // 0x80823d5
        if (*(int32_t *)(v7 + 24) != -2) {
            int32_t v9 = 0; // 0x80825c5
            int32_t v10 = 92 * v9; // 0x80823e8
            int32_t v11 = PCB; // 0x80823f4
            int32_t v12; // 0x8081f10
            int32_t v13; // 0x8081f10
            int32_t v14; // 0x8081f10
            int32_t v15; // 0x8081f10
            int32_t v16; // 0x8081f10
            int32_t v17; // 0x8081f10
            int32_t v18; // 0x8081f10
            int32_t v19; // 0x8081f10
            int32_t v20; // 0x8082400
            int32_t v21; // 0x8082402
            int32_t v22; // 0x808247e
            int32_t v23; // 0x80824fc
            int32_t v24; // 0x8082575
            if (*(char *)(v7 + 144 + v10) != 0) {
                // 0x80823fa
                v20 = *(int32_t *)(v6 + (int32_t)&Buffers + 24) + v10;
                v21 = *(int32_t *)(v20 + 80);
                v13 = v21;
                if (v21 != 0) {
                    v12 = v13 - 1;
                    v13 = v12;
                    while (v12 != 0) {
                        // 0x8082428
                        v12 = v13 - 1;
                        v13 = v12;
                    }
                }
                // 0x8082477
                v22 = *(int32_t *)(v20 + 92);
                v15 = v22;
                if (v22 != 0) {
                    v14 = v15 - 1;
                    v15 = v14;
                    while (v14 != 0) {
                        // 0x80824a0
                        v14 = v15 - 1;
                        v15 = v14;
                    }
                }
                // 0x80824f5
                v23 = *(int32_t *)(v20 + 84);
                v17 = v23;
                if (v23 != 0) {
                    v16 = v17 - 1;
                    v17 = v16;
                    while (v16 != 0) {
                        // 0x8082520
                        v16 = v17 - 1;
                        v17 = v16;
                    }
                }
                // 0x808256e
                v24 = *(int32_t *)(v20 + 88);
                v19 = v24;
                v11 = PCB;
                if (v24 != 0) {
                    v18 = v19 - 1;
                    XORPolygon((int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
                    v19 = v18;
                    while (v18 != 0) {
                        // 0x8082598
                        v18 = v19 - 1;
                        XORPolygon((int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
                        v19 = v18;
                    }
                    // 0x80825b9
                    v11 = PCB;
                }
            }
            int32_t v25 = PCB;
            int32_t v26 = *(int32_t *)(v25 + 0x220c); // 0x80825bf
            v9++;
            v8 = v25;
            while (v9 < *(int32_t *)(v26 + 24) + 2) {
                int32_t v27 = v11;
                v10 = 92 * v9;
                v11 = v27;
                int32_t v28 = v25; // 0x80823f4
                if (*(char *)(v26 + 144 + v10) != 0) {
                    // 0x80823fa
                    v20 = *(int32_t *)(v6 + (int32_t)&Buffers + 24) + v10;
                    v21 = *(int32_t *)(v20 + 80);
                    v13 = v21;
                    if (v21 != 0) {
                        v12 = v13 - 1;
                        v13 = v12;
                        while (v12 != 0) {
                            // 0x8082428
                            v12 = v13 - 1;
                            v13 = v12;
                        }
                    }
                    // 0x8082477
                    v22 = *(int32_t *)(v20 + 92);
                    v15 = v22;
                    if (v22 != 0) {
                        v14 = v15 - 1;
                        v15 = v14;
                        while (v14 != 0) {
                            // 0x80824a0
                            v14 = v15 - 1;
                            v15 = v14;
                        }
                    }
                    // 0x80824f5
                    v23 = *(int32_t *)(v20 + 84);
                    v17 = v23;
                    if (v23 != 0) {
                        v16 = v17 - 1;
                        v17 = v16;
                        while (v16 != 0) {
                            // 0x8082520
                            v16 = v17 - 1;
                            v17 = v16;
                        }
                    }
                    // 0x808256e
                    v24 = *(int32_t *)(v20 + 88);
                    v19 = v24;
                    v11 = v27;
                    v28 = v27;
                    if (v24 != 0) {
                        v18 = v19 - 1;
                        XORPolygon((int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
                        v19 = v18;
                        while (v18 != 0) {
                            // 0x8082598
                            v18 = v19 - 1;
                            XORPolygon((int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
                            v19 = v18;
                        }
                        // 0x80825b9
                        v11 = PCB;
                        v28 = PCB;
                    }
                }
                // 0x80825bf
                v25 = v28;
                v26 = *(int32_t *)(v25 + 0x220c);
                v9++;
                v8 = v25;
            }
        }
        // 0x80825d8
        if (*(char *)(v8 + 38) == 0 || *(char *)(v8 + 35) == 0) {
            // 0x8082090
            return;
        }
        // 0x80825e8
        v5 = (int32_t *)(v6 + (int32_t)&Buffers + 24);
        int32_t v29 = *v5; // 0x80825eb
        int32_t v30 = *(int32_t *)(v29 + 8); // 0x80825ee
        if (v30 == 0) {
            // 0x8082090
            return;
        }
        // 0x80825f9
        v1 = v29;
        v2 = v30;
        v4 = 300 * v30;
        while (true) {
          lab_0x8082616:
            // 0x8082616
            v3 = v4 - 300;
            uint32_t v31 = *(int32_t *)(*(int32_t *)(v1 + 32) + 20 + v3); // 0x8082623
            if (v31 / 128 % 2 == (int32_t)g170) {
                // 0x808263c
                XORDrawElement((int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
                goto lab_0x8082646;
            } else {
                // 0x8082630
                if (*(char *)(PCB + 37) == 0) {
                    goto lab_0x8082646;
                } else {
                    // 0x808263c
                    XORDrawElement((int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
                    goto lab_0x8082646;
                }
            }
        }
    }
    int32_t v32; // 0x8081f10
    if (g141 <= 5) {
        int32_t v33; // 0x8081f10
        switch (g141) {
            case 2: {
                // 0x808217c
                if (g204 == 0 || g205 == 0) {
                    // 0x8082090
                    return;
                }
                int32_t v34 = *(char *)(PCB + 40) == 0 ? g129 : 10; // 0x80821b3
                XORDrawAttachedLine(g203, v34, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
                int32_t v35 = PCB; // 0x80821da
                if (*(int32_t *)(PCB + 108) != 0) {
                    int32_t v36 = *(char *)(PCB + 40) == 0 ? g129 : 10; // 0x80821f1
                    XORDrawAttachedLine(g194, v36, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
                    v35 = PCB;
                }
                // 0x808220e
                if ((*(char *)(v35 + 4) & 8) == 0) {
                    // 0x8082090
                    return;
                }
                // 0x8082218
                v33 = 10;
                if (*(char *)(v35 + 40) == 0) {
                    // 0x8082242
                    v33 = g129 + 2 + 2 * *(int32_t *)(v35 + 112);
                }
                // break -> 0x808224f
                break;
            }
            case 4: {
                // 0x808211e
                if (g212 >= 2) {
                    // 0x808212b
                    XORPolygon(0x1000000 * v32 / 0x1000000, (int32_t)&g231, (int32_t)&g231);
                }
                // 0x8082090
                return;
            }
            default: {
                // 0x8082090
                return;
            }
        }
        // 0x808224f
        XORDrawAttachedLine(g203, v33, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
        if (*(int32_t *)(PCB + 108) == 0) {
            // 0x8082090
            return;
        }
        int32_t v37 = 10; // 0x808228a
        if (*(char *)(PCB + 40) == 0) {
            // 0x808228c
            v37 = g129 + 2 + 2 * *(int32_t *)(PCB + 112);
        }
        // 0x8082299
        XORDrawAttachedLine(g194, v37, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
        // 0x8082090
        return;
    }
    if (g141 == 106) {
        // 0x8082090
        return;
    }
    if (g141 > 106) {
        // 0x80820b8
        if (g141 != 109 || g210 == 0) {
            // 0x8082090
            return;
        }
        // 0x80820c6
        XORDrawAttachedArc(0x1000000 * v32 / 0x1000000);
        if ((*(char *)(PCB + 4) & 8) != 0) {
            // 0x80820db
            XORDrawAttachedArc(Crosshair);
        }
        // 0x8082090
        return;
    }
    if (g141 < 104) {
        // 0x8082090
        return;
    }
    int32_t v38 = g194 - g213; // 0x8081f6f
    if (g214 == 256) {
        // 0x8082a2c
        XORDrawElement(0x1000000 * v32 / 0x1000000, (int32_t)&g231, (int32_t)&g231);
        goto lab_0x8081fc8;
    } else {
        if (g214 > 256) {
            if (g214 == 2048) {
                goto lab_0x8081fc8;
            } else {
                if (g214 > 2048) {
                    if (g214 == 0x1000) {
                        int32_t v39 = *(int32_t *)(g217 + 36);
                        if (g218 == g217 + 44) {
                            int32_t v40 = *(int32_t *)(g217 + 68); // 0x8082a56
                            XORDrawAttachedLine(v40, v39, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
                        } else {
                            int32_t v41 = *(int32_t *)(g217 + 48); // 0x808292e
                            XORDrawAttachedLine(v41, v39, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
                        }
                    }
                    goto lab_0x8081fc8;
                } else {
                    if (g214 == 512) {
                        // 0x8082a2c
                        XORDrawElement(0x1000000 * v32 / 0x1000000, (int32_t)&g231, (int32_t)&g231);
                        goto lab_0x8081fc8;
                    } else {
                        goto lab_0x8081fc8;
                    }
                }
            }
        } else {
            if (g214 == 4) {
                int32_t v42 = *(int32_t *)(g217 + 36); // 0x80828de
                int32_t v43 = *(int32_t *)(g217 + 68); // 0x80828ee
                XORDrawAttachedLine(v43 + v38, v42, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
                goto lab_0x8081fc8;
            } else {
                if (g214 > 4) {
                    if (g214 == 8) {
                        // 0x8082a17
                        XORPolygon(0x1000000 * v32 / 0x1000000, (int32_t)&g231, (int32_t)&g231);
                    }
                    goto lab_0x8081fc8;
                } else {
                    if (g214 == 2) {
                        // 0x8082a2c
                        XORDrawElement(0x1000000 * v32 / 0x1000000, (int32_t)&g231, (int32_t)&g231);
                        goto lab_0x8081fc8;
                    } else {
                        goto lab_0x8081fc8;
                    }
                }
            }
        }
    }
  lab_0x8082646:;
    int32_t v44 = v2 - 1;
    if (v44 == 0) {
        return;
    }
    // 0x8082610
    v1 = *v5;
    v2 = v44;
    v4 = v3;
    goto lab_0x8082616;
  lab_0x8081fc8:
    // 0x8081fc8
    if (g219 == 0) {
        // 0x8082090
        return;
    }
    int32_t v45 = (int32_t)g220;
    int32_t v46 = *(int32_t *)(v45 + 4); // 0x8082024
    int32_t v47 = *(int32_t *)(v46 + 20); // 0x8082027
    int32_t v48; // 0x8081fe0
    int32_t v49; // 0x8081ff6
    int32_t v50; // 0x8082009
    int32_t v51; // 0x808204a
    int32_t v52; // 0x8082057
    if ((v47 & 2) == 0) {
        if ((v47 & 512) != 0) {
            // 0x8081fe0
            v48 = *(int32_t *)(v45 + 8);
            v49 = *(int32_t *)(v46 + 36);
            v50 = *(int32_t *)((v48 == v46 + 44 ? v48 : v46 + 64) + 4);
            XORDrawAttachedLine(v50 + v38, v49, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
        } else {
            // 0x8082033
            if (*(int32_t *)(v45 + 8) == v46 + 44) {
                // 0x808203b
                v51 = *(int32_t *)(v46 + 36);
                v52 = *(int32_t *)(v46 + 68);
                XORDrawAttachedLine(v52 + v38, v51, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
            }
        }
    }
    int32_t v53 = g219 - 1; // 0x808201c
    int32_t v54 = v45 + 12; // 0x808201f
    int32_t v55 = v53; // 0x808201f
    while (v53 != 0) {
        // 0x8082024
        v45 = v54;
        v46 = *(int32_t *)(v45 + 4);
        v47 = *(int32_t *)(v46 + 20);
        if ((v47 & 2) == 0) {
            if ((v47 & 512) != 0) {
                // 0x8081fe0
                v48 = *(int32_t *)(v45 + 8);
                v49 = *(int32_t *)(v46 + 36);
                v50 = *(int32_t *)((v48 == v46 + 44 ? v48 : v46 + 64) + 4);
                XORDrawAttachedLine(v50 + v38, v49, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
            } else {
                // 0x8082033
                if (*(int32_t *)(v45 + 8) == v46 + 44) {
                    // 0x808203b
                    v51 = *(int32_t *)(v46 + 36);
                    v52 = *(int32_t *)(v46 + 68);
                    XORDrawAttachedLine(v52 + v38, v51, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
                }
            }
        }
        // 0x808201c
        v53 = v55 - 1;
        v54 = v45 + 12;
        v55 = v53;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8082a90 - 0x8082ac4
// Line range:    715 - 721
void CrosshairOff(char BlockToo) {
    // 0x8082a90
    if (g199 == 0) {
        // 0x8082aa3
        return;
    }
    // 0x8082aa8
    g199 = 0;
    int32_t v1; // 0x8082a90
    DrawAttached((char)v1);
    DrawMark(1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8082b00 - 0x8082b57
// Line range:    738 - 751
void HideCrosshair(char BlockToo) {
    // 0x8082b00
    if (CrosshairStackLocation > 15) {
        // 0x8082b38
        __fprintf_chk(g43, 1, "Error: CrosshairStackLocation overflow\n");
        return;
    }
    // 0x8082b14
    CrosshairStack[0] = g199;
    CrosshairStackLocation++;
    int32_t v1; // 0x8082b00
    CrosshairOff((char)v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8082bf0 - 0x8082c24
// Line range:    701 - 707
void CrosshairOn(char BlockToo) {
    // 0x8082bf0
    if (g199 != 0) {
        // 0x8082c03
        return;
    }
    // 0x8082c08
    g199 = 1;
    int32_t v1; // 0x8082bf0
    DrawAttached((char)v1);
    DrawMark(1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/crosshair.c
// Address range: 0x8082c30 - 0x8082c97
// Line range:    757 - 776
void RestoreCrosshair(char BlockToo) {
    // 0x8082c30
    if (CrosshairStackLocation < 1) {
        // 0x8082c78
        __fprintf_chk(g43, 1, "Error: CrosshairStackLocation underflow\n");
        return;
    }
    // 0x8082c43
    int32_t v1; // 0x8082c30
    char v2 = v1; // 0x8082c30
    CrosshairStackLocation--;
    if (g50 != 0) {
        // 0x8082c68
        CrosshairOn(v2);
        return;
    }
    // 0x8082c55
    CrosshairOff(v2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/djopt.c
// Address range: 0x8086d30 - 0x8086d4c
// Line range:    3088 - 3088
void register_djopt_action_list(void) {
    // 0x8086d30
    hid_register_actions((int32_t)&djopt_action_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/djopt.c
// Address range: 0x8086d50 - 0x8086d6c
// Line range:    154 - 154
void register_djopt_flag_list(void) {
    // 0x8086d50
    hid_register_flags((int32_t)&djopt_flag_list, 1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x8088fc0 - 0x808906d
// Line range:    121 - 146
void SetPVColor(int32_t Pin, int32_t Type) {
    // 0x8088fc0
    return;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x8089340 - 0x808949f
// Line range:    942 - 999
void DrawSpecialPolygon(int32_t hid, int32_t DrawGC, int32_t X, int32_t Y, int32_t Thickness) {
    // 0x8089340
    if (g53 != DrawGC) {
        // 0x8089360
        g53 = DrawGC;
        float80_t v1 = DrawGC; // 0x808936e
        int32_t v2 = 0;
        int32_t v3 = 4 * v2; // 0x8089380
        float64_t v4 = *(float64_t *)(v3 + (int32_t)&g1); // 0x8089380
        *(int32_t *)(v2 + (int32_t)&g52) = (int32_t)(v1 * (float80_t)v4);
        float64_t v5 = *(float64_t *)(v3 + (int32_t)&g2); // 0x8089395
        *(int32_t *)(v2 + (int32_t)&g51) = (int32_t)(v1 * (float80_t)v5);
        int32_t v6 = v2 + 4; // 0x80893b0
        while (v2 != 28) {
            // 0x8089380
            v2 = v6;
            v3 = 4 * v2;
            v4 = *(float64_t *)(v3 + (int32_t)&g1);
            *(int32_t *)(v2 + (int32_t)&g52) = (int32_t)(v1 * (float80_t)v4);
            v5 = *(float64_t *)(v3 + (int32_t)&g2);
            *(int32_t *)(v2 + (int32_t)&g51) = (int32_t)(v1 * (float80_t)v5);
            v6 = v2 + 4;
        }
    }
    for (int32_t i = 0; i < 8; i++) {
        int32_t v7 = 4 * i; // 0x80893c0
        int32_t v8 = *(int32_t *)(v7 + (int32_t)&g52); // 0x80893c0
        int32_t v9; // bp-64, 0x8089340
        int32_t v10; // 0x8089340
        *(int32_t *)(v7 + (int32_t)&v9) = v8 + v10;
        int32_t v11 = *(int32_t *)(v7 + (int32_t)&g51); // 0x80893cc
        int32_t v12; // bp-100, 0x8089340
        *(int32_t *)(v7 + (int32_t)&v12) = v11 + hid;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x80894a0 - 0x80898d1
// Line range:    1005 - 1053
void DrawPinOrViaLowLevel(int32_t Ptr, char drawHole) {
    // 0x80894a0
    int32_t v1; // 0x80894a0
    int32_t v2 = v1;
    if (Gathering == 0) {
        int32_t v3 = *(int32_t *)(v2 + 20); // 0x80894c0
        if ((v3 & 8) != 0) {
            // 0x80894cf
            return;
        }
        if ((v3 & 256) != 0) {
            // 0x80894cf
            return;
        }
        if ((v3 & 2048) != 0) {
            int32_t v4 = *(int32_t *)(v2 + 36); // 0x80898ac
            int32_t v5 = *(int32_t *)(v2 + 56); // 0x80898bc
            DrawSpecialPolygon(v5, v4, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
        }
        // 0x80894cf
        return;
    }
    int32_t v6 = Block; // 0x80895ca
    int32_t v7 = v6 - v2; // 0x80895ca
    Block = v7 == 0 | v7 < 0 != ((v7 ^ v6) & (v6 ^ v2)) < 0 ? v6 : v2;
    int32_t v8 = *(int32_t *)(v2 + 8); // 0x80895dc
    int32_t v9 = g55; // 0x80895df
    int32_t v10 = v9 - v8; // 0x80895df
    g55 = v10 < 0 == ((v10 ^ v9) & (v9 ^ v8)) < 0 ? v9 : v8;
    int32_t v11 = *(int32_t *)(v2 + 4); // 0x80895f1
    int32_t v12 = g54; // 0x80895f4
    int32_t v13 = v12 - v11; // 0x80895f4
    g54 = v13 == 0 | v13 < 0 != ((v13 ^ v12) & (v12 ^ v11)) < 0 ? v12 : v11;
    int32_t v14 = *(int32_t *)(v2 + 12); // 0x8089606
    int32_t v15 = g56; // 0x8089609
    int32_t v16 = v15 - v14; // 0x8089609
    g56 = v16 < 0 == ((v16 ^ v15) & (v15 ^ v14)) < 0 ? v15 : v14;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x8089ca0 - 0x8089d9a
// Line range:    1569 - 1579
void DrawLineLowLevel(int32_t Line, char HaveGathered) {
    // 0x8089ca0
    int32_t v1; // 0x8089ca0
    int32_t v2 = v1;
    if ((char)v1 != 0 || Gathering == 0) {
        // 0x8089d4a
        return;
    }
    int32_t v3 = Block; // 0x8089cb8
    int32_t v4 = v3 - v2; // 0x8089cb8
    Block = v4 == 0 | v4 < 0 != ((v4 ^ v3) & (v3 ^ v2)) < 0 ? v3 : v2;
    int32_t v5 = *(int32_t *)(v2 + 8); // 0x8089cca
    int32_t v6 = g55; // 0x8089ccd
    int32_t v7 = v6 - v5; // 0x8089ccd
    g55 = v7 < 0 == ((v7 ^ v6) & (v6 ^ v5)) < 0 ? v6 : v5;
    int32_t v8 = *(int32_t *)(v2 + 4); // 0x8089cdf
    int32_t v9 = g54; // 0x8089ce2
    int32_t v10 = v9 - v8; // 0x8089ce2
    g54 = v10 == 0 | v10 < 0 != ((v10 ^ v9) & (v9 ^ v8)) < 0 ? v9 : v8;
    int32_t v11 = *(int32_t *)(v2 + 12); // 0x8089cf4
    int32_t v12 = g56; // 0x8089cf7
    int32_t v13 = v12 - v11; // 0x8089cf7
    g56 = v13 < 0 == ((v13 ^ v12) & (v12 ^ v11)) < 0 ? v12 : v11;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x8089da0 - 0x8089eb5
// Line range:    1699 - 1710
void DrawArcLowLevel(int32_t Arc) {
    // 0x8089da0
    int32_t v1; // 0x8089da0
    int32_t v2 = *(int32_t *)(v1 + 36); // 0x8089da9
    if (v2 == 0 || Gathering == 0) {
        // 0x8089e2f
        return;
    }
    int32_t v3 = Block; // 0x8089e3a
    int32_t v4 = v3 - v2; // 0x8089e3a
    Block = v4 == 0 | v4 < 0 != ((v4 ^ v3) & (v3 ^ v2)) < 0 ? v3 : v2;
    int32_t v5 = *(int32_t *)(v1 + 8); // 0x8089e4c
    int32_t v6 = g55; // 0x8089e4f
    int32_t v7 = v6 - v5; // 0x8089e4f
    g55 = v7 < 0 == ((v7 ^ v6) & (v6 ^ v5)) < 0 ? v6 : v5;
    int32_t v8 = *(int32_t *)(v1 + 4); // 0x8089e61
    int32_t v9 = g54; // 0x8089e64
    int32_t v10 = v9 - v8; // 0x8089e64
    g54 = v10 == 0 | v10 < 0 != ((v10 ^ v9) & (v9 ^ v8)) < 0 ? v9 : v8;
    int32_t v11 = *(int32_t *)(v1 + 12); // 0x8089e76
    int32_t v12 = g56; // 0x8089e79
    int32_t v13 = v12 - v11; // 0x8089e79
    g56 = v13 < 0 == ((v13 ^ v12) & (v12 ^ v11)) < 0 ? v12 : v11;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x8089ec0 - 0x8089f1d
// Line range:    1882 - 1894
void DrawLine(int32_t Layer2, int32_t Line, int32_t unused) {
    // 0x8089ec0
    int32_t v1; // 0x8089ec0
    DrawLineLowLevel(v1, (char)v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x8089f50 - 0x808a0f5
// Line range:    1903 - 1915
void DrawRat(int32_t Line, int32_t unused) {
    // 0x8089f50
    if (g130 <= 19) {
        // 0x8089fa4
        *(int32_t *)(Line + 36) = pixel_slop * g130;
    }
    // 0x8089fae
    if ((*(char *)(Line + 20) & 2) == 0) {
        // 0x808a0a0
        int32_t v1; // 0x8089f50
        DrawLineLowLevel(v1, (char)v1);
        return;
    }
    // 0x8089fb8
    if (Gathering != 0) {
        int32_t v2 = *(int32_t *)(Line + 36); // 0x8089fbf
        int32_t v3 = *(int32_t *)(Line + 44); // 0x808a032
        int32_t v4 = *(int32_t *)(Line + 48); // 0x808a042
        int32_t v5 = Block; // 0x808a045
        int32_t v6 = (v2 + (int32_t)(v2 < 0)) / 2 + 2 * v2;
        int32_t v7 = v3 - v6; // 0x808a052
        int32_t v8 = v7 - v5; // 0x808a055
        Block = v8 == 0 | v8 < 0 != ((v8 ^ v7) & (v5 ^ v7)) < 0 ? v7 : v5;
        int32_t v9 = g55; // 0x808a060
        int32_t v10 = v3 + v6; // 0x808a066
        int32_t v11 = v10 - v9; // 0x808a069
        int32_t v12 = v4 - v6; // 0x808a06e
        g55 = v11 < 0 == ((v11 ^ v10) & (v9 ^ v10)) < 0 ? v10 : v9;
        int32_t v13 = g54; // 0x808a076
        int32_t v14 = v4 + v6; // 0x808a07c
        int32_t v15 = v12 - v13; // 0x808a07f
        g54 = v15 < 0 == ((v15 ^ v12) & (v13 ^ v12)) < 0 == (v15 != 0) ? v13 : v12;
        int32_t v16 = g56; // 0x808a089
        int32_t v17 = v14 - v16; // 0x808a08e
        g56 = v17 < 0 == ((v17 ^ v14) & (v16 ^ v14)) < 0 ? v14 : v16;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808a120 - 0x808a18d
// Line range:    1952 - 1966
void DrawArc(int32_t Layer2, int32_t Arc, int32_t unused) {
    // 0x808a120
    if (*(int32_t *)(Arc + 36) == 0) {
        // 0x808a178
        return;
    }
    // 0x808a134
    int32_t v1; // 0x808a120
    DrawArcLowLevel(v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808af00 - 0x808b7e6
// Line range:    1341 - 1459
void DrawPadLowLevel(int32_t gc, int32_t Pad, char clear, char mask) {
    // 0x808af00
    int32_t v1; // 0x808af00
    int32_t v2 = v1;
    int3_t v3; // 0x808af00
    int3_t v4 = v3;
    int32_t v5; // 0x808af00
    int32_t v6; // 0x808af00
    if ((char)v1 == 0) {
        // 0x808af90
        v6 = *(int32_t *)(v2 + 36);
        goto lab_0x808af93;
    } else {
        if ((char)gc == 0) {
            // 0x808b2e8
            v6 = *(int32_t *)(v2 + 36) + *(int32_t *)(v2 + 40);
            goto lab_0x808af93;
        } else {
            // 0x808af20
            v5 = *(int32_t *)(v2 + 84);
            if (Gathering == 0) {
                goto lab_0x808af9c;
            } else {
                goto lab_0x808af2c;
            }
        }
    }
  lab_0x808af93:
    // 0x808af93
    v5 = v6;
    if (Gathering != 0) {
        goto lab_0x808af2c;
    } else {
        goto lab_0x808af9c;
    }
  lab_0x808af2c:;
    int32_t v7 = Block; // 0x808af2e
    int32_t v8 = v7 - v2; // 0x808af2e
    Block = v8 == 0 | v8 < 0 != ((v8 ^ v7) & (v7 ^ v2)) < 0 ? v7 : v2;
    int32_t v9 = *(int32_t *)(v2 + 8); // 0x808af40
    int32_t v10 = g55; // 0x808af43
    int32_t v11 = v10 - v9; // 0x808af43
    g55 = v11 < 0 == ((v11 ^ v10) & (v10 ^ v9)) < 0 ? v10 : v9;
    int32_t v12 = *(int32_t *)(v2 + 4); // 0x808af55
    int32_t v13 = g54; // 0x808af58
    int32_t v14 = v13 - v12; // 0x808af58
    g54 = v14 == 0 | v14 < 0 != ((v14 ^ v13) & (v13 ^ v12)) < 0 ? v13 : v12;
    int32_t v15 = *(int32_t *)(v2 + 12); // 0x808af6a
    int32_t v16 = g56; // 0x808af6d
    int32_t v17 = v16 - v15; // 0x808af6d
    g56 = v17 < 0 == ((v17 ^ v16) & (v16 ^ v15)) < 0 ? v16 : v15;
  lab_0x808af9c:;
    int32_t v18 = v5;
    int32_t v19 = *(int32_t *)(PCB + 4); // 0x808afa2
    if ((v19 & 0x4000) == 0) {
        if ((char)v1 == 0) {
            // 0x808b2d8
            return;
        }
        if ((v19 & 0x20000) == 0) {
            // 0x808b2d8
            return;
        }
    }
    int32_t v20 = *(int32_t *)(v2 + 64); // 0x808afb0
    int32_t v21 = *(int32_t *)(v2 + 44); // 0x808afb6
    int32_t v22 = (v18 + (int32_t)(v18 < 0)) / 2; // 0x808afbb
    int32_t v23 = *(int32_t *)(v2 + 48); // 0x808afc2
    int32_t v24 = *(int32_t *)(v2 + 68); // 0x808afc8
    bool v25 = v21 > v20 | v23 > v24;
    int32_t v26 = v25 ? v23 : v24;
    int32_t v27 = v25 ? v21 : v20;
    int32_t v28 = v25 ? v24 : v23;
    int32_t v29 = v25 ? v20 : v21;
    if (*(char *)(v2 + 21) % 2 == 0) {
        if (v26 == v28 || v27 == v29) {
            // 0x808b2d8
            return;
        }
        int32_t v30 = v27 - v29; // 0x808b35a
        int3_t v31 = v4 - 1;
        __frontend_reg_store_fpr(v31, (float80_t)v30);
        int32_t v32 = v26 - v28; // 0x808b365
        int3_t v33 = v4 - 2;
        __frontend_reg_store_fpr(v33, (float80_t)v32);
        int3_t v34 = v4 - 3;
        __frontend_reg_store_fpr(v34, __frontend_reg_load_fpr(v31));
        __frontend_reg_store_fpr(v34, __frontend_reg_load_fpr(v34) * __frontend_reg_load_fpr(v31));
        int3_t v35 = v4 ^ -4; // 0x808b377
        __frontend_reg_store_fpr(v35, __frontend_reg_load_fpr(v33));
        __frontend_reg_store_fpr(v35, __frontend_reg_load_fpr(v35) * __frontend_reg_load_fpr(v33));
        __frontend_reg_store_fpr(v34, __frontend_reg_load_fpr(v35) + __frontend_reg_load_fpr(v34));
        __frontend_reg_store_fpr(v34, sqrtl(__frontend_reg_load_fpr(v34)));
        __frontend_reg_store_fpr(v35, (float80_t)v22);
        __frontend_reg_store_fpr(v34, __frontend_reg_load_fpr(v35) / __frontend_reg_load_fpr(v34));
        __frontend_reg_store_fpr(v34, __frontend_reg_load_fpr(v34));
        if (v32 < 1) {
            if (v32 == 0) {
                // 0x808b700
                __frontend_reg_store_fpr(v35, 0.0L);
            } else {
                // 0x808b63e
                __frontend_reg_store_fpr(v35, -0.5L);
            }
        } else {
            // 0x808b390
            __frontend_reg_store_fpr(v35, 0.5L);
        }
        int3_t v36 = v4 + 3; // 0x808b399
        __frontend_reg_store_fpr(v36, __frontend_reg_load_fpr(v33));
        __frontend_reg_store_fpr(v36, __frontend_reg_load_fpr(v36) * __frontend_reg_load_fpr(v34));
        __frontend_reg_store_fpr(v35, __frontend_reg_load_fpr(v36) + __frontend_reg_load_fpr(v35));
        float80_t v37 = __frontend_reg_load_fpr(v35); // 0x808b3b0
        if (v30 < 1) {
            if (v30 == 0) {
                // 0x808b6f0
                __frontend_reg_store_fpr(v35, 0.0L);
                float80_t v38 = __frontend_reg_load_fpr(v35); // 0x808b6f2
                __frontend_reg_store_fpr(v35, __frontend_reg_load_fpr(v34));
                __frontend_reg_store_fpr(v34, v38);
            } else {
                // 0x808b626
                __frontend_reg_store_fpr(v35, -0.5L);
                float80_t v39 = __frontend_reg_load_fpr(v35); // 0x808b62c
                __frontend_reg_store_fpr(v35, __frontend_reg_load_fpr(v34));
                __frontend_reg_store_fpr(v34, v39);
            }
        } else {
            // 0x808b3bf
            __frontend_reg_store_fpr(v35, 0.5L);
            float80_t v40 = __frontend_reg_load_fpr(v35); // 0x808b3c5
            __frontend_reg_store_fpr(v35, __frontend_reg_load_fpr(v34));
            __frontend_reg_store_fpr(v34, v40);
        }
        int32_t v41 = v37; // 0x808b3b0
        __frontend_reg_store_fpr(v35, __frontend_reg_load_fpr(v35) * __frontend_reg_load_fpr(v31));
        __frontend_reg_store_fpr(v34, __frontend_reg_load_fpr(v35) + __frontend_reg_load_fpr(v34));
        __frontend_reg_store_fpr(v34, -__frontend_reg_load_fpr(v34));
        float80_t v42 = __frontend_reg_load_fpr(v34); // 0x808b3d0
        float80_t v43 = __frontend_reg_load_fpr(v33); // 0x808b3d6
        __frontend_reg_store_fpr(v33, __frontend_reg_load_fpr(v31));
        __frontend_reg_store_fpr(v31, v43);
        float80_t v44 = __frontend_reg_load_fpr(v33); // 0x808b405
        float80_t v45 = __frontend_reg_load_fpr(v31); // 0x808b408
        __frontend_reg_store_fpr(v31, v44);
        __frontend_reg_store_fpr(v33, v45);
        if ((v41 < 0 ? -v41 : v41) < pixel_slop) {
            int32_t v46 = v42; // 0x808b3d0
            if (pixel_slop > (v46 < 0 ? -v46 : v46)) {
                // 0x808b2d0
                __frontend_reg_store_fpr(v33, __frontend_reg_load_fpr(v33));
                __frontend_reg_store_fpr(v31, __frontend_reg_load_fpr(v31));
                // 0x808b2d8
                return;
            }
        }
        // 0x808b453
        __frontend_reg_load_fpr(v33);
        atan2((float64_t)__frontend_reg_load_fpr(v31), (float64_t)(int64_t)&g231);
        __frontend_reg_store_fpr(v4, 57.295779L * __frontend_reg_load_fpr(v4));
        __frontend_reg_load_fpr(v4);
        // 0x808b2d8
        return;
    }
    if (v26 != v28 && v27 != v29) {
        int3_t v47 = v4 - 1; // 0x808b041
        __frontend_reg_store_fpr(v47, (float80_t)(v27 - v29));
        __frontend_reg_load_fpr(v47);
        __frontend_reg_store_fpr(v47, (float80_t)(v26 - v28));
        atan2((float64_t)__frontend_reg_load_fpr(v47), (float64_t)(int64_t)&g231);
        __frontend_reg_store_fpr(v47, (float80_t)v22);
        float80_t v48 = __frontend_reg_load_fpr(v47); // 0x808b06a
        __frontend_reg_store_fpr(v47, __frontend_reg_load_fpr(v4));
        __frontend_reg_store_fpr(v4, v48);
        __frontend_reg_store_fpr(v47, __frontend_reg_load_fpr(v47));
        int3_t v49 = v4 - 2; // 0x808b07a
        __frontend_reg_store_fpr(v49, 0.785398163397448278999L);
        __frontend_reg_store_fpr(v47, __frontend_reg_load_fpr(v49) + __frontend_reg_load_fpr(v47));
        __frontend_reg_load_fpr(v47);
        float80_t v50 = __frontend_reg_load_fpr(v4); // 0x808b085
        function_8060d88(v50);
        float64_t v51; // 0x808af00
        __frontend_reg_store_fpr(v4, (float80_t)v51);
        __frontend_reg_store_fpr(v47, v50);
        __frontend_reg_store_fpr(v49, (float80_t)v51);
        __frontend_reg_store_fpr(v49, __frontend_reg_load_fpr(v49) * __frontend_reg_load_fpr(v47));
        int3_t v52 = v4 - 3; // 0x808b0ab
        __frontend_reg_store_fpr(v52, 1.41421356237309514547L);
        __frontend_reg_store_fpr(v49, __frontend_reg_load_fpr(v49) * __frontend_reg_load_fpr(v52));
        float80_t v53 = __frontend_reg_load_fpr(v52); // 0x808b0b3
        __frontend_reg_store_fpr(v52, __frontend_reg_load_fpr(v49));
        __frontend_reg_store_fpr(v49, v53);
        __frontend_reg_store_fpr(v52, __frontend_reg_load_fpr(v52));
        float80_t v54 = __frontend_reg_load_fpr(v52); // 0x808b0c1
        __frontend_reg_store_fpr(v52, __frontend_reg_load_fpr(v4));
        __frontend_reg_store_fpr(v4, v54);
        __frontend_reg_store_fpr(v47, __frontend_reg_load_fpr(v52) * __frontend_reg_load_fpr(v47));
        __frontend_reg_store_fpr(v47, __frontend_reg_load_fpr(v49) * __frontend_reg_load_fpr(v47));
        __frontend_reg_store_fpr(v47, __frontend_reg_load_fpr(v47));
        __frontend_reg_store_fpr(v49, (float80_t)v26);
        __frontend_reg_store_fpr(v52, __frontend_reg_load_fpr(v49));
        __frontend_reg_store_fpr(v52, __frontend_reg_load_fpr(v52) - __frontend_reg_load_fpr(v4));
        __frontend_reg_load_fpr(v52);
        __frontend_reg_store_fpr(v52, (float80_t)v27);
        int3_t v55 = v4 ^ -4; // 0x808b0e3
        __frontend_reg_store_fpr(v55, __frontend_reg_load_fpr(v52));
        __frontend_reg_store_fpr(v55, __frontend_reg_load_fpr(v55) + __frontend_reg_load_fpr(v47));
        __frontend_reg_load_fpr(v55);
        __frontend_reg_store_fpr(v55, (float80_t)v28);
        int3_t v56 = v4 + 3; // 0x808b0f9
        __frontend_reg_store_fpr(v56, __frontend_reg_load_fpr(v55));
        __frontend_reg_store_fpr(v56, __frontend_reg_load_fpr(v56) - __frontend_reg_load_fpr(v47));
        __frontend_reg_load_fpr(v56);
        __frontend_reg_store_fpr(v56, (float80_t)v29);
        int3_t v57 = v4 + 2; // 0x808b10c
        __frontend_reg_store_fpr(v57, __frontend_reg_load_fpr(v56));
        __frontend_reg_store_fpr(v57, __frontend_reg_load_fpr(v57) - __frontend_reg_load_fpr(v4));
        __frontend_reg_load_fpr(v57);
        float80_t v58 = __frontend_reg_load_fpr(v56); // 0x808b119
        __frontend_reg_store_fpr(v56, __frontend_reg_load_fpr(v47));
        __frontend_reg_store_fpr(v47, v58);
        float80_t v59 = __frontend_reg_load_fpr(v56); // 0x808b134
        float80_t v60 = __frontend_reg_load_fpr(v55); // 0x808b137
        __frontend_reg_store_fpr(v55, __frontend_reg_load_fpr(v4));
        __frontend_reg_store_fpr(v4, v60);
        float80_t v61 = __frontend_reg_load_fpr(v55); // 0x808b13e
        float80_t v62 = __frontend_reg_load_fpr(v52); // 0x808b141
        __frontend_reg_store_fpr(v52, __frontend_reg_load_fpr(v47));
        __frontend_reg_store_fpr(v47, v62);
        float80_t v63 = __frontend_reg_load_fpr(v52); // 0x808b143
        float80_t v64 = __frontend_reg_load_fpr(v49); // 0x808b149
        __frontend_reg_store_fpr(v49, __frontend_reg_load_fpr(v4));
        __frontend_reg_store_fpr(v4, v64);
        float80_t v65 = __frontend_reg_load_fpr(v49); // 0x808b14b
        float80_t v66 = __frontend_reg_load_fpr(v47); // 0x808b151
        float80_t v67 = __frontend_reg_load_fpr(v4); // 0x808b157
        __frontend_reg_store_fpr(v4, v59);
        __frontend_reg_store_fpr(v47, v67);
        __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v47) + __frontend_reg_load_fpr(v4));
        __frontend_reg_load_fpr(v4);
        __frontend_reg_store_fpr(v4, v61);
        __frontend_reg_store_fpr(v47, v66);
        __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v47) + __frontend_reg_load_fpr(v4));
        __frontend_reg_load_fpr(v4);
        __frontend_reg_store_fpr(v4, v61);
        __frontend_reg_store_fpr(v47, v65);
        __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v47) + __frontend_reg_load_fpr(v4));
        __frontend_reg_load_fpr(v4);
        __frontend_reg_store_fpr(v4, v59);
        __frontend_reg_store_fpr(v47, v63);
        __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v47) - __frontend_reg_load_fpr(v4));
        __frontend_reg_load_fpr(v4);
    }
    // 0x808b2d8
    return;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808ba50 - 0x808bba9
// Line range:    2022 - 105
void DrawPolygon(int32_t Layer2, int32_t Polygon2, int32_t unused) {
    // 0x808ba50
    GetLayerNumber(*(int32_t *)(PCB + 0x220c), Layer2);
    if (*(int32_t *)(Polygon2 + 44) != 0) {
        // 0x808baab
        if (Gathering == 0) {
            // 0x808bb90
            __printf_chk(1, "DrawPolygonLowLevel: Called without Gathering set!\n");
        } else {
            int32_t v1 = *(int32_t *)Polygon2; // 0x808bab8
            int32_t v2 = Block; // 0x808baba
            int32_t v3 = v2 - v1; // 0x808baba
            Block = v3 == 0 | v3 < 0 != ((v3 ^ v2) & (v2 ^ v1)) < 0 ? v2 : v1;
            int32_t v4 = *(int32_t *)(Polygon2 + 8); // 0x808bacc
            int32_t v5 = g55; // 0x808bacf
            int32_t v6 = v5 - v4; // 0x808bacf
            g55 = v6 < 0 == ((v6 ^ v5) & (v5 ^ v4)) < 0 ? v5 : v4;
            int32_t v7 = *(int32_t *)(Polygon2 + 4); // 0x808bae1
            int32_t v8 = g54; // 0x808bae4
            int32_t v9 = v8 - v7; // 0x808bae4
            g54 = v9 == 0 | v9 < 0 != ((v9 ^ v8) & (v8 ^ v7)) < 0 ? v8 : v7;
            int32_t v10 = *(int32_t *)(Polygon2 + 12); // 0x808baf6
            int32_t v11 = g56; // 0x808baf9
            int32_t v12 = v11 - v10; // 0x808baf9
            g56 = v12 < 0 == ((v12 ^ v11) & (v11 ^ v10)) < 0 ? v11 : v10;
        }
    }
    // 0x808bb0b
    if ((*(char *)(Polygon2 + 20) & 16) != 0) {
        int32_t v13 = *(int32_t *)(PCB + 0x220c); // 0x808bb32
        r_search(*(int32_t *)(v13 + 48), Polygon2, 0, 0x808a1c0, (char *)256);
        int32_t v14 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 40); // 0x808bb6a
        r_search(v14, Polygon2, 0, 0x808a1c0, (char *)1);
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808bbb0 - 0x808bfa0
// Line range:    1592 - 1675
void DrawTextLowLevel(int32_t Text, int32_t min_line_width) {
    int32_t v1 = __readgsdword(20); // 0x808bbc5
    if (Gathering != 0) {
        int32_t v2 = *(int32_t *)Text; // 0x808bf35
        int32_t v3 = Block; // 0x808bf37
        int32_t v4 = v3 - v2; // 0x808bf37
        Block = v4 == 0 | v4 < 0 != ((v4 ^ v3) & (v3 ^ v2)) < 0 ? v3 : v2;
        int32_t v5 = *(int32_t *)(Text + 8); // 0x808bf49
        int32_t v6 = g55; // 0x808bf4c
        int32_t v7 = v6 - v5; // 0x808bf4c
        g55 = v7 < 0 == ((v7 ^ v6) & (v6 ^ v5)) < 0 ? v6 : v5;
        int32_t v8 = *(int32_t *)(Text + 4); // 0x808bf5e
        int32_t v9 = g54; // 0x808bf61
        int32_t v10 = v9 - v8; // 0x808bf61
        g54 = v10 == 0 | v10 < 0 != ((v10 ^ v9) & (v9 ^ v8)) < 0 ? v9 : v8;
        int32_t v11 = *(int32_t *)(Text + 12); // 0x808bf73
        int32_t v12 = g56; // 0x808bf76
        int32_t v13 = v12 - v11; // 0x808bf76
        g56 = v13 < 0 == ((v13 ^ v12) & (v12 ^ v11)) < 0 ? v12 : v11;
    } else {
        int32_t v14 = *(int32_t *)(Text + 52); // 0x808bbd7
        if (v14 != 0) {
            char * v15 = (char *)v14; // 0x808bbe8
            char v16 = *v15; // 0x808bbf4
            if (v16 != 0) {
                int32_t v17 = 0x1000000 * PCB / 0x1000000; // 0x808bc1e
                int32_t * v18 = (int32_t *)(Text + 36);
                char * v19 = (char *)(Text + 48);
                int32_t * v20 = (int32_t *)(Text + 40);
                int32_t v21; // bp-136, 0x808bbb0
                int32_t v22 = &v21;
                int64_t v23; // 0x808bbb0
                int32_t v24 = v23;
                int32_t v25 = 0;
                int32_t v26 = 28 * (int32_t)v16 + v17;
                int32_t v27; // 0x808bbb0
                int32_t v28; // 0x808bbb0
                int32_t v29; // bp-120, 0x808bbb0
                int32_t v30; // 0x808bbb0
                int32_t v31; // 0x808bbb0
                int32_t v32; // 0x808bbb0
                int32_t v33; // 0x808bbb0
                int32_t v34; // 0x808bbb0
                int32_t v35; // 0x808bbb0
                int32_t v36; // 0x808bbb0
                int32_t v37; // 0x808bbb0
                int32_t v38; // 0x808bdfa
                int32_t v39; // 0x808bf1d
                int32_t v40; // 0x808bc37
                int32_t v41; // 0x808bdad
                int32_t v42; // 0x808bcb5
                int32_t v43; // 0x808bce8
                int32_t v44; // 0x808bc64
                int32_t v45; // 0x808bc6c
                int32_t v46; // 0x808bc82
                if (*(char *)(v26 + 212) == 0) {
                    // 0x808bdf0
                    v38 = *(int32_t *)(PCB + 192);
                    v21 = v38;
                    v21 = *v18 * (v38 + v25) / 100;
                    RotateBoxLowLevel(v22, 0, 0, *v19);
                    v21 += *v20;
                    v39 = 6 * (*(int32_t *)(PCB + 200) - v38);
                    v36 = v33;
                    v32 = v24;
                    v37 = v25 + (int32_t)(v39 < 0) + (int32_t)(0x66666667 * (int64_t)v39 / 0x100000000) / 2;
                } else {
                    // 0x808bc31
                    v40 = *(int32_t *)(v26 + 216);
                    v27 = v26;
                    v35 = v33;
                    v31 = v24;
                    if (v40 != 0) {
                        // 0x808bc96
                        v28 = *(int32_t *)(v26 + 208);
                        v46 = v40;
                        __asm_rep_movsd_memcpy((char *)&v29, (char *)v28, 22);
                        v42 = *v18;
                        v43 = v42 * v24 / 100;
                        RotateLineLowLevel((int32_t)&v29, 0, 0, *v19);
                        v44 = v42 * (v33 + v25) / 100 + *v20;
                        v45 = (*(char *)(Text + 20) >= 0 ? v43 : -v43) + *(int32_t *)(Text + 44);
                        DrawLineLowLevel(v44, (char)v45);
                        v46--;
                        v28 += 88;
                        v34 = v44;
                        v30 = v45;
                        while (v46 != 0) {
                            // 0x808bc96
                            __asm_rep_movsd_memcpy((char *)&v29, (char *)v28, 22);
                            v42 = *v18;
                            v43 = v42 * v30 / 100;
                            RotateLineLowLevel((int32_t)&v29, 0, 0, *v19);
                            v44 = v42 * (v34 + v25) / 100 + *v20;
                            v45 = (*(char *)(Text + 20) >= 0 ? v43 : -v43) + *(int32_t *)(Text + 44);
                            DrawLineLowLevel(v44, (char)v45);
                            v46--;
                            v28 += 88;
                            v34 = v44;
                            v30 = v45;
                        }
                        // 0x808bd88
                        v27 = 28 * (int32_t)*v15 + v17;
                        v35 = v44;
                        v31 = v45;
                    }
                    // 0x808bd88
                    v41 = *(int32_t *)(v27 + 224);
                    v36 = v35;
                    v32 = v31;
                    v37 = *(int32_t *)(v27 + 232) + v25 + v41;
                }
                int32_t v47 = (int32_t)v15 + 1; // 0x808bdba
                while (v47 != 0) {
                    char * v48 = (char *)v47; // 0x808bdba
                    char v49 = *v48; // 0x808bdc9
                    if (v49 == 0) {
                        // break -> 0x808bdd4
                        break;
                    }
                    v24 = v32;
                    int32_t v50 = v36;
                    v25 = v37;
                    char * v51 = v48;
                    v26 = 28 * (int32_t)v49 + v17;
                    if (*(char *)(v26 + 212) == 0) {
                        // 0x808bdf0
                        v38 = *(int32_t *)(PCB + 192);
                        v21 = v38;
                        v21 = *v18 * (v38 + v25) / 100;
                        RotateBoxLowLevel(v22, 0, 0, *v19);
                        v21 += *v20;
                        v39 = 6 * (*(int32_t *)(PCB + 200) - v38);
                        v36 = v50;
                        v32 = v24;
                        v37 = v25 + (int32_t)(v39 < 0) + (int32_t)(0x66666667 * (int64_t)v39 / 0x100000000) / 2;
                    } else {
                        // 0x808bc31
                        v40 = *(int32_t *)(v26 + 216);
                        v27 = v26;
                        v35 = v50;
                        v31 = v24;
                        if (v40 != 0) {
                            // 0x808bc96
                            v28 = *(int32_t *)(v26 + 208);
                            v46 = v40;
                            __asm_rep_movsd_memcpy((char *)&v29, (char *)v28, 22);
                            v42 = *v18;
                            v43 = v42 * v24 / 100;
                            RotateLineLowLevel((int32_t)&v29, 0, 0, *v19);
                            v44 = v42 * (v50 + v25) / 100 + *v20;
                            v45 = (*(char *)(Text + 20) >= 0 ? v43 : -v43) + *(int32_t *)(Text + 44);
                            DrawLineLowLevel(v44, (char)v45);
                            v46--;
                            v28 += 88;
                            v34 = v44;
                            v30 = v45;
                            while (v46 != 0) {
                                // 0x808bc96
                                __asm_rep_movsd_memcpy((char *)&v29, (char *)v28, 22);
                                v42 = *v18;
                                v43 = v42 * v30 / 100;
                                RotateLineLowLevel((int32_t)&v29, 0, 0, *v19);
                                v44 = v42 * (v34 + v25) / 100 + *v20;
                                v45 = (*(char *)(Text + 20) >= 0 ? v43 : -v43) + *(int32_t *)(Text + 44);
                                DrawLineLowLevel(v44, (char)v45);
                                v46--;
                                v28 += 88;
                                v34 = v44;
                                v30 = v45;
                            }
                            // 0x808bd88
                            v27 = 28 * (int32_t)*v51 + v17;
                            v35 = v44;
                            v31 = v45;
                        }
                        // 0x808bd88
                        v41 = *(int32_t *)(v27 + 224);
                        v36 = v35;
                        v32 = v31;
                        v37 = *(int32_t *)(v27 + 232) + v25 + v41;
                    }
                    // 0x808bdba
                    v47 = (int32_t)v51 + 1;
                }
            }
        }
    }
    // 0x808bdd4
    if (v1 == __readgsdword(20)) {
        // 0x808bde4
        return;
    }
    // 0x808bf8d
    __stack_chk_fail();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808c060 - 0x808c250
// Line range:    1277 - 1334
void DrawPinOrViaNameLowLevel(int32_t Ptr) {
    int32_t v1 = __readgsdword(20); // 0x808c06c
    int32_t v2; // 0x808c060
    int32_t v3; // 0x808c060
    int32_t v4; // 0x808c060
    if ((*(int32_t *)(v4 + 20) & 0x4000) == 0) {
        int32_t v5 = *(int32_t *)(v4 + 48); // 0x808c138
        int32_t v6 = *(int32_t *)(v4 + 52); // 0x808c141
        int32_t v7 = *(int32_t *)(v4 + 36); // 0x808c156
        v2 = *(int32_t *)(v4 + 56) + g159 - (v7 + (int32_t)(v7 < 0)) / 2;
        v3 = v6 + g158 + (v5 + (int32_t)(v5 < 0)) / 2;
        if (Gathering != 0) {
            goto lab_0x808c0e2;
        } else {
            goto lab_0x808c175;
        }
    } else {
        int32_t v8 = *(int32_t *)(v4 + 36); // 0x808c0a6
        int32_t v9 = *(int32_t *)(v4 + 52); // 0x808c0af
        int32_t v10 = *(int32_t *)(v4 + 48); // 0x808c0be
        int32_t v11 = *(int32_t *)(v4 + 56); // 0x808c0d2
        v2 = v11 - g158 - (v10 + (int32_t)(v10 < 0)) / 2;
        v3 = v9 + g159 - (v8 + (int32_t)(v8 < 0)) / 2;
        if (Gathering == 0) {
            goto lab_0x808c175;
        } else {
            goto lab_0x808c0e2;
        }
    }
  lab_0x808c0e2:;
    int32_t v12 = v3;
    int32_t v13 = v2;
    int32_t v14 = Block; // 0x808c0e2
    int32_t v15 = v12 - v14; // 0x808c0e7
    int32_t v16 = v15 == 0 | v15 < 0 != ((v15 ^ v12) & (v14 ^ v12)) < 0 ? v12 : v14; // 0x808c0e9
    Block = v16;
    int32_t v17 = g55; // 0x808c0f1
    int32_t v18 = v12 - v17; // 0x808c0f6
    int32_t v19 = v18 < 0 == ((v18 ^ v12) & (v17 ^ v12)) < 0 ? v12 : v17; // 0x808c0f8
    int32_t v20 = g54; // 0x808c0fb
    g55 = v19;
    int32_t v21 = v13 - v20; // 0x808c106
    int32_t v22 = v21 == 0 | v21 < 0 != ((v21 ^ v13) & (v20 ^ v13)) < 0 ? v13 : v20; // 0x808c108
    g54 = v22;
    int32_t v23 = g56; // 0x808c110
    int32_t v24 = v13 - v23; // 0x808c115
    int32_t v25 = v24 < 0 == ((v24 ^ v13) & (v23 ^ v13)) < 0 ? v13 : v23; // 0x808c117
    g56 = v25;
    goto lab_0x808c120;
  lab_0x808c175:;
    // 0x808c175
    int32_t v26; // bp-108, 0x808c060
    MakeFlags((int32_t)&v26);
    if (g41 % 2 != 0) {
        int32_t v27 = doing_pinout; // 0x808c240
        doing_pinout = v27 + 1;
    }
    // 0x808c1d0
    int32_t v28; // bp-92, 0x808c060
    DrawTextLowLevel((int32_t)&v28, 0);
    if (g41 % 2 != 0) {
        // 0x808c216
        doing_pinout--;
    }
    goto lab_0x808c120;
  lab_0x808c120:
    // 0x808c120
    if (v1 == __readgsdword(20)) {
        // 0x808c130
        return;
    }
    // 0x808c249
    __stack_chk_fail();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808c430 - 0x808c486
// Line range:    1787 - 1794
void DrawPin(int32_t Pin, int32_t unused) {
    // 0x808c430
    if (Gathering == 0) {
        // 0x808c478
        int32_t v1; // 0x808c430
        SetPVColor(v1, v1);
    }
    // 0x808c443
    DrawPinOrViaLowLevel((int32_t)&g231, (char)&g231);
    if ((*(int32_t *)(Pin + 20) & 40) != 32 == doing_pinout == 0) {
        // 0x808c470
        return;
    }
    // 0x808c463
    DrawPinOrViaNameLowLevel((int32_t)&g231);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808c4f0 - 0x808c53c
// Line range:    1742 - 1751
void DrawVia(int32_t Via, int32_t unused) {
    // 0x808c4f0
    if (Gathering == 0) {
        // 0x808c520
        int32_t v1; // 0x808c4f0
        SetPVColor(v1, v1);
    }
    // 0x808c503
    DrawPinOrViaLowLevel((int32_t)&g231, (char)&g231);
    if ((*(int32_t *)(Via + 20) & 40) != 32) {
        // 0x808c51a
        return;
    }
    // 0x808c530
    DrawPinOrViaNameLowLevel((int32_t)&g231);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808c5c0 - 0x808c780
// Line range:    1490 - 1554
void DrawPadNameLowLevel(int32_t Pad) {
    int32_t v1 = __readgsdword(20); // 0x808c5cc
    int32_t v2; // 0x808c5c0
    int32_t v3 = *(int32_t *)(v2 + 44); // 0x808c5f2
    int32_t v4 = *(int32_t *)(v2 + 64); // 0x808c5f5
    int32_t v5 = *(int32_t *)(v2 + 36);
    int32_t v6; // 0x808c5c0
    int32_t v7; // 0x808c5c0
    int32_t v8; // bp-108, 0x808c5c0
    int32_t v9; // bp-92, 0x808c5c0
    if (v4 != v3) {
        int32_t v10 = (v5 + (int32_t)(v5 < 0)) / 2; // 0x808c6a2
        int32_t v11 = v4 - v3; // 0x808c6a6
        int32_t v12 = v11 == 0 | v11 < 0 != ((v11 ^ v4) & (v4 ^ v3)) < 0 ? v4 : v3; // 0x808c6a8
        v7 = v12 - v10 + g158;
        v6 = g159 - v10 + *(int32_t *)(v2 + 48);
        if (Gathering != 0) {
            goto lab_0x808c63c;
        } else {
            // 0x808c6c9
            MakeFlags((int32_t)&v8);
            DrawTextLowLevel((int32_t)&v9, 0);
            goto lab_0x808c67a;
        }
    } else {
        int32_t v13 = (v5 + (int32_t)(v5 < 0)) / 2; // 0x808c616
        int32_t v14 = *(int32_t *)(v2 + 68); // 0x808c61a
        int32_t v15 = *(int32_t *)(v2 + 48); // 0x808c61d
        int32_t v16 = v15 - v14; // 0x808c61d
        v7 = v3 - v13 + g159;
        v6 = v13 - g158 + (v16 < 0 == ((v16 ^ v15) & (v15 ^ v14)) < 0 ? v15 : v14);
        if (Gathering == 0) {
            // 0x808c6c9
            MakeFlags((int32_t)&v8);
            DrawTextLowLevel((int32_t)&v9, 0);
            goto lab_0x808c67a;
        } else {
            goto lab_0x808c63c;
        }
    }
  lab_0x808c63c:;
    int32_t v17 = v6;
    int32_t v18 = v7;
    int32_t v19 = Block; // 0x808c63c
    int32_t v20 = v18 - v19; // 0x808c641
    int32_t v21 = v20 == 0 | v20 < 0 != ((v20 ^ v18) & (v19 ^ v18)) < 0 ? v18 : v19; // 0x808c643
    Block = v21;
    int32_t v22 = g55; // 0x808c64b
    int32_t v23 = v18 - v22; // 0x808c650
    int32_t v24 = v23 < 0 == ((v23 ^ v18) & (v22 ^ v18)) < 0 ? v18 : v22; // 0x808c652
    int32_t v25 = g54; // 0x808c655
    g55 = v24;
    int32_t v26 = v17 - v25; // 0x808c660
    int32_t v27 = v26 == 0 | v26 < 0 != ((v26 ^ v17) & (v25 ^ v17)) < 0 ? v17 : v25; // 0x808c662
    g54 = v27;
    int32_t v28 = g56; // 0x808c66a
    int32_t v29 = v17 - v28; // 0x808c66f
    int32_t v30 = v29 < 0 == ((v29 ^ v17) & (v28 ^ v17)) < 0 ? v17 : v28; // 0x808c671
    g56 = v30;
    goto lab_0x808c67a;
  lab_0x808c67a:
    // 0x808c67a
    if (v1 == __readgsdword(20)) {
        // 0x808c68a
        return;
    }
    // 0x808c76d
    __stack_chk_fail();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808c9b0 - 0x808ca8a
// Line range:    1835 - 1844
void DrawPad(int32_t Pad, int32_t unused) {
    // 0x808c9b0
    DrawPadLowLevel(0, (int32_t)&g231, (char)&g231, (char)&g231);
    if (doing_pinout != 0) {
        // 0x808ca4a
        DrawPadNameLowLevel((int32_t)&g231);
        return;
    }
    // 0x808ca44
    if ((*(char *)(Pad + 20) & 32) == 0) {
        // 0x808ca58
        return;
    }
    // 0x808ca4a
    DrawPadNameLowLevel((int32_t)&g231);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/draw.c
// Address range: 0x808d3d0 - 0x808d452
// Line range:    188 - 203
void Draw(void) {
    // 0x808d3d0
    render = 1;
    HideCrosshair(1);
    RestoreCrosshair(1);
    g56 = 0;
    g55 = 0;
    g54 = 0;
    Block = 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/error.c
// Address range: 0x8090d00 - 0x8090d20
// Line range:    90 - 96
void Message(char * Format, ...) {
    // 0x8090d00
    return;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/error.c
// Address range: 0x8090d20 - 0x8090d97
// Line range:    183 - 195
void MyFatal(char * Format, ...) {
    // 0x8090d20
    EmergencySave();
    __fprintf_chk(g43, 1, "%s (%i): fatal, ", (char *)Progname, getpid());
    int32_t v1; // 0x8090d20
    __vfprintf_chk(g43, 1, Format, (int32_t)&v1);
    fflush(g43);
    exit(1);
    // UNREACHABLE
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/error.c
// Address range: 0x8090e20 - 0x8090e64
// Line range:    143 - 156
void OpendirErrorMessage(char * DirName) {
    char * v1 = __strdup(DirName); // 0x8090e2d
    int32_t err_num = *__errno_location(); // 0x8090e39
    Message("Can't scan directory\n   '%s'\nopendir() returned: '%s'\n", v1, strerror(err_num));
    free((int32_t *)v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/error.c
// Address range: 0x8090e70 - 0x8090eb4
// Line range:    123 - 136
void PopenErrorMessage(char * Filename) {
    char * v1 = __strdup(Filename); // 0x8090e7d
    int32_t err_num = *__errno_location(); // 0x8090e89
    Message("Can't execute command\n   '%s'\npopen() returned: '%s'\n", v1, strerror(err_num));
    free((int32_t *)v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/error.c
// Address range: 0x8090ec0 - 0x8090f04
// Line range:    103 - 116
void OpenErrorMessage(char * Filename) {
    char * v1 = __strdup(Filename); // 0x8090ecd
    int32_t err_num = *__errno_location(); // 0x8090ed9
    Message("Can't open file\n   '%s'\nfopen() returned: '%s'\n", v1, strerror(err_num));
    free((int32_t *)v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8090f10 - 0x8090f40
// Line range:    416 - 426
void PreLoadElementPCB(void) {
    // 0x8090f10
    if (yyPCB != 0) {
        // 0x8090f1c
        yyFont = yyPCB + 184;
        int32_t v1 = *(int32_t *)(yyPCB + 0x220c); // 0x8090f28
        yyData = v1;
        *(int32_t *)(v1 + 72) = yyPCB;
        *(int32_t *)(v1 + 24) = 0;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8090f50 - 0x8090fcb
// Line range:    1008 - 1024
void EnableAutosave(void) {
    // 0x8090f50
    int32_t v1; // 0x8090f50
    backup_timer = g143 < 1 | g42 == 0 ? 0 : v1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8090fd0 - 0x8091040
// Line range:    191 - 198
void sort_library(int32_t lib) {
    // 0x8090fd0
    int32_t nmemb; // 0x8090fd0
    int32_t * base = (int32_t *)(nmemb + 8); // 0x8090ff0
    qsort((int32_t *)*base, nmemb, 28, (int32_t (*)(int32_t *, int32_t *))0x8091820);
    uint32_t v1 = 0; // 0x8091005
    int32_t v2 = 28 * v1 + *base; // 0x809100e
    int32_t base2 = *(int32_t *)(v2 + 20); // 0x8091028
    qsort((int32_t *)base2, *(int32_t *)(v2 + 12), 24, (int32_t (*)(int32_t *, int32_t *))0x8091800);
    while (v1 != (int32_t)&g231 - 1 && v1 < (int32_t)&g231) {
        // 0x8091008
        v1++;
        v2 = 28 * v1 + *base;
        base2 = *(int32_t *)(v2 + 20);
        qsort((int32_t *)base2, *(int32_t *)(v2 + 12), 24, (int32_t (*)(int32_t *, int32_t *))0x8091800);
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8091850 - 0x8091864
// Line range:    1080 - 1083
void RemoveTMPData(void) {
    // 0x8091850
    unlink(TMPFilename);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8091a90 - 0x8091bb0
// Line range:    478 - 513
void WritePCBInfoHeader(struct _IO_FILE * FP) {
    char hostname[256]; // bp-276, 0x8091a90
    char v1[256]; // 0x8091acd
    int32_t t = __readgsdword(20); // 0x8091aaa
    int32_t time_val = time((int32_t *)t); // 0x8091ab5
    v1[0] = time_val;
    hostname = v1;
    int32_t v2; // 0x8091a90
    struct _IO_FILE * v3 = (struct _IO_FILE *)v2;
    __fprintf_chk(v3, 1, "# release: %s 20091103\n", (char *)Progname);
    __fprintf_chk(v3, 1, "# date:    %s", asctime(localtime((int32_t *)&hostname)));
    struct passwd * v4 = getpwuid(getuid()); // 0x8091b1b
    int32_t v5 = *(int32_t *)((int32_t)v4 + 16); // 0x8091b20
    int32_t v6 = *(int32_t *)v4; // 0x8091b27
    __fprintf_chk(v3, 1, "# user:    %s (%s)\n", (char *)v6, (char *)v5);
    int32_t name; // bp-272, 0x8091a90
    int32_t v7; // 0x8091b9b
    if (gethostname((char *)&name, 255) == -1) {
        goto lab_0x8091b81;
    } else {
        // 0x8091b5a
        v7 = g58;
        if (g58 == 0) {
            struct hostent * v8 = gethostbyname((char *)&name); // 0x8091b9b
            v7 = (int32_t)v8;
            g58 = v7;
            if (v8 == NULL) {
                // 0x8091b65
                __fprintf_chk(v3, 1, "# host:    %s\n", (char *)(int32_t)&name);
                goto lab_0x8091b81;
            } else {
                goto lab_0x8091b63;
            }
        } else {
            goto lab_0x8091b63;
        }
    }
  lab_0x8091b81:
    // 0x8091b81
    if (t != __readgsdword(20)) {
        // 0x8091bab
        __stack_chk_fail();
        return;
    }
  lab_0x8091b63:
    // 0x8091b65
    __fprintf_chk(v3, 1, "# host:    %s\n", (char *)*(int32_t *)v7);
    goto lab_0x8091b81;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8091bb0 - 0x8091be0
// Line range:    452 - 458
void PrintQuotedString(struct _IO_FILE * FP, char * S) {
    // 0x8091bb0
    int32_t stream; // 0x8091bb0
    CreateQuotedString((int32_t)&g59, (char *)stream);
    fputs((char *)g60, (struct _IO_FILE *)stream);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8091be0 - 0x8091cb4
// Line range:    613 - 626
void WriteViaData(struct _IO_FILE * FP, int32_t Data) {
    // 0x8091be0
    int32_t v1; // 0x8091be0
    if (v1 == 0) {
        // 0x8091cac
        return;
    }
    struct _IO_FILE * v2 = (struct _IO_FILE *)v1; // 0x8091c3f
    int32_t v3 = 0; // 0x8091c5f
    int32_t v4 = 76 * v3 + *(int32_t *)(v1 + 28); // 0x8091c03
    int32_t v5 = *(int32_t *)(v4 + 48); // 0x8091c09
    int32_t v6 = *(int32_t *)(v4 + 44); // 0x8091c10
    int32_t v7 = *(int32_t *)(v4 + 40); // 0x8091c17
    int32_t v8 = *(int32_t *)(v4 + 36); // 0x8091c1e
    int32_t v9 = *(int32_t *)(v4 + 56); // 0x8091c25
    int32_t v10 = *(int32_t *)(v4 + 52); // 0x8091c2c
    __fprintf_chk(v2, 1, "Via[%i %i %i %i %i %i ", v10, v9, v8, v7, v6, v5);
    PrintQuotedString((struct _IO_FILE *)&g231, (char *)&g231);
    v3++;
    int32_t v11 = *(int32_t *)(v4 + 24); // 0x8091c70
    __fprintf_chk(v2, 1, " %s]\n", flags_to_string(*(int32_t *)(v4 + 20), v11));
    while (*(int32_t *)v1 > v3) {
        // 0x8091c00
        v4 = 76 * v3 + *(int32_t *)(v1 + 28);
        v5 = *(int32_t *)(v4 + 48);
        v6 = *(int32_t *)(v4 + 44);
        v7 = *(int32_t *)(v4 + 40);
        v8 = *(int32_t *)(v4 + 36);
        v9 = *(int32_t *)(v4 + 56);
        v10 = *(int32_t *)(v4 + 52);
        __fprintf_chk(v2, 1, "Via[%i %i %i %i %i %i ", v10, v9, v8, v7, v6, v5);
        PrintQuotedString((struct _IO_FILE *)&g231, (char *)&g231);
        v3++;
        v11 = *(int32_t *)(v4 + 24);
        __fprintf_chk(v2, 1, " %s]\n", flags_to_string(*(int32_t *)(v4 + 20), v11));
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8091cc0 - 0x8092102
// Line range:    774 - 779
void WriteLayerData(struct _IO_FILE * FP, int32_t Number, int32_t layer) {
    // 0x8091cc0
    int32_t v1; // 0x8091cc0
    int32_t v2 = v1;
    int32_t * v3 = (int32_t *)(v2 + 4); // 0x8091ccc
    if (*v3 == 0) {
        // 0x8091cd6
        if (*(int32_t *)(v2 + 16) == 0) {
            // 0x80920d9
            if (*(int32_t *)(v2 + 8) == 0) {
                // 0x80920e4
                if (*(int32_t *)(v2 + 12) == 0) {
                    if (v2 != 0 != (char)v2 != 0) {
                        // 0x80920d1
                        return;
                    }
                }
            }
        }
    }
    struct _IO_FILE * stream = (struct _IO_FILE *)v1;
    __fprintf_chk(stream, 1, "Layer(%i ", v1 + 1);
    PrintQuotedString((struct _IO_FILE *)&g231, (char *)&g231);
    fwrite((int32_t *)")\n(\n", 1, 4, stream);
    int32_t * v4 = (int32_t *)(v2 + 80); // 0x8091d40
    if (*v4 >= 1) {
        int32_t v5 = 0;
        int32_t v6 = v5 + 1; // 0x8091d57
        int32_t v7 = 8 * v5 + *(int32_t *)(v2 + 88); // 0x8091d5a
        int32_t v8 = *(int32_t *)(v7 + 4); // 0x8091d5d
        int32_t v9 = *(int32_t *)v7; // 0x8091d64
        __fprintf_chk(stream, 1, "%sAttribute(\"%s\" \"%s\")\n", (char *)&g4, (char *)v9, (char *)v8);
        while (v6 < *v4) {
            // 0x8091d50
            v5 = v6;
            v6 = v5 + 1;
            v7 = 8 * v5 + *(int32_t *)(v2 + 88);
            v8 = *(int32_t *)(v7 + 4);
            v9 = *(int32_t *)v7;
            __fprintf_chk(stream, 1, "%sAttribute(\"%s\" \"%s\")\n", (char *)&g4, (char *)v9, (char *)v8);
        }
    }
    // 0x8091d8f
    if (*v3 != 0) {
        int32_t v10 = 0;
        int32_t v11 = v10 + 1; // 0x8091dab
        int32_t v12 = 88 * v10 + *(int32_t *)(v2 + 36); // 0x8091dae
        char * v13 = flags_to_string(*(int32_t *)(v12 + 20), *(int32_t *)(v12 + 24)); // 0x8091dcd
        int32_t v14 = *(int32_t *)(v12 + 40); // 0x8091dd6
        int32_t v15 = *(int32_t *)(v12 + 36); // 0x8091ddd
        int32_t v16 = *(int32_t *)(v12 + 68); // 0x8091de4
        int32_t v17 = *(int32_t *)(v12 + 64); // 0x8091deb
        int32_t v18 = *(int32_t *)(v12 + 48); // 0x8091df2
        int32_t v19 = *(int32_t *)(v12 + 44); // 0x8091df9
        __fprintf_chk(stream, 1, "\tLine[%i %i %i %i %i %i %s]\n", v19, v18, v17, v16, v15, v14, v13);
        while (*v3 > v11) {
            // 0x8091da8
            v10 = v11;
            v11 = v10 + 1;
            v12 = 88 * v10 + *(int32_t *)(v2 + 36);
            v13 = flags_to_string(*(int32_t *)(v12 + 20), *(int32_t *)(v12 + 24));
            v14 = *(int32_t *)(v12 + 40);
            v15 = *(int32_t *)(v12 + 36);
            v16 = *(int32_t *)(v12 + 68);
            v17 = *(int32_t *)(v12 + 64);
            v18 = *(int32_t *)(v12 + 48);
            v19 = *(int32_t *)(v12 + 44);
            __fprintf_chk(stream, 1, "\tLine[%i %i %i %i %i %i %s]\n", v19, v18, v17, v16, v15, v14, v13);
        }
    }
    int32_t * v20 = (int32_t *)(v2 + 16); // 0x8091e25
    if (*v20 != 0) {
        int32_t v21 = 0;
        int32_t v22 = v21 + 1; // 0x8091e3a
        int32_t v23 = 68 * v21 + *(int32_t *)(v2 + 48); // 0x8091e43
        char * v24 = flags_to_string(*(int32_t *)(v23 + 20), *(int32_t *)(v23 + 24)); // 0x8091e62
        int32_t v25 = *(int32_t *)(v23 + 64); // 0x8091e6e
        int32_t v26 = *(int32_t *)(v23 + 60); // 0x8091e75
        int32_t v27 = *(int32_t *)(v23 + 40); // 0x8091e7c
        int32_t v28 = *(int32_t *)(v23 + 36); // 0x8091e83
        int32_t v29 = *(int32_t *)(v23 + 48); // 0x8091e8a
        int32_t v30 = *(int32_t *)(v23 + 44); // 0x8091e91
        int32_t v31 = *(int32_t *)(v23 + 56); // 0x8091e98
        int32_t v32 = *(int32_t *)(v23 + 52); // 0x8091e9f
        __fprintf_chk(stream, 1, "\tArc[%i %i %i %i %i %i %i %i %s]\n", v32, v31, v30, v29, v28, v27, v26, v25, v24);
        while (*v20 > v22) {
            // 0x8091e38
            v21 = v22;
            v22 = v21 + 1;
            v23 = 68 * v21 + *(int32_t *)(v2 + 48);
            v24 = flags_to_string(*(int32_t *)(v23 + 20), *(int32_t *)(v23 + 24));
            v25 = *(int32_t *)(v23 + 64);
            v26 = *(int32_t *)(v23 + 60);
            v27 = *(int32_t *)(v23 + 40);
            v28 = *(int32_t *)(v23 + 36);
            v29 = *(int32_t *)(v23 + 48);
            v30 = *(int32_t *)(v23 + 44);
            v31 = *(int32_t *)(v23 + 56);
            v32 = *(int32_t *)(v23 + 52);
            __fprintf_chk(stream, 1, "\tArc[%i %i %i %i %i %i %i %i %s]\n", v32, v31, v30, v29, v28, v27, v26, v25, v24);
        }
    }
    int32_t * v33 = (int32_t *)(v2 + 8); // 0x8091ecc
    if (*v33 != 0) {
        int32_t v34 = 0; // 0x8091f2c
        int32_t v35 = *(int32_t *)(v2 + 40) + 60 * v34; // 0x8091ee9
        int32_t v36 = *(int32_t *)(v35 + 36); // 0x8091eec
        unsigned char v37 = *(char *)(v35 + 48); // 0x8091ef3
        int32_t v38 = *(int32_t *)(v35 + 44); // 0x8091efb
        int32_t v39 = *(int32_t *)(v35 + 40); // 0x8091f02
        __fprintf_chk(stream, 1, "\tText[%i %i %i %i ", v39, v38, (int32_t)v37, v36);
        v34++;
        PrintQuotedString((struct _IO_FILE *)&g231, (char *)&g231);
        int32_t v40 = *(int32_t *)(v35 + 24); // 0x8091f42
        __fprintf_chk(stream, 1, " %s]\n", flags_to_string(*(int32_t *)(v35 + 20), v40));
        while (*v33 > v34) {
            // 0x8091ee0
            v35 = *(int32_t *)(v2 + 40) + 60 * v34;
            v36 = *(int32_t *)(v35 + 36);
            v37 = *(char *)(v35 + 48);
            v38 = *(int32_t *)(v35 + 44);
            v39 = *(int32_t *)(v35 + 40);
            __fprintf_chk(stream, 1, "\tText[%i %i %i %i ", v39, v38, (int32_t)v37, v36);
            v34++;
            PrintQuotedString((struct _IO_FILE *)&g231, (char *)&g231);
            v40 = *(int32_t *)(v35 + 24);
            __fprintf_chk(stream, 1, " %s]\n", flags_to_string(*(int32_t *)(v35 + 20), v40));
        }
    }
    // 0x8091f82
    for (int32_t i = 0; i < *(int32_t *)(v2 + 12); i++) {
        int32_t v41 = 60 * i + *(int32_t *)(v2 + 44); // 0x8091fa6
        int32_t v42 = *(int32_t *)(v41 + 24); // 0x8091fb7
        __fprintf_chk(stream, 1, "\tPolygon(%s)\n\t(", flags_to_string(*(int32_t *)(v41 + 20), v42));
        int32_t * v43 = (int32_t *)(v41 + 36); // 0x8091fe9
        if (*v43 != 0) {
            int32_t v44 = 0; // 0x8092003
            if (v44 % 5 == 0) {
                // 0x8092052
                fwrite((int32_t *)"\n\t\t", 1, 3, stream);
            }
            int32_t v45 = 20 * v44 + *(int32_t *)(v41 + 56); // 0x8092044
            v44++;
            __fprintf_chk(stream, 1, "[%i %i] ", *(int32_t *)v45, *(int32_t *)(v45 + 4));
            while (*v43 > v44) {
                // 0x8092032
                if (v44 % 5 == 0) {
                    // 0x8092052
                    fwrite((int32_t *)"\n\t\t", 1, 3, stream);
                }
                // 0x8092000
                v45 = 20 * v44 + *(int32_t *)(v41 + 56);
                v44++;
                __fprintf_chk(stream, 1, "[%i %i] ", *(int32_t *)v45, *(int32_t *)(v45 + 4));
            }
        }
        // 0x8092078
        fwrite((int32_t *)"\n\t)\n", 1, 4, stream);
    }
    // 0x80920ae
    fwrite((int32_t *)")\n", 1, 2, stream);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8092110 - 0x8092623
// Line range:    684 - 768
void WriteElementData(struct _IO_FILE * FP, int32_t Data) {
    // 0x8092110
    int32_t v1; // 0x8092110
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x809211b
    int32_t v3 = *v2; // 0x809211b
    if (v3 == 0) {
        // 0x809261b
        return;
    }
    struct _IO_FILE * stream = (struct _IO_FILE *)v1;
    int32_t v4 = v3; // 0x8092110
    int32_t v5 = 0; // 0x809260b
    int32_t v6; // 0x8092110
    int32_t * v7; // 0x8092144
    int32_t v8; // 0x8092141
    while (true) {
      lab_0x8092138:
        // 0x8092138
        v8 = 300 * v5 + *(int32_t *)(v1 + 32);
        v7 = (int32_t *)(v8 + 240);
        if (*v7 != 0) {
            goto lab_0x809261b;
        } else {
            // 0x809214e
            if (*(int32_t *)(v8 + 224) != 0) {
                goto lab_0x809261b;
            } else {
                // 0x8092158
                if (*(int32_t *)(v8 + 248) != 0) {
                    goto lab_0x809261b;
                } else {
                    // 0x8092162
                    v6 = v4;
                    if (*(int32_t *)(v8 + 232) == 0) {
                        goto lab_0x8092608;
                    } else {
                        goto lab_0x809261b;
                    }
                }
            }
        }
    }
  lab_0x809261b:;
    int32_t v9 = *(int32_t *)(v8 + 24); // 0x809217e
    __fprintf_chk(stream, 1, "\nElement[%s ", flags_to_string(*(int32_t *)(v8 + 20), v9));
    PrintQuotedString((struct _IO_FILE *)&g231, (char *)&g231);
    fputc(32, stream);
    PrintQuotedString((struct _IO_FILE *)&g231, (char *)&g231);
    fputc(32, stream);
    PrintQuotedString((struct _IO_FILE *)&g231, (char *)&g231);
    char * v10 = flags_to_string(*(int32_t *)(v8 + 56), *(int32_t *)(v8 + 60)); // 0x809222b
    int32_t * v11 = (int32_t *)(v8 + 216); // 0x8092230
    int32_t v12 = *v11; // 0x8092230
    int32_t * v13 = (int32_t *)(v8 + 220); // 0x8092236
    int32_t v14 = *v13; // 0x8092236
    int32_t v15 = *(int32_t *)(v8 + 72); // 0x8092240
    unsigned char v16 = *(char *)(v8 + 84); // 0x8092247
    int32_t v17 = *(int32_t *)(v8 + 80); // 0x809224f
    int32_t v18 = *(int32_t *)(v8 + 76); // 0x8092258
    __fprintf_chk(stream, 1, " %i %i %i %i %i %i %s]\n(\n", v12, v14, v18 - v12, v17 - v14, (int32_t)v16, v15, v10);
    int32_t * v19 = (int32_t *)(v8 + 288); // 0x8092281
    if (*v19 >= 1) {
        int32_t v20 = 0;
        int32_t v21 = v20 + 1; // 0x8092297
        int32_t v22 = 8 * v20 + *(int32_t *)(v8 + 296); // 0x809229a
        int32_t v23 = *(int32_t *)(v22 + 4); // 0x80922a0
        int32_t v24 = *(int32_t *)v22; // 0x80922a7
        __fprintf_chk(stream, 1, "%sAttribute(\"%s\" \"%s\")\n", (char *)&g4, (char *)v24, (char *)v23);
        while (v21 < *v19) {
            // 0x8092290
            v20 = v21;
            v21 = v20 + 1;
            v22 = 8 * v20 + *(int32_t *)(v8 + 296);
            v23 = *(int32_t *)(v22 + 4);
            v24 = *(int32_t *)v22;
            __fprintf_chk(stream, 1, "%sAttribute(\"%s\" \"%s\")\n", (char *)&g4, (char *)v24, (char *)v23);
        }
    }
    int32_t * v25 = (int32_t *)(v8 + 224); // 0x80922d5
    if (*v25 != 0) {
        for (int32_t i = 0; i < *v25; i++) {
            int32_t v26 = 76 * i + *(int32_t *)(v8 + 256); // 0x80922eb
            int32_t v27 = *(int32_t *)(v26 + 48); // 0x80922f4
            int32_t v28 = *(int32_t *)(v26 + 44); // 0x80922fb
            int32_t v29 = *(int32_t *)(v26 + 40); // 0x8092302
            int32_t v30 = *(int32_t *)(v26 + 36); // 0x8092309
            int32_t v31 = *(int32_t *)(v26 + 56); // 0x8092310
            int32_t v32 = *(int32_t *)(v26 + 52); // 0x809231d
            __fprintf_chk(stream, 1, "\tPin[%i %i %i %i %i %i ", v32 - *v11, v31 - *v13, v30, v29, v28, v27);
            PrintQuotedString((struct _IO_FILE *)&g231, (char *)&g231);
            __fprintf_chk(stream, 1, " ");
            PrintQuotedString((struct _IO_FILE *)&g231, (char *)&g231);
            int32_t v33 = *(int32_t *)(v26 + 24); // 0x8092390
            __fprintf_chk(stream, 1, " %s]\n", flags_to_string(*(int32_t *)(v26 + 20), v33));
        }
    }
    int32_t * v34 = (int32_t *)(v8 + 232); // 0x80923d3
    if (*v34 != 0) {
        for (int32_t i = 0; i < *v34; i++) {
            int32_t v35 = *v11; // 0x80923e8
            int32_t v36 = *(int32_t *)(v8 + 260) + 104 * i; // 0x80923f1
            int32_t v37 = *v13; // 0x80923f7
            int32_t v38 = *(int32_t *)(v36 + 84); // 0x8092403
            int32_t v39 = *(int32_t *)(v36 + 40); // 0x809240a
            int32_t v40 = *(int32_t *)(v36 + 36); // 0x8092411
            int32_t v41 = *(int32_t *)(v36 + 68); // 0x8092418
            int32_t v42 = *(int32_t *)(v36 + 64); // 0x8092421
            int32_t v43 = *(int32_t *)(v36 + 48); // 0x809242b
            int32_t v44 = *(int32_t *)(v36 + 44); // 0x8092434
            __fprintf_chk(stream, 1, "\tPad[%i %i %i %i %i %i %i ", v44 - v35, v43 - v37, v42 - v35, v41 - v37, v40, v39, v38);
            PrintQuotedString((struct _IO_FILE *)&g231, (char *)&g231);
            __fprintf_chk(stream, 1, " ");
            PrintQuotedString((struct _IO_FILE *)&g231, (char *)&g231);
            int32_t v45 = *(int32_t *)(v36 + 24); // 0x80924a4
            __fprintf_chk(stream, 1, " %s]\n", flags_to_string(*(int32_t *)(v36 + 20), v45));
        }
    }
    // 0x80924e7
    if (*v7 != 0) {
        int32_t v46 = 0;
        int32_t v47 = *v13; // 0x80924fb
        int32_t v48 = v46 + 1; // 0x8092501
        int32_t v49 = *(int32_t *)(v8 + 264) + 88 * v46; // 0x8092504
        int32_t v50 = *v11; // 0x809250a
        int32_t v51 = *(int32_t *)(v49 + 36); // 0x8092510
        int32_t v52 = *(int32_t *)(v49 + 68); // 0x8092517
        int32_t v53 = *(int32_t *)(v49 + 64); // 0x8092520
        int32_t v54 = *(int32_t *)(v49 + 48); // 0x8092529
        int32_t v55 = *(int32_t *)(v49 + 44); // 0x8092532
        __fprintf_chk(stream, 1, "\tElementLine [%i %i %i %i %i]\n", v55 - v50, v54 - v47, v53 - v50, v52 - v47, v51);
        while (*v7 > v48) {
            // 0x80924f8
            v46 = v48;
            v47 = *v13;
            v48 = v46 + 1;
            v49 = *(int32_t *)(v8 + 264) + 88 * v46;
            v50 = *v11;
            v51 = *(int32_t *)(v49 + 36);
            v52 = *(int32_t *)(v49 + 68);
            v53 = *(int32_t *)(v49 + 64);
            v54 = *(int32_t *)(v49 + 48);
            v55 = *(int32_t *)(v49 + 44);
            __fprintf_chk(stream, 1, "\tElementLine [%i %i %i %i %i]\n", v55 - v50, v54 - v47, v53 - v50, v52 - v47, v51);
        }
    }
    int32_t * v56 = (int32_t *)(v8 + 248); // 0x8092563
    if (*v56 != 0) {
        int32_t v57 = 0;
        int32_t v58 = v57 + 1; // 0x809257a
        int32_t v59 = 68 * v57 + *(int32_t *)(v8 + 268); // 0x8092583
        int32_t v60 = *(int32_t *)(v59 + 36); // 0x8092589
        int32_t v61 = *(int32_t *)(v59 + 64); // 0x8092590
        int32_t v62 = *(int32_t *)(v59 + 60); // 0x8092597
        int32_t v63 = *(int32_t *)(v59 + 48); // 0x809259e
        int32_t v64 = *(int32_t *)(v59 + 44); // 0x80925a5
        int32_t v65 = *(int32_t *)(v59 + 56); // 0x80925ac
        int32_t v66 = *v13; // 0x80925af
        int32_t v67 = *(int32_t *)(v59 + 52); // 0x80925b9
        int32_t v68 = *v11; // 0x80925bc
        __fprintf_chk(stream, 1, "\tElementArc [%i %i %i %i %i %i %i]\n", v67 - v68, v65 - v66, v64, v63, v62, v61, v60);
        while (*v56 > v58) {
            // 0x8092578
            v57 = v58;
            v58 = v57 + 1;
            v59 = 68 * v57 + *(int32_t *)(v8 + 268);
            v60 = *(int32_t *)(v59 + 36);
            v61 = *(int32_t *)(v59 + 64);
            v62 = *(int32_t *)(v59 + 60);
            v63 = *(int32_t *)(v59 + 48);
            v64 = *(int32_t *)(v59 + 44);
            v65 = *(int32_t *)(v59 + 56);
            v66 = *v13;
            v67 = *(int32_t *)(v59 + 52);
            v68 = *v11;
            __fprintf_chk(stream, 1, "\tElementArc [%i %i %i %i %i %i %i]\n", v67 - v68, v65 - v66, v64, v63, v62, v61, v60);
        }
    }
    // 0x80925e8
    fwrite((int32_t *)"\n\t)\n", 1, 4, stream);
    v6 = *v2;
    goto lab_0x8092608;
  lab_0x8092608:
    // 0x8092608
    v5++;
    v4 = v6;
    if (v6 <= v5) {
        // break -> 0x809261b
        goto lab_0x809261b;
    }
    goto lab_0x8092138;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8092630 - 0x809308c
// Line range:    850 - 665
int32_t WritePCB(struct _IO_FILE * FP) {
    // 0x8092630
    int32_t v1; // 0x8092630
    struct _IO_FILE * stream = (struct _IO_FILE *)v1; // 0x8092639
    WritePCBInfoHeader(stream);
    __fprintf_chk(stream, 1, "\n# To read pcb files, the pcb version (or the cvs source date) must be >= the file version\n");
    __fprintf_chk(stream, 1, "FileVersion[%i]\n", 0x1324007);
    fwrite((int32_t *)"\nPCB[", 1, 5, stream);
    PrintQuotedString((struct _IO_FILE *)&g231, (char *)&g231);
    int32_t v2 = PCB; // 0x80926bc
    __fprintf_chk(stream, 1, " %i %i]\n\n", *(int32_t *)(v2 + 144), *(int32_t *)(v2 + 148));
    int32_t v3 = *(int32_t *)(PCB + 140); // 0x80926fc
    int32_t v4 = *(int32_t *)(PCB + 136); // 0x8092702
    float64_t v5 = *(float64_t *)(PCB + 152); // 0x8092708
    __fprintf_chk(stream, 1, "Grid[%s %i %i %i]\n", c_dtostr(v5), v4, v3, (int32_t)g171);
    char * v6 = c_dtostr(*(float64_t *)(PCB + 160)); // 0x809274f
    int64_t v7 = g190;
    float80_t v8 = Zoom_Multiplier;
    float80_t v9 = (float80_t)(int32_t)((0x100000000 * (int64_t)((int32_t)v7 >> 31) | v7 & 0xffffffff) / 2) / v8;
    int32_t v10; // 0x8092630
    if (g170 == 0) {
        // 0x8092edc
        v10 = Yorig + (int32_t)v9;
    } else {
        // 0x8092763
        v10 = *(int32_t *)(PCB + 148) - (int32_t)v9 - Yorig;
    }
    int32_t v11 = g189; // 0x80927b3
    __fprintf_chk(stream, 1, "Cursor[%i %i %s]\n", Xorig + (int32_t)((float80_t)((v11 + (int32_t)(v11 < 0)) / 2) / v8), v10, v6);
    __fprintf_chk(stream, 1, "PolyArea[%s]\n", c_dtostr(*(float64_t *)(PCB + 168)));
    __fprintf_chk(stream, 1, "Thermal[%s]\n", c_dtostr(*(float64_t *)(PCB + 176)));
    int32_t v12 = *(int32_t *)(PCB + 132); // 0x8092868
    int32_t v13 = *(int32_t *)(PCB + 128); // 0x8092872
    int32_t v14 = *(int32_t *)(PCB + 124); // 0x809287c
    int32_t v15 = *(int32_t *)(PCB + 120); // 0x8092883
    int32_t v16 = *(int32_t *)(PCB + 116); // 0x809288a
    int32_t v17 = *(int32_t *)(PCB + 112); // 0x8092891
    __fprintf_chk(stream, 1, "DRC[%i %i %i %i %i %i]\n", v17, v16, v15, v14, v13, v12);
    __fprintf_chk(stream, 1, "Flags(%s)\n", pcbflags_to_string(*(int32_t *)(PCB + 4)));
    __fprintf_chk(stream, 1, "Groups(\"%s\")\n", LayerGroupsToString(PCB + 0x1cd4));
    fwrite((int32_t *)"Styles[\"", 1, 8, stream);
    int32_t v18 = *(int32_t *)(PCB + 0x21a0); // 0x8092949
    int32_t v19 = *(int32_t *)(PCB + 0x219c); // 0x8092953
    int32_t v20 = *(int32_t *)(PCB + 0x2198); // 0x809295d
    int32_t v21 = *(int32_t *)(PCB + 0x2194); // 0x8092967
    int32_t v22 = *(int32_t *)(PCB + 0x21a4); // 0x8092971
    __fprintf_chk(stream, 1, "%s,%i,%i,%i,%i:", (char *)v22, v21, v20, v19, v18);
    int32_t v23 = *(int32_t *)(PCB + 0x21b8); // 0x809299b
    int32_t v24 = *(int32_t *)(PCB + 0x21b4); // 0x80929a5
    int32_t v25 = *(int32_t *)(PCB + 0x21b0); // 0x80929af
    int32_t v26 = *(int32_t *)(PCB + 0x21ac); // 0x80929b9
    int32_t v27 = *(int32_t *)(PCB + 0x21bc); // 0x80929c6
    __fprintf_chk(stream, 1, "%s,%i,%i,%i,%i:", (char *)v27, v26, v25, v24, v23);
    int32_t v28 = *(int32_t *)(PCB + 0x21d0); // 0x80929ed
    int32_t v29 = *(int32_t *)(PCB + 0x21cc); // 0x80929f7
    int32_t v30 = *(int32_t *)(PCB + 0x21c8); // 0x8092a01
    int32_t v31 = *(int32_t *)(PCB + 0x21c4); // 0x8092a0b
    int32_t v32 = *(int32_t *)(PCB + 0x21d4); // 0x8092a15
    __fprintf_chk(stream, 1, "%s,%i,%i,%i,%i:", (char *)v32, v31, v30, v29, v28);
    int32_t v33 = *(int32_t *)(PCB + 0x21e8); // 0x8092a3f
    int32_t v34 = *(int32_t *)(PCB + 0x21e4); // 0x8092a49
    int32_t v35 = *(int32_t *)(PCB + 0x21e0); // 0x8092a53
    int32_t v36 = *(int32_t *)(PCB + 0x21dc); // 0x8092a5d
    int32_t v37 = *(int32_t *)(PCB + 0x21ec); // 0x8092a6a
    __fprintf_chk(stream, 1, "%s,%i,%i,%i,%i\"]\n\n", (char *)v37, v36, v35, v34, v33);
    char v38 = 0; // 0x8092a9c
    char v39 = PCB; // 0x8092a9c
    int32_t v40; // 0x8092630
    int32_t v41; // 0x8092630
    int32_t v42; // 0x8092630
    int32_t v43; // 0x8092630
    int32_t v44; // 0x8092630
    int32_t v45; // 0x8092630
    int32_t v46; // 0x8092630
    int32_t v47; // 0x8092630
    int32_t v48; // 0x8092630
    int32_t v49; // 0x8092b67
    while (true) {
        char v50 = v38;
        int32_t v51 = v39; // 0x8092aa0
        if (*(char *)(v51 + 212) != 0) {
            int16_t ** v52 = __ctype_b_loc(); // 0x8092ab0
            int32_t v53 = v50; // 0x8092ab5
            int32_t v54 = *(int32_t *)(v51 + 232);
            if ((*(char *)((2 * v53 | 1) + (int32_t)*v52) & 64) != 0) {
                int32_t v55 = v54 / 100; // 0x8092e78
                if (v54 == 100 * v55) {
                    // 0x8092eb0
                    __fprintf_chk(stream, 1, "Symbol('%c' %i)\n(\n", v50, v55);
                } else {
                    // 0x8092e81
                    __fprintf_chk(stream, 1, "Symbol['%c' %i]\n(\n", v50, v54);
                }
            } else {
                // 0x8092ac5
                __fprintf_chk(stream, 1, "Symbol[%i %i]\n(\n", v53, v54);
            }
            int32_t v56 = *(int32_t *)(v51 + 216); // 0x8092af7
            if (v56 != 0) {
                // 0x8092b67
                v44 = v56;
                v40 = *(int32_t *)(v51 + 208);
                while (true) {
                  lab_0x8092b67:
                    // 0x8092b67
                    v41 = v40;
                    v49 = *(int32_t *)(v41 + 44);
                    int32_t v57 = v49 / 100; // 0x8092b7b
                    if (v49 != 100 * v57) {
                        // 0x8092c00
                        v46 = *(int32_t *)(v41 + 64);
                        v43 = *(int32_t *)(v41 + 48);
                        goto lab_0x8092c09;
                    } else {
                        int32_t v58 = *(int32_t *)(v41 + 48); // 0x8092b84
                        int32_t v59 = v58 / 100; // 0x8092b96
                        int32_t v60 = *(int32_t *)(v41 + 64);
                        if (v58 != 100 * v59) {
                            // 0x8092b10
                            v45 = v60;
                            v47 = *(int32_t *)(v41 + 68);
                            v48 = *(int32_t *)(v41 + 36);
                            v42 = v58;
                            goto lab_0x8092b22;
                        } else {
                            int32_t v61 = v60 / 100; // 0x8092bbc
                            v46 = v60;
                            v43 = v58;
                            if (v60 != 100 * v61) {
                                goto lab_0x8092c09;
                            } else {
                                int32_t v62 = *(int32_t *)(v41 + 68); // 0x8092bc9
                                int32_t v63 = v62 / 100; // 0x8092be0
                                int32_t v64 = *(int32_t *)(v41 + 36);
                                v45 = v60;
                                v47 = v62;
                                v48 = v64;
                                v42 = v58;
                                if (v62 == 100 * v63) {
                                    int32_t v65 = v64 / 100; // 0x8092e0e
                                    v45 = v60;
                                    v47 = v62;
                                    v48 = v64;
                                    v42 = v58;
                                    if (v64 != 100 * v65) {
                                        goto lab_0x8092b22;
                                    } else {
                                        // 0x8092e1c
                                        __fprintf_chk(stream, 1, "\tSymbolLine(%i %i %i %i %i)\n", v57, v59, v61, v63, v65);
                                        goto lab_0x8092b5a;
                                    }
                                } else {
                                    goto lab_0x8092b22;
                                }
                            }
                        }
                    }
                }
            }
          lab_0x8092c20:
            // 0x8092c20
            fwrite((int32_t *)")\n", 1, 2, stream);
        }
        // 0x8092c43
        v38 = v50 + 1;
        v39 += 28;
    }
  lab_0x8092c09:
    // 0x8092c09
    v45 = v46;
    v47 = *(int32_t *)(v41 + 68);
    v48 = *(int32_t *)(v41 + 36);
    v42 = v43;
    goto lab_0x8092b22;
  lab_0x8092b22:
    // 0x8092b22
    __fprintf_chk(stream, 1, "\tSymbolLine[%i %i %i %i %i]\n", v49, v42, v45, v47, v48);
    goto lab_0x8092b5a;
  lab_0x8092b5a:;
    int32_t v66 = v44 - 1; // 0x8092b5a
    v44 = v66;
    v40 = v41 + 88;
    if (v66 == 0) {
        // break -> 0x8092c20
        goto lab_0x8092c20;
    }
    goto lab_0x8092b67;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8093090 - 0x80930de
// Line range:    872 - 880
int32_t WritePCBFile(char * Filename) {
    // 0x8093090
    int32_t v1; // 0x8093090
    char * file_path = (char *)v1;
    struct _IO_FILE * file = fopen(file_path, "w"); // 0x80930a9
    int32_t result; // 0x8093090
    if (file == NULL) {
        // 0x80930cf
        OpenErrorMessage(file_path);
        result = -1;
    } else {
        int32_t v2 = WritePCB((struct _IO_FILE *)&g231); // 0x80930b4
        fclose(file);
        result = v2;
    }
    // 0x80930c3
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x80930e0 - 0x809311e
// Line range:    1070 - 1073
void SaveTMPData(void) {
    // 0x80930e0
    __sprintf_chk(TMPFilename, 1, 80, "PCB.%.8i.save", getpid());
    WritePCBFile((char *)&g231);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8093120 - 0x80931b0
// Line range:    951 - 962
void SaveInTMP(void) {
    int32_t v1 = __readgsdword(20); // 0x809312a
    if (PCB != 0) {
        // 0x809313e
        if (*(char *)(PCB + 33) != 0) {
            // 0x8093144
            int32_t v2; // bp-96, 0x8093120
            __sprintf_chk((char *)&v2, 1, 80, "PCB.%.8i.save", getpid());
            Message("Trying to save your layout in '%s'\n", &v2);
            WritePCBFile((char *)&g231);
        }
    }
    // 0x8093187
    if (v1 == __readgsdword(20)) {
        // 0x8093193
        return;
    }
    // 0x809319c
    __stack_chk_fail();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x80931b0 - 0x80931d6
// Line range:    970 - 978
void EmergencySave(void) {
    // 0x80931b0
    if (dont_save_any_more != 0) {
        // 0x80931bf
        return;
    }
    // 0x80931c8
    SaveInTMP();
    dont_save_any_more = 1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8093330 - 0x80933d5
// Line range:    429 - 446
void PostLoadElementPCB(void) {
    // 0x8093330
    if (yyPCB != 0) {
        int32_t v1 = PCB; // 0x809333d
        CreateNewPCBPost(yyPCB, 0);
        ParseGroupString("1,c:2,s", yyPCB + 0x1cd4, *(int32_t *)(yyData + 24));
        int32_t v2 = *(int32_t *)(yyPCB + 0x220c); // 0x8093386
        PCB = yyPCB;
        int32_t v3 = *(int32_t *)(v2 + 32); // 0x8093391
        MoveElementLowLevel(v2, v3, -*(int32_t *)v3, -*(int32_t *)(v3 + 4));
        PCB = v1;
        *(int32_t *)(yyPCB + 144) = *(int32_t *)(v3 + 8);
        *(int32_t *)(yyPCB + 148) = *(int32_t *)(v3 + 12);
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x80933e0 - 0x809364a
// Line range:    349 - 380
int32_t LoadPCB(char * Filename) {
    int32_t v1 = CreateNewPCB(0); // 0x80933f3
    int32_t v2 = 0x1000000 * v1 / 0x1000000; // 0x8093401
    int32_t v3 = ParsePCB(v2, Filename); // 0x8093401
    if (v3 != 0) {
        // 0x80935a0
        hid_action((char *)(int32_t)(char)"PCBChanged");
        RemovePCB(v2);
        return 1;
    }
    // 0x8093410
    RemovePCB(0x1000000 * PCB / 0x1000000);
    PCB = v1;
    CreateNewPCBPost(v2, 0);
    ResetStackAndVisibility();
    int32_t v4 = *(int32_t *)(PCB + 144); // 0x809343d
    int32_t v5 = *(int32_t *)(PCB + 100); // 0x8093443
    int32_t v6 = v5 - v4; // 0x8093443
    float80_t v7 = Zoom_Multiplier; // 0x8093446
    int32_t v8 = v6 == 0 | v6 < 0 != ((v6 ^ v5) & (v5 ^ v4)) < 0 ? v5 : v4; // 0x809344e
    int32_t v9 = v8 < 0 ? v3 : v8; // 0x8093454
    g193 = v9;
    int32_t v10 = *(int32_t *)(PCB + 148); // 0x809345d
    int32_t v11 = *(int32_t *)(PCB + 104); // 0x8093463
    int32_t v12 = v11 - v10; // 0x8093463
    int32_t v13 = v12 < 0 == ((v12 ^ v11) & (v11 ^ v10)) < 0 == (v12 != 0) ? v10 : v11; // 0x8093469
    int32_t v14 = v13 < 0 ? v3 : v13; // 0x809346e
    int32_t v15 = g189;
    g194 = v14;
    Xorig = v9 - (int32_t)((float80_t)((v15 + (int32_t)(v15 < 0)) / 2) / v7);
    int32_t v16 = g190; // 0x80934b0
    Yorig = v14 - (int32_t)((float80_t)(((int32_t)(v16 < 0) + v16) / 2) / v7);
    ChangePCBSize(0x1000000 * v4 / 0x1000000, v10);
    if (*(char *)(PCB + 0x1cd0) == 0) {
        // 0x8093630
        Message((char *)(int32_t)(char)"File '%s' has no font information, using default font\n", Filename);
        CreateDefaultFont();
    }
    // 0x80934f9
    SetChangedFlag(0);
    char * v17 = MyStrdup((char *)(0x1000000 * (int32_t)Filename / 0x1000000), "LoadPCB()"); // 0x8093516
    *(int32_t *)(PCB + 20) = (int32_t)v17;
    float64_t v18 = *(float64_t *)(PCB + 152); // 0x8093523
    *(char *)&Settings = (char)(v18 != v18 || 0.0 != 0.0);
    netlist_sort_offset = 2;
    sort_library((int32_t)v18);
    netlist_sort_offset = 0;
    if (hid_get_flag((char *)(int32_t)(char)"style") == 0) {
        // 0x80935c8
        SetLineSize(0x1000000 * *(int32_t *)(PCB + 0x2194) / 0x1000000);
        SetViaSize(0x1000000 * *(int32_t *)(PCB + 0x2198) / 0x1000000, 1);
        SetViaDrillingHole(0x1000000 * *(int32_t *)(PCB + 0x219c) / 0x1000000, 1);
        SetKeepawayWidth(0x1000000 * *(int32_t *)(PCB + 0x21a0) / 0x1000000);
    }
    // 0x8093588
    hid_action((char *)(int32_t)(char)"PCBChanged");
    return 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8093910 - 0x8093ec0
// Line range:    1100 - 1220
int32_t ParseLibraryTree(void) {
    // 0x809396d
    int32_t str2; // bp-4129, 0x8093910
    int32_t v1 = &str2; // 0x809391b
    int32_t v2 = __readgsdword(20); // 0x8093924
    __asm_rep_stosd_memset((char *)&str2, 0, 1024);
    bool v3; // 0x8093910
    int32_t v4 = v3 ? -0x1000 : 0x1000;
    *(char *)(v4 + v1) = 0;
    int32_t path; // bp-8226, 0x8093910
    __asm_rep_stosd_memset((char *)&path, 0, 1024);
    *(char *)(v4 + (int32_t)&path) = 0;
    GetWorkingDirectory((char *)&path);
    char * str = MyStrdup(g148, "ParseLibraryTree"); // 0x80939c8
    char * next_token = strtok(str, ":"); // 0x80939de
    if (next_token != NULL) {
        // 0x80939eb
        if (*next_token != 0) {
            // 0x8093a00
            strncpy((char *)&str2, next_token, 0x1000);
            chdir((char *)&path);
            struct __dirstream * dirp = opendir((char *)&str2); // 0x8093a31
            struct dirent * v5; // 0x8093910
            struct dirent * v6; // 0x8093910
            int32_t dir; // bp-8316, 0x8093910
            struct dirent * v7; // 0x8093a69
            int32_t v8; // 0x8093910
            char * name; // 0x8093910
            char v9; // 0x8093ab9
            struct dirent * v10; // 0x8093a69
            int32_t v11; // 0x8093aff
            char * found_char_pos; // 0x8093b33
            char * v12; // 0x8093b47
            struct __dirstream * dirp2; // 0x8093b58
            struct dirent * v13; // 0x8093a69
            struct dirent * v14; // 0x8093b89
            char * str3; // 0x8093ba4
            struct dirent * v15; // 0x8093b89
            int32_t v16; // 0x8093910
            if (dirp == NULL) {
                // 0x8093e5b
                OpendirErrorMessage((char *)&str2);
            } else {
                // 0x8093a44
                chdir((char *)&str2);
                GetWorkingDirectory((char *)&str2);
                v7 = readdir(dirp);
                v6 = v7;
                if (v7 != NULL) {
                    v10 = v6;
                    while (true) {
                        // 0x8093a78
                        v8 = (int32_t)v10;
                        chdir((char *)&str2);
                        name = (char *)(v8 + 11);
                        if ((v16 & 0xf000) == 0x4000 == __xstat(3, name, (struct stat *)&dir) == 0) {
                            // 0x8093ab9
                            v9 = *name;
                            if (v9 != 46) {
                                if (v9 != 67) {
                                    // break -> 0x8093af8
                                    break;
                                }
                                // 0x8093acb
                                if (*(char *)(v8 + 12) != 86) {
                                    // break -> 0x8093af8
                                    break;
                                }
                                // 0x8093ad7
                                if (*(char *)(v8 + 13) != 83) {
                                    // break -> 0x8093af8
                                    break;
                                }
                                // 0x8093ae3
                                if (*(char *)(v8 + 14) != 0) {
                                    // break -> 0x8093af8
                                    break;
                                }
                            }
                        }
                        // 0x8093a60
                        v10 = readdir(dirp);
                        if (v10 == NULL) {
                            // break (via goto) -> 0x8093de0
                            goto lab_0x8093de0;
                        }
                    }
                    // 0x8093af8
                    v11 = GetLibraryMenuMemory((int32_t)&Library);
                    *(int32_t *)v11 = (int32_t)MyStrdup(name, "ParseLibraryTree()");
                    found_char_pos = strrchr((char *)&str2, 47);
                    v12 = __strdup((char *)(found_char_pos == NULL ? v1 : (int32_t)found_char_pos + 1));
                    *(int32_t *)(v11 + 4) = (int32_t)v12;
                    dirp2 = opendir(name);
                    chdir(name);
                    if (dirp2 != NULL) {
                        // 0x8093b80
                        v14 = readdir(dirp2);
                        v5 = v14;
                        if (v14 != NULL) {
                            str3 = (char *)((int32_t)v5 + 11);
                            strlen(str3);
                            __xstat(3, str3, (struct stat *)&dir);
                            v15 = readdir(dirp2);
                            while (v15 != NULL) {
                                // 0x8093b98
                                str3 = (char *)((int32_t)v15 + 11);
                                strlen(str3);
                                __xstat(3, str3, (struct stat *)&dir);
                                v15 = readdir(dirp2);
                            }
                        }
                    }
                    // 0x8093e48
                    closedir(dirp2);
                    v13 = readdir(dirp);
                    while (v13 != NULL) {
                        // 0x8093a78
                        v10 = v13;
                        while (true) {
                            // 0x8093a78
                            v8 = (int32_t)v10;
                            chdir((char *)&str2);
                            name = (char *)(v8 + 11);
                            if ((v16 & 0xf000) == 0x4000 == __xstat(3, name, (struct stat *)&dir) == 0) {
                                // 0x8093ab9
                                v9 = *name;
                                if (v9 != 46) {
                                    if (v9 != 67) {
                                        // break -> 0x8093af8
                                        break;
                                    }
                                    // 0x8093acb
                                    if (*(char *)(v8 + 12) != 86) {
                                        // break -> 0x8093af8
                                        break;
                                    }
                                    // 0x8093ad7
                                    if (*(char *)(v8 + 13) != 83) {
                                        // break -> 0x8093af8
                                        break;
                                    }
                                    // 0x8093ae3
                                    if (*(char *)(v8 + 14) != 0) {
                                        // break -> 0x8093af8
                                        break;
                                    }
                                }
                            }
                            // 0x8093a60
                            v10 = readdir(dirp);
                            if (v10 == NULL) {
                                // break (via goto) -> 0x8093de0
                                goto lab_0x8093de0;
                            }
                        }
                        // 0x8093af8
                        v11 = GetLibraryMenuMemory((int32_t)&Library);
                        *(int32_t *)v11 = (int32_t)MyStrdup(name, "ParseLibraryTree()");
                        found_char_pos = strrchr((char *)&str2, 47);
                        v12 = __strdup((char *)(found_char_pos == NULL ? v1 : (int32_t)found_char_pos + 1));
                        *(int32_t *)(v11 + 4) = (int32_t)v12;
                        dirp2 = opendir(name);
                        chdir(name);
                        if (dirp2 != NULL) {
                            // 0x8093b80
                            v14 = readdir(dirp2);
                            v5 = v14;
                            if (v14 != NULL) {
                                str3 = (char *)((int32_t)v5 + 11);
                                strlen(str3);
                                __xstat(3, str3, (struct stat *)&dir);
                                v15 = readdir(dirp2);
                                while (v15 != NULL) {
                                    // 0x8093b98
                                    str3 = (char *)((int32_t)v15 + 11);
                                    strlen(str3);
                                    __xstat(3, str3, (struct stat *)&dir);
                                    v15 = readdir(dirp2);
                                }
                            }
                        }
                        // 0x8093e48
                        closedir(dirp2);
                        v13 = readdir(dirp);
                    }
                }
                // 0x8093de0
                closedir(dirp);
            }
            char * next_token2 = strtok(NULL, ":"); // 0x8093dfd
            while (next_token2 != NULL) {
                // 0x8093e06
                if (*next_token2 == 0) {
                    // break -> 0x8093e0f
                    break;
                }
                strncpy((char *)&str2, next_token2, 0x1000);
                chdir((char *)&path);
                dirp = opendir((char *)&str2);
                if (dirp == NULL) {
                    // 0x8093e5b
                    OpendirErrorMessage((char *)&str2);
                } else {
                    // 0x8093a44
                    chdir((char *)&str2);
                    GetWorkingDirectory((char *)&str2);
                    v7 = readdir(dirp);
                    v6 = v7;
                    if (v7 != NULL) {
                        v10 = v6;
                        while (true) {
                            // 0x8093a78
                            v8 = (int32_t)v10;
                            chdir((char *)&str2);
                            name = (char *)(v8 + 11);
                            if ((v16 & 0xf000) == 0x4000 == __xstat(3, name, (struct stat *)&dir) == 0) {
                                // 0x8093ab9
                                v9 = *name;
                                if (v9 != 46) {
                                    if (v9 != 67) {
                                        // break -> 0x8093af8
                                        break;
                                    }
                                    // 0x8093acb
                                    if (*(char *)(v8 + 12) != 86) {
                                        // break -> 0x8093af8
                                        break;
                                    }
                                    // 0x8093ad7
                                    if (*(char *)(v8 + 13) != 83) {
                                        // break -> 0x8093af8
                                        break;
                                    }
                                    // 0x8093ae3
                                    if (*(char *)(v8 + 14) != 0) {
                                        // break -> 0x8093af8
                                        break;
                                    }
                                }
                            }
                            // 0x8093a60
                            v10 = readdir(dirp);
                            if (v10 == NULL) {
                                // break (via goto) -> 0x8093de0
                                goto lab_0x8093de0;
                            }
                        }
                        // 0x8093af8
                        v11 = GetLibraryMenuMemory((int32_t)&Library);
                        *(int32_t *)v11 = (int32_t)MyStrdup(name, "ParseLibraryTree()");
                        found_char_pos = strrchr((char *)&str2, 47);
                        v12 = __strdup((char *)(found_char_pos == NULL ? v1 : (int32_t)found_char_pos + 1));
                        *(int32_t *)(v11 + 4) = (int32_t)v12;
                        dirp2 = opendir(name);
                        chdir(name);
                        if (dirp2 != NULL) {
                            // 0x8093b80
                            v14 = readdir(dirp2);
                            v5 = v14;
                            if (v14 != NULL) {
                                str3 = (char *)((int32_t)v5 + 11);
                                strlen(str3);
                                __xstat(3, str3, (struct stat *)&dir);
                                v15 = readdir(dirp2);
                                while (v15 != NULL) {
                                    // 0x8093b98
                                    str3 = (char *)((int32_t)v15 + 11);
                                    strlen(str3);
                                    __xstat(3, str3, (struct stat *)&dir);
                                    v15 = readdir(dirp2);
                                }
                            }
                        }
                        // 0x8093e48
                        closedir(dirp2);
                        v13 = readdir(dirp);
                        while (v13 != NULL) {
                            // 0x8093a78
                            v10 = v13;
                            while (true) {
                                // 0x8093a78
                                v8 = (int32_t)v10;
                                chdir((char *)&str2);
                                name = (char *)(v8 + 11);
                                if ((v16 & 0xf000) == 0x4000 == __xstat(3, name, (struct stat *)&dir) == 0) {
                                    // 0x8093ab9
                                    v9 = *name;
                                    if (v9 != 46) {
                                        if (v9 != 67) {
                                            // break -> 0x8093af8
                                            break;
                                        }
                                        // 0x8093acb
                                        if (*(char *)(v8 + 12) != 86) {
                                            // break -> 0x8093af8
                                            break;
                                        }
                                        // 0x8093ad7
                                        if (*(char *)(v8 + 13) != 83) {
                                            // break -> 0x8093af8
                                            break;
                                        }
                                        // 0x8093ae3
                                        if (*(char *)(v8 + 14) != 0) {
                                            // break -> 0x8093af8
                                            break;
                                        }
                                    }
                                }
                                // 0x8093a60
                                v10 = readdir(dirp);
                                if (v10 == NULL) {
                                    // break (via goto) -> 0x8093de0
                                    goto lab_0x8093de0;
                                }
                            }
                            // 0x8093af8
                            v11 = GetLibraryMenuMemory((int32_t)&Library);
                            *(int32_t *)v11 = (int32_t)MyStrdup(name, "ParseLibraryTree()");
                            found_char_pos = strrchr((char *)&str2, 47);
                            v12 = __strdup((char *)(found_char_pos == NULL ? v1 : (int32_t)found_char_pos + 1));
                            *(int32_t *)(v11 + 4) = (int32_t)v12;
                            dirp2 = opendir(name);
                            chdir(name);
                            if (dirp2 != NULL) {
                                // 0x8093b80
                                v14 = readdir(dirp2);
                                v5 = v14;
                                if (v14 != NULL) {
                                    str3 = (char *)((int32_t)v5 + 11);
                                    strlen(str3);
                                    __xstat(3, str3, (struct stat *)&dir);
                                    v15 = readdir(dirp2);
                                    while (v15 != NULL) {
                                        // 0x8093b98
                                        str3 = (char *)((int32_t)v15 + 11);
                                        strlen(str3);
                                        __xstat(3, str3, (struct stat *)&dir);
                                        v15 = readdir(dirp2);
                                    }
                                }
                            }
                            // 0x8093e48
                            closedir(dirp2);
                            v13 = readdir(dirp);
                        }
                    }
                    // 0x8093de0
                    closedir(dirp);
                }
                // 0x8093dee
                next_token2 = strtok(NULL, ":");
            }
        }
    }
    // 0x8093e0f
    free((int32_t *)str);
    chdir((char *)&path);
    if (v2 == __readgsdword(20)) {
        // 0x8093e3d
        return 0;
    }
    // 0x8093eb6
    __stack_chk_fail();
    return &g231;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/file.c
// Address range: 0x8093ec0 - 0x8094290
// Line range:    1227 - 1314
int32_t ReadLibraryContents(void) {
    int32_t v1 = __readgsdword(20); // 0x8093ecc
    SaveFree((char *)g57);
    g57 = 0;
    char * command = EvaluateFilename(g147, g154, g149, NULL); // 0x8093f10
    g57 = (int32_t)command;
    int32_t v2 = 0; // 0x8093f1c
    int32_t * v3; // 0x8093ec0
    int32_t v4; // 0x8093ec0
    int32_t v5; // 0x8093ec0
    int32_t v6; // 0x8093ec0
    int32_t v7; // 0x8093ec0
    int32_t v8; // 0x8093ec0
    int32_t str2; // bp-288, 0x8093ec0
    struct _IO_FILE * stream; // 0x8093f83
    int32_t v9; // 0x8094207
    int32_t v10; // 0x809405e
    if (command != NULL) {
        // 0x8093f1e
        v2 = 0;
        if (*command != 0) {
            // 0x8093f78
            stream = popen(command, "r");
            int32_t v11 = (int32_t)stream; // 0x8093f83
            if (stream == NULL) {
                // 0x8094272
                PopenErrorMessage((char *)g57);
                v2 = v11;
            } else {
                // 0x8093f96
                if (fgets((char *)&str2, 255, stream) != NULL) {
                    int32_t v12 = &str2; // 0x8093f9c
                    bool v13; // 0x8093ec0
                    int32_t v14 = v13 ? -1 : 1;
                    v6 = 0;
                    while (true) {
                      lab_0x8093fdc:;
                        int32_t v15 = v6;
                        int32_t v16 = v12;
                        int32_t v17 = *(int32_t *)v16; // 0x8093fdc
                        int32_t v18 = v16 + 4; // 0x8093fde
                        int32_t v19 = v17 - 0x1010101 & (v17 ^ -0x7f7f7f80); // 0x8093fe9
                        uint32_t v20 = v19 & -0x7f7f7f80; // 0x8093feb
                        while (v20 == 0) {
                            // 0x8093fdc
                            v16 = v18;
                            v17 = *(int32_t *)v16;
                            v18 = v16 + 4;
                            v19 = v17 - 0x1010101 & (v17 ^ -0x7f7f7f80);
                            v20 = v19 & -0x7f7f7f80;
                        }
                        unsigned char v21 = (char)((v19 & 0x8080) == 0 ? v20 / 0x10000 : v20); // 0x8094005
                        int32_t v22 = ((v19 & 0x8080) == 0 ? v16 + 6 : v18) - (-1 - v21 < v21 ? 4 : 3) - v12; // 0x809400a
                        if (v22 != 0) {
                            // 0x809400e
                            int32_t v23; // bp-4, 0x8093ec0
                            char * v24 = (char *)((int32_t)&v23 - 285 + v22); // 0x8094011
                            if (*v24 == 10) {
                                // 0x80941d8
                                *v24 = 0;
                            } else {
                                // 0x809401f
                                Message("linelength (%i) exceeded; following characters will be ignored\n", 255);
                            }
                        }
                        int32_t v25 = 5; // 0x809403f
                        int32_t v26 = v12; // 0x8093ec0
                        int32_t v27 = (int32_t)"TYPE="; // 0x8093ec0
                        while (*(char *)v26 == *(char *)v27) {
                            v25--;
                            v27 += v14;
                            v26 += v14;
                            if (v25 == 0) {
                                int32_t v28 = GetLibraryMenuMemory((int32_t)&Library); // 0x8094187
                                char v29; // bp-283, 0x8093ec0
                                char * v30 = v29 != 0 ? &v29 : "(unknown)"; // 0x80941b0
                                *(int32_t *)v28 = (int32_t)MyStrdup(v30, "ReadLibraryDescription()");
                                *(int32_t *)(v28 + 4) = (int32_t)__strdup(g149);
                                v7 = v28;
                                goto lab_0x8093fb8;
                            }
                        }
                        // 0x8094047
                        v9 = v15;
                        if (v15 == 0) {
                            // 0x8094200
                            v9 = GetLibraryMenuMemory((int32_t)&Library);
                            *(int32_t *)v9 = (int32_t)MyStrdup("(unknown)", "ReadLibraryDescription()");
                            *(int32_t *)(v9 + 4) = (int32_t)__strdup(g149);
                        }
                        // 0x8094055
                        v10 = GetLibraryEntryMemory(v9);
                        char * str3 = MyStrdup((char *)&str2, "ReadLibraryDescription()"); // 0x8094070
                        *(int32_t *)(v10 + 4) = (int32_t)str3;
                        char * next_token = strtok(str3, ":"); // 0x8094083
                        *(int32_t *)(v10 + 8) = (int32_t)next_token;
                        if (next_token == NULL) {
                            goto lab_0x8094178;
                        } else {
                            char * next_token2 = strtok(NULL, ":"); // 0x80940a2
                            *(int32_t *)(v10 + 12) = (int32_t)next_token2;
                            if (next_token2 == NULL) {
                                goto lab_0x8094178;
                            } else {
                                char * next_token3 = strtok(NULL, ":"); // 0x80940c1
                                int32_t * v31 = (int32_t *)(v10 + 16);
                                *v31 = (int32_t)next_token3;
                                if (next_token3 == NULL) {
                                    // 0x80941e8
                                    v8 = 4;
                                    v5 = *(int32_t *)(v10 + 20);
                                    goto lab_0x8094106;
                                } else {
                                    int32_t next_token4 = (int32_t)strtok(NULL, ":"); // 0x80940e0
                                    *(int32_t *)(v10 + 20) = next_token4;
                                    v3 = v31;
                                    v4 = next_token4;
                                    goto lab_0x80940ea;
                                }
                            }
                        }
                    }
                }
              lab_0x8094250:
                // 0x8094250
                pclose(stream);
                v2 = v11;
            }
        }
    }
    int32_t result = 1; // 0x8093f34
    if (ParseLibraryTree() > 0 || v2 != 0) {
        // 0x8093f36
        sort_library((int32_t)&g231);
        result = 0;
    }
    // 0x8093f42
    if (v1 != __readgsdword(20)) {
        // 0x8094284
        __stack_chk_fail();
        return &g231;
    }
    // 0x8093f52
    return result;
  lab_0x8094178:
    // 0x8094178
    v3 = (int32_t *)(v10 + 16);
    v4 = *(int32_t *)(v10 + 20);
    goto lab_0x80940ea;
  lab_0x80940ea:;
    int32_t v32 = v4;
    int32_t str4 = *v3; // 0x80940ea
    v8 = 4;
    v5 = v32;
    if (str4 != 0) {
        // 0x80940f5
        v8 = strlen((char *)str4) + 4;
        v5 = v32;
    }
    goto lab_0x8094106;
  lab_0x8094106:
    // 0x8094106
    if (v5 != 0) {
        // 0x809410c
        int32_t str5; // 0x8093ec0
        int32_t len = strlen((char *)str5); // 0x809410f
    }
    char * v33 = MyCalloc(v8, 1, "ReadLibraryDescription()"); // 0x809412d
    int32_t v34 = *(int32_t *)(v10 + 20); // 0x8094132
    int32_t v35 = v34 == 0 ? (int32_t)&g5 : v34; // 0x809413c
    *(int32_t *)v10 = (int32_t)v33;
    int32_t v36 = *(int32_t *)(v10 + 16); // 0x8094141
    int32_t v37 = v36 == 0 ? (int32_t)&g5 : v36; // 0x809415a
    __sprintf_chk(v33, 1, -1, "%s, %s", (char *)v37, (char *)v35);
    v7 = v9;
    goto lab_0x8093fb8;
  lab_0x8093fb8:;
    char * str = fgets((char *)&str2, 255, stream); // 0x8093fcd
    v6 = v7;
    if (str == NULL) {
        // break -> 0x8094250
        goto lab_0x8094250;
    }
    goto lab_0x8093fdc;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/find.c
// Address range: 0x8096d20 - 0x8097082
// Line range:    3439 - 3502
void ResetFoundLinesAndPolygons(char AndDraw) {
    int32_t v1 = *(int32_t *)(PCB + 0x220c); // 0x8096d39
    int32_t v2 = *(int32_t *)(v1 + 16); // 0x8096d3f
    char v3 = 0; // 0x8096d48
    int32_t v4 = PCB; // 0x8096d48
    int32_t v5 = v1; // 0x8096d48
    char v6; // 0x8096d20
    char v7; // 0x8096d20
    char v8; // 0x8096d20
    int32_t v9; // 0x8096d20
    int32_t v10; // 0x8096d20
    int32_t v11; // 0x8096d20
    int32_t v12; // 0x8096d20
    int32_t v13; // 0x8096d20
    int32_t v14; // 0x8096d20
    int32_t v15; // 0x8096d20
    int32_t v16; // 0x8096d20
    int32_t v17; // 0x8096d20
    if (v2 != 0) {
        // 0x8096d4e
        v8 = 0;
        v10 = PCB;
        v13 = v1;
        v17 = 92 * v2;
        v15 = v2;
        while (true) {
          lab_0x8096d74:
            // 0x8096d74
            v11 = v10;
            v14 = v15 - 1;
            v16 = v17 - 92;
            int32_t v18 = *(int32_t *)(v13 + 36) + v16; // 0x8096d7d
            int32_t * v19 = (int32_t *)(v18 + 20); // 0x8096d7f
            int32_t v20 = *v19; // 0x8096d7f
            v6 = v8;
            if ((v20 & TheFlag) == 0) {
                goto lab_0x8096d63;
            } else {
                if (AndDraw == 0) {
                    // 0x8096d58
                    *v19 = v20 & -1 - TheFlag;
                    v6 = 1;
                    goto lab_0x8096d63;
                } else {
                    char * v21 = (char *)v18; // 0x8096da5
                    AddObjectToFlagUndoList(32, v21, v21, v21);
                    *v19 = *v19 & -1 - TheFlag;
                    DrawRat(0x1000000 * v18 / 0x1000000, 0);
                    v7 = 1;
                    v9 = PCB;
                    v3 = 1;
                    v12 = PCB;
                    if (v14 == 0) {
                        // break -> 0x8096dd2
                        break;
                    }
                    goto lab_0x8096d6e;
                }
            }
        }
      lab_0x8096dd2:
        // 0x8096dd2
        v4 = v12;
        v5 = *(int32_t *)(v4 + 0x220c);
    }
    char v22 = v3; // 0x8096de0
    char v23; // 0x8096d20
    char v24; // 0x8096d20
    char v25; // 0x8096d20
    char v26; // 0x8096d20
    char v27; // 0x8096d20
    char v28; // 0x8096d20
    char v29; // 0x8096d20
    int32_t v30; // 0x8096d20
    int32_t v31; // 0x8096d20
    int32_t v32; // 0x8096d20
    int32_t v33; // 0x8096d20
    if (*(int32_t *)(v5 + 24) != 0) {
        int32_t v34 = 0; // 0x8096ded
        int32_t v35 = v5 + 76;
        char v36 = v3;
        int32_t v37 = *(int32_t *)(v35 + 4); // 0x8096df0
        char v38 = v36; // 0x8096df9
        int32_t v39 = v4; // 0x8096df9
        int32_t v40; // 0x8096d20
        char * v41; // 0x8096d20
        int32_t v42; // 0x8096d20
        int32_t v43; // 0x8096e27
        int32_t * v44; // 0x8096e29
        int32_t v45; // 0x8096e29
        char * v46; // 0x8096e52
        if (v37 != 0) {
            // 0x8096dff
            v41 = (char *)v35;
            v42 = 0x1000000 * v35 / 0x1000000;
            while (true) {
                // 0x8096e1e
                v40 = 88 * v37 - 88;
                v30 = v37 - 1;
                v43 = *(int32_t *)(v35 + 36) + v40;
                v44 = (int32_t *)(v43 + 20);
                v45 = *v44;
                v28 = v36;
                if ((v45 & TheFlag) == 0) {
                    goto lab_0x8096e13;
                } else {
                    if (AndDraw == 0) {
                        // 0x8096e08
                        *v44 = v45 & -1 - TheFlag;
                        v28 = 1;
                        goto lab_0x8096e13;
                    } else {
                        // 0x8096e36
                        v46 = (char *)v43;
                        AddObjectToFlagUndoList(4, v41, v46, v46);
                        *v44 = *v44 & -1 - TheFlag;
                        DrawLine(v42, v43, 0);
                        v29 = 1;
                        if (v30 == 0) {
                            // break -> 0x8096e88
                            break;
                        }
                        goto lab_0x8096e1e_2;
                    }
                }
            }
            // 0x8096e88
            v39 = PCB;
            v38 = 1;
        }
        int32_t v47 = v39;
        char v48 = v38;
        int32_t v49 = *(int32_t *)(v47 + 0x220c); // 0x8096e8d
        v34++;
        uint32_t v50 = *(int32_t *)(v49 + 24); // 0x8096e97
        int32_t v51 = v35 + 92; // 0x8096e9d
        while (v50 > v34) {
            // 0x8096df0
            v35 = v51;
            v36 = v48;
            v37 = *(int32_t *)(v35 + 4);
            v38 = v36;
            v39 = v47;
            if (v37 != 0) {
                // 0x8096dff
                v41 = (char *)v35;
                v42 = 0x1000000 * v35 / 0x1000000;
                while (true) {
                    // 0x8096e1e
                    v40 = 88 * v37 - 88;
                    v30 = v37 - 1;
                    v43 = *(int32_t *)(v35 + 36) + v40;
                    v44 = (int32_t *)(v43 + 20);
                    v45 = *v44;
                    v28 = v36;
                    if ((v45 & TheFlag) == 0) {
                        goto lab_0x8096e13;
                    } else {
                        if (AndDraw == 0) {
                            // 0x8096e08
                            *v44 = v45 & -1 - TheFlag;
                            v28 = 1;
                            goto lab_0x8096e13;
                        } else {
                            // 0x8096e36
                            v46 = (char *)v43;
                            AddObjectToFlagUndoList(4, v41, v46, v46);
                            *v44 = *v44 & -1 - TheFlag;
                            DrawLine(v42, v43, 0);
                            v29 = 1;
                            if (v30 == 0) {
                                // break -> 0x8096e88
                                break;
                            }
                            goto lab_0x8096e1e_2;
                        }
                    }
                }
                // 0x8096e88
                v39 = PCB;
                v38 = 1;
            }
            // 0x8096e8d
            v47 = v39;
            v48 = v38;
            v49 = *(int32_t *)(v47 + 0x220c);
            v34++;
            v50 = *(int32_t *)(v49 + 24);
            v51 = v35 + 92;
        }
        // 0x8096eb9
        v22 = v48;
        if (v50 != 0) {
            int32_t v52 = 0; // 0x8096ec7
            int32_t v53 = v49 + 76;
            char v54 = v48;
            int32_t v55 = *(int32_t *)(v53 + 16); // 0x8096ec8
            char v56 = v54; // 0x8096ed1
            int32_t v57 = v47; // 0x8096ed1
            int32_t v58; // 0x8096d20
            char * v59; // 0x8096d20
            int32_t v60; // 0x8096d20
            int32_t v61; // 0x8096f07
            int32_t * v62; // 0x8096f09
            int32_t v63; // 0x8096f09
            char * v64; // 0x8096f32
            if (v55 != 0) {
                // 0x8096ed7
                v59 = (char *)v53;
                v60 = 0x1000000 * v53 / 0x1000000;
                while (true) {
                    // 0x8096efe
                    v58 = 68 * v55 - 68;
                    v31 = v55 - 1;
                    v61 = *(int32_t *)(v53 + 48) + v58;
                    v62 = (int32_t *)(v61 + 20);
                    v63 = *v62;
                    v23 = v54;
                    if ((v63 & TheFlag) == 0) {
                        goto lab_0x8096ef3;
                    } else {
                        if (AndDraw == 0) {
                            // 0x8096ee8
                            *v62 = v63 & -1 - TheFlag;
                            v23 = 1;
                            goto lab_0x8096ef3;
                        } else {
                            // 0x8096f16
                            v64 = (char *)v61;
                            AddObjectToFlagUndoList(0, v59, v64, v64);
                            *v62 = *v62 & -1 - TheFlag;
                            DrawArc(v60, v61, 0);
                            v24 = 1;
                            if (v31 == 0) {
                                // break -> 0x8096f68
                                break;
                            }
                            goto lab_0x8096efe_2;
                        }
                    }
                }
                // 0x8096f68
                v57 = PCB;
                v56 = 1;
            }
            int32_t v65 = v57;
            char v66 = v56;
            int32_t v67 = *(int32_t *)(v65 + 0x220c); // 0x8096f6d
            v52++;
            uint32_t v68 = *(int32_t *)(v67 + 24); // 0x8096f77
            int32_t v69 = v53 + 92; // 0x8096f7d
            while (v68 > v52) {
                // 0x8096ec8
                v53 = v69;
                v54 = v66;
                v55 = *(int32_t *)(v53 + 16);
                v56 = v54;
                v57 = v65;
                if (v55 != 0) {
                    // 0x8096ed7
                    v59 = (char *)v53;
                    v60 = 0x1000000 * v53 / 0x1000000;
                    while (true) {
                        // 0x8096efe
                        v58 = 68 * v55 - 68;
                        v31 = v55 - 1;
                        v61 = *(int32_t *)(v53 + 48) + v58;
                        v62 = (int32_t *)(v61 + 20);
                        v63 = *v62;
                        v23 = v54;
                        if ((v63 & TheFlag) == 0) {
                            goto lab_0x8096ef3;
                        } else {
                            if (AndDraw == 0) {
                                // 0x8096ee8
                                *v62 = v63 & -1 - TheFlag;
                                v23 = 1;
                                goto lab_0x8096ef3;
                            } else {
                                // 0x8096f16
                                v64 = (char *)v61;
                                AddObjectToFlagUndoList(0, v59, v64, v64);
                                *v62 = *v62 & -1 - TheFlag;
                                DrawArc(v60, v61, 0);
                                v24 = 1;
                                if (v31 == 0) {
                                    // break -> 0x8096f68
                                    break;
                                }
                                goto lab_0x8096efe_2;
                            }
                        }
                    }
                    // 0x8096f68
                    v57 = PCB;
                    v56 = 1;
                }
                // 0x8096f6d
                v65 = v57;
                v66 = v56;
                v67 = *(int32_t *)(v65 + 0x220c);
                v52++;
                v68 = *(int32_t *)(v67 + 24);
                v69 = v53 + 92;
            }
            // 0x8096f87
            v22 = v66;
            if (v68 != 0) {
                int32_t v70 = v67 + 76;
                char v71 = v66;
                int32_t v72 = *(int32_t *)(v70 + 12); // 0x8096fa0
                char v73 = v71; // 0x8096fa9
                int32_t v74 = v65; // 0x8096fa9
                char * v75; // 0x8096d20
                int32_t v76; // 0x8096d20
                int32_t v77; // 0x8096fd7
                int32_t * v78; // 0x8096fd9
                int32_t v79; // 0x8096fd9
                char * v80; // 0x8097002
                if (v72 != 0) {
                    // 0x8096faf
                    v75 = (char *)v70;
                    v76 = 0x1000000 * v70 / 0x1000000;
                    while (true) {
                        // 0x8096fce
                        v33 = 60 * v72 - 60;
                        v32 = v72 - 1;
                        v77 = *(int32_t *)(v70 + 44) + v33;
                        v78 = (int32_t *)(v77 + 20);
                        v79 = *v78;
                        v25 = v71;
                        if ((v79 & TheFlag) == 0) {
                            goto lab_0x8096fc3;
                        } else {
                            if (AndDraw == 0) {
                                // 0x8096fb8
                                *v78 = v79 & -1 - TheFlag;
                                v25 = 1;
                                goto lab_0x8096fc3;
                            } else {
                                // 0x8096fe6
                                v80 = (char *)v77;
                                AddObjectToFlagUndoList(8, v75, v80, v80);
                                *v78 = *v78 & -1 - TheFlag;
                                DrawPolygon(v76, v77, 0);
                                v26 = 1;
                                if (v32 == 0) {
                                    // break -> 0x8097038
                                    break;
                                }
                                goto lab_0x8096fce;
                            }
                        }
                    }
                    // 0x8097038
                    v74 = PCB;
                    v73 = v27;
                }
                int32_t v81 = v74;
                char v82 = v73;
                int32_t v83 = 1; // 0x8097043
                v22 = v82;
                int32_t v84 = v70 + 92; // 0x809704d
                while (*(int32_t *)(*(int32_t *)(v81 + 0x220c) + 24) > v83) {
                    // 0x8096fa0
                    v70 = v84;
                    int32_t v85 = v83;
                    v71 = v82;
                    v72 = *(int32_t *)(v70 + 12);
                    v73 = v71;
                    v74 = v81;
                    if (v72 != 0) {
                        // 0x8096faf
                        v75 = (char *)v70;
                        v76 = 0x1000000 * v70 / 0x1000000;
                        while (true) {
                            // 0x8096fce
                            v33 = 60 * v72 - 60;
                            v32 = v72 - 1;
                            v77 = *(int32_t *)(v70 + 44) + v33;
                            v78 = (int32_t *)(v77 + 20);
                            v79 = *v78;
                            v25 = v71;
                            if ((v79 & TheFlag) == 0) {
                                goto lab_0x8096fc3;
                            } else {
                                if (AndDraw == 0) {
                                    // 0x8096fb8
                                    *v78 = v79 & -1 - TheFlag;
                                    v25 = 1;
                                    goto lab_0x8096fc3;
                                } else {
                                    // 0x8096fe6
                                    v80 = (char *)v77;
                                    AddObjectToFlagUndoList(8, v75, v80, v80);
                                    *v78 = *v78 & -1 - TheFlag;
                                    DrawPolygon(v76, v77, 0);
                                    v26 = 1;
                                    if (v32 == 0) {
                                        // break -> 0x8097038
                                        break;
                                    }
                                    goto lab_0x8096fce;
                                }
                            }
                        }
                        // 0x8097038
                        v74 = PCB;
                        v73 = v27;
                    }
                    // 0x809703d
                    v81 = v74;
                    v82 = v73;
                    v83 = v85 + 1;
                    v22 = v82;
                    v84 = v70 + 92;
                }
            }
        }
    }
    // 0x8096ea7
    if (v22 == 0) {
        // 0x8096eb1
        return;
    }
    // 0x809705b
    SetChangedFlag(1);
    if (AndDraw == 0) {
        // 0x8096eb1
        return;
    }
    // 0x8097071
    IncrementUndoSerialNumber();
    Draw();
  lab_0x8096e13:
    // 0x8096e13
    v29 = v28;
    if (v30 == 0) {
        // break -> 0x8096e88
        goto lab_0x8096e88;
    }
    goto lab_0x8096e1e_2;
  lab_0x8096e1e:
    // 0x8096e1e
    goto lab_0x8096e1e_2;
  lab_0x8096ef3:
    // 0x8096ef3
    v24 = v23;
    if (v31 == 0) {
        // break -> 0x8096f68
        goto lab_0x8096f68;
    }
    goto lab_0x8096efe;
  lab_0x8096efe:
    // 0x8096efe
    goto lab_0x8096efe_2;
  lab_0x8096fc3:
    // 0x8096fc3
    v26 = v25;
    v27 = v25;
    if (v32 == 0) {
        // break -> 0x8097038
        goto lab_0x8097038;
    }
    goto lab_0x8096fce;
  lab_0x8096fce:;
    char v86 = v26; // 0x8096d20
    int32_t v87 = v32; // 0x8096d20
    int32_t v88 = v33; // 0x8096d20
    goto lab_0x8096fce_2;
  lab_0x8096d63:
    // 0x8096d63
    v7 = v6;
    v9 = v11;
    v3 = v6;
    v12 = v11;
    if (v14 == 0) {
        // break -> 0x8096dd2
        goto lab_0x8096dd2;
    }
    goto lab_0x8096d6e;
  lab_0x8096d6e:
    // 0x8096d6e
    v8 = v7;
    v10 = v9;
    v13 = *(int32_t *)(v9 + 0x220c);
    v17 = v16;
    v15 = v14;
    goto lab_0x8096d74;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/find.c
// Address range: 0x8097090 - 0x80972e4
// Line range:    3376 - 3430
void ResetFoundPinsViasAndPads(char AndDraw) {
    int32_t v1 = *(int32_t *)(PCB + 0x220c); // 0x80970a9
    int32_t v2 = *(int32_t *)v1; // 0x80970af
    char v3 = 0; // 0x80970b3
    int32_t v4 = PCB; // 0x80970b3
    int32_t v5 = v1; // 0x80970b3
    char v6; // 0x8097090
    char v7; // 0x8097090
    char v8; // 0x8097090
    int32_t v9; // 0x8097090
    int32_t v10; // 0x8097090
    int32_t v11; // 0x8097090
    int32_t v12; // 0x8097090
    int32_t v13; // 0x8097090
    int32_t v14; // 0x8097090
    int32_t v15; // 0x8097090
    int32_t v16; // 0x8097090
    if (v2 != 0) {
        // 0x80970e3
        v8 = 0;
        v10 = PCB;
        v16 = v1;
        v12 = 0;
        v14 = v2;
        while (true) {
          lab_0x80970e3:
            // 0x80970e3
            v11 = v10;
            int32_t v17 = *(int32_t *)(v16 + 28) + 76 * v12; // 0x80970ec
            int32_t * v18 = (int32_t *)(v17 + 20); // 0x80970ef
            int32_t v19 = *v18; // 0x80970ef
            v6 = v8;
            if ((v19 & TheFlag) == 0) {
                goto lab_0x80970cb;
            } else {
                if (AndDraw == 0) {
                    // 0x80970c0
                    *v18 = v19 & -1 - TheFlag;
                    v6 = 1;
                    goto lab_0x80970cb;
                } else {
                    char * v20 = (char *)v17; // 0x809710f
                    AddObjectToFlagUndoList(1, v20, v20, v20);
                    *v18 = *v18 & -1 - TheFlag;
                    DrawVia(0x1000000 * v17 / 0x1000000, 0);
                    int32_t v21 = *(int32_t *)(PCB + 0x220c); // 0x8097137
                    int32_t v22 = *(int32_t *)v21; // 0x809713d
                    v7 = 1;
                    v9 = PCB;
                    v13 = v22;
                    v15 = v21;
                    v3 = 1;
                    v4 = PCB;
                    v5 = v21;
                    if (v22 == 0) {
                        // break -> 0x8097143
                        break;
                    }
                    goto lab_0x80970d7;
                }
            }
        }
    }
  lab_0x8097143_2:;
    int32_t v23 = *(int32_t *)(v5 + 8); // 0x8097143
    char v24 = v3; // 0x809714f
    if (v23 != 0) {
        int32_t v25 = v23; // 0x8097164
        int32_t v26 = 300 * v23; // 0x8097164
        char v27 = v3;
        v26 -= 300;
        int32_t v28 = *(int32_t *)(*(int32_t *)(v4 + 0x220c) + 32) + v26; // 0x8097171
        int32_t * v29 = (int32_t *)(v28 + 224); // 0x8097174
        int32_t v30 = *v29; // 0x8097174
        char v31 = v27; // 0x809717f
        char v32; // 0x8097090
        char v33; // 0x8097090
        int32_t v34; // 0x8097090
        int32_t v35; // 0x8097090
        int32_t v36; // 0x8097090
        int32_t v37; // 0x8097090
        char * v38; // 0x8097090
        int32_t v39; // 0x80971b6
        int32_t * v40; // 0x80971bc
        int32_t v41; // 0x80971bc
        int32_t v42; // 0x80971a3
        char * v43; // 0x80971dc
        int32_t v44; // 0x80971fb
        if (v30 != 0) {
            // 0x80971ad
            v38 = (char *)v28;
            v36 = 0;
            v37 = v30;
            v39 = *(int32_t *)(v28 + 256) + 76 * v36;
            v40 = (int32_t *)(v39 + 20);
            v41 = *v40;
            v32 = v27;
            v34 = v37;
            if ((v41 & TheFlag) != 0) {
                if (AndDraw == 0) {
                    // 0x8097190
                    *v40 = v41 & -1 - TheFlag;
                    v32 = 1;
                    v34 = v37;
                } else {
                    // 0x80971c9
                    v43 = (char *)v39;
                    AddObjectToFlagUndoList(0, v38, v43, v43);
                    *v40 = *v40 & -1 - TheFlag;
                    DrawPin(0x1000000 * v39 / 0x1000000, 0);
                    v44 = *v29;
                    v32 = 1;
                    v34 = v44;
                    if (v44 == 0) {
                        // break -> 0x8097210
                        break;
                    }
                }
            }
            // 0x809719f
            v35 = v34;
            v33 = v32;
            v42 = 1 - v37 + v36 + v35;
            v31 = v33;
            while (v35 > v42) {
                // 0x80971ad
                v36 = v42;
                v37 = v35;
                v39 = *(int32_t *)(v28 + 256) + 76 * v36;
                v40 = (int32_t *)(v39 + 20);
                v41 = *v40;
                v32 = v33;
                v34 = v37;
                if ((v41 & TheFlag) != 0) {
                    if (AndDraw == 0) {
                        // 0x8097190
                        *v40 = v41 & -1 - TheFlag;
                        v32 = 1;
                        v34 = v37;
                    } else {
                        // 0x80971c9
                        v43 = (char *)v39;
                        AddObjectToFlagUndoList(0, v38, v43, v43);
                        *v40 = *v40 & -1 - TheFlag;
                        DrawPin(0x1000000 * v39 / 0x1000000, 0);
                        v44 = *v29;
                        v32 = 1;
                        v34 = v44;
                        v31 = 1;
                        if (v44 == 0) {
                            // break -> 0x8097210
                            break;
                        }
                    }
                }
                // 0x809719f
                v35 = v34;
                v33 = v32;
                v42 = 1 - v37 + v36 + v35;
                v31 = v33;
            }
        }
        char v45 = v31;
        int32_t * v46 = (int32_t *)(v28 + 232); // 0x8097210
        int32_t v47 = *v46; // 0x8097210
        char v48 = v45; // 0x8097237
        char v49; // 0x8097090
        char v50; // 0x8097090
        int32_t v51; // 0x8097090
        int32_t v52; // 0x8097090
        int32_t v53; // 0x8097090
        char * v54; // 0x8097090
        int32_t v55; // 0x8097246
        int32_t * v56; // 0x809724c
        int32_t v57; // 0x809724c
        int32_t v58; // 0x8097233
        char * v59; // 0x809726c
        if (v47 != 0) {
            // 0x809723d
            v54 = (char *)v28;
            v58 = 0;
            v53 = v47;
            v55 = *(int32_t *)(v28 + 260) + 104 * v58;
            v56 = (int32_t *)(v55 + 20);
            v57 = *v56;
            v49 = v45;
            v51 = v53;
            if ((v57 & TheFlag) != 0) {
                if (AndDraw == 0) {
                    // 0x8097220
                    *v56 = v57 & -1 - TheFlag;
                    v49 = 1;
                    v51 = v53;
                } else {
                    // 0x8097259
                    v59 = (char *)v55;
                    AddObjectToFlagUndoList(0, v54, v59, v59);
                    *v56 = *v56 & -1 - TheFlag;
                    DrawPad(0x1000000 * v55 / 0x1000000, 0);
                    v49 = 1;
                    v51 = *v46;
                }
            }
            // 0x809722b
            v52 = v51;
            v50 = v49;
            v58 += (int32_t)(v47 == v52);
            v48 = v50;
            while (v52 > v58) {
                // 0x809723d
                v53 = v52;
                v55 = *(int32_t *)(v28 + 260) + 104 * v58;
                v56 = (int32_t *)(v55 + 20);
                v57 = *v56;
                v49 = v50;
                v51 = v53;
                if ((v57 & TheFlag) != 0) {
                    if (AndDraw == 0) {
                        // 0x8097220
                        *v56 = v57 & -1 - TheFlag;
                        v49 = 1;
                        v51 = v53;
                    } else {
                        // 0x8097259
                        v59 = (char *)v55;
                        AddObjectToFlagUndoList(0, v54, v59, v59);
                        *v56 = *v56 & -1 - TheFlag;
                        DrawPad(0x1000000 * v55 / 0x1000000, 0);
                        v49 = 1;
                        v51 = *v46;
                    }
                }
                // 0x809722b
                v52 = v51;
                v50 = v49;
                v58 += (int32_t)(v47 == v52);
                v48 = v50;
            }
        }
        // 0x8097298
        v25--;
        char v60 = v48;
        v24 = v60;
        while (v25 != 0) {
            // 0x80972a9
            v27 = v60;
            v26 -= 300;
            v28 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 32) + v26;
            v29 = (int32_t *)(v28 + 224);
            v30 = *v29;
            v31 = v27;
            if (v30 != 0) {
                // 0x80971ad
                v38 = (char *)v28;
                v36 = 0;
                v37 = v30;
                v39 = *(int32_t *)(v28 + 256) + 76 * v36;
                v40 = (int32_t *)(v39 + 20);
                v41 = *v40;
                v32 = v27;
                v34 = v37;
                if ((v41 & TheFlag) != 0) {
                    if (AndDraw == 0) {
                        // 0x8097190
                        *v40 = v41 & -1 - TheFlag;
                        v32 = 1;
                        v34 = v37;
                    } else {
                        // 0x80971c9
                        v43 = (char *)v39;
                        AddObjectToFlagUndoList(0, v38, v43, v43);
                        *v40 = *v40 & -1 - TheFlag;
                        DrawPin(0x1000000 * v39 / 0x1000000, 0);
                        v44 = *v29;
                        v32 = 1;
                        v34 = v44;
                        if (v44 == 0) {
                            // break -> 0x8097210
                            break;
                        }
                    }
                }
                // 0x809719f
                v35 = v34;
                v33 = v32;
                v42 = 1 - v37 + v36 + v35;
                v31 = v33;
                while (v35 > v42) {
                    // 0x80971ad
                    v36 = v42;
                    v37 = v35;
                    v39 = *(int32_t *)(v28 + 256) + 76 * v36;
                    v40 = (int32_t *)(v39 + 20);
                    v41 = *v40;
                    v32 = v33;
                    v34 = v37;
                    if ((v41 & TheFlag) != 0) {
                        if (AndDraw == 0) {
                            // 0x8097190
                            *v40 = v41 & -1 - TheFlag;
                            v32 = 1;
                            v34 = v37;
                        } else {
                            // 0x80971c9
                            v43 = (char *)v39;
                            AddObjectToFlagUndoList(0, v38, v43, v43);
                            *v40 = *v40 & -1 - TheFlag;
                            DrawPin(0x1000000 * v39 / 0x1000000, 0);
                            v44 = *v29;
                            v32 = 1;
                            v34 = v44;
                            v31 = 1;
                            if (v44 == 0) {
                                // break -> 0x8097210
                                break;
                            }
                        }
                    }
                    // 0x809719f
                    v35 = v34;
                    v33 = v32;
                    v42 = 1 - v37 + v36 + v35;
                    v31 = v33;
                }
            }
            // 0x8097210
            v45 = v31;
            v46 = (int32_t *)(v28 + 232);
            v47 = *v46;
            v48 = v45;
            if (v47 != 0) {
                // 0x809723d
                v54 = (char *)v28;
                v58 = 0;
                v53 = v47;
                v55 = *(int32_t *)(v28 + 260) + 104 * v58;
                v56 = (int32_t *)(v55 + 20);
                v57 = *v56;
                v49 = v45;
                v51 = v53;
                if ((v57 & TheFlag) != 0) {
                    if (AndDraw == 0) {
                        // 0x8097220
                        *v56 = v57 & -1 - TheFlag;
                        v49 = 1;
                        v51 = v53;
                    } else {
                        // 0x8097259
                        v59 = (char *)v55;
                        AddObjectToFlagUndoList(0, v54, v59, v59);
                        *v56 = *v56 & -1 - TheFlag;
                        DrawPad(0x1000000 * v55 / 0x1000000, 0);
                        v49 = 1;
                        v51 = *v46;
                    }
                }
                // 0x809722b
                v52 = v51;
                v50 = v49;
                v58 += (int32_t)(v47 == v52);
                v48 = v50;
                while (v52 > v58) {
                    // 0x809723d
                    v53 = v52;
                    v55 = *(int32_t *)(v28 + 260) + 104 * v58;
                    v56 = (int32_t *)(v55 + 20);
                    v57 = *v56;
                    v49 = v50;
                    v51 = v53;
                    if ((v57 & TheFlag) != 0) {
                        if (AndDraw == 0) {
                            // 0x8097220
                            *v56 = v57 & -1 - TheFlag;
                            v49 = 1;
                            v51 = v53;
                        } else {
                            // 0x8097259
                            v59 = (char *)v55;
                            AddObjectToFlagUndoList(0, v54, v59, v59);
                            *v56 = *v56 & -1 - TheFlag;
                            DrawPad(0x1000000 * v55 / 0x1000000, 0);
                            v49 = 1;
                            v51 = *v46;
                        }
                    }
                    // 0x809722b
                    v52 = v51;
                    v50 = v49;
                    v58 += (int32_t)(v47 == v52);
                    v48 = v50;
                }
            }
            // 0x8097298
            v25--;
            v60 = v48;
            v24 = v60;
        }
    }
    // 0x80972b3
    if (v24 == 0) {
        // 0x80972b9
        return;
    }
    // 0x80972c1
    SetChangedFlag(1);
    if (AndDraw == 0) {
        // 0x80972b9
        return;
    }
    // 0x80972d3
    IncrementUndoSerialNumber();
    Draw();
  lab_0x80970cb:;
    int32_t v61 = *(int32_t *)(v11 + 0x220c); // 0x80970cb
    int32_t v62 = *(int32_t *)v61; // 0x80970d1
    v7 = v6;
    v9 = v11;
    v13 = v62;
    v15 = v61;
    v3 = v6;
    v4 = v11;
    v5 = v61;
    if (v62 == 0) {
        // break -> 0x8097143
        goto lab_0x8097143_2;
    }
    goto lab_0x80970d7;
  lab_0x80970d7:;
    int32_t v63 = v12 + 1 - v14 + v13; // 0x80970db
    v8 = v7;
    v10 = v9;
    v16 = v15;
    v12 = v63;
    v14 = v13;
    v3 = v7;
    v4 = v9;
    v5 = v15;
    if (v13 <= v63) {
        // break -> 0x8097143
        goto lab_0x8097143_2;
    }
    goto lab_0x80970e3;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/flags.c
// Address range: 0x809dbd0 - 0x809dbec
// Line range:    251 - 251
void register_flags_flag_list(void) {
    // 0x809dbd0
    hid_register_flags((int32_t)&flags_flag_list, 70);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/fontmode.c
// Address range: 0x809e310 - 0x809e32c
// Line range:    246 - 246
void register_fontmode_action_list(void) {
    // 0x809e310
    hid_register_actions((int32_t)&fontmode_action_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/insert.c
// Address range: 0x809e690 - 0x809e998
// Line range:    234 - 298
int32_t AdjustInsertPoint(void) {
    // 0x809e690
    if (g215 == 0) {
        // 0x809e6b1
        return 0;
    }
    // 0x809e6c0
    g218 = &g61;
    int32_t * v1 = (int32_t *)(g217 + 64); // 0x809e6ea
    int32_t v2 = g193 - *v1; // 0x809e6ea
    int32_t v3 = g217 + 68; // 0x809e6ed
    int32_t v4 = g194 - *(int32_t *)v3; // 0x809e6ed
    int32_t * v5 = (int32_t *)(g217 + 44); // 0x809e6f0
    int32_t v6 = g193 - *v5; // 0x809e6f0
    int32_t v7 = g217 + 48; // 0x809e6f3
    int32_t v8 = g194 - *(int32_t *)v7; // 0x809e6f3
    int3_t v9; // 0x809e690
    int3_t v10 = v9 - 1; // 0x809e70b
    __frontend_reg_store_fpr(v10, (float80_t)(v4 * v4 + v2 * v2));
    int3_t v11 = v9 - 2; // 0x809e711
    __frontend_reg_store_fpr(v11, (float80_t)(v8 * v8 + v6 * v6));
    float80_t v12 = __frontend_reg_load_fpr(v11); // 0x809e714
    __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v10));
    __frontend_reg_store_fpr(v10, v12);
    float80_t v13 = __frontend_reg_load_fpr(v11); // 0x809e716
    float80_t v14 = __frontend_reg_load_fpr(v10); // 0x809e716
    bool v15 = false; // 0x809e716
    bool v16 = false; // 0x809e716
    if (v13 <= v14) {
        v15 = true;
        v16 = false;
        if (v13 >= v14) {
            v15 = v13 != v14;
            v16 = true;
        }
    }
    // 0x809e73b
    __frontend_reg_store_fpr(v10, __frontend_reg_load_fpr(v10));
    bool v17 = v15 | v16; // 0x809e71a
    int32_t v18 = *((v17 ? v1 : v5));
    int32_t v19 = v18; // bp-76, 0x809e747
    FortyFiveLine((int32_t)&v19);
    g61 = v18;
    g62 = *(int32_t *)(v17 ? v3 : v7);
    // 0x809e6b1
    return &g61;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/line.c
// Address range: 0x809f810 - 0x809f983
// Line range:    98 - 164
void FortyFiveLine(int32_t Line) {
    int32_t v1 = *(int32_t *)Line; // 0x809f827
    int32_t * v2 = (int32_t *)(Line + 4); // 0x809f82c
    int32_t v3 = *v2; // 0x809f82c
    int32_t v4 = g194 - v3; // 0x809f83d
    int32_t v5 = g193 - v1; // 0x809f83f
    int32_t v6; // 0x809f810
    if (v5 != 0) {
        // 0x809f898
        int3_t v7; // 0x809f810
        int3_t v8 = v7 - 1; // 0x809f89b
        __frontend_reg_store_fpr(v8, (float80_t)v4);
        int3_t v9 = v7 - 2; // 0x809f8a1
        __frontend_reg_store_fpr(v9, (float80_t)v5);
        __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v8) / __frontend_reg_load_fpr(v9));
        __frontend_reg_store_fpr(v9, 0.57735027L);
        float80_t v10 = __frontend_reg_load_fpr(v9); // 0x809f8ac
        __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v8));
        __frontend_reg_store_fpr(v8, v10);
        float80_t v11 = __frontend_reg_load_fpr(v9); // 0x809f8ae
        float80_t v12 = __frontend_reg_load_fpr(v8); // 0x809f8ae
        bool v13 = false; // 0x809f8ae
        bool v14 = false; // 0x809f8ae
        if (v11 <= v12) {
            v13 = true;
            v14 = false;
            if (v11 >= v12) {
                v13 = v11 != v12;
                v14 = true;
            }
        }
        __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v9));
        int32_t v15; // 0x809f810
        if (v13 || v14) {
            // 0x809f8d8
            __frontend_reg_store_fpr(v9, -0.57735027L);
            if (__frontend_reg_load_fpr(v9) <= __frontend_reg_load_fpr(v8)) {
                // 0x809f8c8
                __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v8));
                v15 = 2;
            } else {
                // 0x809f8e7
                __frontend_reg_store_fpr(v9, -1.7320508L);
                float80_t v16 = __frontend_reg_load_fpr(v9); // 0x809f8ed
                float80_t v17 = __frontend_reg_load_fpr(v8); // 0x809f8ed
                bool v18 = false; // 0x809f8ed
                bool v19 = false; // 0x809f8ed
                if (v16 <= v17) {
                    v18 = true;
                    v19 = false;
                    if (v16 >= v17) {
                        v18 = v16 != v17;
                        v19 = true;
                    }
                }
                __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v8));
                v15 = v18 | v19 ? 3 : 0;
            }
        } else {
            // 0x809f8b4
            __frontend_reg_store_fpr(v9, 1.7320508L);
            float80_t v20 = __frontend_reg_load_fpr(v9); // 0x809f8ba
            __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v8));
            __frontend_reg_store_fpr(v8, v20);
            float80_t v21 = __frontend_reg_load_fpr(v9); // 0x809f8bc
            float80_t v22 = __frontend_reg_load_fpr(v8); // 0x809f8bc
            bool v23 = false; // 0x809f8bc
            bool v24 = false; // 0x809f8bc
            if (v21 <= v22) {
                v23 = true;
                v24 = false;
                if (v21 >= v22) {
                    v23 = v21 != v22;
                    v24 = true;
                }
            }
            __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v8));
            v15 = v23 | v24;
        }
        int32_t v25 = v15;
        v6 = v5 >= 0 ? v25 : v25 | 4;
    } else {
        if (v4 == 0) {
            // 0x809f888
            return;
        }
        // 0x809f849
        v6 = 4 * (int32_t)(v4 < 1);
    }
    int32_t v26 = v4 < 0 ? -v4 : v4; // 0x809f858
    int32_t v27 = v5 < 0 ? -v5 : v5; // 0x809f861
    int32_t v28 = v26 - v27; // 0x809f863
    int32_t v29 = v28 < 0 == ((v28 ^ v26) & (v26 ^ v27)) < 0 == (v28 != 0) ? v27 : v26; // 0x809f865
    g226 = v6 % 256;
    uint32_t v30; // 0x809f810
    switch ((char)v30) {
        case 1: {
            // 0x809f958
            *(int32_t *)(Line + 20) = v29 + v1;
            *(int32_t *)(Line + 24) = *v2 + v29;
            // break -> 0x809f888
            break;
        }
        case 2: {
        }
        case 6: {
            // 0x809f940
            *(int32_t *)(Line + 20) = g193;
            *(int32_t *)(Line + 24) = v3;
            // break -> 0x809f888
            break;
        }
        case 3: {
            // 0x809f928
            *(int32_t *)(Line + 20) = v29 + v1;
            *(int32_t *)(Line + 24) = v3 - v29;
            // break -> 0x809f888
            break;
        }
        case 5: {
            // 0x809f910
            *(int32_t *)(Line + 20) = v1 - v29;
            *(int32_t *)(Line + 24) = v3 - v29;
            // break -> 0x809f888
            break;
        }
        case 7: {
            // 0x809f970
            *(int32_t *)(Line + 20) = v1 - v29;
            *(int32_t *)(Line + 24) = *v2 + v29;
            // break -> 0x809f888
            break;
        }
        default: {
            // 0x809f873
            *(int32_t *)(Line + 20) = v1;
            *(int32_t *)(Line + 24) = g194;
            // break -> 0x809f888
            break;
        }
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/line.c
// Address range: 0x809f990 - 0x809f9fd
// Line range:    61 - 84
void AdjustAttachedLine(void) {
    // 0x809f990
    if (g204 == 0) {
        // 0x809f9d4
        return;
    }
    // 0x809f99f
    if (g141 == 2) {
        // 0x809f9e8
        g205 = 0;
        return;
    }
    // 0x809f9a8
    g205 = 1;
    if (*(char *)(PCB + 40) == 0) {
        // 0x809f9ba
        if (*(char *)(PCB + 5) % 2 == 0) {
            // 0x809f9d8
            FortyFiveLine((int32_t)&g200);
            return;
        }
    }
    // 0x809f9c0
    g202 = (char *)g193;
    g203 = g194;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/line.c
// Address range: 0x809fa00 - 0x809fb9b
// Line range:    173 - 222
void AdjustTwoLine(int32_t way) {
    // 0x809fa00
    if (g204 != 0) {
        // 0x809faf0
        g205 = 0;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/line.c
// Address range: 0x809fba0 - 0x80a0730
// Line range:    290 - 483
float32_t drc_lines(int32_t end, char way) {
    int32_t v1[8]; // 0x809fba0
    struct __jmp_buf_tag v2; // 0x809fba0
    struct __jmp_buf_tag env[1]; // 0x809fba0
    int32_t v3 = __readgsdword(20); // 0x809fbb2
    int32_t v4; // bp-396, 0x809fba0
    MakeFlags((int32_t)&v4);
    int32_t v5; // 0x809fba0
    int32_t * v6 = (int32_t *)(v5 + 4); // 0x809fc51
    int32_t v7; // 0x809fba0
    if (*(char *)(PCB + 39) == 0) {
        // 0x80a06fe
        v7 = LayerStack[0];
    } else {
        int32_t v8 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24); // 0x809fcb2
        v7 = v8 + (int32_t)(g170 == 0);
    }
    int32_t v9 = GetGroupOfLayer(v7); // 0x809fcb8
    int32_t v10 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24); // 0x809fcce
    int32_t v11; // 0x809fba0
    char v12; // 0x809fba0
    if (GetLayerGroupNumberByNumber(v10) != v9) {
        int32_t v13 = *(int32_t *)(PCB + 0x220c); // 0x80a06df
        v11 = GetLayerGroupNumberByNumber(*(int32_t *)(v13 + 24) + 1);
        v12 = 0;
    } else {
        // 0x809fce5
        v11 = v10 + 10;
        v12 = 1;
    }
    int32_t v14 = *v6 - g201; // 0x809fc57
    int32_t v15 = v14 < 0 ? -v14 : v14; // 0x809fc7d
    int32_t v16 = v15 > -1 ? v15 : 0;
    char * v17 = g200; // 0x809fd0e
    int32_t v18 = g201; // 0x809fd0e
    float32_t result = 0.0f; // 0x809fd0e
    char * v19; // 0x809fba0
    char * v20; // 0x809fba0
    float32_t v21; // 0x809fba0
    float32_t v22; // 0x809fba0
    int32_t v23; // 0x809fba0
    int32_t v24; // 0x809fba0
    int32_t v25; // 0x809fba0
    float32_t v26; // 0x809fba0
    float32_t v27; // 0x809fba0
    float32_t v28; // 0x809fba0
    float32_t v29; // 0x809fba0
    float32_t v30; // 0x809fba0
    int32_t v31; // 0x809fba0
    int32_t v32; // 0x809fba0
    int32_t v33; // 0x809fba0
    if (v16 == -1) {
        goto lab_0x80a061a;
    } else {
        // 0x809fd14
        v33 = (int32_t)g200;
        v19 = g200;
        v26 = v14;
        v32 = g201;
        v22 = 0.0f;
        v30 = 0.5f;
        v24 = v15;
        v28 = 1.0f;
        v20 = g200;
        v27 = 1.0f;
        v23 = 0;
        v29 = 0.5f;
        v21 = 0.0f;
        v31 = g201;
        v25 = 0;
        if (v15 > -1) {
            goto lab_0x80a009d;
        } else {
            goto lab_0x80a06a7;
        }
    }
  lab_0x809fe3c:;
    // 0x809fe3c
    float32_t v34; // 0x809fba0
    float32_t v35 = v34; // 0x809fe6a
    int32_t v36; // 0x809fba0
    int32_t v37 = v36; // 0x809fe6a
    char v38 = 1; // 0x809fe6a
    int32_t v39 = v36; // 0x809fe6a
    int32_t v40; // 0x809fba0
    int32_t v41 = v40 + g201; // 0x809fe6a
    goto lab_0x809fe70;
  lab_0x809fe70:;
    int32_t v42 = v41;
    int32_t v43 = v39;
    int32_t v44 = v37;
    float32_t v45 = v35;
    int32_t v46; // 0x809fe70
    SetLineBoundingBox(v46);
    int32_t v47; // 0x809fba0
    SetLineBoundingBox(v47);
    char * v48; // 0x809fba0
    char * v49; // 0x809fba0
    float32_t v50; // 0x809fba0
    float32_t v51; // 0x809fba0
    char v52; // 0x809fba0
    char v53; // 0x809fba0
    float32_t v54; // 0x809fba0
    float32_t v55; // 0x809fba0
    float32_t v56; // 0x809fba0
    int32_t v57; // 0x809fba0
    int32_t v58; // 0x809fba0
    int32_t v59; // 0x809fba0
    if (_setjmp(env) == 0) {
        char v60 = v38;
        int32_t v61 = v46; // bp-372, 0x80a00ed
        int32_t v62 = *(int32_t *)(PCB + 0x220c); // 0x80a010c
        r_search(*(int32_t *)(v62 + 40), v46, 0, 0x80a0960, (char *)&v61);
        int32_t v63 = *(int32_t *)(PCB + 0x220c); // 0x80a013d
        r_search(*(int32_t *)(v63 + 48), v46, 0, 0x80a0960, (char *)&v61);
        if (v11 == v9 || v12 != 0) {
            int32_t v64 = *(int32_t *)(PCB + 0x220c); // 0x80a052e
            r_search(*(int32_t *)(v64 + 52), v46, 0, 0x80a08f0, (char *)&v61);
        }
        if (v60 != 0) {
            int32_t v65 = *(int32_t *)(PCB + 0x220c); // 0x80a0471
            v61 = v47;
            r_search(*(int32_t *)(v65 + 40), v47, 0, 0x80a0960, (char *)&v61);
            int32_t v66 = *(int32_t *)(PCB + 0x220c); // 0x80a04a5
            r_search(*(int32_t *)(v66 + 48), v47, 0, 0x80a0960, (char *)&v61);
            if (v11 != v9 != (v12 == 0)) {
                int32_t v67 = *(int32_t *)(PCB + 0x220c); // 0x80a04f2
                r_search(*(int32_t *)(v67 + 52), v47, 0, 0x80a08f0, (char *)&v61);
            }
        }
        int32_t v68 = *(int32_t *)(PCB + 0x220c); // 0x80a018a
        int32_t v69 = *(int32_t *)(v68 + 72); // 0x80a0196
        int32_t v70 = v68; // 0x80a019f
        int32_t v71 = v69; // 0x80a019f
        int32_t v72 = 0; // 0x80a019f
        if (*(int32_t *)(v69 + v59) != 0) {
            int32_t v73 = v70;
            uint32_t v74 = *(int32_t *)(v71 + 4 + 4 * (18 * v9 + 1860 + v72)); // 0x80a01d2
            int32_t v75; // 0x80a01f4
            int32_t * v76; // 0x80a020a
            int32_t * v77; // 0x80a023f
            if (v74 < *(int32_t *)(v73 + 24)) {
                // 0x80a01db
                v61 = v46;
                v75 = 92 * v74 + v73;
                v76 = (int32_t *)(v75 + 128);
                r_search(*v76, v46, 0, 0x80a08a0, (char *)&v61);
                v77 = (int32_t *)(v75 + 140);
                r_search(*v77, v46, 0, 0x80a0850, (char *)&v61);
                if (v60 != 0) {
                    // 0x80a0260
                    v61 = v47;
                    r_search(*v76, v47, 0, 0x80a08a0, (char *)&v61);
                    r_search(*v77, v47, 0, 0x80a0850, (char *)&v61);
                }
            }
            int32_t v78 = v72 + 1; // 0x80a01b5
            int32_t v79 = *(int32_t *)(PCB + 0x220c); // 0x80a01b8
            int32_t v80 = *(int32_t *)(v79 + 72); // 0x80a01be
            v72 = v78;
            while (*(int32_t *)(v80 + v59) > v78) {
                // 0x80a01cb
                v73 = v79;
                v74 = *(int32_t *)(v80 + 4 + 4 * (18 * v9 + 1860 + v72));
                if (v74 < *(int32_t *)(v73 + 24)) {
                    // 0x80a01db
                    v61 = v46;
                    v75 = 92 * v74 + v73;
                    v76 = (int32_t *)(v75 + 128);
                    r_search(*v76, v46, 0, 0x80a08a0, (char *)&v61);
                    v77 = (int32_t *)(v75 + 140);
                    r_search(*v77, v46, 0, 0x80a0850, (char *)&v61);
                    if (v60 != 0) {
                        // 0x80a0260
                        v61 = v47;
                        r_search(*v76, v47, 0, 0x80a08a0, (char *)&v61);
                        r_search(*v77, v47, 0, 0x80a0850, (char *)&v61);
                    }
                }
                // 0x80a01b0
                v78 = v72 + 1;
                v79 = *(int32_t *)(PCB + 0x220c);
                v80 = *(int32_t *)(v79 + 72);
                v72 = v78;
            }
        }
        float32_t v81 = v56 + v55; // 0x80a02f6
        float80_t v82 = v43; // 0x80a0308
        float80_t v83 = v42 - g201; // 0x80a031b
        float80_t v84 = v82 * v82 + v83 * v83; // 0x80a0323
        v48 = v49;
        v57 = v58;
        v50 = v51;
        v54 = v81;
        v52 = 0;
        if (v84 > (float80_t)v51) {
            // 0x80a0337
            v48 = (char *)(v43 + v33);
            v57 = v42;
            v50 = v84;
            v54 = v81;
            v52 = 0;
        }
    } else {
        // 0x809fe9f
        v48 = v49;
        v57 = v58;
        v50 = v51;
        v54 = v55 - v56;
        v52 = v53;
    }
    char v85 = v52;
    float32_t v86 = v54;
    float32_t v87 = v50;
    int32_t v88 = v57;
    char * v89 = v48;
    float80_t v90; // 0x809fba0
    float80_t v91 = v90 * (float80_t)v86; // 0x809fecc
    int32_t v92; // 0x809fba0
    int32_t v93; // 0x809fba0
    int32_t v94; // 0x809fba0
    if (v91 >= v90) {
        // 0x809ffc0
        v93 = v94;
        if (v92 == v94) {
            // break -> 0x809fffc
            goto lab_0x809fffc_2;
        }
    } else {
        int32_t v95 = v91; // 0x809fef6
        v93 = v95;
        if (v92 == v95) {
            // break -> 0x809fffc
            goto lab_0x809fffc_2;
        }
    }
    char * v96 = v89; // 0x809ff26
    float32_t v97 = v45; // 0x809ff26
    int32_t v98 = v44; // 0x809ff26
    int32_t v99 = v88; // 0x809ff26
    float32_t v100 = v87; // 0x809ff26
    float32_t v101 = 0.5f * v56; // 0x809ff26
    int32_t v102 = v93; // 0x809ff26
    float32_t v103 = v86; // 0x809ff26
    char v104 = v85; // 0x809ff26
    goto lab_0x809ff2c;
  lab_0x80a061a:;
    int32_t v119 = __readgsdword(20); // 0x80a061d
    *(int32_t *)v5 = (int32_t)v17;
    *v6 = v18;
    if (v3 != v119) {
        // 0x80a0720
        __stack_chk_fail();
        return result;
    }
    // 0x80a0647
    return result;
  lab_0x80a009d:;
    int32_t v120 = v24;
    float32_t v121 = v26;
    int32_t v122 = v120; // 0x80a00ab
    if ((int32_t)v121 < 1) {
        // 0x80a06bd
        v122 = (int32_t)v121 != 0 ? -v120 : 0;
    }
    int32_t v123 = v122 - v33; // 0x80a00bf
    char * v124 = v19; // 0x80a00db
    int32_t v125 = v122; // 0x80a00db
    int32_t v126 = v123; // 0x80a00db
    int32_t v127 = v32; // 0x80a00db
    float32_t v128 = v22; // 0x80a00db
    float32_t v129 = v30; // 0x80a00db
    int32_t v130 = v120; // 0x80a00db
    float32_t v131 = v28; // 0x80a00db
    int32_t v132 = v123 < 0 ? -v123 : v123; // 0x80a00db
    goto lab_0x809fd95;
  lab_0x80a06a7:;
    char * v141 = v20; // 0x80a06b8
    float32_t v147 = v27; // 0x80a06b8
    int32_t v146 = v23; // 0x80a06b8
    float32_t v145 = v29; // 0x80a06b8
    float32_t v144 = v21; // 0x80a06b8
    int32_t v143 = v31; // 0x80a06b8
    int32_t v142 = v25 != 0 ? -v23 : 0; // 0x80a06b8
    goto lab_0x809fd6e;
  lab_0x809fd95:
    // 0x809fd95
    v94 = v132;
    float32_t v133 = v131;
    int32_t v134 = v130;
    float32_t v135 = v129;
    v90 = v94;
    int32_t v136; // bp-120, 0x809fba0
    v46 = &v136;
    int32_t v137; // bp-208, 0x809fba0
    v47 = &v137;
    int32_t v138; // bp-364, 0x809fba0
    v1[0] = &v138;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    v59 = 4 * v9 + 0x1cd4;
    v96 = v124;
    v97 = v125;
    v98 = v126;
    v99 = v127;
    v100 = v128;
    v101 = 0.5f;
    v102 = v94;
    v103 = 1.0f;
    v104 = 1;
    while (true) {
      lab_0x809ff2c:
        // 0x809ff2c
        v53 = v104;
        v55 = v103;
        v92 = v102;
        v56 = v101;
        v51 = v100;
        v58 = v99;
        int32_t v105 = v98;
        float32_t v106 = v97;
        v49 = v96;
        if (v15 <= -1) {
            int32_t v107; // 0x809fba0
            int32_t v108; // 0x809fba0
            if ((int32_t)v106 < 1) {
                // 0x80a03e8
                v107 = 0;
                v108 = 0;
                if ((int32_t)v106 != 0) {
                    int32_t v109 = -v92; // 0x80a0566
                    v107 = v109 < 0 ? v92 : v109;
                    v108 = v109;
                }
            } else {
                // 0x809fdd5
                v107 = v92 < 0 ? -v92 : v92;
                v108 = v92;
            }
            int32_t v110 = v108;
            int32_t v111 = v105 < 0 ? -v105 : v105; // 0x809fdff
            v40 = v110;
            v34 = v110;
            v36 = v105;
            if (v111 > v107) {
                goto lab_0x809fe3c;
            } else {
                int32_t v112 = 0; // 0x80a0379
                if ((char)v5 != 0) {
                    // 0x80a05d0
                    v112 = v111;
                    if (v110 >= 0 != v110 != 0) {
                        // 0x80a05de
                        v112 = v110 != 0 ? -v111 : 0;
                    }
                }
                // 0x80a0381
                v35 = v110;
                v37 = v105;
                v38 = 0;
                v39 = v105;
                v41 = v112 + g201;
                goto lab_0x809fe70;
            }
        } else {
            int32_t v113; // 0x809fba0
            int32_t v114; // 0x809fba0
            if (v105 < 1) {
                // 0x80a03d8
                v113 = 0;
                v114 = 0;
                if (v105 != 0) {
                    int32_t v115 = -v92; // 0x80a054e
                    v113 = v115;
                    v114 = v115 < 0 ? v92 : v115;
                }
            } else {
                // 0x809ff46
                v113 = v92;
                v114 = v92 < 0 ? -v92 : v92;
            }
            int32_t v116 = v113;
            int32_t v117 = (int32_t)v106 < 0 ? -(int32_t)v106 : (int32_t)v106; // 0x809ff70
            v40 = v106;
            v34 = v106;
            v36 = v116;
            if (v117 < v114) {
                int32_t v118 = g201 + (int32_t)v106; // 0x80a0426
                v35 = v106;
                v37 = v116;
                v38 = 0;
                v39 = 0;
                v41 = v118;
                if ((char)v5 != 0) {
                    // 0x80a05a8
                    v35 = v106;
                    v37 = v116;
                    v38 = 0;
                    v39 = v117;
                    v41 = v118;
                    if (v116 >= 0 != v116 != 0) {
                        // 0x80a05b6
                        v35 = v106;
                        v37 = v116;
                        v38 = 0;
                        v39 = v116 != 0 ? -v117 : 0;
                        v41 = v118;
                    }
                }
                goto lab_0x809fe70;
            } else {
                goto lab_0x809fe3c;
            }
        }
    }
  lab_0x809fffc_2:;
    float32_t v139; // 0x809fba0
    if (v85 != 0) {
        // 0x80a0028
        v139 = v133 - v135;
        goto lab_0x80a003a;
    } else {
        if (v15 <= -1) {
            if (v43 != v44) {
                // 0x80a0028
                v139 = v133 - v135;
                goto lab_0x80a003a;
            } else {
                // 0x80a0690
                v139 = v135 + v133;
                goto lab_0x80a003a;
            }
        } else {
            if (v42 - g201 == (int32_t)v45) {
                // 0x80a0690
                v139 = v135 + v133;
                goto lab_0x80a003a;
            } else {
                // 0x80a0028
                v139 = v133 - v135;
                goto lab_0x80a003a;
            }
        }
    }
  lab_0x809fd6e:;
    int32_t v140 = *v6 - g201; // 0x809fd7d
    v124 = v141;
    v125 = v140;
    v126 = v142;
    v127 = v143;
    v128 = v144;
    v129 = v145;
    v130 = v146;
    v131 = v147;
    v132 = v140 < 0 ? -v140 : v140;
    goto lab_0x809fd95;
  lab_0x80a003a:;
    float32_t v148 = v139;
    float80_t v149 = v16; // 0x80a003a
    float80_t v150 = v149 * (float80_t)v148; // 0x80a0046
    int32_t v151; // 0x809fba0
    if (v150 >= v149) {
        // 0x80a05f4
        v151 = v16;
        v17 = v89;
        v18 = v88;
        result = v87;
        if (v134 != v16) {
            goto lab_0x80a0078;
        } else {
            goto lab_0x80a061a;
        }
    } else {
        int32_t v152 = v150; // 0x80a005a
        v151 = v152;
        v17 = v89;
        v18 = v88;
        result = v87;
        if (v134 == v152) {
            goto lab_0x80a061a;
        } else {
            goto lab_0x80a0078;
        }
    }
  lab_0x80a0078:;
    int32_t v153 = v151;
    float32_t v154 = 0.5f * v135; // 0x80a0091
    v19 = v89;
    v26 = v45;
    v32 = v88;
    v22 = v87;
    v30 = v154;
    v24 = v153;
    v28 = v148;
    if (v15 <= -1) {
        // 0x809fd5a
        v141 = v89;
        v147 = v148;
        v146 = v153;
        v145 = v154;
        v144 = v87;
        v143 = v88;
        v142 = v153;
        v20 = v89;
        v27 = v148;
        v23 = v153;
        v29 = v154;
        v21 = v87;
        v31 = v88;
        v25 = v44;
        if (v44 < 1) {
            goto lab_0x80a06a7;
        } else {
            goto lab_0x809fd6e;
        }
    } else {
        goto lab_0x80a009d;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/line.c
// Address range: 0x80a0730 - 0x80a084f
// Line range:    486 - 526
void EnforceLineDRC(void) {
    // 0x80a0730
    return;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/lrealpath.c
// Address range: 0x80a09b0 - 0x80a0a10
// Line range:    75 - 157
char * lrealpath(char * filename) {
    int32_t v1 = __readgsdword(20); // 0x80a09bd
    int32_t v2; // bp-4112, 0x80a09b0
    char * v3 = __realpath_chk(filename, (char *)&v2, 0x1000); // 0x80a09dd
    char * result = __strdup(v3 == NULL ? filename : v3); // 0x80a09ea
    if (v1 == __readgsdword(20)) {
        // 0x80a09fb
        return result;
    }
    // 0x80a0a04
    __stack_chk_fail();
    return (char *)&g231;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/main.c
// Address range: 0x80a0a10 - 0x80a0bb5
// Line range:    280 - 291
void print_defaults_1(int32_t a, char * value) {
    // 0x80a0a10
    int32_t v1; // 0x80a0a10
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x80a0a1c
    g227 = v2;
    int32_t v3; // 0x80a0a10
    int32_t v4; // 0x80a0a3f
    switch (v2) {
        case 1: {
            int32_t v5; // 0x80a0a10
            if (v1 == 0) {
                int32_t v6 = *(int32_t *)(v1 + 20); // 0x80a0ba8
                v3 = v6;
                v5 = v6;
            }
            // 0x80a0aba
            __fprintf_chk(g43, 1, "%s %d\n", (char *)v1, v5);
            return;
        }
        case 2: {
            float64_t * v7 = v1 == 0 ? (float64_t *)(v1 + 28) : (float64_t *)&v3;
            __fprintf_chk(g43, 1, "%s %g\n", (char *)v1, *v7);
            return;
        }
        case 3: {
        }
        case 7: {
            int32_t v8; // 0x80a0a10
            if (v1 == 0) {
                int32_t v9 = *(int32_t *)(v1 + 24); // 0x80a0b88
                v3 = v9;
                v8 = v9;
            }
            // 0x80a0b26
            __fprintf_chk(g43, 1, "%s \"%s\"\n", (char *)v1, (char *)v8);
            return;
        }
        case 4: {
            int32_t v10; // 0x80a0a10
            if (v1 == 0) {
                // 0x80a0b80
                v10 = *(int32_t *)(v1 + 20);
            } else {
                // 0x80a0a30
                v10 = 0x1000000 * v1 / 0x1000000;
            }
            // 0x80a0a33
            v4 = v10 != 0 ? (int32_t)"yes" : (int32_t)"no";
            // break -> 0x80a0a42
            break;
        }
        case 5: {
            int32_t v11 = *(int32_t *)(v1 + 36); // 0x80a0b56
            int32_t v12 = *(int32_t *)(v11 + 4 * *((v1 == 0 ? (int32_t *)(v1 + 20) : &v3))); // 0x80a0b59
            // 0x80a0a42
            v3 = v12;
            __fprintf_chk(g43, 1, "%s %s\n", (char *)v1, (char *)v12);
            // 0x80a0a69
            return;
        }
        case 6: {
            int32_t v13; // 0x80a0a10
            float64_t * v14; // 0x80a0a10
            if (v1 == 0) {
                // 0x80a0b68
                v13 = *(int32_t *)(v1 + 20);
                v14 = (float64_t *)(v1 + 28);
            } else {
                // 0x80a0a78
                v14 = (float64_t *)&v3;
            }
            float64_t v15 = *v14;
            int32_t v16 = *(int32_t *)(*(int32_t *)(v1 + 36) + 4 * v13); // 0x80a0a7f
            __fprintf_chk(g43, 1, "%s %g%s\n", (char *)v1, v15, (char *)v16);
            return;
        }
        default: {
            // 0x80a0a69
            return;
        }
    }
    // 0x80a0a42
    v3 = v4;
    __fprintf_chk(g43, 1, "%s %s\n", (char *)v1, (char *)v4);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/main.c
// Address range: 0x80a0bc0 - 0x80a0c00
// Line range:    136 - 143
void u(char * fmt, ...) {
    // 0x80a0bc0
    int32_t v1; // 0x80a0bc0
    __vfprintf_chk(g43, 1, fmt, (int32_t)&v1);
    fputc(10, g43);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/main.c
// Address range: 0x80a0c00 - 0x80a0ed9
// Line range:    146 - 146
void usage_attr(int32_t a) {
    // 0x80a0c00
    int32_t v1; // 0x80a0c00
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x80a0c0b
    int32_t v3 = *v2; // 0x80a0c0b
    if (v3 == 1) {
        // 0x80a0ca4
        return;
    }
    int32_t * v4 = (int32_t *)(v1 + 8); // 0x80a0cb0
    int32_t v5 = *v4; // 0x80a0cb0
    g228 = v5;
    int32_t v6 = v3; // 0x80a0cb3
    char * v7 = "--%s"; // 0x80a0cb3
    switch (v5) {
        case 0: {
            // 0x80a0ca4
            return;
        }
        case 1: {
        }
        case 2: {
            // 0x80a0e08
            v7 = "--%s <num>";
        }
        case 4: {
          lab_0x80a0dce:
            // 0x80a0dce
            __sprintf_chk((char *)&g63, 1, 200, v7, (char *)v5);
            v6 = *v2;
            // break -> 0x80a0c21
            break;
        }
        case 3: {
            // 0x80a0df8
            v7 = "--%s <string>";
            // branch (via goto) -> 0x80a0dce
            goto lab_0x80a0dce;
        }
        case 5: {
        }
        case 6: {
            // 0x80a0d00
            __sprintf_chk((char *)&g63, 1, 200, "--%s ", (char *)v5);
            if (*v4 == 6) {
                // 0x80a0eb8
                __strcat_chk((char *)&g63, " <val>", 200);
            }
            int32_t * v8 = (int32_t *)(v1 + 36); // 0x80a0d34
            int32_t v9 = (int32_t)&g6; // 0x80a0d3b
            if (*(int32_t *)*v8 != 0) {
                int32_t v10 = 1; // 0x80a0d50
                __strcat_chk((char *)&g63, (char *)v9, 200);
                int32_t v11 = *(int32_t *)*v8; // 0x80a0d6e
                int32_t v12 = 4 * v10; // 0x80a0d71
                __strcat_chk((char *)&g63, (char *)v11, 200);
                v9 = &g7;
                int32_t v13 = v10; // 0x80a0d95
                int32_t v14 = v12; // 0x80a0d95
                while (*(int32_t *)(*v8 + v12) != 0) {
                    // 0x80a0d48
                    v10 = v13 + 1;
                    __strcat_chk((char *)&g63, (char *)v9, 200);
                    v11 = *(int32_t *)(*v8 + v14);
                    v12 = 4 * v10;
                    __strcat_chk((char *)&g63, (char *)v11, 200);
                    v9 = &g7;
                    v13 = v10;
                    v14 = v12;
                }
            }
            // 0x80a0d97
            __strcat_chk((char *)&g63, ">", 200);
            v6 = *v2;
            // break -> 0x80a0c21
            break;
        }
        case 7: {
            // 0x80a0e18
            v7 = "--%s <path>";
            // branch (via goto) -> 0x80a0dce
            goto lab_0x80a0dce;
        }
    }
    int32_t v15 = (int32_t)&g63;
    int32_t v16 = *(int32_t *)v15; // 0x80a0c26
    int32_t v17 = v15 + 4; // 0x80a0c28
    int32_t v18 = v16 - 0x1010101 & (v16 ^ -0x7f7f7f80); // 0x80a0c33
    uint32_t v19 = v18 & -0x7f7f7f80; // 0x80a0c35
    while (v19 == 0) {
        // 0x80a0c26
        v15 = v17;
        v16 = *(int32_t *)v15;
        v17 = v15 + 4;
        v18 = v16 - 0x1010101 & (v16 ^ -0x7f7f7f80);
        v19 = v18 & -0x7f7f7f80;
    }
    int32_t v20 = (v18 & 0x8080) == 0 ? v15 + 6 : v17; // 0x80a0c4c
    unsigned char v21 = (char)((v18 & 0x8080) == 0 ? v19 / 0x10000 : v19); // 0x80a0c4f
    uint32_t v22 = v20 - (-1 - v21 < v21 ? 4 : 3) - (int32_t)&g63; // 0x80a0c54
    if (v22 < 31) {
        // 0x80a0cc0
        if (v6 != 0) {
            // 0x80a0cc8
            __fprintf_chk(g43, 1, " %-30s\t%s\n", (char *)&g63, (char *)v6);
            return;
        }
        // 0x80a0e88
        __fprintf_chk(g43, 1, " %-30s\n", (char *)&g63);
        // 0x80a0ca4
        return;
    }
    if (v6 == 0) {
        // 0x80a0e28
        __fprintf_chk(g43, 1, " %s\n", (char *)&g63);
        // 0x80a0ca4
        return;
    }
    char * str = (char *)v6;
    if (strlen(str) + v22 < 72) {
        // 0x80a0e58
        __fprintf_chk(g43, 1, " %s\t%s\n", (char *)&g63, str);
    } else {
        // 0x80a0c7b
        __fprintf_chk(g43, 1, " %s\n\t\t\t%s\n", (char *)&g63, str);
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/main.c
// Address range: 0x80a0ee0 - 0x80a0ffc
// Line range:    201 - 230
void usage_hid(int32_t h) {
    // 0x80a0ee0
    int32_t v1; // 0x80a0ee0
    if (*(char *)(v1 + 12) % 2 == 0) {
        // 0x80a0f95
        __fprintf_chk(g43, 1, "\n%s options:\n", (char *)*(int32_t *)(v1 + 4));
        int32_t v2 = 0; // 0x80a0fd1
        if (v1 < 1) {
            // 0x80a0fea
            exporter = 0;
            return;
        }
        v2++;
        usage_attr((int32_t)&g231);
        while (v2 != v1) {
            // 0x80a0fd8
            v2++;
            usage_attr((int32_t)&g231);
        }
        // 0x80a0fea
        exporter = 0;
        return;
    }
    int32_t v3 = hid_enumerate(); // 0x80a0ef5
    __fprintf_chk(g43, 1, "\ngui options:\n");
    if (hid_attr_nodes == 0) {
        // 0x80a0f59
        return;
    }
    int32_t v4 = hid_attr_nodes; // 0x80a0ee0
    int32_t v5; // 0x80a0ee0
    while (true) {
      lab_0x80a0f28_2:
        // 0x80a0f28
        v5 = v4;
        int32_t v6 = *(int32_t *)v3; // 0x80a0f2b
        if (v6 != 0) {
            int32_t v7 = v6; // 0x80a0f38
            int32_t v8 = v3; // 0x80a0f38
            while (*(int32_t *)(v5 + 4) != v7) {
                // 0x80a0f38
                v8 += 4;
                v7 = *(int32_t *)v8;
                if (v7 == 0) {
                    goto lab_0x80a0f68;
                }
            }
            goto lab_0x80a0f53;
        } else {
            goto lab_0x80a0f68;
        }
    }
  lab_0x80a0f68:;
    int32_t * v9 = (int32_t *)(v5 + 8); // 0x80a0f68
    if (*v9 < 1) {
        goto lab_0x80a0f53;
    } else {
        int32_t v10 = 1; // 0x80a0f7b
        usage_attr((int32_t)&g231);
        int32_t v11 = v10; // 0x80a0f8b
        while (*v9 > v10) {
            // 0x80a0f78
            v10 = v11 + 1;
            usage_attr((int32_t)&g231);
            v11 = v10;
        }
        int32_t v12 = *(int32_t *)v5; // 0x80a0f8d
        if (v12 == 0) {
            return;
        }
        // 0x80a0f28
        v4 = v12;
        goto lab_0x80a0f28_2;
    }
  lab_0x80a0f53:;
    int32_t v13 = *(int32_t *)v5; // 0x80a0f53
    if (v13 == 0) {
        return;
    }
    // 0x80a0f28
    v4 = v13;
    goto lab_0x80a0f28_2;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/main.c
// Address range: 0x80a1000 - 0x80a12f2
// Line range:    233 - 251
void usage(void) {
    int32_t v1 = hid_enumerate(); // 0x80a1009
    int32_t * v2 = (int32_t *)v1; // 0x80a1013
    int32_t v3 = *v2; // 0x80a1013
    int32_t v4 = v1; // 0x80a1017
    int32_t v5 = 0; // 0x80a1017
    int32_t v6 = 0; // 0x80a1017
    int32_t v7 = 0; // 0x80a1017
    int32_t v8; // 0x80a1000
    int32_t v9; // 0x80a1000
    int32_t v10; // 0x80a1000
    int32_t v11; // 0x80a1000
    int32_t v12; // 0x80a1000
    if (v3 == 0) {
        // 0x80a12b3
        u("PCB Printed Circuit Board editing program, http://pcb.sourceforge.net");
        u("%s [-h|-V|--copyright]\t\t\tHelp, version, copyright", (char *)Progname);
        u("%s [gui options] <pcb file>\t\tto edit", (char *)Progname);
        v8 = 0;
        v10 = 0;
        goto lab_0x80a1094;
    } else {
        unsigned char v13 = *(char *)(v3 + 12); // 0x80a1028
        v7 += (int32_t)(v13 % 2 != 0);
        v6 += (int32_t)((v13 & 2) != 0);
        v4 += 4;
        int32_t v14 = *(int32_t *)v4; // 0x80a1047
        v5 += (int32_t)((v13 & 4) != 0);
        while (v14 != 0) {
            // 0x80a1028
            v13 = *(char *)(v14 + 12);
            v7 += (int32_t)(v13 % 2 != 0);
            v6 += (int32_t)((v13 & 2) != 0);
            v4 += 4;
            v14 = *(int32_t *)v4;
            v5 += (int32_t)((v13 & 4) != 0);
        }
        // 0x80a1054
        u("PCB Printed Circuit Board editing program, http://pcb.sourceforge.net");
        u("%s [-h|-V|--copyright]\t\t\tHelp, version, copyright", (char *)Progname);
        u("%s [gui options] <pcb file>\t\tto edit", (char *)Progname);
        v8 = v5;
        v10 = v6;
        v9 = v5;
        v11 = v6;
        v12 = (int32_t)&g5;
        if (v7 == 1) {
            goto lab_0x80a1099;
        } else {
            goto lab_0x80a1094;
        }
    }
  lab_0x80a1094:
    // 0x80a1094
    v9 = v8;
    v11 = v10;
    v12 = &g3;
    goto lab_0x80a1099;
  lab_0x80a1099:
    // 0x80a1099
    u("Available GUI hid%s:", (char *)v12);
    int32_t v15 = *v2; // 0x80a10ac
    int32_t v16 = v15; // 0x80a10b0
    int32_t v17 = v1; // 0x80a10b0
    if (v15 != 0) {
        while (true) {
            int32_t v18 = v17;
            int32_t v19 = v16;
            int32_t v20; // 0x80a1000
            int32_t v21; // 0x80a1000
            if (*(char *)(v19 + 12) % 2 == 0) {
                int32_t v22 = v18 + 4; // 0x80a10b8
                int32_t v23 = *(int32_t *)v22; // 0x80a10b8
                v20 = v23;
                v21 = v22;
                if (v23 == 0) {
                    // break -> 0x80a10fd
                    break;
                }
            } else {
                int32_t v24 = *(int32_t *)(v19 + 8); // 0x80a10c8
                int32_t v25 = *(int32_t *)(v19 + 4); // 0x80a10cf
                __fprintf_chk(g43, 1, "\t%s\t%s\n", (char *)v25, (char *)v24);
                int32_t v26 = v18 + 4; // 0x80a10f3
                int32_t v27 = *(int32_t *)v26; // 0x80a10f3
                v20 = v27;
                v21 = v26;
                if (v27 == 0) {
                    // break -> 0x80a10fd
                    break;
                }
            }
            // 0x80a10c2
            v16 = v20;
            v17 = v21;
        }
    }
    // 0x80a10fd
    u("%s -p [printing options] <pcb file>\tto print", (char *)Progname);
    int32_t v28 = v11 == 1 ? (int32_t)&g5 : (int32_t)&g3; // 0x80a111f
    u("Available printing hid%s:", (char *)v28);
    int32_t v29 = *v2; // 0x80a1135
    int32_t v30 = v29; // 0x80a1139
    int32_t v31 = v1; // 0x80a1139
    if (v29 != 0) {
        while (true) {
            int32_t v32 = v31;
            int32_t v33 = v30;
            int32_t v34; // 0x80a1000
            int32_t v35; // 0x80a1000
            if ((*(char *)(v33 + 12) & 2) == 0) {
                int32_t v36 = v32 + 4; // 0x80a1140
                int32_t v37 = *(int32_t *)v36; // 0x80a1140
                v34 = v37;
                v35 = v36;
                if (v37 == 0) {
                    // break -> 0x80a1185
                    break;
                }
            } else {
                int32_t v38 = *(int32_t *)(v33 + 8); // 0x80a1150
                int32_t v39 = *(int32_t *)(v33 + 4); // 0x80a1157
                __fprintf_chk(g43, 1, "\t%s\t%s\n", (char *)v39, (char *)v38);
                int32_t v40 = v32 + 4; // 0x80a117b
                int32_t v41 = *(int32_t *)v40; // 0x80a117b
                v34 = v41;
                v35 = v40;
                if (v41 == 0) {
                    // break -> 0x80a1185
                    break;
                }
            }
            // 0x80a114a
            v30 = v34;
            v31 = v35;
        }
    }
    // 0x80a1185
    u("%s -x hid [export options] <pcb file>\tto export", (char *)Progname);
    int32_t v42 = v9 == 1 ? (int32_t)&g5 : (int32_t)&g3; // 0x80a11a7
    u("Available export hid%s:", (char *)v42);
    int32_t v43 = *v2; // 0x80a11bd
    int32_t v44 = v43; // 0x80a11c1
    int32_t v45 = v1; // 0x80a11c1
    if (v43 == 0) {
        // 0x80a12a7
        exit(1);
        // UNREACHABLE
    }
    while (true) {
        int32_t v46 = v45;
        int32_t v47 = v44;
        int32_t v48; // 0x80a1000
        int32_t v49; // 0x80a1000
        if ((*(char *)(v47 + 12) & 4) == 0) {
            int32_t v50 = v46 + 4; // 0x80a11d0
            int32_t v51 = *(int32_t *)v50; // 0x80a11d0
            v48 = v51;
            v49 = v50;
            if (v51 == 0) {
                // break -> 0x80a1215
                break;
            }
        } else {
            int32_t v52 = *(int32_t *)(v47 + 8); // 0x80a11e0
            int32_t v53 = *(int32_t *)(v47 + 4); // 0x80a11e7
            __fprintf_chk(g43, 1, "\t%s\t%s\n", (char *)v53, (char *)v52);
            int32_t v54 = v46 + 4; // 0x80a120b
            int32_t v55 = *(int32_t *)v54; // 0x80a120b
            v48 = v55;
            v49 = v54;
            if (v55 == 0) {
                // break -> 0x80a1215
                break;
            }
        }
        // 0x80a11da
        v44 = v48;
        v45 = v49;
    }
    int32_t v56 = *v2; // 0x80a1218
    int32_t v57 = v56; // 0x80a121c
    int32_t v58 = v1; // 0x80a121c
    if (v56 == 0) {
        // 0x80a12a7
        exit(1);
        // UNREACHABLE
    }
    while (true) {
        int32_t v59 = v58;
        int32_t v60; // 0x80a1000
        int32_t v61; // 0x80a1000
        if (*(char *)(v57 + 12) % 2 == 0) {
            int32_t v62 = v59 + 4; // 0x80a1228
            int32_t v63 = *(int32_t *)v62; // 0x80a1228
            v60 = v63;
            v61 = v62;
            if (v63 == 0) {
                // break -> 0x80a1247
                break;
            }
        } else {
            // 0x80a1238
            usage_hid((int32_t)&g231);
            int32_t v64 = v59 + 4; // 0x80a123d
            int32_t v65 = *(int32_t *)v64; // 0x80a123d
            v60 = v65;
            v61 = v64;
            if (v65 == 0) {
                // break -> 0x80a1247
                break;
            }
        }
        // 0x80a1232
        v57 = v60;
        v58 = v61;
    }
    int32_t v66 = *v2; // 0x80a124a
    int32_t v67 = v66; // 0x80a124e
    int32_t v68 = v1; // 0x80a124e
    if (v66 == 0) {
        // 0x80a12a7
        exit(1);
        // UNREACHABLE
    }
    while (true) {
        int32_t v69 = v68;
        int32_t v70; // 0x80a1000
        int32_t v71; // 0x80a1000
        if ((*(char *)(v67 + 12) & 2) == 0) {
            int32_t v72 = v69 + 4; // 0x80a1258
            int32_t v73 = *(int32_t *)v72; // 0x80a1258
            v70 = v73;
            v71 = v72;
            if (v73 == 0) {
                // break -> 0x80a1277
                break;
            }
        } else {
            // 0x80a1268
            usage_hid((int32_t)&g231);
            int32_t v74 = v69 + 4; // 0x80a126d
            int32_t v75 = *(int32_t *)v74; // 0x80a126d
            v70 = v75;
            v71 = v74;
            if (v75 == 0) {
                // break -> 0x80a1277
                break;
            }
        }
        // 0x80a1262
        v67 = v70;
        v68 = v71;
    }
    int32_t v76 = *v2; // 0x80a127a
    int32_t v77 = v76; // 0x80a127e
    int32_t v78 = v1; // 0x80a127e
    if (v76 == 0) {
        // 0x80a12a7
        exit(1);
        // UNREACHABLE
    }
    while (true) {
        int32_t v79 = v78;
        int32_t v80; // 0x80a1000
        int32_t v81; // 0x80a1000
        if ((*(char *)(v77 + 12) & 4) == 0) {
            int32_t v82 = v79 + 4; // 0x80a1288
            int32_t v83 = *(int32_t *)v82; // 0x80a1288
            v80 = v83;
            v81 = v82;
            if (v83 == 0) {
                // break -> 0x80a12a7
                break;
            }
        } else {
            // 0x80a1298
            usage_hid((int32_t)&g231);
            int32_t v84 = v79 + 4; // 0x80a129d
            int32_t v85 = *(int32_t *)v84; // 0x80a129d
            v80 = v85;
            v81 = v84;
            if (v85 == 0) {
                // break -> 0x80a12a7
                break;
            }
        }
        // 0x80a1292
        v77 = v80;
        v78 = v81;
    }
    // 0x80a12a7
    exit(1);
    // UNREACHABLE
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/main.c
// Address range: 0x80a1300 - 0x80a132e
// Line range:    602 - 605
void print_version(void) {
    // 0x80a1300
    __printf_chk(1, "PCB version %s\n", "20091103");
    exit(0);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/main.c
// Address range: 0x80a1330 - 0x80a1367
// Line range:    113 - 132
void copyright(void) {
    // 0x80a1330
    __printf_chk(1, "\n                COPYRIGHT for %s version %s\n\n    PCB, interactive printed circuit board design\n    Copyright (C) 1994,1995,1996,1997 Thomas Nau\n    Copyright (C) 1998, 1999, 2000 Harry Eaton\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\n", (char *)Progname, "20091103");
    exit(0);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/main.c
// Address range: 0x80a1370 - 0x80a138c
// Line range:    555 - 555
void register_main_attribute_list(void) {
    // 0x80a1370
    hid_register_attributes((int32_t)&main_attribute_list, 133);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/main.c
// Address range: 0x80a1390 - 0x80a2132
// Line range:    834 - 928
int main(int argc, char ** argv) {
    int32_t v1 = __readgsdword(20); // 0x80a13ab
    register_action_action_list();
    register_rotate_action_list();
    register_command_action_list();
    register_djopt_flag_list();
    register_djopt_action_list();
    register_flags_flag_list();
    register_fontmode_action_list();
    register_main_attribute_list();
    register_move_action_list();
    register_netlist_action_list();
    register_puller_action_list();
    register_report_action_list();
    register_vendor_action_list();
    register_vendor_flag_list();
    register_toporouter_action_list();
    setbuf((struct _IO_FILE *)(0x1000000 * g45 / 0x1000000), NULL);
    char * v2 = *argv;
    int32_t v3 = (int32_t)v2;
    char * str = (char *)(0x1000000 * v3 / 0x1000000); // 0x80a1428
    int32_t len = strlen(str); // 0x80a1428
    int32_t v4 = 0; // 0x80a1444
    int32_t v5 = 0; // 0x80a1444
    int32_t v6; // 0x80a1390
    if (len != 0) {
        v5 = *(char *)(v4 + v3) == 47 ? 1 : v5;
        v4++;
        while (v4 != len) {
            // 0x80a1438
            v5 = *(char *)(v4 + v3) == 47 ? 1 : v5;
            v4++;
        }
        if (v5 == 0) {
            goto lab_0x80a1c7f;
        } else {
            char * v7 = lrealpath(str); // 0x80a1451
            int32_t v8 = (int32_t)__strdup((char *)(0x1000000 * (int32_t)v7 / 0x1000000)); // 0x80a1459
            bindir = v8;
            v6 = v8;
            goto lab_0x80a1465;
        }
    } else {
        goto lab_0x80a1c7f;
    }
  lab_0x80a176a:;
    // 0x80a176a
    int32_t * v9; // 0x80a1724
    int32_t v10 = *v9; // 0x80a176a
    int32_t v11; // 0x80a1390
    *(int32_t *)(v11 + (int32_t)&g37) = pcblibpath;
    int32_t v12 = v10; // 0x80a177d
    int32_t v13; // 0x80a1390
    if (v10 != 0) {
        goto lab_0x80a1700;
    } else {
        if (v11 == 0x18c0) {
            // break -> 0x80a178a
            goto lab_0x80a178a_2;
        }
        // 0x80a1724
        v13 = v11 + 48;
        goto lab_0x80a1724_2;
    }
  lab_0x80a1719:
    if (v11 == 0x18c0) {
        // break -> 0x80a178a
        goto lab_0x80a178a_2;
    }
    // 0x80a1724
    v13 = v11 + 48;
    goto lab_0x80a1724_2;
  lab_0x80a174a:;
    int32_t v21 = 10; // 0x80a1390
    int32_t v14; // 0x80a1724
    int32_t v22 = v14;
    int32_t v23 = (int32_t)"font-path";
    unsigned char v24 = *(char *)v22; // 0x80a1756
    char v25 = *(char *)v23; // 0x80a1756
    char v26 = v25; // 0x80a1756
    bool v27 = false; // 0x80a1756
    int32_t v20; // 0x80a1390
    while (v24 == v25) {
        int32_t v28 = v21 - 1; // 0x80a1756
        int32_t v29 = v23 + v20; // 0x80a1756
        int32_t v30 = v22 + v20; // 0x80a1756
        v21 = v28;
        v26 = v24;
        v27 = true;
        if (v28 == 0) {
            // break -> 
            break;
        }
        v22 = v30;
        v23 = v29;
        v24 = *(char *)v22;
        v25 = *(char *)v23;
        v26 = v25;
        v27 = false;
    }
    unsigned char v31 = v26;
    int32_t v32 = v14; // 0x80a1764
    int32_t v33 = 13; // 0x80a1764
    if ((v24 >= v31 && !v27) != v24 < v31) {
        int32_t v34 = v32;
        int32_t v35 = (int32_t)"element-path";
        unsigned char v36 = *(char *)v34; // 0x80a16d4
        char v37 = *(char *)v35; // 0x80a16d4
        char v38 = v37; // 0x80a16d4
        bool v39 = false; // 0x80a16d4
        while (v36 == v37) {
            int32_t v40 = v33 - 1; // 0x80a16d4
            int32_t v41 = v35 + v20; // 0x80a16d4
            v32 = v34 + v20;
            v33 = v40;
            v38 = v36;
            v39 = true;
            if (v40 == 0) {
                // break -> 
                break;
            }
            v34 = v32;
            v35 = v41;
            v36 = *(char *)v34;
            v37 = *(char *)v35;
            v38 = v37;
            v39 = false;
        }
        unsigned char v42 = v38;
        int32_t v43 = v14; // 0x80a16e2
        int32_t v44 = 9; // 0x80a16e2
        if ((v36 >= v42 && !v39) == v36 < v42) {
            goto lab_0x80a176a;
        } else {
            int32_t v45 = v43;
            int32_t v46 = (int32_t)"lib-path"; // 0x80a1390
            while (*(char *)v45 == *(char *)v46) {
                int32_t v47 = v44 - 1; // 0x80a16f4
                v46 += v20;
                v43 = v45 + v20;
                v44 = v47;
                if (v47 == 0) {
                    goto lab_0x80a176a;
                }
                v45 = v43;
            }
            // 0x80a16f8
            v12 = *v9;
            goto lab_0x80a1700;
        }
    } else {
        goto lab_0x80a176a;
    }
  lab_0x80a1700:;
    int32_t v48 = 11; // 0x80a1390
    int32_t v49 = v12;
    int32_t v50 = (int32_t)"lib-newlib";
    while (*(char *)v49 == *(char *)v50) {
        int32_t v51 = v48 - 1; // 0x80a170a
        int32_t v52 = v50 + v20; // 0x80a170a
        int32_t v53 = v49 + v20; // 0x80a170a
        v48 = v51;
        if (v51 == 0) {
            // 0x80a170e
            *(int32_t *)(v11 + (int32_t)&g37) = pcbtreepath;
            goto lab_0x80a1719;
        }
        v49 = v53;
        v50 = v52;
    }
    goto lab_0x80a1719;
  lab_0x80a1c7f:;
    char * env_val = getenv((char *)(int32_t)(char)"PATH"); // 0x80a1c86
    if (env_val != NULL) {
        int32_t str2 = 0x1000000 * (int32_t)__strdup((char *)(0x1000000 * (int32_t)env_val / 0x1000000)) / 0x1000000; // 0x80a1caa
        char * next_token = strtok((char *)str2, ":"); // 0x80a1caa
        if (next_token != NULL) {
            char * next_token2 = next_token; // 0x80a1d57
            while (*next_token2 != 0) {
                int32_t len2 = strlen(str); // 0x80a1cc3
                int32_t * mem = calloc(1, len2 + 2 + strlen((char *)(0x1000000 * (int32_t)next_token2 / 0x1000000))); // 0x80a1ce1
                if (mem == NULL) {
                    // 0x80a20dd
                    __fprintf_chk((struct _IO_FILE *)(0x1000000 * (int32_t)g43 / 0x1000000), 1, "InitPaths():  malloc failed\n");
                    exit(1);
                    // UNREACHABLE
                }
                int32_t v54 = 0x1000000 * (int32_t)mem / 0x1000000; // 0x80a1d1b
                char * v55 = (char *)v54;
                __sprintf_chk(v55, 1, -1, "%s%s%s", next_token2, (char *)&g35, v2);
                int32_t v56; // bp-148, 0x80a1390
                if (__xstat(3, (char *)mem, (struct stat *)&v56) == 0) {
                    // 0x80a207d
                    bindir = (int32_t)lrealpath(v55);
                    free((int32_t *)v54);
                    free((int32_t *)str2);
                    v6 = bindir;
                    goto lab_0x80a1465;
                }
                // 0x80a1d40
                free((int32_t *)v54);
                next_token2 = strtok(NULL, ":");
                if (next_token2 == NULL) {
                    // break -> 0x80a1d6b
                    break;
                }
            }
        }
        // 0x80a1d6b
        free((int32_t *)str2);
    }
    int32_t * mem2 = calloc(1, 9); // 0x80a1d86
    int32_t v57 = (int32_t)mem2; // 0x80a1d86
    if (mem2 != NULL) {
        // 0x80a1d91
        *mem2 = 0x7273752f;
        *(int32_t *)(v57 + 4) = 0x6e69622f;
        *(char *)(v57 + 8) = 0;
    }
    // 0x80a1da2
    bindir = v57;
    int32_t v58 = v57; // 0x80a1da7
    goto lab_0x80a14b4;
  lab_0x80a14b4:;
    int32_t * mem3 = calloc(1, strlen((char *)(0x1000000 * v58 / 0x1000000)) + 4); // 0x80a14ca
    int32_t v59 = (int32_t)mem3; // 0x80a14ca
    exec_prefix = v59;
    if (mem3 == NULL) {
        // 0x80a20dd
        __fprintf_chk((struct _IO_FILE *)(0x1000000 * (int32_t)g43 / 0x1000000), 1, "InitPaths():  malloc failed\n");
        exit(1);
        // UNREACHABLE
    }
    // 0x80a14dc
    __sprintf_chk((char *)(0x1000000 * v59 / 0x1000000), 1, -1, "%s%s%s", (char *)bindir, (char *)&g35, "..");
    int32_t * mem4 = calloc(1, strlen((char *)(0x1000000 * bindir / 0x1000000)) + 14); // 0x80a1531
    int32_t v60 = (int32_t)mem4; // 0x80a1531
    pcblibdir = v60;
    if (mem4 == NULL) {
        // 0x80a20dd
        __fprintf_chk((struct _IO_FILE *)(0x1000000 * (int32_t)g43 / 0x1000000), 1, "InitPaths():  malloc failed\n");
        exit(1);
        // UNREACHABLE
    }
    // 0x80a1543
    __sprintf_chk((char *)(0x1000000 * v60 / 0x1000000), 1, -1, "%s%s%s", (char *)bindir, (char *)&g35, "../share/pcb");
    int32_t * mem5 = calloc(1, strlen((char *)(0x1000000 * bindir / 0x1000000)) + 21); // 0x80a1598
    int32_t v61 = (int32_t)mem5; // 0x80a1598
    pcbtreedir = v61;
    if (mem5 == NULL) {
        // 0x80a20dd
        __fprintf_chk((struct _IO_FILE *)(0x1000000 * (int32_t)g43 / 0x1000000), 1, "InitPaths():  malloc failed\n");
        exit(1);
        // UNREACHABLE
    }
    // 0x80a15aa
    __sprintf_chk((char *)(0x1000000 * v61 / 0x1000000), 1, -1, "%s%s%s", (char *)bindir, (char *)&g35, "../share/pcb/newlib");
    int32_t * mem6 = calloc(1, strlen((char *)(0x1000000 * pcblibdir / 0x1000000)) + 3); // 0x80a15ff
    int32_t v62 = (int32_t)mem6; // 0x80a15ff
    pcblibpath = v62;
    if (mem6 == NULL) {
        // 0x80a20dd
        __fprintf_chk((struct _IO_FILE *)(0x1000000 * (int32_t)g43 / 0x1000000), 1, "InitPaths():  malloc failed\n");
        exit(1);
        // UNREACHABLE
    }
    // 0x80a1611
    __sprintf_chk((char *)(0x1000000 * v62 / 0x1000000), 1, -1, ".%s%s", ":", (char *)pcblibdir);
    int32_t len3 = strlen((char *)(0x1000000 * pcblibdir / 0x1000000)); // 0x80a164b
    int32_t * mem7 = calloc(1, len3 + 16 + strlen((char *)(0x1000000 * pcbtreedir / 0x1000000))); // 0x80a166e
    int32_t v63 = (int32_t)mem7; // 0x80a166e
    pcbtreepath = v63;
    if (mem7 == NULL) {
        // 0x80a20dd
        __fprintf_chk((struct _IO_FILE *)(0x1000000 * (int32_t)g43 / 0x1000000), 1, "InitPaths():  malloc failed\n");
        exit(1);
        // UNREACHABLE
    }
    // 0x80a1680
    __sprintf_chk((char *)(0x1000000 * v63 / 0x1000000), 1, -1, "%s%s%s%spcblib-newlib", (char *)pcbtreedir, ":", (char *)pcblibdir, (char *)&g35);
    bool v64; // 0x80a1390
    v20 = v64 ? -1 : 1;
    v13 = 0;
    while (true) {
      lab_0x80a1724_2:
        // 0x80a1724
        v11 = v13;
        v9 = (int32_t *)(v11 + (int32_t)&main_attribute_list);
        v14 = *v9;
        int32_t v15 = v14; // 0x80a172c
        int32_t v16 = 16; // 0x80a172c
        if (v14 == 0) {
            goto lab_0x80a1719;
        } else {
            int32_t v17 = v15;
            int32_t v18 = (int32_t)"lib-command-dir"; // 0x80a1390
            while (*(char *)v17 == *(char *)v18) {
                int32_t v19 = v16 - 1; // 0x80a173a
                v18 += v20;
                v15 = v17 + v20;
                v16 = v19;
                if (v19 == 0) {
                    // 0x80a173e
                    *(int32_t *)(v11 + (int32_t)&g37) = pcblibdir;
                    goto lab_0x80a174a;
                }
                v17 = v15;
            }
            goto lab_0x80a174a;
        }
    }
  lab_0x80a178a_2:;
    char * env_val2 = getenv((char *)(int32_t)(char)"HOME"); // 0x80a1791
    char * v65 = env_val2; // 0x80a1798
    int32_t v66; // 0x80a1390
    if (env_val2 == NULL) {
        char * env_val3 = getenv((char *)(int32_t)(char)"USERPROFILE"); // 0x80a20b0
        v65 = env_val3;
        v66 = 0;
        if (env_val3 != NULL) {
            goto lab_0x80a179e;
        } else {
            goto lab_0x80a17ab;
        }
    } else {
        goto lab_0x80a179e;
    }
  lab_0x80a1465:;
    int32_t v67 = v6;
    char * found_char_pos = strchr((char *)(0x1000000 * v67 / 0x1000000), 47); // 0x80a1470
    v58 = v67;
    if (found_char_pos != NULL) {
        char * v68 = found_char_pos; // 0x80a147e
        v58 = v67;
        if (*found_char_pos != 0) {
            char * v69 = v68;
            char * found_char_pos2 = strchr((char *)((0x1000000 * (int32_t)v69 + 0x1000000) / 0x1000000), 47); // 0x80a14a2
            while (found_char_pos2 != NULL) {
                // 0x80a1488
                v68 = found_char_pos2;
                if (*found_char_pos2 == 0) {
                    // break -> 0x80a14ab
                    break;
                }
                v69 = v68;
                found_char_pos2 = strchr((char *)((0x1000000 * (int32_t)v69 + 0x1000000) / 0x1000000), 47);
            }
            // 0x80a14ab
            *v69 = 0;
            v58 = bindir;
        }
    }
    goto lab_0x80a14b4;
  lab_0x80a179e:
    // 0x80a179e
    v66 = (int32_t)__strdup((char *)(0x1000000 * (int32_t)v65 / 0x1000000));
    goto lab_0x80a17ab;
  lab_0x80a17ab:
    // 0x80a17ab
    homedir = v66;
    bindtextdomain((char *)(int32_t)(char)"pcb", "/usr/share/locale");
    bind_textdomain_codeset((char *)(int32_t)(char)"pcb", "UTF-8");
    hid_init();
    hid_load_settings();
    int32_t v70 = (int32_t)*argv;
    program_name = v70;
    char * str3 = (char *)(0x1000000 * v70 / 0x1000000); // 0x80a17f4
    char * found_char_pos3 = strrchr(str3, 47); // 0x80a17f4
    program_basename = (int32_t)found_char_pos3;
    int32_t v71; // 0x80a1390
    if (found_char_pos3 == NULL) {
        // 0x80a1fb4
        program_directory = &g36;
        v71 = v70;
    } else {
        int32_t v72 = (int32_t)__strdup(str3); // 0x80a1809
        program_directory = v72;
        *strrchr((char *)(0x1000000 * v72 / 0x1000000), 47) = 0;
        v71 = program_basename + 1;
    }
    // 0x80a1835
    program_basename = v71;
    Progname = v71;
    int32_t v73; // 0x80a1390
    int32_t v74; // 0x80a1390
    char ** v75; // 0x80a1390
    char v76; // 0x80a1853
    int32_t v77; // 0x80a1841
    int32_t v78; // 0x80a1845
    char v79; // 0x80a1848
    if (argc < 2) {
        goto lab_0x80a18b2;
    } else {
        // 0x80a1841
        v77 = (int32_t)argv;
        int32_t v80 = v77 + 4; // 0x80a1845
        v78 = *(int32_t *)v80;
        v79 = *(char *)v78;
        if (v79 != 45) {
            goto lab_0x80a18b2;
        } else {
            // 0x80a1853
            v76 = *(char *)(v78 + 1);
            if (v76 == 104) {
                // 0x80a185f
                if (*(char *)(v78 + 2) == 0) {
                    // 0x80a186b
                    usage();
                    // UNREACHABLE
                }
            }
            if (v76 == 86) {
                // 0x80a1df9
                if (*(char *)(v78 + 2) == 0) {
                    // 0x80a1e09
                    print_version();
                    // UNREACHABLE
                }
            }
            // 0x80a1dac
            if (v76 != *(char *)&g8) {
                goto lab_0x80a189e;
            } else {
                // 0x80a1dbc
                if (*(char *)(v78 + 2) != 0) {
                    goto lab_0x80a189e;
                } else {
                    int32_t v81 = hid_find_printer(); // 0x80a1dcc
                    gui = v81;
                    exporter = v81;
                    v74 = argc - 1;
                    v75 = (char **)v80;
                    v73 = v81;
                    goto lab_0x80a18bc;
                }
            }
        }
    }
  lab_0x80a18b2:;
    int32_t v82 = hid_find_gui(); // 0x80a18b2
    gui = v82;
    v74 = argc;
    v75 = argv;
    v73 = v82;
    goto lab_0x80a18bc;
  lab_0x80a18bc:
    // 0x80a18bc
    if (v73 == 0) {
        // 0x80a1fa8
        exit(1);
        // UNREACHABLE
    }
    // 0x80a18d0
    int32_t v83; // bp-56, 0x80a1390
    char * v84 = (char *)(0x1000000 * (int32_t)&v83 / 0x1000000); // 0x80a18f2
    int32_t v85 = 1; // 0x80a18d0
    __sprintf_chk(v84, 1, 20, "signal%d", v85);
    char * v86 = MyStrdup(v84, "DefaultLayerNames"); // 0x80a1902
    int32_t v87 = 4 * v85; // 0x80a190a
    *(int32_t *)(v87 + (int32_t)&g121) = (int32_t)"#c49350";
    *(int32_t *)(v87 + (int32_t)&g123) = (int32_t)"#00ffff";
    *(int32_t *)(v87 + (int32_t)&g143) = (int32_t)v86;
    int32_t v88 = v85; // 0x80a1927
    while (v85 != 16) {
        // 0x80a18d0
        v85 = v88 + 1;
        __sprintf_chk(v84, 1, 20, "signal%d", v85);
        v86 = MyStrdup(v84, "DefaultLayerNames");
        v87 = 4 * v85;
        *(int32_t *)(v87 + (int32_t)&g121) = (int32_t)"#c49350";
        *(int32_t *)(v87 + (int32_t)&g123) = (int32_t)"#00ffff";
        *(int32_t *)(v87 + (int32_t)&g143) = (int32_t)v86;
        v88 = v85;
    }
    // 0x80a1929
    if (show_help != 0) {
        // 0x80a1ef7
        usage();
        // UNREACHABLE
    }
    if (v74 >= 2) {
        char v89 = *(char *)*(int32_t *)((int32_t)v75 + 4); // 0x80a195a
        if (v89 == 45) {
            // 0x80a1ef7
            usage();
            // UNREACHABLE
        }
    }
    // 0x80a1963
    if (show_version != 0) {
        // 0x80a1f0b
        print_version();
        // UNREACHABLE
    }
    // 0x80a1971
    if (show_defaults != 0) {
        int32_t v90 = hid_enumerate(); // 0x80a1f1e
        int32_t v91 = *(int32_t *)v90; // 0x80a1f23
        if (v91 == 0) {
            // 0x80a1fa8
            exit(1);
            // UNREACHABLE
        }
        int32_t v92 = v90; // 0x80a1f9a
        int32_t v93; // 0x80a1390
        int32_t v94; // 0x80a1390
        int32_t v95; // 0x80a1390
        int32_t v96; // 0x80a1fc9
        int32_t v97; // 0x80a2019
        int32_t * v98; // 0x80a1f68
        int32_t v99; // 0x80a1f90
        int32_t v100; // 0x80a1f7b
        int32_t v101; // 0x80a1390
        if (*(char *)(v91 + 12) % 2 == 0) {
            // 0x80a1fc9
            v96 = *(int32_t *)(v91 + 4);
            if (!((v101 < 1 | __fprintf_chk((struct _IO_FILE *)(0x1000000 * (int32_t)g43 / 0x1000000), 1, "\n%s defaults:\n", (char *)v96) == 0))) {
                print_defaults_1((int32_t)&g231, (char *)&g231);
                v97 = 1;
                v94 = v97;
                while (v97 != v101) {
                    // 0x80a2010
                    print_defaults_1((int32_t)&g231, (char *)&g231);
                    v97 = v94 + 1;
                    v94 = v97;
                }
            }
        } else {
            // 0x80a1f3a
            __fprintf_chk((struct _IO_FILE *)(0x1000000 * (int32_t)g43 / 0x1000000), 1, "\ngui defaults:\n");
            if (hid_attr_nodes != 0) {
                v98 = (int32_t *)(hid_attr_nodes + 8);
                if (*v98 >= 1) {
                    v100 = 1;
                    print_defaults_1((int32_t)&g231, (char *)&g231);
                    v93 = v100;
                    while (v100 < *v98) {
                        // 0x80a1f78
                        v100 = v93 + 1;
                        print_defaults_1((int32_t)&g231, (char *)&g231);
                        v93 = v100;
                    }
                }
                // 0x80a1f90
                v99 = *(int32_t *)hid_attr_nodes;
                v95 = v99;
                while (v99 != 0) {
                    // 0x80a1f68
                    v98 = (int32_t *)(v95 + 8);
                    if (*v98 >= 1) {
                        v100 = 1;
                        print_defaults_1((int32_t)&g231, (char *)&g231);
                        v93 = v100;
                        while (v100 < *v98) {
                            // 0x80a1f78
                            v100 = v93 + 1;
                            print_defaults_1((int32_t)&g231, (char *)&g231);
                            v93 = v100;
                        }
                    }
                    // 0x80a1f90
                    v99 = *(int32_t *)v95;
                    v95 = v99;
                }
            }
        }
        // 0x80a1f96
        v92 += 4;
        int32_t v102 = *(int32_t *)v92; // 0x80a1f9a
        while (v102 != 0) {
            int32_t v103 = v102;
            if (*(char *)(v103 + 12) % 2 == 0) {
                // 0x80a1fc9
                v96 = *(int32_t *)(v103 + 4);
                if (!((v101 < 1 | __fprintf_chk((struct _IO_FILE *)(0x1000000 * (int32_t)g43 / 0x1000000), 1, "\n%s defaults:\n", (char *)v96) == 0))) {
                    print_defaults_1((int32_t)&g231, (char *)&g231);
                    v97 = 1;
                    v94 = v97;
                    while (v97 != v101) {
                        // 0x80a2010
                        print_defaults_1((int32_t)&g231, (char *)&g231);
                        v97 = v94 + 1;
                        v94 = v97;
                    }
                }
            } else {
                // 0x80a1f3a
                __fprintf_chk((struct _IO_FILE *)(0x1000000 * (int32_t)g43 / 0x1000000), 1, "\ngui defaults:\n");
                if (hid_attr_nodes != 0) {
                    v98 = (int32_t *)(hid_attr_nodes + 8);
                    if (*v98 >= 1) {
                        v100 = 1;
                        print_defaults_1((int32_t)&g231, (char *)&g231);
                        v93 = v100;
                        while (v100 < *v98) {
                            // 0x80a1f78
                            v100 = v93 + 1;
                            print_defaults_1((int32_t)&g231, (char *)&g231);
                            v93 = v100;
                        }
                    }
                    // 0x80a1f90
                    v99 = *(int32_t *)hid_attr_nodes;
                    v95 = v99;
                    while (v99 != 0) {
                        // 0x80a1f68
                        v98 = (int32_t *)(v95 + 8);
                        if (*v98 >= 1) {
                            v100 = 1;
                            print_defaults_1((int32_t)&g231, (char *)&g231);
                            v93 = v100;
                            while (v100 < *v98) {
                                // 0x80a1f78
                                v100 = v93 + 1;
                                print_defaults_1((int32_t)&g231, (char *)&g231);
                                v93 = v100;
                            }
                        }
                        // 0x80a1f90
                        v99 = *(int32_t *)v95;
                        v95 = v99;
                    }
                }
            }
            // 0x80a1f96
            v92 += 4;
            v102 = *(int32_t *)v92;
        }
        // 0x80a1fa8
        exit(1);
        // UNREACHABLE
    }
    // 0x80a197f
    if (show_copyright != 0) {
        // 0x80a202d
        copyright();
        // UNREACHABLE
    }
    // 0x80a198d
    Output = &hid_nogui;
    g186 = (char *)&hid_nogui;
    g187 = (char *)&hid_nogui;
    g188 = (char *)&hid_nogui;
    if ((*g146 || 1) != 47) {
        // 0x80a19d1
        g146 = Concat((char *)(0x1000000 * g145 / 0x1000000));
    }
    // 0x80a19f7
    if ((*g147 || 1) != 47) {
        // 0x80a1a07
        g147 = Concat((char *)(0x1000000 * g145 / 0x1000000));
    }
    // 0x80a1a2d
    if (g129 >= 0x989681) {
        // 0x80a1a3c
        g129 = 1000;
    }
    int32_t v104 = g127; // 0x80a1a46
    char * v105 = g128;
    if (v104 < 0x989681) {
        // 0x80a1a5b
        if (v105 > NULL) {
            goto lab_0x80a1a69;
        } else {
            // 0x80a1e60
            g128 = (char *)(40 * v104 / 100);
            goto lab_0x80a1a69;
        }
    } else {
        // 0x80a1e48
        g127 = 4000;
        if (v105 >= NULL == (v105 != NULL)) {
            goto lab_0x80a1a69;
        } else {
            // 0x80a1e60
            g128 = (char *)1600;
            goto lab_0x80a1a69;
        }
    }
  lab_0x80a189e:
    if (v76 == 120 == argc > 2 == v79 == 45) {
        // 0x80a1e97
        if (*(char *)(v78 + 2) != 0) {
            goto lab_0x80a18b2;
        } else {
            int32_t v106 = v77 + 8; // 0x80a1ea7
            int32_t v107 = hid_find_exporter((char *)(0x1000000 * *(int32_t *)v106 / 0x1000000)); // 0x80a1ead
            gui = v107;
            exporter = v107;
            v74 = argc - 2;
            v75 = (char **)v106;
            v73 = v107;
            goto lab_0x80a18bc;
        }
    } else {
        goto lab_0x80a18b2;
    }
  lab_0x80a1a69:;
    int32_t v108 = g132; // 0x80a1a73
    int32_t v109 = v108 < 1000 == (999 - v108 & v108) < 0 ? v108 : 1000; // 0x80a1a7f
    int32_t v110 = v109 - 0x989680; // 0x80a1a96
    int32_t v111 = g133; // 0x80a1a9f
    int32_t v112 = v111 < 1000 == (999 - v111 & v111) < 0 ? v111 : 1000; // 0x80a1aa9
    g132 = v110 < 0 == (0x98967f - v109 & v109) < 0 == (v110 != 0) ? 0x989680 : v109;
    int32_t v113 = v112 - 0x989680; // 0x80a1ab6
    g133 = v113 == 0 | v113 < 0 != (0x98967f - v112 & v112) < 0 ? v112 : 0x989680;
    ParseRouteString((char *)(0x1000000 * g152 / 0x1000000), (int32_t)&g160, 1);
    if (show_actions != 0) {
        // 0x80a2121
        print_actions();
        exit(0);
        // UNREACHABLE
    }
    // 0x80a1adf
    if (do_dump_actions != 0) {
        // 0x80a20cc
        dump_actions();
        exit(0);
        // UNREACHABLE
    }
    int32_t v114 = CreateNewPCB(1); // 0x80a1af4
    PCB = v114;
    *(int32_t *)(*(int32_t *)(v114 + 0x220c) + 24) = 8;
    ParseGroupString((char *)(0x1000000 * g151 / 0x1000000), v114 + 0x1cd4, 8);
    CreateNewPCBPost(0x1000000 * PCB / 0x1000000, 1);
    if (v74 >= 2) {
        // 0x80a1b44
        command_line_pcb = *(int32_t *)((int32_t)v75 + 4);
    }
    // 0x80a1b50
    ResetStackAndVisibility();
    CreateDefaultFont();
    if (g41 % 2 != 0) {
        // 0x80a203d
        InitCrosshair();
    }
    // 0x80a1b69
    signal(SIGPIPE, SIG_IGN);
    InitBuffers();
    SetMode(110);
    if (command_line_pcb != 0) {
        // 0x80a1b97
        if (LoadPCB((char *)(0x1000000 * command_line_pcb / 0x1000000)) != 0) {
            char * v115 = MyStrdup((char *)(0x1000000 * command_line_pcb / 0x1000000), "main()"); // 0x80a2070
            *(int32_t *)(PCB + 20) = (int32_t)v115;
        }
    }
    // 0x80a1ba7
    if (g157 != NULL) {
        // 0x80a1bb0
        if (*g157 != 0) {
            // 0x80a204d
            LayerStringToLayerStack((char *)(0x1000000 * (int32_t)g157 / 0x1000000));
        }
    }
    // 0x80a1bb9
    if ((g41 & 6) != 0) {
        // 0x80a2106
        exit(0);
        // UNREACHABLE
    }
    // 0x80a1bc8
    atexit(-80);
    if (ReadLibraryContents() == 0 && Library != 0) {
        // 0x80a1e37
        hid_action((char *)(int32_t)(char)"LibraryChanged");
    }
    // 0x80a1be1
    g180 = 0;
    if (g155 != NULL) {
        // 0x80a1bf4
        Message((char *)(int32_t)(char)"Executing startup script file %s\n", g155);
        hid_actionl((char *)(int32_t)(char)"ExecuteFile");
    }
    // 0x80a1c21
    if (g156 != NULL) {
        // 0x80a1c2a
        Message((char *)(int32_t)(char)"Executing startup action %s\n", g156);
        hid_parse_actions((char *)(0x1000000 * (int32_t)g156 / 0x1000000), NULL);
    }
    // 0x80a1c4f
    if (g180 == 0) {
        // 0x80a1eca
        g180 = 1;
        pcb_dbus_setup();
        EnableAutosave();
        pcb_dbus_finish();
    }
    // 0x80a1c5c
    if (v1 == __readgsdword(20)) {
        // 0x80a1c72
        return 0;
    }
    // 0x80a211c
    __stack_chk_fail();
    // 0x80a2121
    print_actions();
    exit(0);
    // UNREACHABLE
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a23a0 - 0x80a23f5
// Line range:    155 - 169
void SetPinBoundingBox(int32_t Pin) {
    int32_t v1 = *(int32_t *)(Pin + 40) + 1 + *(int32_t *)(Pin + 36); // 0x80a23ad
    int32_t v2 = (v1 + (int32_t)(v1 < 0)) / 2; // 0x80a23bb
    int32_t v3 = *(int32_t *)(Pin + 44) + 1; // 0x80a23bd
    int32_t v4 = (v3 + (int32_t)(v3 < 0)) / 2; // 0x80a23c8
    int32_t v5 = v2 - v4; // 0x80a23ca
    int32_t v6 = v5 < 0 == ((v5 ^ v2) & (v4 ^ v2)) < 0 ? v2 : v4; // 0x80a23cc
    int32_t * v7 = (int32_t *)(Pin + 52); // 0x80a23cf
    *(int32_t *)Pin = *v7 - v6;
    int32_t v8 = *(int32_t *)(Pin + 56); // 0x80a23d6
    *(int32_t *)(Pin + 4) = v8 - v6;
    int32_t v9 = v6 + 1;
    *(int32_t *)(Pin + 8) = v9 + *v7;
    *(int32_t *)(Pin + 12) = v9 + v8;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a2400 - 0x80a2495
// Line range:    229 - 242
void SetLineBoundingBox(int32_t Line) {
    int32_t v1 = *(int32_t *)(Line + 64); // 0x80a241a
    int32_t v2 = *(int32_t *)(Line + 36) + 1 + *(int32_t *)(Line + 40); // 0x80a241d
    int32_t v3 = (v2 + (int32_t)(v2 < 0)) / 2; // 0x80a242c
    int32_t * v4 = (int32_t *)(Line + 44); // 0x80a242e
    int32_t v5 = *v4; // 0x80a242e
    int32_t v6 = v5 - v1; // 0x80a242e
    int32_t v7 = v6 == 0 | v6 < 0 != ((v6 ^ v5) & (v5 ^ v1)) < 0 ? v5 : v1; // 0x80a2431
    *(int32_t *)Line = v7 - v3;
    int32_t v8 = *(int32_t *)(Line + 68); // 0x80a2439
    int32_t v9 = *v4; // 0x80a243c
    int32_t v10 = v9 - v1; // 0x80a243c
    int32_t v11 = v10 < 0 == ((v10 ^ v9) & (v9 ^ v1)) < 0 ? v9 : v1; // 0x80a243f
    int32_t * v12 = (int32_t *)(Line + 48); // 0x80a2443
    int32_t v13 = *v12; // 0x80a2443
    int32_t v14 = v13 - v8; // 0x80a2443
    int32_t v15 = v14 == 0 | v14 < 0 != ((v14 ^ v13) & (v13 ^ v8)) < 0 ? v13 : v8; // 0x80a2448
    int32_t v16 = v3 + 1;
    *(int32_t *)(Line + 8) = v11 + v16;
    *(int32_t *)(Line + 4) = v15 - v3;
    int32_t v17 = *v12; // 0x80a245a
    int32_t v18 = v17 - v8; // 0x80a245a
    int32_t v19 = v18 < 0 == ((v18 ^ v17) & (v17 ^ v8)) < 0 ? v17 : v8; // 0x80a245d
    *(int32_t *)(Line + 72) = v1 + 1;
    *(int32_t *)(Line + 12) = v19 + v16;
    *(int32_t *)(Line + 76) = v8 + 1;
    *(int32_t *)(Line + 52) = *v4 + 1;
    *(int32_t *)(Line + 56) = *v12 + 1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a24a0 - 0x80a2530
// Line range:    248 - 262
void SetPolygonBoundingBox(int32_t Polygon2) {
    int32_t v1 = *(int32_t *)(Polygon2 + 36); // 0x80a24ac
    int32_t * v2 = (int32_t *)(Polygon2 + 4); // 0x80a24af
    *v2 = 0x989680;
    int32_t * v3 = (int32_t *)Polygon2; // 0x80a24b6
    *v3 = 0x989680;
    int32_t * v4 = (int32_t *)(Polygon2 + 12); // 0x80a24bc
    *v4 = 0;
    int32_t * v5 = (int32_t *)(Polygon2 + 8); // 0x80a24c9
    *v5 = 0;
    if (v1 == 0) {
        // 0x80a2528
        return;
    }
    int32_t v6 = v1; // 0x80a24eb
    int32_t v7 = 20 * v1 - 20 + *(int32_t *)(Polygon2 + 56); // 0x80a24eb
    int32_t v8 = 0;
    int32_t v9 = 0;
    int32_t v10 = *(int32_t *)v7; // 0x80a24f2
    if (v10 < 0x989680) {
        // 0x80a24f8
        *v3 = v10;
    }
    int32_t v11 = *(int32_t *)(v7 + 4); // 0x80a24fa
    if (v11 < *v2) {
        // 0x80a2502
        *v2 = v11;
    }
    // 0x80a2505
    v6--;
    int32_t v12 = v10 - v8; // 0x80a2505
    int32_t v13 = v11 - v9; // 0x80a250a
    int32_t v14 = (v12 < 0 == ((v12 ^ v10) & (v10 ^ v8)) < 0 ? v10 : v8) + 1; // 0x80a250f
    int32_t v15 = (v13 < 0 == ((v13 ^ v11) & (v11 ^ v9)) < 0 ? v11 : v9) + 1; // 0x80a2516
    while (v6 != 0) {
        // 0x80a24f0
        v7 -= 20;
        v8 = v14;
        v9 = v15;
        v10 = *(int32_t *)v7;
        if (v10 < *v3) {
            // 0x80a24f8
            *v3 = v10;
        }
        // 0x80a24fa
        v11 = *(int32_t *)(v7 + 4);
        if (v11 < *v2) {
            // 0x80a2502
            *v2 = v11;
        }
        // 0x80a2505
        v6--;
        v12 = v10 - v8;
        v13 = v11 - v9;
        v14 = (v12 < 0 == ((v12 ^ v10) & (v10 ^ v8)) < 0 ? v10 : v8) + 1;
        v15 = (v13 < 0 == ((v13 ^ v11) & (v11 ^ v9)) < 0 ? v11 : v9) + 1;
    }
    // 0x80a2522
    *v5 = v14;
    *v4 = v15;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a2530 - 0x80a259c
// Line range:    491 - 504
char IsDataEmpty(int32_t Data) {
    int32_t result = (*(int32_t *)(Data + 8) | *(int32_t *)Data) == 0; // 0x80a2546
    uint32_t v1 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24) + 2; // 0x80a2557
    int32_t v2 = result; // 0x80a255a
    int32_t v3 = Data; // 0x80a255a
    if (v1 == 0) {
        // 0x80a2599
        return result;
    }
    int32_t v4 = 0; // 0x80a255a
    int32_t v5; // 0x80a2530
    int32_t v6; // 0x80a2530
    int32_t v7; // 0x80a2530
    while (true) {
      lab_0x80a2582_2:
        // 0x80a2582
        v7 = v4;
        v6 = v3;
        v5 = v2;
        if ((char)v2 == 0) {
            goto lab_0x80a2578;
        } else {
            // 0x80a2586
            if (*(int32_t *)(v6 + 80) == 0) {
                // 0x80a2560
                if (*(int32_t *)(v6 + 92) != 0) {
                    goto lab_0x80a258d;
                } else {
                    // 0x80a2567
                    if (*(int32_t *)(v6 + 84) != 0) {
                        goto lab_0x80a258d;
                    } else {
                        // 0x80a256e
                        v5 = *(int32_t *)(v6 + 88) == 0;
                        goto lab_0x80a2578;
                    }
                }
            } else {
                goto lab_0x80a258d;
            }
        }
    }
  lab_0x80a2599_2:;
    // 0x80a2599
    int32_t result2; // 0x80a2530
    return result2;
  lab_0x80a2578:;
    int32_t v8 = v7 + 1; // 0x80a2578
    v2 = v5;
    v4 = v8;
    result2 = v5;
    if (v8 >= v1) {
        // break -> 0x80a2599
        goto lab_0x80a2599_2;
    }
    goto lab_0x80a2582;
  lab_0x80a2582:
    // 0x80a2582
    v3 = v6 + 92;
    goto lab_0x80a2582_2;
  lab_0x80a258d:;
    int32_t v9 = v7 + 1; // 0x80a258d
    v2 = 0;
    v4 = v9;
    result2 = 0;
    if (v9 >= v1) {
        // break -> 0x80a2599
        goto lab_0x80a2599_2;
    }
    goto lab_0x80a2582;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a25d0 - 0x80a2a20
// Line range:    521 - 582
int32_t GetDataBoundingBox(int32_t Data) {
    // 0x80a25d0
    g76 = 0x989680;
    g75 = 0x989680;
    g78 = -0x989680;
    g77 = -0x989680;
    int32_t v1 = *(int32_t *)Data; // 0x80a2604
    int32_t v2 = -0x989680; // 0x80a260b
    int32_t v3 = -0x989680; // 0x80a260b
    int32_t v4 = 0x989680; // 0x80a260b
    int32_t v5 = 0x989680; // 0x80a260b
    if (v1 != 0) {
        int32_t v6 = 0; // 0x80a2634
        int32_t v7 = *(int32_t *)(Data + 28); // 0x80a2634
        int32_t v8 = 0x989680;
        int32_t v9 = 0x989680;
        int32_t v10 = -0x989680;
        int32_t v11 = -0x989680;
        int32_t v12 = *(int32_t *)(v7 + 36); // 0x80a2638
        int32_t v13 = *(int32_t *)(v7 + 52); // 0x80a2647
        int32_t v14 = (v12 + (int32_t)(v12 < 0)) / 2; // 0x80a264a
        int32_t v15 = v13 - v14; // 0x80a264e
        int32_t v16 = v8 - v15; // 0x80a2651
        v5 = v16 < 0 == ((v16 ^ v8) & (v15 ^ v8)) < 0 == (v16 != 0) ? v15 : v8;
        int32_t v17 = *(int32_t *)(v7 + 56); // 0x80a2659
        int32_t v18 = v17 - v14; // 0x80a2659
        int32_t v19 = v9 - v18; // 0x80a265c
        v4 = v19 < 0 == ((v19 ^ v9) & (v18 ^ v9)) < 0 == (v19 != 0) ? v18 : v9;
        int32_t v20 = v14 + v13; // 0x80a2666
        int32_t v21 = v10 - v20; // 0x80a2669
        v3 = v21 < 0 == ((v21 ^ v10) & (v20 ^ v10)) < 0 ? v10 : v20;
        int32_t v22 = v14 + v17; // 0x80a266e
        int32_t v23 = v11 - v22; // 0x80a2671
        v2 = v23 < 0 == ((v23 ^ v11) & (v22 ^ v11)) < 0 ? v11 : v22;
        v6++;
        v7 += 76;
        while (v6 != v1) {
            // 0x80a2638
            v8 = v5;
            v9 = v4;
            v10 = v3;
            v11 = v2;
            v12 = *(int32_t *)(v7 + 36);
            v13 = *(int32_t *)(v7 + 52);
            v14 = (v12 + (int32_t)(v12 < 0)) / 2;
            v15 = v13 - v14;
            v16 = v8 - v15;
            v5 = v16 < 0 == ((v16 ^ v8) & (v15 ^ v8)) < 0 == (v16 != 0) ? v15 : v8;
            v17 = *(int32_t *)(v7 + 56);
            v18 = v17 - v14;
            v19 = v9 - v18;
            v4 = v19 < 0 == ((v19 ^ v9) & (v18 ^ v9)) < 0 == (v19 != 0) ? v18 : v9;
            v20 = v14 + v13;
            v21 = v10 - v20;
            v3 = v21 < 0 == ((v21 ^ v10) & (v20 ^ v10)) < 0 ? v10 : v20;
            v22 = v14 + v17;
            v23 = v11 - v22;
            v2 = v23 < 0 == ((v23 ^ v11) & (v22 ^ v11)) < 0 ? v11 : v22;
            v6++;
            v7 += 76;
        }
        // 0x80a268a
        g75 = v5;
        g76 = v4;
        g77 = v3;
        g78 = v2;
    }
    int32_t v24 = *(int32_t *)(Data + 8); // 0x80a26a5
    int32_t v25 = v2; // 0x80a26b1
    int32_t v26 = v5; // 0x80a26b1
    int32_t v27 = v3; // 0x80a26b1
    int32_t v28 = v4; // 0x80a26b1
    if (v24 != 0) {
        int32_t v29 = v24; // 0x80a26dd
        int32_t v30 = 300 * v24 - 300 + *(int32_t *)(Data + 32); // 0x80a26dd
        int32_t v31 = v2;
        int32_t v32 = v5;
        int32_t v33 = v3;
        int32_t v34 = v4;
        v29--;
        int32_t v35 = *(int32_t *)v30; // 0x80a26e0
        int32_t v36 = v32 - v35; // 0x80a26e2
        int32_t v37 = v36 < 0 == ((v36 ^ v32) & (v35 ^ v32)) < 0 == (v36 != 0) ? v35 : v32; // 0x80a26e4
        int32_t v38 = *(int32_t *)(v30 + 96); // 0x80a26e7
        int32_t v39 = *(int32_t *)(v30 + 4); // 0x80a26ea
        int32_t v40 = v39 - v34; // 0x80a26ea
        int32_t v41 = v40 == 0 | v40 < 0 != ((v40 ^ v39) & (v39 ^ v34)) < 0 ? v39 : v34; // 0x80a26ed
        int32_t v42 = *(int32_t *)(v30 + 8); // 0x80a26f1
        int32_t v43 = v42 - v33; // 0x80a26f1
        int32_t v44 = v43 < 0 == ((v43 ^ v42) & (v42 ^ v33)) < 0 ? v42 : v33; // 0x80a26f4
        int32_t v45 = v37 - v38; // 0x80a26f8
        v26 = v45 < 0 == ((v45 ^ v37) & (v37 ^ v38)) < 0 == (v45 != 0) ? v38 : v37;
        int32_t v46 = *(int32_t *)(v30 + 100); // 0x80a26fd
        int32_t v47 = v41 - v46; // 0x80a2700
        v28 = v47 < 0 == ((v47 ^ v41) & (v41 ^ v46)) < 0 == (v47 != 0) ? v46 : v41;
        int32_t v48 = *(int32_t *)(v30 + 104); // 0x80a2705
        int32_t v49 = v44 - v48; // 0x80a2708
        v27 = v49 < 0 == ((v49 ^ v44) & (v44 ^ v48)) < 0 ? v44 : v48;
        int32_t v50 = *(int32_t *)(v30 + 12); // 0x80a270d
        int32_t v51 = *(int32_t *)(v30 + 108); // 0x80a2710
        int32_t v52 = v51 - v50; // 0x80a2710
        int32_t v53 = v52 < 0 == ((v52 ^ v51) & (v51 ^ v50)) < 0 ? v51 : v50; // 0x80a2713
        int32_t v54 = v31 - v53; // 0x80a2717
        v25 = v54 < 0 == ((v54 ^ v31) & (v53 ^ v31)) < 0 ? v31 : v53;
        v30 -= 300;
        while (v29 != 0) {
            // 0x80a26e0
            v31 = v25;
            v32 = v26;
            v33 = v27;
            v34 = v28;
            v29--;
            v35 = *(int32_t *)v30;
            v36 = v32 - v35;
            v37 = v36 < 0 == ((v36 ^ v32) & (v35 ^ v32)) < 0 == (v36 != 0) ? v35 : v32;
            v38 = *(int32_t *)(v30 + 96);
            v39 = *(int32_t *)(v30 + 4);
            v40 = v39 - v34;
            v41 = v40 == 0 | v40 < 0 != ((v40 ^ v39) & (v39 ^ v34)) < 0 ? v39 : v34;
            v42 = *(int32_t *)(v30 + 8);
            v43 = v42 - v33;
            v44 = v43 < 0 == ((v43 ^ v42) & (v42 ^ v33)) < 0 ? v42 : v33;
            v45 = v37 - v38;
            v26 = v45 < 0 == ((v45 ^ v37) & (v37 ^ v38)) < 0 == (v45 != 0) ? v38 : v37;
            v46 = *(int32_t *)(v30 + 100);
            v47 = v41 - v46;
            v28 = v47 < 0 == ((v47 ^ v41) & (v41 ^ v46)) < 0 == (v47 != 0) ? v46 : v41;
            v48 = *(int32_t *)(v30 + 104);
            v49 = v44 - v48;
            v27 = v49 < 0 == ((v49 ^ v44) & (v44 ^ v48)) < 0 ? v44 : v48;
            v50 = *(int32_t *)(v30 + 12);
            v51 = *(int32_t *)(v30 + 108);
            v52 = v51 - v50;
            v53 = v52 < 0 == ((v52 ^ v51) & (v51 ^ v50)) < 0 ? v51 : v50;
            v54 = v31 - v53;
            v25 = v54 < 0 == ((v54 ^ v31) & (v53 ^ v31)) < 0 ? v31 : v53;
            v30 -= 300;
        }
        // 0x80a272b
        g75 = v26;
        g76 = v28;
        g77 = v27;
        g78 = v25;
    }
    int32_t v55 = Data + 76; // 0x80a2746
    int32_t v56 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24) + 2; // 0x80a275a
    int32_t v57 = 0; // 0x80a2760
    char v58; // 0x80a285f
    if (v56 == 0) {
        // 0x80a2859
        v58 = IsDataEmpty(Data);
        return v58 == 0 ? (int32_t)&g75 : 0;
    }
    int32_t v59 = *(int32_t *)(v55 + 4); // 0x80a2793
    int32_t v60 = v28; // 0x80a279f
    int32_t v61 = v25; // 0x80a279f
    int32_t v62 = v27; // 0x80a279f
    int32_t v63 = v26; // 0x80a279f
    int32_t v64; // 0x80a25d0
    int32_t v65; // 0x80a25d0
    int32_t v66; // 0x80a25d0
    int32_t v67; // 0x80a25d0
    int32_t v68; // 0x80a25d0
    int32_t v69; // 0x80a25d0
    int32_t v70; // 0x80a27b0
    int32_t v71; // 0x80a27bf
    int32_t v72; // 0x80a27c1
    int32_t v73; // 0x80a27c5
    int32_t v74; // 0x80a27c8
    int32_t v75; // 0x80a27ca
    int32_t v76; // 0x80a27cd
    int32_t v77; // 0x80a27d0
    int32_t v78; // 0x80a27d3
    int32_t v79; // 0x80a27d5
    int32_t v80; // 0x80a27d8
    int32_t v81; // 0x80a27db
    int32_t v82; // 0x80a27de
    int32_t v83; // 0x80a27de
    int32_t v84; // 0x80a27e1
    int32_t v85; // 0x80a27e3
    int32_t v86; // 0x80a27e8
    int32_t v87; // 0x80a27eb
    int32_t v88; // 0x80a27f7
    int32_t v89; // 0x80a27fa
    int32_t v90; // 0x80a27fc
    int32_t v91; // 0x80a2802
    int32_t v92; // 0x80a2805
    int32_t v93; // 0x80a2807
    int32_t v94; // 0x80a280d
    int32_t v95; // 0x80a2810
    int32_t v96; // 0x80a2813
    int32_t v97; // 0x80a2815
    int32_t v98; // 0x80a2818
    int32_t v99; // 0x80a281a
    if (v59 != 0) {
        // 0x80a27a5
        v68 = v59;
        v66 = 88 * v59 - 44 + *(int32_t *)(v55 + 36);
        v65 = v26;
        v67 = v27;
        v64 = v25;
        v69 = v28;
        v68--;
        v70 = *(int32_t *)(v66 - 8);
        v71 = *(int32_t *)v66;
        v72 = (v70 + (int32_t)(v70 < 0)) / 2;
        v73 = v71 - v72;
        v74 = v65 - v73;
        v75 = v74 < 0 == ((v74 ^ v65) & (v73 ^ v65)) < 0 == (v74 != 0) ? v73 : v65;
        v76 = *(int32_t *)(v66 + 20);
        v77 = v76 - v72;
        v78 = v75 - v77;
        v79 = v78 < 0 == ((v78 ^ v75) & (v75 ^ v77)) < 0 == (v78 != 0) ? v77 : v75;
        v80 = *(int32_t *)(v66 + 24);
        v81 = v80 - v72;
        v82 = *(int32_t *)(v66 + 4);
        v83 = v82 - v72;
        v84 = v81 - v83;
        v85 = v84 < 0 == ((v84 ^ v81) & (v83 ^ v81)) < 0 == (v84 != 0) ? v83 : v81;
        v86 = v69 - v85;
        v87 = v86 == 0 | v86 < 0 != ((v86 ^ v69) & (v85 ^ v69)) < 0 ? v69 : v85;
        v88 = v72 + v71;
        v89 = v88 - v67;
        v90 = v89 < 0 == ((v89 ^ v88) & (v88 ^ v67)) < 0 ? v88 : v67;
        v91 = v72 + v76;
        v92 = v90 - v91;
        v93 = v92 < 0 == ((v92 ^ v90) & (v90 ^ v91)) < 0 ? v90 : v91;
        v94 = v72 + v80;
        v95 = v82 + v72;
        v96 = v94 - v95;
        v97 = v96 < 0 == ((v96 ^ v94) & (v95 ^ v94)) < 0 ? v94 : v95;
        v98 = v64 - v97;
        v99 = v98 < 0 == ((v98 ^ v64) & (v97 ^ v64)) < 0 ? v64 : v97;
        v66 -= 88;
        v60 = v87;
        v61 = v99;
        v62 = v93;
        v63 = v79;
        while (v68 != 0) {
            // 0x80a27b0
            v65 = v79;
            v67 = v93;
            v64 = v99;
            v69 = v87;
            v68--;
            v70 = *(int32_t *)(v66 - 8);
            v71 = *(int32_t *)v66;
            v72 = (v70 + (int32_t)(v70 < 0)) / 2;
            v73 = v71 - v72;
            v74 = v65 - v73;
            v75 = v74 < 0 == ((v74 ^ v65) & (v73 ^ v65)) < 0 == (v74 != 0) ? v73 : v65;
            v76 = *(int32_t *)(v66 + 20);
            v77 = v76 - v72;
            v78 = v75 - v77;
            v79 = v78 < 0 == ((v78 ^ v75) & (v75 ^ v77)) < 0 == (v78 != 0) ? v77 : v75;
            v80 = *(int32_t *)(v66 + 24);
            v81 = v80 - v72;
            v82 = *(int32_t *)(v66 + 4);
            v83 = v82 - v72;
            v84 = v81 - v83;
            v85 = v84 < 0 == ((v84 ^ v81) & (v83 ^ v81)) < 0 == (v84 != 0) ? v83 : v81;
            v86 = v69 - v85;
            v87 = v86 == 0 | v86 < 0 != ((v86 ^ v69) & (v85 ^ v69)) < 0 ? v69 : v85;
            v88 = v72 + v71;
            v89 = v88 - v67;
            v90 = v89 < 0 == ((v89 ^ v88) & (v88 ^ v67)) < 0 ? v88 : v67;
            v91 = v72 + v76;
            v92 = v90 - v91;
            v93 = v92 < 0 == ((v92 ^ v90) & (v90 ^ v91)) < 0 ? v90 : v91;
            v94 = v72 + v80;
            v95 = v82 + v72;
            v96 = v94 - v95;
            v97 = v96 < 0 == ((v96 ^ v94) & (v95 ^ v94)) < 0 ? v94 : v95;
            v98 = v64 - v97;
            v99 = v98 < 0 == ((v98 ^ v64) & (v97 ^ v64)) < 0 ? v64 : v97;
            v66 -= 88;
            v60 = v87;
            v61 = v99;
            v62 = v93;
            v63 = v79;
        }
    }
    int32_t v100 = v63;
    int32_t v101 = v62;
    int32_t v102 = v61;
    int32_t v103 = v60;
    v57++;
    int32_t v104 = v55 + 92; // 0x80a2834
    while (v57 != v56) {
        int32_t v105 = v100;
        int32_t v106 = v101;
        int32_t v107 = v102;
        int32_t v108 = v104;
        int32_t v109 = v103;
        v59 = *(int32_t *)(v108 + 4);
        v60 = v109;
        v61 = v107;
        v62 = v106;
        v63 = v105;
        if (v59 != 0) {
            // 0x80a27a5
            v68 = v59;
            v66 = 88 * v59 - 44 + *(int32_t *)(v108 + 36);
            v65 = v105;
            v67 = v106;
            v64 = v107;
            v69 = v109;
            v68--;
            v70 = *(int32_t *)(v66 - 8);
            v71 = *(int32_t *)v66;
            v72 = (v70 + (int32_t)(v70 < 0)) / 2;
            v73 = v71 - v72;
            v74 = v65 - v73;
            v75 = v74 < 0 == ((v74 ^ v65) & (v73 ^ v65)) < 0 == (v74 != 0) ? v73 : v65;
            v76 = *(int32_t *)(v66 + 20);
            v77 = v76 - v72;
            v78 = v75 - v77;
            v79 = v78 < 0 == ((v78 ^ v75) & (v75 ^ v77)) < 0 == (v78 != 0) ? v77 : v75;
            v80 = *(int32_t *)(v66 + 24);
            v81 = v80 - v72;
            v82 = *(int32_t *)(v66 + 4);
            v83 = v82 - v72;
            v84 = v81 - v83;
            v85 = v84 < 0 == ((v84 ^ v81) & (v83 ^ v81)) < 0 == (v84 != 0) ? v83 : v81;
            v86 = v69 - v85;
            v87 = v86 == 0 | v86 < 0 != ((v86 ^ v69) & (v85 ^ v69)) < 0 ? v69 : v85;
            v88 = v72 + v71;
            v89 = v88 - v67;
            v90 = v89 < 0 == ((v89 ^ v88) & (v88 ^ v67)) < 0 ? v88 : v67;
            v91 = v72 + v76;
            v92 = v90 - v91;
            v93 = v92 < 0 == ((v92 ^ v90) & (v90 ^ v91)) < 0 ? v90 : v91;
            v94 = v72 + v80;
            v95 = v82 + v72;
            v96 = v94 - v95;
            v97 = v96 < 0 == ((v96 ^ v94) & (v95 ^ v94)) < 0 ? v94 : v95;
            v98 = v64 - v97;
            v99 = v98 < 0 == ((v98 ^ v64) & (v97 ^ v64)) < 0 ? v64 : v97;
            v66 -= 88;
            v60 = v87;
            v61 = v99;
            v62 = v93;
            v63 = v79;
            while (v68 != 0) {
                // 0x80a27b0
                v65 = v79;
                v67 = v93;
                v64 = v99;
                v69 = v87;
                v68--;
                v70 = *(int32_t *)(v66 - 8);
                v71 = *(int32_t *)v66;
                v72 = (v70 + (int32_t)(v70 < 0)) / 2;
                v73 = v71 - v72;
                v74 = v65 - v73;
                v75 = v74 < 0 == ((v74 ^ v65) & (v73 ^ v65)) < 0 == (v74 != 0) ? v73 : v65;
                v76 = *(int32_t *)(v66 + 20);
                v77 = v76 - v72;
                v78 = v75 - v77;
                v79 = v78 < 0 == ((v78 ^ v75) & (v75 ^ v77)) < 0 == (v78 != 0) ? v77 : v75;
                v80 = *(int32_t *)(v66 + 24);
                v81 = v80 - v72;
                v82 = *(int32_t *)(v66 + 4);
                v83 = v82 - v72;
                v84 = v81 - v83;
                v85 = v84 < 0 == ((v84 ^ v81) & (v83 ^ v81)) < 0 == (v84 != 0) ? v83 : v81;
                v86 = v69 - v85;
                v87 = v86 == 0 | v86 < 0 != ((v86 ^ v69) & (v85 ^ v69)) < 0 ? v69 : v85;
                v88 = v72 + v71;
                v89 = v88 - v67;
                v90 = v89 < 0 == ((v89 ^ v88) & (v88 ^ v67)) < 0 ? v88 : v67;
                v91 = v72 + v76;
                v92 = v90 - v91;
                v93 = v92 < 0 == ((v92 ^ v90) & (v90 ^ v91)) < 0 ? v90 : v91;
                v94 = v72 + v80;
                v95 = v82 + v72;
                v96 = v94 - v95;
                v97 = v96 < 0 == ((v96 ^ v94) & (v95 ^ v94)) < 0 ? v94 : v95;
                v98 = v64 - v97;
                v99 = v98 < 0 == ((v98 ^ v64) & (v97 ^ v64)) < 0 ? v64 : v97;
                v66 -= 88;
                v60 = v87;
                v61 = v99;
                v62 = v93;
                v63 = v79;
            }
        }
        // 0x80a282a
        v100 = v63;
        v101 = v62;
        v102 = v61;
        v103 = v60;
        v57++;
        v104 = v108 + 92;
    }
    // 0x80a287a
    g77 = v101;
    g75 = v100;
    g76 = v103;
    g78 = v102;
    int32_t v110 = 0; // 0x80a28a5
    int32_t v111 = *(int32_t *)(v55 + 16); // 0x80a28ab
    int32_t v112 = v102; // 0x80a28b9
    int32_t v113 = v101; // 0x80a28b9
    int32_t v114 = v103; // 0x80a28b9
    int32_t v115 = v100; // 0x80a28b9
    int32_t v116; // 0x80a25d0
    int32_t v117; // 0x80a25d0
    int32_t v118; // 0x80a25d0
    int32_t v119; // 0x80a25d0
    int32_t v120; // 0x80a25d0
    int32_t v121; // 0x80a25d0
    int32_t v122; // 0x80a28ee
    int32_t v123; // 0x80a28d8
    int32_t v124; // 0x80a28d8
    int32_t v125; // 0x80a28da
    int32_t v126; // 0x80a28dd
    int32_t v127; // 0x80a28dd
    int32_t v128; // 0x80a28e0
    int32_t v129; // 0x80a28e4
    int32_t v130; // 0x80a28e4
    int32_t v131; // 0x80a28e7
    int32_t v132; // 0x80a28eb
    int32_t v133; // 0x80a28eb
    if (v111 != 0) {
        // 0x80a28bb
        v121 = v111;
        v119 = 68 * v111 - 68 + *(int32_t *)(v55 + 48);
        v118 = v100;
        v120 = v103;
        v117 = v101;
        v116 = v102;
        v121--;
        v123 = *(int32_t *)v119;
        v124 = v118 - v123;
        v125 = v124 < 0 == ((v124 ^ v118) & (v123 ^ v118)) < 0 == (v124 != 0) ? v123 : v118;
        v126 = *(int32_t *)(v119 + 4);
        v127 = v120 - v126;
        v128 = v127 < 0 == ((v127 ^ v120) & (v126 ^ v120)) < 0 == (v127 != 0) ? v126 : v120;
        v129 = *(int32_t *)(v119 + 8);
        v130 = v117 - v129;
        v131 = v130 < 0 == ((v130 ^ v117) & (v129 ^ v117)) < 0 ? v117 : v129;
        v132 = *(int32_t *)(v119 + 12);
        v133 = v116 - v132;
        v122 = v133 < 0 == ((v133 ^ v116) & (v132 ^ v116)) < 0 ? v116 : v132;
        v119 -= 68;
        v112 = v122;
        v113 = v131;
        v114 = v128;
        v115 = v125;
        while (v121 != 0) {
            // 0x80a28d8
            v118 = v125;
            v120 = v128;
            v117 = v131;
            v116 = v122;
            v121--;
            v123 = *(int32_t *)v119;
            v124 = v118 - v123;
            v125 = v124 < 0 == ((v124 ^ v118) & (v123 ^ v118)) < 0 == (v124 != 0) ? v123 : v118;
            v126 = *(int32_t *)(v119 + 4);
            v127 = v120 - v126;
            v128 = v127 < 0 == ((v127 ^ v120) & (v126 ^ v120)) < 0 == (v127 != 0) ? v126 : v120;
            v129 = *(int32_t *)(v119 + 8);
            v130 = v117 - v129;
            v131 = v130 < 0 == ((v130 ^ v117) & (v129 ^ v117)) < 0 ? v117 : v129;
            v132 = *(int32_t *)(v119 + 12);
            v133 = v116 - v132;
            v122 = v133 < 0 == ((v133 ^ v116) & (v132 ^ v116)) < 0 ? v116 : v132;
            v119 -= 68;
            v112 = v122;
            v113 = v131;
            v114 = v128;
            v115 = v125;
        }
    }
    int32_t v134 = v115;
    int32_t v135 = v114;
    int32_t v136 = v113;
    int32_t v137 = v112;
    v110++;
    int32_t v138 = v55 + 92; // 0x80a290c
    while (v110 != v56) {
        int32_t v139 = v134;
        int32_t v140 = v135;
        int32_t v141 = v136;
        int32_t v142 = v138;
        int32_t v143 = v137;
        v111 = *(int32_t *)(v142 + 16);
        v112 = v143;
        v113 = v141;
        v114 = v140;
        v115 = v139;
        if (v111 != 0) {
            // 0x80a28bb
            v121 = v111;
            v119 = 68 * v111 - 68 + *(int32_t *)(v142 + 48);
            v118 = v139;
            v120 = v140;
            v117 = v141;
            v116 = v143;
            v121--;
            v123 = *(int32_t *)v119;
            v124 = v118 - v123;
            v125 = v124 < 0 == ((v124 ^ v118) & (v123 ^ v118)) < 0 == (v124 != 0) ? v123 : v118;
            v126 = *(int32_t *)(v119 + 4);
            v127 = v120 - v126;
            v128 = v127 < 0 == ((v127 ^ v120) & (v126 ^ v120)) < 0 == (v127 != 0) ? v126 : v120;
            v129 = *(int32_t *)(v119 + 8);
            v130 = v117 - v129;
            v131 = v130 < 0 == ((v130 ^ v117) & (v129 ^ v117)) < 0 ? v117 : v129;
            v132 = *(int32_t *)(v119 + 12);
            v133 = v116 - v132;
            v122 = v133 < 0 == ((v133 ^ v116) & (v132 ^ v116)) < 0 ? v116 : v132;
            v119 -= 68;
            v112 = v122;
            v113 = v131;
            v114 = v128;
            v115 = v125;
            while (v121 != 0) {
                // 0x80a28d8
                v118 = v125;
                v120 = v128;
                v117 = v131;
                v116 = v122;
                v121--;
                v123 = *(int32_t *)v119;
                v124 = v118 - v123;
                v125 = v124 < 0 == ((v124 ^ v118) & (v123 ^ v118)) < 0 == (v124 != 0) ? v123 : v118;
                v126 = *(int32_t *)(v119 + 4);
                v127 = v120 - v126;
                v128 = v127 < 0 == ((v127 ^ v120) & (v126 ^ v120)) < 0 == (v127 != 0) ? v126 : v120;
                v129 = *(int32_t *)(v119 + 8);
                v130 = v117 - v129;
                v131 = v130 < 0 == ((v130 ^ v117) & (v129 ^ v117)) < 0 ? v117 : v129;
                v132 = *(int32_t *)(v119 + 12);
                v133 = v116 - v132;
                v122 = v133 < 0 == ((v133 ^ v116) & (v132 ^ v116)) < 0 ? v116 : v132;
                v119 -= 68;
                v112 = v122;
                v113 = v131;
                v114 = v128;
                v115 = v125;
            }
        }
        // 0x80a2902
        v134 = v115;
        v135 = v114;
        v136 = v113;
        v137 = v112;
        v110++;
        v138 = v142 + 92;
    }
    // 0x80a2914
    g75 = v134;
    g76 = v135;
    g77 = v136;
    g78 = v137;
    int32_t v144 = 0; // 0x80a293e
    int32_t v145 = *(int32_t *)(v55 + 8); // 0x80a2943
    int32_t v146 = v137; // 0x80a294c
    int32_t v147 = v136; // 0x80a294c
    int32_t v148 = v135; // 0x80a294c
    int32_t v149 = v134; // 0x80a294c
    int32_t v150; // 0x80a25d0
    int32_t v151; // 0x80a25d0
    int32_t v152; // 0x80a25d0
    int32_t v153; // 0x80a25d0
    int32_t v154; // 0x80a25d0
    int32_t v155; // 0x80a25d0
    int32_t v156; // 0x80a2960
    int32_t v157; // 0x80a2960
    int32_t v158; // 0x80a2962
    int32_t v159; // 0x80a2965
    int32_t v160; // 0x80a2965
    int32_t v161; // 0x80a2968
    int32_t v162; // 0x80a296c
    int32_t v163; // 0x80a296c
    int32_t v164; // 0x80a296f
    int32_t v165; // 0x80a2973
    int32_t v166; // 0x80a2973
    int32_t v167; // 0x80a2976
    if (v145 != 0) {
        // 0x80a294e
        v155 = v145;
        v153 = 60 * v145 - 60 + *(int32_t *)(v55 + 40);
        v152 = v134;
        v154 = v135;
        v151 = v136;
        v150 = v137;
        v155--;
        v156 = *(int32_t *)v153;
        v157 = v152 - v156;
        v158 = v157 < 0 == ((v157 ^ v152) & (v156 ^ v152)) < 0 == (v157 != 0) ? v156 : v152;
        v159 = *(int32_t *)(v153 + 4);
        v160 = v154 - v159;
        v161 = v160 < 0 == ((v160 ^ v154) & (v159 ^ v154)) < 0 == (v160 != 0) ? v159 : v154;
        v162 = *(int32_t *)(v153 + 8);
        v163 = v151 - v162;
        v164 = v163 < 0 == ((v163 ^ v151) & (v162 ^ v151)) < 0 ? v151 : v162;
        v165 = *(int32_t *)(v153 + 12);
        v166 = v150 - v165;
        v167 = v166 < 0 == ((v166 ^ v150) & (v165 ^ v150)) < 0 ? v150 : v165;
        v153 -= 60;
        v146 = v167;
        v147 = v164;
        v148 = v161;
        v149 = v158;
        while (v155 != 0) {
            // 0x80a2960
            v152 = v158;
            v154 = v161;
            v151 = v164;
            v150 = v167;
            v155--;
            v156 = *(int32_t *)v153;
            v157 = v152 - v156;
            v158 = v157 < 0 == ((v157 ^ v152) & (v156 ^ v152)) < 0 == (v157 != 0) ? v156 : v152;
            v159 = *(int32_t *)(v153 + 4);
            v160 = v154 - v159;
            v161 = v160 < 0 == ((v160 ^ v154) & (v159 ^ v154)) < 0 == (v160 != 0) ? v159 : v154;
            v162 = *(int32_t *)(v153 + 8);
            v163 = v151 - v162;
            v164 = v163 < 0 == ((v163 ^ v151) & (v162 ^ v151)) < 0 ? v151 : v162;
            v165 = *(int32_t *)(v153 + 12);
            v166 = v150 - v165;
            v167 = v166 < 0 == ((v166 ^ v150) & (v165 ^ v150)) < 0 ? v150 : v165;
            v153 -= 60;
            v146 = v167;
            v147 = v164;
            v148 = v161;
            v149 = v158;
        }
    }
    int32_t v168 = v149;
    int32_t v169 = v148;
    int32_t v170 = v147;
    int32_t v171 = v146;
    v144++;
    int32_t v172 = v55 + 92; // 0x80a2994
    while (v144 != v56) {
        int32_t v173 = v168;
        int32_t v174 = v169;
        int32_t v175 = v170;
        int32_t v176 = v172;
        int32_t v177 = v171;
        v145 = *(int32_t *)(v176 + 8);
        v146 = v177;
        v147 = v175;
        v148 = v174;
        v149 = v173;
        if (v145 != 0) {
            // 0x80a294e
            v155 = v145;
            v153 = 60 * v145 - 60 + *(int32_t *)(v176 + 40);
            v152 = v173;
            v154 = v174;
            v151 = v175;
            v150 = v177;
            v155--;
            v156 = *(int32_t *)v153;
            v157 = v152 - v156;
            v158 = v157 < 0 == ((v157 ^ v152) & (v156 ^ v152)) < 0 == (v157 != 0) ? v156 : v152;
            v159 = *(int32_t *)(v153 + 4);
            v160 = v154 - v159;
            v161 = v160 < 0 == ((v160 ^ v154) & (v159 ^ v154)) < 0 == (v160 != 0) ? v159 : v154;
            v162 = *(int32_t *)(v153 + 8);
            v163 = v151 - v162;
            v164 = v163 < 0 == ((v163 ^ v151) & (v162 ^ v151)) < 0 ? v151 : v162;
            v165 = *(int32_t *)(v153 + 12);
            v166 = v150 - v165;
            v167 = v166 < 0 == ((v166 ^ v150) & (v165 ^ v150)) < 0 ? v150 : v165;
            v153 -= 60;
            v146 = v167;
            v147 = v164;
            v148 = v161;
            v149 = v158;
            while (v155 != 0) {
                // 0x80a2960
                v152 = v158;
                v154 = v161;
                v151 = v164;
                v150 = v167;
                v155--;
                v156 = *(int32_t *)v153;
                v157 = v152 - v156;
                v158 = v157 < 0 == ((v157 ^ v152) & (v156 ^ v152)) < 0 == (v157 != 0) ? v156 : v152;
                v159 = *(int32_t *)(v153 + 4);
                v160 = v154 - v159;
                v161 = v160 < 0 == ((v160 ^ v154) & (v159 ^ v154)) < 0 == (v160 != 0) ? v159 : v154;
                v162 = *(int32_t *)(v153 + 8);
                v163 = v151 - v162;
                v164 = v163 < 0 == ((v163 ^ v151) & (v162 ^ v151)) < 0 ? v151 : v162;
                v165 = *(int32_t *)(v153 + 12);
                v166 = v150 - v165;
                v167 = v166 < 0 == ((v166 ^ v150) & (v165 ^ v150)) < 0 ? v150 : v165;
                v153 -= 60;
                v146 = v167;
                v147 = v164;
                v148 = v161;
                v149 = v158;
            }
        }
        // 0x80a298a
        v168 = v149;
        v169 = v148;
        v170 = v147;
        v171 = v146;
        v144++;
        v172 = v176 + 92;
    }
    // 0x80a299c
    g75 = v168;
    g76 = v169;
    g77 = v170;
    g78 = v171;
    int32_t v178 = 0; // 0x80a29bd
    int32_t v179 = *(int32_t *)(v55 + 12); // 0x80a29c3
    int32_t v180 = v171; // 0x80a29cc
    int32_t v181 = v170; // 0x80a29cc
    int32_t v182 = v169; // 0x80a29cc
    int32_t v183 = v168; // 0x80a29cc
    int32_t v184; // 0x80a25d0
    int32_t v185; // 0x80a25d0
    int32_t v186; // 0x80a25d0
    int32_t v187; // 0x80a25d0
    int32_t v188; // 0x80a25d0
    int32_t v189; // 0x80a25d0
    int32_t v190; // 0x80a29e0
    int32_t v191; // 0x80a29e0
    int32_t v192; // 0x80a29e2
    int32_t v193; // 0x80a29e5
    int32_t v194; // 0x80a29e5
    int32_t v195; // 0x80a29e8
    int32_t v196; // 0x80a29ec
    int32_t v197; // 0x80a29ec
    int32_t v198; // 0x80a29ef
    int32_t v199; // 0x80a29f3
    int32_t v200; // 0x80a29f3
    int32_t v201; // 0x80a29f6
    if (v179 != 0) {
        // 0x80a29ce
        v189 = v179;
        v187 = 60 * v179 - 60 + *(int32_t *)(v55 + 44);
        v186 = v168;
        v188 = v169;
        v185 = v170;
        v184 = v171;
        v189--;
        v190 = *(int32_t *)v187;
        v191 = v186 - v190;
        v192 = v191 < 0 == ((v191 ^ v186) & (v190 ^ v186)) < 0 == (v191 != 0) ? v190 : v186;
        v193 = *(int32_t *)(v187 + 4);
        v194 = v188 - v193;
        v195 = v194 < 0 == ((v194 ^ v188) & (v193 ^ v188)) < 0 == (v194 != 0) ? v193 : v188;
        v196 = *(int32_t *)(v187 + 8);
        v197 = v185 - v196;
        v198 = v197 < 0 == ((v197 ^ v185) & (v196 ^ v185)) < 0 ? v185 : v196;
        v199 = *(int32_t *)(v187 + 12);
        v200 = v184 - v199;
        v201 = v200 < 0 == ((v200 ^ v184) & (v199 ^ v184)) < 0 ? v184 : v199;
        v187 -= 60;
        v180 = v201;
        v181 = v198;
        v182 = v195;
        v183 = v192;
        while (v189 != 0) {
            // 0x80a29e0
            v186 = v192;
            v188 = v195;
            v185 = v198;
            v184 = v201;
            v189--;
            v190 = *(int32_t *)v187;
            v191 = v186 - v190;
            v192 = v191 < 0 == ((v191 ^ v186) & (v190 ^ v186)) < 0 == (v191 != 0) ? v190 : v186;
            v193 = *(int32_t *)(v187 + 4);
            v194 = v188 - v193;
            v195 = v194 < 0 == ((v194 ^ v188) & (v193 ^ v188)) < 0 == (v194 != 0) ? v193 : v188;
            v196 = *(int32_t *)(v187 + 8);
            v197 = v185 - v196;
            v198 = v197 < 0 == ((v197 ^ v185) & (v196 ^ v185)) < 0 ? v185 : v196;
            v199 = *(int32_t *)(v187 + 12);
            v200 = v184 - v199;
            v201 = v200 < 0 == ((v200 ^ v184) & (v199 ^ v184)) < 0 ? v184 : v199;
            v187 -= 60;
            v180 = v201;
            v181 = v198;
            v182 = v195;
            v183 = v192;
        }
    }
    int32_t v202 = v183;
    int32_t v203 = v182;
    int32_t v204 = v181;
    int32_t v205 = v180;
    v178++;
    int32_t v206 = v55 + 92; // 0x80a2a14
    while (v178 != v56) {
        int32_t v207 = v202;
        int32_t v208 = v203;
        int32_t v209 = v204;
        int32_t v210 = v206;
        int32_t v211 = v205;
        v179 = *(int32_t *)(v210 + 12);
        v180 = v211;
        v181 = v209;
        v182 = v208;
        v183 = v207;
        if (v179 != 0) {
            // 0x80a29ce
            v189 = v179;
            v187 = 60 * v179 - 60 + *(int32_t *)(v210 + 44);
            v186 = v207;
            v188 = v208;
            v185 = v209;
            v184 = v211;
            v189--;
            v190 = *(int32_t *)v187;
            v191 = v186 - v190;
            v192 = v191 < 0 == ((v191 ^ v186) & (v190 ^ v186)) < 0 == (v191 != 0) ? v190 : v186;
            v193 = *(int32_t *)(v187 + 4);
            v194 = v188 - v193;
            v195 = v194 < 0 == ((v194 ^ v188) & (v193 ^ v188)) < 0 == (v194 != 0) ? v193 : v188;
            v196 = *(int32_t *)(v187 + 8);
            v197 = v185 - v196;
            v198 = v197 < 0 == ((v197 ^ v185) & (v196 ^ v185)) < 0 ? v185 : v196;
            v199 = *(int32_t *)(v187 + 12);
            v200 = v184 - v199;
            v201 = v200 < 0 == ((v200 ^ v184) & (v199 ^ v184)) < 0 ? v184 : v199;
            v187 -= 60;
            v180 = v201;
            v181 = v198;
            v182 = v195;
            v183 = v192;
            while (v189 != 0) {
                // 0x80a29e0
                v186 = v192;
                v188 = v195;
                v185 = v198;
                v184 = v201;
                v189--;
                v190 = *(int32_t *)v187;
                v191 = v186 - v190;
                v192 = v191 < 0 == ((v191 ^ v186) & (v190 ^ v186)) < 0 == (v191 != 0) ? v190 : v186;
                v193 = *(int32_t *)(v187 + 4);
                v194 = v188 - v193;
                v195 = v194 < 0 == ((v194 ^ v188) & (v193 ^ v188)) < 0 == (v194 != 0) ? v193 : v188;
                v196 = *(int32_t *)(v187 + 8);
                v197 = v185 - v196;
                v198 = v197 < 0 == ((v197 ^ v185) & (v196 ^ v185)) < 0 ? v185 : v196;
                v199 = *(int32_t *)(v187 + 12);
                v200 = v184 - v199;
                v201 = v200 < 0 == ((v200 ^ v184) & (v199 ^ v184)) < 0 ? v184 : v199;
                v187 -= 60;
                v180 = v201;
                v181 = v198;
                v182 = v195;
                v183 = v192;
            }
        }
        // 0x80a2a0a
        v202 = v183;
        v203 = v182;
        v204 = v181;
        v205 = v180;
        v178++;
        v206 = v210 + 92;
    }
    // 0x80a283f
    g75 = v202;
    g76 = v203;
    g77 = v204;
    g78 = v205;
    // 0x80a2859
    v58 = IsDataEmpty(Data);
    return v58 == 0 ? (int32_t)&g75 : 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a2a20 - 0x80a2bdf
// Line range:    625 - 687
void SetFontInfo(int32_t Ptr) {
    int32_t * v1 = (int32_t *)(Ptr + 4); // 0x80a2a3b
    *v1 = 50;
    int32_t * v2 = (int32_t *)Ptr; // 0x80a2a42
    *v2 = 50;
    int32_t v3 = Ptr + 24; // 0x80a2a48
    int32_t v4 = Ptr + 28; // 0x80a2a56
    int32_t v5 = 0; // 0x80a2a4e
    int32_t v6 = 0x989680; // 0x80a2a4e
    int32_t v7; // 0x80a2a20
    int32_t v8; // 0x80a2a20
    int32_t v9; // 0x80a2a20
    int32_t v10; // 0x80a2a20
    int32_t v11; // 0x80a2a20
    int32_t v12; // 0x80a2ab5
    int32_t v13; // 0x80a2ac7
    int32_t v14; // 0x80a2ad3
    int32_t v15; // 0x80a2adf
    int32_t v16; // 0x80a2a20
    while (true) {
      lab_0x80a2a50:
        // 0x80a2a50
        v9 = v6;
        v11 = v5;
        v10 = v9;
        if (*(char *)(v11 + v4) == 0) {
            goto lab_0x80a2b5b;
        } else {
            // 0x80a2a61
            v16 = v11 + Ptr;
            int32_t v17 = *(int32_t *)(v16 + 32); // 0x80a2a61
            v10 = v9;
            if (v17 == 0) {
                goto lab_0x80a2b5b;
            } else {
                int32_t v18 = *(int32_t *)(v11 + v3); // 0x80a2a70
                int32_t v19 = 0; // 0x80a2a9c
                int32_t v20 = 0; // 0x80a2a9c
                int32_t v21 = v17; // 0x80a2a9c
                int32_t v22 = 0x989680; // 0x80a2a9c
                int32_t v23 = 0x989680; // 0x80a2a9c
                int32_t v24 = v18; // 0x80a2a9c
                while (true) {
                    int32_t v25 = v23;
                    int32_t v26 = v22;
                    int32_t v27 = v20;
                    int32_t v28 = v19;
                    int32_t v29 = *(int32_t *)(v24 + 44); // 0x80a2aa0
                    int32_t v30 = *(int32_t *)(v24 + 64); // 0x80a2aa3
                    int32_t v31 = *(int32_t *)(v24 + 48); // 0x80a2aa6
                    int32_t v32 = v30 - v29; // 0x80a2aab
                    int32_t v33 = v32 == 0 | v32 < 0 != ((v32 ^ v30) & (v30 ^ v29)) < 0 ? v30 : v29; // 0x80a2aad
                    int32_t v34 = v25 - v33; // 0x80a2ab2
                    v12 = v34 == 0 | v34 < 0 != ((v34 ^ v25) & (v33 ^ v25)) < 0 ? v25 : v33;
                    int32_t v35 = *(int32_t *)(v24 + 68); // 0x80a2abc
                    int32_t v36 = v35 - v31; // 0x80a2abf
                    int32_t v37 = v36 == 0 | v36 < 0 != ((v36 ^ v35) & (v35 ^ v31)) < 0 ? v35 : v31; // 0x80a2ac1
                    int32_t v38 = v26 - v37; // 0x80a2ac4
                    v13 = v38 == 0 | v38 < 0 != ((v38 ^ v26) & (v37 ^ v26)) < 0 ? v26 : v37;
                    int32_t v39 = v32 < 0 == ((v32 ^ v30) & (v30 ^ v29)) < 0 ? v30 : v29; // 0x80a2acd
                    int32_t v40 = v27 - v39; // 0x80a2ad0
                    v14 = v40 < 0 == ((v40 ^ v27) & (v39 ^ v27)) < 0 ? v27 : v39;
                    int32_t v41 = v36 < 0 == ((v36 ^ v35) & (v35 ^ v31)) < 0 ? v35 : v31; // 0x80a2ad9
                    int32_t v42 = v28 - v41; // 0x80a2adc
                    v15 = v42 < 0 == ((v42 ^ v28) & (v41 ^ v28)) < 0 ? v28 : v41;
                    v21--;
                    v19 = v15;
                    v20 = v14;
                    v22 = v13;
                    v23 = v12;
                    v24 += 88;
                    v7 = v18;
                    v8 = v17;
                    if (v21 == 0) {
                        goto lab_0x80a2b00;
                    }
                }
                goto lab_0x80a2b16;
            }
        }
    }
  lab_0x80a2b78:;
    int32_t v43; // 0x80a2a20
    while (true) {
        int32_t v44 = v43;
        if (*(char *)(v44 + v4) != 0) {
            int32_t v45 = v44 + Ptr;
            int32_t v46 = *(int32_t *)(v45 + 32); // 0x80a2b87
            int32_t * v47 = (int32_t *)(v45 + 44); // 0x80a2b8b
            *v47 = *v47 - v6;
            if (v46 != 0) {
                int32_t v48 = *(int32_t *)(v44 + v3); // 0x80a2a20
                int32_t v49 = v46; // 0x80a2ba9
                int32_t * v50 = (int32_t *)(v48 + 48); // 0x80a2b98
                *v50 = *v50 - v6;
                int32_t * v51 = (int32_t *)(v48 + 68); // 0x80a2b9b
                *v51 = *v51 - v6;
                SetLineBoundingBox(v48);
                v49--;
                v48 += 88;
                while (v49 != 0) {
                    // 0x80a2b98
                    v50 = (int32_t *)(v48 + 48);
                    *v50 = *v50 - v6;
                    v51 = (int32_t *)(v48 + 68);
                    *v51 = *v51 - v6;
                    SetLineBoundingBox(v48);
                    v49--;
                    v48 += 88;
                }
            }
        }
        // 0x80a2bae
        v43 = v44 + 28;
        if (v44 == 0x1be4) {
            // break -> 0x80a2bbb
            break;
        }
    }
    // 0x80a2bbb
    *(int32_t *)(Ptr + 12) = 0;
    *(int32_t *)(Ptr + 8) = 0;
    *(int32_t *)(Ptr + 16) = *v1;
    *(int32_t *)(Ptr + 20) = *v2;
  lab_0x80a2b00:;
    int32_t * v52 = (int32_t *)(v7 + 44); // 0x80a2b00
    *v52 = *v52 - v12;
    int32_t * v53 = (int32_t *)(v7 + 64); // 0x80a2b03
    *v53 = *v53 - v12;
    SetLineBoundingBox(v7);
    int32_t v54 = v8 - 1; // 0x80a2b11
    v7 += 88;
    v8 = v54;
    if (v54 != 0) {
        goto lab_0x80a2b00;
    } else {
        goto lab_0x80a2b16;
    }
  lab_0x80a2b5b:
    // 0x80a2b5b
    v6 = v10;
    v5 = v11 + 28;
    v43 = 0;
    if (v11 == 0x1be4) {
        // break -> 0x80a2b78
        goto lab_0x80a2b78;
    }
    goto lab_0x80a2a50;
  lab_0x80a2b16:;
    int32_t v55 = v14 + 1 - v12; // 0x80a2b25
    *(int32_t *)(v16 + 40) = v55;
    int32_t * v56 = (int32_t *)(v16 + 44); // 0x80a2b2e
    *v56 = v15 + 1;
    int32_t v57 = *v1; // 0x80a2b35
    int32_t v58 = v55 - v57; // 0x80a2b38
    *v1 = v58 < 0 == ((v58 ^ v55) & (v57 ^ v55)) < 0 ? v55 : v57;
    int32_t v59 = *v56; // 0x80a2b43
    int32_t v60 = *v2; // 0x80a2b47
    int32_t v61 = v60 - v59; // 0x80a2b47
    *v2 = v61 < 0 == ((v61 ^ v60) & (v60 ^ v59)) < 0 ? v60 : v59;
    int32_t v62 = v9 - v13; // 0x80a2b51
    int32_t v63 = v62 == 0 | v62 < 0 != ((v62 ^ v9) & (v13 ^ v9)) < 0 ? v9 : v13; // 0x80a2b54
    v10 = v63;
    goto lab_0x80a2b5b;
}

// Address range: 0x80a2be0 - 0x80a2c06
int32_t GetLayerNumber(int32_t a1, int32_t a2) {
    int32_t v1 = 0;
    int32_t result = v1; // 0x80a2bf9
    while (a1 + 76 + 92 * v1 != a2) {
        int32_t v2 = v1 + 1; // 0x80a2bfb
        result = v2;
        if (v1 == 17) {
            // break -> 0x80a2c03
            break;
        }
        v1 = v2;
        result = v1;
    }
    // 0x80a2c03
    return result;
}

// Address range: 0x80a2c10 - 0x80a2ca6
int32_t GetGroupOfLayer(int32_t result) {
    int32_t v1 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24); // 0x80a2c2c
    if (v1 == result) {
        // 0x80a2c88
        return result;
    }
    int32_t result2 = v1; // 0x80a2c3d
    if (v1 < 1) {
      lab_0x80a2c88:
        // 0x80a2c88
        return result2;
    }
    int32_t v2 = 0x1000000 * PCB / 0x1000000; // 0x80a2c3f
    int32_t v3 = 0;
    char v4 = PCB;
    uint32_t v5 = *(int32_t *)(v2 + 0x1cd4 + 4 * v3); // 0x80a2c42
    int32_t v6; // 0x80a2c10
    int32_t v7; // 0x80a2c10
    int32_t v8; // 0x80a2c71
    if (v5 != 0) {
        // 0x80a2c4d
        if (*(int32_t *)((int32_t)v4 + 0x1d14) == result) {
            // break -> 0x80a2c88
            break;
        }
        // 0x80a2c58
        v8 = 0;
        v6 = v2 + 0x1d18 + 72 * v3;
        v8++;
        while (v5 > v8) {
            // 0x80a2c68
            v7 = v6;
            v6 = v7 + 4;
            result2 = v3;
            if (*(int32_t *)v7 == result) {
                return result2;
            }
            v8++;
        }
    }
    int32_t v9 = v3 + 1; // 0x80a2c78
    char v10 = v4 + 72; // 0x80a2c82
    result2 = v1;
    while (v1 > v9) {
        // 0x80a2c3f
        v3 = v9;
        v4 = v10;
        v5 = *(int32_t *)(v2 + 0x1cd4 + 4 * v3);
        if (v5 != 0) {
            // 0x80a2c4d
            result2 = v3;
            if (*(int32_t *)((int32_t)v4 + 0x1d14) == result) {
                // break -> 0x80a2c88
                break;
            }
            // 0x80a2c58
            v8 = 0;
            v6 = v2 + 0x1d18 + 72 * v3;
            v8++;
            while (v5 > v8) {
                // 0x80a2c68
                v7 = v6;
                v6 = v7 + 4;
                result2 = v3;
                if (*(int32_t *)v7 == result) {
                    return result2;
                }
                v8++;
            }
        }
        // 0x80a2c78
        v9 = v3 + 1;
        v10 = v4 + 72;
        result2 = v1;
    }
    // 0x80a2c88
    return result2;
}

// Address range: 0x80a2d50 - 0x80a2dd0
int32_t GetLayerGroupNumberByNumber(int32_t a1) {
    uint32_t v1 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24); // 0x80a2d6f
    int32_t result = 0; // 0x80a2d7c
    if (v1 < 1) {
      lab_0x80a2dc8:
        // 0x80a2dc8
        return result;
    }
    int32_t v2 = 0x1000000 * PCB / 0x1000000; // 0x80a2d7e
    int32_t v3 = 0;
    char v4 = PCB;
    uint32_t v5 = *(int32_t *)(v2 + 0x1cd4 + 4 * v3); // 0x80a2d81
    int32_t v6; // 0x80a2d50
    int32_t v7; // 0x80a2d50
    int32_t v8; // 0x80a2db1
    if (v5 != 0) {
        // 0x80a2d8c
        if (*(int32_t *)((int32_t)v4 + 0x1d14) == a1) {
            // break -> 0x80a2dc8
            break;
        }
        // 0x80a2d97
        v6 = v2 + 0x1d18 + 72 * v3;
        v8 = 0;
        while (v8 + 1 < v5) {
            // 0x80a2db1
            v8++;
            // 0x80a2da8
            v7 = v6;
            v6 = v7 + 4;
            result = v3;
            if (*(int32_t *)v7 == a1) {
                return result;
            }
        }
    }
    int32_t v9 = v3 + 1; // 0x80a2db8
    char v10 = v4 + 72; // 0x80a2dc2
    result = v9;
    while (v9 < v1) {
        // 0x80a2d7e
        v3 = v9;
        v4 = v10;
        v5 = *(int32_t *)(v2 + 0x1cd4 + 4 * v3);
        if (v5 != 0) {
            // 0x80a2d8c
            result = v3;
            if (*(int32_t *)((int32_t)v4 + 0x1d14) == a1) {
                // break -> 0x80a2dc8
                break;
            }
            // 0x80a2d97
            v6 = v2 + 0x1d18 + 72 * v3;
            v8 = 0;
            while (v8 + 1 < v5) {
                // 0x80a2db1
                v8++;
                // 0x80a2da8
                v7 = v6;
                v6 = v7 + 4;
                result = v3;
                if (*(int32_t *)v7 == a1) {
                    return result;
                }
            }
        }
        // 0x80a2db8
        v9 = v3 + 1;
        v10 = v4 + 72;
        result = v9;
    }
    // 0x80a2dc8
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a2dd0 - 0x80a2df6
// Line range:    1711 - 1717
int32_t mem_any_set(char * ptr, int32_t bytes) {
    // 0x80a2dd0
    if (bytes == 0) {
        // 0x80a2df4
        return 0;
    }
    int32_t v1 = (int32_t)ptr; // 0x80a2dd0
    int32_t v2 = bytes; // 0x80a2de7
    int32_t result = 1; // 0x80a2ded
    while (*(char *)v1 == 0) {
        // 0x80a2de0
        v2--;
        v1++;
        result = 0;
        if (v2 == 0) {
            // break -> 0x80a2df4
            break;
        }
        result = 1;
    }
    // 0x80a2df4
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a35c0 - 0x80a3732
// Line range:    1902 - 1959
float64_t c_strtod(char * s) {
    int32_t v1 = (int32_t)s;
    unsigned char v2 = *s; // 0x80a35c9
    int32_t v3 = v2; // 0x80a35c9
    int32_t v4 = v1; // 0x80a35ce
    int32_t v5 = v3; // 0x80a35ce
    float80_t v6 = 0.0L; // 0x80a35ce
    float80_t v7 = 1.0L; // 0x80a35ce
    int32_t v8 = v1; // 0x80a35ce
    int32_t v9 = v3; // 0x80a35ce
    char v10; // 0x80a35c0
    int32_t v11; // 0x80a35c0
    int32_t v12; // 0x80a35c0
    int32_t v13; // 0x80a35c0
    float80_t v14; // 0x80a35c0
    float80_t v15; // 0x80a35c0
    float80_t v16; // 0x80a35c0
    float80_t v17; // 0x80a35c0
    if (v2 != 0) {
        int32_t v18; // 0x80a35c0
        char v19; // 0x80a35c0
        while (true) {
          lab_0x80a35e6:
            // 0x80a35e6
            v18 = v5;
            v11 = v4;
            v19 = v18;
            switch (v19) {
                case 9: {
                    goto lab_0x80a35d8;
                }
                case 32: {
                    goto lab_0x80a35d8;
                }
                default: {
                    goto lab_0x80a35f0;
                }
            }
        }
      lab_0x80a35f0:;
        int32_t v20; // 0x80a35c0
        int32_t v21; // 0x80a35c0
        float80_t v22; // 0x80a35c0
        if (v19 != 45) {
            // 0x80a36d0
            v22 = 1.0L;
            v20 = v11;
            v21 = v18;
            if (v19 == 43) {
                int32_t v23 = v11 + 1; // 0x80a36d5
                v22 = 1.0L;
                v20 = v23;
                v21 = (int32_t)*(char *)v23;
            }
        } else {
            int32_t v24 = v11 + 1; // 0x80a35f9
            v22 = -1.0L;
            v20 = v24;
            v21 = (int32_t)*(char *)v24;
        }
        char v25 = v21;
        char v26 = v25; // 0x80a3609
        float80_t v27 = 0.0L; // 0x80a3609
        int32_t v28 = v20; // 0x80a3609
        int32_t v29 = v21; // 0x80a3609
        if (v25 < 58) {
            int32_t v30 = v20 + 1; // 0x80a361b
            unsigned char v31 = *(char *)v30; // 0x80a3626
            int32_t v32 = v31; // 0x80a3626
            float80_t v33 = 0x1000000 * v21 / 0x1000000 - 48; // 0x80a3632
            float80_t v34 = v33; // 0x80a3634
            int32_t v35 = v30; // 0x80a3634
            int32_t v36 = v32; // 0x80a3634
            v26 = v31;
            v27 = v33;
            v28 = v30;
            v29 = v32;
            while (v31 < 58) {
                // 0x80a3618
                v30 = v35 + 1;
                v31 = *(char *)v30;
                v32 = v31;
                v33 = 10.0L * v34 + (float80_t)(0x1000000 * v36 / 0x1000000 - 48);
                v34 = v33;
                v35 = v30;
                v36 = v32;
                v26 = v31;
                v27 = v33;
                v28 = v30;
                v29 = v32;
            }
        }
        // 0x80a3638
        v6 = v27;
        v7 = v22;
        v8 = v28;
        v9 = v29;
        if (v26 != 46) {
            goto lab_0x80a36bc;
        } else {
            int32_t v37 = v28 + 1; // 0x80a363d
            unsigned char v38 = *(char *)v37; // 0x80a3640
            int32_t v39 = v38; // 0x80a3640
            float80_t v40 = 0.1L; // 0x80a3649
            v6 = v27;
            v7 = v22;
            v8 = v37;
            v9 = v39;
            if (v38 < 58) {
                int32_t v41 = v37 + 1; // 0x80a365b
                unsigned char v42 = *(char *)v41; // 0x80a3664
                float80_t v43 = v27 + v40 * (float80_t)(0x1000000 * v39 / 0x1000000 - 48); // 0x80a3672
                v40 *= 0.1L;
                float80_t v44 = v43; // 0x80a3676
                int32_t v45 = v41; // 0x80a3676
                int32_t v46 = v42; // 0x80a3676
                while (v42 < 58) {
                    // 0x80a3658
                    v41 = v45 + 1;
                    v42 = *(char *)v41;
                    v43 = v44 + v40 * (float80_t)(0x1000000 * v46 / 0x1000000 - 48);
                    v40 *= 0.1L;
                    v44 = v43;
                    v45 = v41;
                    v46 = v42;
                }
                // 0x80a3678
                v14 = v43;
                v16 = v22;
                v12 = v41;
                v10 = v42;
                v15 = v43;
                v17 = v22;
                v13 = v41;
                if (v42 != 101) {
                    goto lab_0x80a36c1;
                } else {
                    goto lab_0x80a3688;
                }
            } else {
                goto lab_0x80a36bc;
            }
        }
    } else {
        goto lab_0x80a36bc;
    }
  lab_0x80a35d8:
    // 0x80a35d8
    v4 = v11 + 1;
    unsigned char v47 = *(char *)v4; // 0x80a35db
    v5 = v47;
    if (v47 == 0) {
        // 0x80a36c6
        return 0.0L;
    }
    goto lab_0x80a35e6;
  lab_0x80a36bc:;
    char v48 = v9;
    v14 = v6;
    v16 = v7;
    v12 = v8;
    v10 = v48;
    v15 = v6;
    v17 = v7;
    v13 = v8;
    if (v48 == 101) {
        goto lab_0x80a3688;
    } else {
        goto lab_0x80a36c1;
    }
  lab_0x80a3688:;
    // 0x80a3688
    int32_t v49; // bp-16, 0x80a35c0
    if (function_80607f8(v12 + 1, "%d", &v49, v14) != 1) {
        // 0x80a36b3
        return v14 * v16;
    }
    // 0x80a36e8
    if (v49 >= 1) {
        int32_t v50 = v49 - 1; // 0x80a36f8
        float80_t v51 = 10.0L; // 0x80a36fb
        float80_t v52 = v51; // 0x80a36fd
        int32_t v53 = v50; // 0x80a36fd
        while (v50 != 0) {
            // 0x80a36f8
            v50 = v53 - 1;
            v51 = 10.0L * v52;
            v52 = v51;
            v53 = v50;
        }
        // 0x80a3708
        return v16 * v14 * v51;
    }
    // 0x80a370c
    if (v49 == 0) {
        // 0x80a3708
        return v16 * v14;
    }
    int32_t v54 = v49 + 1; // 0x80a3718
    float80_t v55 = 0.1L; // 0x80a371b
    float80_t v56 = v55; // 0x80a371d
    int32_t v57 = v54; // 0x80a371d
    while (v54 != 0) {
        // 0x80a3718
        v54 = v57 + 1;
        v55 = 0.1L * v56;
        v56 = v55;
        v57 = v54;
    }
    // 0x80a3708
    return v16 * v14 * v55;
  lab_0x80a36c1:
    // 0x80a36c1
    v14 = v15;
    v16 = v17;
    v12 = v13;
    if (v10 != 69) {
        // 0x80a36c6
        return v17 * v15;
    }
    goto lab_0x80a3688;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a3740 - 0x80a381e
// Line range:    1878 - 1899
char * c_dtostr(float64_t d) {
    int32_t v1 = (int32_t)&g64; // 0x80a3752
    float80_t v2; // 0x80a3740
    if (d < 0.0) {
        // 0x80a3756
        *(char *)&g64 = 45;
        float80_t v3; // 0x80a3740
        v2 = -v3;
        v1 = &g65;
    }
    float80_t v4 = v2 + 5.0e-7L; // 0x80a3764
    floor((float64_t)v4);
    char * str = (char *)v1; // 0x80a3775
    __sprintf_chk(str, 1, 100, "%d", (int32_t)v4);
    int32_t v5 = strlen(str) + v1; // 0x80a37ba
    *(char *)v5 = 46;
    float80_t v6 = 0.0L; // 0x80a37cd
    floor((float64_t)v6);
    __sprintf_chk((char *)(v5 + 1), 1, -1, "%06d", (int32_t)v6);
    return (char *)&g64;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a3820 - 0x80a398a
// Line range:    1796 - 1834
char * LayerGroupsToString(int32_t lg) {
    int32_t v1 = 0; // 0x80a3840
    int32_t v2 = PCB; // 0x80a3840
    int32_t v3 = PCB; // 0x80a3840
    int32_t v4 = (int32_t)&g66; // 0x80a3840
    int32_t v5 = 0; // 0x80a3840
    if (*(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24) < 1) {
        // 0x80a397a
        *(char *)(int32_t)&g66 = 0;
        return (char *)&g66;
    }
    int32_t v6; // 0x80a3820
    int32_t v7; // 0x80a3820
    int32_t v8; // 0x80a3820
    int32_t v9; // 0x80a3820
    int32_t v10; // 0x80a3820
    int32_t v11; // 0x80a3820
    int32_t v12; // 0x80a3820
    while (true) {
      lab_0x80a3872:;
        int32_t v13 = v5;
        int32_t v14 = v4;
        v10 = v3;
        v6 = v2;
        v11 = v1;
        v12 = 4 * v11 + 0x1cd4;
        int32_t * v15 = (int32_t *)(v12 + v10); // 0x80a387b
        v2 = v6;
        v9 = v6;
        v7 = v14;
        v5 = v13;
        if (*v15 == 0) {
            goto lab_0x80a385a;
        } else {
            // 0x80a3886
            v8 = v14;
            if ((char)v13 == 0) {
                goto lab_0x80a38b2;
            } else {
                // 0x80a3892
                *(char *)v14 = 58;
                int32_t v16 = v14 + 1; // 0x80a388f
                v2 = v6;
                v9 = v10;
                v7 = v16;
                v5 = 1;
                v8 = v16;
                if (*v15 == 0) {
                    goto lab_0x80a385a;
                } else {
                    goto lab_0x80a38b2;
                }
            }
        }
    }
  lab_0x80a397a:;
    // 0x80a397a
    int32_t v17; // 0x80a3820
    *(char *)v17 = 0;
    return (char *)&g66;
  lab_0x80a385a:
    // 0x80a385a
    v4 = v7;
    v3 = v9;
    v1 = v11 + 1;
    v17 = v4;
    if (*(int32_t *)(*(int32_t *)(v3 + 0x220c) + 24) <= v1) {
        // break -> 0x80a397a
        goto lab_0x80a397a;
    }
    goto lab_0x80a3872;
  lab_0x80a38b2:;
    int32_t v18 = 18 * v11 + 1860; // 0x80a38fb
    int32_t v19 = 0; // 0x80a38bf
    int32_t v20 = v8;
    int32_t v21 = v6;
    int32_t v22 = *(int32_t *)(v10 + 4 + 4 * (v18 + v19)); // 0x80a3902
    int32_t v23 = *(int32_t *)(*(int32_t *)(v10 + 0x220c) + 24); // 0x80a390c
    int32_t v24; // 0x80a3820
    int32_t v25; // 0x80a3820
    int32_t v26; // 0x80a3820
    int32_t v27; // 0x80a3948
    if (v23 + 1 == v22) {
        // 0x80a3960
        *(char *)v20 = 99;
        v24 = v21;
        v25 = v20 + 1;
    } else {
        if (v22 == v23) {
            // 0x80a38c8
            *(char *)v20 = 115;
            v24 = v21;
            v25 = v20 + 1;
        } else {
            // 0x80a391a
            __sprintf_chk((char *)v20, 1, 91, "%d", v22 + 1);
            v27 = v20 + 1;
            v26 = v27;
            while (*(char *)v27 != 0) {
                // 0x80a3948
                v27 = v26 + 1;
                v26 = v27;
            }
            // 0x80a3950
            v24 = PCB;
            v25 = v27;
        }
    }
    int32_t v28 = v25;
    int32_t * v29 = (int32_t *)(v24 + v12); // 0x80a38d3
    int32_t v30 = *v29; // 0x80a38d3
    int32_t v31 = v30; // 0x80a38dd
    int32_t v32 = v28; // 0x80a38dd
    if (v19 != v30 - 1) {
        // 0x80a38df
        *(char *)v28 = 44;
        v31 = *v29;
        v32 = v28 + 1;
    }
    int32_t v33 = v19 + 1; // 0x80a38ec
    v2 = v24;
    v9 = v24;
    v7 = v32;
    v5 = 1;
    v19 = v33;
    int32_t v34 = v24; // 0x80a38f4
    while (v31 > v33) {
        // 0x80a38f8
        v20 = v32;
        v21 = v24;
        v22 = *(int32_t *)(v34 + 4 + 4 * (v18 + v19));
        v23 = *(int32_t *)(*(int32_t *)(v34 + 0x220c) + 24);
        if (v23 + 1 == v22) {
            // 0x80a3960
            *(char *)v20 = 99;
            v24 = v21;
            v25 = v20 + 1;
        } else {
            if (v22 == v23) {
                // 0x80a38c8
                *(char *)v20 = 115;
                v24 = v21;
                v25 = v20 + 1;
            } else {
                // 0x80a391a
                __sprintf_chk((char *)v20, 1, 91, "%d", v22 + 1);
                v27 = v20 + 1;
                v26 = v27;
                while (*(char *)v27 != 0) {
                    // 0x80a3948
                    v27 = v26 + 1;
                    v26 = v27;
                }
                // 0x80a3950
                v24 = PCB;
                v25 = v27;
            }
        }
        // 0x80a38ce
        v28 = v25;
        v29 = (int32_t *)(v24 + v12);
        v30 = *v29;
        v31 = v30;
        v32 = v28;
        if (v19 != v30 - 1) {
            // 0x80a38df
            *(char *)v28 = 44;
            v31 = *v29;
            v32 = v28 + 1;
        }
        // 0x80a38ec
        v33 = v19 + 1;
        v2 = v24;
        v9 = v24;
        v7 = v32;
        v5 = 1;
        v19 = v33;
        v34 = v24;
    }
    goto lab_0x80a385a;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a3a70 - 0x80a3af9
// Line range:    1686 - 1708
char * Concat(char * first, ...) {
    int32_t len = strlen(first); // 0x80a3a7f
    int32_t * mem = calloc(1, len + 1); // 0x80a3a94
    int32_t v1 = (int32_t)mem; // 0x80a3a94
    strcpy((char *)mem, first);
    char * v2; // 0x80a3a70
    if (v2 == NULL) {
        // 0x80a3aef
        return (char *)v1;
    }
    // 0x80a3ab8
    int32_t v3; // bp+12, 0x80a3a70
    int32_t v4 = &v3; // 0x80a3a70
    int32_t v5 = len; // 0x80a3ac6
    char * str = (char *)(int32_t)v2; // 0x80a3ab8
    v5 += strlen(str);
    int32_t * mem2 = realloc((int32_t *)v1, v5 + 1); // 0x80a3acf
    int32_t v6 = (int32_t)mem2;
    strcat((char *)mem2, str);
    int32_t v7 = *(int32_t *)v4; // 0x80a3ae8
    v4 += 4;
    while (v7 != 0) {
        // 0x80a3ab8
        str = (char *)v7;
        v5 += strlen(str);
        mem2 = realloc((int32_t *)v6, v5 + 1);
        v6 = (int32_t)mem2;
        strcat((char *)mem2, str);
        v7 = *(int32_t *)v4;
        v4 += 4;
    }
    // 0x80a3aef
    return (char *)v6;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a3b30 - 0x80a3c59
// Line range:    1545 - 1554
char * UniqueElementName(int32_t Data, char * Name) {
    int32_t v1 = (int32_t)Name;
    if (Name == NULL || *Name == 0) {
        // 0x80a3b92
        return (char *)v1;
    }
    int32_t * v2 = (int32_t *)(Data + 8); // 0x80a3b48
    int32_t v3 = *v2; // 0x80a3b48
    int32_t v4 = v1; // 0x80a3b51
    if (v3 == 0) {
      lab_0x80a3b92:
        // 0x80a3b92
        return (char *)v4;
    }
    char * str2 = (char *)v1;
    int32_t v5 = 300 * v3 - 152 + *(int32_t *)(Data + 32); // 0x80a3b62
    int32_t v6 = v3; // 0x80a3b62
    int32_t v7; // 0x80a3b30
    int32_t v8; // 0x80a3b30
    int32_t str; // 0x80a3b68
    while (true) {
        // 0x80a3b68
        v7 = v6;
        v8 = v5;
        str = *(int32_t *)v8;
        if (str != 0) {
            // 0x80a3b6e
            if (strcmp((char *)str, str2) == 0) {
                // break -> 0x80a3ba0
                break;
            }
        }
        // 0x80a3b84
        v6 = v7 - 1;
        v5 = v8 - 300;
        v4 = v1;
        if (v6 == 0) {
            return (char *)v4;
        }
    }
    int32_t v9 = v1; // 0x80a3ba5
    int32_t v10; // 0x80a3b30
    int32_t v11; // 0x80a3ba8
    if (*str2 != 0) {
        v11 = v1 + 1;
        v10 = v11;
        v9 = v11;
        while (*(char *)v11 != 0) {
            // 0x80a3ba8
            v11 = v10 + 1;
            v10 = v11;
            v9 = v11;
        }
    }
    int16_t * v12 = *__ctype_b_loc(); // 0x80a3bb8
    int32_t v13 = v9;
    int32_t v14 = v13 - 1;
    char v15 = *(char *)v14; // 0x80a3bc3
    while ((*(char *)((int32_t)v12 + 1 + 2 * (int32_t)v15) & 8) != 0) {
        // 0x80a3bc3
        v13 = v14;
        v14 = v13 - 1;
        v15 = *(char *)v14;
    }
    char * str3 = (char *)v13; // 0x80a3bd4
    int32_t v16 = 1; // 0x80a3bdb
    char v17 = 0; // 0x80a3bdb
    int32_t str_as_l; // 0x80a3c43
    if (*str3 != 0) {
        // 0x80a3c2d
        str_as_l = strtol(str3, NULL, 10);
        v17 = *str3;
        v16 = str_as_l + 1;
    }
    // 0x80a3bdd
    *str3 = 0;
    __sprintf_chk((char *)&g67, 1, 256, "%s%d", str2, v16);
    char v18 = v17; // 0x80a3c1f
    if (v1 == (int32_t)&g67) {
        // 0x80a3c54
        v18 = *str3;
    }
    // 0x80a3c21
    *str3 = v18;
    int32_t v19 = *v2; // 0x80a3b48
    while (v19 != 0) {
        int32_t v20 = (int32_t)&g67;
        str2 = (char *)v20;
        v5 = 300 * v19 - 152 + *(int32_t *)(Data + 32);
        v6 = v19;
        while (true) {
            // 0x80a3b68
            v7 = v6;
            v8 = v5;
            str = *(int32_t *)v8;
            if (str != 0) {
                // 0x80a3b6e
                if (strcmp((char *)str, str2) == 0) {
                    // break -> 0x80a3ba0
                    break;
                }
            }
            // 0x80a3b84
            v6 = v7 - 1;
            v5 = v8 - 300;
            v4 = v20;
            if (v6 == 0) {
                return (char *)v4;
            }
        }
        // 0x80a3ba0
        v10 = v20;
        v9 = v20;
        if (*str2 != 0) {
            v11 = v10 + 1;
            v10 = v11;
            v9 = v11;
            while (*(char *)v11 != 0) {
                // 0x80a3ba8
                v11 = v10 + 1;
                v10 = v11;
                v9 = v11;
            }
        }
        // 0x80a3bb0
        v12 = *__ctype_b_loc();
        v13 = v9;
        v14 = v13 - 1;
        v15 = *(char *)v14;
        while ((*(char *)((int32_t)v12 + 1 + 2 * (int32_t)v15) & 8) != 0) {
            // 0x80a3bc3
            v13 = v14;
            v14 = v13 - 1;
            v15 = *(char *)v14;
        }
        // 0x80a3bcd
        str3 = (char *)v13;
        v16 = 1;
        v17 = 0;
        if (*str3 != 0) {
            // 0x80a3c2d
            str_as_l = strtol(str3, NULL, 10);
            v17 = *str3;
            v16 = str_as_l + 1;
        }
        // 0x80a3bdd
        *str3 = 0;
        __sprintf_chk((char *)&g67, 1, 256, "%s%d", str2, v16);
        v18 = v17;
        if (v20 == (int32_t)&g67) {
            // 0x80a3c54
            v18 = *str3;
        }
        // 0x80a3c21
        *str3 = v18;
        v19 = *v2;
    }
    // 0x80a3b92
    return (char *)(int32_t)&g67;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a3c60 - 0x80a3f59
// Line range:    778 - 802
int32_t ParseGroupString(char * s, int32_t LayerGroup, int32_t LayerN) {
    char * v1 = (char *)LayerGroup; // 0x80a3c79
    __asm_rep_stosd_memset(v1, 0, 304);
    int32_t v2; // bp-4, 0x80a3c60
    int32_t v3 = (int32_t)&v2 - 96; // 0x80a3c80
    for (int32_t i = 0; i < 18; i++) {
        // 0x80a3c80
        *(int32_t *)(4 * i + v3) = -1;
    }
    char * str; // 0x80a3c60
    int32_t v4; // 0x80a3c60
    char v5; // 0x80a3c60
    char v6; // 0x80a3c60
    char v7; // 0x80a3c60
    char v8; // 0x80a3c60
    char v9; // 0x80a3c60
    char v10; // 0x80a3c60
    int32_t v11; // 0x80a3c60
    int32_t v12; // 0x80a3c60
    int32_t v13; // 0x80a3c60
    bool v14; // 0x80a3c60
    bool v15; // 0x80a3c60
    int32_t v16; // 0x80a3c60
    int32_t v17; // 0x80a3c60
    int32_t v18; // 0x80a3c60
    int32_t v19; // 0x80a3c60
    int32_t v20; // 0x80a3c60
    int32_t v21; // 0x80a3c60
    int32_t v22; // 0x80a3c60
    int32_t v23; // 0x80a3c60
    char v24; // 0x80a3c60
    char v25; // 0x80a3c60
    char v26; // 0x80a3c60
    char v27; // 0x80a3c60
    char v28; // 0x80a3c60
    char v29; // 0x80a3c60
    int32_t v30; // 0x80a3c60
    int32_t v31; // 0x80a3c60
    int32_t v32; // 0x80a3c60
    int32_t v33; // 0x80a3c60
    int32_t v34; // 0x80a3c60
    bool v35; // 0x80a3c60
    int32_t result; // 0x80a3c60
    int16_t v36; // 0x80a3d31
    int32_t v37; // 0x80a3cc3
    int16_t ** v38; // 0x80a3cd4
    if (s == NULL) {
        // 0x80a3ebb
        v9 = 0;
        v33 = 0;
        v14 = LayerN >= 0 == (LayerN != 0);
        goto lab_0x80a3ecd;
    } else {
        char v39 = *s; // 0x80a3c9b
        v9 = 0;
        v33 = 0;
        v14 = LayerN >= 0 == (LayerN != 0);
        if (LayerN < 1 || v39 == 0) {
            goto lab_0x80a3ecd;
        } else {
            // 0x80a3cb1
            v37 = LayerN + 1;
            char v40 = 0; // 0x80a3cc6
            char v41 = 0; // 0x80a3cc6
            int32_t v42 = 0; // 0x80a3cc6
            char v43 = v39; // 0x80a3cc6
            int32_t v44 = (int32_t)s; // 0x80a3cc6
            char v45; // 0x80a3c60
            bool v46; // 0x80a3c60
            char v47; // 0x80a3c60
            int32_t v48; // 0x80a3de1
            while (true) {
                // 0x80a3cd1
                v32 = v42;
                char v49 = v41;
                char v50 = v40;
                v38 = __ctype_b_loc();
                int32_t v51 = (int32_t)*v38; // 0x80a3cdf
                int32_t v52 = v44;
                int32_t v53 = v43;
                while ((*(char *)(v51 + 1 + 0x1000000 * v53 / 0x800000) & 32) != 0) {
                    int32_t v54 = v52 + 1; // 0x80a3ce8
                    char v55 = *(char *)v54; // 0x80a3ceb
                    v4 = v54;
                    v29 = v50;
                    v8 = v49;
                    v22 = 0;
                    if (v55 == 0) {
                        goto lab_0x80a3dd0_6;
                    }
                    v52 = v54;
                    v53 = v55;
                }
                // 0x80a3d0a
                v25 = v50;
                v5 = v49;
                v30 = LayerGroup + 64 + 72 * v32;
                v11 = v53;
                v23 = v51;
                v16 = v52;
                v21 = 0;
                while (true) {
                  lab_0x80a3d2e:;
                    int32_t v56 = v23;
                    v31 = v30;
                    v6 = v5;
                    v26 = v25;
                    v17 = v16;
                    int32_t v57 = v11;
                    v36 = *(int16_t *)(0x1000000 * v57 / 0x800000 + v56);
                    while ((v36 & 0x2000) != 0) {
                        int32_t v58 = v17 + 1; // 0x80a3d20
                        char * v59 = (char *)v58;
                        unsigned char v60 = *v59; // 0x80a3d23
                        int32_t v61 = v60; // 0x80a3d28
                        int32_t v62 = v58; // 0x80a3d28
                        if (v60 == 0) {
                            // 0x80a3e60
                            str = v59;
                            v18 = v58;
                            if ((*(int16_t *)v56 & 2048) != 0) {
                                goto lab_0x80a3d68;
                            } else {
                                // 0x80a3e6c
                                __asm_rep_stosd_memset(v1, 0, 304);
                                result = 1;
                                return result;
                            }
                        }
                        v17 = v62;
                        v57 = v61;
                        v36 = *(int16_t *)(0x1000000 * v57 / 0x800000 + v56);
                    }
                    char v63 = v57; // 0x80a3d3a
                    v27 = 1;
                    v12 = LayerN;
                    v19 = v17;
                    v35 = (v37 & (LayerN ^ -0x80000000)) < 0;
                    if (v63 == 83) {
                        goto lab_0x80a3d89;
                    } else {
                        if (v63 > 83) {
                            // 0x80a3e98
                            v28 = v26;
                            v7 = 1;
                            v13 = v37;
                            v20 = v17;
                            if (v63 == 99) {
                                goto lab_0x80a3d91;
                            } else {
                                // 0x80a3e9c
                                v27 = 1;
                                v12 = LayerN;
                                v19 = v17;
                                v35 = (v37 & (LayerN ^ -0x80000000)) < 0;
                                if (v63 != 115) {
                                    goto lab_0x80a3d56;
                                } else {
                                    goto lab_0x80a3d89;
                                }
                            }
                        } else {
                            // 0x80a3d48
                            v28 = v26;
                            v7 = 1;
                            v13 = v37;
                            v20 = v17;
                            if (v63 == 67) {
                                goto lab_0x80a3d91;
                            } else {
                                goto lab_0x80a3d56;
                            }
                        }
                    }
                }
              lab_0x80a3dd0_6:
                // 0x80a3dd0
                v45 = v8;
                v47 = v29;
                int32_t v64 = v4;
                *(int32_t *)(4 * v32 + LayerGroup) = v22;
                v48 = v32 + 1;
                v44 = v64 + (int32_t)(*(char *)v64 == 58);
                if (v44 == 0) {
                    // break -> 0x80a3f44
                    break;
                }
                // 0x80a3def
                v43 = *(char *)v44;
                int32_t v65 = LayerN - v48; // 0x80a3df2
                v40 = v47;
                v41 = v45;
                v42 = v48;
                v46 = v65 < 0 == ((v65 ^ LayerN) & (v48 ^ LayerN)) < 0 == (v65 != 0);
                if (v65 < 0 == ((v65 ^ LayerN) & (v48 ^ LayerN)) < 0 == (v65 != 0) != v43 != 0) {
                    goto lab_0x80a3e04;
                }
            }
            int32_t v66 = LayerN - v48; // 0x80a3f47
            v46 = v66 < 0 == ((v66 ^ LayerN) & (v48 ^ LayerN)) < 0 == (v66 != 0);
          lab_0x80a3e04:
            // 0x80a3e04
            v10 = v45;
            v34 = v48;
            v15 = v46;
            v24 = 1;
            if (v47 != 0) {
                goto lab_0x80a3ee3;
            } else {
                int32_t v67 = LayerN - v48; // 0x80a3e16
                v9 = v45;
                v33 = v48;
                v14 = v67 < 0 == ((v67 ^ LayerN) & (v48 ^ LayerN)) < 0 == (v67 != 0);
                goto lab_0x80a3ecd;
            }
        }
    }
  lab_0x80a3d89:
    // 0x80a3d89
    v28 = v27;
    v7 = v6;
    v13 = v12;
    v20 = v19;
    if (v35) {
        // 0x80a3e6c
        __asm_rep_stosd_memset(v1, 0, 304);
        result = 1;
        return result;
    }
    goto lab_0x80a3d91;
  lab_0x80a3d91:
    if (v21 > LayerN) {
        // 0x80a3e6c
        __asm_rep_stosd_memset(v1, 0, 304);
        result = 1;
        goto lab_0x80a3e7a;
    }
    char v68 = v7;
    char v69 = v28;
    int32_t v70 = v20 + 1; // 0x80a3d9d
    int32_t v71 = v21 + 1; // 0x80a3da0
    *(int32_t *)(4 * v13 + v3) = v32;
    *(int32_t *)v31 = v13;
    char v72 = *(char *)v70; // 0x80a3dac
    v4 = v70;
    v29 = v69;
    v8 = v68;
    v22 = v71;
    if (v72 == 0) {
        // break -> 0x80a3dd0
        goto lab_0x80a3dd0_6;
    }
    int32_t v73 = (int32_t)*v38;
    int32_t v74 = v70;
    char v75 = v72;
    int16_t v76 = *(int16_t *)(0x1000000 * (int32_t)v75 / 0x800000 + v73); // 0x80a3dbd
    while ((v76 & 2048) != 0) {
        int32_t v77 = v74 + 1; // 0x80a3dc6
        char v78 = *(char *)v77; // 0x80a3dc9
        char v79 = v78; // 0x80a3dce
        int32_t v80 = v77; // 0x80a3dce
        v4 = v77;
        v29 = v69;
        v8 = v68;
        v22 = v71;
        if (v78 == 0) {
            // break (via goto) -> 0x80a3dd0
            goto lab_0x80a3dd0_6;
        }
        v74 = v80;
        v75 = v79;
        v76 = *(int16_t *)(0x1000000 * (int32_t)v75 / 0x800000 + v73);
    }
    int32_t v81 = v74; // 0x80a3e3c
    char v82 = v75; // 0x80a3e3c
    int32_t v83 = v74; // 0x80a3e3c
    if ((v76 & 0x2000) != 0) {
        int32_t v84 = v81 + 1; // 0x80a3e28
        unsigned char v85 = *(char *)v84; // 0x80a3e2b
        v4 = v84;
        v29 = v69;
        v8 = v68;
        v22 = v71;
        if (v85 == 0) {
            // break (via goto) -> 0x80a3dd0
            goto lab_0x80a3dd0_6;
        }
        // 0x80a3e32
        v81 = v84;
        v82 = v85;
        v83 = v84;
        while ((*(int16_t *)(0x1000000 * (int32_t)v85 / 0x800000 + v73) & 0x2000) != 0) {
            // 0x80a3e28
            v84 = v81 + 1;
            v85 = *(char *)v84;
            v4 = v84;
            v29 = v69;
            v8 = v68;
            v22 = v71;
            if (v85 == 0) {
                // break (via goto) -> 0x80a3dd0
                goto lab_0x80a3dd0_6;
            }
            // 0x80a3e32
            v81 = v84;
            v82 = v85;
            v83 = v84;
        }
    }
    int32_t v86 = v83;
    char v87 = v82;
    v4 = v86;
    v29 = v69;
    v8 = v68;
    v22 = v71;
    if (v87 == 58) {
        // break -> 0x80a3dd0
        goto lab_0x80a3dd0_6;
    }
    if (v87 != 44) {
        // 0x80a3e6c
        __asm_rep_stosd_memset(v1, 0, 304);
        result = 1;
        goto lab_0x80a3e7a;
    }
    int32_t v88 = v86 + 1; // 0x80a3e46
    unsigned char v89 = *(char *)v88; // 0x80a3e49
    v25 = v69;
    v5 = v68;
    v30 = v31 + 4;
    v11 = v89;
    v23 = v73;
    v16 = v88;
    v21 = v71;
    v4 = v88;
    v29 = v69;
    v8 = v68;
    v22 = v71;
    if (v89 == 0) {
        // break -> 0x80a3dd0
        goto lab_0x80a3dd0_6;
    }
    goto lab_0x80a3d2e;
  lab_0x80a3d56:
    if ((v36 & 2048) == 0) {
        // 0x80a3e6c
        __asm_rep_stosd_memset(v1, 0, 304);
        result = 1;
        goto lab_0x80a3e7a;
    }
    // 0x80a3d56
    str = (char *)v17;
    v18 = v17;
    goto lab_0x80a3d68;
  lab_0x80a3d68:;
    int32_t v90 = strtol(str, NULL, 10) - 1; // 0x80a3d80
    int32_t v91 = v90 - v37; // 0x80a3d83
    v27 = v26;
    v12 = v90;
    v19 = v18;
    v35 = v91 < 0 == ((v91 ^ v90) & (v90 ^ v37)) < 0 == (v91 != 0);
    goto lab_0x80a3d89;
  lab_0x80a3ecd:;
    int32_t * v92 = (int32_t *)LayerGroup; // 0x80a3ed3
    int32_t v93 = *v92; // 0x80a3ed3
    *(int32_t *)(LayerGroup + 64 + 4 * v93) = LayerN;
    *v92 = v93 + 1;
    v10 = v9;
    v34 = v33;
    v15 = v14;
    v24 = LayerN >= 0 == (LayerN != 0);
    goto lab_0x80a3ee3;
  lab_0x80a3ee3:
    // 0x80a3ee3
    if (v10 == 0) {
        int32_t * v94 = (int32_t *)(LayerGroup + 4); // 0x80a3eef
        int32_t v95 = *v94; // 0x80a3eef
        *(int32_t *)(LayerGroup + 136 + 4 * v95) = LayerN + 1;
        *v94 = v95 + 1;
    }
    // 0x80a3f02
    if (!v15 || v24 == 0) {
        // 0x80a3e7a
        return 0;
    }
    int32_t v96 = 0;
    int32_t v97 = v34; // 0x80a3f28
    if (*(int32_t *)(4 * v96 + v3) == -1) {
        // 0x80a3f2a
        *(int32_t *)(4 * v34 + LayerGroup) = 1;
        *(int32_t *)(LayerGroup + 64 + 72 * v34) = v96;
        v97 = v34 + 1;
    }
    int32_t v98 = v96 + 1; // 0x80a3f18
    result = 0;
    while (v98 < LayerN == v97 < LayerN) {
        int32_t v99 = v97;
        v96 = v98;
        v97 = v99;
        if (*(int32_t *)(4 * v96 + v3) == -1) {
            // 0x80a3f2a
            *(int32_t *)(4 * v99 + LayerGroup) = 1;
            *(int32_t *)(LayerGroup + 64 + 72 * v99) = v96;
            v97 = v99 + 1;
        }
        // 0x80a3f18
        v98 = v96 + 1;
        result = 0;
    }
  lab_0x80a3e7a:
    // 0x80a3e7a
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a3f60 - 0x80a3fae
// Line range:    690 - 695
void GetNum(char ** s, int32_t * num) {
    // 0x80a3f60
    int32_t str; // 0x80a3f60
    *(int32_t *)str = strtol((char *)str, NULL, 10);
    int16_t ** v1 = __ctype_b_loc(); // 0x80a3f88
    int32_t v2 = (int32_t)*v1;
    int32_t v3 = v2 + 1; // 0x80a3fa0
    if ((*(char *)(0x1000000 * v2 / 0x800000 + v3) & 8) == 0) {
        // 0x80a3fa7
        return;
    }
    int32_t v4 = (int32_t)v1;
    v4++;
    *(int32_t *)str = v4;
    while ((*(char *)(2 * (int32_t)*(char *)v4 + v3) & 8) != 0) {
        // 0x80a3f98
        v4++;
        *(int32_t *)str = v4;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a3fb0 - 0x80a3ff6
// Line range:    1471 - 1475
void RightAngles(int32_t Angle, float32_t * cosa, float32_t * sina) {
    // 0x80a3fb0
    int32_t v1; // 0x80a3fb0
    function_8060d88(0.0174532925199432954744L * (float80_t)v1);
    float64_t v2; // 0x80a3fb0
    *(float32_t *)v1 = (float32_t)v2;
    *(float32_t *)v1 = (float32_t)v2;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a4000 - 0x80a40b0
// Line range:    1478 - 1490
int32_t GetArcEnds(int32_t Arc) {
    // 0x80a4000
    int32_t v1; // 0x80a4000
    RightAngles(v1, (float32_t *)v1, (float32_t *)v1);
    int32_t * v2 = (int32_t *)(Arc + 52); // 0x80a4022
    int32_t v3 = *v2; // 0x80a4022
    int32_t * v4 = (int32_t *)(Arc + 44); // 0x80a4025
    int32_t v5 = *v4; // 0x80a4025
    float32_t v6; // 0x80a4000
    float80_t v7 = v6; // 0x80a4028
    g68 = (float80_t)v3 - v7 * (float80_t)v5;
    int32_t * v8 = (int32_t *)(Arc + 56); // 0x80a404c
    int32_t v9 = *v8; // 0x80a404c
    int32_t * v10 = (int32_t *)(Arc + 48); // 0x80a404f
    int32_t v11 = *v10; // 0x80a404f
    float80_t v12 = v6; // 0x80a4052
    g69 = v12 * (float80_t)v11 + (float80_t)v9;
    int16_t v13; // 0x80a4000
    RightAngles((int32_t)(v13 % 256 | 3072), (float32_t *)&g231, (float32_t *)&g231);
    int32_t v14 = *v2; // 0x80a4068
    int32_t v15 = *v4; // 0x80a406b
    g70 = (float80_t)v14 - v7 * (float80_t)v15;
    int32_t v16 = *v8; // 0x80a4091
    int32_t v17 = *v10; // 0x80a4094
    g71 = v12 * (float80_t)v17 + (float80_t)v16;
    return &g68;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a40b0 - 0x80a440b
// Line range:    1246 - 1283
void SetArcBoundingBox(int32_t Arc) {
    int32_t * v1 = (int32_t *)(Arc + 64); // 0x80a40bc
    int32_t v2 = *v1; // 0x80a40bc
    int32_t v3 = *(int32_t *)(Arc + 60);
    int32_t v4; // 0x80a40b0
    int32_t v5; // 0x80a40b0
    int32_t v6; // 0x80a40b0
    int32_t v7; // 0x80a40b0
    int32_t v8; // 0x80a40b0
    if (v2 < 361) {
        int32_t v9 = v3 + v2; // 0x80a42c5
        v6 = v9;
        if (v2 >= 0) {
            goto lab_0x80a40da;
        } else {
            // 0x80a42ce
            v7 = v3;
            v4 = v9;
            v8 = v3;
            v5 = v9;
            if (v9 >= 0) {
                goto lab_0x80a40e2;
            } else {
                goto lab_0x80a42dc;
            }
        }
    } else {
        // 0x80a40ca
        *v1 = 360;
        v6 = v3 + 360;
        goto lab_0x80a40da;
    }
  lab_0x80a40da:
    // 0x80a40da
    v7 = v6;
    v4 = v3;
    v8 = v6;
    v5 = v3;
    if (v3 < 0) {
        goto lab_0x80a42dc;
    } else {
        goto lab_0x80a40e2;
    }
  lab_0x80a42dc:;
    int32_t v10 = v5 + 360; // 0x80a42dc
    int32_t v11 = v8 + 360; // 0x80a42e2
    int32_t v12 = 90; // 0x80a42eb
    int32_t v13 = v10; // 0x80a42eb
    int32_t v14 = v11; // 0x80a42eb
    int32_t v15 = v10; // 0x80a42eb
    int32_t v16 = v11; // 0x80a42eb
    int32_t v17 = v10; // 0x80a42eb
    if (v5 != -270) {
        goto lab_0x80a40eb;
    } else {
        goto lab_0x80a42f1;
    }
  lab_0x80a40e2:
    // 0x80a40e2
    v14 = v7;
    v15 = v4;
    v16 = v7;
    v17 = 90;
    if (v4 == 90) {
        goto lab_0x80a42f1;
    } else {
        goto lab_0x80a40eb;
    }
  lab_0x80a40eb:;
    // 0x80a40eb
    float80_t v18; // 0x80a40b0
    float80_t v19; // 0x80a40b0
    if (v13 > v12) {
        // 0x80a40f1
        v18 = 0.0L;
        v19 = -1.0L;
        switch (v15) {
            case 180: {
                // 0x80a4400
                v18 = -1.0L;
                v19 = 0.0L;
                goto lab_0x80a4136;
            }
            case 270: {
                goto lab_0x80a4136;
            }
            default: {
                goto lab_0x80a410e;
            }
        }
    } else {
        // 0x80a4340
        v18 = 1.0L;
        v19 = 0.0L;
        if (v15 != 0) {
            goto lab_0x80a410e;
        } else {
            goto lab_0x80a4136;
        }
    }
  lab_0x80a42f1:;
    int32_t v20 = v16; // 0x80a42f8
    int32_t v21 = 90; // 0x80a42f8
    float80_t v22 = 0.0L; // 0x80a42f8
    float80_t v23 = 1.0L; // 0x80a42f8
    int32_t v24 = v16; // 0x80a42f8
    int32_t v25 = v17; // 0x80a42f8
    float80_t v26 = 0.0L; // 0x80a42f8
    float80_t v27 = 1.0L; // 0x80a42f8
    int32_t v28 = v16; // 0x80a42f8
    int32_t v29 = v17; // 0x80a42f8
    if (v16 != 90) {
        goto lab_0x80a413f;
    } else {
        goto lab_0x80a42fe;
    }
  lab_0x80a413f:;
    // 0x80a413f
    float80_t v30; // 0x80a40b0
    float80_t v31; // 0x80a40b0
    if (v20 > v21) {
        // 0x80a43c0
        v30 = -1.0L;
        v31 = 0.0L;
        if (v24 == 180) {
            goto lab_0x80a4183;
        } else {
            // 0x80a43c8
            v30 = 0.0L;
            v31 = -1.0L;
            if (v24 != 270) {
                goto lab_0x80a414d;
            } else {
                goto lab_0x80a4183;
            }
        }
    } else {
        // 0x80a4145
        v30 = 1.0L;
        v31 = 0.0L;
        if (v24 == 0) {
            goto lab_0x80a4183;
        } else {
            goto lab_0x80a414d;
        }
    }
  lab_0x80a42fe:;
    int32_t v32 = *(int32_t *)(Arc + 52); // 0x80a4306
    int32_t v33 = *(int32_t *)(Arc + 44); // 0x80a430b
    float80_t v34 = v27; // 0x80a430e
    float80_t v35 = v26; // 0x80a430e
    float80_t v36 = 0.0L; // 0x80a430e
    float80_t v37 = 1.0L; // 0x80a430e
    int32_t v38 = v33; // 0x80a430e
    int32_t v39 = v32; // 0x80a430e
    int32_t v40 = v28; // 0x80a430e
    int32_t v41 = v29; // 0x80a430e
    float80_t v42 = 0.0L; // 0x80a430e
    float80_t v43 = v26; // 0x80a430e
    float80_t v44 = v27; // 0x80a430e
    float80_t v45 = 1.0L; // 0x80a430e
    int32_t v46 = v33; // 0x80a430e
    int32_t v47 = v32; // 0x80a430e
    int32_t v48 = v28; // 0x80a430e
    int32_t v49 = v29; // 0x80a430e
    if (v28 > 180) {
        goto lab_0x80a419e;
    } else {
        goto lab_0x80a432a;
    }
  lab_0x80a4136:
    // 0x80a4136
    v22 = v18;
    v23 = v19;
    v24 = v14;
    v25 = v15;
    v26 = v18;
    v27 = v19;
    v28 = 90;
    v29 = v15;
    if (v14 == 90) {
        goto lab_0x80a42fe;
    } else {
        goto lab_0x80a413f;
    }
  lab_0x80a410e:
    // 0x80a410e
    function_8060d88(0.0174532925199432954744L * (float80_t)v15);
    float64_t v50; // 0x80a40b0
    v18 = v50;
    v19 = v50;
    goto lab_0x80a4136;
  lab_0x80a419e:;
    float80_t v51 = -1.0L; // 0x80a41a4
    float80_t v52 = v34; // 0x80a41a4
    float80_t v53 = v35; // 0x80a41a4
    float80_t v54 = v36; // 0x80a41a4
    float80_t v55 = v37; // 0x80a41a4
    int32_t v56 = v38; // 0x80a41a4
    int32_t v57 = v39; // 0x80a41a4
    int32_t v58 = v40; // 0x80a41a4
    int32_t v59 = v41; // 0x80a41a4
    v42 = v36;
    v43 = v35;
    v44 = v34;
    v45 = v37;
    v46 = v38;
    v47 = v39;
    v48 = v40;
    v49 = v41;
    if (v41 > 179) {
        goto lab_0x80a432a;
    } else {
        goto lab_0x80a41ae;
    }
  lab_0x80a432a:;
    bool v60 = false; // 0x80a432a
    bool v61 = false; // 0x80a432a
    if (v42 <= v43) {
        v60 = true;
        v61 = false;
        if (v42 >= v43) {
            v60 = v42 != v43;
            v61 = true;
        }
    }
    v51 = v60 | v61 ? v42 : v43;
    v52 = v44;
    v53 = v43;
    v54 = v42;
    v55 = v45;
    v56 = v46;
    v57 = v47;
    v58 = v48;
    v59 = v49;
    goto lab_0x80a41ae;
  lab_0x80a4183:;
    int32_t v84 = *(int32_t *)(Arc + 52); // 0x80a4189
    int32_t v85 = *(int32_t *)(Arc + 44); // 0x80a418c
    v34 = v23;
    v35 = v22;
    v36 = v30;
    v37 = v31;
    v38 = v85;
    v39 = v84;
    v40 = v24;
    v41 = v25;
    v42 = v30;
    v43 = v22;
    v44 = v23;
    v45 = v31;
    v46 = v85;
    v47 = v84;
    v48 = v24;
    v49 = v25;
    if (v24 < 181) {
        goto lab_0x80a432a;
    } else {
        goto lab_0x80a419e;
    }
  lab_0x80a414d:
    // 0x80a414d
    function_8060d88(0.0174532925199432954744L * (float80_t)v24);
    v30 = v50;
    v31 = v50;
    goto lab_0x80a4183;
  lab_0x80a41ae:;
    float80_t v62 = v57; // 0x80a41b7
    float80_t v63 = v56; // 0x80a41c0
    int32_t v64 = v62 - v51 * v63; // 0x80a41d4
    int32_t * v65 = (int32_t *)(Arc + 8); // 0x80a41dd
    *v65 = v64;
    float80_t v66 = 1.0L; // 0x80a41e0
    if (v58 < 361 || v59 > 359) {
        bool v67 = false; // 0x80a4392
        bool v68 = false; // 0x80a4392
        if (v53 <= v54) {
            v67 = true;
            v68 = false;
            if (v53 >= v54) {
                v67 = v53 != v54;
                v68 = true;
            }
        }
        v66 = v67 | v68 ? v54 : v53;
    }
    int32_t v69 = v62 - v66 * v63; // 0x80a4214
    int32_t * v70 = (int32_t *)Arc; // 0x80a421d
    *v70 = v69;
    float80_t v71 = 1.0L; // 0x80a421f
    if (v58 < 91 || v59 > 89) {
        bool v72 = false; // 0x80a4378
        bool v73 = false; // 0x80a4378
        if (v52 <= v55) {
            v72 = true;
            v73 = false;
            if (v52 >= v55) {
                v72 = v52 != v55;
                v73 = true;
            }
        }
        v71 = v72 | v73 ? v55 : v52;
    }
    float80_t v74 = (float80_t)*(int32_t *)(Arc + 56); // 0x80a4239
    float80_t v75 = (float80_t)*(int32_t *)(Arc + 48); // 0x80a423f
    int32_t v76 = v71 * v75 + v74; // 0x80a4249
    int32_t * v77 = (int32_t *)(Arc + 12); // 0x80a4252
    *v77 = v76;
    float80_t v78 = -1.0L; // 0x80a4255
    if (v58 < 271 || v59 > 269) {
        bool v79 = false; // 0x80a4262
        bool v80 = false; // 0x80a4262
        if (v55 <= v52) {
            v79 = true;
            v80 = false;
            if (v55 >= v52) {
                v79 = v55 != v52;
                v80 = true;
            }
        }
        v78 = v79 | v80 ? v55 : v52;
    }
    int32_t v81 = *(int32_t *)(Arc + 36) + *(int32_t *)(Arc + 40); // 0x80a4287
    int32_t v82 = (v81 + (int32_t)(v81 < 0)) / 2; // 0x80a4295
    *v70 = v69 - v82;
    int32_t v83 = v82 + 1; // 0x80a42a0
    *(int32_t *)(Arc + 4) = (int32_t)(v78 * v75 + v74) - v82;
    *v65 = v83 + v64;
    *v77 = v83 + v76;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a44e0 - 0x80a454d
// Line range:    1456 - 1466
void CreateQuotedString(int32_t DS, char * S) {
    // 0x80a44e0
    DSClearString(DS);
    int32_t v1 = (int32_t)S; // 0x80a44fe
    char v2 = 34; // 0x80a44fe
    while (true) {
        // 0x80a450e
        DSAddCharacter(DS, v2);
        char * v3 = (char *)v1; // 0x80a4516
        char v4 = *v3; // 0x80a4516
        v2 = v4;
        switch (v4) {
            case 0: {
                // 0x80a4538
                DSAddCharacter(DS, 34);
                return;
            }
            case 92: {
            }
            case 34: {
                // 0x80a4521
                DSAddCharacter(DS, 92);
                v2 = *v3;
                // break -> 0x80a4504
                break;
            }
        }
        // 0x80a4504
        v1++;
    }
    // 0x80a4538
    DSAddCharacter(DS, 34);
    return;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a4550 - 0x80a456b
// Line range:    1440 - 1449
char * GetWorkingDirectory(char * path) {
    // 0x80a4550
    return getcwd(path, 0x1000);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a4b70 - 0x80a4db4
// Line range:    1035 - 105
int32_t ChangeGroupVisibility(int32_t Layer2, char On, char ChangeStackOrder) {
    // 0x80a4b70
    if (g108 != 0) {
        // 0x80a4d88
        __printf_chk(1, "ChangeGroupVisibility(Layer=%d, On=%d, ChangeStackOrder=%d)\n", Layer2, (int32_t)On, (int32_t)ChangeStackOrder);
    }
    int32_t v1 = *(int32_t *)(PCB + 0x220c); // 0x80a4b9e
    int32_t v2 = *(int32_t *)(v1 + 24); // 0x80a4ba7
    int32_t v3; // 0x80a4b70
    int32_t v4; // 0x80a4bc8
    uint32_t v5; // 0x80a4bcb
    if (v2 != Layer2 && v2 >= 1) {
        // 0x80a4bc5
        v4 = 0x1000000 * PCB / 0x1000000;
        char v6 = PCB;
        v3 = 0;
        v5 = *(int32_t *)(v4 + 0x1cd4 + 4 * v3);
        int32_t v7; // 0x80a4b70
        int32_t v8; // 0x80a4b70
        int32_t v9; // 0x80a4c05
        if (v5 != 0) {
            // 0x80a4bd6
            if (*(int32_t *)((int32_t)v6 + 0x1d14) == Layer2) {
                goto lab_0x80a4cb8_2;
            }
            // 0x80a4be5
            v9 = 0;
            v7 = v4 + 0x1d18 + 72 * v3;
            v9++;
            while (v5 > v9) {
                // 0x80a4bf8
                v8 = v7;
                v7 = v8 + 4;
                if (*(int32_t *)v8 == Layer2) {
                    goto lab_0x80a4cb8_2;
                }
                v9++;
            }
        }
        int32_t v10 = v3 + 1; // 0x80a4c0c
        char v11 = v6 + 72; // 0x80a4c1a
        while (v2 > v10) {
            // 0x80a4bc5
            v6 = v11;
            v3 = v10;
            v5 = *(int32_t *)(v4 + 0x1cd4 + 4 * v3);
            if (v5 != 0) {
                // 0x80a4bd6
                if (*(int32_t *)((int32_t)v6 + 0x1d14) == Layer2) {
                    goto lab_0x80a4cb8_2;
                }
                // 0x80a4be5
                v9 = 0;
                v7 = v4 + 0x1d18 + 72 * v3;
                v9++;
                while (v5 > v9) {
                    // 0x80a4bf8
                    v8 = v7;
                    v7 = v8 + 4;
                    if (*(int32_t *)v8 == Layer2) {
                        goto lab_0x80a4cb8_2;
                    }
                    v9++;
                }
            }
            // 0x80a4c0c
            v10 = v3 + 1;
            v11 = v6 + 72;
        }
    }
    goto lab_0x80a4c20;
  lab_0x80a4cb8_2:;
    int32_t v21; // 0x80a4b70
    int32_t v30; // 0x80a4b70
    int32_t v19; // 0x80a4b70
    int32_t v23; // 0x80a4b70
    if (v2 > v3) {
        // 0x80a4cc4
        v21 = 1;
        v30 = v5;
        v23 = v4 + 4 + 4 * (18 * v3 + 1859 + v5);
        v19 = v1;
        goto lab_0x80a4d0c;
    } else {
        goto lab_0x80a4c20;
    }
  lab_0x80a4c20:;
    int32_t result = 1; // 0x80a4c36
    int32_t v12 = v1; // 0x80a4c36
    goto lab_0x80a4c39;
  lab_0x80a4c39:
    // 0x80a4c39
    *(char *)(92 * Layer2 + 144 + v12) = On;
    if (On == 0 || ChangeStackOrder == 0) {
        // 0x80a4c9d
        hid_action("LayersChanged");
        return result;
    }
    uint32_t v13 = *(int32_t *)(*(int32_t *)(0x1000000 * PCB / 0x1000000 + 0x220c) + 24); // 0x80a4c56
    if (v13 <= Layer2) {
        // 0x80a4c9d
        hid_action("LayersChanged");
        return result;
    }
    if (v13 < 1) {
        // 0x80a4c97
        LayerStack[0] = Layer2;
        // 0x80a4c9d
        hid_action("LayersChanged");
        return result;
    }
    // 0x80a4c61
    if (LayerStack[0] == Layer2) {
        // 0x80a4c97
        LayerStack[0] = Layer2;
        // 0x80a4c9d
        hid_action("LayersChanged");
        return result;
    }
    int32_t v14 = 1; // 0x80a4c79
    int32_t v15 = 4 * v14 + (int32_t)&LayerStack;
    while (v13 > v14) {
        // 0x80a4c70
        if (*(int32_t *)v15 == Layer2) {
            // break -> 0x80a4c80
            break;
        }
        v14++;
        v15 = 4 * v14 + (int32_t)&LayerStack;
    }
    int32_t v16 = v15 - 4; // 0x80a4c88
    *(int32_t *)v15 = *(int32_t *)v16;
    int32_t v17 = v16; // 0x80a4c95
    while (v16 != (int32_t)&LayerStack) {
        // 0x80a4c88
        v16 = v17 - 4;
        *(int32_t *)v17 = *(int32_t *)v16;
        v17 = v16;
    }
    // 0x80a4c97
    LayerStack[0] = Layer2;
    // 0x80a4c9d
    hid_action("LayersChanged");
    return result;
  lab_0x80a4d0c:;
    int32_t v18 = v19;
    int32_t v20 = v21;
    int32_t v22 = *(int32_t *)v23; // 0x80a4d0c
    int32_t v24 = v20; // 0x80a4d14
    int32_t v25 = v18; // 0x80a4d14
    int32_t v26; // 0x80a4b70
    int32_t v27; // 0x80a4b70
    int32_t v28; // 0x80a4d38
    if (v22 == Layer2) {
        goto lab_0x80a4d05;
    } else {
        // 0x80a4d16
        v24 = v20;
        v25 = v18;
        if (v22 < *(int32_t *)(v18 + 24)) {
            // 0x80a4d1b
            *(char *)(v18 + 144 + 92 * v22) = On;
            v27 = *(int32_t *)(v4 + 0x220c);
            if (On == 0 || ChangeStackOrder == 0) {
                // 0x80a4d01
                v24 = v20 + 1;
                v25 = v27;
                goto lab_0x80a4d05;
            } else {
                // 0x80a4d2f
                v28 = *(int32_t *)(v27 + 24);
                if (v22 < v28) {
                    if (v28 < 1) {
                        goto lab_0x80a4d77;
                    } else {
                        // 0x80a4d43
                        v26 = 0;
                        if (v22 != LayerStack[0]) {
                            goto lab_0x80a4d59;
                        } else {
                            goto lab_0x80a4d77;
                        }
                    }
                } else {
                    // 0x80a4d01
                    v24 = v20 + 1;
                    v25 = v27;
                    goto lab_0x80a4d05;
                }
            }
        } else {
            goto lab_0x80a4d05;
        }
    }
  lab_0x80a4d05:;
    int32_t v29 = v30 - 1; // 0x80a4d0e
    result = v24;
    v12 = v25;
    v21 = v24;
    v30 = v29;
    v23 -= 4;
    v19 = v25;
    if (v29 == 0) {
        goto lab_0x80a4c39;
    } else {
        goto lab_0x80a4d0c;
    }
  lab_0x80a4d77:
    // 0x80a4d77
    LayerStack[0] = v22;
    // 0x80a4d01
    v24 = v20 + 1;
    v25 = v27;
    goto lab_0x80a4d05;
  lab_0x80a4d59:;
    int32_t v31 = v26 + 1; // 0x80a4d59
    int32_t v32 = 4 * v31 + (int32_t)&LayerStack;
    int32_t v33; // 0x80a4b70
    if (v28 > v31) {
        // 0x80a4d50
        v26 = v31;
        if (v22 == *(int32_t *)v32) {
            // 0x80a4d60
            v33 = v32;
            goto lab_0x80a4d68;
        } else {
            goto lab_0x80a4d59;
        }
    } else {
        // 0x80a4d60
        v33 = v32;
        goto lab_0x80a4d68;
    }
  lab_0x80a4d68:;
    int32_t v34 = v33 - 4; // 0x80a4d68
    *(int32_t *)v33 = *(int32_t *)v34;
    v33 = v34;
    if (v34 != (int32_t)&LayerStack) {
        goto lab_0x80a4d68;
    } else {
        goto lab_0x80a4d77;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a4dc0 - 0x80a4ec6
// Line range:    1341 - 1203
void ResetStackAndVisibility(void) {
    int32_t * v1 = (int32_t *)(PCB + 0x220c); // 0x80a4dcf
    int32_t v2 = *v1; // 0x80a4dcf
    int32_t * v3 = (int32_t *)(v2 + 24);
    uint32_t v4 = *v3; // 0x80a4dd5
    int32_t * v5 = v3; // 0x80a4ddb
    if (v4 != -2) {
        int32_t v6 = v2; // 0x80a4dc0
        uint32_t v7 = 0;
        if (v4 > v7) {
            // 0x80a4dec
            *(int32_t *)(4 * v7 + (int32_t)&LayerStack) = v7;
        }
        // 0x80a4df3
        *(char *)(v6 + 144) = 1;
        int32_t v8 = v7 + 1; // 0x80a4e02
        v6 += 92;
        while (v7 != v4 + 1) {
            // 0x80a4de8
            v7 = v8;
            if (v4 > v7) {
                // 0x80a4dec
                *(int32_t *)(4 * v7 + (int32_t)&LayerStack) = v7;
            }
            // 0x80a4df3
            *(char *)(v6 + 144) = 1;
            v8 = v7 + 1;
            v6 += 92;
        }
        // 0x80a4e04
        v5 = (int32_t *)(*v1 + 24);
    }
    // 0x80a4e0a
    *(char *)(PCB + 35) = 1;
    *(char *)(PCB + 37) = 1;
    *(char *)(PCB + 38) = 1;
    *(char *)(PCB + 34) = 1;
    *(char *)(PCB + 36) = 1;
    uint32_t v9 = *v5; // 0x80a4e1e
    if (v9 < 1) {
        // 0x80a4e98
        ChangeGroupVisibility(*(int32_t *)(PCB + 0x1d14), 1, 1);
        return;
    }
    int32_t v10 = v9 + 1; // 0x80a4e2d
    int32_t v11 = 0;
    char v12 = PCB;
    uint32_t v13 = *(int32_t *)(PCB + 0x1cd4 + 4 * v11); // 0x80a4e3e
    int32_t v14; // 0x80a4dc0
    int32_t v15; // 0x80a4dc0
    int32_t v16; // 0x80a4dc0
    int32_t v17; // 0x80a4e4c
    int32_t v18; // 0x80a4e71
    if (v13 != 0) {
        // 0x80a4e49
        v17 = *(int32_t *)((int32_t)v12 + 0x1d14);
        if (v10 == v17) {
            // 0x80a4e98
            ChangeGroupVisibility(v10, 1, 1);
            return;
        }
        // 0x80a4e59
        v18 = 0;
        v14 = PCB + 0x1d18 + 72 * v11;
        v18++;
        while (v13 > v18) {
            // 0x80a4e68
            v15 = v14;
            v14 = v15 + 4;
            v16 = v17;
            if (v10 == *(int32_t *)v15) {
                // 0x80a4e98
                ChangeGroupVisibility(v16, 1, 1);
                return;
            }
            v18++;
        }
    }
    int32_t v19 = v11 + 1; // 0x80a4e78
    char v20 = v12 + 72; // 0x80a4e86
    while (v9 > v19) {
        // 0x80a4e3b
        v11 = v19;
        v12 = v20;
        v13 = *(int32_t *)(PCB + 0x1cd4 + 4 * v11);
        if (v13 != 0) {
            // 0x80a4e49
            v17 = *(int32_t *)((int32_t)v12 + 0x1d14);
            if (v10 == v17) {
                // 0x80a4e98
                ChangeGroupVisibility(v10, 1, 1);
                return;
            }
            // 0x80a4e59
            v18 = 0;
            v14 = PCB + 0x1d18 + 72 * v11;
            v18++;
            while (v13 > v18) {
                // 0x80a4e68
                v15 = v14;
                v14 = v15 + 4;
                v16 = v17;
                if (v10 == *(int32_t *)v15) {
                    // 0x80a4e98
                    ChangeGroupVisibility(v16, 1, 1);
                    return;
                }
                v18++;
            }
        }
        // 0x80a4e78
        v19 = v11 + 1;
        v20 = v12 + 72;
    }
    // 0x80a4e98
    ChangeGroupVisibility(*(int32_t *)(PCB + 0x1d14 + 72 * v19), 1, 1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a4ed0 - 0x80a5225
// Line range:    1081 - 1140
void LayerStringToLayerStack(char * s) {
    uint32_t len = strlen(s); // 0x80a4edf
    char * v1 = __strdup(s); // 0x80a4eee
    int32_t mem = (int32_t)calloc(1, 4 * len); // 0x80a4f07
    int32_t v2 = -1; // 0x80a4f11
    if (len >= 1) {
        int32_t v3 = 0; // 0x80a4f1e
        int32_t v4 = 0;
        int32_t v5 = (int32_t)v1;
        char * v6 = (char *)v5; // 0x80a4f20
        char v7 = *v6; // 0x80a4f20
        g229 = v7 - 9;
        int32_t v8; // 0x80a4ed0
        int32_t v9; // 0x80a4ed0
        switch (v7) {
            case 9: {
            }
            case 32: {
            }
            case 44: {
            }
            case 58: {
            }
            case 59: {
                // 0x80a4f40
                *v6 = 0;
                v8 = v4;
                v9 = 1;
                // break -> 0x80a4f48
                break;
            }
            default: {
                // 0x80a5020
                v8 = v4;
                v9 = 0;
                // 0x80a5028
                *(int32_t *)(4 * v4 + mem) = v5;
                v8 = v4 + 1;
                v9 = 0;
                // break -> 0x80a4f48
                break;
            }
        }
        int32_t v10 = v8;
        v3++;
        int32_t v11 = v5 + 1; // 0x80a4f50
        int32_t v12 = v9; // 0x80a4f50
        while (len != v3) {
            // 0x80a4f20
            v4 = v10;
            v5 = v11;
            v6 = (char *)v5;
            v7 = *v6;
            g229 = v7 - 9;
            switch (v7) {
                case 9: {
                }
                case 32: {
                }
                case 44: {
                }
                case 58: {
                }
                case 59: {
                    // 0x80a4f40
                    *v6 = 0;
                    v8 = v4;
                    v9 = 1;
                    // break -> 0x80a4f48
                    break;
                }
                default: {
                    // 0x80a5020
                    v8 = v4;
                    v9 = 0;
                    if (v12 != 0) {
                        // 0x80a5028
                        *(int32_t *)(4 * v4 + mem) = v5;
                        v8 = v4 + 1;
                        v9 = 0;
                    }
                    // break -> 0x80a4f48
                    break;
                }
            }
            // 0x80a4f48
            v10 = v8;
            v3++;
            v11 = v5 + 1;
            v12 = v9;
        }
        // 0x80a4f52
        v2 = v10 - 1;
    }
    int32_t * v13 = (int32_t *)(PCB + 0x220c); // 0x80a4f5b
    int32_t v14 = *v13; // 0x80a4f5b
    uint32_t v15 = *(int32_t *)(v14 + 24); // 0x80a4f61
    if (v15 >= 0xffffffff) {
        int32_t v16 = 0;
        if (v16 < v15) {
            // 0x80a4f74
            *(int32_t *)(4 * v16 + (int32_t)&LayerStack) = v16;
        }
        int32_t v17 = v16 + 1; // 0x80a4f7e
        *(char *)(v14 + 144 + 92 * v16) = 0;
        int32_t v18 = *v13; // 0x80a4f89
        int32_t v19 = *(int32_t *)(v18 + 24); // 0x80a4f8f
        while (v19 + 1 >= v17) {
            // 0x80a4f70
            v16 = v17;
            if (v16 < v19) {
                // 0x80a4f74
                *(int32_t *)(4 * v16 + (int32_t)&LayerStack) = v16;
            }
            // 0x80a4f7b
            v17 = v16 + 1;
            *(char *)(v18 + 144 + 92 * v16) = 0;
            v18 = *v13;
            v19 = *(int32_t *)(v18 + 24);
        }
    }
    // 0x80a4f99
    *(char *)(PCB + 35) = 0;
    *(char *)(PCB + 37) = 0;
    *(char *)(PCB + 38) = 0;
    *(char *)(PCB + 34) = 0;
    *(char *)(PCB + 36) = 0;
    if (v2 == -1) {
        // 0x80a5012
        return;
    }
    int32_t v20 = v2; // 0x80a4fb8
    int32_t v21 = 4 * v2 + mem; // 0x80a4fb8
    int32_t v22; // 0x80a4ed0
    int32_t v23; // 0x80a4ed0
    while (true) {
      lab_0x80a4fd4_2:
        // 0x80a4fd4
        v23 = v21;
        v22 = v20;
        char * str = (char *)*(int32_t *)v23;
        if (strcasecmp(str, "rats") == 0) {
            // 0x80a4fc0
            *(char *)(PCB + 36) = 1;
            goto lab_0x80a4fc9;
        } else {
            // 0x80a4fea
            if (strcasecmp(str, "invisible") != 0) {
                // 0x80a5038
                if (strcasecmp(str, "pins") != 0) {
                    // 0x80a5060
                    if (strcasecmp(str, "vias") != 0) {
                        // 0x80a5088
                        if (strcasecmp(str, "elements") == 0) {
                            // 0x80a5128
                            *(char *)(PCB + 35) = 1;
                        } else {
                            int16_t * v24 = *__ctype_b_loc(); // 0x80a50a8
                            char v25 = *(char *)((int32_t)v24 + 1 + 2 * (int32_t)*str); // 0x80a50aa
                            if ((v25 & 8) != 0) {
                                // 0x80a51f0
                                ChangeGroupVisibility(strtol(str, NULL, 10), 1, 1);
                            } else {
                                int32_t v26 = *(int32_t *)(PCB + 0x220c); // 0x80a50ba
                                uint32_t v27 = *(int32_t *)(v26 + 24); // 0x80a50c0
                                int32_t v28 = v26; // 0x80a50cd
                                if (v27 < 1) {
                                  lab_0x80a513c:
                                    // 0x80a513c
                                    __fprintf_chk(g43, 1, "Warning: layer \"%s\" not known\n", str);
                                    if (g72 == 0) {
                                        // 0x80a516b
                                        __fprintf_chk(g43, 1, "Named layers in this board are:\n");
                                        g72 = 1;
                                        int32_t v29 = *(int32_t *)(PCB + 0x220c); // 0x80a5197
                                        int32_t v30 = v29; // 0x80a51a2
                                        int32_t v31 = 0; // 0x80a51a2
                                        if (*(int32_t *)(v29 + 24) >= 1) {
                                            int32_t v32 = v31 + 1; // 0x80a51b3
                                            int32_t v33 = *(int32_t *)(v30 + 76 + 92 * v31); // 0x80a51b6
                                            __fprintf_chk(g43, 1, "\t%s\n", (char *)v33);
                                            int32_t v34 = *(int32_t *)(PCB + 0x220c); // 0x80a51e0
                                            v31 = v32;
                                            while (*(int32_t *)(v34 + 24) > v32) {
                                                // 0x80a51b0
                                                v32 = v31 + 1;
                                                v33 = *(int32_t *)(v34 + 76 + 92 * v31);
                                                __fprintf_chk(g43, 1, "\t%s\n", (char *)v33);
                                                v34 = *(int32_t *)(PCB + 0x220c);
                                                v31 = v32;
                                            }
                                        }
                                    }
                                } else {
                                    int32_t v35 = 0;
                                    int32_t v36 = v28;
                                    while (strcasecmp(str, (char *)*(int32_t *)(v36 + 76)) != 0) {
                                        int32_t v37 = v35 + 1; // 0x80a50e0
                                        v28 = v36 + 92;
                                        int32_t v38 = v37; // 0x80a50e9
                                        if (v37 >= v27) {
                                            goto lab_0x80a513c;
                                        }
                                        v35 = v38;
                                        v36 = v28;
                                    }
                                    // 0x80a50fe
                                    ChangeGroupVisibility(v35, 1, 1);
                                }
                            }
                        }
                    } else {
                        // 0x80a5074
                        *(char *)(PCB + 34) = 1;
                    }
                } else {
                    // 0x80a504c
                    *(char *)(PCB + 38) = 1;
                }
                goto lab_0x80a4fc9;
            } else {
                // 0x80a4ffe
                *(char *)(PCB + 37) = 1;
                if (v22 == 0) {
                    // break -> 0x80a5012
                    break;
                }
                // 0x80a4fd4
                v20 = v22 - 1;
                v21 = v23 - 4;
                goto lab_0x80a4fd4_2;
            }
        }
    }
  lab_0x80a4fc9:
    if (v22 == 0) {
        return;
    }
    // 0x80a4fd4
    v20 = v22 - 1;
    v21 = v23 - 4;
    goto lab_0x80a4fd4_2;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a5390 - 0x80a553c
// Line range:    900 - 105
char * EvaluateFilename(char * Template, char * Path, char * Filename, char * Parameter) {
    // 0x80a5390
    if (g108 != 0) {
        // 0x80a54c0
        __printf_chk(1, "EvaluateFilename:\n");
        __printf_chk(1, (char *)&g9);
        __printf_chk(1, (char *)&g10);
        __printf_chk(1, (char *)&g11);
        __printf_chk(1, (char *)&g12);
    }
    // 0x80a53b6
    DSClearString((int32_t)&g73);
    int32_t v1 = (int32_t)Template; // 0x80a53ca
    int32_t v2; // 0x80a5390
    if (Template != NULL) {
        while (true) {
          lab_0x80a53cc:;
            int32_t v3 = v1;
            char v4 = *(char *)v3; // 0x80a53cc
            if (v4 == 0) {
                // break (via goto) -> 0x80a5408
                goto lab_0x80a5408_3;
            }
            int32_t v5 = v3 + 1;
            while (v4 == 37) {
                char v6 = *(char *)v5; // 0x80a53de
                if (v6 != 112) {
                    if (v6 != 102) {
                        if (v6 != 97) {
                            // 0x80a5463
                            DSAddCharacter((int32_t)&g73, v4);
                            v2 = v5;
                            goto lab_0x80a53c8;
                        } else {
                            // 0x80a54a5
                            DSAddString((int32_t)&g73, Parameter);
                            v2 = v3 + 2;
                            goto lab_0x80a53c8;
                        }
                    } else {
                        // 0x80a5485
                        DSAddString((int32_t)&g73, Filename);
                        v2 = v3 + 2;
                        goto lab_0x80a53c8;
                    }
                }
                int32_t v7 = v3 + 2; // 0x80a53ea
                DSAddString((int32_t)&g73, Path);
                if (v7 == 0) {
                    // break (via goto) -> 0x80a5408
                    goto lab_0x80a5408_3;
                }
                v3 = v7;
                v4 = *(char *)v3;
                if (v4 == 0) {
                    // break (via goto) -> 0x80a5408
                    goto lab_0x80a5408_3;
                }
                // 0x80a53d3
                v5 = v3 + 1;
            }
            // 0x80a5463
            DSAddCharacter((int32_t)&g73, v4);
            v2 = v5;
            goto lab_0x80a53c8;
        }
    }
  lab_0x80a5408_3:
    // 0x80a5408
    DSAddCharacter((int32_t)&g73, 0);
    if (g108 != 0) {
        // 0x80a5426
        __printf_chk(1, (char *)&g13);
    }
    // 0x80a5443
    return MyStrdup(g74, "EvaluateFilename()");
  lab_0x80a53c8:
    // 0x80a53c8
    v1 = v2;
    if (v1 == 0) {
        // break -> 0x80a5408
        goto lab_0x80a5408_3;
    }
    goto lab_0x80a53cc;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a5540 - 0x80a5930
// Line range:    704 - 771
int32_t ParseRouteString(char * s, int32_t routeStyle, int32_t scale) {
    int32_t v1 = __readgsdword(20); // 0x80a5554
    __asm_rep_stosd_memset((char *)routeStyle, 0, 24);
    int16_t ** v2 = __ctype_b_loc(); // 0x80a556c
    char v3 = *s; // 0x80a5583
    int32_t * v4; // 0x80a5540
    int32_t * v5; // 0x80a5540
    int32_t v6; // 0x80a5540
    int32_t v7; // 0x80a5540
    int32_t v8; // 0x80a5540
    int32_t v9; // 0x80a5540
    char v10; // 0x80a5540
    char * v11; // 0x80a5540
    char * v12; // 0x80a5540
    int32_t v13; // 0x80a5540
    int32_t v14; // 0x80a5540
    if (v3 == 0) {
        // 0x80a5540
        v4 = (int32_t *)v2;
        v12 = s;
        v14 = 0;
        v9 = routeStyle;
        goto lab_0x80a582e;
    } else {
        // 0x80a5540
        v6 = (int32_t)*v2 + 1;
        v5 = (int32_t *)v2;
        v11 = s;
        v13 = 0;
        v7 = (int32_t)s;
        v10 = v3;
        v8 = routeStyle;
        goto lab_0x80a5594;
    }
  lab_0x80a582e:;
    int32_t * v15 = v4; // 0x80a5830
    char * v16 = v12; // 0x80a5830
    int32_t v17 = v14; // 0x80a5830
    int32_t v18 = 0; // 0x80a5830
    int32_t v19 = v9; // 0x80a5830
    goto lab_0x80a55fb_2;
  lab_0x80a56df:;
    // 0x80a56df
    int32_t * v21; // 0x80a5540
    int32_t v20; // 0x80a5540
    int16_t v40; // 0x80a5540
    int16_t v46; // 0x80a5540
    char * v39; // 0x80a5540
    char * v47; // 0x80a5540
    char * v48; // 0x80a5540
    int32_t result; // 0x80a5540
    int32_t v49; // 0x80a5717
    if ((v40 & 2048) == 0) {
        // 0x80a5861
        __asm_rep_stosd_memset((char *)v20, 0, 24);
        result = 1;
        goto lab_0x80a583a;
    } else {
        // 0x80a56e8
        GetNum((char **)v39, &g231);
        int32_t * v50 = (int32_t *)(v20 + 4); // 0x80a56f9
        *v50 = *v50 * scale;
        char v51 = *v39; // 0x80a5706
        if (v51 == 0) {
            // 0x80a5861
            __asm_rep_stosd_memset((char *)v20, 0, 24);
            result = 1;
            goto lab_0x80a583a;
        } else {
            // 0x80a5711
            v49 = *v21;
            unsigned char v52 = v51;
            int32_t v53 = (int32_t)v39;
            char v54 = *(char *)(v49 + 1 + 0x1000000 * (int32_t)v52 / 0x800000); // 0x80a5737
            int32_t v55 = v53 + 1;
            while ((v54 & 32) != 0) {
                char v56 = *(char *)v55; // 0x80a5729
                if (v56 == 0) {
                    // 0x80a5861
                    __asm_rep_stosd_memset((char *)v20, 0, 24);
                    result = 1;
                    goto lab_0x80a583a;
                }
                v52 = v56;
                v53 = v55;
                v54 = *(char *)(v49 + 1 + 0x1000000 * (int32_t)v52 / 0x800000);
                v55 = v53 + 1;
            }
            if (v52 != 44) {
                // 0x80a5861
                __asm_rep_stosd_memset((char *)v20, 0, 24);
                result = 1;
                goto lab_0x80a583a;
            } else {
                char * v57 = (char *)v55; // 0x80a5744
                unsigned char v58 = *v57; // 0x80a5750
                v47 = v57;
                if (v58 == 0) {
                    goto lab_0x80a578c;
                } else {
                    // 0x80a5758
                    if ((*(int16_t *)(0x1000000 * (int32_t)v58 / 0x800000 + v49) & 0x2000) == 0) {
                        goto lab_0x80a578f;
                    } else {
                        int32_t v59 = v53 + 2;
                        char * v60 = (char *)v59;
                        unsigned char v61 = *v60; // 0x80a5785
                        v47 = v60;
                        while (v61 != 0) {
                            int16_t v62 = *(int16_t *)(0x1000000 * (int32_t)v61 / 0x800000 + v49); // 0x80a5776
                            int32_t v63 = v59 + 1; // 0x80a577d
                            v48 = v60;
                            v46 = v62;
                            if ((v62 & 0x2000) == 0) {
                                goto lab_0x80a578f;
                            }
                            v59 = v63;
                            v60 = (char *)v59;
                            v61 = *v60;
                            v47 = v60;
                        }
                        goto lab_0x80a578c;
                    }
                }
            }
        }
    }
  lab_0x80a578f:;
    // 0x80a578f
    char * v64; // 0x80a5540
    if ((v46 & 2048) == 0) {
        // 0x80a5861
        __asm_rep_stosd_memset((char *)v20, 0, 24);
        result = 1;
        goto lab_0x80a583a;
    } else {
        char * v65 = v48;
        GetNum((char **)v65, &g231);
        int32_t * v66 = (int32_t *)(v20 + 8); // 0x80a57a9
        *v66 = *v66 * scale;
        if (*v65 == 44) {
            int32_t v67 = (int32_t)v65; // 0x80a57b0
            char * v68 = (char *)(v67 + 1); // 0x80a5873
            unsigned char v69 = *v68; // 0x80a5879
            int16_t v70; // 0x80a5540
            char * v71; // 0x80a5540
            if (v69 == 0) {
                // 0x80a591b
                v71 = v68;
                v70 = *(int16_t *)*v21;
            } else {
                int32_t v72 = *v21; // 0x80a588e
                int16_t v73 = *(int16_t *)(v72 + 0x1000000 * (int32_t)v69 / 0x800000); // 0x80a5890
                v71 = v68;
                v70 = v73;
                if ((v73 & 0x2000) != 0) {
                    int32_t v74 = v67 + 2;
                    char * v75 = (char *)v74;
                    unsigned char v76 = *v75; // 0x80a58b5
                    while (v76 != 0) {
                        int16_t v77 = *(int16_t *)(0x1000000 * (int32_t)v76 / 0x800000 + v72); // 0x80a58a6
                        int32_t v78 = v74 + 1; // 0x80a58ad
                        v71 = v75;
                        v70 = v77;
                        if ((v77 & 0x2000) == 0) {
                            goto lab_0x80a58bf;
                        }
                        v74 = v78;
                        v75 = (char *)v74;
                        v76 = *v75;
                    }
                    // 0x80a58bc
                    v71 = v75;
                    v70 = *(int16_t *)v72;
                }
            }
          lab_0x80a58bf:
            // 0x80a58bf
            if ((v70 & 2048) == 0) {
                // 0x80a5861
                __asm_rep_stosd_memset((char *)v20, 0, 24);
                result = 1;
                goto lab_0x80a583a;
            } else {
                char * v79 = v71;
                GetNum((char **)v79, &g231);
                int32_t * v80 = (int32_t *)(v20 + 12); // 0x80a58d5
                *v80 = *v80 * scale;
                unsigned char v81 = *v79; // 0x80a58e2
                v64 = v79;
                if (v81 != 0) {
                    int32_t v82 = *v21 + 1; // 0x80a590f
                    v64 = v79;
                    if ((*(char *)(v82 + 0x1000000 * (int32_t)v81 / 0x800000) & 32) != 0) {
                        int32_t v83 = (int32_t)v79; // 0x80a58f8
                        v83++;
                        char * v84 = (char *)v83;
                        unsigned char v85 = *v84; // 0x80a5901
                        v64 = v84;
                        while (v85 != 0) {
                            // 0x80a590c
                            v64 = v84;
                            if ((*(char *)(0x1000000 * (int32_t)v85 / 0x800000 + v82) & 32) == 0) {
                                // break -> 0x80a57c6
                                break;
                            }
                            v83++;
                            v84 = (char *)v83;
                            v85 = *v84;
                            v64 = v84;
                        }
                    }
                }
                goto lab_0x80a57c6;
            }
        } else {
            // 0x80a57bf
            *(int32_t *)(v20 + 12) = 1000;
            v64 = v65;
            goto lab_0x80a57c6;
        }
    }
  lab_0x80a5594:;
    int32_t v86 = v8;
    int32_t v87 = v13;
    int32_t * v88 = v5;
    int32_t v89 = v6;
    char v90 = *(char *)(0x1000000 * (int32_t)v10 / 0x800000 + v89); // 0x80a55b7
    int32_t v91 = v7; // 0x80a55bc
    char v92 = v10; // 0x80a55bc
    char * v93 = v11; // 0x80a55bc
    if ((v90 & 32) != 0) {
        int32_t v94 = v91 + 1; // 0x80a55a0
        char * v95 = (char *)v94;
        unsigned char v96 = *v95; // 0x80a55a9
        v4 = v88;
        v12 = v95;
        v14 = v87;
        v9 = v86;
        if (v96 == 0) {
            goto lab_0x80a582e;
        }
        char v97 = *(char *)(0x1000000 * (int32_t)v96 / 0x800000 + v89); // 0x80a55b7
        v91 = v94;
        v92 = v96;
        v93 = v95;
        while ((v97 & 32) != 0) {
            // 0x80a55a0
            v94 = v91 + 1;
            v95 = (char *)v94;
            v96 = *v95;
            v4 = v88;
            v12 = v95;
            v14 = v87;
            v9 = v86;
            if (v96 == 0) {
                goto lab_0x80a582e;
            }
            // 0x80a55b4
            v97 = *(char *)(0x1000000 * (int32_t)v96 / 0x800000 + v89);
            v91 = v94;
            v92 = v96;
            v93 = v95;
        }
    }
    char * v98 = v93;
    char v99 = v92; // 0x80a55c4
    v4 = v88;
    v12 = v98;
    v14 = v87;
    v9 = v86;
    int32_t v24; // bp-288, 0x80a5540
    switch (v99) {
        case 44: {
            goto lab_0x80a582e;
        }
        case 0: {
            goto lab_0x80a582e;
        }
        default: {
            int32_t v100 = (int32_t)v98; // 0x80a55e4
            int32_t v101 = 0; // 0x80a5540
            char v102 = v99; // 0x80a55f3
            int32_t v103; // 0x80a55ea
            char * v104; // 0x80a5540
            while (true) {
              lab_0x80a55e4:
                // 0x80a55e4
                v100++;
                *(char *)(v101 + (int32_t)&v24) = v102;
                v103 = v101 + 1;
                v104 = (char *)v100;
                v102 = *v104;
                v101 = v103;
                switch (v102) {
                    case 44: {
                        goto lab_0x80a55fb;
                    }
                    case 0: {
                        goto lab_0x80a55fb;
                    }
                    default: {
                        goto lab_0x80a55e4;
                    }
                }
            }
          lab_0x80a55fb:
            // 0x80a55fb
            v15 = v88;
            v16 = v104;
            v17 = v87;
            v18 = v103;
            v19 = v86;
            goto lab_0x80a55fb_2;
        }
    }
  lab_0x80a55fb_2:
    // 0x80a55fb
    v20 = v19;
    v21 = v15;
    int32_t v22; // bp-4, 0x80a5540
    *(char *)((int32_t)&v22 - 284 + v18) = 0;
    char * v23 = MyStrdup((char *)&v24, "ParseRouteString()"); // 0x80a560e
    *(int32_t *)(v20 + 16) = (int32_t)v23;
    int32_t v25 = (int32_t)v16 + 1; // 0x80a5624
    char * v26 = (char *)v25; // 0x80a5627
    char * v27; // 0x80a5540
    int32_t v28; // 0x80a5668
    if ((*(char *)(*v21 + 1 + 2 * (int32_t)*v26) & 8) == 0) {
        // 0x80a5861
        __asm_rep_stosd_memset((char *)v20, 0, 24);
        result = 1;
        goto lab_0x80a583a;
    } else {
        // 0x80a563c
        GetNum((char **)v25, &g231);
        int32_t * v29 = (int32_t *)v20; // 0x80a564c
        *v29 = *v29 * scale;
        char v30 = *v26; // 0x80a5657
        if (v30 == 0) {
            // 0x80a5861
            __asm_rep_stosd_memset((char *)v20, 0, 24);
            result = 1;
            goto lab_0x80a583a;
        } else {
            // 0x80a5662
            v28 = *v21;
            unsigned char v31 = v30;
            int32_t v32 = v25;
            char v33 = *(char *)(v28 + 1 + 0x1000000 * (int32_t)v31 / 0x800000); // 0x80a5687
            int32_t v34 = v32 + 1;
            while ((v33 & 32) != 0) {
                char v35 = *(char *)v34; // 0x80a5679
                if (v35 == 0) {
                    // 0x80a5861
                    __asm_rep_stosd_memset((char *)v20, 0, 24);
                    result = 1;
                    goto lab_0x80a583a;
                }
                v31 = v35;
                v32 = v34;
                v33 = *(char *)(v28 + 1 + 0x1000000 * (int32_t)v31 / 0x800000);
                v34 = v32 + 1;
            }
            if (v31 != 44) {
                // 0x80a5861
                __asm_rep_stosd_memset((char *)v20, 0, 24);
                result = 1;
                goto lab_0x80a583a;
            } else {
                char * v36 = (char *)v34; // 0x80a5694
                unsigned char v37 = *v36; // 0x80a56a0
                v27 = v36;
                if (v37 == 0) {
                    goto lab_0x80a56dc;
                } else {
                    int16_t v38 = *(int16_t *)(0x1000000 * (int32_t)v37 / 0x800000 + v28); // 0x80a56ab
                    v39 = v36;
                    v40 = v38;
                    if ((v38 & 0x2000) == 0) {
                        goto lab_0x80a56df;
                    } else {
                        int32_t v41 = v32 + 2;
                        char * v42 = (char *)v41;
                        unsigned char v43 = *v42; // 0x80a56d5
                        v27 = v42;
                        while (v43 != 0) {
                            int16_t v44 = *(int16_t *)(0x1000000 * (int32_t)v43 / 0x800000 + v28); // 0x80a56c6
                            int32_t v45 = v41 + 1; // 0x80a56cd
                            v39 = v42;
                            v40 = v44;
                            if ((v44 & 0x2000) == 0) {
                                goto lab_0x80a56df;
                            }
                            v41 = v45;
                            v42 = (char *)v41;
                            v43 = *v42;
                            v27 = v42;
                        }
                        goto lab_0x80a56dc;
                    }
                }
            }
        }
    }
  lab_0x80a583a:
    // 0x80a583a
    if (v1 != __readgsdword(20)) {
        // 0x80a5928
        __stack_chk_fail();
        return &g231;
    }
    // 0x80a584a
    return result;
  lab_0x80a56dc:
    // 0x80a56dc
    v39 = v27;
    v40 = *(int16_t *)v28;
    goto lab_0x80a56df;
  lab_0x80a578c:
    // 0x80a578c
    v48 = v47;
    v46 = *(int16_t *)v49;
    goto lab_0x80a578f;
  lab_0x80a57c6:
    // 0x80a57c6
    result = 0;
    if (v17 == 3) {
        goto lab_0x80a583a;
    } else {
        char v105 = *v64; // 0x80a57d5
        if (v105 == 0) {
            // 0x80a5861
            __asm_rep_stosd_memset((char *)v20, 0, 24);
            result = 1;
            goto lab_0x80a583a;
        } else {
            int32_t v106 = *v21 + 1;
            unsigned char v107 = v105;
            int32_t v108 = (int32_t)v64 + 1;
            while ((*(char *)(0x1000000 * (int32_t)v107 / 0x800000 + v106) & 32) != 0) {
                char v109 = *(char *)v108; // 0x80a57f1
                if (v109 == 0) {
                    // 0x80a5861
                    __asm_rep_stosd_memset((char *)v20, 0, 24);
                    result = 1;
                    goto lab_0x80a583a;
                }
                v107 = v109;
                v108++;
            }
            if (v107 != 58) {
                // 0x80a5861
                __asm_rep_stosd_memset((char *)v20, 0, 24);
                result = 1;
                goto lab_0x80a583a;
            } else {
                char * v110 = (char *)v108; // 0x80a5808
                int32_t v111 = v17 + 1; // 0x80a5810
                char v112 = *v110; // 0x80a5820
                int32_t v113 = v20 + 24; // 0x80a5823
                v6 = v106;
                v5 = v21;
                v11 = v110;
                v13 = v111;
                v7 = v108;
                v10 = v112;
                v8 = v113;
                v4 = v21;
                v12 = v110;
                v14 = v111;
                v9 = v113;
                if (v112 != 0) {
                    goto lab_0x80a5594;
                } else {
                    goto lab_0x80a582e;
                }
            }
        }
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a5a10 - 0x80a5c3a
// Line range:    417 - 426
void SetTextBoundingBox(int32_t FontPtr, int32_t Text) {
    int32_t v1 = *(int32_t *)(Text + 52); // 0x80a5a1c
    int32_t v2 = 0; // 0x80a5a24
    int32_t v3 = 0; // 0x80a5a24
    int32_t v4 = 0; // 0x80a5a24
    if (v1 != 0) {
        char * v5 = (char *)v1; // 0x80a5a21
        char v6 = *v5; // 0x80a5a2a
        v2 = 0;
        v3 = 0;
        v4 = 0;
        if (v6 != 0) {
            int32_t v7 = 0;
            int32_t v8 = 0;
            int32_t v9 = 28 * (int32_t)v6 + FontPtr; // 0x80a5a46
            int32_t v10; // 0x80a5a10
            int32_t v11; // 0x80a5a10
            int32_t v12; // 0x80a5a10
            int32_t v13; // 0x80a5a10
            int32_t v14; // 0x80a5a10
            int32_t v15; // 0x80a5a10
            int32_t v16; // 0x80a5bb9
            int32_t v17; // 0x80a5a56
            int32_t v18; // 0x80a5a84
            int32_t v19; // 0x80a5a87
            int32_t v20; // 0x80a5a90
            int32_t v21; // 0x80a5a92
            int32_t v22; // 0x80a5a68
            int32_t v23; // 0x80a5a6b
            int32_t v24; // 0x80a5a6d
            int32_t v25; // 0x80a5a70
            int32_t v26; // 0x80a5a10
            if (*(char *)(v9 + 28) == 0) {
                // 0x80a5ba8
                v16 = 6 * (*(int32_t *)(FontPtr + 16) - *(int32_t *)(FontPtr + 8));
                v26 = v8 + (int32_t)(v16 < 0) + (int32_t)(0x66666667 * (int64_t)v16 / 0x100000000) / 2;
                v13 = v7;
                v15 = *(int32_t *)(FontPtr + 20) - *(int32_t *)(FontPtr + 12);
            } else {
                // 0x80a5a56
                v14 = 0;
                v17 = *(int32_t *)(v9 + 32);
                v12 = v7;
                if (v17 != 0) {
                    // 0x80a5a60
                    v10 = *(int32_t *)(v9 + 24);
                    v25 = 0;
                    v11 = v7;
                    v22 = *(int32_t *)(v10 + 36);
                    v23 = v11 - v22;
                    v24 = v23 < 0 == ((v23 ^ v11) & (v22 ^ v11)) < 0 ? v11 : v22;
                    v25++;
                    v10 += 88;
                    v12 = v24;
                    while (v25 != v17) {
                        // 0x80a5a68
                        v11 = v24;
                        v22 = *(int32_t *)(v10 + 36);
                        v23 = v11 - v22;
                        v24 = v23 < 0 == ((v23 ^ v11) & (v22 ^ v11)) < 0 ? v11 : v22;
                        v25++;
                        v10 += 88;
                        v12 = v24;
                    }
                }
                // 0x80a5a7a
                v18 = *(int32_t *)(v9 + 40);
                v19 = *(int32_t *)(v9 + 44);
                v20 = v14 - v19;
                v21 = v20 < 0 == ((v20 ^ v14) & (v19 ^ v14)) < 0 ? v14 : v19;
                v26 = *(int32_t *)(v9 + 48) + v8 + v18;
                v13 = v12;
                v15 = v21;
            }
            int32_t v27 = v13;
            int32_t v28 = v26;
            int32_t v29 = (int32_t)v5 + 1; // 0x80a5a95
            v2 = v28;
            v3 = v27;
            v4 = v15;
            while (v29 != 0) {
                char * v30 = (char *)v29; // 0x80a5a95
                char v31 = *v30; // 0x80a5a9e
                int32_t v32 = v15; // 0x80a5aa3
                v2 = v28;
                v3 = v27;
                v4 = v15;
                if (v31 == 0) {
                    // break -> 0x80a5aa5
                    break;
                }
                v7 = v27;
                v8 = v28;
                v9 = 28 * (int32_t)v31 + FontPtr;
                if (*(char *)(v9 + 28) == 0) {
                    // 0x80a5ba8
                    v16 = 6 * (*(int32_t *)(FontPtr + 16) - *(int32_t *)(FontPtr + 8));
                    v26 = v8 + (int32_t)(v16 < 0) + (int32_t)(0x66666667 * (int64_t)v16 / 0x100000000) / 2;
                    v13 = v7;
                    v15 = *(int32_t *)(FontPtr + 20) - *(int32_t *)(FontPtr + 12);
                } else {
                    // 0x80a5a56
                    v14 = v32;
                    v17 = *(int32_t *)(v9 + 32);
                    v12 = v7;
                    if (v17 != 0) {
                        // 0x80a5a60
                        v10 = *(int32_t *)(v9 + 24);
                        v25 = 0;
                        v11 = v7;
                        v22 = *(int32_t *)(v10 + 36);
                        v23 = v11 - v22;
                        v24 = v23 < 0 == ((v23 ^ v11) & (v22 ^ v11)) < 0 ? v11 : v22;
                        v25++;
                        v10 += 88;
                        v12 = v24;
                        while (v25 != v17) {
                            // 0x80a5a68
                            v11 = v24;
                            v22 = *(int32_t *)(v10 + 36);
                            v23 = v11 - v22;
                            v24 = v23 < 0 == ((v23 ^ v11) & (v22 ^ v11)) < 0 ? v11 : v22;
                            v25++;
                            v10 += 88;
                            v12 = v24;
                        }
                    }
                    // 0x80a5a7a
                    v18 = *(int32_t *)(v9 + 40);
                    v19 = *(int32_t *)(v9 + 44);
                    v20 = v14 - v19;
                    v21 = v20 < 0 == ((v20 ^ v14) & (v19 ^ v14)) < 0 ? v14 : v19;
                    v26 = *(int32_t *)(v9 + 48) + v8 + v18;
                    v13 = v12;
                    v15 = v21;
                }
                // 0x80a5a95
                v27 = v13;
                v28 = v26;
                v29 = (int32_t)v30 + 1;
                v2 = v28;
                v3 = v27;
                v4 = v15;
            }
        }
    }
    float80_t v33 = (float80_t)*(int32_t *)(Text + 36); // 0x80a5aad
    float80_t v34 = v33 / 100.0L; // 0x80a5ab2
    int32_t v35 = v34 * (float80_t)v2; // 0x80a5ad0
    int32_t v36 = v34 * (float80_t)v4; // 0x80a5ade
    int32_t v37 = v33 / 200.0L * (float80_t)v3; // 0x80a5afa
    int32_t v38 = *(int32_t *)(Text + 44); // 0x80a5b03
    int32_t v39 = v37 - 399; // 0x80a5b06
    int32_t v40 = v39 == 0 | v39 < 0 != (398 - v37 & v37) < 0 ? 400 : v37; // 0x80a5b0b
    int32_t v41 = *(int32_t *)(Text + 40); // 0x80a5b0e
    int32_t * v42 = (int32_t *)(Text + 4); // 0x80a5b15
    *v42 = v38;
    int32_t * v43 = (int32_t *)Text; // 0x80a5b18
    *v43 = v41 - v40;
    int32_t * v44; // 0x80a5a10
    int32_t * v45; // 0x80a5a10
    if (*(char *)(Text + 20) < 0) {
        int32_t v46 = v40 + v38; // 0x80a5bda
        *v42 = v46;
        int32_t * v47 = (int32_t *)(Text + 8);
        *v47 = v41 + v35;
        int32_t * v48 = (int32_t *)(Text + 12);
        *v48 = -2 * v40 - v36 + v46;
        RotateBoxLowLevel(Text, v41, v38, -*(char *)(Text + 48) % 4);
        v45 = v48;
        v44 = v47;
    } else {
        int32_t v49 = v38 - v40; // 0x80a5b2e
        *v42 = v49;
        int32_t * v50 = (int32_t *)(Text + 8);
        *v50 = v41 + v35;
        int32_t * v51 = (int32_t *)(Text + 12);
        *v51 = 2 * v40 + v36 + v49;
        RotateBoxLowLevel(Text, v41, v38, *(char *)(Text + 48));
        v45 = v51;
        v44 = v50;
    }
    int32_t * v52 = v45;
    int32_t * v53 = (int32_t *)(PCB + 112); // 0x80a5b73
    *v43 = *v43 - *v53;
    *v42 = *v42 - *v53;
    int32_t v54 = *v44 + *v53; // 0x80a5b81
    *v44 = v54;
    *v44 = v54 + 1;
    *v52 = *v53 + 1 + *v52;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a5c40 - 0x80a5df0
// Line range:    175 - 189
void SetPadBoundingBox(int32_t Pad) {
    // 0x80a5c40
    int3_t v1; // 0x80a5c40
    int3_t v2 = v1;
    int32_t * v3 = (int32_t *)(Pad + 48); // 0x80a5c52
    int32_t * v4 = (int32_t *)(Pad + 44); // 0x80a5c55
    int32_t v5 = *v4; // 0x80a5c55
    int32_t v6 = *(int32_t *)(Pad + 36) + 1 + *(int32_t *)(Pad + 40); // 0x80a5c58
    int32_t v7 = (v6 + (int32_t)(v6 < 0)) / 2; // 0x80a5c66
    int32_t v8 = *(int32_t *)(Pad + 84) + 1; // 0x80a5c6b
    int32_t * v9 = (int32_t *)(Pad + 68); // 0x80a5c76
    int32_t v10 = *v9; // 0x80a5c76
    int32_t v11 = (v8 + (int32_t)(v8 < 0)) / 2; // 0x80a5c79
    int32_t v12 = v7 - v11; // 0x80a5c7b
    int32_t v13 = v12 < 0 == ((v12 ^ v7) & (v11 ^ v7)) < 0 ? v7 : v11; // 0x80a5c7d
    int32_t * v14 = (int32_t *)(Pad + 64); // 0x80a5c80
    int32_t v15 = *v14; // 0x80a5c80
    int32_t v16 = v15 - v5; // 0x80a5c85
    int32_t * v17; // 0x80a5c40
    int32_t * v18; // 0x80a5c40
    int32_t v19; // 0x80a5c40
    int32_t v20; // 0x80a5c40
    if (v16 == 0) {
        goto lab_0x80a5c92;
    } else {
        // 0x80a5c8c
        if (*(char *)(Pad + 21) % 2 != 0) {
            int32_t v21 = v10 - *v3; // 0x80a5cda
            if (v21 == 0) {
                goto lab_0x80a5c92;
            } else {
                int3_t v22 = v2 - 1; // 0x80a5ce2
                __frontend_reg_store_fpr(v22, (float80_t)v16);
                __frontend_reg_load_fpr(v22);
                __frontend_reg_store_fpr(v22, (float80_t)v21);
                atan2((float64_t)__frontend_reg_load_fpr(v22), (float64_t)(int64_t)&g231);
                __frontend_reg_store_fpr(v22, (float80_t)v13);
                float80_t v23 = __frontend_reg_load_fpr(v22); // 0x80a5d08
                __frontend_reg_store_fpr(v22, __frontend_reg_load_fpr(v2));
                __frontend_reg_store_fpr(v2, v23);
                __frontend_reg_store_fpr(v22, __frontend_reg_load_fpr(v22));
                int3_t v24 = v2 - 2; // 0x80a5d10
                __frontend_reg_store_fpr(v24, 0.785398163397448278999L);
                __frontend_reg_store_fpr(v22, __frontend_reg_load_fpr(v24) + __frontend_reg_load_fpr(v22));
                __frontend_reg_load_fpr(v22);
                float80_t v25 = __frontend_reg_load_fpr(v2); // 0x80a5d1b
                function_8060d88(v25);
                float64_t v26; // 0x80a5c40
                __frontend_reg_store_fpr(v2, (float80_t)v26);
                __frontend_reg_store_fpr(v22, v25);
                __frontend_reg_store_fpr(v24, (float80_t)v26);
                __frontend_reg_store_fpr(v24, __frontend_reg_load_fpr(v24) * __frontend_reg_load_fpr(v22));
                int3_t v27 = v2 - 3; // 0x80a5d35
                __frontend_reg_store_fpr(v27, 1.41421356237309514547L);
                __frontend_reg_store_fpr(v24, __frontend_reg_load_fpr(v24) * __frontend_reg_load_fpr(v27));
                float80_t v28 = __frontend_reg_load_fpr(v27); // 0x80a5d3d
                __frontend_reg_store_fpr(v27, __frontend_reg_load_fpr(v24));
                __frontend_reg_store_fpr(v24, v28);
                __frontend_reg_store_fpr(v27, __frontend_reg_load_fpr(v27));
                int32_t v29 = __frontend_reg_load_fpr(v27); // 0x80a5d4e
                float80_t v30 = __frontend_reg_load_fpr(v24); // 0x80a5d54
                __frontend_reg_store_fpr(v24, __frontend_reg_load_fpr(v2));
                __frontend_reg_store_fpr(v2, v30);
                __frontend_reg_store_fpr(v22, __frontend_reg_load_fpr(v24) * __frontend_reg_load_fpr(v22));
                __frontend_reg_store_fpr(v2, __frontend_reg_load_fpr(v22) * __frontend_reg_load_fpr(v2));
                float80_t v31 = __frontend_reg_load_fpr(v2); // 0x80a5d5d
                int32_t v32 = *v14; // 0x80a5d60
                __frontend_reg_store_fpr(v2, v31);
                int32_t v33 = __frontend_reg_load_fpr(v2); // 0x80a5d69
                int32_t v34 = *v4; // 0x80a5d6f
                int32_t v35 = v32 + v29; // 0x80a5d72
                int32_t v36 = v32 + v33; // 0x80a5d74
                int32_t v37 = v35 - v36; // 0x80a5d79
                int32_t v38 = v37 == 0 | v37 < 0 != ((v37 ^ v35) & (v36 ^ v35)) < 0 ? v35 : v36; // 0x80a5d7d
                int32_t v39 = v34 - v33; // 0x80a5d80
                int32_t v40 = v38 - v39; // 0x80a5d83
                int32_t v41 = v40 < 0 == ((v40 ^ v38) & (v38 ^ v39)) < 0 == (v40 != 0) ? v39 : v38; // 0x80a5d85
                int32_t v42 = v34 - v29; // 0x80a5d88
                int32_t v43 = v41 - v42; // 0x80a5d8b
                int32_t v44 = v43 < 0 == ((v43 ^ v41) & (v41 ^ v42)) < 0 == (v43 != 0) ? v42 : v41; // 0x80a5d8d
                int32_t v45 = v37 < 0 == ((v37 ^ v35) & (v36 ^ v35)) < 0 ? v35 : v36; // 0x80a5d92
                int32_t v46 = v45 - v39; // 0x80a5d95
                int32_t v47 = v46 < 0 == ((v46 ^ v45) & (v45 ^ v39)) < 0 ? v45 : v39; // 0x80a5d97
                int32_t v48 = *v9; // 0x80a5d9a
                int32_t v49 = v47 - v42; // 0x80a5d9d
                int32_t v50 = v49 < 0 == ((v49 ^ v47) & (v47 ^ v42)) < 0 ? v47 : v42; // 0x80a5d9f
                *(int32_t *)Pad = v44;
                int32_t v51 = v48 + v33; // 0x80a5da9
                int32_t v52 = v48 - v29; // 0x80a5dac
                int32_t * v53 = (int32_t *)(Pad + 8);
                *v53 = v50;
                int32_t v54 = v52 - v51; // 0x80a5db4
                int32_t v55 = v54 == 0 | v54 < 0 != ((v54 ^ v52) & (v52 ^ v51)) < 0 ? v52 : v51; // 0x80a5db6
                int32_t v56 = *v3 - v33; // 0x80a5db9
                int32_t v57 = v55 - v56; // 0x80a5dbc
                int32_t v58 = v57 < 0 == ((v57 ^ v55) & (v55 ^ v56)) < 0 == (v57 != 0) ? v56 : v55; // 0x80a5dbe
                int32_t v59 = *v3 + v29; // 0x80a5dc7
                int32_t v60 = v58 - v59; // 0x80a5dcd
                int32_t v61 = v60 == 0 | v60 < 0 != ((v60 ^ v58) & (v58 ^ v59)) < 0 ? v58 : v59; // 0x80a5dd0
                int32_t v62 = v54 < 0 == ((v54 ^ v52) & (v52 ^ v51)) < 0 ? v52 : v51; // 0x80a5dd6
                int32_t v63 = v62 - v56; // 0x80a5dd9
                int32_t v64 = v63 < 0 == ((v63 ^ v62) & (v62 ^ v56)) < 0 ? v62 : v56; // 0x80a5ddb
                int32_t v65 = v64 - v59; // 0x80a5dde
                int32_t v66 = v65 < 0 == ((v65 ^ v64) & (v64 ^ v59)) < 0 ? v64 : v59; // 0x80a5de1
                *(int32_t *)(Pad + 4) = v61;
                int32_t * v67 = (int32_t *)(Pad + 12);
                *v67 = v66;
                v19 = v66;
                v18 = v53;
                v17 = v67;
                v20 = v50;
                goto lab_0x80a5cc2;
            }
        } else {
            goto lab_0x80a5c92;
        }
    }
  lab_0x80a5c92:;
    int32_t v68 = v5 - v15; // 0x80a5c92
    int32_t v69 = v68 < 0 == ((v68 ^ v5) & (v15 ^ v5)) < 0 == (v68 != 0) ? v15 : v5; // 0x80a5c94
    *(int32_t *)Pad = v69 - v13;
    int32_t v70 = *v4; // 0x80a5c9d
    int32_t v71 = v70 - v15; // 0x80a5c9d
    int32_t v72 = *v3; // 0x80a5ca4
    int32_t v73 = v72 - v10; // 0x80a5ca4
    int32_t v74 = v73 == 0 | v73 < 0 != ((v73 ^ v72) & (v72 ^ v10)) < 0 ? v72 : v10; // 0x80a5ca7
    int32_t v75 = (v71 < 0 == ((v71 ^ v70) & (v70 ^ v15)) < 0 ? v70 : v15) + v13; // 0x80a5cab
    int32_t * v76 = (int32_t *)(Pad + 8);
    *v76 = v75;
    int32_t v77 = *v3; // 0x80a5cb3
    int32_t v78 = v77 - v10; // 0x80a5cb3
    *(int32_t *)(Pad + 4) = v74 - v13;
    int32_t v79 = (v78 < 0 == ((v78 ^ v77) & (v77 ^ v10)) < 0 ? v77 : v10) + v13; // 0x80a5cbd
    int32_t * v80 = (int32_t *)(Pad + 12);
    *v80 = v79;
    v19 = v79;
    v18 = v76;
    v17 = v80;
    v20 = v75;
    goto lab_0x80a5cc2;
  lab_0x80a5cc2:
    // 0x80a5cc2
    *v17 = v19 + 1;
    *v18 = v20 + 1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a5df0 - 0x80a64a4
// Line range:    268 - 408
void SetElementBoundingBox(int32_t Data, int32_t Element, int32_t Font) {
    if (Data != 0) {
        int32_t v1 = *(int32_t *)(Data + 44); // 0x80a5e0c
        if (v1 != 0) {
            // 0x80a5e13
            r_delete_entry(v1, Element);
        }
    }
    for (int32_t i = 2; i > -1; i--) {
        int32_t v2 = Element + 36 + 60 * i; // 0x80a5e32
        if (Data == 0) {
            // 0x80a6438
            SetTextBoundingBox(Font, v2);
        } else {
            int32_t * v3 = (int32_t *)(Data + 56 + 4 * i); // 0x80a5e3c
            int32_t v4 = *v3; // 0x80a5e3c
            if (v4 != 0) {
                // 0x80a5e44
                r_delete_entry(v4, v2);
            }
            // 0x80a5e50
            SetTextBoundingBox(Font, v2);
            int32_t v5 = *v3; // 0x80a5e5f
            int32_t v6 = v5; // 0x80a5e65
            if (v5 == 0) {
                // 0x80a6458
                v6 = r_create_tree(0, 0, 0);
                *v3 = v6;
            }
            // 0x80a5e6b
            r_insert_entry(v6, v2, 0);
        }
    }
    int32_t v7 = *(int32_t *)(Element + 240); // 0x80a5e8a
    int32_t * v8 = (int32_t *)(Element + 4); // 0x80a5e90
    *v8 = 0x989680;
    int32_t * v9 = (int32_t *)Element; // 0x80a5e97
    *v9 = 0x989680;
    int32_t * v10 = (int32_t *)(Element + 12); // 0x80a5e9d
    *v10 = 0;
    int32_t * v11 = (int32_t *)(Element + 8); // 0x80a5eaa
    *v11 = 0;
    if (v7 != 0) {
        int32_t v12 = 88 * v7; // 0x80a5ec4
        int32_t v13 = v7; // 0x80a5ec4
        v12 -= 88;
        int32_t v14 = *(int32_t *)(Element + 264) + v12; // 0x80a5ecb
        SetLineBoundingBox(v14);
        int32_t v15 = *(int32_t *)(v14 + 44); // 0x80a5edc
        int32_t v16 = *(int32_t *)(v14 + 36) + 1; // 0x80a5edf
        int32_t v17 = (v16 + (int32_t)(v16 < 0)) / 2; // 0x80a5ee9
        int32_t v18 = v15 - v17; // 0x80a5eed
        int32_t v19 = *v9; // 0x80a5ef0
        int32_t v20 = v19; // 0x80a5ef5
        if (v18 < v19) {
            // 0x80a5ef7
            *v9 = v18;
            v20 = v18;
        }
        int32_t v21 = *(int32_t *)(v14 + 48); // 0x80a5ef9
        int32_t v22 = v21 - v17; // 0x80a5eff
        int32_t v23 = *v8; // 0x80a5f02
        int32_t v24 = v23; // 0x80a5f05
        int32_t v25 = v20; // 0x80a5f05
        if (v22 < v23) {
            // 0x80a5f07
            *v8 = v22;
            v24 = v22;
            v25 = *v9;
        }
        int32_t v26 = *(int32_t *)(v14 + 64); // 0x80a5f0a
        int32_t v27 = v26 - v17; // 0x80a5f0d
        int32_t v28 = v24; // 0x80a5f15
        if (v27 < v25) {
            // 0x80a5f17
            *v9 = v27;
            v28 = *v8;
        }
        int32_t v29 = *(int32_t *)(v14 + 68); // 0x80a5f19
        int32_t v30 = v29 - v17; // 0x80a5f1c
        if (v30 < v28) {
            // 0x80a5f23
            *v8 = v30;
        }
        int32_t v31 = v17 + v15; // 0x80a5f33
        int32_t v32 = *v11; // 0x80a5f36
        int32_t v33 = v32; // 0x80a5f39
        if (v31 > v32) {
            // 0x80a5f3b
            *v11 = v31;
            v33 = v31;
        }
        int32_t v34 = v21 + v17; // 0x80a5f41
        int32_t v35 = *v10; // 0x80a5f44
        int32_t v36 = v35; // 0x80a5f47
        int32_t v37 = v33; // 0x80a5f47
        if (v34 > v35) {
            // 0x80a5f49
            *v10 = v34;
            v36 = v34;
            v37 = *v11;
        }
        int32_t v38 = v26 + v17; // 0x80a5f4c
        int32_t v39 = v36; // 0x80a5f52
        if (v38 > v37) {
            // 0x80a5f54
            *v11 = v38;
            v39 = *v10;
        }
        int32_t v40 = v29 + v17; // 0x80a5f57
        if (v40 > v39) {
            // 0x80a5f5e
            *v10 = v40;
        }
        while (v13 != 1) {
            // 0x80a5f61
            v13--;
            v12 -= 88;
            v14 = *(int32_t *)(Element + 264) + v12;
            SetLineBoundingBox(v14);
            v15 = *(int32_t *)(v14 + 44);
            v16 = *(int32_t *)(v14 + 36) + 1;
            v17 = (v16 + (int32_t)(v16 < 0)) / 2;
            v18 = v15 - v17;
            v19 = *v9;
            v20 = v19;
            if (v18 < v19) {
                // 0x80a5ef7
                *v9 = v18;
                v20 = v18;
            }
            // 0x80a5ef9
            v21 = *(int32_t *)(v14 + 48);
            v22 = v21 - v17;
            v23 = *v8;
            v24 = v23;
            v25 = v20;
            if (v22 < v23) {
                // 0x80a5f07
                *v8 = v22;
                v24 = v22;
                v25 = *v9;
            }
            // 0x80a5f0a
            v26 = *(int32_t *)(v14 + 64);
            v27 = v26 - v17;
            v28 = v24;
            if (v27 < v25) {
                // 0x80a5f17
                *v9 = v27;
                v28 = *v8;
            }
            // 0x80a5f19
            v29 = *(int32_t *)(v14 + 68);
            v30 = v29 - v17;
            if (v30 < v28) {
                // 0x80a5f23
                *v8 = v30;
            }
            // 0x80a5f26
            v31 = v17 + v15;
            v32 = *v11;
            v33 = v32;
            if (v31 > v32) {
                // 0x80a5f3b
                *v11 = v31;
                v33 = v31;
            }
            // 0x80a5f3e
            v34 = v21 + v17;
            v35 = *v10;
            v36 = v35;
            v37 = v33;
            if (v34 > v35) {
                // 0x80a5f49
                *v10 = v34;
                v36 = v34;
                v37 = *v11;
            }
            // 0x80a5f4c
            v38 = v26 + v17;
            v39 = v36;
            if (v38 > v37) {
                // 0x80a5f54
                *v11 = v38;
                v39 = *v10;
            }
            // 0x80a5f57
            v40 = v29 + v17;
            if (v40 > v39) {
                // 0x80a5f5e
                *v10 = v40;
            }
        }
    }
    int32_t v41 = *(int32_t *)(Element + 248); // 0x80a5f73
    if (v41 != 0) {
        int32_t v42 = v41; // 0x80a5f8e
        int32_t v43 = 68 * v41; // 0x80a5f8e
        v43 -= 68;
        int32_t v44 = *(int32_t *)(Element + 268) + v43; // 0x80a5f96
        SetArcBoundingBox(v44);
        int32_t v45 = *(int32_t *)v44; // 0x80a5fa3
        if (v45 < *v9) {
            // 0x80a5fac
            *v9 = v45;
        }
        int32_t v46 = *(int32_t *)(v44 + 4); // 0x80a5fae
        if (v46 < *v8) {
            // 0x80a5fb6
            *v8 = v46;
        }
        int32_t v47 = *(int32_t *)(v44 + 8); // 0x80a5fb9
        if (v47 > *v11) {
            // 0x80a5fc1
            *v11 = v47;
        }
        int32_t v48 = *(int32_t *)(v44 + 12); // 0x80a5fc4
        if (v48 > *v10) {
            // 0x80a5fcc
            *v10 = v48;
        }
        // 0x80a5fcf
        v42--;
        while (v42 != 0) {
            // 0x80a5f90
            v43 -= 68;
            v44 = *(int32_t *)(Element + 268) + v43;
            SetArcBoundingBox(v44);
            v45 = *(int32_t *)v44;
            if (v45 < *v9) {
                // 0x80a5fac
                *v9 = v45;
            }
            // 0x80a5fae
            v46 = *(int32_t *)(v44 + 4);
            if (v46 < *v8) {
                // 0x80a5fb6
                *v8 = v46;
            }
            // 0x80a5fb9
            v47 = *(int32_t *)(v44 + 8);
            if (v47 > *v11) {
                // 0x80a5fc1
                *v11 = v47;
            }
            // 0x80a5fc4
            v48 = *(int32_t *)(v44 + 12);
            if (v48 > *v10) {
                // 0x80a5fcc
                *v10 = v48;
            }
            // 0x80a5fcf
            v42--;
        }
    }
    int32_t * v49 = (int32_t *)(Element + 272); // 0x80a5fdc
    *v49 = *v9;
    int32_t * v50 = (int32_t *)(Element + 276); // 0x80a5fe5
    *v50 = *v8;
    int32_t * v51 = (int32_t *)(Element + 280); // 0x80a5fee
    *v51 = *v11;
    int32_t * v52 = (int32_t *)(Element + 284); // 0x80a5ff7
    *v52 = *v10;
    int32_t * v53 = (int32_t *)(Element + 224); // 0x80a5ffd
    int32_t v54 = *v53; // 0x80a5ffd
    if (v54 != 0) {
        int32_t * v55 = (int32_t *)(Data + 48);
        int32_t v56 = 0; // 0x80a60fa
        int32_t v57 = v54;
        int32_t v58 = 76 * v56 + *(int32_t *)(Element + 256); // 0x80a610a
        int32_t v59; // 0x80a601b
        int32_t v60; // 0x80a6039
        int32_t v61; // 0x80a62cf
        if (Data != 0) {
            // 0x80a6018
            v59 = *v55;
            if (v59 != 0) {
                // 0x80a6022
                r_delete_entry(v59, v58);
            }
            // 0x80a602e
            SetPinBoundingBox(v58);
            v60 = *v55;
            v61 = v60;
            if (v60 == 0) {
                // 0x80a62b8
                v61 = r_create_tree(0, 0, 0);
                *v55 = v61;
            }
            // 0x80a6044
            r_insert_entry(v61, v58, 0);
        } else {
            // 0x80a6118
            SetPinBoundingBox(v58);
        }
        int32_t v62 = *(int32_t *)v58; // 0x80a6058
        if (v62 < *v9) {
            // 0x80a605e
            *v9 = v62;
        }
        int32_t v63 = *(int32_t *)(v58 + 4); // 0x80a6060
        if (v63 < *v8) {
            // 0x80a6068
            *v8 = v63;
        }
        int32_t v64 = *(int32_t *)(v58 + 8); // 0x80a606b
        if (v64 > *v11) {
            // 0x80a6073
            *v11 = v64;
        }
        int32_t v65 = *(int32_t *)(v58 + 12); // 0x80a6076
        if (v65 > *v10) {
            // 0x80a607e
            *v10 = v65;
        }
        int32_t v66 = *(int32_t *)(v58 + 52); // 0x80a6081
        int32_t v67 = *(int32_t *)(v58 + 36); // 0x80a6084
        int32_t v68 = (v67 + (int32_t)(v67 < 0)) / 2; // 0x80a6094
        int32_t v69 = v66 - v68; // 0x80a6098
        if (v69 < *v49) {
            // 0x80a60a5
            *v49 = v69;
        }
        int32_t v70 = *(int32_t *)(v58 + 56); // 0x80a60ab
        int32_t v71 = v70 - v68; // 0x80a60ae
        if (v71 < *v50) {
            // 0x80a60b8
            *v50 = v71;
        }
        int32_t v72 = v68 + v66; // 0x80a60cb
        if (v72 > *v51) {
            // 0x80a60d6
            *v51 = v72;
        }
        int32_t v73 = v70 + v68; // 0x80a60dc
        if (v73 > *v52) {
            // 0x80a60e6
            *v52 = v73;
        }
        uint32_t v74 = *v53; // 0x80a60ec
        while (v74 != 0) {
            // 0x80a60f6
            v56 = 1 - v57 + v56 + v74;
            if (v74 <= v56) {
                // break -> 0x80a6128
                break;
            }
            v57 = v74;
            v58 = 76 * v56 + *(int32_t *)(Element + 256);
            if (Data != 0) {
                // 0x80a6018
                v59 = *v55;
                if (v59 != 0) {
                    // 0x80a6022
                    r_delete_entry(v59, v58);
                }
                // 0x80a602e
                SetPinBoundingBox(v58);
                v60 = *v55;
                v61 = v60;
                if (v60 == 0) {
                    // 0x80a62b8
                    v61 = r_create_tree(0, 0, 0);
                    *v55 = v61;
                }
                // 0x80a6044
                r_insert_entry(v61, v58, 0);
            } else {
                // 0x80a6118
                SetPinBoundingBox(v58);
            }
            // 0x80a6058
            v62 = *(int32_t *)v58;
            if (v62 < *v9) {
                // 0x80a605e
                *v9 = v62;
            }
            // 0x80a6060
            v63 = *(int32_t *)(v58 + 4);
            if (v63 < *v8) {
                // 0x80a6068
                *v8 = v63;
            }
            // 0x80a606b
            v64 = *(int32_t *)(v58 + 8);
            if (v64 > *v11) {
                // 0x80a6073
                *v11 = v64;
            }
            // 0x80a6076
            v65 = *(int32_t *)(v58 + 12);
            if (v65 > *v10) {
                // 0x80a607e
                *v10 = v65;
            }
            // 0x80a6081
            v66 = *(int32_t *)(v58 + 52);
            v67 = *(int32_t *)(v58 + 36);
            v68 = (v67 + (int32_t)(v67 < 0)) / 2;
            v69 = v66 - v68;
            if (v69 < *v49) {
                // 0x80a60a5
                *v49 = v69;
            }
            // 0x80a60ab
            v70 = *(int32_t *)(v58 + 56);
            v71 = v70 - v68;
            if (v71 < *v50) {
                // 0x80a60b8
                *v50 = v71;
            }
            // 0x80a60be
            v72 = v68 + v66;
            if (v72 > *v51) {
                // 0x80a60d6
                *v51 = v72;
            }
            // 0x80a60dc
            v73 = v70 + v68;
            if (v73 > *v52) {
                // 0x80a60e6
                *v52 = v73;
            }
            // 0x80a60ec
            v74 = *v53;
        }
    }
    int32_t * v75 = (int32_t *)(Element + 232); // 0x80a6128
    int32_t v76 = *v75; // 0x80a6128
    int32_t * v77 = (int32_t *)(Element + 260);
    int32_t * v78 = (int32_t *)(Data + 52);
    int32_t v79 = 0; // 0x80a613c
    int32_t v80 = 0; // 0x80a613c
    int32_t v81; // 0x80a5df0
    uint32_t v82; // 0x80a5df0
    int32_t v83; // 0x80a5df0
    int32_t v84; // 0x80a63b8
    int32_t v85; // 0x80a63bb
    int32_t v86; // 0x80a63be
    int32_t v87; // 0x80a63c0
    while (true) {
        // 0x80a613f
        v82 = v76;
        if (v82 == 0) {
            // break (via goto) -> 0x80a62e0
            goto lab_0x80a62e0;
        }
        if (v82 <= v79) {
            // 0x80a63b8
            v84 = *v8;
            v85 = *v11;
            v86 = *v9;
            v87 = *v10;
            v83 = 0;
            v81 = *v77;
            goto lab_0x80a63e0;
        }
        int32_t v88 = *v77 + v80; // 0x80a6261
        int32_t v89; // 0x80a62a7
        int32_t v90; // 0x80a614b
        int32_t v91; // 0x80a6169
        if (Data != 0) {
            // 0x80a6148
            v90 = *v78;
            if (v90 != 0) {
                // 0x80a6152
                r_delete_entry(v90, v88);
            }
            // 0x80a615e
            SetPadBoundingBox(v88);
            v91 = *v78;
            v89 = v91;
            if (v91 == 0) {
                // 0x80a6290
                v89 = r_create_tree(0, 0, 0);
                *v78 = v89;
            }
            // 0x80a6174
            r_insert_entry(v89, v88, 0);
        } else {
            // 0x80a626f
            SetPadBoundingBox(v88);
        }
        int32_t v92 = *(int32_t *)v88; // 0x80a6188
        if (v92 < *v9) {
            // 0x80a618e
            *v9 = v92;
        }
        int32_t v93 = *(int32_t *)(v88 + 4); // 0x80a6190
        if (v93 < *v8) {
            // 0x80a6198
            *v8 = v93;
        }
        int32_t v94 = *(int32_t *)(v88 + 8); // 0x80a619b
        if (v94 > *v11) {
            // 0x80a61a3
            *v11 = v94;
        }
        int32_t v95 = *(int32_t *)(v88 + 12); // 0x80a61a6
        if (v95 > *v10) {
            // 0x80a61ae
            *v10 = v95;
        }
        int32_t v96 = *(int32_t *)(v88 + 36); // 0x80a61b1
        int32_t v97 = *(int32_t *)(v88 + 64); // 0x80a61b4
        int32_t v98 = (v96 + (int32_t)(v96 < 0)) / 2; // 0x80a61c1
        int32_t v99 = *(int32_t *)(v88 + 44); // 0x80a61c3
        int32_t v100 = v99 - v97; // 0x80a61cb
        int32_t v101 = v100 == 0 | v100 < 0 != ((v100 ^ v99) & (v99 ^ v97)) < 0 ? v99 : v97; // 0x80a61ce
        int32_t v102 = v101 - v98; // 0x80a61d1
        if (v102 < *v49) {
            // 0x80a61dc
            *v49 = v102;
        }
        int32_t v103 = *(int32_t *)(v88 + 68); // 0x80a61e2
        int32_t v104 = *(int32_t *)(v88 + 48); // 0x80a61e8
        int32_t v105 = v104 - v103; // 0x80a61ee
        int32_t v106 = v105 == 0 | v105 < 0 != ((v105 ^ v104) & (v104 ^ v103)) < 0 ? v104 : v103; // 0x80a61f1
        int32_t v107 = v106 - v98; // 0x80a61f4
        if (v107 < *v50) {
            // 0x80a61ff
            *v50 = v107;
        }
        int32_t v108 = (v100 < 0 == ((v100 ^ v99) & (v99 ^ v97)) < 0 ? v99 : v97) + v98; // 0x80a6216
        if (v108 > *v51) {
            // 0x80a6221
            *v51 = v108;
        }
        int32_t v109 = (v105 < 0 == ((v105 ^ v104) & (v104 ^ v103)) < 0 ? v104 : v103) + v98; // 0x80a622e
        if (v109 > *v52) {
            // 0x80a6239
            *v52 = v109;
        }
        int32_t v110 = *v75; // 0x80a623f
        while (v110 != v76) {
            // 0x80a624a
            v82 = v110;
            if (v82 == 0) {
                // break (via goto) -> 0x80a62e0
                goto lab_0x80a62e0;
            }
            if (v82 <= v79) {
                // 0x80a63b8
                v84 = *v8;
                v85 = *v11;
                v86 = *v9;
                v87 = *v10;
                v83 = 0;
                v81 = *v77;
                goto lab_0x80a63e0;
            }
            // 0x80a625b
            v88 = *v77 + v80;
            if (Data != 0) {
                // 0x80a6148
                v90 = *v78;
                if (v90 != 0) {
                    // 0x80a6152
                    r_delete_entry(v90, v88);
                }
                // 0x80a615e
                SetPadBoundingBox(v88);
                v91 = *v78;
                v89 = v91;
                if (v91 == 0) {
                    // 0x80a6290
                    v89 = r_create_tree(0, 0, 0);
                    *v78 = v89;
                }
                // 0x80a6174
                r_insert_entry(v89, v88, 0);
            } else {
                // 0x80a626f
                SetPadBoundingBox(v88);
            }
            // 0x80a6188
            v92 = *(int32_t *)v88;
            if (v92 < *v9) {
                // 0x80a618e
                *v9 = v92;
            }
            // 0x80a6190
            v93 = *(int32_t *)(v88 + 4);
            if (v93 < *v8) {
                // 0x80a6198
                *v8 = v93;
            }
            // 0x80a619b
            v94 = *(int32_t *)(v88 + 8);
            if (v94 > *v11) {
                // 0x80a61a3
                *v11 = v94;
            }
            // 0x80a61a6
            v95 = *(int32_t *)(v88 + 12);
            if (v95 > *v10) {
                // 0x80a61ae
                *v10 = v95;
            }
            // 0x80a61b1
            v96 = *(int32_t *)(v88 + 36);
            v97 = *(int32_t *)(v88 + 64);
            v98 = (v96 + (int32_t)(v96 < 0)) / 2;
            v99 = *(int32_t *)(v88 + 44);
            v100 = v99 - v97;
            v101 = v100 == 0 | v100 < 0 != ((v100 ^ v99) & (v99 ^ v97)) < 0 ? v99 : v97;
            v102 = v101 - v98;
            if (v102 < *v49) {
                // 0x80a61dc
                *v49 = v102;
            }
            // 0x80a61e2
            v103 = *(int32_t *)(v88 + 68);
            v104 = *(int32_t *)(v88 + 48);
            v105 = v104 - v103;
            v106 = v105 == 0 | v105 < 0 != ((v105 ^ v104) & (v104 ^ v103)) < 0 ? v104 : v103;
            v107 = v106 - v98;
            if (v107 < *v50) {
                // 0x80a61ff
                *v50 = v107;
            }
            // 0x80a6205
            v108 = (v100 < 0 == ((v100 ^ v99) & (v99 ^ v97)) < 0 ? v99 : v97) + v98;
            if (v108 > *v51) {
                // 0x80a6221
                *v51 = v108;
            }
            // 0x80a6227
            v109 = (v105 < 0 == ((v105 ^ v104) & (v104 ^ v103)) < 0 ? v104 : v103) + v98;
            if (v109 > *v52) {
                // 0x80a6239
                *v52 = v109;
            }
            // 0x80a623f
            v110 = *v75;
        }
        // 0x80a6280
        v79++;
        v80 += 104;
    }
  lab_0x80a62e0:;
    int32_t v111 = *v9; // 0x80a62f1
    int32_t v112 = *v11; // 0x80a62f1
    int32_t v113 = *v8; // 0x80a62f1
    int32_t v114 = *v10; // 0x80a62f1
    goto lab_0x80a62f4;
  lab_0x80a62f4:;
    int32_t v115 = *v53;
    if (v112 - v111 > v114 - v113) {
        if (v115 != 0) {
            int32_t v116 = *(int32_t *)(Element + 256); // 0x80a630b
            int32_t * v117 = (int32_t *)(v116 + 20); // 0x80a6316
            *v117 = *v117 | 0x4000;
            int32_t v118 = v116; // 0x80a632f
            if (v115 != 1) {
                int32_t * v119 = (int32_t *)(v118 + 96); // 0x80a6320
                *v119 = *v119 | 0x4000;
                while (2 != v115) {
                    // 0x80a6320
                    v119 = (int32_t *)(v118 + 96);
                    *v119 = *v119 | 0x4000;
                    int32_t v120; // 0x80a5df0
                    int32_t v121 = v120 + 1; // 0x80a6327
                    v120 = v121;
                    v118 += 76;
                }
            }
        }
    } else {
        if (v115 != 0) {
            int32_t v122 = *(int32_t *)(Element + 256); // 0x80a638a
            int32_t * v123 = (int32_t *)(v122 + 20); // 0x80a6395
            *v123 = *v123 & -0x4001;
            int32_t v124 = v122; // 0x80a63af
            if (v115 != 1) {
                int32_t * v125 = (int32_t *)(v124 + 96); // 0x80a63a0
                *v125 = *v125 & -0x4001;
                int32_t v126 = 2; // 0x80a63a7
                int32_t v127 = v126; // 0x80a63af
                v124 += 76;
                while (v126 != v115) {
                    // 0x80a63a0
                    v125 = (int32_t *)(v124 + 96);
                    *v125 = *v125 & -0x4001;
                    v126 = v127 + 1;
                    v127 = v126;
                    v124 += 76;
                }
            }
        }
    }
    // 0x80a6331
    *v10 = *v10 + 1;
    *v51 = *v51 + 1;
    *v52 = *v52 + 1;
    *v11 = v112 + 1;
    if (Data == 0) {
        // 0x80a644c
        return;
    }
    int32_t * v128 = (int32_t *)(Data + 44); // 0x80a635a
    int32_t v129 = *v128; // 0x80a635a
    int32_t v130 = v129; // 0x80a635f
    if (v129 == 0) {
        int32_t v131 = r_create_tree(0, 0, 0); // 0x80a6494
        *v128 = v131;
        v130 = v131;
    }
    // 0x80a6365
    r_insert_entry(v130, Element, 0);
  lab_0x80a63e0:;
    int32_t v132 = v81;
    int32_t v133 = *(int32_t *)(v132 + 48); // 0x80a63e0
    int32_t v134 = *(int32_t *)(v132 + 68); // 0x80a63e3
    if (v133 == v134) {
        int32_t v135 = *(int32_t *)(v132 + 64); // 0x80a641e
        if (v85 - v135 < *(int32_t *)(v132 + 44) - v86) {
            goto lab_0x80a63f4;
        } else {
            goto lab_0x80a6428;
        }
    } else {
        if (v87 - v134 < v133 - v84) {
            goto lab_0x80a63f4;
        } else {
            goto lab_0x80a6428;
        }
    }
  lab_0x80a63f4:;
    int32_t * v136 = (int32_t *)(v132 + 20); // 0x80a63f4
    *v136 = *v136 | 0x4000;
    goto lab_0x80a63fb;
  lab_0x80a6428:;
    int32_t * v138 = (int32_t *)(v132 + 20); // 0x80a6428
    *v138 = *v138 & -0x4001;
    goto lab_0x80a63fb;
  lab_0x80a63fb:;
    int32_t v137 = v83 + 1; // 0x80a63fb
    v111 = v86;
    v112 = v85;
    v113 = v84;
    v114 = v87;
    v83 = v137;
    v81 = v132 + 104;
    if (v137 < v82) {
        goto lab_0x80a63e0;
    } else {
        goto lab_0x80a62f4;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a65a0 - 0x80a6640
// Line range:    1731 - 1747
int32_t OldFlags(int32_t flags) {
    // 0x80a65a0
    int32_t v1; // 0x80a65a0
    uint32_t v2 = v1;
    int32_t v3 = __readgsdword(20); // 0x80a65b4
    int32_t v4 = 0x10000; // 0x80a65dc
    uint32_t v5 = 0;
    int32_t v6; // bp-4, 0x80a65a0
    char * v7; // 0x80a65fb
    if ((v4 & v2) != 0) {
        // 0x80a65e6
        v7 = (char *)((int32_t)&v6 - 36 + v5 / 2);
        *v7 = *v7 | (char)(1 << (4 * v5 & 4));
    }
    while (v5 != 7) {
        // 0x80a65e0
        v4 *= 2;
        v5++;
        if ((v4 & v2) != 0) {
            // 0x80a65e6
            v7 = (char *)((int32_t)&v6 - 36 + v5 / 2);
            *v7 = *v7 | (char)(1 << (4 * v5 & 4));
        }
    }
    int32_t v8 = __readgsdword(20); // 0x80a6610
    *(int32_t *)flags = v2 % 0x10000;
    *(int32_t *)(flags + 4) = 0;
    *(int32_t *)(flags + 8) = 0;
    if (v3 == v8) {
        // 0x80a6629
        return flags;
    }
    // 0x80a6633
    __stack_chk_fail();
    return &g231;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/misc.c
// Address range: 0x80a6640 - 0x80a6690
// Line range:    1721 - 1727
int32_t MakeFlags(int32_t flags) {
    int32_t v1 = __readgsdword(20); // 0x80a6646
    int32_t v2 = __readgsdword(20); // 0x80a666e
    *(int32_t *)(flags + 4) = 0;
    *(int32_t *)(flags + 8) = 0;
    if (v1 == v2) {
        // 0x80a6685
        return flags;
    }
    // 0x80a6689
    __stack_chk_fail();
    return &g231;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/move.c
// Address range: 0x80a68a0 - 0x80a68bc
// Line range:    1168 - 1168
void register_move_action_list(void) {
    // 0x80a68a0
    hid_register_actions((int32_t)&move_action_list, 1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/move.c
// Address range: 0x80a8490 - 0x80a8858
// Line range:    116 - 175
void MoveElementLowLevel(int32_t Data, int32_t Element, int32_t DX, int32_t DY) {
    if (Data != 0) {
        // 0x80a84ac
        r_delete_entry(*(int32_t *)(Data + 44), Element);
    }
    int32_t v1 = *(int32_t *)(Element + 240); // 0x80a84c1
    if (v1 != 0) {
        int32_t v2 = 88 * v1; // 0x80a84da
        int32_t v3 = v1; // 0x80a84da
        v3--;
        v2 -= 88;
        int32_t v4 = *(int32_t *)(Element + 264) + v2; // 0x80a84eb
        int32_t * v5 = (int32_t *)(v4 + 48); // 0x80a84f1
        *v5 = *v5 + DY;
        int32_t * v6 = (int32_t *)(v4 + 68); // 0x80a84f4
        *v6 = *v6 + DY;
        int32_t * v7 = (int32_t *)(v4 + 44); // 0x80a84f7
        *v7 = *v7 + DX;
        int32_t * v8 = (int32_t *)(v4 + 64); // 0x80a84fa
        *v8 = *v8 + DX;
        SetLineBoundingBox(v4);
        while (v3 != 0) {
            // 0x80a84e0
            v3--;
            v2 -= 88;
            v4 = *(int32_t *)(Element + 264) + v2;
            v5 = (int32_t *)(v4 + 48);
            *v5 = *v5 + DY;
            v6 = (int32_t *)(v4 + 68);
            *v6 = *v6 + DY;
            v7 = (int32_t *)(v4 + 44);
            *v7 = *v7 + DX;
            v8 = (int32_t *)(v4 + 64);
            *v8 = *v8 + DX;
            SetLineBoundingBox(v4);
        }
    }
    int32_t * v9 = (int32_t *)(Element + 224); // 0x80a8513
    int32_t v10 = *v9; // 0x80a8513
    if (v10 != 0) {
        int32_t * v11 = (int32_t *)(Data + 48);
        char * v12 = (char *)Element;
        int32_t v13 = 0; // 0x80a853c
        int32_t v14 = v10;
        int32_t v15 = 76 * v13 + *(int32_t *)(Element + 256); // 0x80a8550
        if (Data != 0) {
            // 0x80a855a
            r_delete_entry(*v11, v15);
            RestoreToPolygon(Data, 256, v12, (char *)v15);
        }
        int32_t * v16 = (int32_t *)(v15 + 52); // 0x80a8590
        *v16 = *v16 + DX;
        int32_t * v17 = (int32_t *)(v15 + 56); // 0x80a8593
        *v17 = *v17 + DY;
        int32_t * v18 = (int32_t *)v15; // 0x80a8596
        *v18 = *v18 + DX;
        int32_t * v19 = (int32_t *)(v15 + 4); // 0x80a8598
        *v19 = *v19 + DY;
        int32_t * v20 = (int32_t *)(v15 + 8); // 0x80a859b
        *v20 = *v20 + DX;
        int32_t * v21 = (int32_t *)(v15 + 12); // 0x80a859e
        *v21 = *v21 + DY;
        if (Data != 0) {
            // 0x80a85a5
            r_insert_entry(*v11, v15, 0);
            ClearFromPolygon(Data, 256, v12, (char *)v15);
        }
        uint32_t v22 = *v9; // 0x80a85e6
        while (v22 != 0) {
            // 0x80a8538
            v13 = 1 - v14 + v13 + v22;
            if (v22 <= v13) {
                // break -> 0x80a85fb
                break;
            }
            v14 = v22;
            v15 = 76 * v13 + *(int32_t *)(Element + 256);
            if (Data != 0) {
                // 0x80a855a
                r_delete_entry(*v11, v15);
                RestoreToPolygon(Data, 256, v12, (char *)v15);
            }
            // 0x80a8590
            v16 = (int32_t *)(v15 + 52);
            *v16 = *v16 + DX;
            v17 = (int32_t *)(v15 + 56);
            *v17 = *v17 + DY;
            v18 = (int32_t *)v15;
            *v18 = *v18 + DX;
            v19 = (int32_t *)(v15 + 4);
            *v19 = *v19 + DY;
            v20 = (int32_t *)(v15 + 8);
            *v20 = *v20 + DX;
            v21 = (int32_t *)(v15 + 12);
            *v21 = *v21 + DY;
            if (Data != 0) {
                // 0x80a85a5
                r_insert_entry(*v11, v15, 0);
                ClearFromPolygon(Data, 256, v12, (char *)v15);
            }
            // 0x80a85e3
            v22 = *v9;
        }
    }
    int32_t * v23 = (int32_t *)(Element + 232); // 0x80a85fb
    uint32_t v24 = *v23; // 0x80a85fb
    if (v24 != 0 && v24 != 0) {
        int32_t * v25 = (int32_t *)(Data + 52);
        char * v26 = (char *)Element;
        uint32_t v27 = 0;
        int32_t v28; // 0x80a8490
        uint32_t v29; // 0x80a8490
        int32_t v30; // 0x80a86af
        char * v31; // 0x80a864a
        int32_t * v32; // 0x80a8655
        int32_t * v33; // 0x80a8658
        int32_t * v34; // 0x80a865b
        int32_t * v35; // 0x80a865e
        int32_t v36; // 0x80a8698
        int32_t * v37; // 0x80a86c3
        int32_t * v38; // 0x80a86c6
        int32_t * v39; // 0x80a86c9
        int32_t * v40; // 0x80a86cc
        int32_t v41; // 0x80a86d7
        while (true) {
            // 0x80a86ac
            v30 = *(int32_t *)(Element + 260);
            if (Data != 0) {
                // 0x80a8628
                r_delete_entry(*v25, v30);
                v31 = (char *)v30;
                RestoreToPolygon(Data, 512, v26, v31);
                v32 = (int32_t *)(v30 + 44);
                *v32 = *v32 + DX;
                v33 = (int32_t *)(v30 + 48);
                *v33 = *v33 + DY;
                v34 = (int32_t *)(v30 + 64);
                *v34 = *v34 + DX;
                v35 = (int32_t *)(v30 + 68);
                *v35 = *v35 + DY;
                SetPadBoundingBox(v30);
                r_insert_entry(*v25, v30, 0);
                ClearFromPolygon(Data, 512, v26, v31);
                v36 = *v23;
                v28 = v36;
                if (v36 == v24) {
                    // break -> 0x80a86e2
                    break;
                }
            } else {
                // 0x80a86bd
                v37 = (int32_t *)(v30 + 44);
                *v37 = *v37 + DX;
                v38 = (int32_t *)(v30 + 64);
                *v38 = *v38 + DX;
                v39 = (int32_t *)(v30 + 48);
                *v39 = *v39 + DY;
                v40 = (int32_t *)(v30 + 68);
                *v40 = *v40 + DY;
                SetPadBoundingBox(v30);
                v41 = *v23;
                v28 = v41;
                if (v41 == v24) {
                    // break -> 0x80a86e2
                    break;
                }
            }
            // 0x80a86a3
            v29 = v28;
            if (v29 == 0 || v27 >= v29) {
                // break (via goto) -> 0x80a86f0
                goto lab_0x80a86f0;
            }
        }
        int32_t v42 = v27 + 1; // 0x80a86e2
        int32_t v43 = 104 * v42; // 0x80a86a5
        while (v42 < v24) {
            // 0x80a86ac
            v27 = v42;
            while (true) {
                // 0x80a86ac
                v30 = *(int32_t *)(Element + 260) + v43;
                if (Data != 0) {
                    // 0x80a8628
                    r_delete_entry(*v25, v30);
                    v31 = (char *)v30;
                    RestoreToPolygon(Data, 512, v26, v31);
                    v32 = (int32_t *)(v30 + 44);
                    *v32 = *v32 + DX;
                    v33 = (int32_t *)(v30 + 48);
                    *v33 = *v33 + DY;
                    v34 = (int32_t *)(v30 + 64);
                    *v34 = *v34 + DX;
                    v35 = (int32_t *)(v30 + 68);
                    *v35 = *v35 + DY;
                    SetPadBoundingBox(v30);
                    r_insert_entry(*v25, v30, 0);
                    ClearFromPolygon(Data, 512, v26, v31);
                    v36 = *v23;
                    v28 = v36;
                    if (v36 == v24) {
                        // break -> 0x80a86e2
                        break;
                    }
                } else {
                    // 0x80a86bd
                    v37 = (int32_t *)(v30 + 44);
                    *v37 = *v37 + DX;
                    v38 = (int32_t *)(v30 + 64);
                    *v38 = *v38 + DX;
                    v39 = (int32_t *)(v30 + 48);
                    *v39 = *v39 + DY;
                    v40 = (int32_t *)(v30 + 68);
                    *v40 = *v40 + DY;
                    SetPadBoundingBox(v30);
                    v41 = *v23;
                    v28 = v41;
                    if (v41 == v24) {
                        // break -> 0x80a86e2
                        break;
                    }
                }
                // 0x80a86a3
                v29 = v28;
                if (v29 == 0 || v27 >= v29) {
                    // break (via goto) -> 0x80a86f0
                    goto lab_0x80a86f0;
                }
            }
            // 0x80a86e2
            v42 = v27 + 1;
            v43 = 104 * v42;
        }
    }
  lab_0x80a86f0:;
    int32_t v44 = *(int32_t *)(Element + 248); // 0x80a86f5
    if (v44 != 0) {
        int32_t v45 = v44; // 0x80a8715
        int32_t v46 = 68 * v44 - 68 + *(int32_t *)(Element + 268); // 0x80a8715
        v45--;
        int32_t * v47 = (int32_t *)(v46 + 52); // 0x80a871b
        *v47 = *v47 + DX;
        int32_t * v48 = (int32_t *)(v46 + 56); // 0x80a871e
        *v48 = *v48 + DY;
        int32_t * v49 = (int32_t *)v46; // 0x80a8721
        *v49 = *v49 + DX;
        int32_t * v50 = (int32_t *)(v46 + 4); // 0x80a8723
        *v50 = *v50 + DY;
        int32_t * v51 = (int32_t *)(v46 + 8); // 0x80a8726
        *v51 = *v51 + DX;
        int32_t * v52 = (int32_t *)(v46 + 12); // 0x80a8729
        *v52 = *v52 + DY;
        v46 -= 68;
        while (v45 != 0) {
            // 0x80a8718
            v45--;
            v47 = (int32_t *)(v46 + 52);
            *v47 = *v47 + DX;
            v48 = (int32_t *)(v46 + 56);
            *v48 = *v48 + DY;
            v49 = (int32_t *)v46;
            *v49 = *v49 + DX;
            v50 = (int32_t *)(v46 + 4);
            *v50 = *v50 + DY;
            v51 = (int32_t *)(v46 + 8);
            *v51 = *v51 + DX;
            v52 = (int32_t *)(v46 + 12);
            *v52 = *v52 + DY;
            v46 -= 68;
        }
    }
    int32_t v53 = Data + 56;
    int32_t v54 = Element; // 0x80a8743
    int32_t v55 = 2;
    int32_t v56 = Element + 36 + 60 * v55; // 0x80a874e
    int32_t v57; // 0x80a8757
    if (Data != 0) {
        // 0x80a8757
        v57 = 4 * v55;
        if (*(int32_t *)(v57 + v53) != 0) {
            // 0x80a875f
            r_delete_entry(*(int32_t *)(v57 + 56 + *(int32_t *)(PCB + 0x220c)), v56);
        }
    }
    int32_t * v58 = (int32_t *)(v54 + 156); // 0x80a8783
    *v58 = *v58 + DX;
    int32_t * v59 = (int32_t *)(v54 + 160); // 0x80a8789
    *v59 = *v59 + DY;
    int32_t * v60 = (int32_t *)(v54 + 164); // 0x80a878f
    *v60 = *v60 + DX;
    int32_t * v61 = (int32_t *)(v54 + 168); // 0x80a8795
    *v61 = *v61 + DY;
    int32_t * v62 = (int32_t *)(v54 + 196); // 0x80a879b
    *v62 = *v62 + DX;
    int32_t * v63 = (int32_t *)(v54 + 200); // 0x80a87a1
    *v63 = *v63 + DY;
    int32_t v64; // 0x80a87ab
    if (Data != 0) {
        // 0x80a87ab
        v64 = 4 * v55;
        if (*(int32_t *)(v64 + v53) != 0) {
            // 0x80a87b3
            r_insert_entry(*(int32_t *)(v64 + 56 + *(int32_t *)(PCB + 0x220c)), v56, 0);
        }
    }
    // 0x80a87df
    v54 -= 60;
    int32_t v65 = v55 - 1; // 0x80a87e8
    while (v55 != 0) {
        // 0x80a8746
        v55 = v65;
        v56 = Element + 36 + 60 * v55;
        if (Data != 0) {
            // 0x80a8757
            v57 = 4 * v55;
            if (*(int32_t *)(v57 + v53) != 0) {
                // 0x80a875f
                r_delete_entry(*(int32_t *)(v57 + 56 + *(int32_t *)(PCB + 0x220c)), v56);
            }
        }
        // 0x80a8780
        v58 = (int32_t *)(v54 + 156);
        *v58 = *v58 + DX;
        v59 = (int32_t *)(v54 + 160);
        *v59 = *v59 + DY;
        v60 = (int32_t *)(v54 + 164);
        *v60 = *v60 + DX;
        v61 = (int32_t *)(v54 + 168);
        *v61 = *v61 + DY;
        v62 = (int32_t *)(v54 + 196);
        *v62 = *v62 + DX;
        v63 = (int32_t *)(v54 + 200);
        *v63 = *v63 + DY;
        if (Data != 0) {
            // 0x80a87ab
            v64 = 4 * v55;
            if (*(int32_t *)(v64 + v53) != 0) {
                // 0x80a87b3
                r_insert_entry(*(int32_t *)(v64 + 56 + *(int32_t *)(PCB + 0x220c)), v56, 0);
            }
        }
        // 0x80a87df
        v54 -= 60;
        v65 = v55 - 1;
    }
    int32_t * v66 = (int32_t *)(Element + 4); // 0x80a87f4
    *v66 = *v66 + DY;
    int32_t * v67 = (int32_t *)(Element + 12); // 0x80a87f7
    *v67 = *v67 + DY;
    int32_t * v68 = (int32_t *)(Element + 276); // 0x80a87fa
    *v68 = *v68 + DY;
    int32_t * v69 = (int32_t *)(Element + 284); // 0x80a8800
    *v69 = *v69 + DY;
    int32_t * v70 = (int32_t *)(Element + 220); // 0x80a8806
    *v70 = *v70 + DY;
    int32_t * v71 = (int32_t *)Element; // 0x80a880f
    *v71 = *v71 + DX;
    int32_t * v72 = (int32_t *)(Element + 8); // 0x80a8811
    *v72 = *v72 + DX;
    int32_t * v73 = (int32_t *)(Element + 272); // 0x80a8814
    *v73 = *v73 + DX;
    int32_t * v74 = (int32_t *)(Element + 280); // 0x80a881a
    *v74 = *v74 + DX;
    int32_t * v75 = (int32_t *)(Element + 216); // 0x80a8820
    *v75 = *v75 + DX;
    if (Data == 0) {
        // 0x80a8850
        return;
    }
    // 0x80a882a
    r_insert_entry(*(int32_t *)(Data + 44), Element, 0);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa040 - 0x80aa052
// Line range:    1053 - 1057
void DSClearString(int32_t Ptr) {
    int32_t v1 = *(int32_t *)(Ptr + 4); // 0x80aa046
    if (v1 != 0) {
        // 0x80aa04d
        *(char *)v1 = 0;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa060 - 0x80aa07a
// Line range:    996 - 1003
void SaveFree(char * Ptr) {
    // 0x80aa060
    if (Ptr == NULL) {
        // 0x80aa078
        return;
    }
    // 0x80aa06d
    int32_t v1; // 0x80aa060
    free((int32_t *)v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa080 - 0x80aa0e4
// Line range:    809 - 821
void FreeAttributeListMemory(int32_t list) {
    // 0x80aa080
    int32_t v1; // 0x80aa080
    int32_t * v2 = (int32_t *)(v1 + 8);
    int32_t v3 = 0; // 0x80aa08f
    if (v1 < 1) {
        // 0x80aa0c3
        SaveFree((char *)*v2);
        *v2 = 0;
        *(int32_t *)(v1 + 4) = 0;
        return;
    }
    int32_t v4 = 8 * v3; // 0x80aa09b
    v3++;
    SaveFree((char *)*(int32_t *)(*v2 + v4));
    SaveFree((char *)*(int32_t *)(*v2 + (v4 | 4)));
    while (v3 < (int32_t)&g231) {
        // 0x80aa098
        v4 = 8 * v3;
        v3++;
        SaveFree((char *)*(int32_t *)(*v2 + v4));
        SaveFree((char *)*(int32_t *)(*v2 + (v4 | 4)));
    }
    // 0x80aa0c3
    SaveFree((char *)*v2);
    *v2 = 0;
    *(int32_t *)(v1 + 4) = 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa0f0 - 0x80aa1be
// Line range:    970 - 988
void FreeLibraryMemory(int32_t lib) {
    int32_t * v1 = (int32_t *)lib; // 0x80aa0fc
    int32_t v2 = *v1; // 0x80aa0fc
    int32_t * v3; // 0x80aa0f0
    if (v2 == 0) {
        // 0x80aa0f0
        v3 = (int32_t *)(lib + 8);
    } else {
        int32_t * v4 = (int32_t *)(lib + 8);
        int32_t v5 = v2; // 0x80aa116
        int32_t v6 = 28 * v2; // 0x80aa116
        v6 -= 28;
        int32_t v7 = v6 + *v4; // 0x80aa11e
        int32_t v8 = *(int32_t *)(v7 + 12); // 0x80aa121
        int32_t * v9; // 0x80aa0f0
        int32_t v10; // 0x80aa0f0
        int32_t v11; // 0x80aa0f0
        int32_t v12; // 0x80aa14b
        int32_t * v13; // 0x80aa0f0
        if (v8 == 0) {
            // 0x80aa118
            v9 = (int32_t *)(v7 + 20);
        } else {
            // 0x80aa12f
            v13 = (int32_t *)(v7 + 20);
            v10 = v8;
            v11 = 24 * v8;
            v11 -= 24;
            v10--;
            v12 = v11 + *v13;
            SaveFree((char *)*(int32_t *)(v12 + 4));
            SaveFree((char *)*(int32_t *)v12);
            v9 = v13;
            while (v10 != 0) {
                // 0x80aa140
                v11 -= 24;
                v10--;
                v12 = v11 + *v13;
                SaveFree((char *)*(int32_t *)(v12 + 4));
                SaveFree((char *)*(int32_t *)v12);
                v9 = v13;
            }
        }
        // 0x80aa168
        v5--;
        SaveFree((char *)*v9);
        SaveFree((char *)*(int32_t *)v7);
        v3 = v4;
        while (v5 != 0) {
            // 0x80aa118
            v6 -= 28;
            v7 = v6 + *v4;
            v8 = *(int32_t *)(v7 + 12);
            if (v8 == 0) {
                // 0x80aa118
                v9 = (int32_t *)(v7 + 20);
            } else {
                // 0x80aa12f
                v13 = (int32_t *)(v7 + 20);
                v10 = v8;
                v11 = 24 * v8;
                v11 -= 24;
                v10--;
                v12 = v11 + *v13;
                SaveFree((char *)*(int32_t *)(v12 + 4));
                SaveFree((char *)*(int32_t *)v12);
                v9 = v13;
                while (v10 != 0) {
                    // 0x80aa140
                    v11 -= 24;
                    v10--;
                    v12 = v11 + *v13;
                    SaveFree((char *)*(int32_t *)(v12 + 4));
                    SaveFree((char *)*(int32_t *)v12);
                    v9 = v13;
                }
            }
            // 0x80aa168
            v5--;
            SaveFree((char *)*v9);
            SaveFree((char *)*(int32_t *)v7);
            v3 = v4;
        }
    }
    // 0x80aa191
    SaveFree((char *)*v3);
    *v1 = 0;
    *(int32_t *)(lib + 4) = 0;
    *v3 = 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa1c0 - 0x80aa33e
// Line range:    827 - 855
void FreeElementMemory(int32_t Element) {
    if (Element == 0) {
        // 0x80aa336
        return;
    }
    // 0x80aa1d4
    SaveFree((char *)*(int32_t *)(Element + 208));
    SaveFree((char *)*(int32_t *)(Element + 148));
    SaveFree((char *)*(int32_t *)(Element + 88));
    int32_t * v1 = (int32_t *)(Element + 224); // 0x80aa1fb
    int32_t v2 = *v1; // 0x80aa1fb
    if (v2 != 0) {
        int32_t v3 = 0; // 0x80aa214
        int32_t v4 = v2;
        int32_t v5 = 76 * v3 + *(int32_t *)(Element + 256); // 0x80aa221
        int32_t * v6 = (int32_t *)(v5 + 60); // 0x80aa227
        SaveFree((char *)*v6);
        int32_t * v7 = (int32_t *)(v5 + 64); // 0x80aa232
        *v6 = 0;
        SaveFree((char *)*v7);
        uint32_t v8 = *v1; // 0x80aa244
        *v7 = 0;
        while (v8 != 0) {
            // 0x80aa210
            v3 = 1 - v4 + v3 + v8;
            if (v8 <= v3) {
                // break -> 0x80aa255
                break;
            }
            v4 = v8;
            v5 = 76 * v3 + *(int32_t *)(Element + 256);
            v6 = (int32_t *)(v5 + 60);
            SaveFree((char *)*v6);
            v7 = (int32_t *)(v5 + 64);
            *v6 = 0;
            SaveFree((char *)*v7);
            v8 = *v1;
            *v7 = 0;
        }
    }
    int32_t * v9 = (int32_t *)(Element + 232); // 0x80aa255
    int32_t v10 = *v9; // 0x80aa255
    int32_t * v11 = (int32_t *)(Element + 260);
    int32_t v12 = 0; // 0x80aa264
    int32_t v13 = 0; // 0x80aa264
    while (true) {
        uint32_t v14 = v10;
        if (v14 == 0 || v13 >= v14) {
            // break (via goto) -> 0x80aa2c0
            goto lab_0x80aa2c0;
        }
        int32_t v15 = *v11 + v12; // 0x80aa27b
        int32_t * v16 = (int32_t *)(v15 + 88); // 0x80aa281
        SaveFree((char *)*v16);
        int32_t * v17 = (int32_t *)(v15 + 92); // 0x80aa28c
        *v16 = 0;
        SaveFree((char *)*v17);
        int32_t v18 = *v9; // 0x80aa29e
        *v17 = 0;
        while (v18 != v10) {
            // 0x80aa270
            v14 = v18;
            if (v14 == 0 || v13 >= v14) {
                // break (via goto) -> 0x80aa2c0
                goto lab_0x80aa2c0;
            }
            // 0x80aa278
            v15 = *v11 + v12;
            v16 = (int32_t *)(v15 + 88);
            SaveFree((char *)*v16);
            v17 = (int32_t *)(v15 + 92);
            *v16 = 0;
            SaveFree((char *)*v17);
            v18 = *v9;
            *v17 = 0;
        }
        // 0x80aa2b0
        v12 += 104;
        v13++;
    }
  lab_0x80aa2c0:;
    int32_t * v19 = (int32_t *)(Element + 256); // 0x80aa2c0
    SaveFree((char *)*v19);
    *v19 = 0;
    SaveFree((char *)*v11);
    int32_t * v20 = (int32_t *)(Element + 264); // 0x80aa2e8
    *v11 = 0;
    SaveFree((char *)*v20);
    int32_t * v21 = (int32_t *)(Element + 268); // 0x80aa300
    *v20 = 0;
    SaveFree((char *)*v21);
    *v21 = 0;
    FreeAttributeListMemory((int32_t)&g231);
    __asm_rep_stosd_memset((char *)Element, 0, 75);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa4d0 - 0x80aa527
// Line range:    732 - 742
void FreePolygonMemory(int32_t Polygon2) {
    if (Polygon2 == 0) {
        // 0x80aa51d
        return;
    }
    int32_t * v1 = (int32_t *)(Polygon2 + 56); // 0x80aa4e3
    SaveFree((char *)*v1);
    int32_t v2 = Polygon2 + 44; // 0x80aa4ee
    *v1 = 0;
    if (*(int32_t *)v2 != 0) {
        // 0x80aa4fc
        poly_Free(v2);
    }
    // 0x80aa507
    poly_FreeContours(Polygon2 + 48);
    __asm_rep_stosd_memset((char *)Polygon2, 0, 15);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa530 - 0x80aa828
// Line range:    891 - 98
void FreeDataMemory(int32_t Data) {
    if (Data == 0) {
        // 0x80aa809
        __fprintf_chk(g43, 1, "Warning:  Tried to FreeDataMemory(null)\n");
        // 0x80aa801
        return;
    }
    int32_t * v1 = (int32_t *)Data; // 0x80aa547
    int32_t v2 = *v1; // 0x80aa547
    if (v2 != 0) {
        int32_t v3 = 0; // 0x80aa55c
        int32_t v4 = v2;
        int32_t * v5 = (int32_t *)(*(int32_t *)(Data + 28) + 60 + 76 * v3); // 0x80aa56c
        SaveFree((char *)*v5);
        uint32_t v6 = *v1; // 0x80aa577
        *v5 = 0;
        while (v6 != 0) {
            // 0x80aa558
            v3 = 1 - v4 + v3 + v6;
            if (v6 <= v3) {
                // break -> 0x80aa584
                break;
            }
            v4 = v6;
            v5 = (int32_t *)(*(int32_t *)(Data + 28) + 60 + 76 * v3);
            SaveFree((char *)*v5);
            v6 = *v1;
            *v5 = 0;
        }
    }
    int32_t v7 = *(int32_t *)(Data + 8); // 0x80aa587
    if (v7 != 0) {
        int32_t v8 = v7; // 0x80aa59a
        int32_t v9 = 300 * v7; // 0x80aa59a
        v9 -= 300;
        v8--;
        FreeElementMemory(*(int32_t *)(Data + 32) + v9);
        while (v8 != 0) {
            // 0x80aa5a0
            v9 -= 300;
            v8--;
            FreeElementMemory(*(int32_t *)(Data + 32) + v9);
        }
    }
    int32_t v10 = 0; // 0x80aa5c5
    int32_t v11 = Data + 76;
    FreeAttributeListMemory(v10);
    int32_t v12 = *(int32_t *)(v11 + 8); // 0x80aa5d0
    int32_t v13; // 0x80aa530
    int32_t v14; // 0x80aa530
    int32_t * v15; // 0x80aa5f6
    if (v12 != 0) {
        // 0x80aa5db
        v14 = v12;
        v13 = 60 * v12;
        v13 -= 60;
        v14--;
        v15 = (int32_t *)(*(int32_t *)(v11 + 40) + 52 + v13);
        SaveFree((char *)*v15);
        *v15 = 0;
        while (v14 != 0) {
            // 0x80aa5e8
            v13 -= 60;
            v14--;
            v15 = (int32_t *)(*(int32_t *)(v11 + 40) + 52 + v13);
            SaveFree((char *)*v15);
            *v15 = 0;
        }
    }
    int32_t * v16 = (int32_t *)v11; // 0x80aa610
    int32_t v17 = *v16; // 0x80aa610
    if (v17 != 0) {
        // 0x80aa616
        SaveFree((char *)v17);
        *v16 = 0;
    }
    int32_t v18 = *(int32_t *)(v11 + 4); // 0x80aa624
    int32_t * v19; // 0x80aa530
    int32_t v20; // 0x80aa530
    int32_t v21; // 0x80aa530
    int32_t v22; // 0x80aa530
    int32_t v23; // 0x80aa530
    int32_t * v24; // 0x80aa530
    int32_t * v25; // 0x80aa530
    int32_t * v26; // 0x80aa643
    int32_t v27; // 0x80aa643
    int32_t v28; // 0x80aa65c
    if (v18 == 0) {
        // 0x80aa73c
        v24 = (int32_t *)(v11 + 36);
        v19 = v24;
        v21 = *v24;
    } else {
        // 0x80aa633
        v25 = (int32_t *)(v11 + 36);
        v20 = *v25;
        v23 = v18;
        v22 = 88 * v18;
        v22 -= 88;
        v26 = (int32_t *)(v20 + 84 + v22);
        v27 = *v26;
        v28 = v20;
        if (v27 != 0) {
            // 0x80aa64a
            SaveFree((char *)v27);
            *v26 = 0;
            v28 = *v25;
        }
        // 0x80aa65f
        v23--;
        v20 = v28;
        v19 = v25;
        v21 = v20;
        while (v23 != 0) {
            // 0x80aa640
            v22 -= 88;
            v26 = (int32_t *)(v20 + 84 + v22);
            v27 = *v26;
            v28 = v20;
            if (v27 != 0) {
                // 0x80aa64a
                SaveFree((char *)v27);
                *v26 = 0;
                v28 = *v25;
            }
            // 0x80aa65f
            v23--;
            v20 = v28;
            v19 = v25;
            v21 = v20;
        }
    }
    // 0x80aa66d
    SaveFree((char *)v21);
    int32_t * v29 = (int32_t *)(v11 + 48); // 0x80aa675
    *v19 = 0;
    SaveFree((char *)*v29);
    int32_t * v30 = (int32_t *)(v11 + 40); // 0x80aa687
    *v29 = 0;
    SaveFree((char *)*v30);
    int32_t v31 = *(int32_t *)(v11 + 12); // 0x80aa699
    *v30 = 0;
    int32_t * v32; // 0x80aa530
    int32_t v33; // 0x80aa530
    int32_t v34; // 0x80aa530
    int32_t * v35; // 0x80aa530
    if (v31 == 0) {
        // 0x80aa66d
        v32 = (int32_t *)(v11 + 44);
    } else {
        // 0x80aa6ab
        v35 = (int32_t *)(v11 + 44);
        v34 = v31;
        v33 = 60 * v31;
        v33 -= 60;
        v34--;
        FreePolygonMemory(*v35 + v33);
        v32 = v35;
        while (v34 != 0) {
            // 0x80aa6b8
            v33 -= 60;
            v34--;
            FreePolygonMemory(*v35 + v33);
            v32 = v35;
        }
    }
    // 0x80aa6d0
    SaveFree((char *)*v32);
    int32_t v36 = v11 + 52; // 0x80aa6db
    *v32 = 0;
    if (*(int32_t *)v36 != 0) {
        // 0x80aa6e9
        r_destroy_tree(v36);
    }
    int32_t v37 = v11 + 64; // 0x80aa6f4
    if (*(int32_t *)v37 != 0) {
        // 0x80aa6fb
        r_destroy_tree(v37);
    }
    int32_t v38 = v11 + 56; // 0x80aa706
    if (*(int32_t *)v38 != 0) {
        // 0x80aa70d
        r_destroy_tree(v38);
    }
    int32_t v39 = v11 + 60; // 0x80aa718
    if (*(int32_t *)v39 != 0) {
        // 0x80aa71f
        r_destroy_tree(v39);
    }
    while (v10 != 17) {
        // 0x80aa734
        v10++;
        v11 += 92;
        FreeAttributeListMemory(v10);
        v12 = *(int32_t *)(v11 + 8);
        if (v12 != 0) {
            // 0x80aa5db
            v14 = v12;
            v13 = 60 * v12;
            v13 -= 60;
            v14--;
            v15 = (int32_t *)(*(int32_t *)(v11 + 40) + 52 + v13);
            SaveFree((char *)*v15);
            *v15 = 0;
            while (v14 != 0) {
                // 0x80aa5e8
                v13 -= 60;
                v14--;
                v15 = (int32_t *)(*(int32_t *)(v11 + 40) + 52 + v13);
                SaveFree((char *)*v15);
                *v15 = 0;
            }
        }
        // 0x80aa610
        v16 = (int32_t *)v11;
        v17 = *v16;
        if (v17 != 0) {
            // 0x80aa616
            SaveFree((char *)v17);
            *v16 = 0;
        }
        // 0x80aa624
        v18 = *(int32_t *)(v11 + 4);
        if (v18 == 0) {
            // 0x80aa73c
            v24 = (int32_t *)(v11 + 36);
            v19 = v24;
            v21 = *v24;
        } else {
            // 0x80aa633
            v25 = (int32_t *)(v11 + 36);
            v20 = *v25;
            v23 = v18;
            v22 = 88 * v18;
            v22 -= 88;
            v26 = (int32_t *)(v20 + 84 + v22);
            v27 = *v26;
            v28 = v20;
            if (v27 != 0) {
                // 0x80aa64a
                SaveFree((char *)v27);
                *v26 = 0;
                v28 = *v25;
            }
            // 0x80aa65f
            v23--;
            v20 = v28;
            v19 = v25;
            v21 = v20;
            while (v23 != 0) {
                // 0x80aa640
                v22 -= 88;
                v26 = (int32_t *)(v20 + 84 + v22);
                v27 = *v26;
                v28 = v20;
                if (v27 != 0) {
                    // 0x80aa64a
                    SaveFree((char *)v27);
                    *v26 = 0;
                    v28 = *v25;
                }
                // 0x80aa65f
                v23--;
                v20 = v28;
                v19 = v25;
                v21 = v20;
            }
        }
        // 0x80aa66d
        SaveFree((char *)v21);
        v29 = (int32_t *)(v11 + 48);
        *v19 = 0;
        SaveFree((char *)*v29);
        v30 = (int32_t *)(v11 + 40);
        *v29 = 0;
        SaveFree((char *)*v30);
        v31 = *(int32_t *)(v11 + 12);
        *v30 = 0;
        if (v31 == 0) {
            // 0x80aa66d
            v32 = (int32_t *)(v11 + 44);
        } else {
            // 0x80aa6ab
            v35 = (int32_t *)(v11 + 44);
            v34 = v31;
            v33 = 60 * v31;
            v33 -= 60;
            v34--;
            FreePolygonMemory(*v35 + v33);
            v32 = v35;
            while (v34 != 0) {
                // 0x80aa6b8
                v33 -= 60;
                v34--;
                FreePolygonMemory(*v35 + v33);
                v32 = v35;
            }
        }
        // 0x80aa6d0
        SaveFree((char *)*v32);
        v36 = v11 + 52;
        *v32 = 0;
        if (*(int32_t *)v36 != 0) {
            // 0x80aa6e9
            r_destroy_tree(v36);
        }
        // 0x80aa6f4
        v37 = v11 + 64;
        if (*(int32_t *)v37 != 0) {
            // 0x80aa6fb
            r_destroy_tree(v37);
        }
        // 0x80aa706
        v38 = v11 + 56;
        if (*(int32_t *)v38 != 0) {
            // 0x80aa70d
            r_destroy_tree(v38);
        }
        // 0x80aa718
        v39 = v11 + 60;
        if (*(int32_t *)v39 != 0) {
            // 0x80aa71f
            r_destroy_tree(v39);
        }
    }
    int32_t v40 = Data + 44; // 0x80aa748
    if (*(int32_t *)v40 != 0) {
        // 0x80aa74f
        r_destroy_tree(v40);
    }
    int32_t v41 = Data + 56; // 0x80aa75d
    if (*(int32_t *)v41 != 0) {
        // 0x80aa764
        r_destroy_tree(v41);
    }
    int32_t v42 = Data + 60; // 0x80aa774
    if (*(int32_t *)v42 != 0) {
        // 0x80aa77b
        r_destroy_tree(v42);
    }
    int32_t v43 = Data + 64; // 0x80aa789
    if (*(int32_t *)v43 != 0) {
        // 0x80aa790
        r_destroy_tree(v43);
    }
    int32_t v44 = Data + 40; // 0x80aa7a0
    if (*(int32_t *)v44 != 0) {
        // 0x80aa7a7
        r_destroy_tree(v44);
    }
    int32_t v45 = Data + 48; // 0x80aa7b5
    if (*(int32_t *)v45 != 0) {
        // 0x80aa7bc
        r_destroy_tree(v45);
    }
    int32_t v46 = Data + 52; // 0x80aa7cc
    if (*(int32_t *)v46 != 0) {
        // 0x80aa7d3
        r_destroy_tree(v46);
    }
    int32_t v47 = Data + 68; // 0x80aa7e1
    if (*(int32_t *)v47 != 0) {
        // 0x80aa7e8
        r_destroy_tree(v47);
    }
    // 0x80aa7f5
    __asm_rep_stosd_memset((char *)Data, 0, 433);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa830 - 0x80aa929
// Line range:    861 - 885
void FreePCBMemory(int32_t PCBPtr) {
    if (PCBPtr == 0) {
        // 0x80aa905
        __fprintf_chk(g43, 1, "Warning:  Tried to FreePCBMemory(null)\n");
        return;
    }
    int32_t * v1 = (int32_t *)(PCBPtr + 16); // 0x80aa843
    SaveFree((char *)*v1);
    int32_t * v2 = (int32_t *)(PCBPtr + 20); // 0x80aa84e
    *v1 = 0;
    SaveFree((char *)*v2);
    int32_t * v3 = (int32_t *)(PCBPtr + 24); // 0x80aa860
    *v2 = 0;
    SaveFree((char *)*v3);
    int32_t * v4 = (int32_t *)(PCBPtr + 0x220c); // 0x80aa872
    int32_t v5 = *v4; // 0x80aa872
    *v3 = 0;
    char * v6 = NULL; // 0x80aa883
    if (v5 != 0) {
        // 0x80aa885
        FreeDataMemory(v5);
        v6 = (char *)*v4;
    }
    // 0x80aa893
    SaveFree(v6);
    *v4 = 0;
    for (int32_t i = 0; i < 0x1be5; i += 28) {
        int32_t * v7 = (int32_t *)(PCBPtr + 208 + i); // 0x80aa8a8
        SaveFree((char *)*v7);
        *v7 = 0;
    }
    // 0x80aa8cd
    FreeLibraryMemory(PCBPtr + 0x21f4);
    FreeAttributeListMemory((int32_t)&g231);
    memset(&((struct _IO_FILE *)PCBPtr)->e0, 0, 0x2210);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa930 - 0x80aa97e
// Line range:    699 - 711
char * MyStrdup(char * S, char * Text) {
    // 0x80aa930
    if (S == NULL) {
        // 0x80aa94f
        return (char *)0;
    }
    char * v1 = __strdup(S); // 0x80aa946
    if (v1 != NULL) {
        // 0x80aa94f
        return (char *)(int32_t)v1;
    }
    // 0x80aa958
    MyFatal("out of memory during g_strdup() in '%s'\n", Text == NULL ? "(unknown)" : Text);
    // UNREACHABLE
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aa980 - 0x80aa9f2
// Line range:    676 - 685
char * MyRealloc(char * Ptr, int32_t Size, char * Text) {
    int32_t size = Size == 0 ? 1 : Size; // 0x80aa997
    int32_t * mem; // 0x80aa980
    if (Ptr == NULL) {
        // 0x80aa9e0
        mem = calloc(1, size);
    } else {
        // 0x80aa99e
        mem = realloc((int32_t *)Ptr, size);
    }
    // 0x80aa9aa
    if (mem != NULL) {
        // 0x80aa9ae
        return (char *)mem;
    }
    // 0x80aa9b8
    MyFatal("out of memory during realloc() in '%s'()\n", Text == NULL ? "(unknown)" : Text);
    // UNREACHABLE
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aaab0 - 0x80aab83
// Line range:    1038 - 1017
void DSAddString(int32_t Ptr, char * S) {
    int32_t * v1 = (int32_t *)(Ptr + 4); // 0x80aaac7
    int32_t str = *v1; // 0x80aaac7
    int32_t len = 0; // 0x80aaacf
    if (str != 0) {
        // 0x80aaad1
        len = strlen((char *)str);
    }
    if (S == NULL || *S == 0) {
        // 0x80aab40
        return;
    }
    uint32_t v2 = len + 1 + strlen(S); // 0x80aaaf4
    if (str == 0) {
        int32_t v3 = v2 + 512; // 0x80aab50
        *(int32_t *)Ptr = v3;
        char * v4 = MyRealloc(NULL, v3, "ReallocDS()"); // 0x80aab6d
        *v1 = (int32_t)v4;
        *v4 = 0;
        // 0x80aab25
        strcat((char *)(*v1 + len), S);
        return;
    }
    int32_t * v5 = (int32_t *)Ptr; // 0x80aaafa
    int32_t v6 = str; // 0x80aaafc
    if (v2 >= *v5) {
        int32_t v7 = v2 + 512; // 0x80aaafe
        *v5 = v7;
        v6 = (int32_t)MyRealloc((char *)str, v7, "ReallocDS()");
        *v1 = v6;
    }
    // 0x80aab25
    strcat((char *)(v6 + len), S);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aab90 - 0x80aac3c
// Line range:    1025 - 1017
void DSAddCharacter(int32_t Ptr, char Char) {
    int32_t * v1 = (int32_t *)(Ptr + 4); // 0x80aaba6
    int32_t v2 = *v1; // 0x80aaba6
    int32_t v3; // 0x80aab90
    int32_t v4; // 0x80aab90
    int32_t v5; // 0x80aab90
    if (v2 == 0) {
        // 0x80aac08
        *(int32_t *)Ptr = 513;
        char * v6 = MyRealloc(NULL, 513, "ReallocDS()"); // 0x80aac27
        *v1 = (int32_t)v6;
        *v6 = 0;
        v4 = 1;
        v5 = *v1;
        v3 = 0;
    } else {
        char * str = (char *)v2; // 0x80aabb0
        int32_t len = strlen(str); // 0x80aabb3
        int32_t v7 = len + 1; // 0x80aabb8
        int32_t * v8 = (int32_t *)Ptr; // 0x80aabbd
        v4 = v7;
        v5 = v2;
        v3 = len;
        if (v7 >= *v8) {
            int32_t v9 = len + 513; // 0x80aabc1
            *v8 = v9;
            int32_t v10 = (int32_t)MyRealloc(str, v9, "ReallocDS()"); // 0x80aabda
            *v1 = v10;
            v4 = v7;
            v5 = v10;
            v3 = len;
        }
    }
    // 0x80aabe7
    *(char *)(v3 + v5) = Char;
    *(char *)(*v1 + v4) = 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aaec0 - 0x80aaf94
// Line range:    539 - 86
int32_t GetLibraryEntryMemory(int32_t Menu2) {
    int32_t * v1 = (int32_t *)(Menu2 + 12); // 0x80aaed2
    uint32_t v2 = *v1; // 0x80aaed2
    int32_t * v3 = (int32_t *)(Menu2 + 16); // 0x80aaed5
    uint32_t v4 = *v3; // 0x80aaed5
    int32_t * v5 = (int32_t *)(Menu2 + 20); // 0x80aaed8
    int32_t v6 = *v5; // 0x80aaed8
    if (v2 < v4) {
        // 0x80aaedf
        *v1 = v2 + 1;
        return v6 + 24 * v2;
    }
    int32_t v7 = v4 + 20; // 0x80aaef8
    *v3 = v7;
    int32_t v8 = (int32_t)MyRealloc((char *)v6, 24 * v7, "GetLibraryEntryMemory()"); // 0x80aaf18
    *v5 = v8;
    int32_t v9 = 24 * *v1 + v8; // 0x80aaf28
    int32_t v10 = 480; // 0x80aaf31
    int32_t v11 = v9; // 0x80aaf31
    if (v9 % 2 != 0) {
        // 0x80aaf88
        *(char *)v9 = 0;
        v10 = 479;
        v11 = v9 + 1;
    }
    int32_t v12 = v10; // 0x80aaf39
    int32_t v13 = v11; // 0x80aaf39
    if ((v11 & 2) != 0) {
        // 0x80aaf78
        *(int16_t *)v11 = 0;
        v12 = v10 - 2;
        v13 = v11 + 2;
    }
    uint32_t v14 = v12 / 4; // 0x80aaf3f
    __asm_rep_stosd_memset((char *)v13, 0, v14);
    bool v15; // 0x80aaec0
    int32_t v16 = v14 * (v15 ? -4 : 4) + v13; // 0x80aaf48
    int32_t v17; // 0x80aaec0
    if ((v12 & 2) != 0) {
        // 0x80aaf68
        *(int16_t *)v16 = 0;
        v17 = v16 + 2;
        if (v12 % 2 == 0) {
            goto lab_0x80aaf51;
        } else {
            goto lab_0x80aaf58;
        }
    } else {
        // 0x80aaf4c
        v17 = v16;
        if (v12 % 2 != 0) {
            goto lab_0x80aaf58;
        } else {
            goto lab_0x80aaf51;
        }
    }
  lab_0x80aaf51:;
    int32_t v18 = *v1;
    *v1 = v18 + 1;
    return v8 + 24 * v18;
  lab_0x80aaf58:
    // 0x80aaf58
    *(char *)v17 = 0;
    // 0x80aaedf
    v18 = *v1;
    *v1 = v18 + 1;
    return v8 + 24 * v18;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80aafa0 - 0x80ab064
// Line range:    518 - 86
int32_t GetLibraryMenuMemory(int32_t lib) {
    int32_t * v1 = (int32_t *)lib; // 0x80aafb2
    uint32_t v2 = *v1; // 0x80aafb2
    int32_t * v3 = (int32_t *)(lib + 4); // 0x80aafb4
    uint32_t v4 = *v3; // 0x80aafb4
    int32_t * v5 = (int32_t *)(lib + 8); // 0x80aafb7
    int32_t v6 = *v5; // 0x80aafb7
    if (v2 < v4) {
        // 0x80aafbe
        *v1 = v2 + 1;
        return v6 + 28 * v2;
    }
    int32_t v7 = v4 + 10; // 0x80aafd8
    *v3 = v7;
    int32_t v8 = (int32_t)MyRealloc((char *)v6, 28 * v7, "GetLibraryMenuMemory()"); // 0x80aaff5
    int32_t v9 = 28 * *v1 + v8; // 0x80aaffd
    *v5 = v8;
    int32_t v10 = 280; // 0x80ab00b
    int32_t v11 = v9; // 0x80ab00b
    if (v9 % 2 != 0) {
        // 0x80ab058
        *(char *)v9 = 0;
        v10 = 279;
        v11 = v9 + 1;
    }
    int32_t v12 = v10; // 0x80ab013
    int32_t v13 = v11; // 0x80ab013
    if ((v11 & 2) != 0) {
        // 0x80ab048
        *(int16_t *)v11 = 0;
        v12 = v10 - 2;
        v13 = v11 + 2;
    }
    uint32_t v14 = v12 / 4; // 0x80ab019
    __asm_rep_stosd_memset((char *)v13, 0, v14);
    bool v15; // 0x80aafa0
    int32_t v16 = v14 * (v15 ? -4 : 4) + v13; // 0x80ab022
    int32_t v17; // 0x80aafa0
    if ((v12 & 2) != 0) {
        // 0x80ab038
        *(int16_t *)v16 = 0;
        v17 = v16 + 2;
        if (v12 % 2 == 0) {
            goto lab_0x80ab02b;
        } else {
            goto lab_0x80ab030;
        }
    } else {
        // 0x80ab026
        v17 = v16;
        if (v12 % 2 != 0) {
            goto lab_0x80ab030;
        } else {
            goto lab_0x80ab02b;
        }
    }
  lab_0x80ab02b:;
    int32_t v18 = *v1;
    *v1 = v18 + 1;
    return v8 + 28 * v18;
  lab_0x80ab030:
    // 0x80ab030
    *(char *)v17 = 0;
    // 0x80aafbe
    v18 = *v1;
    *v1 = v18 + 1;
    return v8 + 28 * v18;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80ab070 - 0x80ab144
// Line range:    444 - 86
int32_t GetPointMemoryInPolygon(int32_t Polygon2) {
    int32_t * v1 = (int32_t *)(Polygon2 + 36); // 0x80ab082
    uint32_t v2 = *v1; // 0x80ab082
    int32_t * v3 = (int32_t *)(Polygon2 + 40); // 0x80ab085
    uint32_t v4 = *v3; // 0x80ab085
    int32_t * v5 = (int32_t *)(Polygon2 + 56); // 0x80ab088
    int32_t v6 = *v5; // 0x80ab088
    if (v2 < v4) {
        // 0x80ab08f
        *v1 = v2 + 1;
        return v6 + 20 * v2;
    }
    int32_t v7 = v4 + 10; // 0x80ab0a8
    *v3 = v7;
    int32_t v8 = (int32_t)MyRealloc((char *)v6, 20 * v7, "GetPointMemoryInPolygon()"); // 0x80ab0c8
    *v5 = v8;
    int32_t v9 = 20 * *v1 + v8; // 0x80ab0d8
    int32_t v10 = 200; // 0x80ab0e1
    int32_t v11 = v9; // 0x80ab0e1
    if (v9 % 2 != 0) {
        // 0x80ab138
        *(char *)v9 = 0;
        v10 = 199;
        v11 = v9 + 1;
    }
    int32_t v12 = v10; // 0x80ab0e9
    int32_t v13 = v11; // 0x80ab0e9
    if ((v11 & 2) != 0) {
        // 0x80ab128
        *(int16_t *)v11 = 0;
        v12 = v10 - 2;
        v13 = v11 + 2;
    }
    uint32_t v14 = v12 / 4; // 0x80ab0ef
    __asm_rep_stosd_memset((char *)v13, 0, v14);
    bool v15; // 0x80ab070
    int32_t v16 = v14 * (v15 ? -4 : 4) + v13; // 0x80ab0f8
    int32_t v17; // 0x80ab070
    if ((v12 & 2) != 0) {
        // 0x80ab118
        *(int16_t *)v16 = 0;
        v17 = v16 + 2;
        if (v12 % 2 == 0) {
            goto lab_0x80ab101;
        } else {
            goto lab_0x80ab108;
        }
    } else {
        // 0x80ab0fc
        v17 = v16;
        if (v12 % 2 != 0) {
            goto lab_0x80ab108;
        } else {
            goto lab_0x80ab101;
        }
    }
  lab_0x80ab101:;
    int32_t v18 = *v1;
    *v1 = v18 + 1;
    return v8 + 20 * v18;
  lab_0x80ab108:
    // 0x80ab108
    *(char *)v17 = 0;
    // 0x80ab08f
    v18 = *v1;
    *v1 = v18 + 1;
    return v8 + 20 * v18;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80ab620 - 0x80ab67e
// Line range:    626 - 648
char * MyCalloc(int32_t Number, int32_t Size, char * Text) {
    int32_t * mem = calloc(Number == 0 ? 1 : Number, Size == 0 ? 1 : Size); // 0x80ab646
    if (mem != NULL) {
        // 0x80ab64f
        return (char *)mem;
    }
    // 0x80ab658
    MyFatal("out of memory during malloc() in '%s'()\n", Text == NULL ? "(unknown)" : Text);
    // UNREACHABLE
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80ab680 - 0x80ab860
// Line range:    465 - 512
int32_t GetElementMemory(int32_t Data) {
    int32_t * v1 = (int32_t *)(Data + 32); // 0x80ab68c
    int32_t v2 = *v1; // 0x80ab68c
    int32_t * v3 = (int32_t *)(Data + 12); // 0x80ab68f
    uint32_t v4 = *v3; // 0x80ab68f
    int32_t * v5 = (int32_t *)(Data + 8); // 0x80ab695
    uint32_t v6 = *v5; // 0x80ab695
    if (v6 < v4) {
        // 0x80ab849
        *v5 = v6 + 1;
        return 300 * v6 + v2;
    }
    int32_t v7 = Data + 44; // 0x80ab6a0
    int32_t * v8 = (int32_t *)v7; // 0x80ab6a0
    int32_t v9 = v4 + 50; // 0x80ab6a3
    *v3 = v9;
    int32_t v10 = v9; // 0x80ab6ab
    if (*v8 != 0) {
        // 0x80ab6ad
        r_destroy_tree(v7);
        v10 = *v3;
    }
    int32_t v11 = (int32_t)MyRealloc((char *)v2, 300 * v10, "GetElementMemory()"); // 0x80ab6d5
    *v1 = v11;
    memset((int32_t *)(300 * *v5 + v11), 0, 0x3a98);
    *v8 = r_create_tree(0, 0, 0);
    int32_t v12 = Data + 56; // 0x80ab721
    for (int32_t i = 0; i < 3; i++) {
        int32_t v13 = 4 * i + v12; // 0x80ab721
        int32_t * v14 = (int32_t *)v13; // 0x80ab721
        if (*v14 != 0) {
            // 0x80ab729
            r_destroy_tree(v13);
        }
        // 0x80ab735
        *v14 = r_create_tree(0, 0, 0);
    }
    int32_t v15 = *v5; // 0x80ab75d
    int32_t v16; // 0x80ab680
    if (v15 == 0) {
        // 0x80ab849
        v16 = 0;
        *v5 = v16 + 1;
        return 300 * v16 + v11;
    }
    int32_t v17 = v15; // 0x80ab77d
    int32_t v18 = 300 * v15; // 0x80ab77d
    v18 -= 300;
    int32_t v19 = v18 + *v1; // 0x80ab783
    r_insert_entry(*v8, v19, 0);
    int32_t v20 = *(int32_t *)(v19 + 224); // 0x80ab79d
    int32_t v21; // 0x80ab680
    int32_t v22; // 0x80ab680
    int32_t v23; // 0x80ab7bf
    if (v20 != 0) {
        // 0x80ab7a7
        v22 = *(int32_t *)(v19 + 256) + 68;
        *(int32_t *)v22 = v19;
        v21 = 1;
        if (v20 != 1) {
            *(int32_t *)(76 * v21 + v22) = v19;
            v23 = v21 + 1;
            v21 = v23;
            while (v23 != v20) {
                // 0x80ab7b8
                *(int32_t *)(76 * v21 + v22) = v19;
                v23 = v21 + 1;
                v21 = v23;
            }
        }
    }
    int32_t v24 = *(int32_t *)(v19 + 232); // 0x80ab7c6
    int32_t v25; // 0x80ab680
    int32_t v26; // 0x80ab7de
    if (v24 != 0) {
        // 0x80ab7d8
        v25 = 0;
        v26 = 0;
        v26++;
        *(int32_t *)(v25 + 96 + *(int32_t *)(v19 + 260)) = v19;
        v25 += 104;
        while (v26 != v24) {
            // 0x80ab7d8
            v26++;
            *(int32_t *)(v25 + 96 + *(int32_t *)(v19 + 260)) = v19;
            v25 += 104;
        }
    }
    // 0x80ab7f9
    v17--;
    int32_t v27 = v19; // 0x80ab680
    int32_t v28 = 2;
    *(int32_t *)(v27 + 212) = v19;
    r_insert_entry(*(int32_t *)(4 * v28 + v12), v19 + 36 + 60 * v28, 0);
    v27 -= 60;
    int32_t v29 = v28 - 1; // 0x80ab82d
    while (v28 != 0) {
        // 0x80ab7f9
        v28 = v29;
        *(int32_t *)(v27 + 212) = v19;
        r_insert_entry(*(int32_t *)(4 * v28 + v12), v19 + 36 + 60 * v28, 0);
        v27 -= 60;
        v29 = v28 - 1;
    }
    while (v17 != 0) {
        // 0x80ab780
        v18 -= 300;
        v19 = v18 + *v1;
        r_insert_entry(*v8, v19, 0);
        v20 = *(int32_t *)(v19 + 224);
        if (v20 != 0) {
            // 0x80ab7a7
            v22 = *(int32_t *)(v19 + 256) + 68;
            *(int32_t *)v22 = v19;
            v21 = 1;
            if (v20 != 1) {
                *(int32_t *)(76 * v21 + v22) = v19;
                v23 = v21 + 1;
                v21 = v23;
                while (v23 != v20) {
                    // 0x80ab7b8
                    *(int32_t *)(76 * v21 + v22) = v19;
                    v23 = v21 + 1;
                    v21 = v23;
                }
            }
        }
        // 0x80ab7c6
        v24 = *(int32_t *)(v19 + 232);
        if (v24 != 0) {
            // 0x80ab7d8
            v25 = 0;
            v26 = 0;
            v26++;
            *(int32_t *)(v25 + 96 + *(int32_t *)(v19 + 260)) = v19;
            v25 += 104;
            while (v26 != v24) {
                // 0x80ab7d8
                v26++;
                *(int32_t *)(v25 + 96 + *(int32_t *)(v19 + 260)) = v19;
                v25 += 104;
            }
        }
        // 0x80ab7f9
        v17--;
        v27 = v19;
        v28 = 2;
        *(int32_t *)(v27 + 212) = v19;
        r_insert_entry(*(int32_t *)(4 * v28 + v12), v19 + 36 + 60 * v28, 0);
        v27 -= 60;
        v29 = v28 - 1;
        while (v28 != 0) {
            // 0x80ab7f9
            v28 = v29;
            *(int32_t *)(v27 + 212) = v19;
            r_insert_entry(*(int32_t *)(4 * v28 + v12), v19 + 36 + 60 * v28, 0);
            v27 -= 60;
            v29 = v28 - 1;
        }
    }
    // 0x80ab849
    v16 = *v5;
    *v5 = v16 + 1;
    return 300 * v16 + v11;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80ab860 - 0x80ab9a8
// Line range:    414 - 86
int32_t GetPolygonMemory(int32_t Layer2) {
    int32_t * v1 = (int32_t *)(Layer2 + 12); // 0x80ab86c
    uint32_t v2 = *v1; // 0x80ab86c
    int32_t * v3 = (int32_t *)(Layer2 + 28); // 0x80ab86f
    uint32_t v4 = *v3; // 0x80ab86f
    int32_t * v5 = (int32_t *)(Layer2 + 44); // 0x80ab872
    int32_t v6 = *v5; // 0x80ab872
    if (v2 < v4) {
        // 0x80ab958
        *v1 = v2 + 1;
        return v6 + 60 * v2;
    }
    int32_t v7 = Layer2 + 60; // 0x80ab87d
    int32_t * v8 = (int32_t *)v7; // 0x80ab87d
    int32_t v9 = v4 + 10; // 0x80ab880
    *v3 = v9;
    int32_t v10 = v9; // 0x80ab888
    if (*v8 != 0) {
        // 0x80ab88a
        r_destroy_tree(v7);
        v10 = *v3;
    }
    int32_t v11 = (int32_t)MyRealloc((char *)v6, 60 * v10, "GetPolygonMemory()"); // 0x80ab8aa
    int32_t v12 = 60 * *v1 + v11; // 0x80ab8b8
    *v5 = v11;
    int32_t v13 = 600; // 0x80ab8c6
    int32_t v14 = v12; // 0x80ab8c6
    if (v12 % 2 != 0) {
        // 0x80ab99b
        *(char *)v12 = 0;
        v13 = 599;
        v14 = v12 + 1;
    }
    int32_t v15 = v13; // 0x80ab8d2
    int32_t v16 = v14; // 0x80ab8d2
    if ((v14 & 2) != 0) {
        // 0x80ab98b
        *(int16_t *)v14 = 0;
        v15 = v13 - 2;
        v16 = v14 + 2;
    }
    uint32_t v17 = v15 / 4; // 0x80ab8dc
    __asm_rep_stosd_memset((char *)v16, 0, v17);
    bool v18; // 0x80ab860
    int32_t v19 = v17 * (v18 ? -4 : 4) + v16; // 0x80ab8e2
    if ((v15 & 2) != 0) {
        // 0x80ab978
        *(int16_t *)v19 = 0;
        if (v15 % 2 == 0) {
            goto lab_0x80ab8f3;
        } else {
            // 0x80ab970
            *(char *)(v19 + 2) = 0;
            goto lab_0x80ab8f3;
        }
    } else {
        // 0x80ab8ea
        if (v15 % 2 != 0) {
            // 0x80ab970
            *(char *)v19 = 0;
            goto lab_0x80ab8f3;
        } else {
            goto lab_0x80ab8f3;
        }
    }
  lab_0x80ab8f3:;
    int32_t v20 = r_create_tree(0, 0, 0); // 0x80ab90a
    int32_t v21 = *v1; // 0x80ab90f
    *v8 = v20;
    int32_t v22; // 0x80ab860
    if (v21 == 0) {
        // 0x80ab958
        v22 = 0;
        *v1 = v22 + 1;
        return v11 + 60 * v22;
    }
    int32_t v23 = v21 - 1;
    int32_t v24 = 60 * v21 - 60;
    r_insert_entry(v20, *v5 + v24, 0);
    if (v23 != 0) {
        int32_t v25 = v23 - 1;
        int32_t v26 = v24 - 60;
        r_insert_entry(*v8, *v5 + v26, 0);
        int32_t v27 = v26; // 0x80ab953
        int32_t v28 = v25; // 0x80ab953
        while (v25 != 0) {
            // 0x80ab928
            v25 = v28 - 1;
            v26 = v27 - 60;
            r_insert_entry(*v8, *v5 + v26, 0);
            v27 = v26;
            v28 = v25;
        }
    }
    // 0x80ab958
    v22 = *v1;
    *v1 = v22 + 1;
    return v11 + 60 * v22;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80ab9b0 - 0x80abaf8
// Line range:    386 - 86
int32_t GetTextMemory(int32_t Layer2) {
    int32_t * v1 = (int32_t *)(Layer2 + 8); // 0x80ab9bc
    uint32_t v2 = *v1; // 0x80ab9bc
    int32_t * v3 = (int32_t *)(Layer2 + 24); // 0x80ab9bf
    uint32_t v4 = *v3; // 0x80ab9bf
    int32_t * v5 = (int32_t *)(Layer2 + 40); // 0x80ab9c2
    int32_t v6 = *v5; // 0x80ab9c2
    if (v2 < v4) {
        // 0x80abaa8
        *v1 = v2 + 1;
        return v6 + 60 * v2;
    }
    int32_t v7 = Layer2 + 56; // 0x80ab9cd
    int32_t * v8 = (int32_t *)v7; // 0x80ab9cd
    int32_t v9 = v4 + 50; // 0x80ab9d0
    *v3 = v9;
    int32_t v10 = v9; // 0x80ab9d8
    if (*v8 != 0) {
        // 0x80ab9da
        r_destroy_tree(v7);
        v10 = *v3;
    }
    int32_t v11 = (int32_t)MyRealloc((char *)v6, 60 * v10, "GetTextMemory()"); // 0x80ab9fa
    int32_t v12 = 60 * *v1 + v11; // 0x80aba08
    *v5 = v11;
    int32_t v13 = 3000; // 0x80aba16
    int32_t v14 = v12; // 0x80aba16
    if (v12 % 2 != 0) {
        // 0x80abaeb
        *(char *)v12 = 0;
        v13 = 2999;
        v14 = v12 + 1;
    }
    int32_t v15 = v13; // 0x80aba22
    int32_t v16 = v14; // 0x80aba22
    if ((v14 & 2) != 0) {
        // 0x80abadb
        *(int16_t *)v14 = 0;
        v15 = v13 - 2;
        v16 = v14 + 2;
    }
    uint32_t v17 = v15 / 4; // 0x80aba2c
    __asm_rep_stosd_memset((char *)v16, 0, v17);
    bool v18; // 0x80ab9b0
    int32_t v19 = v17 * (v18 ? -4 : 4) + v16; // 0x80aba32
    if ((v15 & 2) != 0) {
        // 0x80abac8
        *(int16_t *)v19 = 0;
        if (v15 % 2 == 0) {
            goto lab_0x80aba43;
        } else {
            // 0x80abac0
            *(char *)(v19 + 2) = 0;
            goto lab_0x80aba43;
        }
    } else {
        // 0x80aba3a
        if (v15 % 2 != 0) {
            // 0x80abac0
            *(char *)v19 = 0;
            goto lab_0x80aba43;
        } else {
            goto lab_0x80aba43;
        }
    }
  lab_0x80aba43:;
    int32_t v20 = r_create_tree(0, 0, 0); // 0x80aba5a
    int32_t v21 = *v1; // 0x80aba5f
    *v8 = v20;
    int32_t v22; // 0x80ab9b0
    if (v21 == 0) {
        // 0x80abaa8
        v22 = 0;
        *v1 = v22 + 1;
        return v11 + 60 * v22;
    }
    int32_t v23 = v21 - 1;
    int32_t v24 = 60 * v21 - 60;
    r_insert_entry(v20, *v5 + v24, 0);
    if (v23 != 0) {
        int32_t v25 = v23 - 1;
        int32_t v26 = v24 - 60;
        r_insert_entry(*v8, *v5 + v26, 0);
        int32_t v27 = v26; // 0x80abaa3
        int32_t v28 = v25; // 0x80abaa3
        while (v25 != 0) {
            // 0x80aba78
            v25 = v28 - 1;
            v26 = v27 - 60;
            r_insert_entry(*v8, *v5 + v26, 0);
            v27 = v26;
            v28 = v25;
        }
    }
    // 0x80abaa8
    v22 = *v1;
    *v1 = v22 + 1;
    return v11 + 60 * v22;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80abb00 - 0x80abc01
// Line range:    358 - 380
int32_t GetArcMemory(int32_t Layer2) {
    int32_t * v1 = (int32_t *)(Layer2 + 16); // 0x80abb0c
    uint32_t v2 = *v1; // 0x80abb0c
    int32_t * v3 = (int32_t *)(Layer2 + 32); // 0x80abb0f
    uint32_t v4 = *v3; // 0x80abb0f
    int32_t * v5 = (int32_t *)(Layer2 + 48); // 0x80abb12
    int32_t v6 = *v5; // 0x80abb12
    if (v2 < v4) {
        // 0x80abbe8
        *v1 = v2 + 1;
        return v6 + 68 * v2;
    }
    int32_t v7 = Layer2 + 64; // 0x80abb1d
    int32_t * v8 = (int32_t *)v7; // 0x80abb1d
    int32_t v9 = v4 + 1000; // 0x80abb20
    *v3 = v9;
    int32_t v10 = v9; // 0x80abb2a
    if (*v8 != 0) {
        // 0x80abb2c
        r_destroy_tree(v7);
        v10 = *v3;
    }
    int32_t v11 = (int32_t)MyRealloc((char *)v6, 68 * v10, "GetArcMemory()"); // 0x80abb51
    *v5 = v11;
    memset((int32_t *)(68 * *v1 + v11), 0, 0x109a0);
    int32_t v12 = r_create_tree(0, 0, 0); // 0x80abb98
    int32_t v13 = *v1; // 0x80abb9d
    *v8 = v12;
    int32_t v14; // 0x80abb00
    if (v13 == 0) {
        // 0x80abbe8
        v14 = 0;
        *v1 = v14 + 1;
        return v11 + 68 * v14;
    }
    int32_t v15 = 68 * v13 - 68; // 0x80abbb0
    int32_t v16 = v13 - 1;
    r_insert_entry(v12, *v5 + v15, 0);
    int32_t v17 = v16; // 0x80abbe3
    int32_t v18 = v15; // 0x80abbe3
    if (v16 != 0) {
        v18 -= 68;
        v17--;
        r_insert_entry(*v8, *v5 + v18, 0);
        while (v17 != 0) {
            // 0x80abbb8
            v18 -= 68;
            v17--;
            r_insert_entry(*v8, *v5 + v18, 0);
        }
    }
    // 0x80abbe8
    v14 = *v1;
    *v1 = v14 + 1;
    return v11 + 68 * v14;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80abc10 - 0x80abcfc
// Line range:    329 - 352
int32_t GetLineMemory(int32_t Layer2) {
    int32_t * v1 = (int32_t *)(Layer2 + 4); // 0x80abc1c
    uint32_t v2 = *v1; // 0x80abc1c
    int32_t * v3 = (int32_t *)(Layer2 + 20); // 0x80abc1f
    uint32_t v4 = *v3; // 0x80abc1f
    int32_t * v5 = (int32_t *)(Layer2 + 36); // 0x80abc22
    int32_t v6 = *v5; // 0x80abc22
    if (v2 < v4) {
        // 0x80abce8
        *v1 = v2 + 1;
        return v6 + 88 * v2;
    }
    int32_t v7 = Layer2 + 52; // 0x80abc2d
    int32_t * v8 = (int32_t *)v7; // 0x80abc2d
    int32_t v9 = v4 + 0x2710; // 0x80abc30
    *v3 = v9;
    int32_t v10 = v9; // 0x80abc3a
    if (*v8 != 0) {
        // 0x80abc3c
        r_destroy_tree(v7);
        v10 = *v3;
    }
    int32_t v11 = (int32_t)MyRealloc((char *)v6, 88 * v10, "GetLineMemory()"); // 0x80abc5c
    *v5 = v11;
    memset((int32_t *)(88 * *v1 + v11), 0, 0xd6d80);
    int32_t v12 = r_create_tree(0, 0, 0); // 0x80abc9c
    int32_t v13 = *v1; // 0x80abca1
    *v8 = v12;
    int32_t v14; // 0x80abc10
    if (v13 == 0) {
        // 0x80abce8
        v14 = 0;
        *v1 = v14 + 1;
        return v11 + 88 * v14;
    }
    int32_t v15 = v13 - 1;
    int32_t v16 = 88 * v13 - 88;
    r_insert_entry(v12, *v5 + v16, 0);
    int32_t v17 = v16; // 0x80abce3
    int32_t v18 = v15; // 0x80abce3
    if (v15 != 0) {
        v18--;
        v17 -= 88;
        r_insert_entry(*v8, *v5 + v17, 0);
        while (v18 != 0) {
            // 0x80abcb8
            v18--;
            v17 -= 88;
            r_insert_entry(*v8, *v5 + v17, 0);
        }
    }
    // 0x80abce8
    v14 = *v1;
    *v1 = v14 + 1;
    return v11 + 88 * v14;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80abd00 - 0x80abdec
// Line range:    300 - 323
int32_t GetRatMemory(int32_t Data) {
    int32_t * v1 = (int32_t *)(Data + 16); // 0x80abd0c
    uint32_t v2 = *v1; // 0x80abd0c
    int32_t * v3 = (int32_t *)(Data + 20); // 0x80abd0f
    uint32_t v4 = *v3; // 0x80abd0f
    int32_t * v5 = (int32_t *)(Data + 36); // 0x80abd12
    int32_t v6 = *v5; // 0x80abd12
    if (v2 < v4) {
        // 0x80abdd8
        *v1 = v2 + 1;
        return v6 + 92 * v2;
    }
    int32_t v7 = Data + 68; // 0x80abd1d
    int32_t * v8 = (int32_t *)v7; // 0x80abd1d
    int32_t v9 = v4 + 2000; // 0x80abd20
    *v3 = v9;
    int32_t v10 = v9; // 0x80abd2a
    if (*v8 != 0) {
        // 0x80abd2c
        r_destroy_tree(v7);
        v10 = *v3;
    }
    int32_t v11 = (int32_t)MyRealloc((char *)v6, 92 * v10, "GetRatMemory()"); // 0x80abd4c
    *v5 = v11;
    memset((int32_t *)(92 * *v1 + v11), 0, 0x2cec0);
    int32_t v12 = r_create_tree(0, 0, 0); // 0x80abd8c
    int32_t v13 = *v1; // 0x80abd91
    *v8 = v12;
    int32_t v14; // 0x80abd00
    if (v13 == 0) {
        // 0x80abdd8
        v14 = 0;
        *v1 = v14 + 1;
        return v11 + 92 * v14;
    }
    int32_t v15 = v13 - 1;
    int32_t v16 = 92 * v13 - 92;
    r_insert_entry(v12, *v5 + v16, 0);
    int32_t v17 = v16; // 0x80abdd3
    int32_t v18 = v15; // 0x80abdd3
    if (v15 != 0) {
        v18--;
        v17 -= 92;
        r_insert_entry(*v8, *v5 + v17, 0);
        while (v18 != 0) {
            // 0x80abda8
            v18--;
            v17 -= 92;
            r_insert_entry(*v8, *v5 + v17, 0);
        }
    }
    // 0x80abdd8
    v14 = *v1;
    *v1 = v14 + 1;
    return v11 + 92 * v14;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80abdf0 - 0x80abee4
// Line range:    272 - 294
int32_t GetViaMemory(int32_t Data) {
    int32_t * v1 = (int32_t *)(Data + 28); // 0x80abdfc
    int32_t v2 = *v1; // 0x80abdfc
    int32_t * v3 = (int32_t *)Data; // 0x80abdff
    uint32_t v4 = *v3; // 0x80abdff
    int32_t * v5 = (int32_t *)(Data + 4); // 0x80abe04
    uint32_t v6 = *v5; // 0x80abe04
    if (v4 < v6) {
        // 0x80abed2
        *v3 = v4 + 1;
        return 76 * v4 + v2;
    }
    int32_t v7 = Data + 40; // 0x80abe12
    int32_t * v8 = (int32_t *)v7; // 0x80abe12
    int32_t v9 = v6 + 2000; // 0x80abe15
    *v5 = v9;
    int32_t v10 = v9; // 0x80abe1f
    if (*v8 != 0) {
        // 0x80abe21
        r_destroy_tree(v7);
        v10 = *v5;
    }
    int32_t result = (int32_t)MyRealloc((char *)v2, 76 * v10, "GetViaMemory()"); // 0x80abe44
    *v1 = result;
    memset((int32_t *)(76 * *v3 + result), 0, 0x251c0);
    int32_t v11 = r_create_tree(0, 0, 0); // 0x80abe84
    int32_t v12 = *v3; // 0x80abe89
    *v8 = v11;
    if (v12 == 0) {
        // 0x80abed2
        *v3 = 1;
        return result;
    }
    // 0x80abeaf
    r_insert_entry(v11, *v1, 0);
    int32_t v13 = *v3; // 0x80abec9
    int32_t v14 = v13 + 1; // 0x80abecd
    int32_t v15 = v14; // 0x80abed0
    int32_t v16 = 0; // 0x80abed0
    if (v13 == 0) {
        // 0x80abed2
        *v3 = v14;
        return 76 * v13 + result;
    }
    int32_t v17 = v13;
    v16 += v15 - v12;
    int32_t v18 = v17; // 0x80abea8
    while (v17 > v16) {
        // 0x80abeaa
        r_insert_entry(*v8, *v1 + 76 * v16, 0);
        int32_t v19 = *v3; // 0x80abec9
        v15 = v19 + 1;
        v18 = v19;
        if (v19 == 0) {
            // break -> 0x80abed2
            break;
        }
        int32_t v20 = v17;
        v17 = v19;
        v16 += v15 - v20;
        v18 = v17;
    }
    // 0x80abed2
    *v3 = v15;
    return 76 * v18 + result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80abef0 - 0x80ac155
// Line range:    234 - 86
int32_t GetPadMemory(int32_t Element) {
    int32_t * v1 = (int32_t *)(Element + 260); // 0x80abefc
    int32_t v2 = *v1; // 0x80abefc
    int32_t * v3 = (int32_t *)(Element + 232); // 0x80abf02
    uint32_t v4 = *v3; // 0x80abf02
    int32_t * v5 = (int32_t *)(Element + 236); // 0x80abf0b
    uint32_t v6 = *v5; // 0x80abf0b
    if (v4 < v6) {
        // 0x80ac0de
        *v3 = v4 + 1;
        return 104 * v4 + v2;
    }
    // 0x80abf19
    int32_t v7; // 0x80abef0
    char v8; // 0x80abef0
    int32_t v9; // 0x80abef0
    int32_t v10; // 0x80abfa9
    bool v11; // 0x80abef0
    if (*(int32_t *)(*(int32_t *)(PCB + 0x220c) + 52) == 0) {
        int32_t v12 = v6 + 20; // 0x80ac068
        *v5 = v12;
        int32_t v13 = (int32_t)MyRealloc((char *)v2, 104 * v12, "GetPadMemory()"); // 0x80ac086
        int32_t v14 = 104 * *v3 + v13; // 0x80ac097
        *v1 = v13;
        int32_t v15 = 2080; // 0x80ac0a8
        int32_t v16 = v14; // 0x80ac0a8
        if (v14 % 2 != 0) {
            // 0x80ac148
            *(char *)v14 = 0;
            v15 = 2079;
            v16 = v14 + 1;
        }
        int32_t v17 = v15; // 0x80ac0b4
        int32_t v18 = v16; // 0x80ac0b4
        if ((v16 & 2) != 0) {
            // 0x80ac138
            *(int16_t *)v16 = 0;
            v17 = v15 - 2;
            v18 = v16 + 2;
        }
        uint32_t v19 = v17 / 4; // 0x80ac0be
        __asm_rep_stosd_memset((char *)v18, 0, v19);
        int32_t v20 = v19 * (v11 ? -4 : 4) + v18; // 0x80ac0c4
        int32_t v21 = v20; // 0x80ac0c6
        if ((v17 & 2) != 0) {
            // 0x80ac0c8
            *(int16_t *)v20 = 0;
            v21 = v20 + 2;
        }
        // 0x80ac0d0
        v9 = v13;
        if (v17 % 2 != 0) {
            // 0x80ac0d5
            *(char *)v21 = 0;
            v9 = v13;
        }
        goto lab_0x80ac0d8;
    } else {
        int32_t v22 = 0; // 0x80abf83
        int32_t v23 = v6; // 0x80abf83
        v8 = 0;
        if (v4 != 0 && v4 != 0) {
            int32_t v24 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 52); // 0x80abf5c
            int32_t v25 = r_delete_entry(v24, 104 * v22 + v2) != 0 ? 1 : 0; // 0x80abf6e
            uint32_t v26 = *v3; // 0x80abf71
            int32_t v27 = v22 + (int32_t)(v4 == v26); // 0x80abf7f
            while (v26 != 0 && v27 < v26) {
                // 0x80abf44
                v24 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 52);
                v25 = r_delete_entry(v24, 104 * v27 + *v1) != 0 ? 1 : v25;
                v26 = *v3;
                v27 += (int32_t)(v4 == v26);
            }
            // 0x80abf81
            v23 = *v5;
            v8 = v25;
        }
        int32_t v28 = v23 + 20; // 0x80abf8b
        *v5 = v28;
        v10 = (int32_t)MyRealloc((char *)v2, 104 * v28, "GetPadMemory()");
        int32_t v29 = 104 * *v3 + v10; // 0x80abfba
        *v1 = v10;
        int32_t v30 = 2080; // 0x80abfcb
        int32_t v31 = v29; // 0x80abfcb
        if (v29 % 2 != 0) {
            // 0x80ac12b
            *(char *)v29 = 0;
            v30 = 2079;
            v31 = v29 + 1;
        }
        int32_t v32 = v30; // 0x80abfd7
        int32_t v33 = v31; // 0x80abfd7
        if ((v31 & 2) != 0) {
            // 0x80ac11b
            *(int16_t *)v31 = 0;
            v32 = v30 - 2;
            v33 = v31 + 2;
        }
        uint32_t v34 = v32 / 4; // 0x80abfe1
        __asm_rep_stosd_memset((char *)v33, 0, v34);
        int32_t v35 = v34 * (v11 ? -4 : 4) + v33; // 0x80abfe7
        if ((v32 & 2) != 0) {
            // 0x80ac108
            *(int16_t *)v35 = 0;
            v7 = v35 + 2;
            if (v32 % 2 == 0) {
                goto lab_0x80abff8;
            } else {
                goto lab_0x80ac0f8;
            }
        } else {
            // 0x80abfef
            v7 = v35;
            if (v32 % 2 != 0) {
                goto lab_0x80ac0f8;
            } else {
                goto lab_0x80abff8;
            }
        }
    }
  lab_0x80ac0d8:;
    int32_t v36 = v9; // 0x80ac0d8
    int32_t v37 = *v3; // 0x80ac0d8
  lab_0x80ac0de:
    // 0x80ac0de
    *v3 = v37 + 1;
    return 104 * v37 + v36;
  lab_0x80abff8:
    // 0x80abff8
    v9 = v10;
    if (v8 == 0) {
        goto lab_0x80ac0d8;
    } else {
        goto lab_0x80ac002;
    }
  lab_0x80ac0f8:
    // 0x80ac0f8
    *(char *)v7 = 0;
    v9 = v10;
    if (v8 != 0) {
        goto lab_0x80ac002;
    } else {
        goto lab_0x80ac0d8;
    }
  lab_0x80ac002:;
    int32_t v38 = *v3; // 0x80ac002
    int32_t v39 = 0; // 0x80ac011
    int32_t v40 = 0; // 0x80ac011
    while (true) {
        int32_t v41 = v38;
        v36 = v10;
        v37 = v41;
        if (v41 == 0 || v40 >= v41) {
            // break (via goto) -> 0x80ac0de
            goto lab_0x80ac0de;
        }
        int32_t v42 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 52); // 0x80ac048
        r_insert_entry(v42, *v1 + v39, 0);
        int32_t v43 = *v3; // 0x80ac053
        while (v43 != v38) {
            // 0x80ac018
            v41 = v43;
            v36 = v10;
            v37 = v41;
            if (v41 == 0 || v40 >= v41) {
                // break (via goto) -> 0x80ac0de
                goto lab_0x80ac0de;
            }
            // 0x80ac028
            v42 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 52);
            r_insert_entry(v42, *v1 + v39, 0);
            v43 = *v3;
        }
        // 0x80ac05e
        v39 += 104;
        v40++;
    }
    int32_t v44 = v37;
    int32_t v45 = v36;
    *v3 = v44 + 1;
    return 104 * v44 + v45;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/mymem.c
// Address range: 0x80ac160 - 0x80ac3f0
// Line range:    196 - 86
int32_t GetPinMemory(int32_t Element) {
    int32_t * v1 = (int32_t *)(Element + 256); // 0x80ac16c
    int32_t v2 = *v1; // 0x80ac16c
    int32_t * v3 = (int32_t *)(Element + 224); // 0x80ac172
    int32_t v4 = *v3; // 0x80ac172
    char * v5 = (char *)v2;
    char * v6 = v5; // bp-36, 0x80ac178
    int32_t * v7 = (int32_t *)(Element + 228); // 0x80ac17b
    uint32_t v8 = *v7; // 0x80ac17b
    int32_t v9 = v4; // 0x80ac183
    if (v4 >= v8) {
        int32_t v10 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 48); // 0x80ac195
        char * v11; // 0x80ac160
        int32_t v12; // 0x80ac160
        bool v13; // 0x80ac160
        if (v10 == 0) {
            int32_t v14 = v8 + 20; // 0x80ac2f8
            *v7 = v14;
            v11 = v5;
            v12 = v14;
        } else {
            if (v4 != 0) {
                char v15 = r_delete_entry(v10, v2) != 0;
                int32_t v16 = *v3; // 0x80ac1f8
                char v17 = v15; // 0x80ac203
                char v18 = v15; // 0x80ac203
                if (v16 != 0) {
                    int32_t v19 = v16;
                    int32_t v20 = v19 + 1 - v4; // 0x80ac1bc
                    v18 = v17;
                    while (v19 > v20) {
                        int32_t v21 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 48); // 0x80ac1d6
                        char v22 = r_delete_entry(v21, *v1 + 76 * v20) == 0 ? v17 : 1;
                        int32_t v23 = *v3; // 0x80ac1f8
                        v17 = v22;
                        int32_t v24 = v19; // 0x80ac203
                        v18 = v22;
                        if (v23 == 0) {
                            // break -> 0x80ac205
                            break;
                        }
                        v19 = v23;
                        v20 += v19 + 1 - v24;
                        v18 = v17;
                    }
                }
                int32_t v25 = *v7 + 20; // 0x80ac20e
                *v7 = v25;
                char * v26 = MyRealloc(v5, 76 * v25, "GetPinMemory()"); // 0x80ac229
                int32_t v27 = (int32_t)v26; // 0x80ac229
                int32_t v28 = 76 * *v3 + v27; // 0x80ac23a
                *v1 = v27;
                int32_t v29 = 1520; // 0x80ac24b
                int32_t v30 = v28; // 0x80ac24b
                if (v28 % 2 != 0) {
                    // 0x80ac3b6
                    *(char *)v28 = 0;
                    v29 = 1519;
                    v30 = v28 + 1;
                }
                int32_t v31 = v29; // 0x80ac257
                int32_t v32 = v30; // 0x80ac257
                if ((v30 & 2) != 0) {
                    // 0x80ac3c3
                    *(int16_t *)v30 = 0;
                    v31 = v29 - 2;
                    v32 = v30 + 2;
                }
                uint32_t v33 = v31 / 4; // 0x80ac261
                __asm_rep_stosd_memset((char *)v32, 0, v33);
                int32_t v34 = v33 * (v13 ? -4 : 4) + v32; // 0x80ac267
                int32_t v35 = v34; // 0x80ac269
                if ((v31 & 2) != 0) {
                    // 0x80ac26b
                    *(int16_t *)v34 = 0;
                    v35 = v34 + 2;
                }
                if (v31 % 2 != 0) {
                    // 0x80ac278
                    *(char *)v35 = 0;
                }
                int32_t v36 = *v3;
                if (v18 == 0) {
                    // 0x80ac371
                    *v3 = v36 + 1;
                    return 76 * v36 + (int32_t)v26;
                }
                int32_t v37 = v36; // 0x80ac29c
                int32_t v38 = 0; // 0x80ac29c
                if (v36 % 256 == 0) {
                    // 0x80ac371
                    *v3 = 1;
                    return (int32_t)v26;
                }
                r_insert_entry(*(int32_t *)(*(int32_t *)(PCB + 0x220c) + 48), 76 * v38 + *v1, 0);
                int32_t v39 = *v3; // 0x80ac2e5
                int32_t v40 = v39 + 1; // 0x80ac2ed
                int32_t v41 = 0; // 0x80ac2f0
                while (v39 != 0) {
                    // 0x80ac2a8
                    v38 += v40 - 0x1000000 * v37 / 0x1000000;
                    v37 = v39;
                    v41 = v39;
                    if (v39 <= v38) {
                        // break -> 0x80ac371
                        break;
                    }
                    r_insert_entry(*(int32_t *)(*(int32_t *)(PCB + 0x220c) + 48), 76 * v38 + *v1, 0);
                    v39 = *v3;
                    v40 = v39 + 1;
                    v41 = 0;
                }
                // 0x80ac371
                *v3 = v40;
                return 76 * v41 + (int32_t)v26;
            }
            int32_t v42 = v8 + 20; // 0x80ac393
            *v7 = v42;
            v11 = v6;
            v12 = v42;
        }
        char * v43 = MyRealloc(v11, 76 * v12, "GetPinMemory()"); // 0x80ac316
        int32_t v44 = (int32_t)v43; // 0x80ac316
        int32_t v45 = 76 * *v3 + v44; // 0x80ac327
        v6 = v43;
        *v1 = v44;
        int32_t v46 = 1520; // 0x80ac338
        int32_t v47 = v45; // 0x80ac338
        if (v45 % 2 != 0) {
            // 0x80ac3e3
            *(char *)v45 = 0;
            v46 = 1519;
            v47 = v45 + 1;
        }
        int32_t v48 = v46; // 0x80ac344
        int32_t v49 = v47; // 0x80ac344
        if ((v47 & 2) != 0) {
            // 0x80ac3d3
            *(int16_t *)v47 = 0;
            v48 = v46 - 2;
            v49 = v47 + 2;
        }
        uint32_t v50 = v48 / 4; // 0x80ac34e
        __asm_rep_stosd_memset((char *)v49, 0, v50);
        int32_t v51 = v50 * (v13 ? -4 : 4) + v49; // 0x80ac354
        int32_t v52 = v51; // 0x80ac356
        if ((v48 & 2) != 0) {
            // 0x80ac358
            *(int16_t *)v51 = 0;
            v52 = v51 + 2;
        }
        if (v48 % 2 != 0) {
            // 0x80ac365
            *(char *)v52 = 0;
        }
        // 0x80ac368
        v9 = *v3;
    }
    // 0x80ac371
    *v3 = v9 + 1;
    return 76 * v9 + (int32_t)v6;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/netlist.c
// Address range: 0x80ac9e0 - 0x80ac9fc
// Line range:    366 - 366
void register_netlist_action_list(void) {
    // 0x80ac9e0
    hid_register_actions((int32_t)&netlist_action_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.c
// Address range: 0x80acbd0 - 0x80acc36
// Line range:    1723 - 1749
void yy_flush_buffer(int32_t b) {
    if (b == 0) {
        // 0x80acc0a
        return;
    }
    int32_t * v1 = (int32_t *)(b + 4); // 0x80acbda
    int32_t * v2 = (int32_t *)(b + 16); // 0x80acbdd
    *v2 = 0;
    *(char *)*v1 = 0;
    *(char *)(*v1 + 1) = 0;
    int32_t v3 = *v1; // 0x80acbee
    *(int32_t *)(b + 28) = 1;
    *(int32_t *)(b + 36) = 0;
    *(int32_t *)(b + 8) = v3;
    if ((int32_t)g79 != b) {
        // 0x80acc0a
        return;
    }
    // 0x80acc10
    g81 = v3;
    yytext = v3;
    g84 = *v2;
    yyin = *(int32_t *)b;
    g83 = *(char *)v3;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.c
// Address range: 0x80acc40 - 0x80acc9e
// Line range:    1670 - 1686
void yy_delete_buffer(int32_t b) {
    // 0x80acc40
    if (b == 0) {
        // 0x80acc98
        return;
    }
    // 0x80acc4e
    if ((int32_t)g79 == b) {
        // 0x80acc88
        g79 = NULL;
    }
    // 0x80acc56
    if (*(int32_t *)(b + 20) == 0) {
        // 0x80acc5d
        int32_t v1; // 0x80acc40
        free((int32_t *)v1);
        return;
    }
    // 0x80acc70
    free((int32_t *)*(int32_t *)(b + 4));
    free((int32_t *)b);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.c
// Address range: 0x80acca0 - 0x80accd3
// Line range:    1914 - 1921
void yy_fatal_error(char * msg) {
    // 0x80acca0
    int32_t v1; // 0x80acca0
    __fprintf_chk(g43, 1, "%s\n", (char *)v1);
    exit(2);
    // UNREACHABLE
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.c
// Address range: 0x80ace50 - 0x80acea4
// Line range:    1696 - 1716
void yy_init_buffer(int32_t b, struct _IO_FILE * file) {
    // 0x80ace50
    yy_flush_buffer(b);
    *(int32_t *)b = (int32_t)file;
    *(int32_t *)(b + 32) = 1;
    if (file != NULL) {
        // 0x80ace77
        if (isatty(fileno(file)) >= 1) {
            // 0x80ace90
            *(int32_t *)(b + 24) = 1;
            return;
        }
    }
    // 0x80ace90
    *(int32_t *)(b + 24) = 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.c
// Address range: 0x80aceb0 - 0x80acf34
// Line range:    1639 - 1650
int32_t yy_create_buffer(struct _IO_FILE * file, int32_t size) {
    int32_t * mem = calloc(1, 40); // 0x80aceca
    if (mem == NULL) {
        // 0x80acf28
        yy_fatal_error((char *)&g231);
        // UNREACHABLE
    }
    int32_t result = (int32_t)mem; // 0x80aceca
    *(int32_t *)(result + 12) = size;
    int32_t * mem2 = calloc(1, size + 2); // 0x80acee6
    *(int32_t *)(result + 4) = (int32_t)mem2;
    if (mem2 == NULL) {
        // 0x80acf18
        yy_fatal_error((char *)&g231);
        // UNREACHABLE
    }
    // 0x80acef2
    *(int32_t *)(result + 20) = 1;
    yy_init_buffer(result, file);
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.c
// Address range: 0x80acf40 - 0x80acfac
// Line range:    1581 - 1588
void yyrestart(struct _IO_FILE * input_file) {
    int32_t v1 = (int32_t)g79; // 0x80acf4d
    if (g79 == NULL) {
        // 0x80acf90
        v1 = yy_create_buffer((struct _IO_FILE *)yyin, 0x4000);
        g79 = (struct _IO_FILE *)v1;
    }
    // 0x80acf4f
    yy_init_buffer(v1, input_file);
    int32_t v2 = (int32_t)g79; // 0x80acf5e
    g84 = *(int32_t *)(v2 + 16);
    int32_t v3 = *(int32_t *)(v2 + 8); // 0x80acf6c
    g81 = v3;
    yytext = v3;
    yyin = g79->e0;
    g83 = *(char *)v3;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.l
// Address range: 0x80acfb0 - 0x80ad223
// Line range:    203 - 225
int32_t Parse(char * Executable, char * Path, char * Filename, char * Parameter) {
    // 0x80acfb0
    int32_t v1; // 0x80acfb0
    int32_t str = v1;
    int32_t v2 = v1;
    int32_t v3; // 0x80acfb0
    int32_t v4; // 0x80acfb0
    int32_t v5; // 0x80acfb0
    if (v2 == 0 || (char)v2 == 0) {
        int32_t v6 = 2; // 0x80ad0b7
        if (str != 0) {
            // 0x80ad0b9
            v6 = strlen((char *)str) + 2;
        }
        char * str2 = (char *)v1;
        int32_t * mem = calloc(1, strlen(str2) + v6); // 0x80ad0da
        if (mem == NULL) {
            // 0x80ad1fa
            __fprintf_chk(g43, 1, "Parse():  malloc failed\n");
            exit(1);
            // UNREACHABLE
        }
        if ((char)str != 0 == (str != 0)) {
            // 0x80ad188
            __sprintf_chk((char *)mem, 1, -1, "%s%s%s", (char *)str, (char *)&g35, str2);
        } else {
            // 0x80ad0f6
            __sprintf_chk((char *)mem, 1, -1, "%s", str2);
        }
        struct _IO_FILE * file = fopen((char *)mem, "r"); // 0x80ad125
        yyin = (int32_t)file;
        if (file == NULL) {
            // 0x80ad1e0
            Message("Can't open %s for reading\n", mem);
            // 0x80ad0a0
            return 1;
        }
        // 0x80ad137
        free(mem);
        v4 = 0;
        if (g38 != 0) {
            goto lab_0x80ad044;
        } else {
            // 0x80ad137
            v3 = yyin;
            v5 = 0;
            goto lab_0x80ad14e;
        }
    } else {
        int32_t v7 = g80; // 0x80acfce
        if (v7 != 0) {
            // 0x80acfd8
            SaveFree((char *)v7);
            g80 = 0;
        }
        char * command = EvaluateFilename((char *)v2, (char *)str, (char *)v1, Executable); // 0x80ad002
        int32_t v8 = (int32_t)command; // 0x80ad002
        g80 = v8;
        if (*command == 0) {
            // 0x80ad1c8
            PopenErrorMessage((char *)v8);
            return 1;
        }
        struct _IO_FILE * v9 = popen(command, "r"); // 0x80ad025
        int32_t v10 = (int32_t)v9; // 0x80ad025
        yyin = v10;
        if (v9 == NULL) {
            // 0x80ad1c8
            PopenErrorMessage((char *)g80);
            return 1;
        }
        // 0x80ad037
        v4 = 1;
        v3 = v10;
        v5 = 1;
        if (g38 == 0) {
            goto lab_0x80ad14e;
        } else {
            goto lab_0x80ad044;
        }
    }
  lab_0x80ad044:
    // 0x80ad044
    g38 = 0;
    yylineno = 1;
    if (PCB != 0) {
        // 0x80ad065
        SaveTMPData();
    }
    int32_t result = yyparse(); // 0x80ad06a
    RemoveTMPData();
    yy_delete_buffer((int32_t)g79);
    struct _IO_FILE * file2 = (struct _IO_FILE *)yyin;
    if (v4 == 0) {
        // 0x80ad160
        if (fclose(file2) == 0) {
            // 0x80ad0a0
            return result;
        }
        // 0x80ad0a0
        return 1;
    }
    // 0x80ad08b
    if (pclose(file2) == 0) {
        // 0x80ad0a0
        return result;
    }
    // 0x80ad0a0
    return 1;
  lab_0x80ad14e:
    // 0x80ad14e
    yyrestart((struct _IO_FILE *)v3);
    v4 = v5;
    goto lab_0x80ad044;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.l
// Address range: 0x80ad230 - 0x80ad307
// Line range:    330 - 341
int32_t ParseFont(int32_t Ptr, char * Filename) {
    // 0x80ad230
    yyPCB = 0;
    yyElement = 0;
    yyFont = Ptr;
    char * str = __strdup(g153); // 0x80ad260
    char * next_token = strtok(str, ":"); // 0x80ad272
    if (next_token == NULL) {
        // 0x80ad2eb
        free((int32_t *)str);
        return 0;
    }
    // 0x80ad281
    if (*next_token == 0) {
        // 0x80ad2eb
        free((int32_t *)str);
        return 0;
    }
    char * v1 = next_token;
    Message("Looking for %s in %s\n", Filename, v1);
    int32_t result2 = Parse(NULL, (char *)&g231, (char *)&g231, (char *)&g231); // 0x80ad2cb
    while (result2 != 0) {
        char * next_token2 = strtok(NULL, ":"); // 0x80ad297
        int32_t result = result2; // 0x80ad2a0
        if (next_token2 == NULL) {
            // 0x80ad2eb
            free((int32_t *)str);
            return result;
        }
        // 0x80ad2a2
        result = result2;
        if (*next_token2 == 0) {
            // 0x80ad2eb
            free((int32_t *)str);
            return result;
        }
        v1 = next_token2;
        Message("Looking for %s in %s\n", Filename, v1);
        result2 = Parse(NULL, (char *)&g231, (char *)&g231, (char *)&g231);
    }
    // 0x80ad2d7
    Message("Found %s in %s\n", Filename, v1);
    // 0x80ad2eb
    free((int32_t *)str);
    return result2;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.l
// Address range: 0x80ad310 - 0x80ad357
// Line range:    318 - 324
int32_t ParsePCB(int32_t Ptr, char * Filename) {
    // 0x80ad310
    yyData = 0;
    yyFont = 0;
    yyElement = 0;
    yyPCB = Ptr;
    return Parse(NULL, (char *)&g231, (char *)&g231, (char *)&g231);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.l
// Address range: 0x80ad400 - 0x80ad468
// Line range:    358 - 365
int32_t parse_number(float64_t scale) {
    // 0x80ad400
    float64_t val; // bp-20, 0x80ad400
    sscanf((char *)yytext, "%lf", &val);
    float80_t v1 = (float80_t)scale * (float80_t)val; // 0x80ad42b
    float80_t v2; // 0x80ad400
    if (v1 < 0.0L) {
        // 0x80ad43a
        yylval = v2 + (0 ? 0.49L : -0.49L);
        return 258;
    }
    bool v3 = true; // 0x80ad430
    bool v4 = false; // 0x80ad430
    if (v1 <= 0.0L) {
        v3 = v1 != 0.0L;
        v4 = true;
    }
    float80_t v5 = v3 | v4 ? 0.49L : -0.49L;
    yylval = v2 + v5;
    return 258;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_l.c
// Address range: 0x80ad470 - 0x80adee1
// Line range:    753 - 1189
int32_t yylex(void) {
    // 0x80ad470
    char * v1; // 0x80ad470
    char v2; // 0x80ad470
    if (g39 == 0) {
        goto lab_0x80ad664_2;
    } else {
        int32_t v3 = g82;
        g39 = 0;
        g82 = v3 != 0 ? v3 : 1;
        int32_t v4 = yyin; // 0x80ad4b2
        if (yyin == 0) {
            // 0x80ad68c
            v4 = g44;
            yyin = v4;
        }
        // 0x80ad4b8
        if (yyout == 0) {
            // 0x80ad67d
            yyout = g45;
        }
        int32_t v5 = (int32_t)g79; // 0x80ad4d0
        if (g79 == NULL) {
            // 0x80ad69b
            v5 = yy_create_buffer((struct _IO_FILE *)v4, 0x4000);
            g79 = (struct _IO_FILE *)v5;
        }
        int32_t v6 = *(int32_t *)(v5 + 8); // 0x80ad4d9
        g84 = *(int32_t *)(v5 + 16);
        g81 = v6;
        yytext = v6;
        yyin = *(int32_t *)v5;
        char * v7 = (char *)v6;
        char v8 = *v7; // 0x80ad4f4
        g83 = v8;
        v1 = v7;
        v2 = v8;
        goto lab_0x80ad4fc;
    }
  lab_0x80add22:;
    // 0x80add22
    int32_t v9; // 0x80ad470
    int32_t v10 = v9;
    g84 = v10;
    int32_t v11 = v10; // 0x80add28
    goto lab_0x80adbaa;
  lab_0x80adad7:
    // 0x80adad7
    g85 = 0;
    if (yywrap() == 0) {
        int32_t v264 = g85; // 0x80ade76
        if (v264 != 0) {
            goto lab_0x80ad664_2;
        } else {
            int32_t v265 = yyin; // 0x80ade83
            yyrestart((struct _IO_FILE *)v265);
            goto lab_0x80ad664_2;
        }
    }
    int32_t v266 = g82; // 0x80adaee
    int32_t v267 = yytext; // 0x80adaf4
    int32_t v268 = v266 - 1; // 0x80adaf9
    g81 = v267;
    int32_t v51 = (int32_t)((0x100000000 * (int64_t)(v268 >> 31) | (int64_t)v268) / 2) + 47; // 0x80adb0b
    goto lab_0x80ad655;
  lab_0x80adbbe:;
    // 0x80adbbe
    struct _IO_FILE * v89; // bp-36, 0x80ad470
    struct _IO_FILE * v269 = v89; // 0x80adbbe
    int32_t v15; // 0x80ad470
    int32_t v16; // 0x80ad470
    int32_t v17; // 0x80ad470
    int32_t v18; // 0x80ad470
    if (v269 == NULL) {
        int32_t v270 = yyin; // 0x80adeab
        yyrestart((struct _IO_FILE *)v270);
        int32_t v271 = g84; // 0x80adeb8
        struct _IO_FILE * v272 = g79; // 0x80adec3
        v16 = (int32_t)v272;
        v17 = v271;
        v18 = 1;
    } else {
        int32_t v273 = v15;
        int32_t v274 = g84; // 0x80adbc8
        *(int32_t *)(v273 + 36) = 2;
        v16 = v273;
        v17 = v274;
        v18 = 2;
    }
    goto lab_0x80adbda;
  lab_0x80adbda:;
    int32_t v275 = v18;
    int32_t v276 = v17;
    int32_t v277 = v16;
    int32_t v278 = *(int32_t *)(v277 + 4); // 0x80adbda
    struct _IO_FILE * v279 = v89; // 0x80adbdd
    int32_t v280 = v276 + (int32_t)v279; // 0x80adbdd
    g84 = v280;
    *(char *)(v280 + v278) = 0;
    struct _IO_FILE * v281 = g79; // 0x80adbed
    int32_t v282 = g84; // 0x80adbf2
    int32_t v283 = *(int32_t *)((int32_t)v281 + 4); // 0x80adbf8
    *(char *)(v282 + 1 + v283) = 0;
    struct _IO_FILE * v284 = g79; // 0x80adc00
    int32_t * v285 = (int32_t *)((int32_t)v284 + 4);
    int32_t v286 = *v285; // 0x80adc06
    yytext = v286;
    int32_t * v134; // 0x80ad470
    int32_t v189; // 0x80ad470
    int32_t v35; // 0x80ad470
    int32_t v135; // 0x80ad470
    int32_t v83; // 0x80ad7e9
    switch (v275) {
        case 1: {
            goto lab_0x80adad7;
        }
        case 2: {
            // 0x80add2d
            v89 = v284;
            v134 = v285;
            v135 = v286;
            goto lab_0x80ad88e_2;
        }
        default: {
            struct _IO_FILE * v287 = (struct _IO_FILE *)v286; // 0x80adc25
            v89 = v287;
            int32_t v288 = v35 + -1 - v83 + v286; // 0x80adc2b
            int32_t v289 = g82; // 0x80adc2d
            g81 = v288;
            g86 = v289;
            struct _IO_FILE * v290 = v287; // 0x80adc42
            int32_t v291 = v289; // 0x80adc42
            int32_t v292 = &g87; // 0x80adc42
            int32_t v293 = &g87; // 0x80adc42
            if (v288 > v286) {
                int32_t v294; // 0x80adca1
                while (true) {
                    int32_t v295 = v292;
                    int32_t v296 = v291;
                    struct _IO_FILE * v297 = v290; // 0x80adc9b
                    unsigned char v298 = *(char *)v297; // 0x80adc4c
                    int32_t v299 = 1; // 0x80adc51
                    if (v298 != 0) {
                        unsigned char v300 = *(char *)(4 * (int32_t)v298 + (int32_t)&g14); // 0x80adc56
                        v299 = v300;
                    }
                    int32_t v301 = v299;
                    int32_t v302 = v296; // 0x80ad470
                    int32_t v303 = v301; // 0x80ad470
                    int32_t v304; // 0x80ad470
                    while (true) {
                        int32_t v305 = v303;
                        int32_t v306 = v302;
                        int32_t v307 = v306; // 0x80ad470
                        int32_t v308 = v307;
                        int32_t v309 = 2 * v308;
                        int16_t v310 = *(int16_t *)(v309 + (int32_t)&g17); // 0x80adc5e
                        v304 = 2 * (v305 + (int32_t)v310);
                        int16_t v311 = *(int16_t *)(v304 + (int32_t)&g18); // 0x80adc6b
                        if (v308 == (int32_t)v311) {
                            // break (via goto) -> 0x80adc90
                            goto lab_0x80adc90;
                        }
                        uint16_t v312 = *(int16_t *)(v309 + (int32_t)&g15); // 0x80adc77
                        int32_t v313 = v312; // 0x80adc77
                        v307 = v313;
                        while (v312 < 180) {
                            // 0x80adc5e
                            v308 = v307;
                            v309 = 2 * v308;
                            v310 = *(int16_t *)(v309 + (int32_t)&g17);
                            v304 = 2 * (v305 + (int32_t)v310);
                            v311 = *(int16_t *)(v304 + (int32_t)&g18);
                            if (v308 == (int32_t)v311) {
                                // break (via goto) -> 0x80adc90
                                goto lab_0x80adc90;
                            }
                            // 0x80adc77
                            v312 = *(int16_t *)(v309 + (int32_t)&g15);
                            v313 = v312;
                            v307 = v313;
                        }
                        unsigned char v314 = *(char *)(4 * v305 + (int32_t)&g16); // 0x80adc86
                        v302 = v313;
                        v303 = v314;
                    }
                  lab_0x80adc90:;
                    int16_t v315 = *(int16_t *)(v304 + (int32_t)&g19); // 0x80adc93
                    int32_t v316 = v315; // 0x80adc93
                    v89 = (struct _IO_FILE *)((int32_t)v297 + 1);
                    *(int32_t *)v295 = v316;
                    v294 = v295 + 4;
                    struct _IO_FILE * v317 = v89; // 0x80adc3f
                    v290 = v317;
                    v291 = v316;
                    v292 = v294;
                    if (v288 <= (int32_t)v317) {
                        // break -> 0x80adc3f
                        break;
                    }
                }
                // 0x80adc3f
                v293 = v294;
            }
            int32_t v318 = v293;
            struct _IO_FILE * v319 = (struct _IO_FILE *)v318;
            g88 = v319;
            v189 = v318;
            goto lab_0x80adcba;
        }
    }
  lab_0x80adbaa:;
    int32_t v12 = v11; // 0x80adbaa
    struct _IO_FILE * v13 = g79; // 0x80adbb2
    int32_t v14 = (int32_t)v13; // 0x80adbb2
    *(int32_t *)(v14 + 16) = v12;
    v15 = v14;
    v16 = v14;
    v17 = v12;
    v18 = 0;
    if (v12 != 0) {
        goto lab_0x80adbda;
    } else {
        goto lab_0x80adbbe;
    }
  lab_0x80adacc:;
    // 0x80adacc
    int32_t v19; // 0x80ad470
    int32_t v20 = v19;
    int32_t v21; // 0x80ad470
    int32_t v22 = v21;
    struct _IO_FILE * v23; // 0x80ad470
    struct _IO_FILE * v24 = v23; // 0x80adacc
    struct _IO_FILE * v25 = v24; // 0x80adad2
    int32_t v26 = v22; // 0x80adad2
    int32_t v27 = v20; // 0x80adad2
    goto lab_0x80ad5a1;
  lab_0x80adcba:;
    int32_t v188 = v189;
    *(int32_t *)&v89 = v188;
    goto lab_0x80ad51c;
  lab_0x80ad664_2:
    // 0x80ad664
    v1 = (char *)g81;
    v2 = g83;
    goto lab_0x80ad4fc;
  lab_0x80ad4fc:
    // 0x80ad4fc
    *v1 = v2;
    g88 = (struct _IO_FILE *)&g87;
    v89 = (struct _IO_FILE *)&g87;
    g86 = g82;
    while (true) {
      lab_0x80ad51c:;
        // 0x80ad51c
        int32_t v190; // 0x80ad574
        struct _IO_FILE * v191; // 0x80ad470
        while (true) {
            // 0x80ad528
            int32_t v192; // 0x80ad470
            int32_t v193 = v192;
            int16_t v194; // 0x80ad470
            int16_t v195 = v194;
            int32_t v196; // 0x80ad470
            int32_t v197 = v196;
            struct _IO_FILE * v198; // 0x80ad470
            struct _IO_FILE * v199 = v198; // 0x80ad577
            unsigned char v200 = *(char *)v193; // 0x80ad528
            unsigned char v201 = *(char *)(4 * (int32_t)v200 + (int32_t)&g14); // 0x80ad52b
            int32_t v202 = v201; // 0x80ad52b
            int32_t v203 = 2 * (v202 + (int32_t)v195);
            int16_t v204 = *(int16_t *)(v203 + (int32_t)&g18); // 0x80ad560
            int32_t v205 = v202; // 0x80ad56a
            int32_t v206 = v202; // 0x80ad56a
            int32_t v207 = v197; // 0x80ad56a
            int32_t v208 = v203; // 0x80ad56a
            if (v197 != (int32_t)v204) {
                int32_t v209 = v207;
                int32_t v210 = v206;
                uint16_t v211 = *(int16_t *)(2 * v209 + (int32_t)&g15); // 0x80ad538
                int32_t v212 = v210; // 0x80ad545
                int32_t v213; // 0x80ad470
                unsigned char v214; // 0x80ad547
                if (v211 >= 180) {
                    // 0x80ad547
                    v213 = v205;
                    v214 = *(char *)(4 * v213 + (int32_t)&g16);
                    v212 = v214;
                }
                int32_t v215 = v211; // 0x80ad538
                int32_t v216 = v212;
                int16_t v217 = *(int16_t *)(2 * v215 + (int32_t)&g17); // 0x80ad54f
                int32_t v218 = v216 % 256; // 0x80ad557
                int32_t v219 = 2 * (v218 + (int32_t)v217);
                int16_t v220 = *(int16_t *)(v219 + (int32_t)&g18); // 0x80ad560
                v205 = v218;
                v206 = v216;
                v207 = v215;
                v208 = v219;
                while (v211 != v220) {
                    // 0x80ad538
                    v209 = v207;
                    v210 = v206;
                    v211 = *(int16_t *)(2 * v209 + (int32_t)&g15);
                    v212 = v210;
                    if (v211 >= 180) {
                        // 0x80ad547
                        v213 = v205;
                        v214 = *(char *)(4 * v213 + (int32_t)&g16);
                        v212 = v214;
                    }
                    // 0x80ad54f
                    v215 = v211;
                    v216 = v212;
                    v217 = *(int16_t *)(2 * v215 + (int32_t)&g17);
                    v218 = v216 % 256;
                    v219 = 2 * (v218 + (int32_t)v217);
                    v220 = *(int16_t *)(v219 + (int32_t)&g18);
                    v205 = v218;
                    v206 = v216;
                    v207 = v215;
                    v208 = v219;
                }
            }
            int32_t v221 = v208;
            int16_t v222 = *(int16_t *)(v221 + (int32_t)&g19); // 0x80ad56c
            int32_t v223 = v222; // 0x80ad56c
            v190 = v193 + 1;
            v199->e0 = v223;
            v191 = (struct _IO_FILE *)((int32_t)v199 + 4);
            v89 = v191;
            int16_t v224 = *(int16_t *)(2 * v223 + (int32_t)&g17); // 0x80ad582
            v198 = v191;
            v196 = v223;
            v194 = v224;
            v192 = v190;
            if (v224 == 232) {
                // break -> 0x80ad591
                break;
            }
        }
        // 0x80ad591
        g88 = v191;
        v25 = v191;
        v26 = v190;
        int32_t v225; // 0x80ad470
        v27 = v225;
        int32_t v185; // 0x80ade5e
        int32_t v187; // 0x80ad470
        while (true) {
          lab_0x80ad5a1:;
            int32_t v28 = v27;
            int32_t v29 = v26;
            struct _IO_FILE * v30 = v25;
            int32_t v31 = (int32_t)v30; // 0x80ad5af
            int32_t v32 = v29; // 0x80ad5af
            int32_t v33; // 0x80ad470
            int16_t v34; // 0x80ad470
            while (true) {
                // 0x80ad5c8
                v35 = v32;
                int32_t v36 = v31;
                v33 = v36 - 4;
                int32_t v37 = *(int32_t *)v33;
                int32_t v38 = 2 * v37;
                v34 = *(int16_t *)(v38 + (int32_t)&g20);
                if (v34 != 0) {
                    int16_t v39 = *(int16_t *)(v38 + (int32_t)&g21); // 0x80ad5cc
                    if (v34 < v39) {
                        // break -> 0x80ad5d8
                        break;
                    }
                }
                // 0x80ad5b8
                v31 = v33;
                v32 = v35 - 1;
            }
            int32_t v40 = v34;
            g88 = (struct _IO_FILE *)v33;
            int16_t v41 = *(int16_t *)(2 * v40 + (int32_t)&g22); // 0x80ad5e1
            g90 = v40;
            g89 = v35;
            yytext = v28;
            yyleng = v35 - v28;
            char * v42 = (char *)v35; // 0x80ad601
            char v43 = *v42; // 0x80ad601
            g83 = v43;
            *v42 = 0;
            g81 = v35;
            if (v41 != 46) {
                uint32_t v44 = yyleng; // 0x80ad618
                if (v44 >= 1) {
                    int32_t v45 = yytext; // 0x80ad622
                    int32_t v46 = 0; // 0x80ad62a
                    while (true) {
                        int32_t v47 = v46;
                        char v48 = *(char *)(v47 + v45); // 0x80ad637
                        int32_t v49 = v47 + 1;
                        if (v48 != 10) {
                            if (v49 == v44) {
                                // break -> 0x80ad650
                                break;
                            }
                        } else {
                            int32_t v50 = yylineno; // 0x80ad640
                            yylineno = v50 + 1;
                            if (v49 == v44) {
                                // break -> 0x80ad650
                                break;
                            }
                        }
                        // 0x80ad637
                        v46 = v49;
                    }
                }
            }
            // 0x80ad650
            v51 = v41;
            int32_t v52; // 0x80ad470
            while (true) {
              lab_0x80ad655:;
                int32_t v53 = v51;
                g225 = v53;
                int32_t v54 = 0; // 0x80ad676
                int32_t result; // 0x80ad470
                switch (v53) {
                    case 1: {
                        // 0x80ada05
                        v54 = 262;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 2: {
                        // 0x80ad913
                        v54 = 263;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 3: {
                        // 0x80ada0f
                        v54 = 275;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 4: {
                        // 0x80ad6e2
                        v54 = 279;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 5: {
                        // 0x80ad6d6
                        v54 = 289;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 6: {
                        // 0x80ad6cf
                        v54 = 288;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 7: {
                        // 0x80ad6c8
                        v54 = 290;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 8: {
                        // 0x80ad722
                        v54 = 276;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 9: {
                        // 0x80ad719
                        v54 = 264;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 10: {
                        // 0x80ad712
                        v54 = 273;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 11: {
                        // 0x80ad709
                        v54 = 274;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 12: {
                        // 0x80ad702
                        v54 = 265;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 13: {
                        // 0x80ad6f9
                        v54 = 267;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 14: {
                        // 0x80ad6f2
                        v54 = 266;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 15: {
                        // 0x80ad6e9
                        v54 = 269;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 16: {
                        // 0x80ada19
                        v54 = 270;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 17: {
                        // 0x80ad9a5
                        v54 = 271;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 18: {
                        // 0x80ad996
                        v54 = 280;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 19: {
                        // 0x80ad98c
                        v54 = 272;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 20: {
                        // 0x80ad982
                        v54 = 278;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 21: {
                        // 0x80ad9f9
                        v54 = 277;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 22: {
                        // 0x80ad9ef
                        v54 = 281;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 23: {
                        // 0x80ad9e5
                        v54 = 282;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 24: {
                        // 0x80ad9d9
                        v54 = 283;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 25: {
                        // 0x80ad9cf
                        v54 = 284;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 26: {
                        // 0x80ad9c5
                        v54 = 268;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 27: {
                        // 0x80ad9b9
                        v54 = 285;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 28: {
                        // 0x80ad9af
                        v54 = 286;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 29: {
                        // 0x80ad748
                        v54 = 287;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 30: {
                        // 0x80ad73e
                        v54 = 291;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 31: {
                        int32_t v55 = yytext; // 0x80ad729
                        char v56 = *(char *)(v55 + 1); // 0x80ad72e
                        yylval = v56;
                        v54 = 259;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 32: {
                        // 0x80ad79a
                        v54 = parse_number(5.7576694970416511e-315);
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 33: {
                        // 0x80ad787
                        v54 = parse_number(5.345129346743907e-315);
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 34: {
                        // 0x80ad774
                        v54 = parse_number(5.948463104172927e-315);
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 35: {
                        // 0x80ad761
                        v54 = parse_number(5.5355285709140466e-315);
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 36: {
                        // 0x80ad752
                        v54 = parse_number(5.2635442471208903e-315);
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 37: {
                        int32_t str = yytext; // 0x80ad95b
                        sscanf((char *)str, "%x", &yylval);
                        v54 = 258;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 38: {
                        int32_t v57 = yytext; // 0x80ad93e
                        yylval = (float32_t)c_strtod((char *)v57);
                        v54 = 260;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 39: {
                        int32_t v58 = yyleng; // 0x80ad91d
                        if (v58 == 2) {
                            // 0x80ad92b
                            yylval = 0;
                            v54 = v58 & -0x10000 | 261;
                            // 0x80ad6c0
                            result = v54;
                            return result;
                        }
                        // 0x80ada4e
                        yyleng = v58 - 2;
                        int32_t v59 = (int32_t)MyCalloc(v58 - 1, 1, "LEX"); // 0x80ada6d
                        int32_t v60 = yytext; // 0x80ada72
                        yylval = v59;
                        int32_t v61 = yyleng; // 0x80ada85
                        yyleng = v61 - 1;
                        int32_t v62 = v61; // 0x80ada96
                        int32_t v63 = v60; // 0x80ada96
                        int32_t v64 = v59; // 0x80ada96
                        int32_t v65 = v59; // 0x80ada96
                        if (v61 != 0) {
                            int32_t v66 = v64;
                            int32_t v67 = v63;
                            int32_t v68 = v67 + 1; // 0x80ada98
                            char v69 = *(char *)v68; // 0x80ada9b
                            int32_t v70 = v68; // 0x80adaa1
                            char v71 = v69; // 0x80adaa1
                            int32_t v72; // 0x80ad470
                            int32_t v73; // 0x80adaa6
                            char v74; // 0x80adaaf
                            if (v69 == 92) {
                                // 0x80adaa3
                                v72 = v62;
                                v73 = v67 + 2;
                                yyleng = v72 - 2;
                                v74 = *(char *)v73;
                                v70 = v73;
                                v71 = v74;
                            }
                            char v75 = v71;
                            int32_t v76 = v70;
                            *(char *)v66 = v75;
                            int32_t v77 = v66 + 1; // 0x80ada82
                            int32_t v78 = yyleng; // 0x80ada85
                            yyleng = v78 - 1;
                            v62 = v78;
                            v63 = v76;
                            v64 = v77;
                            v65 = v77;
                            while (v78 != 0) {
                                // 0x80ada98
                                v66 = v64;
                                v67 = v63;
                                v68 = v67 + 1;
                                v69 = *(char *)v68;
                                v70 = v68;
                                v71 = v69;
                                if (v69 == 92) {
                                    // 0x80adaa3
                                    v72 = v62;
                                    v73 = v67 + 2;
                                    yyleng = v72 - 2;
                                    v74 = *(char *)v73;
                                    v70 = v73;
                                    v71 = v74;
                                }
                                // 0x80ada80
                                v75 = v71;
                                v76 = v70;
                                *(char *)v66 = v75;
                                v77 = v66 + 1;
                                v78 = yyleng;
                                yyleng = v78 - 1;
                                v62 = v78;
                                v63 = v76;
                                v64 = v77;
                                v65 = v77;
                            }
                        }
                        int32_t v79 = v65;
                        *(char *)v79 = 0;
                        v54 = 261;
                      lab_0x80ad6c0:
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 40: {
                        goto lab_0x80ad664_2;
                    }
                    case 41: {
                        goto lab_0x80ad664_2;
                    }
                    case 42: {
                        goto lab_0x80ad664_2;
                    }
                    case 43: {
                        goto lab_0x80ad664_2;
                    }
                    case 44: {
                        int32_t v80 = yytext; // 0x80ad7ad
                        char v81 = *(char *)v80; // 0x80ad7b2
                        v54 = v81;
                        // 0x80ad6c0
                        result = v54;
                        return result;
                    }
                    case 45: {
                        int32_t stream = yyout; // 0x80ad7ba
                        int32_t size = yyleng; // 0x80ad7cb
                        int32_t v82 = yytext; // 0x80ad7d4
                        fwrite(&((struct _IO_FILE *)v82)->e0, size, 1, (struct _IO_FILE *)stream);
                        goto lab_0x80ad664_2;
                    }
                    case 46: {
                        // 0x80ad7e6
                        v83 = yytext;
                        char v84 = g83; // 0x80ad7f4
                        *v42 = v84;
                        struct _IO_FILE * v85 = g79; // 0x80ad7fd
                        int32_t v86 = (int32_t)v85; // 0x80ad7fd
                        int32_t * v87 = (int32_t *)(v86 + 36);
                        int32_t v88 = *v87; // 0x80ad802
                        v89 = v85;
                        int32_t v90; // 0x80ad470
                        if (v88 != 0) {
                            int32_t v91 = g84; // 0x80ada43
                            v90 = v91;
                        } else {
                            int32_t v92 = *(int32_t *)(v86 + 16); // 0x80ad80f
                            int32_t v93 = yyin; // 0x80ad812
                            g84 = v92;
                            v85->e0 = v93;
                            *v87 = 1;
                            v90 = v92;
                        }
                        int32_t v94 = v90;
                        int32_t v95 = *(int32_t *)(v86 + 4); // 0x80ad827
                        uint32_t v96 = g81; // 0x80ad830
                        uint32_t v97 = v95 + v94;
                        v52 = yytext;
                        if (v97 >= v96) {
                            // break -> 0x80add74
                            break;
                        }
                        if (v96 > v97 + 1) {
                            // 0x80ad857
                            yy_fatal_error((char *)v52);
                            // UNREACHABLE
                        }
                        int32_t v98 = *(int32_t *)(v86 + 32); // 0x80ad878
                        if (v98 != 0) {
                            uint32_t v99 = v96 + -1 - v52; // 0x80adb16
                            struct _IO_FILE * v100 = (struct _IO_FILE *)v99; // 0x80adb1a
                            v89 = v100;
                            int32_t v101 = 0; // 0x80adb1d
                            int32_t * v102 = v87; // 0x80adb1d
                            struct _IO_FILE * v103 = v100; // 0x80adb1d
                            int32_t v104 = v86; // 0x80adb1d
                            if (v99 >= 1) {
                                int32_t v105 = v101;
                                char v106 = *(char *)(v105 + v52); // 0x80adb27
                                *(char *)(v105 + v95) = v106;
                                int32_t v107 = v105 + 1; // 0x80adb2e
                                struct _IO_FILE * v108 = v89; // 0x80adb31
                                v101 = v107;
                                while (v107 != (int32_t)v108) {
                                    // 0x80adb27
                                    v105 = v101;
                                    v106 = *(char *)(v105 + v52);
                                    *(char *)(v105 + v95) = v106;
                                    v107 = v105 + 1;
                                    v108 = v89;
                                    v101 = v107;
                                }
                                struct _IO_FILE * v109 = g79; // 0x80adb36
                                int32_t v110 = (int32_t)v109; // 0x80adb36
                                v102 = (int32_t *)(v110 + 36);
                                v103 = v108;
                                v104 = v110;
                            }
                            int32_t v111 = v104;
                            int32_t * v112 = v102;
                            int32_t v113 = *v112; // 0x80adb3b
                            if (v113 == 2) {
                                // 0x80ade95
                                g84 = 0;
                                *(int32_t *)(v111 + 16) = 0;
                                v15 = v111;
                                goto lab_0x80adbbe;
                            } else {
                                struct _IO_FILE * v114 = v103; // 0x80adb45
                                int32_t v115 = (int32_t)v114; // 0x80adb45
                                int32_t v116 = *(int32_t *)(v111 + 12); // 0x80adb4a
                                int32_t v117 = v116 + -1 - v115; // 0x80adb4a
                                if (v117 >= 0 != v117 != 0) {
                                    // 0x80adb51
                                    yy_fatal_error((char *)&g231);
                                    // UNREACHABLE
                                }
                                int32_t v118 = v117 - 0x2000; // 0x80adb5d
                                uint32_t nmemb = v118 == 0 | v118 < 0 != (0x1fff - v117 & v117) < 0 ? v117 : 0x2000; // 0x80adb68
                                int32_t v119 = *(int32_t *)(v111 + 24); // 0x80adb6d
                                int32_t v120 = 0; // 0x80adb71
                                if (v119 != 0) {
                                    int32_t v121 = v120;
                                    int32_t v122 = yyin; // 0x80adcf5
                                    int32_t v123 = _IO_getc((struct _IO_FILE *)v122); // 0x80adcfd
                                    while (v123 != -1) {
                                        struct _IO_FILE * v124 = g79;
                                        int32_t v125 = (int32_t)v124;
                                        if (v123 == 10) {
                                            struct _IO_FILE * v126 = v89; // 0x80add63
                                            int32_t v127 = *(int32_t *)(v125 + 4); // 0x80add66
                                            *(char *)(v121 + (int32_t)v126 + v127) = 10;
                                            v9 = v121 + 1;
                                            goto lab_0x80add22;
                                        }
                                        int32_t v128 = *(int32_t *)(v125 + 4); // 0x80adcdc
                                        struct _IO_FILE * v129 = v89; // 0x80adce2
                                        int32_t v130 = v121 + 1; // 0x80adcea
                                        *(char *)(v128 + v121 + (int32_t)v129) = (char)v123;
                                        v120 = v130;
                                        v9 = v130;
                                        if (nmemb <= v130) {
                                            goto lab_0x80add22;
                                        }
                                        v121 = v120;
                                        v122 = yyin;
                                        v123 = _IO_getc((struct _IO_FILE *)v122);
                                    }
                                    int32_t stream2 = yyin; // 0x80add07
                                    v9 = v121;
                                    if (ferror((struct _IO_FILE *)stream2) != 0) {
                                        // 0x80add18
                                        yy_fatal_error((char *)&g231);
                                        // UNREACHABLE
                                    }
                                    goto lab_0x80add22;
                                } else {
                                    int32_t stream3 = yyin; // 0x80adb77
                                    int32_t v131 = *(int32_t *)(v111 + 4); // 0x80adb8d
                                    int32_t items_read = fread(&((struct _IO_FILE *)(v131 + v115))->e0, 1, nmemb, (struct _IO_FILE *)stream3); // 0x80adb96
                                    g84 = items_read;
                                    v11 = items_read;
                                    if (items_read == 0) {
                                        int32_t stream4 = yyin; // 0x80add38
                                        if (ferror((struct _IO_FILE *)stream4) != 0) {
                                            // 0x80add49
                                            yy_fatal_error((char *)&g231);
                                            // UNREACHABLE
                                        }
                                        int32_t v132 = g84; // 0x80add53
                                        v11 = v132;
                                    }
                                    goto lab_0x80adbaa;
                                }
                            }
                        } else {
                            if (v96 != v52 + 1) {
                                struct _IO_FILE * v133 = v89;
                                v134 = (int32_t *)((int32_t)v133 + 4);
                                v135 = v52;
                                goto lab_0x80ad88e_2;
                            }
                            goto lab_0x80adad7;
                        }
                    }
                    case 47: {
                        goto lab_0x80ad6c0;
                    }
                    default: {
                        goto lab_0x80ad65a;
                    }
                }
            }
            int32_t v136 = g82; // 0x80add84
            int32_t v137 = v35 + -1 - v83 + v52; // 0x80add89
            g81 = v137;
            g86 = v136;
            int32_t v138 = &g87; // 0x80adda1
            int32_t v139 = v52; // 0x80adda1
            int32_t v140 = v136; // 0x80adda1
            int32_t v141 = v136; // 0x80adda1
            int32_t v142 = &g87; // 0x80adda1
            if (v137 > v52) {
                while (true) {
                    int32_t v143 = v140;
                    int32_t v144 = v139;
                    int32_t v145 = v138;
                    unsigned char v146 = *(char *)v144; // 0x80adda3
                    v89 = (struct _IO_FILE *)1;
                    int32_t v147 = 1; // 0x80addae
                    if (v146 != 0) {
                        unsigned char v148 = *(char *)(4 * (int32_t)v146 + (int32_t)&g14); // 0x80addb6
                        v147 = v148;
                    }
                    int32_t v149 = v147;
                    int32_t v150 = v143; // 0x80ad470
                    int32_t v151 = v149; // 0x80ad470
                    int32_t v152; // 0x80ad470
                    while (true) {
                        int32_t v153 = v151;
                        int32_t v154 = v150;
                        struct _IO_FILE * v155 = (struct _IO_FILE *)v153; // 0x80addcc
                        int32_t v156 = v154; // 0x80ad470
                        int32_t v157 = v156;
                        int32_t v158 = 2 * v157;
                        int16_t v159 = *(int16_t *)(v158 + (int32_t)&g17); // 0x80addbe
                        v89 = v155;
                        v152 = 2 * (v153 + (int32_t)v159);
                        int16_t v160 = *(int16_t *)(v152 + (int32_t)&g18); // 0x80addd8
                        if (v157 == (int32_t)v160) {
                            // break (via goto) -> 0x80ade06
                            goto lab_0x80ade06;
                        }
                        uint16_t v161 = *(int16_t *)(v158 + (int32_t)&g15); // 0x80adde4
                        int32_t v162 = v161; // 0x80adde4
                        v156 = v162;
                        while (v161 < 180) {
                            // 0x80addbe
                            v157 = v156;
                            v158 = 2 * v157;
                            v159 = *(int16_t *)(v158 + (int32_t)&g17);
                            v89 = v155;
                            v152 = 2 * (v153 + (int32_t)v159);
                            v160 = *(int16_t *)(v152 + (int32_t)&g18);
                            if (v157 == (int32_t)v160) {
                                // break (via goto) -> 0x80ade06
                                goto lab_0x80ade06;
                            }
                            // 0x80adde4
                            v161 = *(int16_t *)(v158 + (int32_t)&g15);
                            v162 = v161;
                            v156 = v162;
                        }
                        unsigned char v163 = *(char *)(4 * v153 + (int32_t)&g16); // 0x80addf6
                        v150 = v162;
                        v151 = v163;
                    }
                  lab_0x80ade06:;
                    int32_t v164 = v145 + 4; // 0x80ade09
                    int32_t v165 = v144 + 1; // 0x80ade0c
                    int16_t v166 = *(int16_t *)(v152 + (int32_t)&g19); // 0x80ade0f
                    int32_t v167 = v166; // 0x80ade0f
                    *(int32_t *)v145 = v167;
                    v138 = v164;
                    v139 = v165;
                    v140 = v167;
                    v141 = v167;
                    v142 = v164;
                    if (v165 == v137) {
                        // break -> 0x80ade1d
                        break;
                    }
                }
            }
            int32_t v168 = v142;
            int32_t v169 = v141;
            struct _IO_FILE * v170 = (struct _IO_FILE *)v168; // 0x80ade1f
            g88 = v170;
            int16_t v171 = *(int16_t *)(2 * v169 + (int32_t)&g17); // 0x80ade2f
            int32_t v172 = 2 * (int32_t)v171 | 1;
            int16_t v173 = *(int16_t *)(v172 + 0x814b261); // 0x80ade3a
            int32_t v174 = v169; // 0x80ade44
            int32_t v175 = v172; // 0x80ade44
            if (v169 != (int32_t)v173) {
                int32_t v176 = v174;
                int16_t v177 = *(int16_t *)(2 * v176 + (int32_t)&g15); // 0x80ade27
                int32_t v178 = v177; // 0x80ade27
                int16_t v179 = *(int16_t *)(2 * v178 + (int32_t)&g17); // 0x80ade2f
                int32_t v180 = 2 * (int32_t)v179 | 1;
                int16_t v181 = *(int16_t *)(v180 + 0x814b261); // 0x80ade3a
                v174 = v178;
                v175 = v180;
                while (v177 != v181) {
                    // 0x80ade27
                    v176 = v174;
                    v177 = *(int16_t *)(2 * v176 + (int32_t)&g15);
                    v178 = v177;
                    v179 = *(int16_t *)(2 * v178 + (int32_t)&g17);
                    v180 = 2 * (int32_t)v179 | 1;
                    v181 = *(int16_t *)(v180 + 0x814b261);
                    v174 = v178;
                    v175 = v180;
                }
            }
            int32_t v182 = v175;
            int16_t v183 = *(int16_t *)(v182 + 0x814b4a1); // 0x80ade46
            v23 = v170;
            v21 = v137;
            v19 = v52;
            if (v183 != 179) {
                int32_t v184 = v183; // 0x80ade46
                *(int32_t *)v168 = v184;
                v185 = v168 + 4;
                struct _IO_FILE * v186 = (struct _IO_FILE *)v185;
                g88 = v186;
                v187 = g81;
                v23 = v186;
                v21 = v187;
                v19 = v52;
                if (v183 != 0) {
                    // break -> 0x80adecd
                    break;
                }
            }
            goto lab_0x80adacc;
        }
        int32_t v226 = v187 + 1; // 0x80aded3
        g81 = v226;
        v189 = v185;
        goto lab_0x80adcba;
    }
  lab_0x80ad65a:
    // 0x80ad65a
    yy_fatal_error((char *)&g231);
    // UNREACHABLE
  lab_0x80ad88e_2:;
    int32_t v227 = v135;
    int32_t * v228 = v134;
    int32_t v229 = g82; // 0x80ad899
    int32_t v230 = *v228; // 0x80ad8a1
    int32_t v231 = g84; // 0x80ad8a4
    int32_t v232 = v231 + v230; // 0x80ad8a4
    struct _IO_FILE * v233 = (struct _IO_FILE *)v227; // 0x80ad8aa
    v89 = v233;
    g86 = v229;
    g81 = v232;
    struct _IO_FILE * v234 = v233; // 0x80ad8bd
    int32_t v235 = v229; // 0x80ad8bd
    int32_t v236 = &g87; // 0x80ad8bd
    int32_t v237 = &g87; // 0x80ad8bd
    if (v232 > v227) {
        while (true) {
            int32_t v238 = v236;
            int32_t v239 = v235;
            struct _IO_FILE * v240 = v234; // 0x80ada30
            unsigned char v241 = *(char *)v240; // 0x80ad8cb
            int32_t v242 = 1; // 0x80ad8d0
            if (v241 != 0) {
                unsigned char v243 = *(char *)(4 * (int32_t)v241 + (int32_t)&g14); // 0x80ad8d5
                v242 = v243;
            }
            int32_t v244 = v242;
            int32_t v245 = v239; // 0x80ad470
            int32_t v246 = v244; // 0x80ad470
            int32_t v247; // 0x80ad470
            while (true) {
                int32_t v248 = v246;
                int32_t v249 = v245;
                int32_t v250 = v249; // 0x80ad470
                int32_t v251 = v250;
                int32_t v252 = 2 * v251;
                int16_t v253 = *(int16_t *)(v252 + (int32_t)&g17); // 0x80ad8dd
                v247 = 2 * (v248 + (int32_t)v253);
                int16_t v254 = *(int16_t *)(v247 + (int32_t)&g18); // 0x80ad8ea
                if (v251 == (int32_t)v254) {
                    // break (via goto) -> 0x80ada25
                    goto lab_0x80ada25;
                }
                uint16_t v255 = *(int16_t *)(v252 + (int32_t)&g15); // 0x80ad8fa
                int32_t v256 = v255; // 0x80ad8fa
                v250 = v256;
                while (v255 < 180) {
                    // 0x80ad8dd
                    v251 = v250;
                    v252 = 2 * v251;
                    v253 = *(int16_t *)(v252 + (int32_t)&g17);
                    v247 = 2 * (v248 + (int32_t)v253);
                    v254 = *(int16_t *)(v247 + (int32_t)&g18);
                    if (v251 == (int32_t)v254) {
                        // break (via goto) -> 0x80ada25
                        goto lab_0x80ada25;
                    }
                    // 0x80ad8fa
                    v255 = *(int16_t *)(v252 + (int32_t)&g15);
                    v256 = v255;
                    v250 = v256;
                }
                unsigned char v257 = *(char *)(4 * v248 + (int32_t)&g16); // 0x80ad909
                v245 = v256;
                v246 = v257;
            }
          lab_0x80ada25:;
            int16_t v258 = *(int16_t *)(v247 + (int32_t)&g19); // 0x80ada28
            int32_t v259 = v258; // 0x80ada28
            v89 = (struct _IO_FILE *)((int32_t)v240 + 1);
            int32_t v260 = v238 + 4; // 0x80ada36
            *(int32_t *)v238 = v259;
            struct _IO_FILE * v261 = v89; // 0x80ad8ba
            v234 = v261;
            v235 = v259;
            v236 = v260;
            v237 = v260;
            if (v232 <= (int32_t)v261) {
                // break -> 0x80adac1
                break;
            }
        }
    }
    int32_t v262 = v237;
    struct _IO_FILE * v263 = (struct _IO_FILE *)v262; // 0x80adac6
    g88 = v263;
    v23 = v263;
    v21 = v232;
    v19 = v227;
    goto lab_0x80adacc;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_y.y
// Address range: 0x80adef0 - 0x80adefa
// Line range:    1906 - 1909
int32_t yywrap(void) {
    // 0x80adef0
    return 1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/parse_y.c
// Address range: 0x80adf30 - 0x80b093b
// Line range:    1711 - 910
int32_t yyparse(void) {
    // 0x80adf30
    int32_t v1; // bp-3188, 0x80adf30
    int32_t v2 = &v1; // 0x80adf42
    int32_t v3 = __readgsdword(20); // 0x80adf4c
    int32_t v4; // bp-788, 0x80adf30
    int32_t v5 = &v4; // 0x80adf69
    yynerrs = 0;
    yychar = -2;
    int32_t v6; // bp-52, 0x80adf30
    int32_t v7 = &v6;
    int32_t v8; // bp-40, 0x80adf30
    int32_t v9 = &v8;
    int32_t v10; // bp-376, 0x80adf30
    int32_t v11 = &v10;
    int32_t v12; // bp-3212, 0x80adf30
    int32_t v13 = &v12;
    int32_t v14 = v2; // 0x80adfbb
    int32_t v15 = v5; // 0x80adfbb
    int32_t v16 = 200; // 0x80adfbb
    int32_t v17 = 0; // 0x80adfbb
    int32_t v18 = 199; // 0x80adfbb
    int32_t v19 = v5; // 0x80adfbb
    int32_t v20 = 0; // 0x80adfbb
    int32_t v21; // bp-3388, 0x80adf30
    int32_t v22 = &v21; // 0x80adfbb
    int32_t v23 = v2; // 0x80adfbb
    int32_t * v24; // 0x80adf30
    int32_t v25; // 0x80adf30
    int32_t v26; // 0x80adf30
    int32_t v27; // 0x80adf30
    int32_t v28; // 0x80adf30
    int32_t nmemb; // 0x80adf30
    int32_t v29; // 0x80adf30
    int32_t v30; // 0x80adf30
    int32_t v31; // 0x80adf30
    int32_t v32; // 0x80adf30
    int32_t v33; // 0x80adf30
    int32_t v34; // 0x80adf30
    int32_t v35; // 0x80adf30
    int32_t v36; // 0x80adf30
    int32_t v37; // 0x80adf30
    int32_t v38; // 0x80adf30
    int32_t v39; // 0x80adf30
    int32_t v40; // 0x80adf30
    int32_t v41; // 0x80adf30
    int32_t v42; // 0x80adf30
    int32_t v43; // 0x80adf30
    int32_t v44; // 0x80adf30
    int32_t v45; // 0x80adf30
    int32_t v46; // 0x80adf30
    int32_t v47; // 0x80adf30
    int32_t v48; // 0x80adf30
    int32_t v49; // 0x80adf30
    int32_t v50; // 0x80adf30
    int32_t v51; // 0x80adf30
    int32_t v52; // 0x80adf30
    int32_t v53; // 0x80adf30
    int32_t v54; // 0x80adf30
    int32_t v55; // 0x80adf30
    int32_t * v56; // 0x80adf30
    int32_t v57; // 0x80adf30
    int32_t v58; // 0x80adf30
    int32_t v59; // 0x80adf30
    int32_t v60; // 0x80adf30
    int32_t v61; // 0x80adf30
    int32_t v62; // 0x80adf30
    int32_t v63; // 0x80adf30
    while (true) {
      lab_0x80adfc1:
        // 0x80adfc1
        v28 = v23;
        v31 = v22;
        v26 = v20;
        nmemb = v19;
        v51 = v50;
        v54 = v53;
        v62 = v61;
        int32_t v64 = v38;
        v58 = v18;
        v57 = v17;
        int32_t v65 = v16;
        v35 = v15;
        v32 = v14;
        *(int16_t *)nmemb = (int16_t)v26;
        v33 = v32;
        v36 = v35;
        v42 = v65;
        v59 = v58;
        v45 = v28;
        v49 = v47;
        v39 = v64;
        v30 = nmemb;
        if (nmemb < 2 * v58 + v35) {
            goto lab_0x80ae11b;
        } else {
            // 0x80adfe1
            v56 = (int32_t *)v31;
            if (v65 < 0x2710) {
                // 0x80adff1
                *v56 = 1;
                uint32_t v66 = 2 * v65; // 0x80ae00e
                int32_t v67 = v66 < 0x2710 ? v66 : 0x2710; // 0x80ae015
                int32_t v68 = 2 * v67; // 0x80ae022
                int32_t * v69 = (int32_t *)(v31 + 4);
                *v69 = 14 * v67 + 11;
                int32_t * mem = calloc(nmemb, (int32_t)&g231); // 0x80ae040
                v24 = v69;
                v44 = v67;
                v41 = v68;
                if (mem == NULL) {
                    goto lab_0x80b06d2;
                } else {
                    int32_t v70 = (int32_t)mem; // 0x80ae040
                    int32_t v71 = nmemb - v35; // 0x80ae055
                    *v56 = v70;
                    int32_t v72 = v71 / 2; // 0x80ae064
                    int32_t v73 = v72 + 1; // 0x80ae066
                    int32_t v74 = 2 * v73; // 0x80ae06b
                    int32_t * v75 = (int32_t *)(v31 + 8); // 0x80ae073
                    *v75 = v74;
                    *v69 = v35;
                    memcpy((int32_t *)v74, &g231, (int32_t)&g231);
                    *v69 = v28;
                    *v75 = 12 * v73;
                    int32_t v76 = 4 * (v68 + 11) / 12 + v70; // 0x80ae0b3
                    *v56 = v76;
                    memcpy((int32_t *)v76, &g231, (int32_t)&g231);
                    if (v35 != v5) {
                        // 0x80ae0d2
                        *v56 = v35;
                        free(&g231);
                    }
                    int32_t v77 = v67 - 1; // 0x80ae0e9
                    int32_t v78 = v71 & -2; // 0x80ae0ec
                    int32_t v79 = v78 + v70; // 0x80ae0ef
                    v34 = v73;
                    v37 = v70;
                    v43 = v67;
                    v60 = v77;
                    v46 = v76;
                    v48 = v74;
                    v40 = v68;
                    v63 = v62;
                    v55 = v54;
                    v52 = v51;
                    v25 = 0;
                    v29 = v79;
                    v27 = 1;
                    if (v79 >= 2 * v77 + v70) {
                        goto lab_0x80aece1;
                    } else {
                        // 0x80ae103
                        v33 = v76 + 4 * (v78 + v72);
                        v36 = v70;
                        v42 = v67;
                        v59 = v77;
                        v45 = v76;
                        v49 = v74;
                        v39 = v68;
                        v30 = v79;
                        goto lab_0x80ae11b;
                    }
                }
            } else {
                // 0x80adfe1
                v24 = (int32_t *)(v31 + 4);
                v44 = v65;
                v41 = v64;
                goto lab_0x80b06d2;
            }
        }
    }
  lab_0x80ae3cb:;
    // 0x80ae3cb
    int32_t result; // 0x80adf30
    return result;
  lab_0x80ae11b:;
    int32_t v80 = v30;
    int32_t v81 = v49;
    int32_t v82 = v45;
    int32_t v83 = v59;
    int32_t v84 = v42;
    int32_t v85 = v36;
    int32_t v86 = v33;
    int16_t v87 = *(int16_t *)(2 * v26 + (int32_t)&g23); // 0x80ae11b
    int32_t v88 = v87; // 0x80ae11b
    int32_t v89 = v81; // 0x80ae129
    int32_t v90; // 0x80adf30
    int32_t v91; // 0x80adf30
    int32_t v92; // 0x80adf30
    int32_t v93; // 0x80adf30
    int32_t v94; // 0x80adf30
    int32_t v95; // 0x80adf30
    int32_t v96; // 0x80adf30
    int32_t v97; // 0x80adf30
    int32_t v98; // 0x80adf30
    int32_t v99; // 0x80adf30
    int32_t v100; // 0x80adf30
    int32_t v101; // 0x80adf30
    int32_t v102; // 0x80adf30
    int32_t v103; // 0x80adf30
    int32_t v104; // 0x80adf30
    int32_t v105; // 0x80adf30
    int32_t v106; // 0x80adf30
    int32_t v107; // 0x80adf30
    if (v87 == -424) {
        goto lab_0x80ae16f;
    } else {
        int32_t v108 = v39;
        int32_t v109 = v81; // 0x80ae133
        int32_t v110 = yychar; // 0x80ae133
        if (yychar == -2) {
            // 0x80ae488
            v110 = yylex();
            yychar = v110;
            v109 = v80;
        }
        int32_t v111 = v110;
        int32_t v112 = v109;
        int32_t v113; // 0x80adf30
        int32_t v114; // 0x80adf30
        if (v111 < 1) {
            // 0x80ae420
            yychar = 0;
            v113 = 0;
            v114 = 0;
        } else {
            // 0x80ae141
            v113 = v111;
            v114 = 2;
            if (v111 < 292) {
                unsigned char v115 = *(char *)(v111 + (int32_t)&g24); // 0x80ae14d
                v113 = v111;
                v114 = v115;
            }
        }
        int32_t v116 = v114;
        uint32_t v117 = v116 + v88; // 0x80ae154
        v89 = v112;
        if (v117 < 590) {
            int32_t v118 = 2 * v117;
            int16_t v119 = *(int16_t *)(v118 + (int32_t)&g25); // 0x80ae15f
            v89 = v112;
            if (v116 == (int32_t)v119) {
                int16_t v120 = *(int16_t *)(v118 + (int32_t)&g26); // 0x80ae2c0
                int32_t v121 = v120; // 0x80ae2c0
                if (v120 >= 0 == (v120 != 0)) {
                    // 0x80ae4a3
                    v34 = v86;
                    v37 = v85;
                    v43 = v84;
                    v60 = v83;
                    v46 = v82;
                    v48 = v112;
                    v40 = v108;
                    v63 = v62;
                    v55 = v54;
                    v52 = v51;
                    v25 = 0;
                    v29 = v80;
                    v27 = 0;
                    if (v120 == 10) {
                        goto lab_0x80aece1;
                    } else {
                        int32_t v122 = v86 + 12; // 0x80ae4cd
                        yychar = v113 == 0 ? 0 : -2;
                        *(int32_t *)v122 = yylval;
                        *(int32_t *)(v86 + 16) = g222;
                        *(int32_t *)(v86 + 20) = g223;
                        v93 = v122;
                        v94 = v85;
                        v98 = v84;
                        v105 = v57 - 1 + (int32_t)(v57 == 0);
                        v106 = v83;
                        v99 = v82;
                        v101 = v112;
                        v96 = v108;
                        v107 = v62;
                        v104 = v54;
                        v103 = v51;
                        v91 = v80;
                        v90 = v121;
                        v92 = v31;
                        goto lab_0x80ae2ae;
                    }
                } else {
                    // 0x80ae2d0
                    v102 = v112;
                    v97 = v108;
                    switch (v120) {
                        case -93: {
                            goto lab_0x80ae2e0;
                        }
                        case 0: {
                            goto lab_0x80ae2e0;
                        }
                        default: {
                            // 0x80ae548
                            v100 = v112;
                            v95 = -v121;
                            goto lab_0x80ae184;
                        }
                    }
                }
            } else {
                goto lab_0x80ae16f;
            }
        } else {
            goto lab_0x80ae16f;
        }
    }
  lab_0x80ae16f:;
    unsigned char v123 = *(char *)(v26 + (int32_t)&g27); // 0x80ae16f
    v100 = v89;
    v95 = v123;
    v102 = v89;
    v97 = 0;
    if (v123 == 0) {
        goto lab_0x80ae2e0;
    } else {
        goto lab_0x80ae184;
    }
  lab_0x80ae2e0:;
    int32_t v124 = v97;
    int32_t v125 = v102;
    int32_t v126 = v125; // 0x80adf30
    switch (v57) {
        case 0: {
            // 0x80ae438
            yynerrs++;
            *(int32_t *)(v31 + 8) = yylineno;
            *(int32_t *)(v31 + 12) = (int32_t)"syntax error";
            *(int32_t *)v31 = (int32_t)"ERROR parsing file '%s'\n    line:        %i\n    description: '%s'\n";
            *(int32_t *)(v31 + 4) = yyfilename;
            Message((char *)v80);
            v126 = v80;
            goto lab_0x80ae329;
        }
        case 3: {
            int32_t v127 = yychar; // 0x80ae3f8
            if (v127 < 1) {
                // 0x80ae52b
                v126 = v125;
                v34 = v86;
                v37 = v85;
                v43 = v84;
                v60 = v83;
                v46 = v82;
                v48 = v125;
                v40 = v124;
                v63 = v62;
                v55 = v54;
                v52 = v51;
                v25 = 0;
                v29 = v80;
                v27 = 1;
                if (v127 != 0) {
                    goto lab_0x80ae329;
                } else {
                    goto lab_0x80aece1;
                }
            } else {
                // 0x80ae405
                yychar = -2;
                v126 = v125;
                goto lab_0x80ae329;
            }
        }
        default: {
            goto lab_0x80ae329;
        }
    }
  lab_0x80ae184:;
    int32_t v128 = v95;
    int32_t v129 = v100;
    unsigned char v130 = *(char *)(v128 + (int32_t)&g28); // 0x80ae195
    int32_t v131 = v130; // 0x80ae195
    int32_t v132 = 12 * (1 - v131) + v86;
    v6 = *(int32_t *)v132;
    int32_t v133 = *(int32_t *)(v132 + 4); // 0x80ae1b4
    int32_t v134 = *(int32_t *)(v132 + 8); // 0x80ae1bb
    g224 = v128 - 5;
    int32_t v135 = v86; // 0x80ae1d2
    int32_t v136 = v85; // 0x80ae1d2
    int32_t v137 = v84; // 0x80ae1d2
    int32_t v138 = v83; // 0x80ae1d2
    int32_t v139 = v82; // 0x80ae1d2
    int32_t v140 = v129; // 0x80ae1d2
    int32_t v141 = v128; // 0x80ae1d2
    int32_t v142 = v131; // 0x80ae1d2
    int32_t v143 = v133; // 0x80ae1d2
    int32_t v144 = v134; // 0x80ae1d2
    int32_t v145 = v80; // 0x80ae1d2
    int32_t v146 = v31; // 0x80ae1d2
    int32_t * v147; // 0x80adf30
    int32_t * v148; // 0x80adf30
    int32_t * v149; // 0x80adf30
    int32_t * v150; // 0x80adf30
    int32_t * v151; // 0x80adf30
    int32_t * v152; // 0x80adf30
    int32_t * v153; // 0x80adf30
    int32_t * v154; // 0x80adf30
    int32_t * v155; // 0x80adf30
    int32_t * v156; // 0x80adf30
    int32_t * v157; // 0x80adf30
    int32_t * v158; // 0x80adf30
    int32_t * v159; // 0x80adf30
    int32_t * v160; // 0x80adf30
    int32_t * v161; // 0x80adf30
    int32_t * v162; // 0x80adf30
    int32_t * v163; // 0x80adf30
    int32_t * v164; // 0x80adf30
    int32_t * v165; // 0x80adf30
    int32_t * v166; // 0x80adf30
    int32_t v167; // 0x80adf30
    int32_t v168; // 0x80adf30
    int32_t v169; // 0x80adf30
    int32_t v170; // 0x80adf30
    int32_t v171; // 0x80adf30
    int32_t v172; // 0x80adf30
    int32_t v173; // 0x80adf30
    int32_t v174; // 0x80adf30
    int32_t v175; // 0x80adf30
    int32_t v176; // 0x80adf30
    int32_t v177; // 0x80adf30
    int32_t v178; // 0x80adf30
    int32_t v179; // 0x80adf30
    int32_t v180; // 0x80adf30
    int32_t v181; // 0x80adf30
    int32_t v182; // 0x80adf30
    int32_t v183; // 0x80adf30
    int32_t v184; // 0x80adf30
    int32_t v185; // 0x80adf30
    int32_t v186; // 0x80adf30
    int32_t v187; // 0x80adf30
    int32_t v188; // 0x80adf30
    int32_t v189; // 0x80adf30
    int32_t v190; // 0x80adf30
    int32_t v191; // 0x80adf30
    int32_t v192; // 0x80adf30
    int32_t v193; // 0x80adf30
    int32_t v194; // 0x80adf30
    int32_t v195; // 0x80adf30
    int32_t v196; // 0x80adf30
    int32_t v197; // 0x80adf30
    int32_t v198; // 0x80adf30
    int32_t v199; // 0x80adf30
    int32_t v200; // 0x80b0100
    int32_t * v201; // 0x80adf30
    int32_t v202; // 0x80adf30
    int32_t v203; // 0x80adf30
    int32_t v204; // 0x80adf30
    int32_t v205; // 0x80adf30
    switch (v128) {
        case 5: {
            goto lab_0x80aecd2;
        }
        case 6: {
            int32_t v206 = 0; // 0x80aec86
            if (yyPCB == 0) {
                // 0x80b088f
                *(int32_t *)v31 = (int32_t)"illegal fileformat\n";
                // 0x80b0885
                Message((char *)&g231);
                goto lab_0x80af56c;
            } else {
                *(char *)(v206 + (int32_t)&LayerFlag) = 0;
                int32_t v207 = v206 + 1; // 0x80aec95
                v206 = v207;
                while (v207 != 18) {
                    // 0x80aec8e
                    *(char *)(v206 + (int32_t)&LayerFlag) = 0;
                    v207 = v206 + 1;
                    v206 = v207;
                }
                // 0x80aec9d
                layer_group_string = 0;
                yyFont = yyPCB + 184;
                int32_t v208 = *(int32_t *)(yyPCB + 0x220c); // 0x80aecb8
                yyData = v208;
                *(int32_t *)(v208 + 72) = yyPCB;
                *(int32_t *)(v208 + 24) = 0;
                v135 = v86;
                v136 = v85;
                v137 = v84;
                v138 = v83;
                v139 = v82;
                v140 = v129;
                v141 = 6;
                v142 = v131;
                v143 = v133;
                v144 = v134;
                v145 = v80;
                v146 = v31;
                goto lab_0x80ae240;
            }
        }
        case 7: {
            int32_t v209 = PCB; // 0x80aeb80
            if (layer_group_string == 0) {
                // 0x80b0864
                layer_group_string = g151;
            }
            int32_t * v210 = (int32_t *)(v31 + 4); // 0x80aeba4
            *v210 = 0;
            int32_t * v211 = (int32_t *)v31; // 0x80aebac
            *v211 = yyPCB;
            CreateNewPCBPost(v80, (int32_t)&g231);
            int32_t * v212 = (int32_t *)(v31 + 8); // 0x80aebbc
            *v212 = *(int32_t *)(yyData + 24);
            *v210 = yyPCB + 0x1cd4;
            *v211 = layer_group_string;
            int32_t v213 = ParseGroupString((char *)&g231, (int32_t)&g231, (int32_t)&g231); // 0x80aebd6
            if (v213 != 0) {
                // 0x80b087e
                *v211 = (int32_t)"illegal layer-group string\n";
                // 0x80b0885
                Message((char *)&g231);
                goto lab_0x80af56c;
            } else {
                // 0x80aebe9
                PCB = yyPCB;
                int32_t v214 = 0; // 0x80aec06
                int32_t v215 = yyData; // 0x80aec06
                if (*(int32_t *)(yyData + 24) >= 0xffffffff) {
                    int32_t v216 = 92 * v214; // 0x80aec0e
                    int32_t v217 = v216 + 88;
                    int32_t v218 = v215; // 0x80aec1b
                    int32_t v219 = 0; // 0x80aec1b
                    int32_t v220 = v215; // 0x80aec1b
                    int32_t v221; // 0x80aec2b
                    int32_t v222; // 0x80adf30
                    if (*(int32_t *)(v217 + v215) != 0) {
                        v221 = v219 + 1;
                        v222 = v218 + v216;
                        *v211 = v218;
                        *v212 = 60 * v219 + *(int32_t *)(v222 + 120);
                        *v210 = v222 + 76;
                        InitClip((int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
                        v218 = yyData;
                        v219 = v221;
                        v220 = yyData;
                        while (*(int32_t *)(yyData + v217) > v221) {
                            // 0x80aec28
                            v221 = v219 + 1;
                            v222 = v218 + v216;
                            *v211 = v218;
                            *v212 = 60 * v219 + *(int32_t *)(v222 + 120);
                            *v210 = v222 + 76;
                            InitClip((int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
                            v218 = yyData;
                            v219 = v221;
                            v220 = yyData;
                        }
                    }
                    int32_t v223 = v214 + 1; // 0x80aec56
                    v214 = v223;
                    v215 = v220;
                    while (*(int32_t *)(v220 + 24) + 1 >= v223) {
                        // 0x80aec0e
                        v216 = 92 * v214;
                        v217 = v216 + 88;
                        v218 = v215;
                        v219 = 0;
                        v220 = v215;
                        if (*(int32_t *)(v217 + v215) != 0) {
                            v221 = v219 + 1;
                            v222 = v218 + v216;
                            *v211 = v218;
                            *v212 = 60 * v219 + *(int32_t *)(v222 + 120);
                            *v210 = v222 + 76;
                            InitClip((int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
                            v218 = yyData;
                            v219 = v221;
                            v220 = yyData;
                            while (*(int32_t *)(yyData + v217) > v221) {
                                // 0x80aec28
                                v221 = v219 + 1;
                                v222 = v218 + v216;
                                *v211 = v218;
                                *v212 = 60 * v219 + *(int32_t *)(v222 + 120);
                                *v210 = v222 + 76;
                                InitClip((int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
                                v218 = yyData;
                                v219 = v221;
                                v220 = yyData;
                            }
                        }
                        // 0x80aec53
                        v223 = v214 + 1;
                        v214 = v223;
                        v215 = v220;
                    }
                }
                // 0x80aec6e
                PCB = 0x1000000 * v209 / 0x1000000;
                v135 = v86;
                v136 = v85;
                v137 = v84;
                v138 = v83;
                v139 = v82;
                v140 = v80;
                v141 = 7;
                v142 = v131;
                v143 = v133;
                v144 = v134;
                v145 = v80;
                v146 = v31;
                goto lab_0x80ae240;
            }
        }
        case 8: {
            // 0x80aeb60
            PreLoadElementPCB();
            layer_group_string = 0;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 8;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 9: {
            // 0x80aeb30
            LayerFlag[0] = 1;
            *(char *)&g92 = 1;
            *(int32_t *)(yyData + 24) = 2;
            PostLoadElementPCB();
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 9;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 10: {
            int32_t v224 = 0; // 0x80aeafb
            if (yyData == 0 || yyFont == 0) {
                // 0x80b088f
                *(int32_t *)v31 = (int32_t)"illegal fileformat\n";
                // 0x80b0885
                Message((char *)&g231);
                goto lab_0x80af56c;
            } else {
                *(char *)(v224 + (int32_t)&LayerFlag) = 0;
                int32_t v225 = v224 + 1; // 0x80aeb17
                v224 = v225;
                while (v225 != 18) {
                    // 0x80aeb10
                    *(char *)(v224 + (int32_t)&LayerFlag) = 0;
                    v225 = v224 + 1;
                    v224 = v225;
                }
                // 0x80aeb1f
                *(int32_t *)(yyData + 24) = 0;
                v135 = v86;
                v136 = v85;
                v137 = v84;
                v138 = v83;
                v139 = v82;
                v140 = v129;
                v141 = 10;
                v142 = v131;
                v143 = v133;
                v144 = v134;
                v145 = v80;
                v146 = v31;
                goto lab_0x80ae240;
            }
        }
        case 14: {
            int32_t v226 = yyFont; // 0x80aeabd
            if (v226 == 0) {
                // 0x80b089e
                *(int32_t *)v31 = (int32_t)"illegal fileformat\n";
                Message((char *)v80);
                goto lab_0x80af56c;
            } else {
                // 0x80aeaca
                *(char *)(v226 + 0x1c18) = 0;
                int32_t v227 = 0;
                int32_t v228 = v227 + 28;
                *(char *)(v228 + yyFont) = 0;
                v135 = v86;
                v136 = v85;
                v137 = v84;
                v138 = v83;
                v139 = v82;
                v140 = v129;
                v141 = 14;
                v142 = v131;
                v143 = v133;
                v144 = v134;
                v145 = v80;
                v146 = v31;
                while (v227 != 0x1be4) {
                    // 0x80aeae0
                    v227 = v228;
                    v228 = v227 + 28;
                    *(char *)(v228 + yyFont) = 0;
                    v135 = v86;
                    v136 = v85;
                    v137 = v84;
                    v138 = v83;
                    v139 = v82;
                    v140 = v129;
                    v141 = 14;
                    v142 = v131;
                    v143 = v133;
                    v144 = v134;
                    v145 = v80;
                    v146 = v31;
                }
                goto lab_0x80ae240;
            }
        }
        case 15: {
            // 0x80afd11
            *(char *)(yyFont + 0x1c18) = 1;
            *(int32_t *)v31 = yyFont;
            SetFontInfo(v80);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 15;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 17: {
            int32_t v229 = *(int32_t *)(v86 - 12); // 0x80afcdc
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 17;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            if (v229 < 0x1324008) {
                goto lab_0x80ae240;
            } else {
                // 0x80afcea
                *(int32_t *)(v31 + 12) = 0x1324007;
                *(int32_t *)(v31 + 8) = v229;
                *(int32_t *)(v31 + 4) = v229;
                *(int32_t *)v31 = (int32_t)"ERROR:  The file you are attempting to load is in a format\nwhich is too new for this version of pcb.  To load this file\nyou need a version of pcb which is >= %d.  If you are\nusing a version built from cvs sources, the source date\nmust be >= %d.  This copy of pcb can only read files\nup to file version %d.\n";
                Message((char *)v80);
                goto lab_0x80af56c;
            }
        }
        case 18: {
            // 0x80afcac
            *(int32_t *)(yyPCB + 144) = 0x989680;
            *(int32_t *)(yyPCB + 148) = 0x989680;
            *(int32_t *)(yyPCB + 16) = *(int32_t *)(v86 - 12);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 18;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 19: {
            // 0x80afc81
            *(int32_t *)(yyPCB + 16) = *(int32_t *)(v86 - 36);
            *(int32_t *)(yyPCB + 144) = 100 * *(int32_t *)(v86 - 24);
            *(int32_t *)(yyPCB + 148) = 100 * *(int32_t *)(v86 - 12);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 19;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 20: {
            // 0x80afc59
            *(int32_t *)(yyPCB + 16) = *(int32_t *)(v86 - 36);
            *(int32_t *)(yyPCB + 144) = *(int32_t *)(v86 - 24);
            *(int32_t *)(yyPCB + 148) = *(int32_t *)(v86 - 12);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 20;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 25: {
            int32_t v230 = *(int32_t *)(v86 - 36); // 0x80afc2a
            *(float64_t *)(yyPCB + 152) = (float64_t)(float80_t)(100 * v230);
            *(int32_t *)(yyPCB + 136) = 100 * *(int32_t *)(v86 - 24);
            *(int32_t *)(yyPCB + 140) = 100 * *(int32_t *)(v86 - 12);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 25;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 26: {
            int32_t v231 = *(int32_t *)(v86 - 48); // 0x80afbe4
            *(float64_t *)(yyPCB + 152) = (float64_t)(float80_t)(100 * v231);
            *(int32_t *)(yyPCB + 136) = 100 * *(int32_t *)(v86 - 36);
            *(int32_t *)(yyPCB + 140) = 100 * *(int32_t *)(v86 - 24);
            g171 = *(int32_t *)(v86 - 12) != 0;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 26;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 27: {
            float32_t v232 = *(float32_t *)(v86 - 48); // 0x80aee5d
            *(float64_t *)(yyPCB + 152) = 100.0 * (float64_t)v232;
            *(int32_t *)(yyPCB + 136) = 100 * *(int32_t *)(v86 - 36);
            *(int32_t *)(yyPCB + 140) = 100 * *(int32_t *)(v86 - 24);
            g171 = *(int32_t *)(v86 - 12) != 0;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 27;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 28: {
            float32_t v233 = *(float32_t *)(v86 - 48); // 0x80aee1e
            *(float64_t *)(yyPCB + 152) = (float64_t)v233;
            *(int32_t *)(yyPCB + 136) = *(int32_t *)(v86 - 36);
            *(int32_t *)(yyPCB + 140) = *(int32_t *)(v86 - 24);
            g171 = *(int32_t *)(v86 - 12) != 0;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 28;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 29: {
            // 0x80aeddd
            *(int32_t *)(yyPCB + 100) = 100 * *(int32_t *)(v86 - 36);
            *(int32_t *)(yyPCB + 104) = 100 * *(int32_t *)(v86 - 24);
            int32_t v234 = *(int32_t *)(v86 - 12); // 0x80aedf7
            *(float64_t *)(yyPCB + 160) = (float64_t)(float80_t)(2 * v234);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 29;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 30: {
            // 0x80aedb8
            *(int32_t *)(yyPCB + 100) = *(int32_t *)(v86 - 36);
            *(int32_t *)(yyPCB + 104) = *(int32_t *)(v86 - 24);
            int32_t v235 = *(int32_t *)(v86 - 12); // 0x80aedcf
            *(float64_t *)(yyPCB + 160) = (float64_t)(float80_t)v235;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 30;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 31: {
            // 0x80aed93
            *(int32_t *)(yyPCB + 100) = *(int32_t *)(v86 - 36);
            *(int32_t *)(yyPCB + 104) = *(int32_t *)(v86 - 24);
            float32_t v236 = *(float32_t *)(v86 - 12); // 0x80aedaa
            *(float64_t *)(yyPCB + 160) = (float64_t)v236;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 31;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 34: {
            float32_t v237 = *(float32_t *)(v86 - 12); // 0x80aed85
            *(float64_t *)(yyPCB + 168) = (float64_t)v237;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 34;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 36: {
            float32_t v238 = *(float32_t *)(v86 - 12); // 0x80aed6c
            *(float64_t *)(yyPCB + 176) = (float64_t)v238;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 36;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 41: {
            // 0x80aed36
            *(int32_t *)(yyPCB + 112) = *(int32_t *)(v86 - 36);
            *(int32_t *)(yyPCB + 116) = *(int32_t *)(v86 - 24);
            int32_t * v239 = (int32_t *)(v86 - 12); // 0x80aed4d
            *(int32_t *)(yyPCB + 120) = *v239;
            *(int32_t *)(yyPCB + 132) = *v239;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 41;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 42: {
            // 0x80aed05
            *(int32_t *)(yyPCB + 112) = *(int32_t *)(v86 - 48);
            *(int32_t *)(yyPCB + 116) = *(int32_t *)(v86 - 36);
            int32_t * v240 = (int32_t *)(v86 - 24); // 0x80aed1c
            *(int32_t *)(yyPCB + 120) = *v240;
            *(int32_t *)(yyPCB + 124) = *(int32_t *)(v86 - 12);
            *(int32_t *)(yyPCB + 132) = *v240;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 42;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 43: {
            // 0x80aee8a
            *(int32_t *)(yyPCB + 112) = *(int32_t *)(v86 - 72);
            *(int32_t *)(yyPCB + 116) = *(int32_t *)(v86 - 60);
            *(int32_t *)(yyPCB + 120) = *(int32_t *)(v86 - 48);
            *(int32_t *)(yyPCB + 124) = *(int32_t *)(v86 - 36);
            *(int32_t *)(yyPCB + 128) = *(int32_t *)(v86 - 24);
            *(int32_t *)(yyPCB + 132) = *(int32_t *)(v86 - 12);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 43;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 44: {
            // 0x80af601
            *(int32_t *)v31 = v13;
            *(int32_t *)(v31 + 4) = *(int32_t *)(v86 - 12) % 0x100000;
            MakeFlags(v80);
            v169 = yyPCB;
            goto lab_0x80af5e9;
        }
        case 45: {
            // 0x80af5ba
            *(int32_t *)(v31 + 8) = 0x80adf00;
            *(int32_t *)v31 = v13;
            *(int32_t *)(v31 + 4) = *(int32_t *)(v86 - 12);
            string_to_pcbflags((char *)v80, (int32_t (*)(char *))&g231);
            v169 = yyPCB;
            goto lab_0x80af5e9;
        }
        case 47: {
            // 0x80af5a7
            layer_group_string = *(int32_t *)(v86 - 12);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 47;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 49: {
            // 0x80af586
            *(int32_t *)(v31 + 8) = 100;
            *(int32_t *)(v31 + 4) = yyPCB + 0x2194;
            goto lab_0x80af544;
        }
        case 50: {
            // 0x80af525
            *(int32_t *)(v31 + 8) = 1;
            *(int32_t *)(v31 + 4) = yyPCB + 0x2194;
            goto lab_0x80af544;
        }
        case 57: {
            // 0x80af511
            attr_list = yyPCB + 0x2200;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 57;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 61: {
            // 0x80b06c3
            yyElement = 0;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 61;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 63: {
            goto lab_0x80aecd2;
        }
        case 69: {
            // 0x80b0643
            __asm_rep_movsd_memcpy((char *)(v31 + 32), (char *)(v86 - 12), 3);
            int32_t * v241 = (int32_t *)(v86 - 24); // 0x80b065d
            *(int32_t *)(v31 + 28) = *v241;
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 84);
            *(int32_t *)(v31 + 4) = *(int32_t *)(v86 - 96);
            int32_t * v242 = (int32_t *)v31; // 0x80b0699
            *v242 = yyData;
            CreateNewVia(v80, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char *)&g231, (int32_t)&g231);
            *v242 = *v241;
            SaveFree((char *)&g231);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 69;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 70: {
            // 0x80b05db
            int32_t v243; // bp-64, 0x80adf30
            *(int32_t *)v31 = (int32_t)&v243;
            int32_t * v244 = (int32_t *)(v31 + 4); // 0x80b05f0
            *v244 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v245 = v31 - 4; // 0x80b05fe
            int32_t * v246 = (int32_t *)v245;
            *v246 = v86;
            __asm_rep_movsd_memcpy((char *)(v31 + 28), (char *)&v243, 3);
            int32_t * v247 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 24) = *v247;
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 16) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 72);
            *v244 = 100 * *(int32_t *)(v86 - 84);
            v147 = v247;
            v150 = v246;
            v168 = v86 - 96;
            v171 = v245;
            goto lab_0x80b0547;
        }
        case 71: {
            // 0x80b055d
            int32_t v248; // bp-76, 0x80adf30
            *(int32_t *)v31 = (int32_t)&v248;
            int32_t * v249 = (int32_t *)(v31 + 4); // 0x80b0572
            *v249 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v250 = v31 - 4; // 0x80b057b
            int32_t * v251 = (int32_t *)v250;
            *v251 = v133;
            int32_t v252 = *(int32_t *)(v86 - 60); // 0x80b057c
            int32_t v253 = *(int32_t *)(v86 - 48); // 0x80b058a
            __asm_rep_movsd_memcpy((char *)(v31 + 28), (char *)&v248, 3);
            int32_t * v254 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 24) = *v254;
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 16) = 100 * (v253 + v252);
            *(int32_t *)(v31 + 12) = 100 * v253;
            *(int32_t *)(v31 + 8) = 100 * v252;
            *v249 = 100 * *(int32_t *)(v86 - 72);
            v147 = v254;
            v150 = v251;
            v168 = v86 - 84;
            v171 = v250;
            goto lab_0x80b0547;
        }
        case 72: {
            // 0x80b04e2
            int32_t v255; // bp-88, 0x80adf30
            *(int32_t *)v31 = (int32_t)&v255;
            int32_t * v256 = (int32_t *)(v31 + 4); // 0x80b04f7
            *v256 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v257 = v31 - 4; // 0x80b0505
            int32_t * v258 = (int32_t *)v257;
            *v258 = v80;
            int32_t v259 = 100 * *(int32_t *)(v86 - 48); // 0x80b0506
            __asm_rep_movsd_memcpy((char *)(v31 + 28), (char *)&v255, 3);
            int32_t * v260 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 24) = *v260;
            *(int32_t *)(v31 + 12) = 3000;
            *(int32_t *)(v31 + 8) = v259;
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 16) = v259 + 600;
            *v256 = 100 * *(int32_t *)(v86 - 60);
            v147 = v260;
            v150 = v258;
            v168 = v86 - 72;
            v171 = v257;
            goto lab_0x80b0547;
        }
        case 73: {
            int32_t * v261 = (int32_t *)(v86 - 36); // 0x80b0438
            int32_t v262 = *v261; // 0x80b0438
            int32_t v263 = 40 * v262; // 0x80b043e
            int32_t v264 = v263; // 0x80b044b
            if (-39 * v262 <= 399) {
                // 0x80b044d
                v264 = v262 < 401 == (400 - v262 & v262) < 0 ? v262 - 400 : v263;
            }
            int32_t * v265 = (int32_t *)v31; // 0x80b046d
            int32_t v266; // bp-100, 0x80adf30
            *v265 = (int32_t)&v266;
            int32_t * v267 = (int32_t *)(v31 + 4); // 0x80b0470
            *v267 = *(int32_t *)(v86 - 12);
            int32_t v268 = OldFlags(v80); // 0x80b0474
            int32_t v269 = v31 - 4; // 0x80b047e
            int32_t * v270 = (int32_t *)v269; // 0x80b047e
            *v270 = v268;
            int32_t v271 = 100 * *v261; // 0x80b047f
            __asm_rep_movsd_memcpy((char *)(v31 + 28), (char *)&v266, 3);
            int32_t * v272 = (int32_t *)(v86 - 24); // 0x80b048e
            *(int32_t *)(v31 + 20) = v264;
            *(int32_t *)(v31 + 12) = 3000;
            *(int32_t *)(v31 + 8) = v271;
            *(int32_t *)(v31 + 24) = *v272;
            *(int32_t *)(v31 + 16) = v271 + 600;
            *v267 = 100 * *(int32_t *)(v86 - 48);
            *v265 = 100 * *(int32_t *)(v86 - 60);
            *v270 = yyData;
            CreateNewVia((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char *)&g231, (int32_t)&g231);
            *v270 = *v272;
            SaveFree((char *)&g231);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 73;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v269;
            goto lab_0x80ae240;
        }
        case 74: {
            // 0x80b03c1
            __asm_rep_movsd_memcpy((char *)(v31 + 32), (char *)(v86 - 12), 3);
            *(int32_t *)(v31 + 28) = g130;
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 4) = *(int32_t *)(v86 - 84);
            *(int32_t *)v31 = yyData;
            CreateNewRat(v80, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 74;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 75: {
            int32_t * v273 = (int32_t *)v31; // 0x80b0354
            int32_t v274; // bp-112, 0x80adf30
            *v273 = (int32_t)&v274;
            int32_t * v275 = (int32_t *)(v31 + 4); // 0x80b0357
            *v275 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v276 = v31 - 4; // 0x80b0360
            int32_t * v277 = (int32_t *)v276; // 0x80b0360
            *v277 = v86;
            __asm_rep_movsd_memcpy((char *)(v31 + 28), (char *)&v274, 3);
            *(int32_t *)(v31 + 24) = g130;
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 48);
            *v275 = 100 * *(int32_t *)(v86 - 72);
            *v273 = 100 * *(int32_t *)(v86 - 84);
            *v277 = yyData;
            CreateNewRat((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 75;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v276;
            goto lab_0x80ae240;
        }
        case 76: {
            int32_t * v278 = (int32_t *)(v86 - 48); // 0x80ae1e5
            int32_t v279 = *v278; // 0x80ae1e5
            uint32_t v280 = v279 - 1; // 0x80ae1eb
            if (v280 < 18) {
                // 0x80ae1f7
                if (*(char *)(v279 + (int32_t)&g91) != 0) {
                    // 0x80b08f0
                    *(int32_t *)(v31 + 12) = (int32_t)"Layernumber used twice";
                    goto lab_0x80b08bd;
                } else {
                    int32_t v281 = 92 * v280 + 76 + yyData; // 0x80ae213
                    Layer = v281;
                    *(int32_t *)v281 = *(int32_t *)(v86 - 36);
                    *(char *)(*v278 + (int32_t)&g91) = 1;
                    v135 = v86;
                    v136 = v85;
                    v137 = v84;
                    v138 = v83;
                    v139 = v82;
                    v140 = v129;
                    v141 = 76;
                    v142 = v131;
                    v143 = v133;
                    v144 = v134;
                    v145 = v80;
                    v146 = v31;
                    if (*(int32_t *)(yyData + 24) + 2 < *v278) {
                        // 0x80ae238
                        int32_t v282; // 0x80ae22c
                        int32_t * v283; // 0x80ae22e
                        *v283 = v282 - 2;
                        v135 = v86;
                        v136 = v85;
                        v137 = v84;
                        v138 = v83;
                        v139 = v82;
                        v140 = v129;
                        v141 = 76;
                        v142 = v131;
                        v143 = v133;
                        v144 = v134;
                        v145 = v80;
                        v146 = v31;
                    }
                    goto lab_0x80ae240;
                }
            } else {
                // 0x80b08fa
                *(int32_t *)(v31 + 12) = (int32_t)"Layernumber out of range";
                goto lab_0x80b08bd;
            }
        }
        case 88: {
            int32_t * v284 = (int32_t *)v31; // 0x80b02cc
            int32_t v285; // bp-124, 0x80adf30
            *v284 = (int32_t)&v285;
            int32_t * v286 = (int32_t *)(v31 + 4); // 0x80b02cf
            *v286 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v287 = v31 - 4; // 0x80b02e3
            int32_t * v288 = (int32_t *)v287; // 0x80b02e3
            *v288 = v80;
            int32_t v289 = *(int32_t *)(v86 - 60); // 0x80b02e4
            int32_t v290 = *(int32_t *)(v86 - 48); // 0x80b02e7
            __asm_rep_movsd_memcpy((char *)(v31 + 16), (char *)&v285, 3);
            int32_t v291 = *(int32_t *)(v86 - 24); // 0x80b02fe
            *(int32_t *)(v31 + 12) = 100 * (v291 + v290);
            int32_t v292 = *(int32_t *)(v86 - 36); // 0x80b030e
            *(int32_t *)(v31 + 8) = 100 * (v292 + v289);
            *v286 = 100 * v290;
            *v284 = 100 * v289;
            *v288 = Layer;
            CreateNewPolygonFromRectangle((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 88;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v287;
            goto lab_0x80ae240;
        }
        case 92: {
            // 0x80b02a8
            attr_list = Layer + 80;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 92;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 94: {
            // 0x80b0271
            __asm_rep_movsd_memcpy((char *)(v31 + 4), (char *)(v86 - 24), 3);
            *(int32_t *)v31 = Layer;
            Polygon = CreateNewPolygon(v80, (int32_t)&g231);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 94;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 95: {
            int32_t v293 = Polygon; // 0x80b0212
            if (*(int32_t *)(v293 + 36) < 3) {
                int32_t * v294 = (int32_t *)v31; // 0x80b072d
                *v294 = (int32_t)"WARNING parsing file '%s'\n    line:        %i\n    description: 'ignored polygon (< 3 points)'\n";
                int32_t * v295 = (int32_t *)(v31 + 8); // 0x80b0734
                *v295 = yylineno;
                int32_t * v296 = (int32_t *)(v31 + 4); // 0x80b073d
                *v296 = yyfilename;
                Message((char *)v80);
                *v296 = 8;
                *(int32_t *)(v31 + 16) = Polygon;
                *(int32_t *)(v31 + 12) = Polygon;
                *v295 = Layer;
                *v294 = yyData;
                DestroyObject((int32_t)&g231, (int32_t)&g231, (char *)&g231, (char *)&g231, (char *)&g231);
                v135 = v86;
                v136 = v85;
                v137 = v84;
                v138 = v83;
                v139 = v82;
                v140 = v80;
                v141 = 95;
                v142 = v131;
                v143 = v133;
                v144 = v134;
                v145 = v80;
                v146 = v31;
                goto lab_0x80ae240;
            } else {
                int32_t * v297 = (int32_t *)v31;
                *v297 = v293;
                SetPolygonBoundingBox(v80);
                int32_t * v298 = (int32_t *)(Layer + 60);
                int32_t v299 = *v298; // 0x80b023b
                v148 = v298;
                v166 = v297;
                v179 = v86;
                v181 = v85;
                v185 = v84;
                v203 = v83;
                v187 = v82;
                v188 = v80;
                v182 = 95;
                v205 = v131;
                v192 = v133;
                v190 = v134;
                if (v299 == 0) {
                    goto lab_0x80b0909;
                } else {
                    // 0x80b0221
                    v165 = (int32_t *)(v31 + 4);
                    v164 = (int32_t *)(v31 + 8);
                    v149 = v297;
                    v178 = v86;
                    v180 = v85;
                    v184 = v84;
                    v202 = v83;
                    v186 = v82;
                    v183 = 95;
                    v204 = v131;
                    v191 = v133;
                    v189 = v134;
                    v167 = v299;
                    v170 = v80;
                    goto lab_0x80b0246;
                }
            }
        }
        case 96: {
            // 0x80b01b0
            __asm_rep_movsd_memcpy((char *)(v31 + 28), (char *)(v86 - 12), 3);
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 4) = *(int32_t *)(v86 - 84);
            *(int32_t *)v31 = Layer;
            CreateNewLineOnLayer(v80, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 96;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 97: {
            // 0x80b014f
            int32_t v300; // bp-136, 0x80adf30
            *(int32_t *)v31 = (int32_t)&v300;
            int32_t * v301 = (int32_t *)(v31 + 4); // 0x80b0167
            *v301 = *(int32_t *)(v86 - 12);
            int32_t v302 = OldFlags(v80); // 0x80b016b
            int32_t v303 = v31 - 4; // 0x80b0175
            int32_t * v304 = (int32_t *)v303;
            *v304 = v302;
            __asm_rep_movsd_memcpy((char *)(v31 + 24), (char *)&v300, 3);
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 16) = 100 * *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 60);
            *v301 = 100 * *(int32_t *)(v86 - 72);
            v201 = v304;
            v200 = v303;
            v194 = v86 - 84;
            goto lab_0x80b0133;
        }
        case 98: {
            int32_t v305 = *(int32_t *)(v86 - 12); // 0x80b00d8
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 98;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            if ((v305 & 16) != 0) {
                goto lab_0x80ae240;
            } else {
                int32_t * v306 = (int32_t *)(v31 + 4); // 0x80b00e9
                *v306 = v305;
                int32_t v307; // bp-148, 0x80adf30
                *(int32_t *)v31 = (int32_t)&v307;
                OldFlags(v80);
                v200 = v31 - 4;
                v201 = (int32_t *)v200;
                *v201 = v131;
                __asm_rep_movsd_memcpy((char *)(v31 + 24), (char *)&v307, 3);
                *(int32_t *)(v31 + 20) = 3000;
                *(int32_t *)(v31 + 16) = 100 * *(int32_t *)(v86 - 24);
                *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 36);
                *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 48);
                *v306 = 100 * *(int32_t *)(v86 - 60);
                v194 = v86 - 72;
                goto lab_0x80b0133;
            }
        }
        case 99: {
            // 0x80b0062
            __asm_rep_movsd_memcpy((char *)(v31 + 36), (char *)(v86 - 12), 3);
            *(int32_t *)(v31 + 32) = *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 28) = *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 84);
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 96);
            *(int32_t *)(v31 + 4) = *(int32_t *)(v86 - 108);
            *(int32_t *)v31 = Layer;
            CreateNewArcOnLayer(v80, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 99;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 100: {
            // 0x80afff0
            int32_t v308; // bp-160, 0x80adf30
            *(int32_t *)v31 = (int32_t)&v308;
            int32_t * v309 = (int32_t *)(v31 + 4); // 0x80b0008
            *v309 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v310 = v31 - 4; // 0x80b0011
            int32_t * v311 = (int32_t *)v310;
            *v311 = v133;
            __asm_rep_movsd_memcpy((char *)(v31 + 32), (char *)&v308, 3);
            *(int32_t *)(v31 + 28) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 24) = 100 * *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 84);
            *v309 = 100 * *(int32_t *)(v86 - 96);
            v153 = v311;
            v177 = v310;
            v193 = v86 - 108;
            goto lab_0x80affd4;
        }
        case 101: {
            // 0x80aff65
            int32_t v312; // bp-172, 0x80adf30
            *(int32_t *)v31 = (int32_t)&v312;
            int32_t * v313 = (int32_t *)(v31 + 4); // 0x80aff7d
            *v313 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v314 = v31 - 4; // 0x80aff91
            int32_t * v315 = (int32_t *)v314;
            *v315 = v80;
            int32_t v316 = 100 * *(int32_t *)(v86 - 72); // 0x80aff92
            __asm_rep_movsd_memcpy((char *)(v31 + 32), (char *)&v312, 3);
            *(int32_t *)(v31 + 28) = 3000;
            *(int32_t *)(v31 + 24) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 12) = v316;
            *(int32_t *)(v31 + 8) = v316;
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 36);
            *v313 = 100 * *(int32_t *)(v86 - 84);
            v153 = v315;
            v177 = v314;
            v193 = v86 - 96;
            goto lab_0x80affd4;
        }
        case 102: {
            int32_t * v317 = (int32_t *)v31; // 0x80afefa
            int32_t v318; // bp-184, 0x80adf30
            *v317 = (int32_t)&v318;
            int32_t * v319 = (int32_t *)(v31 + 4); // 0x80afefd
            *v319 = *(int32_t *)(v86 - 12);
            int32_t v320 = OldFlags(v80); // 0x80aff01
            int32_t v321 = v31 - 4; // 0x80aff0b
            int32_t * v322 = (int32_t *)v321; // 0x80aff0b
            *v322 = v320;
            __asm_rep_movsd_memcpy((char *)(v31 + 24), (char *)&v318, 3);
            int32_t * v323 = (int32_t *)(v86 - 24); // 0x80aff12
            *(int32_t *)(v31 + 16) = 100;
            *(int32_t *)(v31 + 20) = *v323;
            unsigned char v324 = *(char *)(v86 - 36); // 0x80aff21
            *(int32_t *)(v31 + 12) = (int32_t)v324;
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 48);
            *v319 = 100 * *(int32_t *)(v86 - 60);
            *v317 = yyFont;
            *v322 = Layer;
            CreateNewText((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char)&g231, (int32_t)&g231, (char *)&g231, (int32_t)&g231);
            *v322 = *v323;
            SaveFree((char *)&g231);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 102;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v321;
            goto lab_0x80ae240;
        }
        case 103: {
            uint32_t v325 = *(int32_t *)(v86 - 12); // 0x80afe3d
            if ((v325 & 1024) == 0) {
                int32_t * v326 = (int32_t *)(v31 + 4); // 0x80b07ed
                *v326 = v325;
                int32_t * v327 = (int32_t *)v31; // 0x80b07f1
                int32_t v328; // bp-208, 0x80adf30
                *v327 = (int32_t)&v328;
                OldFlags(v80);
                int32_t v329 = v31 - 4; // 0x80b07fe
                int32_t * v330 = (int32_t *)v329;
                *v330 = v86;
                __asm_rep_movsd_memcpy((char *)(v31 + 24), (char *)&v328, 3);
                int32_t * v331 = (int32_t *)(v86 - 24);
                *(int32_t *)(v31 + 20) = *v331;
                *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 36);
                unsigned char v332 = *(char *)(v86 - 48); // 0x80b0822
                *(int32_t *)(v31 + 12) = (int32_t)v332;
                *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 60);
                *v326 = 100 * *(int32_t *)(v86 - 72);
                *v327 = yyFont;
                *v330 = Layer;
                CreateNewText((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char)&g231, (int32_t)&g231, (char *)&g231, (int32_t)&g231);
                v155 = v330;
                v154 = v331;
                v176 = v329;
            } else {
                int32_t v333 = yyData; // 0x80afe49
                int32_t * v334 = (int32_t *)(v31 + 4); // 0x80afe6c
                *v334 = v325;
                int32_t * v335 = (int32_t *)v31; // 0x80afe70
                int32_t v336; // bp-196, 0x80adf30
                *v335 = (int32_t)&v336;
                OldFlags(v80);
                int32_t v337 = v31 - 4; // 0x80afe90
                int32_t * v338 = (int32_t *)v337;
                *v338 = v131;
                __asm_rep_movsd_memcpy((char *)(v31 + 24), (char *)&v336, 3);
                int32_t * v339 = (int32_t *)(v86 - 24);
                *(int32_t *)(v31 + 20) = *v339;
                *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 36);
                unsigned char v340 = *(char *)(v86 - 48); // 0x80afeab
                *(int32_t *)(v31 + 12) = (int32_t)v340;
                *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 60);
                *v334 = 100 * *(int32_t *)(v86 - 72);
                *v335 = yyFont;
                *v338 = v333 + 76 + 92 * (*(int32_t *)(v333 + 24) + (v325 / 128 % 2 ^ 1));
                CreateNewText((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char)&g231, (int32_t)&g231, (char *)&g231, (int32_t)&g231);
                v155 = v338;
                v154 = v339;
                v176 = v337;
            }
            goto lab_0x80afe1c;
        }
        case 104: {
            int32_t v341 = v86 - 12; // 0x80afd8d
            uint32_t v342 = *(int32_t *)v341; // 0x80afd8d
            __asm_rep_movsd_memcpy((char *)(v31 + 28), (char *)v341, 3);
            int32_t v343 = v86 - 24;
            if ((v342 & 1024) == 0) {
                int32_t * v344 = (int32_t *)v343;
                *(int32_t *)(v31 + 24) = *v344;
                *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 36);
                unsigned char v345 = *(char *)(v86 - 48); // 0x80b07a4
                *(int32_t *)(v31 + 16) = (int32_t)v345;
                *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 60);
                *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 72);
                *(int32_t *)(v31 + 4) = yyFont;
                int32_t * v346 = (int32_t *)v31;
                *v346 = Layer;
                CreateNewText(v80, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char)&g231, (int32_t)&g231, (char *)&g231, (int32_t)&g231);
                v155 = v346;
                v154 = v344;
                v176 = v31;
            } else {
                int32_t v347 = yyData; // 0x80afdbc
                int32_t * v348 = (int32_t *)v343;
                *(int32_t *)(v31 + 24) = *v348;
                *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 36);
                unsigned char v349 = *(char *)(v86 - 48); // 0x80afdd0
                *(int32_t *)(v31 + 16) = (int32_t)v349;
                *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 60);
                *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 72);
                *(int32_t *)(v31 + 4) = yyFont;
                int32_t * v350 = (int32_t *)v31;
                *v350 = v347 + 76 + 92 * (*(int32_t *)(v347 + 24) + (v342 / 128 % 2 ^ 1));
                CreateNewText(v80, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char)&g231, (int32_t)&g231, (char *)&g231, (int32_t)&g231);
                v155 = v350;
                v154 = v348;
                v176 = v31;
            }
            goto lab_0x80afe1c;
        }
        case 107: {
            // 0x80afd6d
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 12);
            v198 = 100 * *(int32_t *)(v86 - 24);
            goto lab_0x80afd4b;
        }
        case 108: {
            // 0x80afd3b
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 12);
            v198 = *(int32_t *)(v86 - 24);
            goto lab_0x80afd4b;
        }
        case 115: {
            int32_t * v351 = (int32_t *)v31; // 0x80ae882
            int32_t v352; // bp-220, 0x80adf30
            *v351 = (int32_t)&v352;
            int32_t v353 = v31 + 4; // 0x80ae885
            *(int32_t *)v353 = 0;
            MakeFlags(v80);
            int32_t * v354 = (int32_t *)(v31 - 4); // 0x80ae898
            *v354 = v133;
            int32_t v355 = (int32_t)*(char *)(v86 - 24); // 0x80ae899
            int32_t * v356 = (int32_t *)(v86 - 60); // 0x80ae8b7
            int32_t * v357 = (int32_t *)(v86 - 72); // 0x80ae8c6
            int32_t v358; // bp-232, 0x80adf30
            *v354 = (int32_t)&v358;
            *v351 = 0;
            MakeFlags(v355);
            int32_t v359 = v31 - 8; // 0x80ae8ea
            int32_t * v360 = (int32_t *)v359; // 0x80ae8ea
            *v360 = v80;
            *(int32_t *)(v31 + 56) = 0;
            __asm_rep_movsd_memcpy((char *)(v31 + 44), (char *)&v352, 3);
            *(int32_t *)(v31 + 40) = 100;
            *(int32_t *)(v31 + 24) = 0;
            *(int32_t *)(v31 + 36) = v355;
            *(int32_t *)(v31 + 32) = 100 * *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 28) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 16) = *v357;
            *(int32_t *)(v31 + 20) = *v356;
            __asm_rep_movsd_memcpy((char *)v353, (char *)&v358, 3);
            *v351 = yyFont;
            *v354 = yyElement;
            *v360 = yyData;
            int32_t v361 = CreateNewElement((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char *)&g231, (char *)&g231, (char *)&g231, (int32_t)&g231, (int32_t)&g231, (char)&g231, (int32_t)&g231, (int32_t)&g231, (char)&g231); // 0x80ae962
            yyElement = v361;
            *v360 = *v357;
            SaveFree((char *)&g231);
            *v360 = *v356;
            SaveFree((char *)&g231);
            pin_num = 1;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 115;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v359;
            goto lab_0x80ae240;
        }
        case 116: {
            goto lab_0x80ae4fb;
        }
        case 117: {
            int32_t * v362 = (int32_t *)v31; // 0x80ae754
            int32_t v363; // bp-244, 0x80adf30
            *v362 = (int32_t)&v363;
            int32_t v364 = v31 + 4; // 0x80ae757
            *(int32_t *)v364 = *(int32_t *)(v86 - 24);
            int32_t v365 = OldFlags(v80); // 0x80ae75b
            int32_t * v366 = (int32_t *)(v31 - 4); // 0x80ae760
            *v366 = v365;
            unsigned char v367 = *(char *)(v86 - 48); // 0x80ae761
            int32_t v368 = *(int32_t *)(v86 - 36); // 0x80ae765
            int32_t * v369 = (int32_t *)(v86 - 84);
            int32_t * v370 = (int32_t *)(v86 - 96); // 0x80ae79d
            int32_t v371; // bp-256, 0x80adf30
            *v366 = (int32_t)&v371;
            *v362 = *(int32_t *)(v86 - 108);
            OldFlags(v368);
            int32_t v372 = v31 - 8; // 0x80ae7c6
            int32_t * v373 = (int32_t *)v372;
            *v373 = v86;
            *(int32_t *)(v31 + 56) = 0;
            __asm_rep_movsd_memcpy((char *)(v31 + 44), (char *)&v363, 3);
            *(int32_t *)(v31 + 24) = 0;
            *(int32_t *)(v31 + 40) = v368;
            *(int32_t *)(v31 + 32) = 100 * *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 28) = 100 * *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 20) = *v369;
            *(int32_t *)(v31 + 36) = (int32_t)v367;
            *(int32_t *)(v31 + 16) = *v370;
            __asm_rep_movsd_memcpy((char *)v364, (char *)&v371, 3);
            *v362 = yyFont;
            *v366 = yyElement;
            *v373 = yyData;
            int32_t v374 = CreateNewElement((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char *)&g231, (char *)&g231, (char *)&g231, (int32_t)&g231, (int32_t)&g231, (char)&g231, (int32_t)&g231, (int32_t)&g231, (char)&g231); // 0x80ae840
            yyElement = v374;
            *v373 = *v370;
            SaveFree((char *)&g231);
            v157 = v373;
            v156 = v369;
            v172 = v372;
            goto lab_0x80ae6d7;
        }
        case 118: {
            goto lab_0x80ae4fb;
        }
        case 119: {
            int32_t * v375 = (int32_t *)v31; // 0x80ae5b4
            int32_t v376; // bp-268, 0x80adf30
            *v375 = (int32_t)&v376;
            int32_t v377 = v31 + 4; // 0x80ae5b7
            *(int32_t *)v377 = *(int32_t *)(v86 - 24);
            OldFlags(v80);
            int32_t * v378 = (int32_t *)(v31 - 4); // 0x80ae5c0
            *v378 = v86;
            unsigned char v379 = *(char *)(v86 - 48); // 0x80ae5c1
            int32_t v380 = *(int32_t *)(v86 - 36); // 0x80ae5c5
            int32_t * v381 = (int32_t *)(v86 - 84);
            int32_t * v382 = (int32_t *)(v86 - 96); // 0x80ae5fd
            int32_t * v383 = (int32_t *)(v86 - 108); // 0x80ae606
            int32_t v384 = *(int32_t *)(v86 - 120); // 0x80ae61b
            int32_t v385; // bp-280, 0x80adf30
            *v378 = (int32_t)&v385;
            *v375 = v384;
            OldFlags(v380);
            int32_t v386 = v31 - 8; // 0x80ae630
            int32_t * v387 = (int32_t *)v386;
            *v387 = v384;
            *(int32_t *)(v31 + 56) = 0;
            __asm_rep_movsd_memcpy((char *)(v31 + 44), (char *)&v376, 3);
            *(int32_t *)(v31 + 40) = v380;
            *(int32_t *)(v31 + 32) = 100 * *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 28) = 100 * *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 24) = *v381;
            *(int32_t *)(v31 + 36) = (int32_t)v379;
            *(int32_t *)(v31 + 16) = *v383;
            *(int32_t *)(v31 + 20) = *v382;
            __asm_rep_movsd_memcpy((char *)v377, (char *)&v385, 3);
            *v375 = yyFont;
            *v378 = yyElement;
            *v387 = yyData;
            int32_t v388 = CreateNewElement((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char *)&g231, (char *)&g231, (char *)&g231, (int32_t)&g231, (int32_t)&g231, (char)&g231, (int32_t)&g231, (int32_t)&g231, (char)&g231); // 0x80ae6b1
            yyElement = v388;
            *v387 = *v383;
            SaveFree((char *)&g231);
            *v387 = *v382;
            SaveFree((char *)&g231);
            v157 = v387;
            v156 = v381;
            v172 = v386;
            goto lab_0x80ae6d7;
        }
        case 120: {
            goto lab_0x80ae4fb;
        }
        case 121: {
            int32_t * v389 = (int32_t *)v31; // 0x80af28b
            int32_t v390; // bp-292, 0x80adf30
            *v389 = (int32_t)&v390;
            int32_t v391 = v31 + 4; // 0x80af28e
            *(int32_t *)v391 = *(int32_t *)(v86 - 24);
            OldFlags(v80);
            int32_t * v392 = (int32_t *)(v31 - 4); // 0x80af297
            *v392 = v80;
            unsigned char v393 = *(char *)(v86 - 48); // 0x80af2a1
            int32_t v394 = *(int32_t *)(v86 - 60); // 0x80af2ab
            int32_t * v395 = (int32_t *)(v86 - 84); // 0x80af2ae
            int32_t * v396 = (int32_t *)(v86 - 108); // 0x80af2c0
            int32_t * v397 = (int32_t *)(v86 - 96); // 0x80af2c6
            int32_t * v398 = (int32_t *)(v86 - 120); // 0x80af2cf
            int32_t v399 = 100 * (*v397 + *(int32_t *)(v86 - 72)); // 0x80af2d8
            int32_t * v400 = (int32_t *)(v86 - 132); // 0x80af2e7
            int32_t v401; // bp-304, 0x80adf30
            *v392 = (int32_t)&v401;
            *v389 = *(int32_t *)(v86 - 144);
            int32_t v402 = OldFlags(v399); // 0x80af306
            int32_t v403 = v31 - 8; // 0x80af310
            int32_t * v404 = (int32_t *)v403; // 0x80af310
            *v404 = v402;
            *(int32_t *)(v31 + 56) = 0;
            __asm_rep_movsd_memcpy((char *)(v31 + 44), (char *)&v390, 3);
            *(int32_t *)(v31 + 40) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 36) = (int32_t)v393;
            *(int32_t *)(v31 + 28) = v399;
            *(int32_t *)(v31 + 32) = 100 * (*v395 + v394);
            *(int32_t *)(v31 + 20) = *v398;
            *(int32_t *)(v31 + 16) = *v400;
            *(int32_t *)(v31 + 24) = *v396;
            __asm_rep_movsd_memcpy((char *)v391, (char *)&v401, 3);
            *v389 = yyFont;
            *v392 = yyElement;
            *v404 = yyData;
            int32_t v405 = CreateNewElement((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char *)&g231, (char *)&g231, (char *)&g231, (int32_t)&g231, (int32_t)&g231, (char)&g231, (int32_t)&g231, (int32_t)&g231, (char)&g231); // 0x80af38c
            yyElement = v405;
            *(int32_t *)(v405 + 216) = 100 * *v397;
            *(int32_t *)(v405 + 220) = 100 * *v395;
            *v404 = *v400;
            SaveFree((char *)&g231);
            *v404 = *v398;
            SaveFree((char *)&g231);
            *v404 = *v396;
            SaveFree((char *)&g231);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 121;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v403;
            goto lab_0x80ae240;
        }
        case 122: {
            goto lab_0x80ae4fb;
        }
        case 123: {
            // 0x80af3e1
            *(int32_t *)(v31 + 64) = 0;
            __asm_rep_movsd_memcpy((char *)(v31 + 52), (char *)(v86 - 24), 3);
            *(int32_t *)(v31 + 48) = *(int32_t *)(v86 - 36);
            unsigned char v406 = *(char *)(v86 - 48); // 0x80af416
            *(int32_t *)(v31 + 44) = (int32_t)v406;
            int32_t * v407 = (int32_t *)(v86 - 84); // 0x80af421
            int32_t v408 = *v407; // 0x80af421
            *(int32_t *)(v31 + 40) = v408 + *(int32_t *)(v86 - 60);
            int32_t * v409 = (int32_t *)(v86 - 96); // 0x80af42b
            int32_t v410 = *v409; // 0x80af42b
            *(int32_t *)(v31 + 36) = v410 + *(int32_t *)(v86 - 72);
            int32_t * v411 = (int32_t *)(v86 - 108); // 0x80af432
            *(int32_t *)(v31 + 32) = *v411;
            int32_t * v412 = (int32_t *)(v86 - 120); // 0x80af439
            *(int32_t *)(v31 + 28) = *v412;
            int32_t * v413 = (int32_t *)(v86 - 132); // 0x80af440
            *(int32_t *)(v31 + 24) = *v413;
            __asm_rep_movsd_memcpy((char *)(v31 + 12), (char *)(v86 - 144), 3);
            *(int32_t *)(v31 + 8) = yyFont;
            *(int32_t *)(v31 + 4) = yyElement;
            int32_t * v414 = (int32_t *)v31; // 0x80af46e
            *v414 = yyData;
            int32_t v415 = CreateNewElement(v80, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char *)&g231, (char *)&g231, (char *)&g231, (int32_t)&g231, (int32_t)&g231, (char)&g231, (int32_t)&g231, (int32_t)&g231, (char)&g231); // 0x80af471
            yyElement = v415;
            *(int32_t *)(v415 + 216) = *v409;
            *(int32_t *)(v415 + 220) = *v407;
            *v414 = *v413;
            SaveFree((char *)&g231);
            *v414 = *v412;
            SaveFree((char *)&g231);
            *v414 = *v411;
            SaveFree((char *)&g231);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 123;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 124: {
            goto lab_0x80ae4fb;
        }
        case 132: {
            // 0x80afbb1
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 12);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 48);
            v197 = *(int32_t *)(v86 - 60);
            goto lab_0x80afb8f;
        }
        case 133: {
            // 0x80afb65
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 12);
            *(int32_t *)(v31 + 16) = 100 * *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 48);
            v197 = 100 * *(int32_t *)(v86 - 60);
            goto lab_0x80afb8f;
        }
        case 134: {
            // 0x80af1e9
            *(int32_t *)(v31 + 28) = *(int32_t *)(v86 - 12);
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 72);
            v196 = *(int32_t *)(v86 - 84);
            goto lab_0x80af1c7;
        }
        case 135: {
            // 0x80af18f
            *(int32_t *)(v31 + 28) = 100 * *(int32_t *)(v86 - 12);
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 16) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 72);
            v196 = 100 * *(int32_t *)(v86 - 84);
            goto lab_0x80af1c7;
        }
        case 136: {
            // 0x80af16d
            *(int32_t *)(yyElement + 216) = *(int32_t *)(v86 - 24);
            *(int32_t *)(yyElement + 220) = *(int32_t *)(v86 - 12);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 136;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 137: {
            // 0x80af148
            *(int32_t *)(yyElement + 216) = 100 * *(int32_t *)(v86 - 24);
            *(int32_t *)(yyElement + 220) = 100 * *(int32_t *)(v86 - 12);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 137;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 138: {
            goto lab_0x80ae555;
        }
        case 146: {
            int32_t v416 = *(int32_t *)(yyElement + 220); // 0x80aeed3
            int32_t v417 = *(int32_t *)(yyElement + 216); // 0x80aeed9
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 12);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 24) + v416;
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 36) + v417;
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 48) + v416;
            *(int32_t *)v31 = yyElement;
            *(int32_t *)(v31 + 4) = *(int32_t *)(v86 - 60) + v417;
            CreateNewLineInElement(v80, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 146;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 147: {
            int32_t v418 = *(int32_t *)(yyElement + 220); // 0x80af0f7
            int32_t v419 = *(int32_t *)(yyElement + 216); // 0x80af0fd
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 12);
            int32_t v420 = *(int32_t *)(v86 - 24); // 0x80af107
            *(int32_t *)(v31 + 16) = 100 * v420 + v418;
            int32_t v421 = *(int32_t *)(v86 - 36); // 0x80af111
            *(int32_t *)(v31 + 12) = 100 * v421 + v419;
            int32_t v422 = *(int32_t *)(v86 - 48); // 0x80af11b
            *(int32_t *)(v31 + 8) = 100 * v422 + v418;
            int32_t v423 = *(int32_t *)(v86 - 60); // 0x80af125
            *(int32_t *)v31 = yyElement;
            *(int32_t *)(v31 + 4) = 100 * v423 + v419;
            CreateNewLineInElement(v80, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 147;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 148: {
            // 0x80af085
            *(int32_t *)(v31 + 28) = *(int32_t *)(v86 - 12);
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 60);
            int32_t v424 = *(int32_t *)(v86 - 72); // 0x80af0ba
            *(int32_t *)(v31 + 8) = v424 + *(int32_t *)(yyElement + 220);
            int32_t v425 = *(int32_t *)(v86 - 84); // 0x80af0c7
            v195 = v425 + *(int32_t *)(yyElement + 216);
            goto lab_0x80af0ca;
        }
        case 149: {
            // 0x80af4c2
            *(int32_t *)(v31 + 28) = 100 * *(int32_t *)(v86 - 12);
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 16) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 60);
            int32_t v426 = *(int32_t *)(v86 - 72); // 0x80af4f4
            *(int32_t *)(v31 + 8) = 100 * v426 + *(int32_t *)(yyElement + 220);
            int32_t v427 = *(int32_t *)(yyElement + 216); // 0x80af506
            v195 = 100 * *(int32_t *)(v86 - 84) + v427;
            goto lab_0x80af0ca;
        }
        case 150: {
            goto lab_0x80ae555;
        }
        case 152: {
            // 0x80aeff2
            __asm_rep_movsd_memcpy((char *)(v31 + 36), (char *)(v86 - 12), 3);
            int32_t * v428 = (int32_t *)(v86 - 24); // 0x80af012
            *(int32_t *)(v31 + 32) = *v428;
            int32_t * v429 = (int32_t *)(v86 - 36); // 0x80af019
            *(int32_t *)(v31 + 28) = *v429;
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 84);
            int32_t v430 = *(int32_t *)(v86 - 96); // 0x80af042
            *(int32_t *)(v31 + 8) = v430 + *(int32_t *)(yyElement + 220);
            int32_t v431 = *(int32_t *)(v86 - 108); // 0x80af04f
            int32_t * v432 = (int32_t *)v31; // 0x80af058
            *v432 = yyElement;
            *(int32_t *)(v31 + 4) = v431 + *(int32_t *)(yyElement + 216);
            CreateNewPin(v80, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char *)&g231, (char *)&g231, (int32_t)&g231);
            *v432 = *v429;
            SaveFree((char *)&g231);
            *v432 = *v428;
            SaveFree((char *)&g231);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 152;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 153: {
            int32_t * v433 = (int32_t *)v31; // 0x80aef55
            int32_t v434; // bp-316, 0x80adf30
            *v433 = (int32_t)&v434;
            int32_t * v435 = (int32_t *)(v31 + 4); // 0x80aef5e
            *v435 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v436 = v31 - 4; // 0x80aef72
            int32_t * v437 = (int32_t *)v436;
            *v437 = v131;
            __asm_rep_movsd_memcpy((char *)(v31 + 32), (char *)&v434, 3);
            int32_t * v438 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 28) = *v438;
            int32_t * v439 = (int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 24) = *v439;
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 16) = 100 * *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 84);
            int32_t v440 = *(int32_t *)(yyElement + 220); // 0x80aefb1
            *v435 = 100 * *(int32_t *)(v86 - 96) + v440;
            int32_t v441 = *(int32_t *)(yyElement + 216); // 0x80aefbf
            *v437 = yyElement;
            *v433 = 100 * *(int32_t *)(v86 - 108) + v441;
            CreateNewPin((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char *)&g231, (char *)&g231, (int32_t)&g231);
            v160 = v438;
            v159 = v437;
            v158 = v439;
            v173 = v436;
            goto lab_0x80aefd1;
        }
        case 154: {
            int32_t * v442 = (int32_t *)v31; // 0x80afae9
            int32_t v443; // bp-328, 0x80adf30
            *v442 = (int32_t)&v443;
            int32_t * v444 = (int32_t *)(v31 + 4); // 0x80afaf2
            *v444 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v445 = v31 - 4; // 0x80afb00
            int32_t * v446 = (int32_t *)v445;
            *v446 = v86;
            int32_t v447 = 100 * *(int32_t *)(v86 - 60); // 0x80afb01
            __asm_rep_movsd_memcpy((char *)(v31 + 32), (char *)&v443, 3);
            int32_t * v448 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 28) = *v448;
            int32_t * v449 = (int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 24) = *v449;
            *(int32_t *)(v31 + 8) = v447;
            *(int32_t *)(v31 + 12) = 3000;
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 16) = v447 + 600;
            *v444 = 100 * *(int32_t *)(v86 - 72);
            *v442 = 100 * *(int32_t *)(v86 - 84);
            *v446 = yyElement;
            CreateNewPin((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char *)&g231, (char *)&g231, (int32_t)&g231);
            v163 = v448;
            v162 = v446;
            v161 = v449;
            v174 = v445;
            goto lab_0x80af255;
        }
        case 155: {
            int32_t v450 = pin_num; // 0x80afa09
            int32_t * v451 = (int32_t *)v31; // 0x80afa12
            *v451 = v9;
            int32_t * v452 = (int32_t *)(v31 + 12); // 0x80afa1b
            *v452 = (int32_t)"%d";
            int32_t * v453 = (int32_t *)(v31 + 8); // 0x80afa23
            *v453 = 8;
            int32_t * v454 = (int32_t *)(v31 + 16); // 0x80afa2e
            *v454 = v450;
            int32_t * v455 = (int32_t *)(v31 + 4); // 0x80afa32
            *v455 = 1;
            pin_num = v450 + 1;
            __sprintf_chk((char *)v80, (int32_t)&g231, (int32_t)&g231, (char *)&g231);
            int32_t v456; // bp-340, 0x80adf30
            *v451 = (int32_t)&v456;
            *v455 = *(int32_t *)(v86 - 12);
            OldFlags((int32_t)&g231);
            int32_t v457 = v31 - 4; // 0x80afa62
            int32_t * v458 = (int32_t *)v457;
            *v458 = v450;
            int32_t v459 = 100 * *(int32_t *)(v86 - 48); // 0x80afa68
            __asm_rep_movsd_memcpy((char *)(v31 + 32), (char *)&v456, 3);
            *(int32_t *)(v31 + 28) = v9;
            int32_t * v460 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 24) = *v460;
            *v452 = 3000;
            *v453 = v459;
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 36);
            *v454 = v459 + 600;
            *v455 = 100 * *(int32_t *)(v86 - 60);
            *v451 = 100 * *(int32_t *)(v86 - 72);
            *v458 = yyElement;
            CreateNewPin((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char *)&g231, (char *)&g231, (int32_t)&g231);
            v152 = v458;
            v151 = v460;
            v175 = v457;
            goto lab_0x80afabe;
        }
        case 156: {
            int32_t * v461 = (int32_t *)(v86 - 36); // 0x80af920
            int32_t v462 = *v461; // 0x80af920
            int32_t v463 = 40 * v462; // 0x80af926
            int32_t v464 = v463; // 0x80af933
            if (-39 * v462 <= 399) {
                // 0x80af935
                v464 = v462 < 401 == (400 - v462 & v462) < 0 ? v462 - 400 : v463;
            }
            int32_t v465 = pin_num; // 0x80af943
            int32_t * v466 = (int32_t *)(v31 + 12); // 0x80af955
            *v466 = (int32_t)"%d";
            int32_t * v467 = (int32_t *)(v31 + 8); // 0x80af95d
            *v467 = 8;
            pin_num = v465 + 1;
            int32_t * v468 = (int32_t *)(v31 + 16); // 0x80af970
            *v468 = v465;
            int32_t * v469 = (int32_t *)(v31 + 4); // 0x80af974
            *v469 = 1;
            int32_t * v470 = (int32_t *)v31; // 0x80af97c
            *v470 = v9;
            __sprintf_chk((char *)v80, (int32_t)&g231, (int32_t)&g231, (char *)&g231);
            int32_t v471; // bp-352, 0x80adf30
            *v470 = (int32_t)&v471;
            *v469 = *(int32_t *)(v86 - 12);
            OldFlags((int32_t)&g231);
            int32_t v472 = v31 - 4; // 0x80af99e
            int32_t * v473 = (int32_t *)v472; // 0x80af99e
            *v473 = v80;
            int32_t v474 = 100 * *v461; // 0x80af99f
            __asm_rep_movsd_memcpy((char *)(v31 + 32), (char *)&v471, 3);
            *(int32_t *)(v31 + 28) = v9;
            int32_t * v475 = (int32_t *)(v86 - 24); // 0x80af9b5
            *(int32_t *)(v31 + 20) = v464;
            *v466 = 3000;
            *v467 = v474;
            *(int32_t *)(v31 + 24) = *v475;
            *v468 = v474 + 600;
            *v469 = 100 * *(int32_t *)(v86 - 48);
            *v470 = 100 * *(int32_t *)(v86 - 60);
            *v473 = yyElement;
            CreateNewPin((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char *)&g231, (char *)&g231, (int32_t)&g231);
            *v473 = *v475;
            SaveFree((char *)&g231);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 156;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v472;
            goto lab_0x80ae240;
        }
        case 157: {
            int32_t v476 = *(int32_t *)(yyElement + 220); // 0x80af89c
            int32_t v477 = *(int32_t *)(yyElement + 216); // 0x80af8a2
            __asm_rep_movsd_memcpy((char *)(v31 + 40), (char *)(v86 - 12), 3);
            int32_t * v478 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 36) = *v478;
            int32_t * v479 = (int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 32) = *v479;
            *(int32_t *)(v31 + 28) = *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 24) = *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 72);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 84) + v476;
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 96) + v477;
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 108) + v476;
            int32_t * v480 = (int32_t *)v31;
            *v480 = yyElement;
            *(int32_t *)(v31 + 4) = *(int32_t *)(v86 - 120) + v477;
            CreateNewPad(v80, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char *)&g231, (char *)&g231, (int32_t)&g231);
            v160 = v478;
            v159 = v480;
            v158 = v479;
            v173 = v31;
            goto lab_0x80aefd1;
        }
        case 158: {
            int32_t * v481 = (int32_t *)v31; // 0x80af7d3
            int32_t v482; // bp-364, 0x80adf30
            *v481 = (int32_t)&v482;
            int32_t * v483 = (int32_t *)(v31 + 4); // 0x80af7dc
            *v483 = *(int32_t *)(v86 - 12);
            int32_t v484 = OldFlags(v80); // 0x80af7e0
            int32_t v485 = v31 - 4; // 0x80af7f0
            int32_t * v486 = (int32_t *)v485;
            *v486 = v484;
            int32_t v487 = *(int32_t *)(yyElement + 220); // 0x80af7f1
            int32_t v488 = *(int32_t *)(yyElement + 216); // 0x80af7f7
            __asm_rep_movsd_memcpy((char *)(v31 + 36), (char *)&v482, 3);
            int32_t * v489 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 32) = *v489;
            int32_t * v490 = (int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 28) = *v490;
            *(int32_t *)(v31 + 24) = 100 * *(int32_t *)(v86 - 48);
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 16) = 100 * *(int32_t *)(v86 - 72);
            int32_t v491 = *(int32_t *)(v86 - 84); // 0x80af841
            *(int32_t *)(v31 + 12) = 100 * v491 + v487;
            int32_t v492 = *(int32_t *)(v86 - 96); // 0x80af84f
            *(int32_t *)(v31 + 8) = 100 * v492 + v488;
            *v483 = 100 * *(int32_t *)(v86 - 108) + v487;
            *v486 = yyElement;
            *v481 = 100 * *(int32_t *)(v86 - 120) + v488;
            CreateNewPad((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char *)&g231, (char *)&g231, (int32_t)&g231);
            v163 = v489;
            v162 = v486;
            v161 = v490;
            v174 = v485;
            goto lab_0x80af255;
        }
        case 159: {
            int32_t * v493 = (int32_t *)v31; // 0x80af740
            *v493 = v11;
            int32_t * v494 = (int32_t *)(v31 + 4); // 0x80af749
            *v494 = *(int32_t *)(v86 - 12);
            OldFlags(v80);
            int32_t v495 = v31 - 4; // 0x80af757
            int32_t * v496 = (int32_t *)v495;
            *v496 = v11;
            int32_t v497 = 100 * *(int32_t *)(v86 - 48); // 0x80af758
            __asm_rep_movsd_memcpy((char *)(v31 + 36), (char *)&v10, 3);
            int32_t * v498 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 32) = *v498;
            int32_t * v499 = (int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 20) = 3000;
            *(int32_t *)(v31 + 16) = v497;
            *(int32_t *)(v31 + 28) = *v499;
            *(int32_t *)(v31 + 24) = v497 + 600;
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 60);
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 72);
            *v494 = 100 * *(int32_t *)(v86 - 84);
            *v493 = 100 * *(int32_t *)(v86 - 96);
            *v496 = yyElement;
            CreateNewPad((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char *)&g231, (char *)&g231, (int32_t)&g231);
            v163 = v498;
            v162 = v496;
            v161 = v499;
            v174 = v495;
            goto lab_0x80af255;
        }
        case 160: {
            int32_t * v500 = (int32_t *)v31; // 0x80af667
            *v500 = v9;
            int32_t * v501 = (int32_t *)(v31 + 12); // 0x80af66a
            *v501 = (int32_t)"%d";
            int32_t * v502 = (int32_t *)(v31 + 16); // 0x80af675
            *v502 = pin_num;
            int32_t * v503 = (int32_t *)(v31 + 8); // 0x80af679
            *v503 = 8;
            int32_t * v504 = (int32_t *)(v31 + 4); // 0x80af681
            *v504 = 1;
            pin_num++;
            __sprintf_chk((char *)v80, (int32_t)&g231, (int32_t)&g231, (char *)&g231);
            *v504 = *(int32_t *)(v86 - 12);
            int32_t v505; // bp-388, 0x80adf30
            *v500 = (int32_t)&v505;
            OldFlags((int32_t)&g231);
            int32_t v506 = v31 - 4; // 0x80af6b9
            int32_t * v507 = (int32_t *)v506; // 0x80af6b9
            *v507 = v86;
            int32_t v508 = 100 * *(int32_t *)(v86 - 36); // 0x80af6ba
            __asm_rep_movsd_memcpy((char *)(v31 + 36), (char *)&v505, 3);
            *(int32_t *)(v31 + 32) = v9;
            int32_t * v509 = (int32_t *)(v86 - 24); // 0x80af6d1
            *(int32_t *)(v31 + 20) = 3000;
            *v502 = v508;
            *(int32_t *)(v31 + 28) = *v509;
            *(int32_t *)(v31 + 24) = v508 + 600;
            *v501 = 100 * *(int32_t *)(v86 - 48);
            *v503 = 100 * *(int32_t *)(v86 - 60);
            *v504 = 100 * *(int32_t *)(v86 - 72);
            *v500 = 100 * *(int32_t *)(v86 - 84);
            *v507 = yyElement;
            CreateNewPad((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char *)&g231, (char *)&g231, (int32_t)&g231);
            *v507 = *v509;
            SaveFree((char *)&g231);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 160;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v506;
            goto lab_0x80ae240;
        }
        case 161: {
            // 0x80af62f
            *(int32_t *)v31 = v7;
            *(int32_t *)(v31 + 4) = *(int32_t *)v86;
            OldFlags(v80);
            int32_t v510 = v31 - 4; // 0x80af652
            *(int32_t *)v510 = v133;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 161;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v510;
            goto lab_0x80ae240;
        }
        case 162: {
            // 0x80aea8c
            *(int32_t *)(v31 + 8) = 0x80adf00;
            *(int32_t *)v31 = v7;
            *(int32_t *)(v31 + 4) = *(int32_t *)v86;
            string_to_flags((char *)v80, (int32_t (*)(char *))&g231);
            int32_t v511 = v31 - 4; // 0x80aeab1
            *(int32_t *)v511 = v80;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 162;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v511;
            goto lab_0x80ae240;
        }
        case 165: {
            int32_t v512 = *(int32_t *)(v86 - 36); // 0x80aea41
            if (v512 < 256) {
                int32_t v513 = yyFont + 28 * v512;
                Symbol = v513 + 24;
                char * v514 = (char *)(v513 + 28); // 0x80aea68
                if (*v514 != 0) {
                    // 0x80b08b5
                    *(int32_t *)(v31 + 12) = (int32_t)"symbol ID used twice";
                    goto lab_0x80b08bd;
                } else {
                    // 0x80aea72
                    *v514 = 1;
                    *(int32_t *)(Symbol + 24) = *(int32_t *)(v86 - 24);
                    v135 = v86;
                    v136 = v85;
                    v137 = v84;
                    v138 = v83;
                    v139 = v82;
                    v140 = v129;
                    v141 = 165;
                    v142 = v131;
                    v143 = v133;
                    v144 = v134;
                    v145 = v80;
                    v146 = v31;
                    goto lab_0x80ae240;
                }
            } else {
                // 0x80b08e6
                *(int32_t *)(v31 + 12) = (int32_t)"fontposition out of range";
                goto lab_0x80b08bd;
            }
        }
        case 167: {
            int32_t v515 = *(int32_t *)(v86 - 36); // 0x80ae9ef
            if (v515 < 256) {
                int32_t v516 = yyFont + 28 * v515;
                Symbol = v516 + 24;
                char * v517 = (char *)(v516 + 28); // 0x80aea16
                if (*v517 != 0) {
                    // 0x80b08b5
                    *(int32_t *)(v31 + 12) = (int32_t)"symbol ID used twice";
                    goto lab_0x80b08bd;
                } else {
                    // 0x80aea20
                    *v517 = 1;
                    *(int32_t *)(Symbol + 24) = 100 * *(int32_t *)(v86 - 24);
                    v135 = v86;
                    v136 = v85;
                    v137 = v84;
                    v138 = v83;
                    v139 = v82;
                    v140 = v129;
                    v141 = 167;
                    v142 = v131;
                    v143 = v133;
                    v144 = v134;
                    v145 = v80;
                    v146 = v31;
                    goto lab_0x80ae240;
                }
            } else {
                // 0x80b08e6
                *(int32_t *)(v31 + 12) = (int32_t)"fontposition out of range";
                goto lab_0x80b08bd;
            }
        }
        case 176: {
            // 0x80ae99d
            *(int32_t *)(v31 + 20) = 100 * *(int32_t *)(v86 - 12);
            *(int32_t *)(v31 + 16) = 100 * *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 12) = 100 * *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 8) = 100 * *(int32_t *)(v86 - 48);
            v199 = 100 * *(int32_t *)(v86 - 60);
            goto lab_0x80ae9c7;
        }
        case 177: {
            // 0x80aef1c
            *(int32_t *)(v31 + 20) = *(int32_t *)(v86 - 12);
            *(int32_t *)(v31 + 16) = *(int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 12) = *(int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 8) = *(int32_t *)(v86 - 48);
            v199 = *(int32_t *)(v86 - 60);
            goto lab_0x80ae9c7;
        }
        case 185: {
            int32_t * v518 = (int32_t *)(v86 - 24);
            *(int32_t *)(v31 + 8) = *v518;
            int32_t * v519 = (int32_t *)(v86 - 36);
            *(int32_t *)(v31 + 4) = *v519;
            int32_t * v520 = (int32_t *)v31;
            *v520 = yyPCB + 0x21f4;
            Menu = CreateNewNet(v80, (char *)&g231, (char *)&g231);
            v163 = v518;
            v162 = v520;
            v161 = v519;
            v174 = v31;
            goto lab_0x80af255;
        }
        case 191: {
            int32_t * v521 = (int32_t *)(v86 - 12); // 0x80ae56f
            *(int32_t *)(v31 + 4) = *v521;
            int32_t * v522 = (int32_t *)v31; // 0x80ae581
            *v522 = Menu;
            CreateNewConnection(v80, (char *)&g231);
            *v522 = *v521;
            SaveFree((char *)&g231);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 191;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 194: {
            int32_t * v523 = (int32_t *)(v86 - 12); // 0x80ae6fd
            *(int32_t *)(v31 + 8) = *v523;
            int32_t * v524 = (int32_t *)(v86 - 24); // 0x80ae704
            *(int32_t *)(v31 + 4) = *v524;
            int32_t * v525 = (int32_t *)v31; // 0x80ae716
            *v525 = attr_list;
            CreateNewAttribute(v80, (char *)&g231, (char *)&g231);
            *v525 = *v524;
            SaveFree((char *)&g231);
            *v525 = *v523;
            SaveFree((char *)&g231);
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v80;
            v141 = 194;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 195: {
            // 0x80ae866
            v6 = *(int32_t *)v86;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 195;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        case 196: {
            // 0x80b06b7
            v6 = 0;
            v135 = v86;
            v136 = v85;
            v137 = v84;
            v138 = v83;
            v139 = v82;
            v140 = v129;
            v141 = 196;
            v142 = v131;
            v143 = v133;
            v144 = v134;
            v145 = v80;
            v146 = v31;
            goto lab_0x80ae240;
        }
        default: {
            goto lab_0x80ae240;
        }
    }
  lab_0x80b06d2:
    // 0x80b06d2
    *(int32_t *)(v31 + 12) = (int32_t)"memory exhausted";
    *v56 = (int32_t)"ERROR parsing file '%s'\n    line:        %i\n    description: '%s'\n";
    *(int32_t *)(v31 + 8) = yylineno;
    *v24 = yyfilename;
    Message((char *)nmemb);
    v34 = v32;
    v37 = v35;
    v43 = v44;
    v60 = v58;
    v46 = v28;
    v48 = nmemb;
    v40 = v41;
    v63 = v62;
    v55 = v54;
    v52 = v51;
    v25 = 0;
    v29 = nmemb;
    v27 = 2;
    goto lab_0x80aece1;
  lab_0x80ae329:;
    int32_t v577 = v88;
    int32_t v578 = v80;
    int32_t v579 = v86;
    int32_t v580; // 0x80adf30
    uint32_t v581; // 0x80ae331
    int32_t v582; // 0x80adf30
    uint16_t v583; // 0x80ae347
    int32_t v584; // 0x80ae362
    if (v577 != -424) {
        // 0x80ae331
        v581 = v577 + 1;
        if (v581 < 590) {
            // 0x80ae33c
            if (*(int16_t *)(v581 + v577 + 0x814c521) == 1) {
                // 0x80ae347
                if (*(int16_t *)(v582 + 0x814c9c1) >= 1) {
                    // 0x80ae353
                    v34 = v579;
                    v37 = v85;
                    v43 = v84;
                    v60 = v83;
                    v46 = v82;
                    v48 = v580;
                    v40 = v124;
                    v63 = v62;
                    v55 = v54;
                    v52 = v51;
                    v25 = 0;
                    v29 = v578;
                    v27 = 0;
                    if (v583 == 10) {
                        goto lab_0x80aece1;
                    } else {
                        // 0x80ae362
                        v584 = v579 + 12;
                        int32_t v585 = yylval; // 0x80ae36b
                        *(int32_t *)v584 = v585;
                        int32_t v586 = g222; // 0x80ae378
                        *(int32_t *)(v579 + 16) = v586;
                        int32_t v587 = g223; // 0x80ae380
                        *(int32_t *)(v579 + 20) = v587;
                        v93 = v584;
                        v94 = v85;
                        v98 = v84;
                        v105 = 3;
                        v106 = v83;
                        v99 = v82;
                        v101 = v580;
                        v96 = v124;
                        v107 = v62;
                        v104 = v54;
                        v103 = v51;
                        v91 = v578;
                        v90 = v583;
                        v92 = v31;
                        goto lab_0x80ae2ae;
                    }
                }
            }
        }
    }
    int32_t v538 = v86; // 0x80ae312
    int32_t v539 = v85; // 0x80ae312
    int32_t v540 = v84; // 0x80ae312
    int32_t v541 = v83; // 0x80ae312
    int32_t v542 = v82; // 0x80ae312
    int32_t v543 = v126; // 0x80ae312
    int32_t v544 = v124; // 0x80ae312
    int32_t v545 = v62; // 0x80ae312
    int32_t v546 = v54; // 0x80ae312
    int32_t v547 = v51; // 0x80ae312
    int32_t v548 = v85; // 0x80ae312
    int32_t v549 = 1; // 0x80ae312
    while (v578 != v85) {
        int32_t v588 = v578 - 2; // 0x80ae318
        int16_t v589 = *(int16_t *)v588; // 0x80ae31e
        int16_t v590 = *(int16_t *)(2 * (int32_t)v589 + (int32_t)&g23); // 0x80ae321
        v577 = v590;
        v578 = v588;
        v579 -= 12;
        if (v577 != -424) {
            // 0x80ae331
            v581 = v577 + 1;
            if (v581 < 590) {
                // 0x80ae33c
                if (*(int16_t *)(v581 + v577 + 0x814c521) == 1) {
                    // 0x80ae347
                    v583 = *(int16_t *)(v582 + 0x814c9c1);
                    if (v583 >= 1) {
                        // 0x80ae353
                        v34 = v579;
                        v37 = v85;
                        v43 = v84;
                        v60 = v83;
                        v46 = v82;
                        v48 = v580;
                        v40 = v124;
                        v63 = v62;
                        v55 = v54;
                        v52 = v51;
                        v25 = 0;
                        v29 = v578;
                        v27 = 0;
                        if (v583 == 10) {
                            goto lab_0x80aece1;
                        } else {
                            // 0x80ae362
                            v584 = v579 + 12;
                            *(int32_t *)v584 = yylval;
                            *(int32_t *)(v579 + 16) = g222;
                            *(int32_t *)(v579 + 20) = g223;
                            v93 = v584;
                            v94 = v85;
                            v98 = v84;
                            v105 = 3;
                            v106 = v83;
                            v99 = v82;
                            v101 = v580;
                            v96 = v124;
                            v107 = v62;
                            v104 = v54;
                            v103 = v51;
                            v91 = v578;
                            v90 = v583;
                            v92 = v31;
                            goto lab_0x80ae2ae;
                        }
                    }
                }
            }
        }
        // 0x80ae310
        v538 = v86;
        v539 = v85;
        v540 = v84;
        v541 = v83;
        v542 = v82;
        v543 = v126;
        v544 = v124;
        v545 = v62;
        v546 = v54;
        v547 = v51;
        v548 = v85;
        v549 = 1;
    }
    goto lab_0x80ae3a3;
  lab_0x80aecd2:
    // 0x80aecd2
    v34 = v86;
    v37 = v85;
    v43 = v84;
    v60 = v83;
    v46 = v82;
    v48 = v129;
    v40 = v128;
    v63 = v131;
    v55 = v133;
    v52 = v134;
    v25 = -((2 * v131));
    v29 = v80;
    v27 = 1;
    goto lab_0x80aece1;
  lab_0x80ae4fb:
    // 0x80ae4fb
    *(int32_t *)(v31 + 8) = yyFont;
    *(int32_t *)(v31 + 4) = yyElement;
    *(int32_t *)v31 = yyData;
    SetElementBoundingBox(v80, (int32_t)&g231, (int32_t)&g231);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v31;
    goto lab_0x80ae240;
  lab_0x80ae555:
    // 0x80ae555
    attr_list = yyElement + 288;
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v129;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v31;
    goto lab_0x80ae240;
  lab_0x80ae240:;
    int32_t v567 = v146;
    int32_t v565 = v144;
    int32_t v564 = v143;
    int32_t v563 = v142;
    int32_t v562 = v141;
    int32_t v561 = v140;
    int32_t v560 = v139;
    int32_t v559 = v138;
    int32_t v558 = v137;
    int32_t v557 = v136;
    int32_t v566 = v145 - 2 * v563; // 0x80ae254
    int32_t v568 = -12 * v563 + v135; // 0x80ae25f
    int32_t v556 = v568 + 12; // 0x80ae261
    *(int32_t *)v556 = v6;
    *(int32_t *)(v568 + 16) = v564;
    *(int32_t *)(v568 + 20) = v565;
    int16_t v569 = *(int16_t *)v566; // 0x80ae27f
    unsigned char v570 = *(char *)(v562 + (int32_t)&g29); // 0x80ae282
    int32_t v555 = 2 * (int32_t)v570;
    int16_t v571 = *(int16_t *)(v555 + (int32_t)&g30 - 82); // 0x80ae28f
    uint32_t v572 = (int32_t)v571 + (int32_t)v569; // 0x80ae297
    if (v572 < 590) {
        int32_t v573 = 2 * v572;
        if (*(int16_t *)(v573 + (int32_t)&g25) != v569) {
            goto lab_0x80ae2a6;
        } else {
            int16_t v574 = *(int16_t *)(v573 + (int32_t)&g26); // 0x80ae3e6
            v93 = v556;
            v94 = v557;
            v98 = v558;
            v105 = v57;
            v106 = v559;
            v99 = v560;
            v101 = v561;
            v96 = v562;
            v107 = v563;
            v104 = v564;
            v103 = v565;
            v91 = v566;
            v90 = v574;
            v92 = v567;
            goto lab_0x80ae2ae;
        }
    } else {
        goto lab_0x80ae2a6;
    }
  lab_0x80aece1:;
    int32_t v526 = v27;
    int32_t v527 = v52;
    int32_t v528 = v55;
    int32_t v529 = v63;
    int32_t v530 = v40;
    int32_t v531 = v48;
    int32_t v532 = v46;
    int32_t v533 = v60;
    int32_t v534 = v43;
    int32_t v535 = v37;
    int32_t v536 = v34;
    int32_t v537 = v29 + v25; // 0x80aece1
    v538 = v536;
    v539 = v535;
    v540 = v534;
    v541 = v533;
    v542 = v532;
    v543 = v531;
    v544 = v530;
    v545 = v529;
    v546 = v528;
    v547 = v527;
    v548 = v535;
    v549 = v526;
    if (v535 != v537) {
        // 0x80aecf0
        v538 = v536;
        v539 = v535;
        v540 = v534;
        v541 = v533;
        v542 = v532;
        v543 = v531;
        v544 = v530;
        v545 = v529;
        v546 = v528;
        v547 = v527;
        v548 = (v535 + 1 - v537 & -2) + v537;
        v549 = v526;
    }
    goto lab_0x80ae3a3;
  lab_0x80ae3a3:
    // 0x80ae3a3
    result = v549;
    int32_t v550 = v539;
    if (v548 != v5) {
        // 0x80ae3ab
        *(int32_t *)v31 = v550;
        free(&g231);
    }
    // 0x80ae3b9
    if (v3 == __readgsdword(20)) {
        // break -> 0x80ae3cb
        goto lab_0x80ae3cb;
    }
    // 0x80b0904
    __stack_chk_fail();
    v148 = (int32_t *)(result + 60);
    v166 = (int32_t *)v31;
    v179 = v538;
    v181 = v550;
    v185 = v540;
    v203 = v541;
    v187 = v542;
    v188 = v543;
    v182 = v544;
    v205 = v545;
    v192 = v546;
    v190 = v547;
    goto lab_0x80b0909;
  lab_0x80ae2a6:;
    int16_t v554 = *(int16_t *)(v555 + (int32_t)&g31 - 82); // 0x80ae2a6
    v93 = v556;
    v94 = v557;
    v98 = v558;
    v105 = v57;
    v106 = v559;
    v99 = v560;
    v101 = v561;
    v96 = v562;
    v107 = v563;
    v104 = v564;
    v103 = v565;
    v91 = v566;
    v90 = v554;
    v92 = v567;
    goto lab_0x80ae2ae;
  lab_0x80af5e9:
    // 0x80af5e9
    __asm_rep_movsd_memcpy((char *)(v169 + 4), (char *)&v12, 3);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v31 - 4;
    goto lab_0x80ae240;
  lab_0x80af544:;
    int32_t * v575 = (int32_t *)v31; // 0x80af54a
    *v575 = *(int32_t *)(v86 - 12);
    int32_t v576 = ParseRouteString((char *)v80, (int32_t)&g231, (int32_t)&g231); // 0x80af54d
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v31;
    if (v576 == 0) {
        goto lab_0x80ae240;
    } else {
        // 0x80af560
        *v575 = (int32_t)"illegal route-style string\n";
        Message((char *)&g231);
        goto lab_0x80af56c;
    }
  lab_0x80b0547:
    // 0x80b0547
    *(int32_t *)(v171 + 4) = 100 * *(int32_t *)v168;
    *v150 = yyData;
    CreateNewVia((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (char *)&g231, (int32_t)&g231);
    v152 = v150;
    v151 = v147;
    v175 = v171;
    goto lab_0x80afabe;
  lab_0x80b0133:
    // 0x80b0133
    *(int32_t *)(v200 + 4) = 100 * *(int32_t *)v194;
    *v201 = Layer;
    CreateNewLineOnLayer((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v200;
    goto lab_0x80ae240;
  lab_0x80affd4:
    // 0x80affd4
    *(int32_t *)(v177 + 4) = 100 * *(int32_t *)v193;
    *v153 = Layer;
    CreateNewArcOnLayer((int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v177;
    goto lab_0x80ae240;
  lab_0x80afe1c:
    // 0x80afe1c
    *v155 = *v154;
    SaveFree((char *)v80);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v176;
    goto lab_0x80ae240;
  lab_0x80afd4b:
    // 0x80afd4b
    *(int32_t *)(v31 + 4) = v198;
    *(int32_t *)v31 = Polygon;
    CreateNewPointInPolygon(v80, (int32_t)&g231, (int32_t)&g231);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v31;
    goto lab_0x80ae240;
  lab_0x80ae6d7:
    // 0x80ae6d7
    *v157 = *v156;
    SaveFree((char *)&g231);
    pin_num = 1;
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v172;
    goto lab_0x80ae240;
  lab_0x80afb8f:
    // 0x80afb8f
    *(int32_t *)(v31 + 4) = v197;
    *(int32_t *)v31 = yyElement;
    CreateNewLineInElement(v80, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v31;
    goto lab_0x80ae240;
  lab_0x80af1c7:
    // 0x80af1c7
    *(int32_t *)(v31 + 4) = v196;
    *(int32_t *)v31 = yyElement;
    CreateNewArcInElement(v80, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v31;
    goto lab_0x80ae240;
  lab_0x80af0ca:
    // 0x80af0ca
    *(int32_t *)(v31 + 4) = v195;
    *(int32_t *)v31 = yyElement;
    CreateNewArcInElement(v80, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v31;
    goto lab_0x80ae240;
  lab_0x80aefd1:
    // 0x80aefd1
    *v159 = *v158;
    SaveFree((char *)&g231);
    *v159 = *v160;
    SaveFree((char *)&g231);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v173;
    goto lab_0x80ae240;
  lab_0x80af255:
    // 0x80af255
    *v162 = *v161;
    SaveFree((char *)&g231);
    *v162 = *v163;
    SaveFree((char *)&g231);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v174;
    goto lab_0x80ae240;
  lab_0x80afabe:
    // 0x80afabe
    *v152 = *v151;
    SaveFree((char *)&g231);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v175;
    goto lab_0x80ae240;
  lab_0x80ae9c7:
    // 0x80ae9c7
    *(int32_t *)(v31 + 4) = v199;
    *(int32_t *)v31 = Symbol;
    CreateNewLineInSymbol(v80, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
    v135 = v86;
    v136 = v85;
    v137 = v84;
    v138 = v83;
    v139 = v82;
    v140 = v80;
    v141 = v128;
    v142 = v131;
    v143 = v133;
    v144 = v134;
    v145 = v80;
    v146 = v31;
    goto lab_0x80ae240;
  lab_0x80b0909:;
    int32_t * v551 = (int32_t *)(v31 + 8);
    *v551 = 0;
    int32_t * v552 = (int32_t *)(v31 + 4);
    *v552 = 0;
    *v166 = 0;
    int32_t v553 = r_create_tree((int32_t)&g231, (int32_t)&g231, (int32_t)&g231); // 0x80b0920
    *v148 = v553;
    v165 = v552;
    v164 = v551;
    v149 = v166;
    v178 = v179;
    v180 = v181;
    v184 = v185;
    v202 = v203;
    v186 = v187;
    v183 = v182;
    v204 = v205;
    v191 = v192;
    v189 = v190;
    v167 = *(int32_t *)(Layer + 60);
    v170 = v188;
    goto lab_0x80b0246;
  lab_0x80ae2ae:
    // 0x80ae2ae
    v14 = v93;
    v15 = v94;
    v16 = v98;
    v17 = v105;
    v18 = v106;
    v47 = v101;
    v38 = v96;
    v61 = v107;
    v53 = v104;
    v50 = v103;
    v19 = v91 + 2;
    v20 = v90;
    v22 = v92;
    v23 = v99;
    goto lab_0x80adfc1;
  lab_0x80af56c:
    // 0x80af56c
    v34 = v86;
    v37 = v85;
    v43 = v84;
    v60 = v83;
    v46 = v82;
    v48 = v80;
    v40 = v128;
    v63 = v131;
    v55 = v133;
    v52 = v134;
    v25 = -((2 * v131));
    v29 = v80;
    v27 = 1;
    goto lab_0x80aece1;
  lab_0x80b08bd:
    // 0x80b08bd
    *(int32_t *)v31 = (int32_t)"ERROR parsing file '%s'\n    line:        %i\n    description: '%s'\n";
    *(int32_t *)(v31 + 8) = yylineno;
    *(int32_t *)(v31 + 4) = yyfilename;
    Message((char *)v80);
    goto lab_0x80af56c;
  lab_0x80b0246:
    // 0x80b0246
    *v164 = 0;
    *v149 = v167;
    *v165 = Polygon;
    r_insert_entry(v170, (int32_t)&g231, (int32_t)&g231);
    v135 = v178;
    v136 = v180;
    v137 = v184;
    v138 = v202;
    v139 = v186;
    v140 = v170;
    v141 = v183;
    v142 = v204;
    v143 = v191;
    v144 = v189;
    v145 = v170;
    v146 = v31;
    goto lab_0x80ae240;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon.c
// Address range: 0x80b11b0 - 0x80b12c5
// Line range:    204 - 229
int32_t original_poly(int32_t p) {
    // 0x80b11b0
    int32_t v1; // 0x80b11b0
    int32_t v2 = *(int32_t *)(v1 + 36); // 0x80b11be
    int32_t v3 = 0; // 0x80b11c7
    if (v2 != 0) {
        int32_t v4 = v2; // 0x80b11d4
        int32_t v5 = 20 * v2; // 0x80b11d4
        int32_t v6 = 0; // 0x80b11d4
        while (true) {
            int32_t v7 = v6;
            v5 -= 20;
            int32_t v8 = *(int32_t *)(*(int32_t *)(v1 + 56) + v5); // bp-36, 0x80b11e4
            int32_t v9; // 0x80b11b0
            if (v7 == 0) {
                int32_t v10 = poly_NewContour(&v8); // 0x80b129e
                v9 = v10;
                if (v10 == 0) {
                    // break -> 0x80b128c
                    break;
                }
            } else {
                int32_t v11 = poly_CreateNode(&v8); // 0x80b11f9
                poly_InclVertex(*(int32_t *)(v7 + 24), v11);
                v9 = v7;
            }
            // 0x80b120d
            v4--;
            v6 = v9;
            v3 = v6;
            if (v4 == 0) {
                goto lab_0x80b1218;
            }
        }
        // 0x80b128c
        return 0;
    }
  lab_0x80b1218:
    // 0x80b1218
    poly_PreContour(v3, 1);
    if ((*(char *)(v3 + 68) & 8) == 0) {
        // 0x80b12b8
        poly_InvContour(v3);
    }
    int32_t result = poly_Create(); // 0x80b1232
    if (result == 0) {
        // 0x80b128c
        return 0;
    }
    // 0x80b123f
    poly_InclContour(result, v3);
    int32_t v12 = result;
    float80_t v13 = (float80_t)*(float64_t *)(*(int32_t *)(v12 + 8) + 56); // 0x80b1265
    int32_t v14 = *(int32_t *)v12;
    int32_t v15; // 0x80b11b0
    while (-1.0L >= v13) {
        // 0x80b126c
        v15 = 0;
        if (result == v14) {
            // break (via goto) -> 0x80b127a
            goto lab_0x80b127a;
        }
        v12 = v14;
        v13 = (float80_t)*(float64_t *)(*(int32_t *)(v12 + 8) + 56);
        v14 = *(int32_t *)v12;
    }
    float80_t v16 = v13; // 0x80b1260
    v15 = v12;
    while (result != v14) {
        int32_t v17 = v12;
        v12 = v14;
        v13 = (float80_t)*(float64_t *)(*(int32_t *)(v12 + 8) + 56);
        v14 = *(int32_t *)v12;
        while (v16 >= v13) {
            // 0x80b126c
            v15 = v17;
            if (result == v14) {
                // break (via goto) -> 0x80b127a
                goto lab_0x80b127a;
            }
            v12 = v14;
            v13 = (float80_t)*(float64_t *)(*(int32_t *)(v12 + 8) + 56);
            v14 = *(int32_t *)v12;
        }
        // 0x80b1258
        v16 = v13;
        v15 = v12;
    }
  lab_0x80b127a:
    // 0x80b127a
    if (result != v15) {
        int32_t * v18 = (int32_t *)(v15 + 8); // 0x80b127e
        int32_t * v19 = (int32_t *)(result + 8); // 0x80b1281
        *v18 = *v19;
        *v19 = *v18;
    }
    // 0x80b128c
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon.c
// Address range: 0x80b1eb0 - 0x80b23de
// Line range:    895 - 889
int32_t clearPoly(int32_t Data, int32_t Layer2, int32_t polygon, int32_t here, int32_t expand) {
    int32_t v1[8]; // 0x80b2072
    struct __jmp_buf_tag v2; // 0x80b2072
    struct __jmp_buf_tag env[1]; // 0x80b2072
    // 0x80b1eb0
    int32_t v3; // 0x80b1eb0
    if ((*(char *)(v3 + 20) & 16) == 0) {
        // 0x80b1ed4
        return 0;
    }
    uint32_t v4 = GetLayerNumber(v3, v3); // 0x80b1eef
    if (v4 >= *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24)) {
        // 0x80b1ed4
        return 0;
    }
    int32_t v5 = GetLayerNumber(v3, v3); // 0x80b1f18
    uint32_t v6 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24); // 0x80b1f29
    int32_t v7 = 0; // 0x80b1f2e
    int32_t v8 = 0; // 0x80b1f2e
    if (v6 != 0) {
        int32_t v9 = *(int32_t *)(v3 + 72); // 0x80b1f44
        int32_t v10 = v9 + 0x1cd4;
        int32_t v11 = v9 + 0x1d18;
        int32_t v12 = 0;
        uint32_t v13 = *(int32_t *)(4 * v12 + v10); // 0x80b1f5f
        int32_t v14; // 0x80b1eb0
        int32_t v15; // 0x80b1eb0
        int32_t v16; // 0x80b1eb0
        int32_t v17; // 0x80b1f9d
        if (v13 != 0) {
            // 0x80b1f6a
            if (v5 == *(int32_t *)(v9 + 0x1d14)) {
                // break -> 0x80b20a0
                break;
            }
            // 0x80b1f7c
            v14 = 72 * v12 + v11;
            v17 = 0;
            while (v17 + 1 < v13) {
                // 0x80b1f9d
                v17++;
                // 0x80b1f90
                v15 = v14;
                v14 = v15 + 4;
                v16 = v12;
                if (v5 == *(int32_t *)v15) {
                    // break (via goto) -> 0x80b20a0
                    goto lab_0x80b20a0;
                }
            }
        }
        int32_t v18 = v12 + 1; // 0x80b1fa4
        int32_t v19 = v9 + 72; // 0x80b1fb8
        v16 = v18;
        while (v18 < v6) {
            int32_t v20 = v19;
            v12 = v18;
            v13 = *(int32_t *)(4 * v12 + v10);
            if (v13 != 0) {
                // 0x80b1f6a
                v16 = v12;
                if (v5 == *(int32_t *)(v20 + 0x1d14)) {
                    // break -> 0x80b20a0
                    break;
                }
                // 0x80b1f7c
                v14 = 72 * v12 + v11;
                v17 = 0;
                while (v17 + 1 < v13) {
                    // 0x80b1f9d
                    v17++;
                    // 0x80b1f90
                    v15 = v14;
                    v14 = v15 + 4;
                    v16 = v12;
                    if (v5 == *(int32_t *)v15) {
                        // break (via goto) -> 0x80b20a0
                        goto lab_0x80b20a0;
                    }
                }
            }
            // 0x80b1fa4
            v18 = v12 + 1;
            v19 = v20 + 72;
            v16 = v18;
        }
      lab_0x80b20a0:;
        int32_t v21 = 0;
        uint32_t v22 = *(int32_t *)(4 * v21 + v10); // 0x80b20bd
        int32_t v23; // 0x80b1eb0
        int32_t v24; // 0x80b1eb0
        int32_t v25; // 0x80b20f5
        if (v22 != 0) {
            // 0x80b20c8
            if (*(int32_t *)(v9 + 0x1d14) == v6) {
                // break -> 0x80b1fc8
                break;
            }
            // 0x80b20da
            v25 = 0;
            v23 = 72 * v21 + v11;
            v25++;
            while (v25 < v22) {
                // 0x80b20e8
                v24 = v23;
                v7 = v16;
                v8 = v21;
                v23 = v24 + 4;
                if (*(int32_t *)v24 == v6) {
                    // break (via goto) -> 0x80b1fc8
                    goto lab_0x80b1fc8;
                }
                v25++;
            }
        }
        int32_t v26 = v21 + 1; // 0x80b20fc
        v7 = v16;
        v8 = v26;
        int32_t v27 = v9 + 72; // 0x80b2108
        while (v26 < v6) {
            // 0x80b20b7
            v21 = v26;
            int32_t v28 = v27;
            v22 = *(int32_t *)(4 * v21 + v10);
            if (v22 != 0) {
                // 0x80b20c8
                v7 = v16;
                v8 = v21;
                if (*(int32_t *)(v28 + 0x1d14) == v6) {
                    // break -> 0x80b1fc8
                    break;
                }
                // 0x80b20da
                v25 = 0;
                v23 = 72 * v21 + v11;
                v25++;
                while (v25 < v22) {
                    // 0x80b20e8
                    v24 = v23;
                    v7 = v16;
                    v8 = v21;
                    v23 = v24 + 4;
                    if (*(int32_t *)v24 == v6) {
                        // break (via goto) -> 0x80b1fc8
                        goto lab_0x80b1fc8;
                    }
                    v25++;
                }
            }
            // 0x80b20fc
            v26 = v21 + 1;
            v7 = v16;
            v8 = v26;
            v27 = v28 + 72;
        }
    }
  lab_0x80b1fc8:;
    // 0x80b1fc8
    int32_t v29; // 0x80b1eb0
    if (Data != 0) {
        int32_t v30 = *(int32_t *)Data; // 0x80b1fde
        int32_t v31 = v30 - Data; // 0x80b1fde
        v29 = v31 < 0 == ((v31 ^ v30) & (v30 ^ Data)) < 0 ? v30 : Data;
    }
    int32_t v32 = v29 - Layer2; // bp-44, 0x80b2018
    int32_t v33 = Data; // bp-220, 0x80b2050
    int32_t v34; // bp-200, 0x80b1eb0
    v1[0] = &v34;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    if (_setjmp(env) != 0) {
        // 0x80b2081
        *(int32_t *)(v3 + 52) = 0;
        return 0;
    }
    int32_t v35 = &v32; // 0x80b2119
    int32_t v36 = r_search(*(int32_t *)(v3 + 40), v35, 0, 0x80b4560, (char *)&v33); // 0x80b213d
    int32_t v37 = r_search(*(int32_t *)(v3 + 48), v35, 0, 0x80b4560, (char *)&v33); // 0x80b216b
    int32_t v38 = v37 + v36; // 0x80b2176
    int32_t * v39 = (int32_t *)(v3 + 72); // 0x80b2179
    int32_t v40 = *v39; // 0x80b2179
    int32_t v41 = 4 * v7 + 0x1cd4;
    int32_t v42 = v40; // 0x80b218e
    int32_t result = v38; // 0x80b218e
    if (*(int32_t *)(v40 + v41) != 0) {
        int32_t v43 = 0; // 0x80b21b3
        uint32_t v44 = *(int32_t *)(v40 + 4 + 4 * (18 * v7 + 1860 + v43)); // 0x80b21cf
        int32_t v45 = v40; // 0x80b21e1
        int32_t v46 = v38; // 0x80b21e1
        int32_t v47; // 0x80b21fb
        int32_t v48; // 0x80b221e
        int32_t v49; // 0x80b2253
        int32_t v50; // 0x80b2294
        if (v44 < *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24)) {
            // 0x80b21e3
            v47 = 92 * v44 + v3;
            v48 = r_search(*(int32_t *)(v47 + 128), v35, 0, 0x80b4460, (char *)&v33);
            v49 = r_search(*(int32_t *)(v47 + 140), v35, 0, 0x80b4310, (char *)&v33);
            v50 = r_search(*(int32_t *)(v47 + 132), v35, 0, 0x80b4630, (char *)&v33);
            v45 = *v39;
            v46 = v48 + v38 + v49 + v50;
        }
        int32_t v51 = v46;
        int32_t v52 = v45; // 0x80b21b8
        v43++;
        v42 = v52;
        result = v51;
        while (*(int32_t *)(v52 + v41) > v43) {
            int32_t v53 = v51;
            v44 = *(int32_t *)(v52 + 4 + 4 * (18 * v7 + 1860 + v43));
            v45 = v52;
            v46 = v53;
            if (v44 < *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24)) {
                // 0x80b21e3
                v47 = 92 * v44 + v3;
                v48 = r_search(*(int32_t *)(v47 + 128), v35, 0, 0x80b4460, (char *)&v33);
                v49 = r_search(*(int32_t *)(v47 + 140), v35, 0, 0x80b4310, (char *)&v33);
                v50 = r_search(*(int32_t *)(v47 + 132), v35, 0, 0x80b4630, (char *)&v33);
                v45 = *v39;
                v46 = v48 + v53 + v49 + v50;
            }
            // 0x80b21b8
            v51 = v46;
            v52 = v45;
            v43++;
            v42 = v52;
            result = v51;
        }
    }
    // 0x80b22be
    if (v8 != v7) {
        uint32_t v54 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24); // 0x80b22e7
        int32_t v55 = 0; // 0x80b22f5
        if (v54 != 0) {
            int32_t v56 = v54 + 1; // 0x80b22ec
            int32_t v57 = 0;
            uint32_t v58 = *(int32_t *)(v42 + 0x1cd4 + 4 * v57); // 0x80b2303
            int32_t v59; // 0x80b1eb0
            int32_t v60; // 0x80b1eb0
            int32_t v61; // 0x80b2339
            if (v58 != 0) {
                // 0x80b230e
                if (v56 == *(int32_t *)(v42 + 0x1d14)) {
                    // break -> 0x80b2366
                    break;
                }
                // 0x80b231c
                v59 = v42 + 0x1d18 + 72 * v57;
                v61 = 0;
                while (v58 > v61 + 1) {
                    // 0x80b2339
                    v61++;
                    // 0x80b2330
                    v60 = v59;
                    v59 = v60 + 4;
                    v55 = v57;
                    if (v56 == *(int32_t *)v60) {
                        // break (via goto) -> 0x80b2366
                        goto lab_0x80b2366;
                    }
                }
            }
            int32_t v62 = v57 + 1; // 0x80b2340
            int32_t v63 = v42 + 72; // 0x80b235a
            v55 = v62;
            while (v54 > v62) {
                int32_t v64 = v63;
                v57 = v62;
                v58 = *(int32_t *)(v42 + 0x1cd4 + 4 * v57);
                if (v58 != 0) {
                    // 0x80b230e
                    v55 = v57;
                    if (v56 == *(int32_t *)(v64 + 0x1d14)) {
                        // break -> 0x80b2366
                        break;
                    }
                    // 0x80b231c
                    v59 = v42 + 0x1d18 + 72 * v57;
                    v61 = 0;
                    while (v58 > v61 + 1) {
                        // 0x80b2339
                        v61++;
                        // 0x80b2330
                        v60 = v59;
                        v59 = v60 + 4;
                        v55 = v57;
                        if (v56 == *(int32_t *)v60) {
                            // break (via goto) -> 0x80b2366
                            goto lab_0x80b2366;
                        }
                    }
                }
                // 0x80b2340
                v62 = v57 + 1;
                v63 = v64 + 72;
                v55 = v62;
            }
        }
      lab_0x80b2366:
        // 0x80b2366
        if (v55 != v7) {
            // 0x80b2081
            *(int32_t *)(v3 + 52) = 0;
            return result;
        }
    }
    int32_t v65 = r_search(*(int32_t *)(v3 + 52), v35, 0, 0x80b43c0, (char *)&v33); // 0x80b23a5
    // 0x80b2081
    *(int32_t *)(v3 + 52) = 0;
    return v65 + result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon.c
// Address range: 0x80b24a0 - 0x80b290b
// Line range:    1383 - 1472
int32_t PlowsPolygon(int32_t Data, int32_t type, char * ptr1, char * ptr2, int32_t call_back) {
    int32_t v1 = (int32_t)ptr2;
    int32_t v2 = (int32_t)ptr1;
    int32_t v3 = *(int32_t *)ptr2; // bp-44, 0x80b24c3
    int32_t v4 = type; // bp-68, 0x80b24db
    int32_t result; // 0x80b24a0
    if (type == 16) {
        goto lab_0x80b2610;
    } else {
        if (type > 16) {
            switch (type) {
                case 512: {
                    int32_t v5 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24); // 0x80b27d0
                    int32_t v6 = GetLayerGroupNumberByNumber((*(int32_t *)(v1 + 20) / 128 % 2 ^ 1) + v5); // 0x80b27d6
                    int32_t * v7 = (int32_t *)(Data + 72); // 0x80b27db
                    int32_t v8 = *v7; // 0x80b27db
                    int32_t v9 = 4 * v6; // 0x80b27de
                    int32_t v10 = v9 + 0x1cd4;
                    if (*(int32_t *)(v10 + v8) == 0) {
                        // 0x80b25ff
                        return 0;
                    }
                    int32_t v11 = &v3;
                    int32_t v12 = 0;
                    int32_t v13 = v8 + 4; // 0x80b2821
                    int32_t * v14 = (int32_t *)(v9 + 0x1cd0 + v13);
                    int32_t v15 = 0;
                    uint32_t v16 = *(int32_t *)(4 * (18 * v6 + 1860 + v15) + v13); // 0x80b2821
                    int32_t v17; // 0x80b280b
                    while (v16 >= *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24)) {
                        // 0x80b2808
                        v17 = v15 + 1;
                        result = v12;
                        if (*v14 <= v17) {
                            return result;
                        }
                        v15 = v17;
                        v16 = *(int32_t *)(4 * (18 * v6 + 1860 + v15) + v13);
                    }
                    int32_t v18 = v15 + 1; // 0x80b2833
                    int32_t v19 = *(int32_t *)(Data + 136 + 92 * v16); // 0x80b285b
                    int32_t v20 = r_search(v19, v11, 0, 0x80b0bd0, (char *)&v4); // 0x80b2865
                    int32_t v21 = *v7; // 0x80b286a
                    int32_t result2 = v20 + v12; // 0x80b286d
                    while (*(int32_t *)(v21 + v10) > v18) {
                        // 0x80b2814
                        v12 = result2;
                        v13 = v21 + 4;
                        v14 = (int32_t *)(v9 + 0x1cd0 + v13);
                        v15 = v18;
                        v16 = *(int32_t *)(4 * (18 * v6 + 1860 + v15) + v13);
                        while (v16 >= *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24)) {
                            // 0x80b2808
                            v17 = v15 + 1;
                            result = v12;
                            if (*v14 <= v17) {
                                return result;
                            }
                            v15 = v17;
                            v16 = *(int32_t *)(4 * (18 * v6 + 1860 + v15) + v13);
                        }
                        // 0x80b2830
                        v18 = v15 + 1;
                        v19 = *(int32_t *)(Data + 136 + 92 * v16);
                        v20 = r_search(v19, v11, 0, 0x80b0bd0, (char *)&v4);
                        v21 = *v7;
                        result2 = v20 + v12;
                    }
                    // 0x80b25ff
                    return result2;
                }
                case 0x4000: {
                    goto lab_0x80b2610;
                }
                default: {
                    // 0x80b2506
                    if (type != 256) {
                        // 0x80b25ff
                        return 0;
                    }
                    goto lab_0x80b2516;
                }
            }
        } else {
            // 0x80b25e8
            result = 0;
            switch (type) {
                case 2: {
                    int32_t * v22 = (int32_t *)(v2 + 224); // 0x80b26e8
                    int32_t v23 = *v22; // 0x80b26e8
                    if (v23 != 0) {
                        int32_t v24 = v23; // 0x80b24a0
                        int32_t v25 = 0; // 0x80b2704
                        PlowsPolygon(Data, 256, ptr1, (char *)(76 * v25 + *(int32_t *)(v2 + 256)), call_back);
                        uint32_t v26 = *v22; // 0x80b2737
                        while (v26 != 0) {
                            // 0x80b2700
                            v25 = 1 - v24 + v25 + v26;
                            v24 = v26;
                            if (v26 <= v25) {
                                // break -> 0x80b2747
                                break;
                            }
                            PlowsPolygon(Data, 256, ptr1, (char *)(76 * v25 + *(int32_t *)(v2 + 256)), call_back);
                            v26 = *v22;
                        }
                    }
                    int32_t * v27 = (int32_t *)(v2 + 232); // 0x80b2747
                    int32_t v28 = *v27; // 0x80b2747
                    int32_t v29 = 0; // 0x80b2759
                    while (true) {
                        // 0x80b275c
                        result = 0;
                        if (v28 <= v29) {
                            return result;
                        }
                        int32_t v30 = *(int32_t *)(v2 + 260); // 0x80b2780
                        PlowsPolygon(Data, 512, ptr1, (char *)(v30 + 104 * v29), call_back);
                        int32_t v31 = *v27; // 0x80b27a0
                        while (v31 != v28) {
                            // 0x80b2768
                            result = 0;
                            if (v31 <= v29) {
                                return result;
                            }
                            // 0x80b2779
                            v30 = *(int32_t *)(v2 + 260);
                            PlowsPolygon(Data, 512, ptr1, (char *)(v30 + 104 * v29), call_back);
                            v31 = *v27;
                        }
                        // 0x80b27ab
                        v29++;
                    }
                }
                case 4: {
                    goto lab_0x80b2610;
                }
                case 1: {
                    goto lab_0x80b2516;
                }
                default: {
                    return result;
                }
            }
        }
    }
  lab_0x80b2610:
    // 0x80b2610
    if ((*(char *)(v1 + 20) & 32) == 0) {
        // 0x80b25ff
        return 0;
    }
    uint32_t v32 = GetLayerNumber(Data, v2); // 0x80b261d
    if (v32 >= *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24)) {
        // 0x80b25ff
        return 0;
    }
    int32_t * v33 = (int32_t *)(Data + 72); // 0x80b2646
    if (*(int32_t *)(*v33 + 0x1cd4 + 4 * GetLayerGroupNumberByNumber(GetLayerNumber(Data, v2))) == 0) {
        // 0x80b25ff
        return 0;
    }
    int32_t v34 = &v3;
    int32_t v35 = 0; // 0x80b24a0
    int32_t v36 = 0;
    int32_t v37 = GetLayerGroupNumberByNumber(GetLayerNumber(Data, v2)); // 0x80b267f
    uint32_t v38 = *(int32_t *)(*v33 + 4 + 4 * (v35 + 1860 + 18 * v37)); // 0x80b269a
    int32_t result3 = v36; // 0x80b26a1
    int32_t v39; // 0x80b26cb
    int32_t v40; // 0x80b26d5
    if (v38 < *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24)) {
        // 0x80b26a3
        v39 = *(int32_t *)(Data + 136 + 92 * v38);
        v40 = r_search(v39, v34, 0, 0x80b0bd0, (char *)&v4);
        result3 = v40 + v36;
    }
    int32_t v41 = v35 + 1; // 0x80b2640
    uint32_t v42 = *(int32_t *)(*v33 + 0x1cd4 + 4 * GetLayerGroupNumberByNumber(GetLayerNumber(Data, v2))); // 0x80b265d
    v35 = v41;
    while (v41 < v42) {
        // 0x80b266a
        v36 = result3;
        v37 = GetLayerGroupNumberByNumber(GetLayerNumber(Data, v2));
        v38 = *(int32_t *)(*v33 + 4 + 4 * (v35 + 1860 + 18 * v37));
        result3 = v36;
        if (v38 < *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24)) {
            // 0x80b26a3
            v39 = *(int32_t *)(Data + 136 + 92 * v38);
            v40 = r_search(v39, v34, 0, 0x80b0bd0, (char *)&v4);
            result3 = v40 + v36;
        }
        // 0x80b2640
        v41 = v35 + 1;
        v42 = *(int32_t *)(*v33 + 0x1cd4 + 4 * GetLayerGroupNumberByNumber(GetLayerNumber(Data, v2)));
        v35 = v41;
    }
    // 0x80b25ff
    return result3;
  lab_0x80b2516:
    if (ptr1 == NULL || type == 256 || ptr1 == ptr2) {
        // 0x80b2890
        if (*(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24) == 0) {
            // 0x80b25ff
            return 0;
        }
        int32_t v43 = &v3; // 0x80b28da
        int32_t v44 = Data; // 0x80b24a0
        int32_t v45 = 0; // 0x80b28b6
        int32_t result4 = 0; // 0x80b28ef
        v45++;
        int32_t v46 = *(int32_t *)(v44 + 136); // 0x80b28de
        result4 += r_search(v46, v43, 0, 0x80b0bd0, (char *)&v4);
        v44 += 92;
        while (*(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24) > v45) {
            // 0x80b28b0
            v45++;
            v46 = *(int32_t *)(v44 + 136);
            result4 += r_search(v46, v43, 0, 0x80b0bd0, (char *)&v4);
            v44 += 92;
        }
        // 0x80b25ff
        return result4;
    }
    int32_t * v47 = (int32_t *)(Data + 72); // 0x80b2546
    if (*(int32_t *)(*v47 + 0x1cd4 + 4 * GetLayerGroupNumberByNumber(GetLayerNumber(Data, v2))) == 0) {
        // 0x80b25ff
        return 0;
    }
    int32_t v48 = &v3;
    int32_t v49 = 0; // 0x80b24a0
    int32_t v50 = 0;
    int32_t v51 = GetLayerGroupNumberByNumber(GetLayerNumber(Data, v2)); // 0x80b257f
    uint32_t v52 = *(int32_t *)(*v47 + 4 + 4 * (v49 + 1860 + 18 * v51)); // 0x80b259a
    int32_t v53 = v50; // 0x80b25a1
    int32_t v54; // 0x80b25cb
    int32_t v55; // 0x80b25d5
    if (v52 < *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24)) {
        // 0x80b25a3
        v54 = *(int32_t *)(Data + 136 + 92 * v52);
        v55 = r_search(v54, v48, 0, 0x80b0bd0, (char *)&v4);
        v53 = v55 + v50;
    }
    int32_t v56 = v49 + 1; // 0x80b2540
    uint32_t v57 = *(int32_t *)(*v47 + 0x1cd4 + 4 * GetLayerGroupNumberByNumber(GetLayerNumber(Data, v2))); // 0x80b255d
    v49 = v56;
    result = v53;
    while (v56 < v57) {
        // 0x80b256a
        v50 = v53;
        v51 = GetLayerGroupNumberByNumber(GetLayerNumber(Data, v2));
        v52 = *(int32_t *)(*v47 + 4 + 4 * (v49 + 1860 + 18 * v51));
        v53 = v50;
        if (v52 < *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24)) {
            // 0x80b25a3
            v54 = *(int32_t *)(Data + 136 + 92 * v52);
            v55 = r_search(v54, v48, 0, 0x80b0bd0, (char *)&v4);
            v53 = v55 + v50;
        }
        // 0x80b2540
        v56 = v49 + 1;
        v57 = *(int32_t *)(*v47 + 0x1cd4 + 4 * GetLayerGroupNumberByNumber(GetLayerNumber(Data, v2)));
        v49 = v56;
        result = v53;
    }
  lab_0x80b25ff_2:
    // 0x80b25ff
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon.c
// Address range: 0x80b2aa0 - 0x80b2b2f
// Line range:    1054 - 1070
int32_t InitClip(int32_t Data, int32_t layer, int32_t p) {
    // 0x80b2aa0
    if (inhibit != 0) {
        // 0x80b2b00
        return 0;
    }
    int32_t v1 = p + 44; // 0x80b2ab3
    int32_t * v2 = (int32_t *)v1; // 0x80b2ab3
    if (*v2 != 0) {
        // 0x80b2aba
        poly_Free(v1);
    }
    // 0x80b2ac5
    *v2 = original_poly((int32_t)&g231);
    poly_FreeContours(p + 48);
    if (*v2 == 0) {
        // 0x80b2b00
        return 0;
    }
    // 0x80b2ae1
    if ((*(char *)(p + 20) & 16) != 0) {
        // 0x80b2b08
        clearPoly(0, 0, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231);
        return 1;
    }
    // 0x80b2ae7
    *(int32_t *)(p + 52) = 0;
    return 1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon.c
// Address range: 0x80b2b30 - 0x80b2b8e
// Line range:    1484 - 1487
void ClearFromPolygon(int32_t Data, int32_t type, char * ptr1, char * ptr2) {
    // 0x80b2b30
    if (type == 8) {
        // 0x80b2b70
        int32_t v1; // 0x80b2b30
        InitClip(v1, v1, *(int32_t *)(PCB + 0x220c));
        return;
    }
    // 0x80b2b48
    PlowsPolygon(Data, type, ptr1, ptr2, 0x80b4680);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon.c
// Address range: 0x80b2b90 - 0x80b2bee
// Line range:    1475 - 1478
void RestoreToPolygon(int32_t Data, int32_t type, char * ptr1, char * ptr2) {
    // 0x80b2b90
    if (type == 8) {
        // 0x80b2bd0
        int32_t v1; // 0x80b2b90
        InitClip(v1, v1, *(int32_t *)(PCB + 0x220c));
        return;
    }
    // 0x80b2ba8
    PlowsPolygon(Data, type, ptr1, ptr2, 0x80b23e0);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b4b60 - 0x80b4baa
// Line range:    2160 - 2182
int32_t poly_InclContour(int32_t p, int32_t c) {
    if (p == 0 || c == 0) {
        // 0x80b4b97
        return 0;
    }
    int32_t * v1 = (int32_t *)(p + 8);
    int32_t v2 = *v1;
    if ((*(char *)(c + 68) & 8) != 0) {
        if (v2 != 0) {
            // 0x80b4b97
            return 0;
        }
        // 0x80b4ba0
        *v1 = c;
        return 1;
    }
    if (v2 == 0) {
        // 0x80b4b97
        return 0;
    }
    int32_t * v3 = (int32_t *)(v2 + 16); // 0x80b4b7e
    *v3 = c;
    *(int32_t *)(c + 16) = *v3;
    return 1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b5530 - 0x80b55c9
// Line range:    2042 - 2063
void poly_InclVertex(int32_t after, int32_t node) {
    int32_t * v1 = (int32_t *)after; // 0x80b5545
    int32_t * v2 = (int32_t *)(node + 4); // 0x80b5547
    *v2 = after;
    *(int32_t *)node = *v1;
    *v1 = node;
    *(int32_t *)(*v1 + 4) = node;
    int32_t v3 = *v2; // 0x80b5553
    int32_t v4 = *(int32_t *)(v3 + 4); // 0x80b5556
    if (v4 == node) {
        // 0x80b55a3
        return;
    }
    int32_t v5 = *(int32_t *)(v4 + 28); // 0x80b555d
    int32_t v6 = *(int32_t *)(v4 + 24); // 0x80b5568
    int3_t v7; // 0x80b5530
    int3_t v8 = v7 - 1; // 0x80b556e
    __frontend_reg_store_fpr(v8, (float80_t)(*(int32_t *)(node + 28) - v5));
    int3_t v9 = v7 - 2; // 0x80b5579
    __frontend_reg_store_fpr(v9, (float80_t)(*(int32_t *)(node + 24) - v6));
    int3_t v10 = v7 - 3; // 0x80b5584
    __frontend_reg_store_fpr(v10, (float80_t)(*(int32_t *)(v3 + 24) - v6));
    __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v10) * __frontend_reg_load_fpr(v8));
    __frontend_reg_store_fpr(v10, (float80_t)(*(int32_t *)(v3 + 28) - v5));
    __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v10) * __frontend_reg_load_fpr(v9));
    __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v8) - __frontend_reg_load_fpr(v9));
    __frontend_reg_store_fpr(v8, fabsl(__frontend_reg_load_fpr(v8)));
    __frontend_reg_store_fpr(v9, 1.0e-8L);
    float80_t v11 = __frontend_reg_load_fpr(v9); // 0x80b559d
    float80_t v12 = __frontend_reg_load_fpr(v8); // 0x80b559d
    bool v13 = false; // 0x80b559d
    bool v14 = false; // 0x80b559d
    if (v11 <= v12) {
        v13 = false;
        v14 = true;
        if (v11 >= v12) {
            v13 = true;
            v14 = v11 != v12;
        }
    }
    __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v8));
    if (v13 || v14) {
        // 0x80b55a3
        return;
    }
    // 0x80b55b0
    *(int32_t *)v4 = node;
    *v2 = v4;
    free((int32_t *)v3);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b55d0 - 0x80b5606
// Line range:    2029 - 2039
void poly_ExclVertex(int32_t node) {
    int32_t v1 = *(int32_t *)(node + 20); // 0x80b55da
    if (v1 != 0) {
        // 0x80b55e1
        free((int32_t *)v1);
        free((int32_t *)*(int32_t *)(node + 16));
    }
    int32_t v2 = *(int32_t *)(node + 4); // 0x80b55f4
    int32_t * v3 = (int32_t *)node; // 0x80b55f7
    *(int32_t *)v2 = *v3;
    *(int32_t *)(*v3 + 4) = v2;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b5670 - 0x80b5694
// Line range:    2308 - 2315
int32_t poly_Create(void) {
    int32_t * mem = malloc(12); // 0x80b567d
    int32_t result = (int32_t)mem; // 0x80b567d
    if (mem != NULL) {
        // 0x80b5686
        *(int32_t *)(result + 4) = result;
        *mem = result;
        *(int32_t *)(result + 8) = 0;
    }
    // 0x80b5692
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b5bf0 - 0x80b5c60
// Line range:    2005 - 2026
void poly_InvContour(int32_t c) {
    int32_t v1 = c + 20; // 0x80b5bfb
    int32_t * v2 = (int32_t *)v1; // 0x80b5c00
    int32_t v3 = *v2; // 0x80b5c00
    int32_t * v4 = (int32_t *)(v1 + 4); // 0x80b5c02
    *v2 = *v4;
    *v4 = v3;
    while (v1 != v3) {
        int32_t v5 = v3;
        v2 = (int32_t *)v5;
        v3 = *v2;
        v4 = (int32_t *)(v5 + 4);
        *v2 = *v4;
        *v4 = v3;
    }
    char * v6 = (char *)(c + 68); // 0x80b5c10
    int32_t v7 = *(int32_t *)(c + 64); // 0x80b5c27
    *v6 = *v6 ^ 8;
    if (v7 != 0) {
        // 0x80b5c31
        r_search(v7, 0, 0, 0x80b4b00, NULL);
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b5d80 - 0x80b5dec
// Line range:    1878 - 1895
int32_t poly_NewContour(int32_t * v) {
    int32_t * mem = calloc(1, 72); // 0x80b5d99
    int32_t result = (int32_t)mem; // 0x80b5d99
    if (mem == NULL) {
        // 0x80b5de6
        return result;
    }
    int32_t v1 = result + 20; // 0x80b5da2
    *(int32_t *)(result + 24) = v1;
    *(int32_t *)v1 = v1;
    int32_t * v2 = (int32_t *)(result + 4); // 0x80b5dad
    *v2 = 0x7fffffff;
    *mem = 0x7fffffff;
    int32_t * v3 = (int32_t *)(result + 12); // 0x80b5dba
    *v3 = -0x80000000;
    int32_t * v4 = (int32_t *)(result + 8); // 0x80b5dc1
    *v4 = -0x80000000;
    if (v != NULL) {
        int32_t v5 = *v; // 0x80b5dca
        *(int32_t *)(result + 44) = v5;
        int32_t v6 = *(int32_t *)((int32_t)v + 4); // 0x80b5dcf
        *mem = v5;
        *v4 = v5 + 1;
        *(int32_t *)(result + 48) = v6;
        *v2 = v6;
        *v3 = v6 + 1;
    }
    // 0x80b5de6
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b5df0 - 0x80b5e23
// Line range:    1850 - 1864
int32_t poly_CreateNode(int32_t * v) {
    int32_t * mem = calloc(1, 32); // 0x80b5e09
    int32_t result = (int32_t)mem; // 0x80b5e09
    if (mem != NULL) {
        // 0x80b5e12
        *(int32_t *)(result + 24) = *v;
        *(int32_t *)(result + 28) = *(int32_t *)((int32_t)v + 4);
    }
    // 0x80b5e1d
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b5ec0 - 0x80b5f7a
// Line range:    665 - 700
char * make_edge_tree(int32_t pb) {
    int32_t v1 = r_create_tree(0, 0, 0); // 0x80b5ee2
    int32_t v2; // 0x80b5ec0
    int32_t v3 = v2 + 20; // 0x80b5ee9
    int32_t v4 = v3; // 0x80b5ef1
    int32_t * v5; // 0x80b5ec0
    int32_t * v6; // 0x80b5ec0
    int32_t v7; // 0x80b5ec0
    int32_t v8; // 0x80b5ec0
    int32_t v9; // 0x80b5ec0
    int32_t v10; // 0x80b5f3f
    int32_t * v11; // 0x80b5f44
    while (true) {
      lab_0x80b5f38:
        // 0x80b5f38
        v7 = v4;
        int32_t * mem = malloc(24); // 0x80b5f3f
        v10 = (int32_t)mem;
        v11 = (int32_t *)v7;
        int32_t v12 = *v11; // 0x80b5f44
        int32_t v13 = *(int32_t *)(v7 + 24); // 0x80b5f46
        int32_t * v14 = (int32_t *)(v12 + 24); // 0x80b5f49
        if (v13 < *v14) {
            // 0x80b5ef8
            *mem = v13;
            *(int32_t *)(v10 + 8) = *v14 + 1;
            int32_t v15 = *(int32_t *)(v7 + 28); // 0x80b5f03
            int32_t * v16 = (int32_t *)(v12 + 28);
            v5 = v16;
            v8 = v15;
            v6 = v16;
            v9 = v15;
            if (v15 < *v16) {
                goto lab_0x80b5f0b;
            } else {
                goto lab_0x80b5f61;
            }
        } else {
            // 0x80b5f4e
            *(int32_t *)(v10 + 8) = v13 + 1;
            *mem = *v14;
            int32_t v17 = *(int32_t *)(v7 + 28); // 0x80b5f59
            int32_t * v18 = (int32_t *)(v12 + 28);
            v5 = v18;
            v8 = v17;
            v6 = v18;
            v9 = v17;
            if (v17 < *v18) {
                goto lab_0x80b5f0b;
            } else {
                goto lab_0x80b5f61;
            }
        }
    }
  lab_0x80b5f70:
    // 0x80b5f70
    return (char *)v1;
  lab_0x80b5f0b:
    // 0x80b5f0b
    *(int32_t *)(v10 + 4) = v8;
    *(int32_t *)(v10 + 12) = *v5 + 1;
    goto lab_0x80b5f17;
  lab_0x80b5f61:
    // 0x80b5f61
    *(int32_t *)(v10 + 12) = v9 + 1;
    *(int32_t *)(v10 + 4) = *v6;
    goto lab_0x80b5f17;
  lab_0x80b5f17:
    // 0x80b5f17
    *(int32_t *)(v10 + 16) = v7;
    r_insert_entry(v1, v10, 1);
    v4 = *v11;
    if (v3 == v4) {
        // break -> 0x80b5f70
        goto lab_0x80b5f70;
    }
    goto lab_0x80b5f38;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b6190 - 0x80b632e
// Line range:    1943 - 1977
void poly_PreContour(int32_t C, int32_t optimize) {
    int32_t v1 = C + 20; // 0x80b619f
    int3_t v2; // 0x80b6190
    if (optimize != 0) {
        int32_t v3 = *(int32_t *)v1; // 0x80b61ad
        if (v1 != v3) {
            int3_t v4 = v2 - 1; // 0x80b61ba
            __frontend_reg_store_fpr(v4, 0.0L);
            int3_t v5 = v2 - 2; // 0x80b61e4
            int3_t v6 = v2 - 3;
            int3_t v7 = v2 ^ -4;
            int32_t v8 = v3; // 0x80b61bf
            int32_t v9 = v1; // 0x80b61bf
            while (true) {
                int32_t v10 = v9;
                int32_t v11 = v8;
                int32_t v12 = *(int32_t *)(v11 + 24); // 0x80b61d1
                int32_t * v13 = (int32_t *)v11; // 0x80b61d4
                int32_t v14 = *v13; // 0x80b61d4
                int32_t v15 = *(int32_t *)(v11 + 28); // 0x80b61d6
                __frontend_reg_store_fpr(v5, (float80_t)(v12 - *(int32_t *)(v10 + 24)));
                __frontend_reg_store_fpr(v6, (float80_t)(*(int32_t *)(v14 + 28) - v15));
                __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v6) * __frontend_reg_load_fpr(v5));
                __frontend_reg_store_fpr(v6, (float80_t)(*(int32_t *)(v14 + 24) - v12));
                __frontend_reg_store_fpr(v7, (float80_t)(v15 - *(int32_t *)(v10 + 28)));
                __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v7) * __frontend_reg_load_fpr(v6));
                __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v5) - __frontend_reg_load_fpr(v6));
                int32_t v16; // 0x80b6190
                int32_t v17; // 0x80b6190
                if (__frontend_reg_load_fpr(v5) != __frontend_reg_load_fpr(v4)) {
                    // 0x80b61c8
                    v16 = v14;
                    v17 = v11;
                    if (v1 == v14) {
                        // break -> 0x80b6238
                        break;
                    }
                } else {
                    float80_t v18 = __frontend_reg_load_fpr(v4); // 0x80b620f
                    poly_ExclVertex(v11);
                    free(v13);
                    int32_t v19 = *(int32_t *)v10; // 0x80b6224
                    __frontend_reg_store_fpr(v4, v18);
                    v16 = v19;
                    v17 = v10;
                    if (v1 == v19) {
                        // 0x80b6230
                        __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v4));
                        goto lab_0x80b623d;
                    }
                }
                // 0x80b61cf
                v8 = v16;
                v9 = v17;
            }
            // 0x80b6238
            __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v4));
        }
    }
    goto lab_0x80b623d;
  lab_0x80b623d:;
    int32_t v20 = *(int32_t *)(C + 44); // 0x80b623d
    int32_t v21 = *(int32_t *)(C + 48); // 0x80b6240
    int32_t v22 = *(int32_t *)(C + 24); // 0x80b6243
    int32_t * v23 = (int32_t *)(C + 52); // 0x80b6249
    *v23 = 0;
    int32_t * v24 = (int32_t *)(C + 8); // 0x80b6250
    *v24 = v20;
    int32_t * v25 = (int32_t *)C; // 0x80b6253
    *v25 = v20;
    int32_t * v26 = (int32_t *)(C + 12); // 0x80b6255
    *v26 = v21;
    int32_t * v27 = (int32_t *)(C + 4); // 0x80b6258
    *v27 = v21;
    int3_t v28 = v2 - 1;
    __frontend_reg_store_fpr(v28, 0.0L);
    char v29 = 0; // 0x80b625e
    if (v1 != v22) {
        int3_t v30 = v2 - 2; // 0x80b6292
        int3_t v31 = v2 - 3;
        int32_t v32 = v20;
        int32_t v33 = v21;
        int32_t v34 = v20;
        int32_t v35 = v21;
        int32_t * v36 = (int32_t *)(v1 + 24); // 0x80b627a
        int32_t v37 = *v36; // 0x80b627a
        int32_t * v38 = (int32_t *)(v1 + 28); // 0x80b628f
        __frontend_reg_store_fpr(v30, (float80_t)(*(int32_t *)(v22 + 24) - v37));
        int32_t v39 = v34 - v37; // 0x80b62a1
        int32_t v40 = v39 == 0 | v39 < 0 != ((v39 ^ v34) & (v37 ^ v34)) < 0 ? v34 : v37; // 0x80b62a4
        __frontend_reg_store_fpr(v31, (float80_t)(*(int32_t *)(v22 + 28) + *v38));
        __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v31) * __frontend_reg_load_fpr(v30));
        *v25 = v40;
        __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v30) + __frontend_reg_load_fpr(v28));
        int32_t v41 = *v36 + 1; // 0x80b62b7
        int32_t v42 = v41 - v32; // 0x80b62ba
        int32_t v43 = v42 < 0 == ((v42 ^ v41) & (v41 ^ v32)) < 0 ? v41 : v32; // 0x80b62bc
        *v24 = v43;
        int32_t v44 = *v38; // 0x80b62c2
        int32_t v45 = v44 - v33; // 0x80b62c2
        int32_t v46 = v45 == 0 | v45 < 0 != ((v45 ^ v44) & (v44 ^ v33)) < 0 ? v44 : v33; // 0x80b62c5
        *v27 = v46;
        int32_t v47 = *v38 + 1; // 0x80b62cf
        int32_t v48 = v47 - v35; // 0x80b62d2
        int32_t v49 = v48 < 0 == ((v48 ^ v47) & (v47 ^ v35)) < 0 ? v47 : v35; // 0x80b62d5
        *v23 = *v23 + 1;
        *v26 = v49;
        int32_t v50 = *(int32_t *)v1; // 0x80b62e3
        int32_t v51 = v1; // 0x80b62e8
        while (v1 != v50) {
            // 0x80b627a
            v32 = v43;
            v33 = v46;
            int32_t v52 = v50;
            v34 = v40;
            v35 = v49;
            v36 = (int32_t *)(v52 + 24);
            v37 = *v36;
            int32_t v53 = *(int32_t *)(v51 + 24); // 0x80b6283
            v38 = (int32_t *)(v52 + 28);
            __frontend_reg_store_fpr(v30, (float80_t)(v53 - v37));
            int32_t v54 = *(int32_t *)(v51 + 28); // 0x80b6298
            v39 = v34 - v37;
            v40 = v39 == 0 | v39 < 0 != ((v39 ^ v34) & (v37 ^ v34)) < 0 ? v34 : v37;
            __frontend_reg_store_fpr(v31, (float80_t)(v54 + *v38));
            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v31) * __frontend_reg_load_fpr(v30));
            *v25 = v40;
            __frontend_reg_store_fpr(v28, __frontend_reg_load_fpr(v30) + __frontend_reg_load_fpr(v28));
            v41 = *v36 + 1;
            v42 = v41 - v32;
            v43 = v42 < 0 == ((v42 ^ v41) & (v41 ^ v32)) < 0 ? v41 : v32;
            *v24 = v43;
            v44 = *v38;
            v45 = v44 - v33;
            v46 = v45 == 0 | v45 < 0 != ((v45 ^ v44) & (v44 ^ v33)) < 0 ? v44 : v33;
            *v27 = v46;
            v47 = *v38 + 1;
            v48 = v47 - v35;
            v49 = v48 < 0 == ((v48 ^ v47) & (v47 ^ v35)) < 0 ? v47 : v35;
            *v23 = *v23 + 1;
            *v26 = v49;
            v50 = *(int32_t *)v52;
            v51 = v52;
        }
        // 0x80b62ea
        __frontend_reg_store_fpr(v30, 0.0L);
        float80_t v55 = __frontend_reg_load_fpr(v30); // 0x80b62ec
        v29 = 0;
        if (v55 > __frontend_reg_load_fpr(v28)) {
            // 0x80b62f3
            __frontend_reg_store_fpr(v28, -__frontend_reg_load_fpr(v28));
            v29 = 8;
        }
    }
    // 0x80b62f5
    *(float64_t *)(C + 56) = (float64_t)__frontend_reg_load_fpr(v28);
    if (*v23 >= 3) {
        char * v56 = (char *)(C + 68); // 0x80b6308
        *v56 = (*v56 & -9 | v29) ^ 8;
    }
    // 0x80b6314
    *(int32_t *)(C + 64) = (int32_t)make_edge_tree((int32_t)&g231);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b6330 - 0x80b63cb
// Line range:    1912 - 1940
void poly_DelContour(int32_t c) {
    int32_t * v1 = (int32_t *)c; // 0x80b633c
    int32_t v2 = *v1; // 0x80b633c
    if (v2 == 0) {
        // 0x80b63c3
        return;
    }
    int32_t v3 = *(int32_t *)(v2 + 24); // 0x80b6346
    int32_t v4 = v2; // 0x80b634e
    if (v2 + 20 != v3) {
        int32_t v5 = *(int32_t *)(v3 + 20); // 0x80b6350
        int32_t v6 = *(int32_t *)(v3 + 4); // 0x80b6353
        if (v5 != 0) {
            // 0x80b635a
            free((int32_t *)v5);
            free((int32_t *)*(int32_t *)(v3 + 16));
        }
        // 0x80b636d
        free((int32_t *)v3);
        int32_t v7 = *v1; // 0x80b6377
        v4 = v7;
        while (v7 + 20 != v6) {
            int32_t v8 = v6;
            v5 = *(int32_t *)(v8 + 20);
            v6 = *(int32_t *)(v8 + 4);
            if (v5 != 0) {
                // 0x80b635a
                free((int32_t *)v5);
                free((int32_t *)*(int32_t *)(v8 + 16));
            }
            // 0x80b636d
            free((int32_t *)v8);
            v7 = *v1;
            v4 = v7;
        }
    }
    int32_t v9 = *(int32_t *)(v4 + 40); // 0x80b6380
    int32_t v10 = v4; // 0x80b6385
    if (v9 != 0) {
        // 0x80b6387
        free((int32_t *)v9);
        free((int32_t *)*(int32_t *)(*v1 + 36));
        v10 = *v1;
    }
    int32_t v11 = *(int32_t *)(v10 + 64); // 0x80b639e
    if (v11 == 0) {
        // 0x80b63b5
        free((int32_t *)v10);
        *v1 = 0;
        // 0x80b63c3
        return;
    }
    int32_t v12 = v11; // bp-32, 0x80b63ab
    r_destroy_tree((int32_t)&v12);
    // 0x80b63b5
    free((int32_t *)*v1);
    *v1 = 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b63d0 - 0x80b6405
// Line range:    2318 - 2327
void poly_FreeContours(int32_t pline) {
    int32_t * v1 = (int32_t *)pline; // 0x80b63db
    int32_t v2 = *v1; // 0x80b63db
    int32_t v3 = v2; // bp-16, 0x80b63df
    if (v2 == 0) {
        // 0x80b63fe
        return;
    }
    // 0x80b63e8
    *v1 = *(int32_t *)(v2 + 16);
    poly_DelContour((int32_t)&v3);
    int32_t v4 = *v1; // 0x80b63f5
    v3 = v4;
    while (v4 != 0) {
        // 0x80b63e8
        *v1 = *(int32_t *)(v4 + 16);
        poly_DelContour((int32_t)&v3);
        v4 = *v1;
        v3 = v4;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/polygon1.c
// Address range: 0x80b6410 - 0x80b647c
// Line range:    2330 - 2345
void poly_Free(int32_t p) {
    int32_t * v1 = (int32_t *)p; // 0x80b641b
    int32_t v2 = *v1; // 0x80b641b
    if (v2 == 0) {
        // 0x80b6475
        return;
    }
    int32_t v3 = *(int32_t *)v2; // 0x80b6421
    int32_t v4 = v3; // 0x80b6425
    if (v2 != v3) {
        poly_FreeContours(v3 + 8);
        int32_t * v5 = (int32_t *)v3; // 0x80b643d
        int32_t v6 = *v5; // 0x80b643d
        int32_t * v7 = (int32_t *)(v3 + 4); // 0x80b643f
        *(int32_t *)(v6 + 4) = *v7;
        *(int32_t *)*v7 = v6;
        free(v5);
        int32_t v8 = *v1; // 0x80b6452
        int32_t v9 = *(int32_t *)v8; // 0x80b6454
        v4 = v8;
        while (v8 != v9) {
            // 0x80b6432
            poly_FreeContours(v9 + 8);
            v5 = (int32_t *)v9;
            v6 = *v5;
            v7 = (int32_t *)(v9 + 4);
            *(int32_t *)(v6 + 4) = *v7;
            *(int32_t *)*v7 = v6;
            free(v5);
            v8 = *v1;
            v9 = *(int32_t *)v8;
            v4 = v8;
        }
    }
    // 0x80b645a
    poly_FreeContours(v4 + 8);
    free((int32_t *)*v1);
    *v1 = 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/puller.c
// Address range: 0x80bda50 - 0x80bda6c
// Line range:    2749 - 2749
void register_puller_action_list(void) {
    // 0x80bda50
    hid_register_actions((int32_t)&puller_action_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/remove.c
// Address range: 0x80c0d90 - 0x80c0dab
// Line range:    610 - 614
char * DestroyObject(int32_t Target, int32_t Type, char * Ptr1, char * Ptr2, char * Ptr3) {
    // 0x80c0d90
    DestroyTarget = Target;
    char * result = ObjectOperation((int32_t)&DestroyFunctions, (int32_t)&g231, (char *)&g231, (char *)&g231, (char *)&g231); // 0x80c0da6
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/remove.c
// Address range: 0x80c1de0 - 0x80c1e0b
// Line range:    118 - 122
void RemovePCB(int32_t Ptr) {
    // 0x80c1de0
    ClearUndoList(1);
    FreePCBMemory(Ptr);
    SaveFree((char *)Ptr);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/report.c
// Address range: 0x80c45d0 - 0x80c45ec
// Line range:    837 - 837
void register_report_action_list(void) {
    // 0x80c45d0
    hid_register_actions((int32_t)&report_action_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rotate.c
// Address range: 0x80c6110 - 0x80c6239
// Line range:    350 - 356
void RotateBoxLowLevel(int32_t Box, int32_t X, int32_t Y, unsigned char Number) {
    int32_t * v1 = (int32_t *)Box; // 0x80c6122
    int32_t v2 = *v1; // 0x80c6122
    int32_t * v3 = (int32_t *)(Box + 4); // 0x80c6124
    int32_t v4 = *v3; // 0x80c6124
    int32_t * v5 = (int32_t *)(Box + 8); // 0x80c6127
    int32_t v6 = *v5; // 0x80c6127
    int32_t * v7 = (int32_t *)(Box + 12); // 0x80c612a
    int32_t v8 = *v7; // 0x80c612a
    int32_t v9 = v2 - X; // 0x80c612f
    int32_t v10 = v4 - Y; // 0x80c6137
    int32_t v11 = v4; // 0x80c6110
    int32_t v12 = v8; // 0x80c6110
    int32_t v13 = v6; // 0x80c6110
    int32_t v14 = v2; // 0x80c6110
    switch (Number % 4) {
        case 2: {
            // 0x80c61e8
            v11 = Y - v10;
            v12 = 2 * Y - v8;
            v13 = 2 * X - v6;
            v14 = X - v9;
            // break -> 0x80c61b4
            break;
        }
        case 3: {
            // 0x80c6210
            v11 = v9 + Y;
            v12 = Y - X + v6;
            v13 = Y + X - v8;
            v14 = X - v10;
            // break -> 0x80c61b4
            break;
        }
        case 1: {
            // 0x80c61a8
            v11 = Y - v9;
            v12 = Y + X - v6;
            v13 = X - Y + v8;
            v14 = v10 + X;
            // break -> 0x80c61b4
            break;
        }
    }
    int32_t v15 = v14;
    int32_t v16 = v13;
    int32_t v17 = v12;
    int32_t v18 = v11;
    int32_t v19 = v15 - v16; // 0x80c61b4
    int32_t v20 = v19 == 0 | v19 < 0 != ((v19 ^ v15) & (v15 ^ v16)) < 0 ? v15 : v16; // 0x80c61b8
    int32_t v21 = v18 - v17; // 0x80c61bb
    *v1 = v20;
    int32_t v22 = v21 == 0 | v21 < 0 != ((v21 ^ v18) & (v17 ^ v18)) < 0 ? v18 : v17; // 0x80c61c1
    int32_t v23 = v19 < 0 == ((v19 ^ v15) & (v15 ^ v16)) < 0 ? v15 : v16; // 0x80c61c6
    int32_t v24 = v21 < 0 == ((v21 ^ v18) & (v17 ^ v18)) < 0 ? v18 : v17; // 0x80c61cb
    *v3 = v22;
    *v5 = v23;
    *v7 = v24;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rotate.c
// Address range: 0x80c64c0 - 0x80c6630
// Line range:    108 - 112
void RotateLineLowLevel(int32_t Line, int32_t X, int32_t Y, unsigned char Number) {
    int32_t * v1 = (int32_t *)(Line + 48); // 0x80c64d8
    int32_t v2 = *v1; // 0x80c64d8
    int32_t * v3 = (int32_t *)(Line + 44); // 0x80c64db
    int32_t v4 = *v3; // 0x80c64db
    int32_t v5 = v2 - Y; // 0x80c64e1
    int32_t v6 = v4 - X; // 0x80c64ec
    int32_t v7; // 0x80c64c0
    int32_t v8; // 0x80c64c0
    int32_t v9; // 0x80c64c0
    int32_t v10; // 0x80c64c0
    int32_t v11; // 0x80c64c0
    int32_t v12; // 0x80c64c0
    int32_t v13; // 0x80c64c0
    int32_t v14; // 0x80c64c0
    int32_t v15; // 0x80c64c0
    int32_t v16; // 0x80c64c0
    switch (Number % 4) {
        case 2: {
            int32_t * v17 = (int32_t *)(Line + 64); // 0x80c6598
            int32_t v18 = X - v6; // 0x80c659d
            int32_t v19 = Y - v5; // 0x80c65a1
            *v3 = v18;
            int32_t * v20 = (int32_t *)(Line + 68); // 0x80c65ac
            *v1 = v19;
            int32_t v21 = X - *v17 + X; // 0x80c65ba
            int32_t v22 = Y - *v20 + Y; // 0x80c65bd
            *v17 = v21;
            *v20 = v22;
            v15 = v19;
            v10 = v21;
            v12 = v22;
            v8 = v18;
            v16 = v19;
            v13 = v22;
            if (v18 != v21) {
                goto lab_0x80c657b;
            } else {
                goto lab_0x80c65d1;
            }
        }
        case 3: {
            int32_t * v23 = (int32_t *)(Line + 64); // 0x80c65f8
            int32_t v24 = X - v5; // 0x80c65fd
            int32_t v25 = v6 + Y; // 0x80c6600
            *v1 = v25;
            int32_t * v26 = (int32_t *)(Line + 68); // 0x80c660b
            *v3 = v24;
            int32_t v27 = Y - *v26 + X; // 0x80c6619
            int32_t v28 = *v23 - X + Y; // 0x80c661c
            *v23 = v27;
            *v26 = v28;
            v14 = v25;
            v9 = v27;
            v11 = v28;
            v7 = v24;
            goto lab_0x80c6576;
        }
        case 1: {
            int32_t v29 = Y - v6; // 0x80c6545
            *v1 = v29;
            int32_t * v30 = (int32_t *)(Line + 64);
            int32_t v31 = v5 + X; // 0x80c654f
            *v3 = v31;
            int32_t * v32 = (int32_t *)(Line + 68);
            int32_t v33 = *v32 - Y + X; // 0x80c6564
            int32_t v34 = X - *v30 + Y; // 0x80c6567
            *v30 = v33;
            *v32 = v34;
            v14 = v29;
            v9 = v33;
            v11 = v34;
            v7 = v31;
            goto lab_0x80c6576;
        }
        default: {
            // 0x80c6508
            v14 = v2;
            v9 = *(int32_t *)(Line + 64);
            v11 = *(int32_t *)(Line + 68);
            v7 = v4;
            goto lab_0x80c6576;
        }
    }
  lab_0x80c6576:
    // 0x80c6576
    v15 = v14;
    v10 = v9;
    v12 = v11;
    v8 = v7;
    v16 = v14;
    v13 = v11;
    if (v7 == v9) {
        goto lab_0x80c65d1;
    } else {
        goto lab_0x80c657b;
    }
  lab_0x80c657b:
    // 0x80c657b
    if (v15 == v12 == v8 > v10) {
        // 0x80c65ed
        *(int32_t *)(Line + 64) = v8;
        *v3 = v10;
    }
    // 0x80c6583
    SetLineBoundingBox(v15);
  lab_0x80c65d1:
    // 0x80c65d1
    if (v16 > v13) {
        // 0x80c65d9
        *v1 = v13;
        *(int32_t *)(Line + 68) = v16;
    }
    // 0x80c6583
    SetLineBoundingBox(v16);
    return;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c7130 - 0x80c71f1
// Line range:    406 - 438
void adjust_bounds(int32_t node) {
    // 0x80c7130
    int32_t v1; // 0x80c7130
    if (*(char *)(v1 + 20) % 2 == 0) {
        int32_t v2 = v1 + 24; // 0x80c7198
        int32_t v3 = *(int32_t *)v2; // 0x80c7198
        int32_t * v4 = (int32_t *)v1; // 0x80c71a0
        *v4 = *(int32_t *)v3;
        int32_t * v5 = (int32_t *)(v1 + 4); // 0x80c71a5
        *v5 = *(int32_t *)(v3 + 4);
        int32_t * v6 = (int32_t *)(v1 + 8); // 0x80c71ab
        *v6 = *(int32_t *)(v3 + 8);
        int32_t * v7 = (int32_t *)(v1 + 12); // 0x80c71b3
        *v7 = *(int32_t *)(v3 + 12);
        int32_t v8; // 0x80c7130
        int32_t v9 = *(int32_t *)(v8 + 28); // 0x80c71b6
        while (v9 != 0) {
            int32_t v10 = *(int32_t *)v9; // 0x80c71bd
            if (v10 < v1) {
                // 0x80c71c3
                *v4 = v10;
            }
            int32_t v11 = *(int32_t *)(v9 + 8); // 0x80c71c5
            if (v11 > *v6) {
                // 0x80c71cd
                *v6 = v11;
            }
            int32_t v12 = *(int32_t *)(v9 + 4); // 0x80c71d0
            if (v12 < *v5) {
                // 0x80c71d8
                *v5 = v12;
            }
            int32_t v13 = *(int32_t *)(v9 + 12); // 0x80c71db
            if (v13 > *v7) {
                // 0x80c71e3
                *v7 = v13;
            }
            int32_t v14 = v8 + 4; // 0x80c71e6
            v8 = v14;
            if (v14 == v2) {
                // break -> 0x80c718f
                break;
            }
            v9 = *(int32_t *)(v8 + 28);
        }
    } else {
        int32_t * v15 = (int32_t *)v1; // 0x80c7141
        *v15 = *(int32_t *)(v1 + 28);
        int32_t * v16 = (int32_t *)(v1 + 4); // 0x80c7146
        *v16 = *(int32_t *)(v1 + 32);
        int32_t * v17 = (int32_t *)(v1 + 8); // 0x80c714c
        *v17 = *(int32_t *)(v1 + 36);
        int32_t * v18 = (int32_t *)(v1 + 12); // 0x80c7152
        *v18 = *(int32_t *)(v1 + 40);
        int32_t v19; // 0x80c7130
        int32_t v20 = v19;
        while (*(int32_t *)(v20 + 44) != 0) {
            int32_t v21 = *(int32_t *)(v20 + 48); // 0x80c715e
            if (v21 < v1) {
                // 0x80c7165
                *v15 = v21;
            }
            int32_t v22 = *(int32_t *)(v20 + 56); // 0x80c7167
            if (v22 > *v17) {
                // 0x80c716f
                *v17 = v22;
            }
            int32_t v23 = *(int32_t *)(v20 + 52); // 0x80c7172
            if (v23 < *v16) {
                // 0x80c717a
                *v16 = v23;
            }
            int32_t v24 = *(int32_t *)(v20 + 60); // 0x80c717d
            if (v24 > *v18) {
                // 0x80c7185
                *v18 = v24;
            }
            // 0x80c7188
            if (v20 == v1 + 100) {
                // break -> 0x80c718f
                break;
            }
            v20 += 20;
        }
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c7200 - 0x80c73e3
// Line range:    517 - 590
int32_t __r_search(int32_t node, int32_t query, int32_t arg) {
    // 0x80c7200
    if (*(char *)(node + 20) % 2 != 0) {
        int32_t v1 = *(int32_t *)(node + 24);
        if (*(int32_t *)(arg + 4) == 0) {
            // 0x80c7318
            if (v1 == 0) {
                // 0x80c726a
                return 0;
            }
            int32_t v2 = 0;
            int32_t v3 = node;
            int32_t v4 = v2; // 0x80c732b
            int32_t v5; // 0x80c733c
            int32_t v6; // 0x80c733f
            int32_t v7; // 0x80c733f
            if (*(int32_t *)(v3 + 28) < *(int32_t *)(query + 8)) {
                // 0x80c732d
                v4 = v2;
                if (*(int32_t *)(v3 + 36) > *(int32_t *)query) {
                    // 0x80c7334
                    v4 = v2;
                    if (*(int32_t *)(v3 + 32) < *(int32_t *)(query + 12)) {
                        // 0x80c733c
                        v5 = *(int32_t *)(v3 + 40);
                        v6 = *(int32_t *)(query + 4);
                        v7 = v5 - v6;
                        v4 = v2 + (int32_t)(v7 < 0 == ((v7 ^ v5) & (v6 ^ v5)) < 0 == (v7 != 0));
                    }
                }
            }
            int32_t result = v4;
            int32_t v8 = v3 + 20; // 0x80c7358
            while (*(int32_t *)(v3 + 44) != 0) {
                // 0x80c7328
                v2 = result;
                v3 = v8;
                v4 = v2;
                if (*(int32_t *)(v3 + 28) < *(int32_t *)(query + 8)) {
                    // 0x80c732d
                    v4 = v2;
                    if (*(int32_t *)(v3 + 36) > *(int32_t *)query) {
                        // 0x80c7334
                        v4 = v2;
                        if (*(int32_t *)(v3 + 32) < *(int32_t *)(query + 12)) {
                            // 0x80c733c
                            v5 = *(int32_t *)(v3 + 40);
                            v6 = *(int32_t *)(query + 4);
                            v7 = v5 - v6;
                            v4 = v2 + (int32_t)(v7 < 0 == ((v7 ^ v5) & (v6 ^ v5)) < 0 == (v7 != 0));
                        }
                    }
                }
                // 0x80c7350
                result = v4;
                v8 = v3 + 20;
            }
            // 0x80c726a
            return result;
        }
        // 0x80c7223
        if (v1 == 0) {
            // 0x80c726a
            return 0;
        }
        int32_t v9 = 0;
        int32_t v10 = v9; // 0x80c723e
        if (*(int32_t *)(node + 28) < *(int32_t *)(query + 8)) {
            // 0x80c7240
            v10 = v9;
            if (*(int32_t *)(node + 36) > *(int32_t *)query) {
                // 0x80c7247
                v10 = v9;
                if (*(int32_t *)(node + 32) < *(int32_t *)(query + 12)) {
                    // 0x80c724f
                    v10 = v9;
                    if (*(int32_t *)(node + 40) > *(int32_t *)(query + 4)) {
                        // 0x80c73a8
                        v10 = v9 + (int32_t)(v1 != 0);
                    }
                }
            }
        }
        int32_t result2 = v10;
        int32_t v11 = *(int32_t *)(node + 44); // 0x80c7260
        int32_t v12 = node + 20; // 0x80c7268
        while (v11 != 0) {
            int32_t v13 = v12;
            v9 = result2;
            v10 = v9;
            if (*(int32_t *)(v13 + 28) < *(int32_t *)(query + 8)) {
                // 0x80c7240
                v10 = v9;
                if (*(int32_t *)(v13 + 36) > *(int32_t *)query) {
                    // 0x80c7247
                    v10 = v9;
                    if (*(int32_t *)(v13 + 32) < *(int32_t *)(query + 12)) {
                        // 0x80c724f
                        v10 = v9;
                        if (*(int32_t *)(v13 + 40) > *(int32_t *)(query + 4)) {
                            // 0x80c73a8
                            v10 = v9 + (int32_t)(v11 != 0);
                        }
                    }
                }
            }
            // 0x80c7260
            result2 = v10;
            v11 = *(int32_t *)(v13 + 44);
            v12 = v13 + 20;
        }
        // 0x80c726a
        return result2;
    }
    int32_t v14 = node + 24;
    int32_t v15 = *(int32_t *)v14;
    if (*(int32_t *)arg == 0) {
        // 0x80c72d0
        if (v15 == 0) {
            // 0x80c726a
            return 0;
        }
        int32_t v16 = v14; // 0x80c7308
        int32_t v17 = 0;
        int32_t v18 = v17; // 0x80c72e5
        if (*(int32_t *)v15 < *(int32_t *)(query + 8)) {
            // 0x80c72e7
            v18 = v17;
            if (*(int32_t *)(v15 + 8) > *(int32_t *)query) {
                // 0x80c72ee
                v18 = v17;
                if (*(int32_t *)(v15 + 4) < *(int32_t *)(query + 12)) {
                    // 0x80c72f6
                    v18 = v17;
                    if (*(int32_t *)(v15 + 12) > *(int32_t *)(query + 4)) {
                        // 0x80c73c6
                        v18 = __r_search(v15, query, arg) + v17;
                    }
                }
            }
        }
        int32_t result3 = v18;
        v16 += 4;
        int32_t v19 = *(int32_t *)v16; // 0x80c730b
        while (v19 != 0) {
            // 0x80c72e0
            v17 = result3;
            int32_t v20 = v19;
            v18 = v17;
            if (*(int32_t *)v20 < *(int32_t *)(query + 8)) {
                // 0x80c72e7
                v18 = v17;
                if (*(int32_t *)(v20 + 8) > *(int32_t *)query) {
                    // 0x80c72ee
                    v18 = v17;
                    if (*(int32_t *)(v20 + 4) < *(int32_t *)(query + 12)) {
                        // 0x80c72f6
                        v18 = v17;
                        if (*(int32_t *)(v20 + 12) > *(int32_t *)(query + 4)) {
                            // 0x80c73c6
                            v18 = __r_search(v20, query, arg) + v17;
                        }
                    }
                }
            }
            // 0x80c7308
            result3 = v18;
            v16 += 4;
            v19 = *(int32_t *)v16;
        }
        // 0x80c726a
        return result3;
    }
    // 0x80c727e
    if (v15 == 0) {
        // 0x80c726a
        return 0;
    }
    int32_t v21 = v14; // 0x80c72b8
    int32_t v22 = 0;
    int32_t v23 = v15; // 0x80c7382
    int32_t v24 = v22; // 0x80c7295
    if (*(int32_t *)v23 < *(int32_t *)(query + 8)) {
        // 0x80c7297
        v24 = v22;
        if (*(int32_t *)(v23 + 8) > *(int32_t *)query) {
            // 0x80c729e
            v24 = v22;
            if (*(int32_t *)(v23 + 4) < *(int32_t *)(query + 12)) {
                // 0x80c72a6
                v24 = v22;
                if (!((v23 == 0 | *(int32_t *)(v23 + 12) <= *(int32_t *)(query + 4)))) {
                    // 0x80c737a
                    v24 = __r_search(v23, query, arg) + v22;
                }
            }
        }
    }
    int32_t result4 = v24;
    v21 += 4;
    int32_t v25 = *(int32_t *)v21; // 0x80c72bb
    while (v25 != 0) {
        // 0x80c7290
        v22 = result4;
        v23 = v25;
        v24 = v22;
        if (*(int32_t *)v23 < *(int32_t *)(query + 8)) {
            // 0x80c7297
            v24 = v22;
            if (*(int32_t *)(v23 + 8) > *(int32_t *)query) {
                // 0x80c729e
                v24 = v22;
                if (*(int32_t *)(v23 + 4) < *(int32_t *)(query + 12)) {
                    // 0x80c72a6
                    v24 = v22;
                    if (!((v23 == 0 | *(int32_t *)(v23 + 12) <= *(int32_t *)(query + 4)))) {
                        // 0x80c737a
                        v24 = __r_search(v23, query, arg) + v22;
                    }
                }
            }
        }
        // 0x80c72b8
        result4 = v24;
        v21 += 4;
        v25 = *(int32_t *)v21;
    }
    // 0x80c726a
    return result4;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c73f0 - 0x80c7490
// Line range:    603 - 636
int32_t r_search(int32_t rtree, int32_t query, int32_t check_region, int32_t found_rectangle, char * cl) {
    // 0x80c73f0
    if (rtree == 0 || *(int32_t *)(rtree + 4) < 1) {
        // 0x80c7442
        return 0;
    }
    int32_t v1 = *(int32_t *)rtree;
    int32_t v2; // bp-40, 0x80c73f0
    if (query == 0) {
        // 0x80c7470
        v2 = check_region;
        // 0x80c7442
        return __r_search(v1, v1, (int32_t)&v2);
    }
    // 0x80c741d
    if (*(int32_t *)v1 >= *(int32_t *)(query + 8) || *(int32_t *)(v1 + 8) <= *(int32_t *)query || *(int32_t *)(v1 + 4) >= *(int32_t *)(query + 12)) {
        // 0x80c7442
        return 0;
    }
    int32_t result = 0; // 0x80c743b
    if (*(int32_t *)(v1 + 12) > *(int32_t *)(query + 4)) {
        // 0x80c7450
        v2 = check_region;
        result = __r_search(v1, query, (int32_t)&v2);
    }
    // 0x80c7442
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c7600 - 0x80c789b
// Line range:    1042 - 1073
char __r_delete(int32_t node, int32_t query) {
    // 0x80c7600
    if (*(int32_t *)query < *(int32_t *)node || *(int32_t *)(query + 4) < *(int32_t *)(node + 4) || *(int32_t *)(node + 8) < *(int32_t *)(query + 8)) {
        // 0x80c7662
        return 0;
    }
    // 0x80c7625
    if (*(int32_t *)(query + 12) > *(int32_t *)(node + 12)) {
        // 0x80c7662
        return 0;
    }
    int32_t v1 = node;
    int32_t v2 = query;
    int32_t v3 = v1 + 20; // 0x80c762d
    char * v4 = (char *)v3;
    int32_t v5 = 0; // 0x80c7631
    int32_t v6 = v1; // 0x80c7631
    int32_t v7 = 1; // 0x80c7631
    int32_t v8 = 0; // 0x80c7631
    char result; // 0x80c7600
    int32_t v9; // 0x80c7600
    while (*v4 % 2 == 0) {
        int32_t v10 = v1 + 24; // 0x80c763c
        int32_t v11 = 0;
        int32_t v12 = 4 * v11; // 0x80c763c
        int32_t * v13 = (int32_t *)(v12 + v10);
        int32_t v14 = *v13; // 0x80c763c
        while (v2 != v14) {
            // 0x80c7644
            if (v14 == 0) {
                // 0x80c7662
                return 0;
            }
            // 0x80c7648
            if (__r_delete(v14, v2) != 0) {
                // 0x80c7662
                return 1;
            }
            // 0x80c7658
            if (v11 == 5) {
                // 0x80c7662
                return 0;
            }
            v11++;
            v12 = 4 * v11;
            v13 = (int32_t *)(v12 + v10);
            v14 = *v13;
        }
        // 0x80c7690
        free((int32_t *)v2);
        if (v11 <= 5) {
            int32_t v15 = v12 + v1;
            int32_t v16 = *(int32_t *)(v15 + 28); // 0x80c769d
            *v13 = v16;
            if (v16 != 0) {
                int32_t v17 = v15 + 32; // 0x80c7600
                int32_t v18 = v11;
                while (v18 < 5) {
                    // 0x80c76c7
                    v18++;
                    int32_t v19 = *(int32_t *)v17; // 0x80c76b8
                    *(int32_t *)(v17 - 4) = v19;
                    v17 += 4;
                    if (v19 == 0) {
                        // break -> 0x80c76cc
                        break;
                    }
                }
            }
        }
        // 0x80c76cc
        v9 = v1;
        if (*(int32_t *)v10 != 0) {
            goto lab_0x80c766d;
        }
        int32_t v20 = *(int32_t *)(v1 + 16); // 0x80c76d3
        if (v20 == 0) {
            // 0x80c785d
            *v4 = *v4 | 1;
            *(int32_t *)(v1 + 44) = 0;
            *(int32_t *)(v1 + 64) = 0;
            *(int32_t *)(v1 + 84) = 0;
            *(int32_t *)(v1 + 104) = 0;
            *(int32_t *)(v1 + 124) = 0;
            *(int32_t *)(v1 + 144) = 0;
            result = 1;
            return result;
        }
        // 0x80c76de
        if (*(int32_t *)v1 < *(int32_t *)v20 || *(int32_t *)(v1 + 4) < *(int32_t *)(v20 + 4) || *(int32_t *)(v1 + 8) > *(int32_t *)(v20 + 8)) {
            // 0x80c7662
            return 0;
        }
        int32_t v21 = v1; // 0x80c770c
        if (*(int32_t *)(v1 + 12) > *(int32_t *)(v20 + 12)) {
            // 0x80c7662
            return 0;
        }
        v1 = v20;
        v2 = v21;
        v3 = v1 + 20;
        v4 = (char *)v3;
        v5 = 0;
        v6 = v1;
        v7 = 1;
        v8 = 0;
    }
    int32_t v22 = *(int32_t *)(v6 + 24); // 0x80c7729
    result = 0;
    int32_t v23; // 0x80c7600
    int32_t v24; // 0x80c7600
    int32_t v25; // 0x80c7600
    int32_t v26; // 0x80c7748
    while (v22 != 0) {
        int32_t v27 = v8;
        v25 = v5;
        v26 = v2;
        v24 = v7;
        v23 = v27;
        if (v2 == v22) {
            goto lab_0x80c7756;
        }
        int32_t v28 = v27 + 1; // 0x80c7738
        int32_t v29 = v7 | v5; // 0x80c773e
        int32_t v30 = 2 * v7; // 0x80c7741
        v5 = v29;
        v6 += 20;
        v7 = v30;
        v8 = v28;
        if (v27 == 5) {
            // 0x80c7748
            v26 = *(int32_t *)(v1 + 144);
            result = 0;
            v25 = v29;
            v24 = v30;
            v23 = v28;
            if (v26 == 0) {
                return result;
            } else {
                goto lab_0x80c7756;
            }
        }
        v22 = *(int32_t *)(v6 + 24);
        result = 0;
    }
  lab_0x80c7662:
    // 0x80c7662
    return result;
  lab_0x80c7756:;
    int32_t v31 = v25;
    int32_t * v32 = (int32_t *)v3; // 0x80c7756
    uint32_t v33 = *v32; // 0x80c7756
    int32_t v34 = v33 / 2; // 0x80c775b
    int32_t v35 = v34; // 0x80c775f
    int32_t v36 = v33; // 0x80c775f
    if ((v34 & v24) != 0) {
        // 0x80c781b
        free((int32_t *)v26);
        *(int32_t *)(v1 + 24 + 20 * v23) = 0;
        uint32_t v37 = *v32; // 0x80c7830
        v35 = v37 / 2;
        v36 = v37;
        goto lab_0x80c7765;
    } else {
        goto lab_0x80c7765;
    }
  lab_0x80c766d:
    // 0x80c766d
    adjust_bounds((int32_t)&g231);
    int32_t v38 = *(int32_t *)(v9 + 16); // 0x80c7674
    result = 1;
    v9 = v38;
    if (v38 != 0) {
        goto lab_0x80c766d;
    } else {
        return result;
    }
  lab_0x80c7765:;
    int32_t v39 = v35;
    *v32 = 2 * (v39 & v31) | v39 & (2 * v31 ^ 0x7ffffffe) | v36 % 2;
    int32_t v40; // 0x80c7600
    int32_t v41; // 0x80c7600
    if (v23 > 5) {
        goto lab_0x80c77fc;
    } else {
        int32_t v42 = v23 + 1; // 0x80c7784
        int32_t v43 = 20 * v42; // 0x80c778d
        int32_t v44 = v1 + 16 + v43; // 0x80c7790
        int32_t v45 = 20 * v23 + v1; // 0x80c779a
        int32_t * v46 = (int32_t *)(v45 + 24); // 0x80c77a0
        *v46 = *(int32_t *)(v44 + 8);
        *(int32_t *)(v45 + 28) = *(int32_t *)(v44 + 12);
        *(int32_t *)(v45 + 32) = *(int32_t *)(v44 + 16);
        *(int32_t *)(v45 + 36) = *(int32_t *)(v44 + 20);
        *(int32_t *)(v45 + 40) = *(int32_t *)(v44 + 24);
        if (*v46 != 0) {
            // 0x80c77f7
            v40 = v1 + 24 + v43;
            v41 = v42;
            goto lab_0x80c77f7_2;
        } else {
            goto lab_0x80c77fc;
        }
    }
  lab_0x80c77fc:;
    int32_t v47 = v1; // 0x80c7801
    if (*(int32_t *)(v1 + 24) == 0) {
        int32_t v48 = *(int32_t *)(v1 + 16); // 0x80c783c
        result = 1;
        if (v48 == 0) {
            return result;
        } else {
            // 0x80c7847
            __r_delete(v48, v1);
            result = 1;
            return result;
        }
    } else {
        goto lab_0x80c7808;
    }
  lab_0x80c7808:
    // 0x80c7808
    adjust_bounds((int32_t)&g231);
    int32_t v49 = *(int32_t *)(v47 + 16); // 0x80c780f
    result = 1;
    v47 = v49;
    if (v49 != 0) {
        goto lab_0x80c7808;
    } else {
        return result;
    }
  lab_0x80c77f7_2:
    // 0x80c77f7
    if (v41 < 6) {
        int32_t v50 = v40;
        int32_t v51 = v50 + 20; // 0x80c77d6
        int32_t v52 = *(int32_t *)v51; // 0x80c77d6
        *(int32_t *)(v50 + 4) = *(int32_t *)(v50 + 24);
        *(int32_t *)v50 = v52;
        *(int32_t *)(v50 + 8) = *(int32_t *)(v50 + 28);
        *(int32_t *)(v50 + 12) = *(int32_t *)(v50 + 32);
        *(int32_t *)(v50 + 16) = *(int32_t *)(v50 + 36);
        v40 = v51;
        v41++;
        if (v52 == 0) {
            goto lab_0x80c77fc;
        } else {
            goto lab_0x80c77f7_2;
        }
    } else {
        goto lab_0x80c77fc;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c78a0 - 0x80c78c9
// Line range:    1149 - 1162
char r_delete_entry(int32_t rtree, int32_t box) {
    char result = __r_delete(*(int32_t *)rtree, box); // 0x80c78b6
    if (result != 0) {
        int32_t * v1 = (int32_t *)(rtree + 4); // 0x80c78bf
        *v1 = *v1 - 1;
    }
    // 0x80c78c3
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c78d0 - 0x80c7958
// Line range:    472 - 482
void __r_destroy_tree(int32_t node) {
    // 0x80c78d0
    int32_t v1; // 0x80c78d0
    int32_t v2 = v1 + 20; // 0x80c78dd
    int32_t v3 = v1 + 24;
    if (*(char *)v2 % 2 == 0) {
        int32_t v4 = 0;
        while (*(int32_t *)(4 * v4 + v3) != 0) {
            // 0x80c7928
            __r_destroy_tree((int32_t)&g231);
            if (v4 == 5) {
                // 0x80c7935
                free((int32_t *)v1);
                return;
            }
            v4++;
        }
        // 0x80c7910
        free((int32_t *)v1);
        return;
    }
    int32_t v5 = *(int32_t *)v3; // 0x80c78ea
    if (v5 == 0) {
        // 0x80c7910
        free((int32_t *)v1);
        return;
    }
    int32_t v6 = 1; // 0x80c78d0
    if ((*(int32_t *)v2 / 2 & v6) != 0) {
        // 0x80c7948
        free((int32_t *)v5);
    }
    int32_t v7; // 0x80c78d0
    while (v7 != v1 + 100) {
        int32_t v8 = *(int32_t *)(v7 + 44); // 0x80c7904
        int32_t v9 = v8; // 0x80c790b
        v7 += 20;
        v6 *= 2;
        if (v8 == 0) {
            // break -> 0x80c7910
            break;
        }
        if ((*(int32_t *)v2 / 2 & v6) != 0) {
            // 0x80c7948
            free((int32_t *)v9);
        }
    }
    // 0x80c7910
    free((int32_t *)v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c7960 - 0x80c7989
// Line range:    497 - 503
void r_destroy_tree(int32_t rtree) {
    // 0x80c7960
    int32_t v1; // 0x80c7960
    __r_destroy_tree(v1);
    int32_t * v2 = (int32_t *)rtree; // 0x80c7973
    free((int32_t *)*v2);
    *v2 = 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c7990 - 0x80c8047
// Line range:    671 - 704
int32_t find_clusters(int32_t node) {
    // 0x80c7990
    float32_t v1; // bp-120, 0x80c7990
    int32_t v2 = &v1; // 0x80c799f
    int3_t v3; // 0x80c7990
    int3_t v4 = v3 - 1; // 0x80c79a2
    __frontend_reg_store_fpr(v4, 0.5L);
    int32_t v5 = node + 20; // 0x80c79a8
    char * v6 = (char *)v5; // 0x80c79a8
    int32_t v7 = node + 24;
    int3_t v8 = v3 - 2;
    int3_t v9 = v3 - 3;
    int32_t v10 = v2; // 0x80c79b7
    int32_t v11 = 0;
    int32_t v12 = node + 28 + 20 * v11; // 0x80c79c9
    if (*v6 % 2 == 0) {
        // 0x80c79cb
        v12 = *(int32_t *)(4 * v11 + v7);
    }
    int32_t v13 = *(int32_t *)v12; // 0x80c79cf
    int32_t v14 = v11 + 1; // 0x80c79d1
    int32_t v15 = *(int32_t *)(v12 + 8); // 0x80c79d4
    __frontend_reg_store_fpr(v8, (float80_t)(float32_t)(v15 + v13));
    __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v8) * __frontend_reg_load_fpr(v4));
    *(float32_t *)v10 = (float32_t)__frontend_reg_load_fpr(v8);
    int32_t v16 = *(int32_t *)(v12 + 4); // 0x80c79f6
    int32_t v17 = *(int32_t *)(v12 + 12); // 0x80c79f9
    __frontend_reg_store_fpr(v8, (float80_t)(float32_t)(v17 + v16));
    __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v8) * __frontend_reg_load_fpr(v4));
    *(float32_t *)(v10 + 4) = (float32_t)__frontend_reg_load_fpr(v8);
    __frontend_reg_store_fpr(v8, (float80_t)(float32_t)(v15 - v13));
    __frontend_reg_store_fpr(v9, (float80_t)(float32_t)(v17 - v16));
    __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v9) * __frontend_reg_load_fpr(v8));
    __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v8) + 1.0L);
    *(float32_t *)(v10 + 8) = (float32_t)__frontend_reg_load_fpr(v8);
    v10 += 12;
    while (v14 != 7) {
        // 0x80c79b8
        v11 = v14;
        v12 = node + 28 + 20 * v11;
        if (*v6 % 2 == 0) {
            // 0x80c79cb
            v12 = *(int32_t *)(4 * v11 + v7);
        }
        // 0x80c79cf
        v13 = *(int32_t *)v12;
        v14 = v11 + 1;
        v15 = *(int32_t *)(v12 + 8);
        __frontend_reg_store_fpr(v8, (float80_t)(float32_t)(v15 + v13));
        __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v8) * __frontend_reg_load_fpr(v4));
        *(float32_t *)v10 = (float32_t)__frontend_reg_load_fpr(v8);
        v16 = *(int32_t *)(v12 + 4);
        v17 = *(int32_t *)(v12 + 12);
        __frontend_reg_store_fpr(v8, (float80_t)(float32_t)(v17 + v16));
        __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v8) * __frontend_reg_load_fpr(v4));
        *(float32_t *)(v10 + 4) = (float32_t)__frontend_reg_load_fpr(v8);
        __frontend_reg_store_fpr(v8, (float80_t)(float32_t)(v15 - v13));
        __frontend_reg_store_fpr(v9, (float80_t)(float32_t)(v17 - v16));
        __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v9) * __frontend_reg_load_fpr(v8));
        __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v8) + 1.0L);
        *(float32_t *)(v10 + 8) = (float32_t)__frontend_reg_load_fpr(v8);
        v10 += 12;
    }
    // 0x80c7a41
    __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v4));
    __frontend_reg_store_fpr(v4, (float80_t)v1);
    float80_t v18 = __frontend_reg_load_fpr(v4); // 0x80c7a46
    float32_t v19; // 0x80c7990
    __frontend_reg_store_fpr(v4, (float80_t)v19);
    float80_t v20 = __frontend_reg_load_fpr(v4); // 0x80c7a4f
    __frontend_reg_store_fpr(v4, (float80_t)v19);
    float80_t v21 = __frontend_reg_load_fpr(v4); // 0x80c7a58
    __frontend_reg_store_fpr(v8, (float80_t)v19);
    float80_t v22 = __frontend_reg_load_fpr(v8); // 0x80c7a61
    __frontend_reg_store_fpr(v9, v18);
    float80_t v23 = __frontend_reg_load_fpr(v9); // 0x80c7a6d
    __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v4));
    __frontend_reg_store_fpr(v4, v23);
    float80_t v24 = __frontend_reg_load_fpr(v9); // 0x80c7a6f
    float80_t v25 = __frontend_reg_load_fpr(v4); // 0x80c7a6f
    __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v8));
    float80_t v26; // 0x80c7990
    if (v24 == v25) {
        if (v24 != v25) {
            // 0x80c7a8f
            __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v4));
            // 0x80c7a95
            __frontend_reg_store_fpr(v4, v20);
            v26 = v21;
            goto lab_0x80c7a9b;
        } else {
            // 0x80c7a77
            __frontend_reg_store_fpr(v8, v20);
            float80_t v27 = __frontend_reg_load_fpr(v8); // 0x80c7a7d
            __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v4));
            __frontend_reg_store_fpr(v4, v27);
            float80_t v28 = __frontend_reg_load_fpr(v8); // 0x80c7a7f
            float80_t v29 = __frontend_reg_load_fpr(v4); // 0x80c7a7f
            if (v28 == v29) {
                if (v28 != v29) {
                    // 0x80c7a93
                    __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v4));
                    // 0x80c7a95
                    __frontend_reg_store_fpr(v4, v20);
                    v26 = v21;
                    goto lab_0x80c7a9b;
                } else {
                    // 0x80c802c
                    __frontend_reg_store_fpr(v8, 1.0e+4L);
                    __frontend_reg_store_fpr(v9, v21);
                    __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v9) + __frontend_reg_load_fpr(v8));
                    float80_t v30 = __frontend_reg_load_fpr(v9); // 0x80c803a
                    __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v4) - __frontend_reg_load_fpr(v8));
                    v26 = v30;
                    goto lab_0x80c7a9b;
                }
            } else {
                // 0x80c7a87
                __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v4));
                // 0x80c7a95
                __frontend_reg_store_fpr(v4, v20);
                v26 = v21;
                goto lab_0x80c7a9b;
            }
        }
    } else {
        // 0x80c7a8b
        __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v4));
        // 0x80c7a95
        __frontend_reg_store_fpr(v4, v20);
        v26 = v21;
        goto lab_0x80c7a9b;
    }
  lab_0x80c7b7a:;
    // 0x80c7b7a
    int3_t v31; // 0x80c7ac8
    __frontend_reg_store_fpr(v31, v20);
    int3_t v32; // 0x80c7ad3
    __frontend_reg_store_fpr(v32, v18);
    int3_t v33; // 0x80c7ae1
    __frontend_reg_store_fpr(v33, 0.0L);
    float80_t v34 = __frontend_reg_load_fpr(v33); // 0x80c7b9c
    float80_t v35 = __frontend_reg_load_fpr(v33); // 0x80c7ba2
    float80_t v36 = __frontend_reg_load_fpr(v33); // 0x80c7ba8
    int3_t v37; // 0x80c7990
    __frontend_reg_store_fpr(v37, __frontend_reg_load_fpr(v33));
    int3_t v38; // 0x80c7990
    __frontend_reg_store_fpr(v38, __frontend_reg_load_fpr(v33));
    float32_t v39 = v34; // 0x80c7bb2
    float32_t v40 = v36; // 0x80c7bb2
    float32_t v41 = v35; // 0x80c7bb2
    int3_t v42 = v38; // 0x80c7bb2
    int32_t v43 = v2; // 0x80c7bb2
    int32_t v44 = 0; // 0x80c7bb2
    float32_t v45; // 0x80c7990
    float32_t v46; // 0x80c7990
    float32_t v47; // 0x80c7990
    int3_t v48; // 0x80c7990
    int32_t v49; // 0x80c7990
    while (true) {
        int32_t v50 = v44;
        int32_t v51 = v43;
        int3_t v52 = v42;
        float32_t v53 = v41;
        float32_t v54 = v40;
        float32_t v55 = v39;
        int3_t v56 = v52 - 1;
        __frontend_reg_store_fpr(v56, (float80_t)*(float32_t *)(v51 + 8));
        int3_t v57 = v52 + 3;
        __frontend_reg_store_fpr(v57, __frontend_reg_load_fpr(v57) * __frontend_reg_load_fpr(v56));
        float80_t v58 = __frontend_reg_load_fpr(v56);
        __frontend_reg_store_fpr(v56, __frontend_reg_load_fpr(v57));
        __frontend_reg_store_fpr(v57, v58);
        float80_t v59 = __frontend_reg_load_fpr(v56);
        float32_t v60; // 0x80c7990
        float32_t v61; // 0x80c7990
        float32_t v62; // 0x80c7990
        int3_t v63; // 0x80c7990
        if (*(char *)(v50 + v49) != 0) {
            // 0x80c7bb8
            __frontend_reg_store_fpr(v56, v59 + (float80_t)v54);
            float32_t v64 = __frontend_reg_load_fpr(v56); // 0x80c7bce
            int3_t v65 = v52 ^ -4; // 0x80c7bd4
            float80_t v66 = __frontend_reg_load_fpr(v52); // 0x80c7bd4
            __frontend_reg_store_fpr(v52, __frontend_reg_load_fpr(v65));
            __frontend_reg_store_fpr(v65, v66);
            float80_t v67 = __frontend_reg_load_fpr(v52); // 0x80c7bd6
            __frontend_reg_store_fpr(v52, v67 * __frontend_reg_load_fpr(v57));
            __frontend_reg_store_fpr(v52, __frontend_reg_load_fpr(v52) + (float80_t)v53);
            float32_t v68 = __frontend_reg_load_fpr(v52); // 0x80c7bde
            int3_t v69 = v52 + 1; // 0x80c7bde
            float80_t v70 = __frontend_reg_load_fpr(v69); // 0x80c7be4
            __frontend_reg_store_fpr(v69, __frontend_reg_load_fpr(v65));
            __frontend_reg_store_fpr(v65, v70);
            __frontend_reg_store_fpr(v57, __frontend_reg_load_fpr(v69) + __frontend_reg_load_fpr(v57));
            int3_t v71 = v52 + 2; // 0x80c7be6
            v62 = v55;
            v60 = v64;
            v61 = v68;
            v63 = v71;
            v47 = v55;
            v45 = v64;
            v46 = v68;
            v48 = v71;
            if (v50 == 6) {
                // break -> 0x80c7c34
                break;
            }
        } else {
            // 0x80c7c08
            __frontend_reg_store_fpr(v56, v59 + (float80_t)v55);
            float32_t v72 = __frontend_reg_load_fpr(v56); // 0x80c7c1e
            int3_t v73 = v52 ^ -4; // 0x80c7c24
            float80_t v74 = __frontend_reg_load_fpr(v52); // 0x80c7c24
            __frontend_reg_store_fpr(v52, __frontend_reg_load_fpr(v73));
            __frontend_reg_store_fpr(v73, v74);
            float80_t v75 = __frontend_reg_load_fpr(v52); // 0x80c7c26
            __frontend_reg_store_fpr(v52, v75 * __frontend_reg_load_fpr(v57));
            int3_t v76 = v52 + 2; // 0x80c7c28
            __frontend_reg_store_fpr(v76, __frontend_reg_load_fpr(v52) + __frontend_reg_load_fpr(v76));
            float80_t v77 = __frontend_reg_load_fpr(v52 + 1); // 0x80c7c2a
            __frontend_reg_store_fpr(v57, v77 + __frontend_reg_load_fpr(v57));
            float80_t v78 = __frontend_reg_load_fpr(v76);
            __frontend_reg_store_fpr(v76, __frontend_reg_load_fpr(v57));
            __frontend_reg_store_fpr(v57, v78);
            float80_t v79 = __frontend_reg_load_fpr(v76);
            __frontend_reg_store_fpr(v76, __frontend_reg_load_fpr(v73));
            __frontend_reg_store_fpr(v73, v79);
            float80_t v80 = __frontend_reg_load_fpr(v76);
            __frontend_reg_store_fpr(v76, __frontend_reg_load_fpr(v57));
            __frontend_reg_store_fpr(v57, v80);
            v62 = v72;
            v60 = v54;
            v61 = v53;
            v63 = v76;
            v47 = v72;
            v45 = v54;
            v46 = v53;
            v48 = v76;
            if (v50 == 6) {
                // break -> 0x80c7c34
                break;
            }
        }
        int32_t v81 = v51 + 12;
        int3_t v82 = v63 - 1; // 0x80c7bf6
        __frontend_reg_store_fpr(v82, (float80_t)*(float32_t *)v81);
        int3_t v83 = v63 - 2; // 0x80c7bf8
        __frontend_reg_store_fpr(v83, (float80_t)*(float32_t *)(v51 + 16));
        int3_t v84 = v63 + 2; // 0x80c7bfb
        float80_t v85 = __frontend_reg_load_fpr(v83); // 0x80c7bfb
        __frontend_reg_store_fpr(v83, __frontend_reg_load_fpr(v84));
        __frontend_reg_store_fpr(v84, v85);
        float80_t v86 = __frontend_reg_load_fpr(v83); // 0x80c7bfd
        __frontend_reg_store_fpr(v83, __frontend_reg_load_fpr(v82));
        __frontend_reg_store_fpr(v82, v86);
        int3_t v87 = v63 + 1; // 0x80c7bff
        float80_t v88 = __frontend_reg_load_fpr(v83); // 0x80c7bff
        __frontend_reg_store_fpr(v83, __frontend_reg_load_fpr(v87));
        __frontend_reg_store_fpr(v87, v88);
        v39 = v62;
        v40 = v60;
        v41 = v61;
        v42 = v83;
        v43 = v81;
        v44 = v50 + 1;
    }
    int3_t v89 = v48;
    int3_t v90 = v89 - 1; // 0x80c7c34
    __frontend_reg_store_fpr(v90, (float80_t)v45);
    int3_t v91 = v89 + 1; // 0x80c7c3a
    __frontend_reg_store_fpr(v90, __frontend_reg_load_fpr(v90) / __frontend_reg_load_fpr(v91));
    float80_t v92 = __frontend_reg_load_fpr(v90); // 0x80c7c3c
    __frontend_reg_store_fpr(v90, __frontend_reg_load_fpr(v91));
    __frontend_reg_store_fpr(v91, v92);
    __frontend_reg_store_fpr(v90, (float80_t)v46 / __frontend_reg_load_fpr(v90));
    int3_t v93 = v89 - 2; // 0x80c7c44
    __frontend_reg_store_fpr(v93, (float80_t)v47);
    int3_t v94 = v89 + 2;
    __frontend_reg_store_fpr(v93, __frontend_reg_load_fpr(v93) / __frontend_reg_load_fpr(v94));
    float80_t v95 = __frontend_reg_load_fpr(v93); // 0x80c7c4c
    __frontend_reg_store_fpr(v93, __frontend_reg_load_fpr(v89));
    __frontend_reg_store_fpr(v89, v95);
    __frontend_reg_store_fpr(v94, __frontend_reg_load_fpr(v93) / __frontend_reg_load_fpr(v94));
    float80_t v96 = __frontend_reg_load_fpr(v90); // 0x80c7c50
    __frontend_reg_store_fpr(v90, __frontend_reg_load_fpr(v91));
    __frontend_reg_store_fpr(v91, v96);
    float80_t v97 = __frontend_reg_load_fpr(v90); // 0x80c7c55
    int3_t v98 = v89 + 3;
    float80_t v99 = __frontend_reg_load_fpr(v90); // 0x80c7c5e
    __frontend_reg_store_fpr(v90, __frontend_reg_load_fpr(v98));
    __frontend_reg_store_fpr(v98, v99);
    float80_t v100 = __frontend_reg_load_fpr(v90); // 0x80c7c69
    float80_t v101 = __frontend_reg_load_fpr(v89);
    float80_t v102; // 0x80c7990
    float80_t v103; // 0x80c7990
    if ((int32_t)(float32_t)v97 == (int32_t)(float32_t)v100) {
        // 0x80c7ce8
        __frontend_reg_store_fpr(v89, __frontend_reg_load_fpr(v91));
        __frontend_reg_store_fpr(v91, v101);
        float80_t v104 = __frontend_reg_load_fpr(v89); // 0x80c7ced
        int3_t v105 = v89 ^ -4; // 0x80c7cf6
        float80_t v106 = __frontend_reg_load_fpr(v89); // 0x80c7cf6
        __frontend_reg_store_fpr(v89, __frontend_reg_load_fpr(v105));
        __frontend_reg_store_fpr(v105, v106);
        float80_t v107 = __frontend_reg_load_fpr(v89); // 0x80c7d01
        float80_t v108 = __frontend_reg_load_fpr(v91);
        if ((int32_t)(float32_t)v104 != (int32_t)(float32_t)v107) {
            // 0x80c7c88
            __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v94));
            __frontend_reg_store_fpr(v94, v108);
            float80_t v109 = __frontend_reg_load_fpr(v91); // 0x80c7c8a
            __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v98));
            __frontend_reg_store_fpr(v98, v109);
            float80_t v110 = __frontend_reg_load_fpr(v91); // 0x80c7c8c
            __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v105));
            __frontend_reg_store_fpr(v105, v110);
            float80_t v111 = __frontend_reg_load_fpr(v91); // 0x80c7c8e
            __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v94));
            __frontend_reg_store_fpr(v94, v111);
        } else {
            // 0x80c7d18
            __frontend_reg_store_fpr(v89, v103);
            float80_t v112 = __frontend_reg_load_fpr(v89); // 0x80c7d33
            float80_t v113 = __frontend_reg_load_fpr(v91);
            __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v94));
            __frontend_reg_store_fpr(v94, v113);
            float80_t v114 = __frontend_reg_load_fpr(v91);
            if ((int32_t)(float32_t)v108 != (int32_t)(float32_t)v112) {
                // 0x80c7c92
                __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v98));
                __frontend_reg_store_fpr(v98, v114);
                float80_t v115 = __frontend_reg_load_fpr(v91); // 0x80c7c96
                __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v105));
                __frontend_reg_store_fpr(v105, v115);
                float80_t v116 = __frontend_reg_load_fpr(v91); // 0x80c7c98
                __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v94));
                __frontend_reg_store_fpr(v94, v116);
            } else {
                // 0x80c7d4a
                __frontend_reg_store_fpr(v89, v102);
                float80_t v117 = __frontend_reg_load_fpr(v89); // 0x80c7d67
                float80_t v118 = __frontend_reg_load_fpr(v91);
                if ((int32_t)(float32_t)v114 == (int32_t)(float32_t)v117) {
                    // 0x80c7d7e
                    __frontend_reg_store_fpr(v91, v118);
                    __frontend_reg_store_fpr(v94, __frontend_reg_load_fpr(v94));
                    __frontend_reg_store_fpr(v98, __frontend_reg_load_fpr(v98));
                    __frontend_reg_store_fpr(v105, __frontend_reg_load_fpr(v105));
                    goto lab_0x80c7d90;
                }
                // 0x80c7c9c
                __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v98));
                __frontend_reg_store_fpr(v98, v118);
                float80_t v119 = __frontend_reg_load_fpr(v91); // 0x80c7c9e
                __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v105));
                __frontend_reg_store_fpr(v105, v119);
                float80_t v120 = __frontend_reg_load_fpr(v91); // 0x80c7ca0
                __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v94));
                __frontend_reg_store_fpr(v94, v120);
            }
        }
    } else {
        int3_t v121 = v89 ^ -4; // 0x80c7c7c
        __frontend_reg_store_fpr(v121, v101);
        float80_t v122 = __frontend_reg_load_fpr(v91); // 0x80c7c7e
        __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v94));
        __frontend_reg_store_fpr(v94, v122);
        float80_t v123 = __frontend_reg_load_fpr(v91); // 0x80c7c80
        __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v98));
        __frontend_reg_store_fpr(v98, v123);
        float80_t v124 = __frontend_reg_load_fpr(v91); // 0x80c7c82
        __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v121));
        __frontend_reg_store_fpr(v121, v124);
    }
    int32_t v125; // 0x80c7990
    if (v125 == 5) {
        // break -> 0x80c7d88
        goto lab_0x80c7d88;
    }
    float80_t v126 = __frontend_reg_load_fpr(v91); // 0x80c7cbc
    __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v98));
    __frontend_reg_store_fpr(v98, v126);
    float80_t v127 = __frontend_reg_load_fpr(v91); // 0x80c7cbe
    float80_t v128 = __frontend_reg_load_fpr(v94); // 0x80c7cc4
    __frontend_reg_store_fpr(v94, __frontend_reg_load_fpr(v98));
    __frontend_reg_store_fpr(v98, v128);
    float80_t v129 = __frontend_reg_load_fpr(v94); // 0x80c7cc6
    int3_t v130 = v89 ^ -4; // 0x80c7ccc
    float80_t v131 = __frontend_reg_load_fpr(v98); // 0x80c7ccc
    __frontend_reg_store_fpr(v98, __frontend_reg_load_fpr(v130));
    __frontend_reg_store_fpr(v130, v131);
    float80_t v132 = v129; // 0x80c7cce
    float80_t v133 = v127; // 0x80c7cce
    v125++;
    int3_t v134 = v98; // 0x80c7cce
    goto lab_0x80c7ac8;
  lab_0x80c7a9b:
    // 0x80c7a9b
    __frontend_reg_store_fpr(v8, v18);
    int32_t v163; // bp-36, 0x80c7990
    int32_t v161 = &v163; // 0x80c7aa7
    int32_t v164; // bp-4, 0x80c7990
    v49 = (int32_t)&v164 - 31;
    v132 = v26;
    v133 = v22;
    v125 = 0;
    v134 = v8;
    while (true) {
      lab_0x80c7ac8:
        // 0x80c7ac8
        v102 = v133;
        v103 = v132;
        v31 = v134 - 1;
        __frontend_reg_store_fpr(v31, v20);
        v32 = v134 - 2;
        __frontend_reg_store_fpr(v32, v18);
        v33 = v134 - 3;
        __frontend_reg_store_fpr(v33, v102);
        v37 = v134 ^ -4;
        v38 = v134 + 3;
        int3_t v135 = v134 + 2;
        int32_t v136; // bp-35, 0x80c7990
        int32_t v137 = &v136; // 0x80c7ae7
        int32_t v138; // bp-108, 0x80c7990
        int32_t v139 = &v138; // 0x80c7ae7
        int32_t v140 = 0; // 0x80c7ae7
        int32_t v141 = 0; // 0x80c7ae7
        while (true) {
            int32_t v142 = v141;
            int32_t v143 = v140;
            int32_t v144 = v139;
            int32_t v145 = v137;
            __frontend_reg_store_fpr(v37, __frontend_reg_load_fpr(v134));
            __frontend_reg_store_fpr(v37, __frontend_reg_load_fpr(v37) - __frontend_reg_load_fpr(v32));
            __frontend_reg_store_fpr(v38, __frontend_reg_load_fpr(v134 + 1));
            __frontend_reg_store_fpr(v38, __frontend_reg_load_fpr(v38) - __frontend_reg_load_fpr(v31));
            float80_t v146 = __frontend_reg_load_fpr(v38); // 0x80c7b1f
            __frontend_reg_store_fpr(v38, __frontend_reg_load_fpr(v32));
            __frontend_reg_store_fpr(v32, v146);
            __frontend_reg_store_fpr(v38, v103 - __frontend_reg_load_fpr(v38));
            float80_t v147 = __frontend_reg_load_fpr(v38); // 0x80c7b27
            __frontend_reg_store_fpr(v38, __frontend_reg_load_fpr(v31));
            __frontend_reg_store_fpr(v31, v147);
            __frontend_reg_store_fpr(v38, __frontend_reg_load_fpr(v33) - __frontend_reg_load_fpr(v38));
            __frontend_reg_store_fpr(v135, (float80_t)(float32_t)(v143 + 3));
            float80_t v148 = __frontend_reg_load_fpr(v135); // 0x80c7b31
            __frontend_reg_store_fpr(v135, __frontend_reg_load_fpr(v37));
            __frontend_reg_store_fpr(v37, v148);
            __frontend_reg_store_fpr(v135, __frontend_reg_load_fpr(v135) * __frontend_reg_load_fpr(v135));
            float80_t v149 = __frontend_reg_load_fpr(v135); // 0x80c7b35
            __frontend_reg_store_fpr(v135, __frontend_reg_load_fpr(v32));
            __frontend_reg_store_fpr(v32, v149);
            __frontend_reg_store_fpr(v135, __frontend_reg_load_fpr(v135) * __frontend_reg_load_fpr(v135));
            __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v135) + __frontend_reg_load_fpr(v32));
            float80_t v150 = __frontend_reg_load_fpr(v38); // 0x80c7b41
            __frontend_reg_store_fpr(v38, __frontend_reg_load_fpr(v37));
            __frontend_reg_store_fpr(v37, v150);
            __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v38) * __frontend_reg_load_fpr(v32));
            __frontend_reg_store_fpr(v38, (float80_t)(float32_t)(v142 + 3));
            float80_t v151 = __frontend_reg_load_fpr(v38); // 0x80c7b4b
            __frontend_reg_store_fpr(v38, __frontend_reg_load_fpr(v31));
            __frontend_reg_store_fpr(v31, v151);
            __frontend_reg_store_fpr(v38, __frontend_reg_load_fpr(v38) * __frontend_reg_load_fpr(v38));
            float80_t v152 = __frontend_reg_load_fpr(v38); // 0x80c7b4f
            __frontend_reg_store_fpr(v38, __frontend_reg_load_fpr(v37));
            __frontend_reg_store_fpr(v37, v152);
            __frontend_reg_store_fpr(v38, __frontend_reg_load_fpr(v38) * __frontend_reg_load_fpr(v38));
            __frontend_reg_store_fpr(v37, __frontend_reg_load_fpr(v38) + __frontend_reg_load_fpr(v37));
            __frontend_reg_store_fpr(v31, __frontend_reg_load_fpr(v37) * __frontend_reg_load_fpr(v31));
            float80_t v153 = __frontend_reg_load_fpr(v33); // 0x80c7b57
            __frontend_reg_store_fpr(v33, __frontend_reg_load_fpr(v31));
            __frontend_reg_store_fpr(v31, v153);
            float80_t v154 = __frontend_reg_load_fpr(v33); // 0x80c7b59
            float80_t v155 = __frontend_reg_load_fpr(v32); // 0x80c7b59
            bool v156 = false; // 0x80c7b59
            bool v157 = false; // 0x80c7b59
            if (v154 <= v155) {
                v156 = true;
                v157 = false;
                if (v154 >= v155) {
                    v156 = v154 != v155;
                    v157 = true;
                }
            }
            __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v32));
            char * v158 = (char *)v145;
            int32_t v159; // 0x80c7990
            int32_t v160; // 0x80c7990
            if (v156 || v157) {
                // 0x80c7b5f
                *v158 = 0;
                v159 = v143;
                v160 = v142 + 1;
                if (v144 == v161) {
                    // break -> 0x80c7b70
                    break;
                }
            } else {
                // 0x80c7af0
                *v158 = 1;
                v159 = v143 + 1;
                v160 = v142;
                if (v144 == v161) {
                    // 0x80c7b78
                    __frontend_reg_store_fpr(v31, __frontend_reg_load_fpr(v31));
                    goto lab_0x80c7b7a;
                }
            }
            // 0x80c7b01
            __frontend_reg_store_fpr(v32, (float80_t)*(float32_t *)v144);
            __frontend_reg_store_fpr(v33, (float80_t)*(float32_t *)(v144 + 4));
            float80_t v162 = __frontend_reg_load_fpr(v33); // 0x80c7b06
            __frontend_reg_store_fpr(v33, __frontend_reg_load_fpr(v31));
            __frontend_reg_store_fpr(v31, v162);
            v137 = v145 + 1;
            v139 = v144 + 12;
            v140 = v159;
            v141 = v160;
        }
        // 0x80c7b70
        __frontend_reg_store_fpr(v31, __frontend_reg_load_fpr(v31));
        goto lab_0x80c7b7a;
    }
  lab_0x80c7d88:
    // 0x80c7d88
    __frontend_reg_store_fpr(v91, __frontend_reg_load_fpr(v91));
    __frontend_reg_store_fpr(v94, __frontend_reg_load_fpr(v94));
    __frontend_reg_store_fpr(v98, __frontend_reg_load_fpr(v98));
    int3_t v165 = v89 ^ -4; // 0x80c7d8c
    __frontend_reg_store_fpr(v165, __frontend_reg_load_fpr(v165));
    goto lab_0x80c7d90;
  lab_0x80c7d90:;
    int32_t mem = (int32_t)calloc(1, 164); // 0x80c7d9f
    int32_t v166 = node + 16; // 0x80c7dac
    int32_t v167 = mem + 16; // 0x80c7daf
    *(int32_t *)v167 = *(int32_t *)v166;
    int32_t v168 = mem + 20; // 0x80c7db2
    char * v169 = (char *)v168; // 0x80c7db2
    unsigned char v170 = *v6 % 2;
    *v169 = v170 | *v169 & -2;
    int32_t * v171; // 0x80c7990
    int32_t v172; // 0x80c7990
    int32_t v173; // 0x80c7990
    int32_t v174; // 0x80c7990
    int32_t v175; // 0x80c7990
    if (v170 == 0) {
        int32_t v176 = 0;
        int32_t v177 = 0;
        int32_t v178 = 0;
        int32_t v179 = *(int32_t *)(4 * v178 + v7);
        int32_t v180 = v178 + 1;
        int32_t v181; // 0x80c7990
        while (*(char *)(v178 + v49) == 0) {
            // 0x80c7fda
            *(int32_t *)(mem + 24 + 4 * v177) = v179;
            *(int32_t *)(v179 + 16) = mem;
            v181 = v176;
            if (v178 == 6) {
                // break (via goto) -> 0x80c7ff0
                goto lab_0x80c7ff0;
            }
            v177++;
            v178 = v180;
            v179 = *(int32_t *)(4 * v178 + v7);
            v180 = v178 + 1;
        }
        // 0x80c7fc0
        *(int32_t *)(4 * v176 + v7) = v179;
        int32_t v182 = v176 + 1; // 0x80c7fcb
        v181 = v182;
        while (v178 != 6) {
            // 0x80c7fd3
            v176 = v182;
            v178 = v180;
            v179 = *(int32_t *)(4 * v178 + v7);
            v180 = v178 + 1;
            while (*(char *)(v178 + v49) == 0) {
                // 0x80c7fda
                *(int32_t *)(mem + 24 + 4 * v177) = v179;
                *(int32_t *)(v179 + 16) = mem;
                v181 = v176;
                if (v178 == 6) {
                    // break (via goto) -> 0x80c7ff0
                    goto lab_0x80c7ff0;
                }
                v177++;
                v178 = v180;
                v179 = *(int32_t *)(4 * v178 + v7);
                v180 = v178 + 1;
            }
            // 0x80c7fc0
            *(int32_t *)(4 * v176 + v7) = v179;
            v182 = v176 + 1;
            v181 = v182;
        }
      lab_0x80c7ff0:;
        int32_t * v183 = (int32_t *)v5;
        v171 = v183;
        v172 = v181;
        v173 = 0;
        v174 = v180 & -256;
        v175 = *v183;
    } else {
        int32_t * v184 = (int32_t *)v5;
        float32_t v185 = 0.0f; // 0x80c7990
        float32_t v186 = 0.0f; // 0x80c7990
        int32_t v187 = 1; // 0x80c7990
        float32_t v188 = 0.0f; // 0x80c7990
        int32_t v189 = 1; // 0x80c7990
        int32_t v190 = 0; // 0x80c7990
        int32_t v191 = 0; // 0x80c7990
        int32_t v192 = node; // 0x80c7990
        int32_t v193 = 1; // 0x80c7990
        float32_t v194; // 0x80c7990
        float32_t v195; // 0x80c7990
        int32_t v196; // 0x80c7990
        int32_t v197; // 0x80c7990
        while (true) {
            int32_t v198 = v193;
            int32_t v199 = v192;
            int32_t v200 = v191;
            int32_t v201 = v190;
            int32_t v202 = v189;
            float32_t v203 = v188;
            int32_t v204 = v187;
            float32_t v205 = v186;
            float32_t v206 = v185;
            float32_t v207; // 0x80c7990
            float32_t v208; // 0x80c7990
            float32_t v209; // 0x80c7990
            int32_t v210; // 0x80c7990
            int32_t v211; // 0x80c7990
            int32_t v212; // 0x80c7990
            if (*(char *)(v200 + v49) != 0) {
                int32_t v213 = 20 * v201 + v166; // 0x80c7e1e
                *(int32_t *)(v213 + 8) = *(int32_t *)(v199 + 24);
                *(int32_t *)(v213 + 12) = *(int32_t *)(v199 + 28);
                *(int32_t *)(v213 + 16) = *(int32_t *)(v199 + 32);
                *(int32_t *)(v213 + 20) = *(int32_t *)(v199 + 36);
                *(int32_t *)(v213 + 24) = *(int32_t *)(v199 + 40);
                uint32_t v214 = *v184; // 0x80c7e43
                int32_t v215 = v201 + 1; // 0x80c7e78
                float32_t v216 = (v214 / 2 & v198) != 0 ? (float32_t)(v202 | (int32_t)v205) : v205; // 0x80c7e87
                v209 = v206;
                v207 = v216;
                v211 = v204;
                v208 = v203;
                v212 = 2 * v202;
                v210 = v215;
                v194 = v216;
                v195 = v203;
                v196 = v215;
                v197 = v214;
                if (v200 == 6) {
                    // break -> 0x80c7f28
                    break;
                }
            } else {
                int32_t v217 = 20 * (int32_t)v206 + v167; // 0x80c7eaf
                *(int32_t *)(v217 + 8) = *(int32_t *)(v199 + 24);
                *(int32_t *)(v217 + 12) = *(int32_t *)(v199 + 28);
                *(int32_t *)(v217 + 16) = *(int32_t *)(v199 + 32);
                *(int32_t *)(v217 + 20) = *(int32_t *)(v199 + 36);
                *(int32_t *)(v217 + 24) = *(int32_t *)(v199 + 40);
                uint32_t v218 = *v184; // 0x80c7ed4
                float32_t v219 = (v218 / 2 & v198) != 0 ? (float32_t)(v204 | (int32_t)v203) : v203; // 0x80c7f1c
                v209 = (int32_t)v206 + 1;
                v207 = v205;
                v211 = 2 * v204;
                v208 = v219;
                v212 = v202;
                v210 = v201;
                v194 = v205;
                v195 = v219;
                v196 = v201;
                v197 = v218;
                if (v200 == 6) {
                    // break -> 0x80c7f28
                    break;
                }
            }
            // 0x80c7e93
            v185 = v209;
            v186 = v207;
            v187 = v211;
            v188 = v208;
            v189 = v212;
            v190 = v210;
            v191 = v200 + 1;
            v192 = v199 + 20;
            v193 = 2 * v198;
        }
        // 0x80c7f28
        v171 = v184;
        v172 = v196;
        v173 = 2 * (int32_t)v195;
        v174 = (int32_t)v194 % 0x80000000;
        v175 = v197;
    }
    // 0x80c7f46
    *v171 = v175 % 2 | 2 * v174;
    int32_t * v220 = (int32_t *)v168; // 0x80c7f55
    *v220 = *v220 % 2 | v173;
    if (*v6 % 2 != 0) {
        if (v172 > 6) {
            // 0x80c7f89
            adjust_bounds((int32_t)&g231);
            adjust_bounds((int32_t)&g231);
            return mem;
        }
        int32_t v221 = 20 * v172 + v7; // 0x80c800e
        int32_t v222 = v172;
        *(int32_t *)v221 = 0;
        int32_t v223 = v222 + 1; // 0x80c801f
        v221 += 20;
        while (v222 != 6) {
            // 0x80c8010
            v222 = v223;
            *(int32_t *)v221 = 0;
            v223 = v222 + 1;
            v221 += 20;
        }
        // 0x80c7f89
        adjust_bounds((int32_t)&g231);
        adjust_bounds((int32_t)&g231);
        return mem;
    }
    if (v172 > 6) {
        // 0x80c7f89
        adjust_bounds((int32_t)&g231);
        adjust_bounds((int32_t)&g231);
        return mem;
    }
    int32_t v224 = 4 * v172 + v7; // 0x80c7990
    int32_t v225 = v172;
    *(int32_t *)v224 = 0;
    int32_t v226 = v225 + 1; // 0x80c7f87
    v224 += 4;
    while (v225 != 6) {
        // 0x80c7f78
        v225 = v226;
        *(int32_t *)v224 = 0;
        v226 = v225 + 1;
        v224 += 4;
    }
    // 0x80c7f89
    adjust_bounds((int32_t)&g231);
    adjust_bounds((int32_t)&g231);
    return mem;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c8050 - 0x80c8478
// Line range:    902 - 838
void __r_insert_node(int32_t node, int32_t query, int32_t manage, char force) {
    // 0x80c8050
    int32_t v1; // 0x80c8050
    int32_t v2 = v1 + 20; // 0x80c8062
    int32_t v3; // 0x80c8050
    int32_t v4; // 0x80c8050
    int32_t v5; // 0x80c8218
    if (*(char *)v2 % 2 == 0) {
        int32_t * v6 = (int32_t *)(v1 + 8);
        int32_t * v7; // 0x80c8050
        int32_t * v8; // 0x80c8050
        if ((char)node != 0) {
            int32_t v9 = *v6; // 0x80c8270
            int32_t * v10 = (int32_t *)(v1 + 8); // 0x80c8273
            if (v9 > *v10) {
                // 0x80c8278
                *v10 = v9;
            }
            int32_t * v11 = (int32_t *)(v1 + 4);
            int32_t v12 = *v11; // 0x80c827b
            int32_t * v13 = (int32_t *)(v1 + 4); // 0x80c827e
            if (v12 < *v13) {
                // 0x80c8283
                *v13 = v12;
            }
            int32_t * v14 = (int32_t *)(v1 + 12);
            int32_t v15 = *v14; // 0x80c8286
            int32_t * v16 = (int32_t *)(v1 + 12); // 0x80c8289
            v8 = v14;
            v7 = v11;
            if (v15 > *v16) {
                // 0x80c828e
                *v16 = v15;
                v8 = v14;
                v7 = v11;
            }
        } else {
            // 0x80c8210
            v8 = (int32_t *)(v1 + 12);
            v7 = (int32_t *)(v1 + 4);
        }
        // 0x80c8214
        v5 = v1 + 24;
        uint32_t v17 = 0;
        int32_t * v18 = (int32_t *)(4 * v17 + v5);
        int32_t v19 = *v18; // 0x80c8218
        while (v19 != 0) {
            // 0x80c8224
            if (*(int32_t *)v19 <= v1) {
                // 0x80c822a
                if (*(int32_t *)(v19 + 8) >= *v6) {
                    // 0x80c8232
                    if (*(int32_t *)(v19 + 4) <= *v7) {
                        // 0x80c823a
                        if (*(int32_t *)(v19 + 12) >= *v8) {
                            // 0x80c8242
                            __r_insert_node(0, (int32_t)&g231, (int32_t)&g231, (char)&g231);
                            return;
                        }
                    }
                }
            }
            // 0x80c8258
            if (v17 == 5) {
                // 0x80c8260
                v4 = *(int32_t *)v5;
                goto lab_0x80c82b9;
            }
            v17++;
            v18 = (int32_t *)(4 * v17 + v5);
            v19 = *v18;
        }
        int32_t v20 = *(int32_t *)v5; // 0x80c82a8
        v4 = v20;
        if (v17 < 6) {
            // 0x80c83ec
            v4 = v20;
            if (*(char *)(v20 + 20) % 2 != 0) {
                int32_t mem = (int32_t)calloc(1, 164); // 0x80c8408
                int32_t v21 = mem + 20; // 0x80c840d
                char * v22 = (char *)v21; // 0x80c840d
                *v22 = *v22 | 1;
                *v18 = mem;
                int32_t v23 = *v7; // 0x80c8423
                *(int32_t *)(mem + 32) = v23;
                int32_t v24 = *v6; // 0x80c8429
                *(int32_t *)(mem + 36) = v24;
                int32_t v25 = *v8; // 0x80c842f
                *(int32_t *)(mem + 4) = v23;
                *(int32_t *)(mem + 8) = v24;
                *(int32_t *)(mem + 40) = v25;
                *(int32_t *)(mem + 12) = v25;
                if (v1 != 0) {
                    int32_t * v26 = (int32_t *)v21; // 0x80c844b
                    *v26 = *v26 % 2 | 2;
                }
                // 0x80c80e2
                return;
            }
        }
        goto lab_0x80c82b9;
    } else {
        int32_t v27 = 1; // 0x80c8075
        int32_t v28; // 0x80c8050
        if (v1 == 0) {
            int32_t v29 = 0;
            v28 = v29;
            int32_t v30; // 0x80c8050
            while (*(int32_t *)(v30 + 24) != 0) {
                int32_t v31 = v29 + 1; // 0x80c80f7
                v30 += 20;
                if (v29 == 5) {
                    // 0x80c8102
                    *(int32_t *)(v1 + 152) = *(int32_t *)(v1 + 4);
                    *(int32_t *)(v1 + 156) = *(int32_t *)(v1 + 8);
                    *(int32_t *)(v1 + 160) = *(int32_t *)(v1 + 12);
                    v3 = v31;
                    goto lab_0x80c812b;
                }
                v29 = v31;
                v28 = v29;
            }
        } else {
            int32_t v32 = 0;
            int32_t v33 = v32; // 0x80c8082
            int32_t v34 = v27; // 0x80c8082
            int32_t v35; // 0x80c8050
            while (*(int32_t *)(v35 + 24) != 0) {
                int32_t v36 = v32 + 1; // 0x80c8084
                int32_t v37 = 2 * v27; // 0x80c8087
                v27 = v37;
                v35 += 20;
                v33 = v36;
                v34 = v37;
                if (v32 == 5) {
                    // break -> 0x80c8091
                    break;
                }
                v32 = v36;
                v33 = v32;
                v34 = v27;
            }
            int32_t * v38 = (int32_t *)v2; // 0x80c8091
            uint32_t v39 = *v38; // 0x80c8091
            *v38 = v39 & -2 | 2 * v34 | v39 % 2;
            v28 = v33;
        }
        int32_t v40 = 20 * v28 + v1; // 0x80c80a8
        int32_t * v41 = (int32_t *)(v1 + 4); // 0x80c80b8
        *(int32_t *)(v40 + 32) = *v41;
        int32_t * v42 = (int32_t *)(v1 + 8); // 0x80c80be
        *(int32_t *)(v40 + 36) = *v42;
        int32_t * v43 = (int32_t *)(v1 + 12); // 0x80c80c4
        *(int32_t *)(v40 + 40) = *v43;
        v3 = v28;
        if (v28 == 0) {
            // 0x80c80cc
            *(int32_t *)(v1 + 4) = *v41;
            *(int32_t *)(v1 + 8) = *v42;
            *(int32_t *)(v1 + 12) = *v43;
            // 0x80c80e2
            return;
        }
        goto lab_0x80c812b;
    }
  lab_0x80c82b9:;
    int32_t v44 = *(int32_t *)(v4 + 4); // 0x80c82f1
    int32_t v45 = *(int32_t *)(v1 + 28); // 0x80c8349
    int32_t v46 = 1; // 0x80c834f
    int32_t v47; // 0x80c8050
    if (v45 == 0) {
        // 0x80c83d0
        v47 = *(int32_t *)(v4 + 12) - v44;
        __r_insert_node(1, v47, (int32_t)&g231, (char)&g231);
        return;
    }
    int32_t v48 = v45;
    int32_t v49 = v46 + 1; // 0x80c83ba
    while (v46 != 5) {
        int32_t v50 = *(int32_t *)(4 * v49 + v5); // 0x80c8349
        v46 = v49;
        if (v50 == 0) {
            // break -> 0x80c83d0
            break;
        }
        v48 = v50;
        v49 = v46 + 1;
    }
    // 0x80c83d0
    v47 = *(int32_t *)(v48 + 12) - *(int32_t *)(v48 + 4);
    __r_insert_node(v49, v47, (int32_t)&g231, (char)&g231);
  lab_0x80c812b:
    // 0x80c812b
    if ((char)node != 0) {
        if (v1 < v3) {
            // branch -> 0x80c8137
        }
        int32_t v51 = *(int32_t *)(v1 + 8); // 0x80c8137
        int32_t * v52 = (int32_t *)(v1 + 8); // 0x80c813a
        if (v51 > *v52) {
            // 0x80c813f
            *v52 = v51;
        }
        int32_t v53 = *(int32_t *)(v1 + 4); // 0x80c8142
        int32_t * v54 = (int32_t *)(v1 + 4); // 0x80c8145
        if (v53 < *v54) {
            // 0x80c814a
            *v54 = v53;
        }
        int32_t v55 = *(int32_t *)(v1 + 12); // 0x80c814d
        int32_t * v56 = (int32_t *)(v1 + 12); // 0x80c8150
        if (v55 > *v56) {
            // 0x80c8155
            *v56 = v55;
        }
    }
    if (v3 < 6) {
        // 0x80c80e2
        return;
    }
    int32_t v57 = find_clusters(v1); // 0x80c8160
    int32_t v58 = *(int32_t *)(v1 + 16); // 0x80c8165
    int32_t v59 = v57; // 0x80c816a
    int32_t v60 = v58; // 0x80c816a
    int32_t v61 = v57; // 0x80c816a
    int32_t v62; // 0x80c8050
    if (v58 != 0) {
        int32_t v63; // 0x80c8050
        int32_t * v64; // 0x80c8050
        while (true) {
            int32_t v65 = v60;
            v63 = v59;
            int32_t v66 = 0;
            v64 = (int32_t *)(v65 + 24 + 4 * v66);
            if (*v64 == 0) {
                // break (via goto) -> 0x80c8298
                goto lab_0x80c8298;
            }
            int32_t v67 = v66 + 1; // 0x80c8180
            while (v66 != 5) {
                // 0x80c816e
                v66 = v67;
                v64 = (int32_t *)(v65 + 24 + 4 * v66);
                if (*v64 == 0) {
                    // break (via goto) -> 0x80c8298
                    goto lab_0x80c8298;
                }
                // 0x80c817a
                v67 = v66 + 1;
            }
            // 0x80c8182
            *(int32_t *)(v65 + 48) = v63;
            int32_t v68 = find_clusters(v65); // 0x80c818a
            int32_t v69 = *(int32_t *)(v65 + 16); // 0x80c818f
            v59 = v68;
            v60 = v69;
            v61 = v68;
            v62 = v65;
            if (v69 == 0) {
                goto lab_0x80c8196;
            }
        }
      lab_0x80c8298:
        // 0x80c8298
        *v64 = v63;
        return;
    }
  lab_0x80c8196:;
    int32_t * mem2 = calloc(1, 164); // 0x80c81aa
    int32_t v70 = (int32_t)mem2; // 0x80c81aa
    __asm_rep_movsd_memcpy((char *)mem2, (char *)v62, 41);
    if (*(char *)(v70 + 20) % 2 == 0) {
        for (int32_t i = 0; i < 6; i++) {
            int32_t v71 = *(int32_t *)(v70 + 24 + 4 * i); // 0x80c8460
            if (v71 != 0) {
                // 0x80c8468
                *(int32_t *)(v71 + 16) = v70;
            }
        }
    }
    int32_t v72 = v62 + 20; // 0x80c81c5
    char * v73 = (char *)v72; // 0x80c81c5
    *v73 = *v73 & -2;
    int32_t * v74 = (int32_t *)v72; // 0x80c81c9
    *v74 = *v74 % 2;
    *(int32_t *)(v62 + 28) = v70;
    *(int32_t *)(v61 + 16) = v62;
    *(int32_t *)(v62 + 24) = v61;
    *(int32_t *)(v70 + 16) = v62;
    *(int32_t *)(v62 + 32) = 0;
    *(int32_t *)(v62 + 36) = 0;
    *(int32_t *)(v62 + 40) = 0;
    *(int32_t *)(v62 + 44) = 0;
    *(int32_t *)(v62 + 48) = 0;
    adjust_bounds((int32_t)&g231);
    return;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c8480 - 0x80c84d2
// Line range:    1026 - 1039
void r_insert_entry(int32_t rtree, int32_t which, int32_t man) {
    int32_t v1 = *(int32_t *)rtree; // 0x80c848d
    int32_t v2 = 1; // 0x80c8493
    if (*(int32_t *)v1 <= *(int32_t *)which) {
        // 0x80c8495
        v2 = 1;
        if (*(int32_t *)(v1 + 8) >= *(int32_t *)(which + 8)) {
            // 0x80c849d
            v2 = 1;
            if (*(int32_t *)(v1 + 4) <= *(int32_t *)(which + 4)) {
                int32_t v3 = *(int32_t *)(v1 + 12); // 0x80c84a5
                int32_t v4 = *(int32_t *)(which + 12); // 0x80c84a8
                int32_t v5 = v3 - v4; // 0x80c84a8
                v2 = v5 < 0 != ((v5 ^ v3) & (v4 ^ v3)) < 0;
            }
        }
    }
    // 0x80c84bd
    __r_insert_node(v2, (int32_t)&g231, (int32_t)&g231, (char)&g231);
    int32_t * v6 = (int32_t *)(rtree + 4); // 0x80c84c8
    *v6 = *v6 + 1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/rtree.c
// Address range: 0x80c84e0 - 0x80c855d
// Line range:    446 - 469
int32_t r_create_tree(int32_t boxlist, int32_t N, int32_t manage) {
    int32_t * mem = calloc(1, 8); // 0x80c84fe
    int32_t result = (int32_t)mem; // 0x80c84fe
    int32_t mem2 = (int32_t)calloc(1, 164); // 0x80c8514
    char * v1 = (char *)(mem2 + 20); // 0x80c8519
    *v1 = *v1 | 1;
    *(int32_t *)(mem2 + 16) = 0;
    *mem = mem2;
    if (N < 1) {
        // 0x80c8553
        return result;
    }
    int32_t v2 = 0; // 0x80c8528
    r_insert_entry(result, *(int32_t *)(4 * v2 + boxlist), manage);
    v2++;
    while (v2 != N) {
        // 0x80c8530
        r_insert_entry(result, *(int32_t *)(4 * v2 + boxlist), manage);
        v2++;
    }
    // 0x80c8553
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80c9bc0 - 0x80ca380
// Line range:    1363 - 1527
int32_t SearchObjectByID(int32_t Base, char ** Result1, char ** Result2, char ** Result3, int32_t ID2, int32_t type) {
    int32_t * v1; // 0x80c9bc0
    int32_t * v2; // 0x80c9bc0
    switch (type) {
        case 0x1000: {
            goto lab_0x80c9d00;
        }
        case 4: {
            goto lab_0x80c9d00;
        }
        case 0x4000: {
            // 0x80c9bc0
            v1 = (int32_t *)(*(int32_t *)(PCB + 0x220c) + 24);
            goto lab_0x80c9da8;
        }
        case 16: {
            // 0x80c9bc0
            v2 = (int32_t *)(*(int32_t *)(PCB + 0x220c) + 24);
            goto lab_0x80ca010;
        }
        default: {
            goto lab_0x80c9bfe;
        }
    }
  lab_0x80c9fb0_2:;
    // 0x80c9fb0
    int32_t v3; // 0x80c9bc0
    *(int32_t *)Result1 = v3;
    int32_t v4; // 0x80c9bc0
    int32_t v5 = v4; // 0x80c9fb3
    goto lab_0x80c9fb5;
  lab_0x80c9fd0_2:
    // 0x80c9fd0
    *(int32_t *)Result1 = v3;
    int32_t v6; // 0x80c9bc0
    int32_t v7 = v6; // 0x80c9fd3
    goto lab_0x80c9fd5;
  lab_0x80ca2e4_2:;
    // 0x80ca2e4
    int32_t v8; // 0x80c9bc0
    *(int32_t *)Result1 = v8;
    int32_t v9; // 0x80c9bc0
    *(int32_t *)Result3 = v9;
    *(int32_t *)Result2 = v9;
    int32_t result = 0x2000; // 0x80ca2f8
    goto lab_0x80c9cf6;
  lab_0x80ca2fd_2:
    // 0x80ca2fd
    *(int32_t *)Result1 = v8;
    int32_t v10; // 0x80c9bc0
    *(int32_t *)Result3 = v10;
    *(int32_t *)Result2 = v10;
    result = 0x8000;
    goto lab_0x80c9cf6;
  lab_0x80ca34e_2:
    // 0x80ca34e
    *(int32_t *)Result1 = v8;
    int32_t v11; // 0x80c9bc0
    *(int32_t *)Result3 = v11;
    *(int32_t *)Result2 = v11;
    result = 256;
    goto lab_0x80c9cf6;
  lab_0x80ca1f0_2:
    // 0x80ca1f0
    *(int32_t *)Result1 = v8;
    int32_t v12; // 0x80c9bc0
    *(int32_t *)Result3 = v12;
    *(int32_t *)Result2 = v12;
    result = 512;
    goto lab_0x80c9cf6;
  lab_0x80ca1a8:
    if (type == 512) {
        uint32_t v13 = *(int32_t *)(v8 + 232); // 0x80ca1b2
        if (v13 != 0) {
            int32_t v14 = *(int32_t *)(v8 + 260); // 0x80ca1c3
            v12 = v14;
            if (*(int32_t *)(v14 + 16) == ID2) {
                goto lab_0x80ca1f0_2;
            }
            int32_t v15 = v14; // 0x80ca1de
            if (v13 > 1) {
                int32_t v16 = v15 + 104;
                v12 = v16;
                if (*(int32_t *)(v15 + 120) == ID2) {
                    goto lab_0x80ca1f0_2;
                }
                int32_t v17 = 2; // 0x80ca1d8
                v15 = v16;
                int32_t v18 = v17; // 0x80ca1de
                while (v13 > v17) {
                    // 0x80ca1e4
                    v16 = v15 + 104;
                    v12 = v16;
                    if (*(int32_t *)(v15 + 120) == ID2) {
                        goto lab_0x80ca1f0_2;
                    }
                    // 0x80ca1db
                    v17 = v18 + 1;
                    v15 = v16;
                    v18 = v17;
                }
            }
        }
    }
    goto lab_0x80ca128;
  lab_0x80ca128:;
    int32_t v19; // 0x80c9bc0
    if (v19 == 0) {
        // 0x80ca0e7
        Message("hace: Internal error, search for ID %d failed\n", ID2);
        // 0x80c9cf6
        return 0;
    }
    // 0x80ca132
    v19--;
    int32_t v20; // 0x80c9bc0
    int32_t v21 = v20 - 300; // 0x80ca141
    int32_t v22 = v20; // 0x80ca141
    int32_t v23 = v20; // 0x80ca141
    if (*(int32_t *)(v20 + 16) == ID2) {
        goto lab_0x80ca147;
    }
    goto lab_0x80c9f0d;
  lab_0x80ca090_2:;
    // 0x80ca090
    int32_t v45; // 0x80c9bc0
    *(int32_t *)Result1 = v45;
    int32_t v46; // 0x80c9bc0
    *(int32_t *)Result3 = v46;
    *(int32_t *)Result2 = v46;
    result = 16;
    goto lab_0x80c9cf6;
  lab_0x80ca2c5_2:;
    // 0x80ca2c5
    int32_t v47; // 0x80c9bc0
    *(int32_t *)Result1 = v47;
    int32_t v48; // 0x80c9bc0
    *(int32_t *)Result3 = v48;
    *(int32_t *)Result2 = v48;
    result = 8;
    goto lab_0x80c9cf6;
  lab_0x80c9cdc_2:
    // 0x80c9cdc
    *(int32_t *)Result1 = v47;
    int32_t v49; // 0x80c9bc0
    *(int32_t *)Result2 = v49;
    int32_t v50; // 0x80c9bc0
    *(int32_t *)Result3 = v50;
    result = 2048;
    goto lab_0x80c9cf6;
  lab_0x80c9e52:
    if (type != 0x1000) {
        goto lab_0x80c9ec2;
    } else {
        goto lab_0x80c9e58;
    }
  lab_0x80c9d00:;
    int32_t * v51 = (int32_t *)(*(int32_t *)(PCB + 0x220c) + 24);
    uint32_t v52 = *v51 + 2; // 0x80c9d15
    if (v52 != 0) {
        int32_t v53 = 0; // 0x80c9d21
        v3 = Base + 76;
        int32_t v54 = *(int32_t *)(v3 + 4); // 0x80c9d28
        int32_t v55; // 0x80c9bc0
        int32_t v56; // 0x80c9bc0
        int32_t v57; // 0x80c9bc0
        int32_t v58; // 0x80c9bc0
        int32_t v59; // 0x80c9d2b
        int32_t v60; // 0x80c9d36
        int32_t v61; // 0x80c9d39
        if (v54 != 0) {
            // 0x80c9d33
            v59 = v54 - 1;
            v60 = *(int32_t *)(v3 + 36);
            v61 = v60 + 88 * v59;
            v58 = v61;
            if (*(int32_t *)(v61 + 16) == ID2) {
                // 0x80c9f90
                *(int32_t *)Result1 = v3;
                *(int32_t *)Result3 = v58;
                *(int32_t *)Result2 = v58;
                return 4;
            }
            // 0x80c9d45
            v4 = v61;
            if (*(int32_t *)(v61 + 60) == ID2) {
                goto lab_0x80c9fb0_2;
            }
            // 0x80c9d4e
            v6 = v61;
            if (*(int32_t *)(v61 + 80) == ID2) {
                goto lab_0x80c9fd0_2;
            }
            // 0x80c9d57
            v56 = 88 * v54 - 176 + v60;
            v55 = v59;
            while (v55 != 0) {
                // 0x80c9d68
                v57 = v56;
                v58 = v57;
                if (*(int32_t *)(v57 + 16) == ID2) {
                    // 0x80c9f90
                    *(int32_t *)Result1 = v3;
                    *(int32_t *)Result3 = v58;
                    *(int32_t *)Result2 = v58;
                    return 4;
                }
                // 0x80c9d73
                v4 = v57;
                if (*(int32_t *)(v57 + 60) == ID2) {
                    goto lab_0x80c9fb0_2;
                }
                // 0x80c9d7c
                v56 = v57 - 88;
                v6 = v57;
                if (*(int32_t *)(v57 + 80) == ID2) {
                    goto lab_0x80c9fd0_2;
                }
                v55--;
            }
        }
        // 0x80c9d92
        v53++;
        while (v53 < v52) {
            // 0x80c9da2
            v3 += 92;
            v54 = *(int32_t *)(v3 + 4);
            if (v54 != 0) {
                // 0x80c9d33
                v59 = v54 - 1;
                v60 = *(int32_t *)(v3 + 36);
                v61 = v60 + 88 * v59;
                v58 = v61;
                if (*(int32_t *)(v61 + 16) == ID2) {
                    // 0x80c9f90
                    *(int32_t *)Result1 = v3;
                    *(int32_t *)Result3 = v58;
                    *(int32_t *)Result2 = v58;
                    return 4;
                }
                // 0x80c9d45
                v4 = v61;
                if (*(int32_t *)(v61 + 60) == ID2) {
                    goto lab_0x80c9fb0_2;
                }
                // 0x80c9d4e
                v6 = v61;
                if (*(int32_t *)(v61 + 80) == ID2) {
                    goto lab_0x80c9fd0_2;
                }
                // 0x80c9d57
                v56 = 88 * v54 - 176 + v60;
                v55 = v59;
                while (v55 != 0) {
                    // 0x80c9d68
                    v57 = v56;
                    v58 = v57;
                    if (*(int32_t *)(v57 + 16) == ID2) {
                        // 0x80c9f90
                        *(int32_t *)Result1 = v3;
                        *(int32_t *)Result3 = v58;
                        *(int32_t *)Result2 = v58;
                        return 4;
                    }
                    // 0x80c9d73
                    v4 = v57;
                    if (*(int32_t *)(v57 + 60) == ID2) {
                        goto lab_0x80c9fb0_2;
                    }
                    // 0x80c9d7c
                    v56 = v57 - 88;
                    v6 = v57;
                    if (*(int32_t *)(v57 + 80) == ID2) {
                        goto lab_0x80c9fd0_2;
                    }
                    v55--;
                }
            }
            // 0x80c9d92
            v53++;
        }
    }
    // 0x80c9be7
    v1 = v51;
    v2 = v51;
    switch (type) {
        case 0x4000: {
            goto lab_0x80c9da8;
        }
        case 16: {
            goto lab_0x80ca010;
        }
        default: {
            goto lab_0x80c9bfe;
        }
    }
  lab_0x80c9bfe:
    switch (type) {
        case 2048: {
            goto lab_0x80c9c0f;
        }
        case 8: {
            goto lab_0x80c9c0f;
        }
        case 1: {
            goto lab_0x80ca209;
        }
        case 32: {
            goto lab_0x80c9e58;
        }
        default: {
            goto lab_0x80c9e52;
        }
    }
  lab_0x80c9c0f:;
    uint32_t v62 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 24) + 2; // 0x80c9c27
    if (v62 != 0) {
        int32_t v63 = 0; // 0x80c9c33
        v47 = Base + 76;
        int32_t v64 = *(int32_t *)(v47 + 12); // 0x80c9c3d
        int32_t v65; // 0x80c9bc0
        int32_t v66; // 0x80c9bc0
        int32_t v67; // 0x80c9bc0
        int32_t v68; // 0x80c9bc0
        int32_t v69; // 0x80c9bc0
        int32_t v70; // 0x80c9bc0
        int32_t v71; // 0x80c9c40
        int32_t v72; // 0x80c9c4f
        int32_t v73; // 0x80c9c55
        int32_t v74; // 0x80c9c98
        int32_t v75; // 0x80c9c9b
        int32_t v76; // 0x80c9ca9
        int32_t v77; // 0x80c9cac
        if (v64 != 0) {
            // 0x80c9c4f
            v71 = v64 - 1;
            v72 = *(int32_t *)(v47 + 44);
            v73 = v72 + 60 * v71;
            v48 = v73;
            if (*(int32_t *)(v73 + 16) == ID2) {
                goto lab_0x80ca2c5_2;
            }
            // 0x80c9c64
            v70 = v73;
            v68 = 60 * v64 - 120 + v72;
            v69 = v71;
            if (type == 2048) {
                // 0x80c9c95
                v49 = v70;
                v74 = *(int32_t *)(v49 + 36);
                if (v74 != 0) {
                    // 0x80c9ca3
                    v75 = v74 - 1;
                    v76 = *(int32_t *)(v49 + 56);
                    v77 = v76 + 20 * v75;
                    v50 = v77;
                    if (*(int32_t *)(v77 + 16) == ID2) {
                        goto lab_0x80c9cdc_2;
                    }
                    // 0x80c9cb7
                    v66 = 20 * v74 - 40 + v76;
                    v65 = v75;
                    while (v65 != 0) {
                        // 0x80c9cd0
                        v67 = v66;
                        v66 = v67 - 20;
                        v50 = v67;
                        if (*(int32_t *)(v67 + 16) == ID2) {
                            goto lab_0x80c9cdc_2;
                        }
                        v65--;
                    }
                }
            }
            while (v69 != 0) {
                // 0x80c9c7e
                v70 = v68;
                v48 = v68;
                if (*(int32_t *)(v68 + 16) == ID2) {
                    goto lab_0x80ca2c5_2;
                }
                v68 -= 60;
                v69--;
                if (type == 2048) {
                    // 0x80c9c95
                    v49 = v70;
                    v74 = *(int32_t *)(v49 + 36);
                    if (v74 != 0) {
                        // 0x80c9ca3
                        v75 = v74 - 1;
                        v76 = *(int32_t *)(v49 + 56);
                        v77 = v76 + 20 * v75;
                        v50 = v77;
                        if (*(int32_t *)(v77 + 16) == ID2) {
                            goto lab_0x80c9cdc_2;
                        }
                        // 0x80c9cb7
                        v66 = 20 * v74 - 40 + v76;
                        v65 = v75;
                        while (v65 != 0) {
                            // 0x80c9cd0
                            v67 = v66;
                            v66 = v67 - 20;
                            v50 = v67;
                            if (*(int32_t *)(v67 + 16) == ID2) {
                                goto lab_0x80c9cdc_2;
                            }
                            v65--;
                        }
                    }
                }
            }
        }
        while (v63 + 1 < v62) {
            // 0x80ca2a9
            v63++;
            // 0x80ca2b9
            v47 += 92;
            v64 = *(int32_t *)(v47 + 12);
            if (v64 != 0) {
                // 0x80c9c4f
                v71 = v64 - 1;
                v72 = *(int32_t *)(v47 + 44);
                v73 = v72 + 60 * v71;
                v48 = v73;
                if (*(int32_t *)(v73 + 16) == ID2) {
                    goto lab_0x80ca2c5_2;
                }
                // 0x80c9c64
                v70 = v73;
                v68 = 60 * v64 - 120 + v72;
                v69 = v71;
                if (type == 2048) {
                    // 0x80c9c95
                    v49 = v70;
                    v74 = *(int32_t *)(v49 + 36);
                    if (v74 != 0) {
                        // 0x80c9ca3
                        v75 = v74 - 1;
                        v76 = *(int32_t *)(v49 + 56);
                        v77 = v76 + 20 * v75;
                        v50 = v77;
                        if (*(int32_t *)(v77 + 16) == ID2) {
                            goto lab_0x80c9cdc_2;
                        }
                        // 0x80c9cb7
                        v66 = 20 * v74 - 40 + v76;
                        v65 = v75;
                        while (v65 != 0) {
                            // 0x80c9cd0
                            v67 = v66;
                            v66 = v67 - 20;
                            v50 = v67;
                            if (*(int32_t *)(v67 + 16) == ID2) {
                                goto lab_0x80c9cdc_2;
                            }
                            v65--;
                        }
                    }
                }
                while (v69 != 0) {
                    // 0x80c9c7e
                    v70 = v68;
                    v48 = v68;
                    if (*(int32_t *)(v68 + 16) == ID2) {
                        goto lab_0x80ca2c5_2;
                    }
                    v68 -= 60;
                    v69--;
                    if (type == 2048) {
                        // 0x80c9c95
                        v49 = v70;
                        v74 = *(int32_t *)(v49 + 36);
                        if (v74 != 0) {
                            // 0x80c9ca3
                            v75 = v74 - 1;
                            v76 = *(int32_t *)(v49 + 56);
                            v77 = v76 + 20 * v75;
                            v50 = v77;
                            if (*(int32_t *)(v77 + 16) == ID2) {
                                goto lab_0x80c9cdc_2;
                            }
                            // 0x80c9cb7
                            v66 = 20 * v74 - 40 + v76;
                            v65 = v75;
                            while (v65 != 0) {
                                // 0x80c9cd0
                                v67 = v66;
                                v66 = v67 - 20;
                                v50 = v67;
                                if (*(int32_t *)(v67 + 16) == ID2) {
                                    goto lab_0x80c9cdc_2;
                                }
                                v65--;
                            }
                        }
                    }
                }
            }
        }
    }
    switch (type) {
        case 1: {
            goto lab_0x80ca209;
        }
        case 32: {
            goto lab_0x80c9e58;
        }
        default: {
            goto lab_0x80c9e52;
        }
    }
  lab_0x80ca209:;
    uint32_t v78 = *(int32_t *)Base; // 0x80ca20c
    int32_t v79; // 0x80c9bc0
    if (v78 == 0) {
        goto lab_0x80c9e52;
    } else {
        int32_t v80 = *(int32_t *)(Base + 28); // 0x80ca216
        v79 = v80;
        if (*(int32_t *)(v80 + 16) != ID2) {
            int32_t v81 = v80; // 0x80ca22d
            int32_t v82 = 1; // 0x80ca22d
            if (v78 > 1) {
                int32_t v83 = v81 + 76;
                v79 = v83;
                while (*(int32_t *)(v81 + 92) != ID2) {
                    int32_t v84 = v82 + 1; // 0x80ca228
                    v81 = v83;
                    v82 = v84;
                    if (v78 <= v84) {
                        goto lab_0x80c9e52;
                    }
                    v83 = v81 + 76;
                    v79 = v83;
                }
                goto lab_0x80ca23f;
            } else {
                goto lab_0x80c9e52;
            }
        } else {
            goto lab_0x80ca23f;
        }
    }
  lab_0x80c9e58:;
    int32_t v85 = *(int32_t *)(Base + 16); // 0x80c9e5b
    if (v85 != 0) {
        int32_t v86 = v85 - 1; // 0x80c9e5e
        int32_t v87 = *(int32_t *)(Base + 36); // 0x80c9e69
        int32_t v88 = v87 + 92 * v86; // 0x80c9e6c
        int32_t v89 = v88; // 0x80c9e72
        if (*(int32_t *)(v88 + 16) == ID2) {
          lab_0x80ca316:
            // 0x80ca316
            *(int32_t *)Result3 = v89;
            *(int32_t *)Result2 = v89;
            *(int32_t *)Result1 = v89;
            // 0x80c9cf6
            return 32;
        }
        int32_t v90 = v88; // 0x80c9e7b
        if (*(int32_t *)(v88 + 60) == ID2) {
          lab_0x80ca32f:
            // 0x80ca32f
            *(int32_t *)Result1 = 0;
            v5 = v90;
          lab_0x80c9fb5:
            // 0x80c9fb5
            *(int32_t *)Result2 = v5;
            *(int32_t *)Result3 = v5 + 44;
            return 0x1000;
        }
        int32_t v91 = v88; // 0x80c9e84
        if (*(int32_t *)(v88 + 80) == ID2) {
          lab_0x80ca33d:
            // 0x80ca33d
            *(int32_t *)Result1 = 0;
            v7 = v91;
          lab_0x80c9fd5:
            // 0x80c9fd5
            *(int32_t *)Result2 = v7;
            *(int32_t *)Result3 = v7 + 64;
            return 0x1000;
        }
        int32_t v92 = v86; // 0x80c9e94
        int32_t v93 = 92 * v85 - 184 + v87; // 0x80c9e94
        while (v92 != 0) {
            int32_t v94 = v93;
            v89 = v94;
            if (*(int32_t *)(v94 + 16) == ID2) {
                goto lab_0x80ca316;
            }
            // 0x80c9ea3
            v90 = v94;
            if (*(int32_t *)(v94 + 60) == ID2) {
                goto lab_0x80ca32f;
            }
            // 0x80c9eac
            v92--;
            v93 = v94 - 92;
            v91 = v94;
            if (*(int32_t *)(v94 + 80) == ID2) {
                goto lab_0x80ca33d;
            }
        }
    }
    goto lab_0x80c9ec2;
  lab_0x80c9da8:;
    uint32_t v99 = *v1 + 2; // 0x80c9dbd
    if (v99 != 0) {
        int32_t v100 = 0; // 0x80c9dc9
        int32_t v101 = Base + 76;
        int32_t v102 = *(int32_t *)(v101 + 16); // 0x80c9dd0
        int32_t v103; // 0x80c9bc0
        int32_t v104; // 0x80c9bc0
        int32_t v105; // 0x80c9bc0
        int32_t v106; // 0x80c9bc0
        int32_t v107; // 0x80c9dd3
        int32_t v108; // 0x80c9ddb
        int32_t v109; // 0x80c9de6
        if (v102 != 0) {
            // 0x80c9ddb
            v107 = v102 - 1;
            v108 = *(int32_t *)(v101 + 48);
            v109 = v108 + 68 * v107;
            v106 = v109;
            if (*(int32_t *)(v109 + 16) == ID2) {
                // 0x80c9ff0
                *(int32_t *)Result1 = v101;
                *(int32_t *)Result3 = v106;
                *(int32_t *)Result2 = v106;
                return 0x4000;
            }
            // 0x80c9df2
            v104 = 68 * v102 - 136 + v108;
            v103 = v107;
            while (v103 != 0) {
                // 0x80c9e08
                v105 = v104;
                v104 = v105 - 68;
                v106 = v105;
                if (*(int32_t *)(v105 + 16) == ID2) {
                    // 0x80c9ff0
                    *(int32_t *)Result1 = v101;
                    *(int32_t *)Result3 = v106;
                    *(int32_t *)Result2 = v106;
                    return 0x4000;
                }
                v103--;
            }
        }
        // 0x80c9e20
        v100++;
        while (v100 < v99) {
            // 0x80c9e2c
            v101 += 92;
            v102 = *(int32_t *)(v101 + 16);
            if (v102 != 0) {
                // 0x80c9ddb
                v107 = v102 - 1;
                v108 = *(int32_t *)(v101 + 48);
                v109 = v108 + 68 * v107;
                v106 = v109;
                if (*(int32_t *)(v109 + 16) == ID2) {
                    // 0x80c9ff0
                    *(int32_t *)Result1 = v101;
                    *(int32_t *)Result3 = v106;
                    *(int32_t *)Result2 = v106;
                    return 0x4000;
                }
                // 0x80c9df2
                v104 = 68 * v102 - 136 + v108;
                v103 = v107;
                while (v103 != 0) {
                    // 0x80c9e08
                    v105 = v104;
                    v104 = v105 - 68;
                    v106 = v105;
                    if (*(int32_t *)(v105 + 16) == ID2) {
                        // 0x80c9ff0
                        *(int32_t *)Result1 = v101;
                        *(int32_t *)Result3 = v106;
                        *(int32_t *)Result2 = v106;
                        return 0x4000;
                    }
                    v103--;
                }
            }
            // 0x80c9e20
            v100++;
        }
    }
    goto lab_0x80c9e52;
  lab_0x80ca010:;
    uint32_t v110 = *v2 + 2; // 0x80ca025
    if (v110 != 0) {
        int32_t v111 = 0; // 0x80ca031
        v45 = Base + 76;
        int32_t v112 = *(int32_t *)(v45 + 8); // 0x80ca038
        int32_t v113; // 0x80c9bc0
        int32_t v114; // 0x80c9bc0
        int32_t v115; // 0x80c9bc0
        int32_t v116; // 0x80ca03b
        int32_t v117; // 0x80ca046
        int32_t v118; // 0x80ca049
        if (v112 != 0) {
            // 0x80ca043
            v116 = v112 - 1;
            v117 = *(int32_t *)(v45 + 40);
            v118 = v117 + 60 * v116;
            v46 = v118;
            if (*(int32_t *)(v118 + 16) == ID2) {
                goto lab_0x80ca090_2;
            }
            // 0x80ca051
            v113 = v116;
            v114 = 60 * v112 - 120 + v117;
            while (v113 != 0) {
                // 0x80ca060
                v115 = v114;
                v113--;
                v114 = v115 - 60;
                if (*(int32_t *)(v115 + 16) == ID2) {
                    goto lab_0x80ca090_2;
                }
            }
        }
        // 0x80ca074
        v111++;
        while (v111 < v110) {
            // 0x80ca084
            v45 += 92;
            v112 = *(int32_t *)(v45 + 8);
            if (v112 != 0) {
                // 0x80ca043
                v116 = v112 - 1;
                v117 = *(int32_t *)(v45 + 40);
                v118 = v117 + 60 * v116;
                v46 = v118;
                if (*(int32_t *)(v118 + 16) == ID2) {
                    goto lab_0x80ca090_2;
                }
                // 0x80ca051
                v113 = v116;
                v114 = 60 * v112 - 120 + v117;
                while (v113 != 0) {
                    // 0x80ca060
                    v115 = v114;
                    v113--;
                    v114 = v115 - 60;
                    v46 = v115;
                    if (*(int32_t *)(v115 + 16) == ID2) {
                        goto lab_0x80ca090_2;
                    }
                }
            }
            // 0x80ca074
            v111++;
        }
    }
    goto lab_0x80c9e52;
  lab_0x80c9ec2:;
    int32_t v95; // 0x80c9ed6
    switch (type) {
        case 0x8000: {
        }
        case 0x2000: {
        }
        case 1024: {
        }
        case 512: {
        }
        case 256: {
        }
        case 2: {
            // 0x80c9ed3
            v95 = *(int32_t *)(Base + 8);
            if (v95 == 0) {
                // 0x80ca0e7
                Message("hace: Internal error, search for ID %d failed\n", ID2);
                // 0x80c9cf6
                return 0;
            }
            // break -> 0x80c9ee8
            break;
        }
        default: {
            // 0x80ca0e7
            Message("hace: Internal error, search for ID %d failed\n", ID2);
            // 0x80c9cf6
            return 0;
        }
    }
    int32_t v96 = v95 - 1; // 0x80c9ed9
    int32_t v97 = *(int32_t *)(Base + 32); // 0x80c9eee
    int32_t v98 = v97 + 300 * v96; // 0x80c9ef1
    v23 = v98;
    if (*(int32_t *)(v98 + 16) == ID2) {
      lab_0x80ca147:
        // 0x80ca147
        *(int32_t *)Result3 = v23;
        *(int32_t *)Result2 = v23;
        *(int32_t *)Result1 = v23;
        // 0x80c9cf6
        return 2;
    }
    // 0x80c9efd
    v19 = v96;
    v21 = 300 * v95 - 600 + v97;
    v22 = v98;
    int32_t v38; // 0x80c9bc0
    while (true) {
      lab_0x80c9f0d:
        // 0x80c9f0d
        v8 = v22;
        v20 = v21;
        switch (type) {
            case 0x2000: {
                int32_t v24 = *(int32_t *)(v8 + 240); // 0x80ca160
                if (v24 != 0) {
                    int32_t v25 = v24 - 1; // 0x80ca166
                    int32_t v26 = *(int32_t *)(v8 + 264); // 0x80ca171
                    int32_t v27 = v26 + 88 * v25; // 0x80ca177
                    v9 = v27;
                    if (*(int32_t *)(v27 + 16) == ID2) {
                        goto lab_0x80ca2e4_2;
                    }
                    int32_t v28 = 88 * v24 - 176 + v26; // 0x80ca18d
                    int32_t v29 = v25;
                    while (v29 != 0) {
                        int32_t v30 = v28;
                        v28 = v30 - 88;
                        v9 = v30;
                        if (*(int32_t *)(v30 + 16) == ID2) {
                            goto lab_0x80ca2e4_2;
                        }
                        v29--;
                    }
                }
                goto lab_0x80ca1a8;
            }
            case 0x8000: {
                int32_t v31 = *(int32_t *)(v8 + 248); // 0x80ca258
                if (v31 != 0) {
                    int32_t v32 = v31 - 1; // 0x80ca25e
                    int32_t v33 = *(int32_t *)(v8 + 268); // 0x80ca26a
                    int32_t v34 = v33 + 68 * v32; // 0x80ca278
                    v10 = v34;
                    if (*(int32_t *)(v34 + 16) == ID2) {
                        goto lab_0x80ca2fd_2;
                    }
                    int32_t v35 = 68 * v31 - 136 + v33; // 0x80ca28e
                    int32_t v36 = v32;
                    while (v36 != 0) {
                        int32_t v37 = v35;
                        v35 = v37 - 68;
                        v10 = v37;
                        if (*(int32_t *)(v37 + 16) == ID2) {
                            goto lab_0x80ca2fd_2;
                        }
                        v36--;
                    }
                }
                goto lab_0x80ca1a8;
            }
            case 1024: {
                // 0x80ca0fe
                if (*(int32_t *)(v8 + 172) == ID2) {
                    // break -> 0x80ca367
                    break;
                }
                // 0x80ca110
                if (*(int32_t *)(v8 + 112) == ID2) {
                    // 0x80ca367
                    v38 = v8 + 96;
                    goto lab_0x80ca367_3;
                }
                // 0x80ca11c
                if (*(int32_t *)(v8 + 52) == ID2) {
                    // 0x80ca367
                    v38 = v8 + 36;
                    goto lab_0x80ca367_3;
                }
                goto lab_0x80ca128;
            }
            default: {
                if (type != 256) {
                    goto lab_0x80ca1a8;
                } else {
                    uint32_t v39 = *(int32_t *)(v8 + 224); // 0x80c9f46
                    if (v39 != 0) {
                        int32_t v40 = *(int32_t *)(v8 + 256); // 0x80c9f54
                        v11 = v40;
                        if (*(int32_t *)(v40 + 16) == ID2) {
                            goto lab_0x80ca34e_2;
                        }
                        int32_t v41 = v40; // 0x80c9f85
                        if (v39 > 1) {
                            int32_t v42 = v41 + 76;
                            v11 = v42;
                            if (*(int32_t *)(v41 + 92) == ID2) {
                                goto lab_0x80ca34e_2;
                            }
                            int32_t v43 = 2; // 0x80c9f80
                            v41 = v42;
                            int32_t v44 = v43; // 0x80c9f85
                            while (v43 < v39) {
                                // 0x80c9f70
                                v42 = v41 + 76;
                                v11 = v42;
                                if (*(int32_t *)(v41 + 92) == ID2) {
                                    goto lab_0x80ca34e_2;
                                }
                                // 0x80c9f83
                                v43 = v44 + 1;
                                v41 = v42;
                                v44 = v43;
                            }
                        }
                    }
                    goto lab_0x80ca128;
                }
            }
        }
    }
    // 0x80ca367
    v38 = v8 + 156;
    goto lab_0x80ca367_3;
  lab_0x80ca367_3:
    // 0x80ca367
    *(int32_t *)Result1 = v8;
    *(int32_t *)Result3 = v38;
    *(int32_t *)Result2 = v38;
    // 0x80c9cf6
    return 1024;
  lab_0x80ca23f:
    // 0x80ca23f
    *(int32_t *)Result3 = v79;
    *(int32_t *)Result2 = v79;
    *(int32_t *)Result1 = v79;
    result = 1;
  lab_0x80c9cf6:
    // 0x80c9cf6
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca380 - 0x80ca40c
// Line range:    300 - 316
char SearchRatLineByLocation(int32_t locked, int32_t Line, int32_t Dummy1, int32_t Dummy2) {
    int32_t v1[8]; // 0x80ca3b9
    struct __jmp_buf_tag v2; // 0x80ca3b9
    struct __jmp_buf_tag env[1]; // 0x80ca3b9
    // 0x80ca380
    int32_t v3; // bp-172, 0x80ca380
    v1[0] = &v3;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    if (_setjmp(env) != 0) {
        // 0x80ca3c9
        return 1;
    }
    int32_t v4 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 68); // 0x80ca3fd
    int32_t v5; // bp-192, 0x80ca380
    r_search(v4, (int32_t)&SearchBox, 0, 0x80cb350, (char *)&v5);
    return 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca410 - 0x80ca4be
// Line range:    130 - 151
char SearchViaByLocation(int32_t locked, int32_t Via, int32_t Dummy1, int32_t Dummy2) {
    int32_t v1[8]; // 0x80ca459
    struct __jmp_buf_tag v2; // 0x80ca459
    struct __jmp_buf_tag env[1]; // 0x80ca459
    // 0x80ca410
    if (*(char *)(PCB + 34) == 0) {
        // 0x80ca467
        return 0;
    }
    // 0x80ca429
    int32_t v3; // bp-172, 0x80ca410
    v1[0] = &v3;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    if (_setjmp(env) != 0) {
        // 0x80ca467
        return 1;
    }
    int32_t v4 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 40); // 0x80ca4a7
    int32_t v5; // bp-192, 0x80ca410
    r_search(v4, (int32_t)&SearchBox, 0, 0x80cb410, (char *)&v5);
    return 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca4c0 - 0x80ca56e
// Line range:    158 - 177
char SearchPinByLocation(int32_t locked, int32_t Element, int32_t Pin, int32_t Dummy) {
    int32_t v1[8]; // 0x80ca509
    struct __jmp_buf_tag v2; // 0x80ca509
    struct __jmp_buf_tag env[1]; // 0x80ca509
    // 0x80ca4c0
    if (*(char *)(PCB + 38) == 0) {
        // 0x80ca517
        return 0;
    }
    // 0x80ca4d9
    int32_t v3; // bp-172, 0x80ca4c0
    v1[0] = &v3;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    if (_setjmp(env) != 0) {
        // 0x80ca517
        return 1;
    }
    int32_t v4 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 48); // 0x80ca557
    int32_t v5; // bp-192, 0x80ca4c0
    r_search(v4, (int32_t)&SearchBox, 0, 0x80cb410, (char *)&v5);
    return 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca570 - 0x80ca5f6
// Line range:    257 - 274
char SearchLineByLocation(int32_t locked, int32_t Layer2, int32_t Line, int32_t Dummy) {
    int32_t v1[8]; // 0x80ca5aa
    struct __jmp_buf_tag v2; // 0x80ca5aa
    struct __jmp_buf_tag env[1]; // 0x80ca5aa
    // 0x80ca570
    int32_t v3; // 0x80ca570
    *(int32_t *)v3 = SearchLayer;
    int32_t v4; // bp-172, 0x80ca570
    v1[0] = &v4;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    if (_setjmp(env) != 0) {
        // 0x80ca5ba
        return 1;
    }
    int32_t v5 = *(int32_t *)(SearchLayer + 52); // 0x80ca5e7
    int32_t v6; // bp-184, 0x80ca570
    r_search(v5, (int32_t)&SearchBox, 0, 0x80cbbd0, (char *)&v6);
    return 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca600 - 0x80ca686
// Line range:    347 - 363
char SearchArcByLocation(int32_t locked, int32_t Layer2, int32_t Arc, int32_t Dummy) {
    int32_t v1[8]; // 0x80ca63a
    struct __jmp_buf_tag v2; // 0x80ca63a
    struct __jmp_buf_tag env[1]; // 0x80ca63a
    // 0x80ca600
    int32_t v3; // 0x80ca600
    *(int32_t *)v3 = SearchLayer;
    int32_t v4; // bp-172, 0x80ca600
    v1[0] = &v4;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    if (_setjmp(env) != 0) {
        // 0x80ca64a
        return 1;
    }
    int32_t v5 = *(int32_t *)(SearchLayer + 64); // 0x80ca677
    int32_t v6; // bp-180, 0x80ca600
    r_search(v5, (int32_t)&SearchBox, 0, 0x80cb860, (char *)&v6);
    return 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca690 - 0x80ca719
// Line range:    386 - 403
char SearchTextByLocation(int32_t locked, int32_t Layer2, int32_t Text, int32_t Dummy) {
    int32_t v1[8]; // 0x80ca6cc
    struct __jmp_buf_tag v2; // 0x80ca6cc
    struct __jmp_buf_tag env[1]; // 0x80ca6cc
    // 0x80ca690
    int32_t v3; // 0x80ca690
    *(int32_t *)v3 = SearchLayer;
    int32_t v4; // bp-172, 0x80ca690
    v1[0] = &v4;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    char result = 1; // 0x80ca6da
    if (_setjmp(env) == 0) {
        int32_t v5 = *(int32_t *)(SearchLayer + 56); // 0x80ca703
        int32_t v6; // bp-192, 0x80ca690
        r_search(v5, (int32_t)&SearchBox, 0, 0x80cb4a0, (char *)&v6);
        result = 0;
    }
    // 0x80ca710
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca720 - 0x80ca7a9
// Line range:    427 - 444
char SearchPolygonByLocation(int32_t locked, int32_t Layer2, int32_t Polygon2, int32_t Dummy) {
    int32_t v1[8]; // 0x80ca75c
    struct __jmp_buf_tag v2; // 0x80ca75c
    struct __jmp_buf_tag env[1]; // 0x80ca75c
    // 0x80ca720
    int32_t v3; // 0x80ca720
    *(int32_t *)v3 = SearchLayer;
    int32_t v4; // bp-172, 0x80ca720
    v1[0] = &v4;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    char result = 1; // 0x80ca76a
    if (_setjmp(env) == 0) {
        int32_t v5 = *(int32_t *)(SearchLayer + 60); // 0x80ca793
        int32_t v6; // bp-192, 0x80ca720
        r_search(v5, (int32_t)&SearchBox, 0, 0x80cb530, (char *)&v6);
        result = 0;
    }
    // 0x80ca7a0
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca7b0 - 0x80ca88c
// Line range:    205 - 222
char SearchPadByLocation(int32_t locked, int32_t Element, int32_t Pad, int32_t Dummy, char BackToo) {
    int32_t v1[8]; // 0x80ca81e
    struct __jmp_buf_tag v2; // 0x80ca81e
    struct __jmp_buf_tag env[1]; // 0x80ca81e
    // 0x80ca7b0
    if (*(char *)(PCB + 38) == 0) {
        // 0x80ca82c
        return 0;
    }
    // 0x80ca7d4
    int32_t v3; // bp-188, 0x80ca7b0
    v1[0] = &v3;
    v2 = (struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){
        .e1 = 0,
        .e2 = (struct {int32_t e0[1];}){
            .e0 = {0}
        }
    };
    v2.e0 = v1;
    env[0] = v2;
    char result = 1; // 0x80ca82a
    if (_setjmp(env) == 0) {
        int32_t v4 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 52); // 0x80ca87f
        int32_t v5; // bp-208, 0x80ca7b0
        r_search(v4, (int32_t)&SearchBox, 0, 0x80cbc60, (char *)&v5);
        result = 0;
    }
    // 0x80ca82c
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca890 - 0x80ca990
// Line range:    567 - 580
char SearchElementNameByLocation(int32_t locked, int32_t Element, int32_t Text, int32_t Dummy, char BackToo) {
    // 0x80ca890
    if (*(char *)(PCB + 35) == 0) {
        // 0x80ca95e
        return 0;
    }
    uint32_t v1 = *(int32_t *)(PCB + 4); // 0x80ca8d5
    int32_t v2 = 4; // 0x80ca8f8
    if ((v1 & 64) == 0) {
        // 0x80ca970
        v2 = v1 / 4 & 8 ^ 8;
    }
    int32_t v3 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 56 + v2); // 0x80ca903
    int32_t v4; // bp-208, 0x80ca890
    int32_t v5 = r_search(v3, (int32_t)&SearchBox, 0, 0x80c93f0, (char *)&v4); // 0x80ca952
    // 0x80ca95e
    return v5 != 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80ca990 - 0x80caa66
// Line range:    621 - 635
char SearchElementByLocation(int32_t locked, int32_t Element, int32_t Dummy1, int32_t Dummy2, char BackToo) {
    // 0x80ca990
    if (*(char *)(PCB + 35) == 0) {
        // 0x80ca9c0
        return 0;
    }
    char result = 0; // 0x80ca9bc
    if (*(char *)(PCB + 38) != 0) {
        int32_t v1 = *(int32_t *)(*(int32_t *)(PCB + 0x220c) + 44); // 0x80caa43
        int32_t v2; // bp-208, 0x80ca990
        int32_t v3 = r_search(v1, (int32_t)&SearchBox, 0, 0x80c9500, (char *)&v2); // 0x80caa49
        result = v3 != 0;
    }
    // 0x80ca9c0
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80caa70 - 0x80cb2f1
// Line range:    1133 - 1330
int32_t SearchObjectByLocation(int32_t Type, char ** Result1, char ** Result2, char ** Result3, int32_t X, int32_t Y, int32_t Radius) {
    // 0x80caa70
    int3_t v1; // 0x80caa70
    int3_t v2 = v1 - 1; // 0x80caa91
    __frontend_reg_store_fpr(v2, (float80_t)X);
    PosX = __frontend_reg_load_fpr(v2);
    __frontend_reg_store_fpr(v2, (float80_t)Y);
    PosY = __frontend_reg_load_fpr(v2);
    SearchRadius = Radius;
    int32_t v3; // 0x80caa70
    int32_t v4; // 0x80caa70
    if (Radius == 0) {
        // 0x80cad88
        SearchBox = X;
        g93 = Y;
        v4 = X + 1;
        v3 = Y + 1;
    } else {
        // 0x80caac8
        SearchBox = X - Radius;
        g93 = Y - Radius;
        v4 = Radius + X;
        v3 = Radius + Y;
    }
    int32_t v5 = (int32_t)Result3;
    g94 = v4;
    g95 = v3;
    int32_t v6 = *(int32_t *)(PCB + 4); // 0x80caaf4
    int32_t v7 = (v6 & 0x240000) == 0 ? Type : Type & -1041; // 0x80cab03
    int32_t v8 = (v6 & 0x80000) == 0 ? v7 : v7 & 1040; // 0x80cab16
    uint32_t v9 = (v6 & 0x24000) == 0 ? v8 : v8 & -9; // 0x80cab26
    if ((v9 & 32) != 0) {
        // 0x80cab32
        if (*(char *)(PCB + 36) != 0) {
            char v10 = SearchRatLineByLocation(v5, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231); // 0x80cadba
            if (v10 != 0) {
                // 0x80cad76
                return 32;
            }
        }
    }
    if (v9 % 2 != 0) {
        char v11 = SearchViaByLocation(v5, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231); // 0x80cb05b
        if (v11 != 0) {
            // 0x80cad76
            return 1;
        }
    }
    int32_t v12; // 0x80caa70
    int32_t v13; // bp-40, 0x80caa70
    if ((v9 & 256) != 0) {
        char v14 = SearchPinByLocation((int32_t)&v13, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231); // 0x80cb086
        v12 = 256;
        if (v14 == 0) {
            goto lab_0x80cab56;
        } else {
            goto lab_0x80cb09d;
        }
    } else {
        goto lab_0x80cab56;
    }
  lab_0x80cac3f:;
    // 0x80cac3f
    int32_t v15; // 0x80caa70
    int32_t v16 = v15;
    char ** v17; // 0x80caa70
    char ** v18 = v17; // 0x80cac49
    char ** v19; // 0x80caa70
    char ** v20 = v19; // 0x80cac49
    char ** v21; // 0x80cac94
    char ** v22 = v21; // 0x80cac49
    int32_t v23; // 0x80caa70
    int32_t v24 = v23; // 0x80cac49
    bool v25; // 0x80caa70
    int32_t result; // 0x80caa70
    int32_t v26; // 0x80caa70
    float80_t v27; // 0x80caa70
    char ** v28; // bp-288, 0x80caa70
    int3_t v29; // 0x80caa70
    int3_t v30; // 0x80caa70
    int3_t v31; // 0x80caa70
    int3_t v32; // 0x80caa70
    int32_t v33; // 0x80caa70
    bool v34; // 0x80caa70
    if (*(char *)(v16 + 68) != 0) {
        char ** v35 = v21; // 0x80cac57
        if ((v26 & 768) == 0) {
            char ** v36 = v19; // 0x80cac65
            if ((v9 & 2048) != 0) {
                int32_t v37 = *(int32_t *)(v16 + 12); // 0x80cac6b
                *(int32_t *)Result1 = v16;
                v36 = v19;
                if (v37 != 0) {
                    // 0x80cac8b
                    __frontend_reg_store_fpr(v2, (float80_t)SearchRadius);
                    __frontend_reg_store_fpr(v2, __frontend_reg_load_fpr(v2) * __frontend_reg_load_fpr(v2));
                    __frontend_reg_store_fpr(v29, (float80_t)PosX);
                    __frontend_reg_store_fpr(v30, (float80_t)PosY);
                    int32_t v38 = v37; // 0x80cacb9
                    int32_t v39 = 60 * v37; // 0x80cacb9
                    int32_t v40 = 0;
                    v39 -= 60;
                    int32_t v41 = *(int32_t *)(v16 + 44) + v39; // 0x80cacd0
                    int32_t v42 = *(int32_t *)(v41 + 36); // 0x80cacd3
                    int32_t v43; // 0x80caa70
                    int32_t v44; // 0x80caa70
                    int32_t v45; // 0x80caa70
                    int32_t v46; // 0x80caa70
                    int32_t v47; // 0x80cacf7
                    float80_t v48; // 0x80cad02
                    float80_t v49; // 0x80cad06
                    float80_t v50; // 0x80cad0c
                    float80_t v51; // 0x80cad0e
                    float80_t v52; // 0x80cad0e
                    float80_t v53; // 0x80caa70
                    float80_t v54; // 0x80cad14
                    float80_t v55; // 0x80cad16
                    float80_t v56; // 0x80cad2a
                    float80_t v57; // 0x80cad2c
                    float80_t v58; // 0x80cacf0
                    float80_t v59; // 0x80cacf2
                    float80_t v60; // 0x80cad3b
                    float80_t v61; // 0x80cad3d
                    if (v42 == 0) {
                        // 0x80cad3b
                        v60 = __frontend_reg_load_fpr(v30);
                        __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                        __frontend_reg_store_fpr(v29, v60);
                        v61 = __frontend_reg_load_fpr(v30);
                        __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v2));
                        __frontend_reg_store_fpr(v2, v61);
                        v45 = v40;
                    } else {
                        // 0x80cacde
                        v43 = 20 * v42;
                        v46 = v42;
                        v44 = v40;
                        v43 -= 20;
                        v47 = *(int32_t *)(v41 + 56) + v43;
                        __frontend_reg_store_fpr(v31, (float80_t)*(int32_t *)v47);
                        __frontend_reg_store_fpr(v31, __frontend_reg_load_fpr(v31) - __frontend_reg_load_fpr(v29));
                        __frontend_reg_store_fpr(v32, (float80_t)*(int32_t *)(v47 + 4));
                        __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v32) - __frontend_reg_load_fpr(v30));
                        v48 = __frontend_reg_load_fpr(v32);
                        __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v31));
                        __frontend_reg_store_fpr(v31, v48);
                        __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v32) * __frontend_reg_load_fpr(v32));
                        v49 = __frontend_reg_load_fpr(v32);
                        __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v31));
                        __frontend_reg_store_fpr(v31, v49);
                        __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v32) * __frontend_reg_load_fpr(v32));
                        __frontend_reg_store_fpr(v31, __frontend_reg_load_fpr(v32) + __frontend_reg_load_fpr(v31));
                        v50 = __frontend_reg_load_fpr(v31);
                        __frontend_reg_store_fpr(v31, __frontend_reg_load_fpr(v2));
                        __frontend_reg_store_fpr(v2, v50);
                        v51 = __frontend_reg_load_fpr(v31);
                        v52 = __frontend_reg_load_fpr(v2);
                        v53 = __frontend_reg_load_fpr(v31);
                        if (v51 > v52) {
                            // 0x80cad12
                            __frontend_reg_store_fpr(v31, v53);
                            v54 = __frontend_reg_load_fpr(v30);
                            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                            __frontend_reg_store_fpr(v29, v54);
                            v55 = __frontend_reg_load_fpr(v30);
                            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v2));
                            __frontend_reg_store_fpr(v2, v55);
                            *(int32_t *)v21 = v47;
                            *(int32_t *)Result2 = v41;
                        } else {
                            // 0x80cad28
                            __frontend_reg_store_fpr(v2, v53);
                            v56 = __frontend_reg_load_fpr(v30);
                            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                            __frontend_reg_store_fpr(v29, v56);
                            v57 = __frontend_reg_load_fpr(v30);
                            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v2));
                            __frontend_reg_store_fpr(v2, v57);
                        }
                        // 0x80cad2e
                        v46--;
                        v45 = v44;
                        while (v46 != 0) {
                            // 0x80cacf0
                            v58 = __frontend_reg_load_fpr(v30);
                            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v2));
                            __frontend_reg_store_fpr(v2, v58);
                            v59 = __frontend_reg_load_fpr(v30);
                            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                            __frontend_reg_store_fpr(v29, v59);
                            v43 -= 20;
                            v47 = *(int32_t *)(v41 + 56) + v43;
                            __frontend_reg_store_fpr(v31, (float80_t)*(int32_t *)v47);
                            __frontend_reg_store_fpr(v31, __frontend_reg_load_fpr(v31) - __frontend_reg_load_fpr(v29));
                            __frontend_reg_store_fpr(v32, (float80_t)*(int32_t *)(v47 + 4));
                            __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v32) - __frontend_reg_load_fpr(v30));
                            v48 = __frontend_reg_load_fpr(v32);
                            __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v31));
                            __frontend_reg_store_fpr(v31, v48);
                            __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v32) * __frontend_reg_load_fpr(v32));
                            v49 = __frontend_reg_load_fpr(v32);
                            __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v31));
                            __frontend_reg_store_fpr(v31, v49);
                            __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v32) * __frontend_reg_load_fpr(v32));
                            __frontend_reg_store_fpr(v31, __frontend_reg_load_fpr(v32) + __frontend_reg_load_fpr(v31));
                            v50 = __frontend_reg_load_fpr(v31);
                            __frontend_reg_store_fpr(v31, __frontend_reg_load_fpr(v2));
                            __frontend_reg_store_fpr(v2, v50);
                            v51 = __frontend_reg_load_fpr(v31);
                            v52 = __frontend_reg_load_fpr(v2);
                            v53 = __frontend_reg_load_fpr(v31);
                            if (v51 > v52) {
                                // 0x80cad12
                                __frontend_reg_store_fpr(v31, v53);
                                v54 = __frontend_reg_load_fpr(v30);
                                __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                                __frontend_reg_store_fpr(v29, v54);
                                v55 = __frontend_reg_load_fpr(v30);
                                __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v2));
                                __frontend_reg_store_fpr(v2, v55);
                                *(int32_t *)v21 = v47;
                                *(int32_t *)Result2 = v41;
                            } else {
                                // 0x80cad28
                                __frontend_reg_store_fpr(v2, v53);
                                v56 = __frontend_reg_load_fpr(v30);
                                __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                                __frontend_reg_store_fpr(v29, v56);
                                v57 = __frontend_reg_load_fpr(v30);
                                __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v2));
                                __frontend_reg_store_fpr(v2, v57);
                            }
                            // 0x80cad2e
                            v46--;
                            v45 = v44;
                        }
                    }
                    // 0x80cad40
                    v38--;
                    int32_t v62 = v45;
                    float80_t v63 = __frontend_reg_load_fpr(v30);
                    while (v38 != 0) {
                        // 0x80cacc0
                        __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v2));
                        __frontend_reg_store_fpr(v2, v63);
                        float80_t v64 = __frontend_reg_load_fpr(v30); // 0x80cacc2
                        __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                        __frontend_reg_store_fpr(v29, v64);
                        v40 = v62;
                        v39 -= 60;
                        v41 = *(int32_t *)(v16 + 44) + v39;
                        v42 = *(int32_t *)(v41 + 36);
                        if (v42 == 0) {
                            // 0x80cad3b
                            v60 = __frontend_reg_load_fpr(v30);
                            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                            __frontend_reg_store_fpr(v29, v60);
                            v61 = __frontend_reg_load_fpr(v30);
                            __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v2));
                            __frontend_reg_store_fpr(v2, v61);
                            v45 = v40;
                        } else {
                            // 0x80cacde
                            v43 = 20 * v42;
                            v46 = v42;
                            v44 = v40;
                            v43 -= 20;
                            v47 = *(int32_t *)(v41 + 56) + v43;
                            __frontend_reg_store_fpr(v31, (float80_t)*(int32_t *)v47);
                            __frontend_reg_store_fpr(v31, __frontend_reg_load_fpr(v31) - __frontend_reg_load_fpr(v29));
                            __frontend_reg_store_fpr(v32, (float80_t)*(int32_t *)(v47 + 4));
                            __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v32) - __frontend_reg_load_fpr(v30));
                            v48 = __frontend_reg_load_fpr(v32);
                            __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v31));
                            __frontend_reg_store_fpr(v31, v48);
                            __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v32) * __frontend_reg_load_fpr(v32));
                            v49 = __frontend_reg_load_fpr(v32);
                            __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v31));
                            __frontend_reg_store_fpr(v31, v49);
                            __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v32) * __frontend_reg_load_fpr(v32));
                            __frontend_reg_store_fpr(v31, __frontend_reg_load_fpr(v32) + __frontend_reg_load_fpr(v31));
                            v50 = __frontend_reg_load_fpr(v31);
                            __frontend_reg_store_fpr(v31, __frontend_reg_load_fpr(v2));
                            __frontend_reg_store_fpr(v2, v50);
                            v51 = __frontend_reg_load_fpr(v31);
                            v52 = __frontend_reg_load_fpr(v2);
                            v53 = __frontend_reg_load_fpr(v31);
                            if (v51 > v52) {
                                // 0x80cad12
                                __frontend_reg_store_fpr(v31, v53);
                                v54 = __frontend_reg_load_fpr(v30);
                                __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                                __frontend_reg_store_fpr(v29, v54);
                                v55 = __frontend_reg_load_fpr(v30);
                                __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v2));
                                __frontend_reg_store_fpr(v2, v55);
                                *(int32_t *)v21 = v47;
                                *(int32_t *)Result2 = v41;
                            } else {
                                // 0x80cad28
                                __frontend_reg_store_fpr(v2, v53);
                                v56 = __frontend_reg_load_fpr(v30);
                                __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                                __frontend_reg_store_fpr(v29, v56);
                                v57 = __frontend_reg_load_fpr(v30);
                                __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v2));
                                __frontend_reg_store_fpr(v2, v57);
                            }
                            // 0x80cad2e
                            v46--;
                            v45 = v44;
                            while (v46 != 0) {
                                // 0x80cacf0
                                v58 = __frontend_reg_load_fpr(v30);
                                __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v2));
                                __frontend_reg_store_fpr(v2, v58);
                                v59 = __frontend_reg_load_fpr(v30);
                                __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                                __frontend_reg_store_fpr(v29, v59);
                                v43 -= 20;
                                v47 = *(int32_t *)(v41 + 56) + v43;
                                __frontend_reg_store_fpr(v31, (float80_t)*(int32_t *)v47);
                                __frontend_reg_store_fpr(v31, __frontend_reg_load_fpr(v31) - __frontend_reg_load_fpr(v29));
                                __frontend_reg_store_fpr(v32, (float80_t)*(int32_t *)(v47 + 4));
                                __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v32) - __frontend_reg_load_fpr(v30));
                                v48 = __frontend_reg_load_fpr(v32);
                                __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v31));
                                __frontend_reg_store_fpr(v31, v48);
                                __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v32) * __frontend_reg_load_fpr(v32));
                                v49 = __frontend_reg_load_fpr(v32);
                                __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v31));
                                __frontend_reg_store_fpr(v31, v49);
                                __frontend_reg_store_fpr(v32, __frontend_reg_load_fpr(v32) * __frontend_reg_load_fpr(v32));
                                __frontend_reg_store_fpr(v31, __frontend_reg_load_fpr(v32) + __frontend_reg_load_fpr(v31));
                                v50 = __frontend_reg_load_fpr(v31);
                                __frontend_reg_store_fpr(v31, __frontend_reg_load_fpr(v2));
                                __frontend_reg_store_fpr(v2, v50);
                                v51 = __frontend_reg_load_fpr(v31);
                                v52 = __frontend_reg_load_fpr(v2);
                                v53 = __frontend_reg_load_fpr(v31);
                                if (v51 > v52) {
                                    // 0x80cad12
                                    __frontend_reg_store_fpr(v31, v53);
                                    v54 = __frontend_reg_load_fpr(v30);
                                    __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                                    __frontend_reg_store_fpr(v29, v54);
                                    v55 = __frontend_reg_load_fpr(v30);
                                    __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v2));
                                    __frontend_reg_store_fpr(v2, v55);
                                    *(int32_t *)v21 = v47;
                                    *(int32_t *)Result2 = v41;
                                } else {
                                    // 0x80cad28
                                    __frontend_reg_store_fpr(v2, v53);
                                    v56 = __frontend_reg_load_fpr(v30);
                                    __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v29));
                                    __frontend_reg_store_fpr(v29, v56);
                                    v57 = __frontend_reg_load_fpr(v30);
                                    __frontend_reg_store_fpr(v30, __frontend_reg_load_fpr(v2));
                                    __frontend_reg_store_fpr(v2, v57);
                                }
                                // 0x80cad2e
                                v46--;
                                v45 = v44;
                            }
                        }
                        // 0x80cad40
                        v38--;
                        v62 = v45;
                        v63 = __frontend_reg_load_fpr(v30);
                    }
                    // 0x80cad5b
                    __frontend_reg_store_fpr(v30, v63);
                    __frontend_reg_store_fpr(v29, __frontend_reg_load_fpr(v29));
                    __frontend_reg_store_fpr(v2, __frontend_reg_load_fpr(v2));
                    v28 = v21;
                    v36 = v21;
                    if ((char)v62 != 0) {
                        // 0x80cad76
                        return 2048;
                    }
                }
            }
            char ** v65 = v36; // 0x80caef8
            char ** v66 = v21; // 0x80caee4
            if ((v9 & 0x1000) != 0) {
                int32_t v67 = SearchRadius; // 0x80caef3
                *(int32_t *)Result1 = v16;
                *(int32_t *)v65 = 0;
                char ** v68 = Result2; // bp-212, 0x80caf0f
                __frontend_reg_store_fpr(v2, (float80_t)(v67 * v67));
                __frontend_reg_load_fpr(v2);
                int32_t v69 = *(int32_t *)(v16 + 52); // 0x80caf66
                int32_t v70 = r_search(v69, (int32_t)&SearchBox, 0, 0x80c9350, (char *)&v68); // 0x80caf6c
                v66 = v65;
                if (v70 != 0) {
                    // 0x80cad76
                    return 0x1000;
                }
            }
            char ** v71 = v66; // 0x80cadd8
            if ((v9 & 4) != 0) {
                // 0x80cb020
                v71 = v28;
                char v72 = SearchLineByLocation((int32_t)v71, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231); // 0x80cb035
                if (v72 != 0) {
                    // 0x80cad76
                    return 4;
                }
            }
            char ** v73 = v71; // 0x80cade5
            if ((v9 & 0x4000) != 0) {
                // 0x80caff0
                v73 = v28;
                char v74 = SearchArcByLocation((int32_t)v73, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231); // 0x80cb005
                if (v74 != 0) {
                    // 0x80cad76
                    return 0x4000;
                }
            }
            // 0x80cadeb
            v35 = v73;
            if ((v9 & 16) != 0) {
                char v75 = SearchTextByLocation((int32_t)v28, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231); // 0x80cae06
                v35 = v28;
                if (v75 != 0) {
                    // 0x80cad76
                    return 16;
                }
            }
        }
        char ** v76 = v35; // 0x80cae1b
        if ((v9 & 8) != 0) {
            // 0x80caf89
            v76 = v28;
            v33 = (int32_t)v76;
            char v77 = SearchPolygonByLocation(v33, (int32_t)&g231, (int32_t)&g231, (int32_t)&g231); // 0x80caf9e
            if (v77 != 0) {
                // 0x80cafab
                result = 8;
                if (v26 == 0) {
                    return result;
                } else {
                    char * v78 = *Result2;
                    int32_t v79 = *(int32_t *)((int32_t)v78 + 8); // 0x80cafbf
                    __frontend_reg_store_fpr(v2, (float80_t)(v79 - *(int32_t *)v78));
                    __frontend_reg_store_fpr(v2, __frontend_reg_load_fpr(v2) * __frontend_reg_load_fpr(v2));
                    __frontend_reg_store_fpr(v29, v27);
                    float80_t v80 = __frontend_reg_load_fpr(v29); // 0x80cafd8
                    __frontend_reg_store_fpr(v29, __frontend_reg_load_fpr(v2));
                    __frontend_reg_store_fpr(v2, v80);
                    float80_t v81 = __frontend_reg_load_fpr(v29); // 0x80cafda
                    float80_t v82 = __frontend_reg_load_fpr(v2); // 0x80cafda
                    v25 = false;
                    v34 = false;
                    if (v81 > v82) {
                        goto lab_dec_label_pc_unknown;
                    } else {
                        v25 = true;
                        v34 = false;
                        if (v81 < v82) {
                            goto lab_dec_label_pc_unknown;
                        } else {
                            v25 = v81 != v82;
                            v34 = true;
                            goto lab_dec_label_pc_unknown;
                        }
                    }
                }
            }
        }
        // 0x80cae21
        v18 = v76;
        v20 = v76;
        v22 = v76;
        v24 = PCB;
    }
    goto lab_0x80cae27;
  lab_0x80cae27:;
    char ** v83 = v18; // 0x80cae43
    int32_t v84 = *(int32_t *)(v24 + 0x220c); // 0x80cae27
    int32_t v85; // 0x80caa70
    int32_t v86 = v85 + 1; // 0x80cae2d
    int32_t v87 = *(int32_t *)(v84 + 24); // 0x80cae34
    char ** v88 = v83; // 0x80cae3d
    char ** v89 = v20; // 0x80cae3d
    char ** v90 = v22; // 0x80cae3d
    int32_t v91 = v86; // 0x80cae3d
    int32_t v92 = v87; // 0x80cae3d
    int32_t v93 = v24; // 0x80cae3d
    int32_t v94 = v84; // 0x80cae3d
    if (v87 < v86) {
        // break -> 0x80cae43
        goto lab_0x80cae43;
    }
    goto lab_0x80cac08;
  lab_0x80cab56:
    if ((v9 & 512) != 0) {
        char v101 = SearchPadByLocation((int32_t)&v13, 0, (int32_t)&g231, (int32_t)&g231, (char)&g231); // 0x80cb0ef
        v12 = 512;
        if (v101 == 0) {
            goto lab_0x80cab66;
        } else {
            goto lab_0x80cb09d;
        }
    } else {
        goto lab_0x80cab66;
    }
  lab_0x80cb09d:
    // 0x80cb09d
    __frontend_reg_store_fpr(v2, 0.0L);
    v27 = __frontend_reg_load_fpr(v2);
    int32_t v102 = v12; // 0x80cb0a5
    goto lab_0x80cab92;
  lab_0x80cab66:;
    int32_t v111; // 0x80caa70
    if ((v9 & 1024) != 0) {
        char v114 = SearchElementNameByLocation((int32_t)&v13, 0, (int32_t)&g231, (int32_t)&g231, (char)&g231); // 0x80cb1c9
        if (v114 == 0) {
            goto lab_0x80cab76;
        } else {
            int32_t v115 = *(int32_t *)v111; // 0x80cb1e6
            int32_t v116 = *(int32_t *)(v111 + 4); // 0x80cb1f1
            __frontend_reg_store_fpr(v2, (float80_t)(*(int32_t *)(v111 + 8) - v115));
            int3_t v117 = v1 - 2; // 0x80cb200
            __frontend_reg_store_fpr(v117, (float80_t)(*(int32_t *)(v111 + 12) - v116));
            __frontend_reg_store_fpr(v2, __frontend_reg_load_fpr(v117) * __frontend_reg_load_fpr(v2));
            v27 = __frontend_reg_load_fpr(v2);
            v102 = 1024;
            goto lab_0x80cab92;
        }
    } else {
        goto lab_0x80cab76;
    }
  lab_0x80cab92:
    // 0x80cab92
    v26 = v102;
    int32_t v103 = *(int32_t *)(PCB + 0x220c); // 0x80cab98
    uint32_t v104 = *(int32_t *)(v103 + 24); // 0x80cab9e
    int32_t v105 = v5; // 0x80caba4
    if (v104 >= 0xffffffff) {
        // 0x80cabaa
        v28 = Result3;
        v29 = v1 - 2;
        v30 = v1 - 3;
        v31 = v1 ^ -4;
        v32 = v1 + 3;
        v88 = Result3;
        v89 = Result3;
        v90 = Result3;
        v91 = -1;
        v92 = v104;
        v93 = PCB;
        v94 = v103;
        while (true) {
          lab_0x80cac08:;
            int32_t v95 = v94;
            v23 = v93;
            int32_t v96 = v92;
            v85 = v91;
            v21 = v90;
            v19 = v89;
            v17 = v88;
            if (v85 == -1) {
                int32_t v97 = v95 + 76 + 92 * (v96 + (int32_t)(g170 == 0)); // 0x80caec7
                SearchLayer = v97;
                v15 = v97;
                goto lab_0x80cac3f;
            } else {
                if (v96 > v85) {
                    int32_t v98 = *(int32_t *)(4 * v85 + (int32_t)&LayerStack); // 0x80cac27
                    int32_t v99 = v95 + 76 + 92 * v98; // 0x80cac2f
                    SearchLayer = v99;
                    v15 = v99;
                    goto lab_0x80cac3f;
                } else {
                    int32_t v100 = v95 + 76 + 92 * (v96 + (int32_t)(g170 != 0)); // 0x80cae8f
                    SearchLayer = v100;
                    v15 = v100;
                    v18 = v17;
                    v20 = v19;
                    v22 = v21;
                    v24 = v23;
                    if (*(char *)(v23 + 37) == 0) {
                        goto lab_0x80cae27;
                    } else {
                        goto lab_0x80cac3f;
                    }
                }
            }
        }
      lab_0x80cae43:
        // 0x80cae43
        v105 = (int32_t)v83;
    }
    goto lab_0x80cae49;
  lab_0x80cab76:
    if ((v9 & 2) != 0) {
        char v109 = SearchElementByLocation((int32_t)&v13, 0, (int32_t)&g231, (int32_t)&g231, (char)&g231); // 0x80cb15b
        if (v109 == 0) {
            goto lab_0x80cab80;
        } else {
            int32_t v110 = *(int32_t *)v111; // 0x80cb178
            int32_t v112 = *(int32_t *)(v111 + 4); // 0x80cb183
            __frontend_reg_store_fpr(v2, (float80_t)(*(int32_t *)(v111 + 8) - v110));
            float80_t v113 = __frontend_reg_load_fpr(v2); // 0x80cb18c
            __frontend_reg_store_fpr(v2, (float80_t)(*(int32_t *)(v111 + 12) - v112));
            __frontend_reg_store_fpr(v2, v113 * __frontend_reg_load_fpr(v2));
            v27 = __frontend_reg_load_fpr(v2);
            v102 = 2;
            goto lab_0x80cab92;
        }
    } else {
        goto lab_0x80cab80;
    }
  lab_0x80cae49:
    // 0x80cae49
    if ((v26 & 256) != 0) {
        // 0x80cae59
        *(int32_t *)v105 = v13;
        // 0x80cad76
        return 256;
    }
    if ((v26 & 512) != 0) {
        // 0x80cb0b6
        *(int32_t *)v105 = v13;
        // 0x80cad76
        return 512;
    }
    if ((v26 & 1024) != 0) {
        // 0x80cb118
        *(int32_t *)v105 = v13;
        // 0x80cad76
        return 1024;
    }
    if ((v26 & 2) != 0) {
        // 0x80cb21c
        *(int32_t *)v105 = v13;
        // 0x80cad76
        return 2;
    }
    // 0x80cb23b
    if (*(char *)(PCB + 37) == 0) {
        // 0x80cad76
        return 0;
    }
    if ((v9 & 512) != 0) {
        char v106 = SearchPadByLocation(v105, 1, (int32_t)&g231, (int32_t)&g231, (char)&g231); // 0x80cb2d8
        if (v106 != 0) {
            // 0x80cad76
            return 512;
        }
    }
    if ((v9 & 1024) != 0) {
        char v107 = SearchElementNameByLocation(v105, 1, (int32_t)&g231, (int32_t)&g231, (char)&g231); // 0x80cb2ac
        if (v107 != 0) {
            // 0x80cad76
            return 1024;
        }
    }
    if ((v9 & 2) == 0) {
        // 0x80cad76
        return 0;
    }
    char v108 = SearchElementByLocation(v105, 1, (int32_t)&g231, (int32_t)&g231, (char)&g231); // 0x80cb280
    result = 2;
    if (v108 == 0) {
        // 0x80cad76
        return 0;
    }
  lab_0x80cad76:
    // 0x80cad76
    return result;
  lab_0x80cab80:
    // 0x80cab80
    __frontend_reg_store_fpr(v2, 0.0L);
    v27 = __frontend_reg_load_fpr(v2);
    v102 = 0;
    goto lab_0x80cab92;
  lab_dec_label_pc_unknown:
    __frontend_reg_store_fpr(v2, __frontend_reg_load_fpr(v2));
    result = 8;
    v105 = v33;
    if (v25 || v34) {
        goto lab_0x80cad76;
    } else {
        goto lab_0x80cae49;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/search.c
// Address range: 0x80cb300 - 0x80cb342
// Line range:    1586 - 1594
int32_t SearchScreen(int32_t X, int32_t Y, int32_t Type, char ** Result1, char ** Result2, char ** Result3) {
    // 0x80cb300
    return SearchObjectByLocation(Type, Result1, Result2, Result3, X, Y, 5 * pixel_slop);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/select.c
// Address range: 0x80cc0c0 - 0x80cc29d
// Line range:    484 - 547
char * ObjectOperation(int32_t F, int32_t Type, char * Ptr1, char * Ptr2, char * Ptr3) {
    if (Type == 32) {
        int32_t v1 = *(int32_t *)(F + 44); // 0x80cc288
        if (v1 != 0) {
            // 0x80cc1c9
            return (char *)v1;
        }
        // 0x80cc1a8
        return NULL;
    }
    if (Type <= 32) {
        if (Type == 4) {
            int32_t v2 = *(int32_t *)F; // 0x80cc270
            if (v2 != 0) {
                // 0x80cc178
                return (char *)v2;
            }
            // 0x80cc1a8
            return NULL;
        }
        if (Type > 4) {
            if (Type == 8) {
                int32_t v3 = *(int32_t *)(F + 8); // 0x80cc1e8
                if (v3 != 0) {
                    // 0x80cc178
                    return (char *)v3;
                }
                // 0x80cc1a8
                return NULL;
            }
            if (Type != 16) {
                // 0x80cc1a8
                return NULL;
            }
            int32_t v4 = *(int32_t *)(F + 4); // 0x80cc16a
            if (v4 != 0) {
                // 0x80cc178
                return (char *)v4;
            }
            // 0x80cc1a8
            return NULL;
        }
        if (Type == 1) {
            int32_t v5 = *(int32_t *)(F + 12); // 0x80cc200
            if (v5 != 0) {
                // 0x80cc1c9
                return (char *)v5;
            }
            // 0x80cc1a8
            return NULL;
        }
        if (Type != 2) {
            // 0x80cc1a8
            return NULL;
        }
        int32_t v6 = *(int32_t *)(F + 16); // 0x80cc1c2
        if (v6 != 0) {
            // 0x80cc1c9
            return (char *)v6;
        }
        // 0x80cc1a8
        return NULL;
    }
    if (Type == 1024) {
        int32_t v7 = *(int32_t *)(F + 20); // 0x80cc1d8
        if (v7 != 0) {
            // 0x80cc1c9
            return (char *)v7;
        }
        // 0x80cc1a8
        return NULL;
    }
    if (Type <= 1024) {
        switch (Type) {
            case 256: {
                int32_t v8 = *(int32_t *)(F + 24); // 0x80cc258
                if (v8 != 0) {
                    // 0x80cc178
                    return (char *)v8;
                }
                // break -> 0x80cc1a8
                break;
            }
            case 512: {
                int32_t v9 = *(int32_t *)(F + 28); // 0x80cc240
                if (v9 != 0) {
                    // 0x80cc178
                    return (char *)v9;
                }
                // break -> 0x80cc1a8
                break;
            }
        }
        // 0x80cc1a8
        return NULL;
    }
    switch (Type) {
        case 0x1000: {
            int32_t v10 = *(int32_t *)(F + 32); // 0x80cc228
            if (v10 != 0) {
                // 0x80cc132
                return (char *)v10;
            }
            // 0x80cc1a8
            return NULL;
        }
        case 0x4000: {
            int32_t v11 = *(int32_t *)(F + 40); // 0x80cc210
            if (v11 != 0) {
                // 0x80cc178
                return (char *)v11;
            }
            // 0x80cc1a8
            return NULL;
        }
    }
    if (Type != 2048) {
        // 0x80cc1a8
        return NULL;
    }
    int32_t v12 = *(int32_t *)(F + 36); // 0x80cc129
    if (v12 != 0) {
        // 0x80cc132
        return (char *)v12;
    }
    // 0x80cc1a8
    return NULL;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/set.c
// Address range: 0x80cee10 - 0x80cee41
// Line range:    107 - 115
void SetViaSize(int32_t Size, char Force) {
    if (Force != 0) {
        // 0x80cee3a
        g127 = Size;
        // 0x80cee3f
        return;
    }
    if ((uint32_t)(Size - 2000) >= 0x988eb1 || (int32_t)g128 + 399 >= Size) {
        // 0x80cee3f
        return;
    }
    // 0x80cee3a
    g127 = Size;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/set.c
// Address range: 0x80cee50 - 0x80cee81
// Line range:    121 - 129
void SetViaDrillingHole(uint32_t Size, char Force) {
    if (Force != 0) {
        // 0x80cee7a
        g128 = (char *)Size;
        // 0x80cee7f
        return;
    }
    if (Size >= 0x989681 || g127 - 399 <= Size) {
        // 0x80cee7f
        return;
    }
    // 0x80cee7a
    g128 = (char *)Size;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/set.c
// Address range: 0x80ceec0 - 0x80ceed4
// Line range:    144 - 150
void SetKeepawayWidth(uint32_t Width) {
    if (Width <= 0x989680) {
        // 0x80ceecd
        g131 = Width;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/set.c
// Address range: 0x80cef00 - 0x80cef15
// Line range:    168 - 175
void SetChangedFlag(char New) {
    char * v1 = (char *)(PCB + 33); // 0x80cef0b
    if (*v1 != New) {
        // 0x80cef10
        *v1 = New;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/set.c
// Address range: 0x80cef50 - 0x80cf029
// Line range:    337 - 350
void SetLocalRef(int32_t X, int32_t Y, char Showing) {
    if (Showing == 0) {
        // 0x80cef68
        if (g96 < 1) {
            // 0x80cefc0
            return;
        }
        // 0x80cef71
        HideCrosshair(0);
        g96 = 0;
        Marked = g97;
        g191 = g98;
        g192 = g99;
        // 0x80cefa5
        RestoreCrosshair(0);
        return;
    }
    // 0x80cefd0
    HideCrosshair(1);
    if (g96 == 0) {
        // 0x80cefe5
        g97 = Marked;
        g98 = g191;
        g99 = g192;
    }
    // 0x80cf009
    g191 = X;
    g192 = Y;
    *(char *)&Marked = 1;
    g96++;
    // 0x80cefa5
    RestoreCrosshair(0);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/set.c
// Address range: 0x80cf0e0 - 0x80cf16a
// Line range:    181 - 193
void SetCrosshairRangeToBuffer(void) {
    // 0x80cf0e0
    if (g141 != 5) {
        // 0x80cf0f5
        return;
    }
    // 0x80cf100
    SetBufferBoundingBox(28 * (int32_t)g142 + (int32_t)&Buffers);
    int32_t v1 = 28 * (int32_t)g142; // 0x80cf11a
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&Buffers); // 0x80cf127
    int32_t v3 = *(int32_t *)(v1 + (int32_t)&Buffers + 4); // 0x80cf12d
    int32_t v4 = *(int32_t *)(PCB + 148); // 0x80cf130
    int32_t v5 = *(int32_t *)(v1 + (int32_t)&Buffers + 20); // 0x80cf138
    int32_t v6 = *(int32_t *)(PCB + 144); // 0x80cf13f
    int32_t v7 = *(int32_t *)(v1 + (int32_t)&Buffers + 16); // 0x80cf147
    int32_t v8 = *(int32_t *)(v1 + (int32_t)&Buffers + 12); // 0x80cf14e
    int32_t v9 = *(int32_t *)(v1 + (int32_t)&Buffers + 8); // 0x80cf155
    SetCrosshairRange(v2 - v9, v3 - v8, v6 + v2 - v7, v4 + v3 - v5);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/set.c
// Address range: 0x80cf170 - 0x80cf431
// Line range:    237 - 298
void SetMode(int32_t Mode) {
    // 0x80cf170
    if (g100 != 0) {
        // 0x80cf183
        return;
    }
    // 0x80cf190
    g100 = 1;
    HideCrosshair(1);
    addedLines = 0;
    g214 = 0;
    g215 = 0;
    g212 = 0;
    bool v1; // 0x80cf170
    int32_t v2; // 0x80cf170
    int32_t v3; // 0x80cf170
    int32_t v4; // 0x80cf170
    int32_t v5; // 0x80cf170
    char v6; // 0x80cf170
    int32_t v7; // 0x80cf2e2
    if (*(char *)(PCB + 40) != 0) {
        switch (Mode) {
            case 109: {
                goto lab_0x80cf2a8;
            }
            case 4: {
                goto lab_0x80cf2a8;
            }
            case 3: {
                goto lab_0x80cf2a8;
            }
            case 108: {
                goto lab_0x80cf2a8;
            }
            case 106: {
                goto lab_0x80cf2a8;
            }
            case 6: {
                goto lab_0x80cf2a8;
            }
            case 1: {
                goto lab_0x80cf2a8;
            }
            default: {
                // 0x80cf2e2
                v7 = g141;
                v4 = v7 == 2;
                goto lab_0x80cf1fa;
            }
        }
    } else {
        int32_t v8 = g141 == 2; // 0x80cf1e2
        v7 = g141;
        v4 = v8;
        if (Mode == 109 == g141 == 2) {
            // 0x80cf1ec
            v1 = false;
            v5 = v8;
            v6 = 0;
            v2 = 109;
            if (g204 != 0) {
                int32_t v9 = (int32_t)g200;
                g204 = 0;
                g210 = 1;
                *(int32_t *)&g208 = v9;
                *(int32_t *)&g206 = v9;
                g209 = g201;
                g207 = g201;
                AdjustAttachedObjects();
                v3 = 109;
                goto lab_0x80cf367;
            } else {
                goto lab_0x80cf223;
            }
        } else {
            goto lab_0x80cf1fa;
        }
    }
  lab_0x80cf2a8:
    // 0x80cf2a8
    Message("That mode is NOT allowed when drawing ratlines!\n");
    v1 = g141 == 109;
    v5 = g141 == 2;
    v6 = 0;
    v2 = 0;
    goto lab_0x80cf223;
  lab_0x80cf1fa:
    // 0x80cf1fa
    v1 = v7 == 109;
    v5 = v4;
    v6 = Mode == 2;
    v2 = Mode;
    int32_t v12; // 0x80cf170
    char v13; // 0x80cf170
    if (Mode == 2 == v7 == 109) {
        // 0x80cf20c
        v12 = 2;
        v13 = 1;
        if (g210 != 0) {
            int32_t v15 = (int32_t)g206;
            g210 = 0;
            g204 = 1;
            g141 = 2;
            *(int32_t *)&g202 = v15;
            *(int32_t *)&g200 = v15;
            g203 = g207;
            g201 = g207;
            AdjustAttachedObjects();
            v3 = 2;
            goto lab_0x80cf367;
        } else {
            goto lab_0x80cf330;
        }
    } else {
        goto lab_0x80cf223;
    }
  lab_0x80cf223:;
    int32_t v10 = v2; // 0x80cf225
    char v11 = v6; // 0x80cf225
    v12 = v2;
    v13 = v6;
    if (!v1 == (char)v5 == 0) {
        goto lab_0x80cf233;
    } else {
        goto lab_0x80cf330;
    }
  lab_0x80cf233:
    // 0x80cf233
    g210 = 0;
    g204 = 0;
    if (v11 != 0) {
        // 0x80cf358
        v3 = v10;
        if (*(char *)(PCB + 4) < 0) {
            // 0x80cf400
            SaveUndoSerialNumber();
            ResetFoundPinsViasAndPads(1);
            RestoreUndoSerialNumber();
            ResetFoundLinesAndPolygons(1);
            IncrementUndoSerialNumber();
            v3 = v10;
        }
        goto lab_0x80cf367;
    } else {
        // 0x80cf24f
        g141 = v10;
        if (v10 == 5) {
            // 0x80cf25e
            SetCrosshairRangeToBuffer();
            // 0x80cf263
            g100 = 0;
            MoveCrosshairRelative(0, 0);
            RestoreCrosshair(1);
            return;
        }
        // 0x80cf2f8
        goto lab_0x80cf2fd;
    }
  lab_0x80cf330:
    // 0x80cf330
    SetLocalRef(0, 0, 0);
    v10 = v12;
    v11 = v13;
    goto lab_0x80cf233;
  lab_0x80cf367:
    // 0x80cf367
    g141 = v3;
    goto lab_0x80cf2fd;
  lab_0x80cf2fd:;
    int32_t v14 = PCB;
    SetCrosshairRange(0, 0, *(int32_t *)(v14 + 144), *(int32_t *)(v14 + 148));
    // 0x80cf263
    g100 = 0;
    MoveCrosshairRelative(0, 0);
    RestoreCrosshair(1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/set.c
// Address range: 0x80cf4a0 - 0x80cf4e0
// Line range:    93 - 101
void SetLineSize(int32_t Size) {
    if ((uint32_t)(Size - 1) >= 0x989680) {
        // 0x80cf4c4
        return;
    }
    // 0x80cf4b4
    g129 = Size;
    if (*(char *)(PCB + 4) >= 0) {
        // 0x80cf4c4
        return;
    }
    // 0x80cf4c8
    FitCrosshairIntoGrid(g193, g194);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/strflags.c
// Address range: 0x80cf5c0 - 0x80cf651
// Line range:    158 - 168
char * alloc_buf(int32_t len) {
    // 0x80cf5c0
    int32_t v1; // 0x80cf5c0
    uint32_t size = v1 + 1; // 0x80cf5d3
    int32_t v2 = (bufptr + 1) % 10;
    int32_t v3 = 8 * v2;
    bufptr = v2;
    if (size <= *(int32_t *)(v3 + (int32_t)&g103)) {
        // 0x80cf62c
        return (char *)*(int32_t *)(v3 + (int32_t)&buffers);
    }
    int32_t * v4 = (int32_t *)(v3 + (int32_t)&buffers); // 0x80cf601
    int32_t v5 = *v4; // 0x80cf601
    int32_t * mem; // 0x80cf5c0
    if (v5 == 0) {
        // 0x80cf640
        mem = malloc(size);
    } else {
        // 0x80cf60c
        mem = realloc((int32_t *)v5, size);
    }
    // 0x80cf61f
    *v4 = (int32_t)mem;
    int32_t v6 = 8 * bufptr;
    *(int32_t *)(v6 + (int32_t)&g103) = size;
    // 0x80cf62c
    return (char *)*(int32_t *)(v6 + (int32_t)&buffers);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/strflags.c
// Address range: 0x80cf660 - 0x80cf6f4
// Line range:    186 - 190
void grow_layer_list(int32_t num) {
    // 0x80cf660
    int32_t v1; // 0x80cf660
    int32_t v2 = v1;
    int32_t v3 = layers; // 0x80cf669
    int32_t v4; // 0x80cf660
    if (v3 == 0) {
        int32_t mem = (int32_t)calloc(v2 >= 0 == (v2 != 0) ? v2 : 1, 1); // 0x80cf6e2
        layers = mem;
        v4 = mem;
    } else {
        // 0x80cf672
        v4 = v3;
        if (v2 > max_layers) {
            int32_t mem2 = (int32_t)realloc((int32_t *)v3, v2); // 0x80cf6bd
            layers = mem2;
            v4 = mem2;
        }
    }
    int32_t v5 = num_layers; // 0x80cf67a
    if (v2 > v5) {
        // 0x80cf683
        memset((int32_t *)(v5 + v4), 0, v2 + -1 - v5);
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/strflags.c
// Address range: 0x80cf700 - 0x80cfd50
// Line range:    474 - 553
char * common_flags_to_string(int32_t flags, int32_t object_type, uint32_t flagbits, int32_t n_flagbits) {
    // 0x80cf700
    int32_t v1; // 0x80cf700
    char v2 = v1; // 0x80cf723
    int32_t v3 = __readgsdword(20); // 0x80cf751
    char v4 = v2; // bp-40, 0x80cf7bf
    int32_t v5; // 0x80cf700
    switch (flags) {
        case 32: {
            // 0x80cfd1d
            v5 = v1 & -17;
            // break -> 0x80cf7e0
            break;
        }
        case 256: {
            // 0x80cfd0e
            v5 = v1 & -2;
            // break -> 0x80cf7e0
            break;
        }
        case 1: {
            // 0x80cfc2d
            v5 = v1 & -3;
            // break -> 0x80cf7e0
            break;
        }
    }
    int32_t v6 = 0; // 0x80cf7ea
    if (flagbits >= 1) {
        int32_t v7 = v5; // 0x80cf803
        int32_t v8; // 0x80cf805
        if ((*(int32_t *)(object_type + 12) & flags) != 0) {
            // 0x80cf805
            v8 = *(int32_t *)object_type;
            v7 = v5;
            if ((v8 & v5) != 0) {
                // 0x80cf80c
                v7 = v5 & -1 - v8;
            }
        }
        // 0x80cf818
        v6++;
        int32_t v9 = object_type + 16; // 0x80cf821
        while (v6 != flagbits) {
            int32_t v10 = v9;
            int32_t v11 = v7;
            v7 = v11;
            if ((*(int32_t *)(v10 + 12) & flags) != 0) {
                // 0x80cf805
                v8 = *(int32_t *)v10;
                v7 = v11;
                if ((v8 & v11) != 0) {
                    // 0x80cf80c
                    v7 = v11 & -1 - v8;
                }
            }
            // 0x80cf818
            v6++;
            v9 = v10 + 16;
        }
    }
    // 0x80cf829
    mem_any_set(&v4, 8);
    char * result = alloc_buf((int32_t)&g231); // 0x80cf8a0
    *result = 34;
    int32_t v12 = (int32_t)result + 1; // 0x80cf8ab
    v4 = v2;
    int32_t v13 = 0; // 0x80cf903
    int32_t v14 = v12; // 0x80cf903
    if (flagbits >= 1) {
        int32_t v15 = v5; // 0x80cf91b
        int32_t v16 = v12; // 0x80cf91b
        int32_t str; // 0x80cf700
        int32_t * v17; // 0x80cf91d
        if ((*(int32_t *)(object_type + 12) & flags) != 0) {
            // 0x80cf91d
            v17 = (int32_t *)object_type;
            v15 = v5;
            v16 = v12;
            if ((*v17 & v5) != 0) {
                // 0x80cf924
                str = v12;
                // 0x80cf92f
                strcpy((char *)str, (char *)*(int32_t *)(object_type + 4));
                v15 = v5 & -1 - *v17;
                v16 = *(int32_t *)(object_type + 8) + str;
            }
        }
        int32_t v18 = v16;
        v13++;
        int32_t v19 = object_type + 16; // 0x80cf968
        v14 = v18;
        while (v13 != flagbits) {
            int32_t v20 = v19;
            int32_t v21 = v18;
            int32_t v22 = v15;
            v15 = v22;
            v16 = v21;
            if ((*(int32_t *)(v20 + 12) & flags) != 0) {
                // 0x80cf91d
                v17 = (int32_t *)v20;
                v15 = v22;
                v16 = v21;
                if ((*v17 & v22) != 0) {
                    // 0x80cf924
                    str = v12;
                    if (v21 != v12) {
                        // 0x80cf929
                        *(char *)v21 = 44;
                        str = v21 + 1;
                    }
                    // 0x80cf92f
                    strcpy((char *)str, (char *)*(int32_t *)(v20 + 4));
                    v15 = v22 & -1 - *v17;
                    v16 = *(int32_t *)(v20 + 8) + str;
                }
            }
            // 0x80cf960
            v18 = v16;
            v13++;
            v19 = v20 + 16;
            v14 = v18;
        }
    }
    int32_t v23 = mem_any_set(&v4, 8); // 0x80cf980
    int32_t v24 = v14; // 0x80cf98d
    char * str4; // 0x80cf700
    int32_t v25; // 0x80cf700
    int32_t v26; // 0x80cf700
    int32_t v27; // 0x80cf700
    int32_t v28; // 0x80cf700
    int32_t v29; // 0x80cf700
    int32_t v30; // 0x80cf700
    int32_t v31; // 0x80cf700
    int32_t v32; // 0x80cf700
    int32_t v33; // 0x80cf700
    char * v34; // 0x80cf700
    char * v35; // 0x80cf700
    int32_t v36; // 0x80cfb3e
    if (v23 != 0) {
        int32_t v37 = v12; // 0x80cf996
        if (v14 != v12) {
            // 0x80cf998
            *(char *)v14 = 44;
            v37 = v14 + 1;
        }
        // 0x80cf99e
        *(int32_t *)v37 = 0x72656874;
        *(int32_t *)(v37 + 4) = 0x6c616d;
        int32_t v38 = v37 + 7; // 0x80cf9af
        grow_layer_list(v38);
        int32_t v39 = num_layers; // 0x80cf9c9
        int32_t v40 = 0; // 0x80cf9c9
        int32_t v41; // 0x80cf700
        while (true) {
            int32_t v42 = v40;
            int32_t v43; // bp-4, 0x80cf700
            unsigned char v44 = *(char *)((int32_t)&v43 - 36 + v42 / 2); // 0x80cf9e9
            uint32_t v45 = (int32_t)v44; // 0x80cf9e9
            uint32_t v46 = 4 * v42 & 4; // 0x80cf9ee
            int32_t v47; // 0x80cf700
            if ((15 << v46 & v45) == 0) {
                // 0x80cf9d0
                v47 = num_layers;
                v41 = num_layers;
                if (v42 == 15) {
                    // break -> 0x80cfa1d
                    break;
                }
            } else {
                int32_t v48 = v39; // 0x80cf9fe
                if (v42 >= v39) {
                    // 0x80cfa98
                    grow_layer_list(v46);
                    v48 = num_layers;
                }
                // 0x80cfa04
                *(char *)(layers + v42) = (char)(v45 >> v46) % 16;
                v47 = v48;
                v41 = v48;
                if (v42 == 15) {
                    // break -> 0x80cfa1d
                    break;
                }
            }
            // 0x80cf9e0
            v39 = v47;
            v40 = v42 + 1;
        }
        char v49 = 2; // 0x80cfa28
        if (v41 >= 1) {
            uint32_t v50 = 0;
            char v51 = 2;
            char v52 = v51; // 0x80cfa5c
            int32_t v53; // 0x80cf700
            int32_t v54; // 0x80cf700
            int32_t v55; // 0x80cf700
            int32_t v56; // 0x80cf700
            int32_t v57; // 0x80cf700
            int32_t v58; // 0x80cfa88
            if (*(char *)(v50 + layers) != 0) {
                // 0x80cfa5e
                v53 = 2;
                if (v50 >= 10) {
                    // 0x80cfa68
                    v53 = 3;
                    v54 = v50;
                    if (v50 >= 100) {
                        v57 = 1;
                        v55 = v54;
                        v58 = (int32_t)(0x66666667 * (int64_t)v55 / 0x100000000) / 4 - (int32_t)(v55 < 0);
                        v56 = v57 + 1;
                        while (v58 > 9) {
                            // 0x80cfa78
                            v57 = v56;
                            v55 = v58;
                            v58 = (int32_t)(0x66666667 * (int64_t)v55 / 0x100000000) / 4 - (int32_t)(v55 < 0);
                            v56 = v57 + 1;
                        }
                        // 0x80cfa91
                        v53 = v57 + 2;
                    }
                }
                // 0x80cfa40
                v52 = (int32_t)v51 + 1 + v53;
            }
            char v59 = v52;
            int32_t v60 = v50 + 1; // 0x80cfa4a
            v49 = v59;
            while (v60 != v41) {
                // 0x80cfa55
                v50 = v60;
                v51 = v59;
                v52 = v51;
                if (*(char *)(v50 + layers) != 0) {
                    // 0x80cfa5e
                    v53 = 2;
                    if (v50 >= 10) {
                        // 0x80cfa68
                        v53 = 3;
                        v54 = v50;
                        if (v50 >= 100) {
                            v57 = 1;
                            v55 = v54;
                            v58 = (int32_t)(0x66666667 * (int64_t)v55 / 0x100000000) / 4 - (int32_t)(v55 < 0);
                            v56 = v57 + 1;
                            while (v58 > 9) {
                                // 0x80cfa78
                                v57 = v56;
                                v55 = v58;
                                v58 = (int32_t)(0x66666667 * (int64_t)v55 / 0x100000000) / 4 - (int32_t)(v55 < 0);
                                v56 = v57 + 1;
                            }
                            // 0x80cfa91
                            v53 = v57 + 2;
                        }
                    }
                    // 0x80cfa40
                    v52 = (int32_t)v51 + 1 + v53;
                }
                // 0x80cfa4a
                v59 = v52;
                v60 = v50 + 1;
                v49 = v59;
            }
        }
        int32_t size = v49; // 0x80cfb12
        char * v61 = g102;
        int32_t v62 = (int32_t)v61; // 0x80cfb1b
        int32_t v63 = v41; // 0x80cfb1b
        if (g101 < size) {
            int32_t * mem; // 0x80cf700
            if (v61 == NULL) {
                // 0x80cfd2c
                mem = malloc(size);
            } else {
                // 0x80cfc05
                mem = realloc((int32_t *)v61, size);
            }
            // 0x80cfc19
            g102 = (char *)mem;
            v63 = num_layers;
            g101 = size;
            v62 = (int32_t)mem;
        }
        int32_t v64 = v62 + 1; // 0x80cfb26
        char * v65 = (char *)v62;
        *v65 = 40;
        char * str3 = v65; // 0x80cfb31
        int32_t v66 = v64; // 0x80cfb31
        v28 = v64;
        v25 = v63;
        v32 = 0;
        if (v63 >= 1) {
            while (true) {
              lab_0x80cfb38:
                // 0x80cfb38
                v33 = v32;
                v29 = v28;
                v36 = v33 + 1;
                int32_t v67 = layers + v33; // 0x80cfb41
                char v68 = *(char *)v67; // 0x80cfb44
                v30 = v29;
                v27 = v36;
                if (v68 == 0) {
                    goto lab_0x80cfbe3;
                } else {
                    int32_t v69 = v25;
                    int32_t v70 = v36; // 0x80cfb57
                    if (v69 > v36) {
                        int32_t v71 = v67; // 0x80cfb62
                        int32_t v72 = v36; // 0x80cfb62
                        v70 = v36;
                        if (*(char *)(v36 + layers) == 1) {
                            int32_t v73 = v72 + 1; // 0x80cfb7c
                            v70 = v73;
                            while (v69 > v73) {
                                int32_t v74 = v71;
                                v71 = v74 + 1;
                                v72 = v73;
                                v70 = v73;
                                if (*(char *)(v74 + 2) != 1) {
                                    // break -> 0x80cfb83
                                    break;
                                }
                                v73 = v72 + 1;
                                v70 = v73;
                            }
                        }
                    }
                    int32_t v75 = v70;
                    if (v33 + 2 < v75) {
                        char * v76 = (char *)v29;
                        __sprintf_chk(v76, 1, -1, "%d-%d,", v33, v75 - 1);
                        str4 = v76;
                        v26 = v75;
                        goto lab_0x80cfbd5;
                    } else {
                        // 0x80cfb8e
                        v35 = "%d+,";
                        if (v68 == 2) {
                            goto lab_0x80cfbba;
                        } else {
                            if (v68 > 2) {
                                if (v68 == 3) {
                                    char * v77 = (char *)v29;
                                    __sprintf_chk(v77, 1, -1, "%dS,", v33);
                                    str4 = v77;
                                    v26 = v36;
                                    goto lab_0x80cfbd5;
                                } else {
                                    // 0x80cfc7e
                                    v35 = "%dt,";
                                    v34 = "%dX,";
                                    if (v68 != 4) {
                                        goto lab_0x80cfbba;
                                    } else {
                                        goto lab_0x80cfc9a;
                                    }
                                }
                            } else {
                                // 0x80cfb9e
                                v35 = "%dt,";
                                v34 = "%d,";
                                if (v68 == 1) {
                                    goto lab_0x80cfc9a;
                                } else {
                                    goto lab_0x80cfbba;
                                }
                            }
                        }
                    }
                }
            }
          lab_0x80cfab8:
            // 0x80cfab8
            str3 = g102;
            v66 = v31;
        }
        // 0x80cfabd
        *(char *)(v66 - 1) = 41;
        *(char *)v66 = 0;
        char * str2 = (char *)v38; // 0x80cfad1
        strcpy(str2, str3);
        v24 = strlen(str2) + v38;
    }
    // 0x80cfae6
    *(char *)v24 = 34;
    *(char *)(v24 + 1) = 0;
    if (v3 != __readgsdword(20)) {
        // 0x80cfd41
        __stack_chk_fail();
        return (char *)&g231;
    }
    // 0x80cfb00
    return result;
  lab_0x80cfbe3:
    // 0x80cfbe3
    v31 = v30;
    v28 = v31;
    v25 = num_layers;
    v32 = v27;
    if (num_layers <= v27) {
        // break -> 0x80cfab8
        goto lab_0x80cfab8;
    }
    goto lab_0x80cfb38;
  lab_0x80cfbd5:
    // 0x80cfbd5
    v30 = strlen(str4) + v29;
    v27 = v26;
    goto lab_0x80cfbe3;
  lab_0x80cfbba:;
    char * v78 = (char *)v29;
    __sprintf_chk(v78, 1, -1, v35, v33);
    str4 = v78;
    v26 = v36;
    goto lab_0x80cfbd5;
  lab_0x80cfc9a:;
    char * v79 = (char *)v29;
    __sprintf_chk(v79, 1, -1, v34, v33);
    str4 = v79;
    v26 = v36;
    goto lab_0x80cfbd5;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/strflags.c
// Address range: 0x80cfd50 - 0x80cfd7d
// Line range:    565 - 571
char * pcbflags_to_string(int32_t flags) {
    // 0x80cfd50
    return common_flags_to_string(-1, (int32_t)&pcb_flagbits, 22, (int32_t)&g231);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/strflags.c
// Address range: 0x80cfd80 - 0x80cfdac
// Line range:    556 - 562
char * flags_to_string(int32_t flags, int32_t object_type) {
    // 0x80cfd80
    int32_t v1; // 0x80cfd80
    return common_flags_to_string(v1, (int32_t)&object_flagbits, 23, (int32_t)&g231);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/strflags.c
// Address range: 0x80cfdb0 - 0x80d0243
// Line range:    379 - 439
int32_t common_string_to_flags(char * flagstring, int32_t (*error)(char *), int32_t flagbits, int32_t n_flagbits) {
    // 0x80cfdb0
    int32_t result; // 0x80cfdb0
    int32_t v1 = result;
    int32_t v2 = __readgsdword(20); // 0x80cfdc5
    char v3; // 0x80cfdb0
    char v4; // 0x80cfdb0
    int32_t v5; // 0x80cfdb0
    int32_t v6; // 0x80cfdb0
    int32_t v7; // 0x80cfdb0
    int32_t v8; // 0x80cfdb0
    int32_t v9; // 0x80cfdb0
    if (result == 0) {
        // 0x80d021f
        __asm_rep_movsd_memcpy((char *)result, (char *)&empty_flags, 3);
        goto lab_0x80cff5a;
    } else {
        char v10 = result;
        char v11 = v10; // 0x80cfe0a
        int32_t v12; // 0x80cfdb0
        if (v10 == 34) {
            int32_t v13 = result + 1; // 0x80d0210
            v11 = *(char *)v13;
            v12 = v13;
        }
        // 0x80cfe10
        v5 = v12;
        v7 = 0;
        v3 = v11;
        v6 = v12;
        v8 = 0;
        v4 = 44;
        v9 = 0;
        switch (v11) {
            case 34: {
                goto lab_0x80cff40;
            }
            case 0: {
                goto lab_0x80cff40;
            }
            case 44: {
                goto lab_0x80cfef2;
            }
            default: {
                goto lab_0x80cfe38;
            }
        }
    }
  lab_0x80cfe91:;
    // 0x80cfe91
    int32_t v14; // 0x80cfdb0
    int32_t v15 = v14;
    if (error > NULL) {
        int32_t v16 = 0; // 0x80cfea0
        int32_t v17 = (int32_t)flagstring; // 0x80cfea0
        int32_t v18; // 0x80cfdb0
        int32_t v19; // 0x80cfdb0
        int32_t v20; // 0x80cfdb0
        int32_t v21; // 0x80cfdb0
        int32_t v22; // 0x80cfdb0
        int32_t v23; // 0x80cfdb0
        int32_t v24; // 0x80cfdb0
        int32_t v25; // 0x80cfdb0
        char v26; // 0x80cfec3
        if (*(int32_t *)(v17 + 8) == v15) {
            // 0x80cfebb
            if (v15 == 0) {
                // 0x80cfec7
                goto lab_0x80cfecc;
            }
            v23 = *(int32_t *)(v18 + 4);
            v26 = *(char *)v24;
            v19 = v15 - 1;
            v22 = v23 + v25;
            v21 = v24 + v25;
            while (*(char *)v23 == v26) {
                v20 = v19;
                if (v20 == 0) {
                    // 0x80cfec7
                    goto lab_0x80cfecc;
                }
                v26 = *(char *)v21;
                v19 = v20 - 1;
                v22 += v25;
                v21 += v25;
            }
        }
        // 0x80cfea8
        v16++;
        v17 += 16;
        while (v16 < (int32_t)error) {
            // 0x80cfeb3
            if (*(int32_t *)(v17 + 8) == v15) {
                // 0x80cfebb
                v20 = v15;
                if (v20 == 0) {
                    // 0x80cfec7
                    goto lab_0x80cfecc;
                }
                v23 = *(int32_t *)(v18 + 4);
                v26 = *(char *)v24;
                v19 = v20 - 1;
                v22 = v23 + v25;
                v21 = v24 + v25;
                while (*(char *)v23 == v26) {
                    v20 = v19;
                    if (v20 == 0) {
                        // 0x80cfec7
                        goto lab_0x80cfecc;
                    }
                    v26 = *(char *)v21;
                    v19 = v20 - 1;
                    v22 += v25;
                    v21 += v25;
                }
            }
            // 0x80cfea8
            v16++;
            v17 += 16;
        }
    }
    char * v27 = alloc_buf((int32_t)&g231); // 0x80cfefe
    int32_t v28; // 0x80cfdb0
    __sprintf_chk(v27, 1, -1, "Unknown flag: \"%.*s\" ignored", v15, (char *)v28);
    int32_t v29; // 0x80cfdb0
    char v30 = *(char *)v29; // 0x80cff39
    int32_t v31; // 0x80cfdb0
    int32_t v32 = v31; // 0x80cff3e
    int32_t v33 = v29; // 0x80cff3e
    char v34 = v30; // 0x80cff3e
    v9 = v31;
    if (v30 != 34) {
        goto lab_0x80cfed6;
    } else {
        goto lab_0x80cff40;
    }
  lab_0x80cfe88:;
    // 0x80cfe88
    int32_t v35; // 0x80cfdb0
    v28 = v35;
    int32_t v36; // 0x80cfdb0
    v31 = v36;
    int32_t v37; // 0x80cfdb0
    v29 = v37;
    int32_t v38; // 0x80cfdb0
    v14 = v38;
    int32_t v39 = v35; // 0x80cfe8b
    int32_t v40 = v36; // 0x80cfe8b
    int32_t v41 = v37; // 0x80cfe8b
    int32_t v42 = 7; // 0x80cfe8b
    if (v38 == 7) {
        goto lab_0x80cff89;
    } else {
        goto lab_0x80cfe91;
    }
  lab_0x80d00a9:;
    // 0x80d00a9
    int32_t v43; // 0x80d0078
    int32_t v44 = v43 + 1; // 0x80d00a9
    char v45 = *(char *)v44; // 0x80d00ac
    int32_t v46; // 0x80cfdb0
    v35 = v46;
    int32_t v47; // 0x80cfdb0
    v36 = v47;
    v37 = v44;
    int32_t v48; // 0x80cfdb0
    v38 = v48;
    int32_t v49 = v44; // 0x80d00b5
    int32_t v50; // 0x80cfdb0
    int32_t v51 = v50 + 1; // 0x80d00b5
    int32_t v52; // 0x80cfdb0
    int32_t v53 = v52; // 0x80d00b5
    int32_t v54; // 0x80cfdb0
    int32_t v55 = v54; // 0x80d00b5
    char v56 = v45; // 0x80d00b5
    int32_t v57; // 0x80cfdb0
    int32_t v58 = v57; // 0x80d00b5
    int32_t v59; // 0x80cfdb0
    int32_t v60 = v59; // 0x80d00b5
    if (v45 == 0) {
        goto lab_0x80cfe88;
    }
    goto lab_0x80d00bf;
  lab_0x80d00f8:;
    // 0x80d00f8
    int32_t v61; // 0x80cfdb0
    int32_t v76 = v61; // 0x80d00fb
    char v77; // 0x80cfdb0
    char v63; // 0x80d00e8
    int32_t v62; // 0x80cfdb0
    if (v62 == -1) {
        goto lab_0x80d0105;
    } else {
        // 0x80d0101
        v76 = v62;
        v77 = v63;
        if (v62 > v61) {
            goto lab_0x80d0147;
        } else {
            goto lab_0x80d0105;
        }
    }
  lab_0x80d00a0:;
    // 0x80d00a0
    int32_t v68; // 0x80cfdb0
    v52 = v68;
    int32_t v69; // 0x80cfdb0
    v54 = v69;
    int32_t v72; // 0x80cfdb0
    v59 = v72;
    int32_t v71; // 0x80cfdb0
    v57 = v71;
    char v70; // 0x80cfdb0
    if (v70 == 41) {
        // break -> 0x80d00d7
        goto lab_0x80d00d7;
    }
    goto lab_0x80d00a9;
  lab_0x80d0105:;
    int32_t v78 = v76; // 0x80d010d
    int32_t v65; // 0x80cfdb0
    int32_t v79 = v65 % 256; // 0x80d010d
    while (true) {
        int32_t v80 = v79;
        int32_t v81 = v78;
        int32_t v82 = v81 + 1; // 0x80d0125
        int32_t v83; // 0x80cfdb0
        if (num_layers > v81) {
            // 0x80d0110
            *(char *)(layers + v81) = (char)v80;
            v83 = v80;
            if (v82 > v61) {
                // break -> 0x80d0147
                break;
            }
        } else {
            int32_t v84 = 0x1000000 * v80 / 0x1000000; // 0x80d012c
            grow_layer_list(v84);
            *(char *)(layers + v81) = (char)v84;
            v83 = v84 % 256;
            if (v82 > v61) {
                // break -> 0x80d0147
                break;
            }
        }
        // 0x80d011d
        v78 = v82;
        v79 = v83;
    }
    // 0x80d0147
    v77 = *(char *)v43;
    goto lab_0x80d0147;
  lab_0x80d0147:
    // 0x80d0147
    v68 = 1;
    int32_t v64; // 0x80cfdb0
    v69 = v64;
    v70 = v77;
    v71 = -1;
    v72 = 0;
    v52 = 1;
    v54 = v64;
    v59 = 0;
    v57 = v61;
    if (v77 == 45) {
        goto lab_0x80d00a9;
    } else {
        goto lab_0x80d00a0;
    }
  lab_0x80cff5a:
    // 0x80cff5a
    if (v2 != __readgsdword(20)) {
        // 0x80d023c
        __stack_chk_fail();
        return string_to_pcbflags((char *)&g231, (int32_t (*)(char *))&g231);
    }
    // 0x80cff6d
    return result;
  lab_0x80cff40:
    // 0x80cff40
    *(int32_t *)result = v9;
    *(int32_t *)(result + 4) = g104;
    *(int32_t *)(result + 8) = g105;
    goto lab_0x80cff5a;
  lab_0x80cfef2:;
    int32_t v85 = v6; // 0x80cfef4
    int32_t v86 = v8; // 0x80cfef4
    int32_t v87 = v6; // 0x80cfef4
    char v88 = v4; // 0x80cfef4
    int32_t v89 = 0; // 0x80cfef4
    goto lab_0x80cfe80;
  lab_0x80cfe38:;
    char v118 = v3;
    int32_t v119 = v7;
    int32_t v120 = v5;
    v28 = v120;
    v31 = v119;
    v29 = v120;
    v14 = 0;
    v6 = v120;
    v8 = v119;
    v4 = 0;
    int32_t v93; // 0x80cfdb0
    int32_t v90; // 0x80cfdb0
    int32_t v92; // 0x80cfdb0
    int32_t v91; // 0x80cfdb0
    switch (v118) {
        case 0: {
            goto lab_0x80cfef2;
        }
        case 34: {
            goto lab_0x80cfe91;
        }
        default: {
            int32_t v121 = v120; // 0x80cfe4b
            v90 = v120;
            v91 = v119;
            v92 = v120;
            v93 = 0;
            if (v118 != 40) {
                int32_t v122; // 0x80cfe6e
                char v123; // 0x80cfe71
                while (true) {
                  lab_0x80cfe6e:
                    // 0x80cfe6e
                    v122 = v121 + 1;
                    v123 = *(char *)v122;
                    v121 = v122;
                    switch (v123) {
                        case 44: {
                            goto lab_0x80cfe78;
                        }
                        case 0: {
                            goto lab_0x80cfe78;
                        }
                        case 34: {
                            int32_t v124 = v122 - v120; // 0x80cff7a
                            v28 = v120;
                            v31 = v119;
                            v29 = v122;
                            v14 = v124;
                            v39 = v120;
                            v40 = v119;
                            v41 = v122;
                            v42 = v124;
                            if (v124 != 7) {
                                goto lab_0x80cfe91;
                            } else {
                                goto lab_0x80cff89;
                            }
                        }
                        case 40: {
                            // 0x80cfff0
                            v90 = v120;
                            v91 = v119;
                            v92 = v122;
                            v93 = v122 - v120;
                            goto lab_0x80cfff8;
                        }
                        default: {
                            goto lab_0x80cfe6e;
                        }
                    }
                }
              lab_0x80cfe78:
                // 0x80cfe78
                v85 = v120;
                v86 = v119;
                v87 = v122;
                v88 = v123;
                v89 = v122 - v120;
                goto lab_0x80cfe80;
            } else {
                goto lab_0x80cfff8;
            }
        }
    }
  lab_0x80cfe80:
    // 0x80cfe80
    v35 = v85;
    v36 = v86;
    v37 = v87;
    v38 = v89;
    v90 = v85;
    v91 = v86;
    v92 = v87;
    v93 = v89;
    if (v88 == 40) {
        goto lab_0x80cfff8;
    } else {
        goto lab_0x80cfe88;
    }
  lab_0x80cfff8:
    // 0x80cfff8
    v48 = v93;
    v47 = v91;
    v46 = v90;
    int32_t v94 = v92 + 1; // 0x80cfffa
    grow_layer_list(v94);
    char * str = (char *)v94; // 0x80d0006
    char v95 = *str; // 0x80d0006
    v35 = v46;
    v36 = v47;
    v37 = v94;
    v38 = v48;
    v49 = v94;
    v51 = 5;
    v53 = 1;
    v55 = v1 != 0 ? v1 : 0x80cf5b0;
    v56 = v95;
    v58 = -1;
    v60 = 0;
    if (v95 != 0) {
        while (true) {
          lab_0x80d00bf:
            // 0x80d00bf
            v61 = v60;
            v62 = v58;
            v63 = v56;
            v64 = v55;
            v50 = v51;
            v43 = v49;
            if (v63 != 43) {
                // 0x80d0040
                v65 = v53;
                v52 = 3;
                v54 = v64;
                v59 = v61;
                v57 = v62;
                switch (v63) {
                    case 83: {
                        goto lab_0x80d00a9;
                    }
                    case 88: {
                        // 0x80d0168
                        v52 = 4;
                        v54 = v64;
                        v59 = v61;
                        v57 = v62;
                        goto lab_0x80d00a9;
                    }
                    case 116: {
                        // 0x80d0178
                        v52 = 5;
                        v54 = v64;
                        v59 = v61;
                        v57 = v62;
                        goto lab_0x80d00a9;
                    }
                    case 44: {
                        goto lab_0x80d00f8;
                    }
                    case 41: {
                        goto lab_0x80d00f8;
                    }
                    case 45: {
                        goto lab_0x80d00f8;
                    }
                    default: {
                        int16_t * v66 = *__ctype_b_loc(); // 0x80d0086
                        char v67 = *(char *)((0x1000000 * (int32_t)v63 / 0x800000 | 1) + (int32_t)v66); // 0x80d0088
                        if ((v67 & 8) == 0) {
                            if (v64 == 0) {
                                // 0x80d0208
                                v68 = v65;
                                v69 = 0;
                                v70 = *(char *)v43;
                                v71 = v62;
                                v72 = v61;
                            } else {
                                // 0x80d018e
                                strlen(str);
                                char * v73 = alloc_buf((int32_t)&g231); // 0x80d019f
                                char * v74 = (char *)v43; // 0x80d01ac
                                char v75 = *v74; // 0x80d01ac
                                __sprintf_chk(v73, 1, -1, "Syntax error parsing layer list \"%.*s\" at %c", v50, str, v75);
                                v68 = v65;
                                v69 = 0;
                                v70 = *v74;
                                v71 = v62;
                                v72 = v61;
                            }
                        } else {
                            // 0x80d0093
                            v68 = v65;
                            v69 = v64;
                            v70 = *(char *)v43;
                            v71 = v62;
                            v72 = (int32_t)v63 - 48 + 10 * v61;
                        }
                        goto lab_0x80d00a0;
                    }
                }
            } else {
                // 0x80d00c8
                v52 = 2;
                v54 = v64;
                v59 = v61;
                v57 = v62;
                if (v63 == 41) {
                    // break -> 0x80d00d7
                    break;
                }
                goto lab_0x80d00a9;
            }
        }
      lab_0x80d00d7:
        // 0x80d00d7
        v35 = v46;
        v36 = v47;
        v37 = v43 + 1;
        v38 = v48;
    }
    goto lab_0x80cfe88;
  lab_0x80cfed6:
    // 0x80cfed6
    v9 = v32;
    if (v34 == 0) {
        goto lab_0x80cff40;
    } else {
        int32_t v96 = v33 + 1;
        char v97 = *(char *)v96; // 0x80cfee3
        v5 = v96;
        v7 = v32;
        v3 = v97;
        v6 = v96;
        v8 = v32;
        v4 = v97;
        if (v97 != 44) {
            goto lab_0x80cfe38;
        } else {
            goto lab_0x80cfef2;
        }
    }
  lab_0x80cff89:;
    int32_t v98 = v42;
    int32_t v99 = v41;
    int32_t v100 = v40;
    int32_t v101 = v39;
    bool v102; // 0x80cfdb0
    int32_t v103 = v102 ? -1 : 1; // 0x80cff96
    int32_t v104 = v101; // 0x80cff96
    int32_t v105 = (int32_t)"thermal"; // 0x80cff96
    int32_t v106 = 7;
    while (v106 != 0) {
        int32_t v107 = v104;
        char v108 = *(char *)v105; // 0x80cff96
        v28 = v101;
        v31 = v100;
        v29 = v99;
        v14 = v98;
        int32_t v109 = v106 - 1; // 0x80cff96
        v104 = v107 + v103;
        v105 += v103;
        if (*(char *)v107 != v108) {
            goto lab_0x80cfe91;
        }
        v106 = v109;
    }
    uint32_t v110 = 0;
    while (num_layers > v110) {
        unsigned char v111 = *(char *)(v110 + layers); // 0x80cffb9
        if (v111 != 0) {
            uint32_t v112 = 4 * v110 & 4; // 0x80cffcd
            int32_t v113; // bp-4, 0x80cfdb0
            char * v114 = (char *)((int32_t)&v113 - 36 + v110 / 2); // 0x80cffd6
            char v115 = *v114; // 0x80cffd6
            *v114 = v115 & -1 - (char)(15 << v112) | (char)((int32_t)v111 << v112);
        }
        int32_t v116 = v110 + 1; // 0x80cffe8
        if (v110 == 15) {
            // break -> 0x80cfecc
            break;
        }
        v110 = v116;
    }
    goto lab_0x80cfecc;
  lab_0x80cfecc:;
    char v117 = *(char *)v99; // 0x80cfecf
    v32 = v100;
    v33 = v99;
    v34 = v117;
    v9 = v100;
    if (v117 == 34) {
        goto lab_0x80cff40;
    } else {
        goto lab_0x80cfed6;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/strflags.c
// Address range: 0x80d0250 - 0x80d0280
// Line range:    452 - 459
int32_t string_to_pcbflags(char * flagstring, int32_t (*error)(char *)) {
    // 0x80d0250
    common_string_to_flags((char *)&pcb_flagbits, (int32_t (*)(char *))22, (int32_t)&g231, (int32_t)&g231);
    return (int32_t)flagstring;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/strflags.c
// Address range: 0x80d0280 - 0x80d02b0
// Line range:    442 - 449
int32_t string_to_flags(char * flagstring, int32_t (*error)(char *)) {
    // 0x80d0280
    common_string_to_flags((char *)&object_flagbits, (int32_t (*)(char *))23, (int32_t)&g231, (int32_t)&g231);
    return (int32_t)flagstring;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/undo.c
// Address range: 0x80d18d0 - 0x80d18df
// Line range:    1079 - 1082
void RestoreUndoSerialNumber(void) {
    // 0x80d18d0
    Serial = SavedSerial;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/undo.c
// Address range: 0x80d18e0 - 0x80d18f6
// Line range:    1088 - 1092
void SaveUndoSerialNumber(void) {
    // 0x80d18e0
    Bumped = 0;
    SavedSerial = Serial;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/undo.c
// Address range: 0x80d1930 - 0x80d1ad0
// Line range:    202 - 230
int32_t GetUndoSlot(int32_t CommandType, int32_t ID2, int32_t Kind) {
    uint32_t v1 = UndoMax; // 0x80d1939
    int32_t v2 = UndoN; // 0x80d194f
    if (UndoN >= v1) {
        int32_t v3 = v1 + 500; // 0x80d1a4d
        UndoMax = v3;
        uint32_t v4 = 32 * v3; // 0x80d1a59
        int32_t v5 = (int32_t)MyRealloc((char *)UndoList, v4, "AddCommandToUndoList()"); // 0x80d1a6b
        UndoList = v5;
        memset((int32_t *)(32 * UndoN + v5), 0, 0x3e80);
        if (v4 > g40) {
            // 0x80d1aaa
            g40 = v4 + 0x100000 & -0x100000;
            Message("Size of 'undo-list' exceeds %li kb\n", v3 / 32 % 0x400000);
        }
        // 0x80d1aa0
        v2 = UndoN;
    }
    int32_t v6 = UndoList + 32 * v2; // 0x80d1960
    int32_t v7 = v2; // 0x80d1968
    int32_t result = v6; // 0x80d1968
    if (RedoN != 0) {
        int32_t v8 = *(int32_t *)(v6 + 4); // 0x80d1991
        char * v9; // bp-32, 0x80d1930
        char * v10; // bp-36, 0x80d1930
        char * v11; // bp-40, 0x80d1930
        int32_t v12; // 0x80d19a8
        int32_t v13; // 0x80d19af
        int32_t v14; // 0x80d19cd
        if (v8 != 1) {
            if (v8 == 4) {
                // 0x80d19a8
                v12 = *(int32_t *)(v6 + 8);
                v13 = *(int32_t *)(v6 + 12);
                v14 = SearchObjectByID(RemoveList, &v9, &v10, &v11, v13, v12);
                if (v14 != 0) {
                    // 0x80d19d6
                    DestroyObject(RemoveList, v14, v9, v10, v11);
                }
            }
        } else {
            // 0x80d1999
            SaveFree((char *)*(int32_t *)(v6 + 16));
        }
        int32_t v15 = RedoN - 1; // 0x80d1982
        RedoN = v15;
        int32_t v16 = v6 + 32; // 0x80d198c
        while (v15 != 0) {
            int32_t v17 = v16;
            v8 = *(int32_t *)(v17 + 4);
            if (v8 != 1) {
                if (v8 == 4) {
                    // 0x80d19a8
                    v12 = *(int32_t *)(v17 + 8);
                    v13 = *(int32_t *)(v17 + 12);
                    v14 = SearchObjectByID(RemoveList, &v9, &v10, &v11, v13, v12);
                    if (v14 != 0) {
                        // 0x80d19d6
                        DestroyObject(RemoveList, v14, v9, v10, v11);
                    }
                }
            } else {
                // 0x80d1999
                SaveFree((char *)*(int32_t *)(v17 + 16));
            }
            // 0x80d197d
            v15 = RedoN - 1;
            RedoN = v15;
            v16 = v17 + 32;
        }
        // 0x80d1a08
        v7 = UndoN;
        result = 32 * v7 + UndoList;
    }
    // 0x80d1a18
    UndoN = v7 + 1;
    *(int32_t *)result = Serial;
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/undo.c
// Address range: 0x80d1da0 - 0x80d1ddb
// Line range:    1327 - 1336
void AddObjectToFlagUndoList(int32_t Type, char * Ptr1, char * Ptr2, char * Ptr3) {
    // 0x80d1da0
    if (Locked == 0) {
        int32_t v1 = (int32_t)Ptr1;
        int32_t v2; // 0x80d1da0
        int32_t v3 = GetUndoSlot(v2, v2, (int32_t)&g231); // 0x80d1dbe
        *(int32_t *)(v3 + 16) = *(int32_t *)(v1 + 20);
        *(int32_t *)(v3 + 20) = *(int32_t *)(v1 + 24);
        *(int32_t *)(v3 + 24) = *(int32_t *)(v1 + 28);
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/undo.c
// Address range: 0x80d23d0 - 0x80d24cf
// Line range:    1117 - 1125
void ClearUndoList(char Force) {
    // 0x80d23d0
    if (UndoN == 0) {
        // 0x80d2486
        Serial = 1;
        return;
    }
    int32_t v1 = UndoList;
    if (*(int32_t *)(v1 + 4) == 1) {
        // 0x80d241a
        SaveFree((char *)*(int32_t *)(v1 + 16));
    }
    int32_t v2 = UndoN - 1; // 0x80d2405
    UndoN = v2;
    int32_t v3 = v1 + 32; // 0x80d240f
    while (v2 != 0) {
        // 0x80d2414
        v1 = v3;
        int32_t v4 = v2; // 0x80d2418
        if (*(int32_t *)(v1 + 4) == 1) {
            // 0x80d241a
            SaveFree((char *)*(int32_t *)(v1 + 16));
            v4 = UndoN;
        }
        // 0x80d2400
        v2 = v4 - 1;
        UndoN = v2;
        v3 = v1 + 32;
    }
    // 0x80d242e
    SaveFree((char *)UndoList);
    UndoList = 0;
    if (RemoveList != 0) {
        // 0x80d2449
        FreeDataMemory(RemoveList);
        free((int32_t *)RemoveList);
        RemoveList = 0;
    }
    // 0x80d2468
    RedoN = 0;
    UndoMax = 0;
    UndoN = 0;
    // 0x80d2486
    Serial = 1;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/undo.c
// Address range: 0x80d24d0 - 0x80d2525
// Line range:    1100 - 1111
void IncrementUndoSerialNumber(void) {
    // 0x80d24d0
    if (Locked != 0 || UndoN == 0) {
        // 0x80d24ff
        return;
    }
    int32_t v1 = *(int32_t *)(32 * UndoN - 32 + UndoList); // 0x80d24f4
    if (v1 != Serial) {
        // 0x80d24ff
        return;
    }
    // 0x80d2508
    Serial = v1 + 1;
    Bumped = 1;
    SetChangedFlag(1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/vendor.c
// Address range: 0x80d3d40 - 0x80d3d5c
// Line range:    981 - 981
void register_vendor_flag_list(void) {
    // 0x80d3d40
    hid_register_flags((int32_t)&vendor_flag_list, 1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/vendor.c
// Address range: 0x80d3d60 - 0x80d3d7c
// Line range:    971 - 971
void register_vendor_action_list(void) {
    // 0x80d3d60
    hid_register_actions((int32_t)&vendor_action_list, 6);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/vendor.c
// Address range: 0x80d3d80 - 0x80d3e87
// Line range:    623 - 653
int32_t vendorDrillMap(int32_t in) {
    // 0x80d3d80
    if (cached_drill == in) {
        // 0x80d3e18
        return cached_map;
    }
    // 0x80d3d98
    cached_drill = in;
    if (n_vendor_drills == 0 || vendor_drills == NULL || vendorMapEnable == 0) {
        // 0x80d3e08
        cached_map = in;
        // 0x80d3e10
        return in;
    }
    int32_t result = (int32_t)vendor_drills; // 0x80d3da8
    if (result >= in) {
        // 0x80d3dfb
        cached_map = result;
        return result;
    }
    int32_t v1 = n_vendor_drills - 1; // 0x80d3dc1
    int32_t v2 = 4 * v1 + result;
    int32_t v3 = *(int32_t *)v2; // 0x80d3dc6
    if (v3 < in) {
        // 0x80d3e45
        Message("Vendor drill list does not contain a drill >= %6.2f mil\nUsing %6.2f mil instead.\n", (float64_t)(0.01L * (float80_t)in), (float64_t)(0.01L * (float80_t)v3));
        int32_t result2 = *(int32_t *)((int32_t)vendor_drills - 4 + 4 * n_vendor_drills); // 0x80d3e7c
        cached_map = result2;
        // 0x80d3e10
        return result2;
    }
    int32_t v4 = v1; // 0x80d3ded
    int32_t v5 = 0; // 0x80d3ded
    int32_t v6 = v2; // 0x80d3ded
    if (v1 > 1) {
        int32_t v7 = v5 + v4; // 0x80d3dd0
        int32_t v8 = (v7 + (int32_t)(v7 < 0)) / 2; // 0x80d3ddb
        int32_t v9 = *(int32_t *)(4 * v8 + result); // 0x80d3ddd
        int32_t v10 = in - v9; // 0x80d3ddd
        v5 = v10 < 0 == ((v10 ^ in) & (v9 ^ in)) < 0 == (v10 != 0) ? v8 : v5;
        v4 = v10 == 0 | v10 < 0 != ((v10 ^ in) & (v9 ^ in)) < 0 ? v8 : v4;
        while (v4 - v5 > 1) {
            // 0x80d3dd0
            v7 = v5 + v4;
            v8 = (v7 + (int32_t)(v7 < 0)) / 2;
            v9 = *(int32_t *)(4 * v8 + result);
            v10 = in - v9;
            v5 = v10 < 0 == ((v10 ^ in) & (v9 ^ in)) < 0 == (v10 != 0) ? v8 : v5;
            v4 = v10 == 0 | v10 < 0 != ((v10 ^ in) & (v9 ^ in)) < 0 ? v8 : v4;
        }
        // 0x80d3de6
        v6 = 4 * v4 + result;
    }
    // 0x80d3def
    if (rounding_method != 1) {
        int32_t result3 = *(int32_t *)v6;
        cached_map = result3;
        return result3;
    }
    int32_t result4 = *(int32_t *)(v6 - 4); // 0x80d3e28
    int32_t result5 = *(int32_t *)v6; // 0x80d3e2e
    if (in - result4 <= result5 - in) {
        // 0x80d3dfb
        cached_map = result4;
        return result4;
    }
    // 0x80d3e3b
    cached_map = result5;
    // 0x80d3e10
    return result5;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/vendor.c
// Address range: 0x80d3e90 - 0x80d3f60
// Line range:    884 - 949
char rematch(char * re, char * s) {
    struct _TYPEDEF_regmatch_t v1; // 0x80d3ee8
    struct _TYPEDEF_regmatch_t pmatch[1]; // 0x80d3ee8
    int32_t v2 = __readgsdword(20); // 0x80d3ea3
    int32_t preg; // bp-184, 0x80d3e90
    int32_t regex; // 0x80d3e90
    int32_t errcode = regcomp((struct re_pattern_buffer *)&preg, (char *)regex, 11); // 0x80d3ebe
    char result; // 0x80d3e90
    if (errcode != 0) {
        // 0x80d3f18
        int32_t errbuf; // bp-144, 0x80d3e90
        regerror(errcode, (struct re_pattern_buffer *)&preg, (char *)&errbuf, 128);
        Message("regexp error: %s\n", &errbuf);
        regfree((struct re_pattern_buffer *)&preg);
        result = 0;
    } else {
        // 0x80d3ec7
        v1 = (struct {int32_t e0; int32_t e1;}){
            .e0 = 0,
            .e1 = 0
        };
        int32_t v3; // bp-152, 0x80d3e90
        v1.e0 = &v3;
        pmatch[0] = v1;
        int32_t v4 = regexec((struct re_pattern_buffer *)&preg, (char *)regex, 1, pmatch, 0); // 0x80d3ee8
        regfree((struct re_pattern_buffer *)&preg);
        result = v4 == 0;
    }
    // 0x80d3efc
    if (v2 == __readgsdword(20)) {
        // 0x80d3f08
        return result;
    }
    // 0x80d3f52
    __stack_chk_fail();
    return &g231;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/vendor.c
// Address range: 0x80d3f60 - 0x80d4200
// Line range:    821 - 881
char vendorIsElementMappable(int32_t element) {
    // 0x80d3f60
    if (vendorMapEnable == 0) {
        // 0x80d403d
        return 0;
    }
    int32_t v1 = 1; // 0x80d3f89
    int32_t v2; // 0x80d3f60
    int32_t v3; // 0x80d3f60
    int32_t v4; // 0x80d3f60
    int32_t v5; // 0x80d3f60
    int32_t str3; // 0x80d3f60
    int32_t v6; // 0x80d3f97
    int32_t * v7; // 0x80d3f97
    int32_t v8; // 0x80d3f90
    int32_t str4; // 0x80d3fa5
    if (n_refdes >= 1) {
        // 0x80d3f90
        v7 = (int32_t *)(element + 148);
        v4 = 1;
        v2 = 0;
        while (true) {
          lab_0x80d3f90:
            // 0x80d3f90
            v3 = v2;
            v5 = v4;
            v8 = 4 * v3;
            str4 = *(int32_t *)(v8 + (int32_t)ignore_refdes);
            if (str4 == 0) {
                goto lab_0x80d3fd2;
            } else {
                // 0x80d3fac
                v6 = *v7;
                if (v6 == 0) {
                    // 0x80d3fb7
                    str3 = (int32_t)"(unknown)";
                    goto lab_0x80d3fbc;
                } else {
                    // 0x80d3fb0
                    str3 = v6;
                    if (*(char *)v6 != 0) {
                        goto lab_0x80d3fbc;
                    } else {
                        // 0x80d3fb7
                        str3 = (int32_t)"(unknown)";
                        goto lab_0x80d3fbc;
                    }
                }
            }
        }
      lab_0x80d4034:
        // 0x80d4034
        if (v1 == 0) {
            // 0x80d403d
            return 0;
        }
    }
    int32_t v9 = v1;
    int32_t v10 = v9; // 0x80d4050
    int32_t v11; // 0x80d3f60
    int32_t v12; // 0x80d3f60
    int32_t v13; // 0x80d3f60
    int32_t v14; // 0x80d3f60
    int32_t v15; // 0x80d4058
    int32_t str2; // 0x80d406d
    int32_t v16; // 0x80d405f
    int32_t * v17; // 0x80d405f
    if (n_value >= 1) {
        // 0x80d4058
        v17 = (int32_t *)(element + 208);
        v13 = v9;
        v11 = 0;
        while (true) {
          lab_0x80d4058:
            // 0x80d4058
            v12 = v11;
            v14 = v13;
            v15 = 4 * v12;
            str2 = *(int32_t *)(v15 + (int32_t)ignore_value);
            if (str2 == 0) {
                goto lab_0x80d409a;
            } else {
                // 0x80d4074
                v16 = *v17;
                if (v16 == 0) {
                    // 0x80d407f
                    goto lab_0x80d4084;
                } else {
                    // 0x80d4078
                    if (*(char *)v16 != 0) {
                        goto lab_0x80d4084;
                    } else {
                        // 0x80d407f
                        goto lab_0x80d4084;
                    }
                }
            }
        }
      lab_0x80d40fc:
        // 0x80d40fc
        if (v10 == 0) {
            // 0x80d403d
            return 0;
        }
    }
    // 0x80d4107
    int32_t v18; // 0x80d3f60
    int32_t v19; // 0x80d3f60
    int32_t v20; // 0x80d3f60
    int32_t v21; // 0x80d3f60
    int32_t v22; // 0x80d3f60
    int32_t * v23; // 0x80d411f
    int32_t v24; // 0x80d4118
    int32_t str; // 0x80d412a
    int32_t v25; // 0x80d411f
    if (n_descr >= 1) {
        // 0x80d4118
        v23 = (int32_t *)(element + 88);
        v20 = v10;
        v18 = 0;
        while (true) {
          lab_0x80d4118:
            // 0x80d4118
            v19 = v18;
            v21 = v20;
            v24 = 4 * v19;
            str = *(int32_t *)(v24 + (int32_t)ignore_descr);
            if (str == 0) {
                goto lab_0x80d4157;
            } else {
                // 0x80d4131
                v25 = *v23;
                if (v25 == 0) {
                    // 0x80d413c
                    goto lab_0x80d4141;
                } else {
                    // 0x80d4135
                    if (*(char *)v25 != 0) {
                        goto lab_0x80d4141;
                    } else {
                        // 0x80d413c
                        goto lab_0x80d4141;
                    }
                }
            }
        }
      lab_0x80d41b8:
        // 0x80d41b8
        if (v22 == 0) {
            // 0x80d403d
            return 0;
        }
    }
    // 0x80d41c3
    if ((*(char *)(element + 21) & 32) == 0) {
        // 0x80d403d
        return 1;
    }
    int32_t v26 = *(int32_t *)(element + 148); // 0x80d41d2
    if (v26 != 0) {
        // 0x80d41dc
        if (*(char *)v26 != 0) {
            // 0x80d41e6
            Message("Vendor mapping skipped because element %s is locked\n", (char *)v26);
            return 0;
        }
    }
    // 0x80d41e6
    Message("Vendor mapping skipped because element %s is locked\n", (char *)(int32_t)"(unknown)");
    return 0;
  lab_0x80d4157:;
    char v27 = rematch((char *)&g231, (char *)&g231); // 0x80d4169
    int32_t v28 = v21; // 0x80d4170
    int32_t v29; // 0x80d3f60
    int32_t v30; // 0x80d3f60
    if (v27 == 0) {
        goto lab_0x80d41a9;
    } else {
        // 0x80d4172
        v29 = *v23;
        v30 = *(int32_t *)(v24 + (int32_t)ignore_descr);
        goto lab_0x80d4180;
    }
  lab_0x80d41a9:
    // 0x80d41a9
    v22 = v28;
    int32_t v31 = v19 + 1; // 0x80d41a9
    v20 = v22;
    v18 = v31;
    if (n_descr <= v31) {
        // break -> 0x80d41b8
        goto lab_0x80d41b8;
    }
    goto lab_0x80d4118;
  lab_0x80d4180:;
    int32_t v32 = v29;
    int32_t v33; // 0x80d3f60
    if (v32 == 0) {
        // 0x80d4189
        v33 = (int32_t)"(unknown)";
        goto lab_0x80d418e;
    } else {
        // 0x80d4184
        v33 = v32;
        if (*(char *)v32 != 0) {
            goto lab_0x80d418e;
        } else {
            // 0x80d4189
            v33 = (int32_t)"(unknown)";
            goto lab_0x80d418e;
        }
    }
  lab_0x80d4141:;
    int32_t strcmp_rc = strcmp((char *)(int32_t)"(unknown)", (char *)str); // 0x80d414b
    v29 = v25;
    v30 = str;
    if (strcmp_rc == 0) {
        goto lab_0x80d4180;
    } else {
        goto lab_0x80d4157;
    }
  lab_0x80d418e:
    // 0x80d418e
    Message("Vendor mapping skipped because descr = %s matches %s\n", (char *)v33, (char *)v30);
    v28 = 0;
    goto lab_0x80d41a9;
  lab_0x80d409a:;
    char v34 = rematch((char *)&g231, (char *)&g231); // 0x80d40aa
    int32_t v35 = v14; // 0x80d40b1
    int32_t v36; // 0x80d3f60
    int32_t v37; // 0x80d3f60
    if (v34 == 0) {
        goto lab_0x80d40ed;
    } else {
        // 0x80d40b3
        v36 = *v17;
        v37 = *(int32_t *)(v15 + (int32_t)ignore_value);
        goto lab_0x80d40c4;
    }
  lab_0x80d40ed:
    // 0x80d40ed
    v10 = v35;
    int32_t v38 = v12 + 1; // 0x80d40ed
    v13 = v10;
    v11 = v38;
    if (n_value <= v38) {
        // break -> 0x80d40fc
        goto lab_0x80d40fc;
    }
    goto lab_0x80d4058;
  lab_0x80d40c4:;
    int32_t v39 = v36;
    int32_t v40; // 0x80d3f60
    if (v39 == 0) {
        // 0x80d40cd
        v40 = (int32_t)"(unknown)";
        goto lab_0x80d40d2;
    } else {
        // 0x80d40c8
        v40 = v39;
        if (*(char *)v39 != 0) {
            goto lab_0x80d40d2;
        } else {
            // 0x80d40cd
            v40 = (int32_t)"(unknown)";
            goto lab_0x80d40d2;
        }
    }
  lab_0x80d4084:;
    int32_t strcmp_rc2 = strcmp((char *)(int32_t)"(unknown)", (char *)str2); // 0x80d408e
    v36 = v16;
    v37 = str2;
    if (strcmp_rc2 == 0) {
        goto lab_0x80d40c4;
    } else {
        goto lab_0x80d409a;
    }
  lab_0x80d40d2:
    // 0x80d40d2
    Message("Vendor mapping skipped because value = %s matches %s\n", (char *)v40, (char *)v37);
    v35 = 0;
    goto lab_0x80d40ed;
  lab_0x80d3fd2:;
    char v41 = rematch((char *)&g231, (char *)&g231); // 0x80d3fe2
    int32_t v42 = v5; // 0x80d3fe9
    int32_t v43; // 0x80d3f60
    int32_t v44; // 0x80d3f60
    if (v41 == 0) {
        goto lab_0x80d4025;
    } else {
        // 0x80d3feb
        v43 = *v7;
        v44 = *(int32_t *)(v8 + (int32_t)ignore_refdes);
        goto lab_0x80d3ffc;
    }
  lab_0x80d4025:
    // 0x80d4025
    v1 = v42;
    int32_t v45 = v3 + 1; // 0x80d4025
    v4 = v1;
    v2 = v45;
    if (n_refdes <= v45) {
        // break -> 0x80d4034
        goto lab_0x80d4034;
    }
    goto lab_0x80d3f90;
  lab_0x80d3ffc:;
    int32_t v46 = v43;
    int32_t v47; // 0x80d3f60
    if (v46 == 0) {
        // 0x80d4005
        v47 = (int32_t)"(unknown)";
        goto lab_0x80d400a;
    } else {
        // 0x80d4000
        v47 = v46;
        if (*(char *)v46 != 0) {
            goto lab_0x80d400a;
        } else {
            // 0x80d4005
            v47 = (int32_t)"(unknown)";
            goto lab_0x80d400a;
        }
    }
  lab_0x80d3fbc:;
    int32_t strcmp_rc3 = strcmp((char *)str3, (char *)str4); // 0x80d3fc6
    v43 = v6;
    v44 = str4;
    if (strcmp_rc3 == 0) {
        goto lab_0x80d3ffc;
    } else {
        goto lab_0x80d3fd2;
    }
  lab_0x80d400a:
    // 0x80d400a
    Message("Vendor mapping skipped because refdes = %s matches %s\n", (char *)v47, (char *)v44);
    v42 = 0;
    goto lab_0x80d4025;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d5220 - 0x80d54fd
// Line range:    320 - 358
int32_t hid_parse_actions(char * rstr, int32_t (*function)(char *, int32_t, char **)) {
    int32_t * mem = malloc(strlen(rstr) + 1); // 0x80d524b
    int32_t v1 = 0; // 0x80d525e
    char ** v2 = NULL; // 0x80d525e
    int32_t v3 = (int32_t)rstr; // 0x80d525e
    char v4 = *(char *)v3; // 0x80d5261
    char * v5 = (char *)mem; // 0x80d5266
    int32_t v6 = v1; // 0x80d5266
    char ** v7 = v2; // 0x80d5266
    char v8 = v4; // 0x80d5266
    int32_t v9 = v3; // 0x80d5266
    char ** v10 = v2; // 0x80d5266
    int32_t result = 0; // 0x80d5266
    char v11; // 0x80d5220
    int32_t v12; // 0x80d5220
    int32_t v13; // 0x80d5220
    int32_t v14; // 0x80d5220
    int32_t v15; // 0x80d5220
    int32_t v16; // 0x80d5220
    int32_t v17; // 0x80d5220
    int32_t v18; // 0x80d5220
    int32_t v19; // 0x80d5220
    char v20; // 0x80d53a0
    while (v4 != 0) {
        // 0x80d5261
        while (true) {
            // 0x80d526c
            v2 = v7;
            v1 = v6;
            int16_t ** v21 = __ctype_b_loc(); // 0x80d526f
            int32_t v22 = (int32_t)*v21 + 1; // 0x80d5291
            char v23 = v8; // 0x80d527d
            int32_t v24 = v9; // 0x80d527d
            int32_t v25 = v24;
            char v26 = v23;
            char v27 = *(char *)(v22 + 0x1000000 * (int32_t)v26 / 0x800000); // 0x80d5291
            while ((v27 & 32) != 0) {
                // 0x80d5280
                v24 = v25 + 1;
                v23 = *(char *)v24;
                v10 = v2;
                result = 0;
                if (v23 == 0) {
                    // break (via goto) -> 0x80d547d
                    goto lab_0x80d547d_4;
                }
                v25 = v24;
                v26 = v23;
                v27 = *(char *)(v22 + 0x1000000 * (int32_t)v26 / 0x800000);
            }
            int32_t v28 = (int32_t)v5;
            char v29 = v26; // 0x80d529b
            int32_t v30 = v25; // 0x80d529b
            int32_t v31 = v28; // 0x80d529b
            char * v32; // 0x80d5220
            int32_t v33; // 0x80d5220
            int32_t v34; // 0x80d5220
            if (v26 != 40 == (v26 != 0)) {
                while (true) {
                    int32_t v35 = v30 + 1; // 0x80d52b4
                    *(char *)v31 = v29;
                    char * v36 = (char *)v35;
                    char v37 = *v36; // 0x80d52b9
                    int32_t v38 = v31 + 1; // 0x80d52bc
                    v29 = v37;
                    v30 = v35;
                    v31 = v38;
                    v32 = v36;
                    v33 = v35;
                    v34 = v38;
                    switch (v37) {
                        case 40: {
                            goto lab_0x80d52c4;
                        }
                        case 0: {
                            goto lab_0x80d52c4;
                        }
                        default: {
                            goto lab_0x80d52b4;
                        }
                    }
                }
            } else {
                // 0x80d54f5
                v32 = (char *)v25;
                v33 = v25;
                v34 = v28;
            }
            int32_t v39 = v34;
            int32_t v40 = v33;
            *(char *)v39 = 0;
            v3 = v40;
            if (*v32 == 0) {
                // break -> 0x80d52cc
                break;
            }
            int32_t v41 = v40 + 1; // 0x80d52f8
            unsigned char v42 = *(char *)v41; // 0x80d52fb
            v3 = v41;
            if (v42 == 0) {
                // break -> 0x80d52cc
                break;
            }
            int32_t v43 = v1; // 0x80d5448
            char ** v44 = v2; // 0x80d5448
            int32_t v45 = v41; // 0x80d5448
            if (v42 != 41) {
                int32_t v46 = v39 + 1; // 0x80d5220
                int32_t v47 = v41; // 0x80d5220
                int32_t v48 = v42; // 0x80d5220
                int32_t v49 = 0; // 0x80d5220
                int32_t v50 = 0; // 0x80d5220
                char ** v51 = v2; // 0x80d5220
                int32_t v52 = v1; // 0x80d5220
                int32_t v53 = v52; // 0x80d5220
                char ** v54 = v51; // 0x80d5220
                int32_t v55 = v50; // 0x80d5220
                int32_t v56 = v49; // 0x80d5220
                int32_t v57 = v48; // 0x80d5220
                bool v58 = false; // 0x80d5220
                int32_t v59 = v47; // 0x80d5220
                int32_t v60 = v46; // 0x80d5220
                char ** v61 = v54;
                v10 = v61;
                result = 0;
                if (v57 == 0 && !v58) {
                    // break (via goto) -> 0x80d547d
                    goto lab_0x80d547d_4;
                }
                int32_t v62 = v60;
                int32_t v63 = v59;
                int32_t v64 = v53;
                int32_t v65 = v64; // 0x80d5336
                char ** v66 = v61; // 0x80d5336
                int32_t v67 = v57; // 0x80d5336
                int32_t v68; // 0x80d533b
                int32_t size; // 0x80d5220
                int32_t * mem2; // 0x80d54db
                int32_t * mem3; // 0x80d5357
                if (v64 <= v56) {
                    // 0x80d5338
                    v68 = v64 + 10;
                    size = 4 * v68;
                    if (v61 == NULL) {
                        // 0x80d54d2
                        mem2 = malloc(size);
                        v65 = v68;
                        v66 = (char **)mem2;
                        v67 = (int32_t)*(char *)v63;
                    } else {
                        // 0x80d5347
                        mem3 = realloc((int32_t *)v61, size);
                        v65 = v68;
                        v66 = (char **)mem3;
                        v67 = (int32_t)*(char *)v63;
                    }
                }
                int32_t v69 = v67;
                char ** v70 = v66;
                int32_t v71 = v65;
                int32_t v72 = v63; // 0x80d5364
                int32_t v73; // 0x80d5220
                int32_t v74; // 0x80d5220
                char v75; // 0x80d537d
                int32_t v76; // 0x80d5370
                unsigned char v77; // 0x80d5373
                if ((char)v69 != 0) {
                    // 0x80d5366
                    v73 = v69;
                    v76 = v63;
                    v74 = v76;
                    v75 = *(char *)((int32_t)*v21 + 1 + 0x1000000 * v73 / 0x800000);
                    v72 = v74;
                    while ((v75 & 32) != 0) {
                        // 0x80d5370
                        v76 = v74 + 1;
                        v77 = *(char *)v76;
                        v73 = v77;
                        v72 = v76;
                        if (v77 == 0) {
                            // break -> 0x80d5384
                            break;
                        }
                        v74 = v76;
                        v75 = *(char *)((int32_t)*v21 + 1 + 0x1000000 * v73 / 0x800000);
                        v72 = v74;
                    }
                }
                int32_t v78 = v72;
                int32_t * v79 = (int32_t *)(v55 + (int32_t)v70); // 0x80d5390
                *v79 = v62;
                char * v80 = (char *)v78;
                unsigned char v81 = *v80; // 0x80d5392
                char * v82 = v80; // 0x80d5399
                int32_t v83 = 0; // 0x80d5399
                int32_t v84 = v78; // 0x80d5399
                int32_t v85 = v62; // 0x80d5399
                int32_t v86; // 0x80d5220
                int32_t v87; // 0x80d5220
                int32_t v88; // 0x80d5220
                if (v81 != 0) {
                    // 0x80d53a0
                    v12 = v81;
                    v16 = 0;
                    v14 = v78;
                    v18 = v62;
                    while (true) {
                        // 0x80d53a0
                        v19 = v18;
                        v15 = v14;
                        v17 = v16;
                        v13 = v12;
                        v20 = v17;
                        v11 = v13;
                        if (v20 != 0) {
                            goto lab_0x80d53ac;
                        } else {
                            // 0x80d53a4
                            switch (v11) {
                                case 41: {
                                    goto lab_0x80d53ed_2;
                                }
                                case 44: {
                                    goto lab_0x80d53ed_2;
                                }
                                default: {
                                    goto lab_0x80d53ac;
                                }
                            }
                        }
                    }
                    // 0x80d53ed
                    v84 = v87;
                    v82 = (char *)v84;
                    v83 = v86;
                    v85 = v88;
                }
                int32_t v89 = v84;
                *(char *)v85 = 0;
                int32_t v90 = 0; // 0x80d53ff
                int32_t v91 = v83; // 0x80d53ff
                int32_t v92 = v89; // 0x80d53ff
                if (*v82 == 44) {
                    // 0x80d54c0
                    v92 = v89 + 1;
                    v90 = 1;
                    v91 = (int32_t)*(char *)v92;
                }
                int32_t v93 = v92;
                int32_t v94 = v91;
                int32_t v95 = v85 - 1;
                char * v96 = (char *)v95; // 0x80d5422
                char v97 = *(char *)((int32_t)*v21 + 1 + 2 * (int32_t)*v96); // 0x80d5427
                char * v98 = v96; // 0x80d542c
                int32_t v99 = v95; // 0x80d542c
                int32_t v100; // 0x80d5220
                uint32_t v101; // 0x80d5220
                char * v102; // 0x80d5422
                char v103; // 0x80d5427
                if ((v97 & 32) != 0) {
                    v101 = v99;
                    while (v101 >= *v79) {
                        // 0x80d541c
                        *v98 = 0;
                        v100 = v101 - 1;
                        v102 = (char *)v100;
                        v103 = *(char *)((int32_t)*v21 + 1 + 2 * (int32_t)*v102);
                        v98 = v102;
                        v99 = v100;
                        if ((v103 & 32) == 0) {
                            // break -> 0x80d542e
                            break;
                        }
                        v101 = v99;
                    }
                }
                int32_t v104 = v56 + 1; // 0x80d538c
                int32_t v105 = v85 + 1; // 0x80d53f2
                int32_t v106 = v55 + 4; // 0x80d5431
                v53 = v71;
                v54 = v70;
                v55 = v106;
                v56 = v104;
                v57 = v94;
                v58 = true;
                v59 = v93;
                v60 = v105;
                while (v90 != 0) {
                    // 0x80d5328
                    v61 = v54;
                    v10 = v61;
                    result = 0;
                    if (v57 == 0 && !v58) {
                        // break (via goto) -> 0x80d547d
                        goto lab_0x80d547d_4;
                    }
                    // 0x80d5330
                    v62 = v60;
                    v63 = v59;
                    v64 = v53;
                    v65 = v64;
                    v66 = v61;
                    v67 = v57;
                    if (v64 <= v56) {
                        // 0x80d5338
                        v68 = v64 + 10;
                        size = 4 * v68;
                        if (v61 == NULL) {
                            // 0x80d54d2
                            mem2 = malloc(size);
                            v65 = v68;
                            v66 = (char **)mem2;
                            v67 = (int32_t)*(char *)v63;
                        } else {
                            // 0x80d5347
                            mem3 = realloc((int32_t *)v61, size);
                            v65 = v68;
                            v66 = (char **)mem3;
                            v67 = (int32_t)*(char *)v63;
                        }
                    }
                    // 0x80d5362
                    v69 = v67;
                    v70 = v66;
                    v71 = v65;
                    v72 = v63;
                    if ((char)v69 != 0) {
                        // 0x80d5366
                        v73 = v69;
                        v76 = v63;
                        v74 = v76;
                        v75 = *(char *)((int32_t)*v21 + 1 + 0x1000000 * v73 / 0x800000);
                        v72 = v74;
                        while ((v75 & 32) != 0) {
                            // 0x80d5370
                            v76 = v74 + 1;
                            v77 = *(char *)v76;
                            v73 = v77;
                            v72 = v76;
                            if (v77 == 0) {
                                // break -> 0x80d5384
                                break;
                            }
                            v74 = v76;
                            v75 = *(char *)((int32_t)*v21 + 1 + 0x1000000 * v73 / 0x800000);
                            v72 = v74;
                        }
                    }
                    // 0x80d5384
                    v78 = v72;
                    v79 = (int32_t *)(v55 + (int32_t)v70);
                    *v79 = v62;
                    v80 = (char *)v78;
                    v81 = *v80;
                    v82 = v80;
                    v83 = 0;
                    v84 = v78;
                    v85 = v62;
                    if (v81 != 0) {
                        // 0x80d53a0
                        v12 = v81;
                        v16 = 0;
                        v14 = v78;
                        v18 = v62;
                        while (true) {
                            // 0x80d53a0
                            v19 = v18;
                            v15 = v14;
                            v17 = v16;
                            v13 = v12;
                            v20 = v17;
                            v11 = v13;
                            if (v20 != 0) {
                                goto lab_0x80d53ac;
                            } else {
                                // 0x80d53a4
                                switch (v11) {
                                    case 41: {
                                        goto lab_0x80d53ed_2;
                                    }
                                    case 44: {
                                        goto lab_0x80d53ed_2;
                                    }
                                    default: {
                                        goto lab_0x80d53ac;
                                    }
                                }
                            }
                        }
                        // 0x80d53ed
                        v84 = v87;
                        v82 = (char *)v84;
                        v83 = v86;
                        v85 = v88;
                    }
                    // 0x80d53ed
                    v89 = v84;
                    *(char *)v85 = 0;
                    v90 = 0;
                    v91 = v83;
                    v92 = v89;
                    if (*v82 == 44) {
                        // 0x80d54c0
                        v92 = v89 + 1;
                        v90 = 1;
                        v91 = (int32_t)*(char *)v92;
                    }
                    // 0x80d5405
                    v93 = v92;
                    v94 = v91;
                    v95 = v85 - 1;
                    v96 = (char *)v95;
                    v97 = *(char *)((int32_t)*v21 + 1 + 2 * (int32_t)*v96);
                    v98 = v96;
                    v99 = v95;
                    if ((v97 & 32) != 0) {
                        v101 = v99;
                        while (v101 >= *v79) {
                            // 0x80d541c
                            *v98 = 0;
                            v100 = v101 - 1;
                            v102 = (char *)v100;
                            v103 = *(char *)((int32_t)*v21 + 1 + 2 * (int32_t)*v102);
                            v98 = v102;
                            v99 = v100;
                            if ((v103 & 32) == 0) {
                                // break -> 0x80d542e
                                break;
                            }
                            v101 = v99;
                        }
                    }
                    // 0x80d542e
                    v104 = v56 + 1;
                    v105 = v85 + 1;
                    v106 = v55 + 4;
                    v53 = v71;
                    v54 = v70;
                    v55 = v106;
                    v56 = v104;
                    v57 = v94;
                    v58 = true;
                    v59 = v93;
                    v60 = v105;
                }
                // 0x80d5446
                v46 = v105;
                v47 = v93;
                v48 = v94;
                v49 = v104;
                v50 = v106;
                v51 = v70;
                v52 = v71;
                v43 = v71;
                v44 = v70;
                v45 = v93;
                while ((char)v94 != 41) {
                    // 0x80d5328
                    v53 = v52;
                    v54 = v51;
                    v55 = v50;
                    v56 = v49;
                    v57 = v48;
                    v58 = false;
                    v59 = v47;
                    v60 = v46;
                    v61 = v54;
                    v10 = v61;
                    result = 0;
                    if (v57 == 0 && !v58) {
                        // break (via goto) -> 0x80d547d
                        goto lab_0x80d547d_4;
                    }
                    // 0x80d5330
                    v62 = v60;
                    v63 = v59;
                    v64 = v53;
                    v65 = v64;
                    v66 = v61;
                    v67 = v57;
                    if (v64 <= v56) {
                        // 0x80d5338
                        v68 = v64 + 10;
                        size = 4 * v68;
                        if (v61 == NULL) {
                            // 0x80d54d2
                            mem2 = malloc(size);
                            v65 = v68;
                            v66 = (char **)mem2;
                            v67 = (int32_t)*(char *)v63;
                        } else {
                            // 0x80d5347
                            mem3 = realloc((int32_t *)v61, size);
                            v65 = v68;
                            v66 = (char **)mem3;
                            v67 = (int32_t)*(char *)v63;
                        }
                    }
                    // 0x80d5362
                    v69 = v67;
                    v70 = v66;
                    v71 = v65;
                    v72 = v63;
                    if ((char)v69 != 0) {
                        // 0x80d5366
                        v73 = v69;
                        v76 = v63;
                        v74 = v76;
                        v75 = *(char *)((int32_t)*v21 + 1 + 0x1000000 * v73 / 0x800000);
                        v72 = v74;
                        while ((v75 & 32) != 0) {
                            // 0x80d5370
                            v76 = v74 + 1;
                            v77 = *(char *)v76;
                            v73 = v77;
                            v72 = v76;
                            if (v77 == 0) {
                                // break -> 0x80d5384
                                break;
                            }
                            v74 = v76;
                            v75 = *(char *)((int32_t)*v21 + 1 + 0x1000000 * v73 / 0x800000);
                            v72 = v74;
                        }
                    }
                    // 0x80d5384
                    v78 = v72;
                    v79 = (int32_t *)(v55 + (int32_t)v70);
                    *v79 = v62;
                    v80 = (char *)v78;
                    v81 = *v80;
                    v82 = v80;
                    v83 = 0;
                    v84 = v78;
                    v85 = v62;
                    if (v81 != 0) {
                        // 0x80d53a0
                        v12 = v81;
                        v16 = 0;
                        v14 = v78;
                        v18 = v62;
                        while (true) {
                            // 0x80d53a0
                            v19 = v18;
                            v15 = v14;
                            v17 = v16;
                            v13 = v12;
                            v20 = v17;
                            v11 = v13;
                            if (v20 != 0) {
                                goto lab_0x80d53ac;
                            } else {
                                // 0x80d53a4
                                switch (v11) {
                                    case 41: {
                                        goto lab_0x80d53ed_2;
                                    }
                                    case 44: {
                                        goto lab_0x80d53ed_2;
                                    }
                                    default: {
                                        goto lab_0x80d53ac;
                                    }
                                }
                            }
                        }
                        // 0x80d53ed
                        v84 = v87;
                        v82 = (char *)v84;
                        v83 = v86;
                        v85 = v88;
                    }
                    // 0x80d53ed
                    v89 = v84;
                    *(char *)v85 = 0;
                    v90 = 0;
                    v91 = v83;
                    v92 = v89;
                    if (*v82 == 44) {
                        // 0x80d54c0
                        v92 = v89 + 1;
                        v90 = 1;
                        v91 = (int32_t)*(char *)v92;
                    }
                    // 0x80d5405
                    v93 = v92;
                    v94 = v91;
                    v95 = v85 - 1;
                    v96 = (char *)v95;
                    v97 = *(char *)((int32_t)*v21 + 1 + 2 * (int32_t)*v96);
                    v98 = v96;
                    v99 = v95;
                    if ((v97 & 32) != 0) {
                        v101 = v99;
                        while (v101 >= *v79) {
                            // 0x80d541c
                            *v98 = 0;
                            v100 = v101 - 1;
                            v102 = (char *)v100;
                            v103 = *(char *)((int32_t)*v21 + 1 + 2 * (int32_t)*v102);
                            v98 = v102;
                            v99 = v100;
                            if ((v103 & 32) == 0) {
                                // break -> 0x80d542e
                                break;
                            }
                            v101 = v99;
                        }
                    }
                    // 0x80d542e
                    v104 = v56 + 1;
                    v105 = v85 + 1;
                    v106 = v55 + 4;
                    v53 = v71;
                    v54 = v70;
                    v55 = v106;
                    v56 = v104;
                    v57 = v94;
                    v58 = true;
                    v59 = v93;
                    v60 = v105;
                    while (v90 != 0) {
                        // 0x80d5328
                        v61 = v54;
                        v10 = v61;
                        result = 0;
                        if (v57 == 0 && !v58) {
                            // break (via goto) -> 0x80d547d
                            goto lab_0x80d547d_4;
                        }
                        // 0x80d5330
                        v62 = v60;
                        v63 = v59;
                        v64 = v53;
                        v65 = v64;
                        v66 = v61;
                        v67 = v57;
                        if (v64 <= v56) {
                            // 0x80d5338
                            v68 = v64 + 10;
                            size = 4 * v68;
                            if (v61 == NULL) {
                                // 0x80d54d2
                                mem2 = malloc(size);
                                v65 = v68;
                                v66 = (char **)mem2;
                                v67 = (int32_t)*(char *)v63;
                            } else {
                                // 0x80d5347
                                mem3 = realloc((int32_t *)v61, size);
                                v65 = v68;
                                v66 = (char **)mem3;
                                v67 = (int32_t)*(char *)v63;
                            }
                        }
                        // 0x80d5362
                        v69 = v67;
                        v70 = v66;
                        v71 = v65;
                        v72 = v63;
                        if ((char)v69 != 0) {
                            // 0x80d5366
                            v73 = v69;
                            v76 = v63;
                            v74 = v76;
                            v75 = *(char *)((int32_t)*v21 + 1 + 0x1000000 * v73 / 0x800000);
                            v72 = v74;
                            while ((v75 & 32) != 0) {
                                // 0x80d5370
                                v76 = v74 + 1;
                                v77 = *(char *)v76;
                                v73 = v77;
                                v72 = v76;
                                if (v77 == 0) {
                                    // break -> 0x80d5384
                                    break;
                                }
                                v74 = v76;
                                v75 = *(char *)((int32_t)*v21 + 1 + 0x1000000 * v73 / 0x800000);
                                v72 = v74;
                            }
                        }
                        // 0x80d5384
                        v78 = v72;
                        v79 = (int32_t *)(v55 + (int32_t)v70);
                        *v79 = v62;
                        v80 = (char *)v78;
                        v81 = *v80;
                        v82 = v80;
                        v83 = 0;
                        v84 = v78;
                        v85 = v62;
                        if (v81 != 0) {
                            // 0x80d53a0
                            v12 = v81;
                            v16 = 0;
                            v14 = v78;
                            v18 = v62;
                            while (true) {
                                // 0x80d53a0
                                v19 = v18;
                                v15 = v14;
                                v17 = v16;
                                v13 = v12;
                                v20 = v17;
                                v11 = v13;
                                if (v20 != 0) {
                                    goto lab_0x80d53ac;
                                } else {
                                    // 0x80d53a4
                                    switch (v11) {
                                        case 41: {
                                            goto lab_0x80d53ed_2;
                                        }
                                        case 44: {
                                            goto lab_0x80d53ed_2;
                                        }
                                        default: {
                                            goto lab_0x80d53ac;
                                        }
                                    }
                                }
                            }
                            // 0x80d53ed
                            v84 = v87;
                            v82 = (char *)v84;
                            v83 = v86;
                            v85 = v88;
                        }
                        // 0x80d53ed
                        v89 = v84;
                        *(char *)v85 = 0;
                        v90 = 0;
                        v91 = v83;
                        v92 = v89;
                        if (*v82 == 44) {
                            // 0x80d54c0
                            v92 = v89 + 1;
                            v90 = 1;
                            v91 = (int32_t)*(char *)v92;
                        }
                        // 0x80d5405
                        v93 = v92;
                        v94 = v91;
                        v95 = v85 - 1;
                        v96 = (char *)v95;
                        v97 = *(char *)((int32_t)*v21 + 1 + 2 * (int32_t)*v96);
                        v98 = v96;
                        v99 = v95;
                        if ((v97 & 32) != 0) {
                            v101 = v99;
                            while (v101 >= *v79) {
                                // 0x80d541c
                                *v98 = 0;
                                v100 = v101 - 1;
                                v102 = (char *)v100;
                                v103 = *(char *)((int32_t)*v21 + 1 + 2 * (int32_t)*v102);
                                v98 = v102;
                                v99 = v100;
                                if ((v103 & 32) == 0) {
                                    // break -> 0x80d542e
                                    break;
                                }
                                v101 = v99;
                            }
                        }
                        // 0x80d542e
                        v104 = v56 + 1;
                        v105 = v85 + 1;
                        v106 = v55 + 4;
                        v53 = v71;
                        v54 = v70;
                        v55 = v106;
                        v56 = v104;
                        v57 = v94;
                        v58 = true;
                        v59 = v93;
                        v60 = v105;
                    }
                    // 0x80d5446
                    v46 = v105;
                    v47 = v93;
                    v48 = v94;
                    v49 = v104;
                    v50 = v106;
                    v51 = v70;
                    v52 = v71;
                    v43 = v71;
                    v44 = v70;
                    v45 = v93;
                }
            }
            // 0x80d544e
            v7 = v44;
            v10 = v7;
            result = 1;
            if (mem != NULL) {
                // break (via goto) -> 0x80d547d
                goto lab_0x80d547d_4;
            }
            // 0x80d546d
            v6 = v43;
            v9 = v45 + 1;
            v8 = *(char *)v9;
            v5 = (char *)mem;
            v10 = v7;
            result = 0;
            if (v8 == 0) {
                // break (via goto) -> 0x80d547d
                goto lab_0x80d547d_4;
            }
        }
        // 0x80d52cc
        v10 = v2;
        result = 1;
        if (mem != NULL) {
            // break -> 0x80d547d
            break;
        }
        v4 = *(char *)v3;
        v5 = NULL;
        v6 = v1;
        v7 = v2;
        v8 = v4;
        v9 = v3;
        v10 = v2;
        result = 0;
    }
  lab_0x80d547d_4:
    // 0x80d547d
    if (v10 != NULL) {
        // 0x80d5484
        free((int32_t *)v10);
    }
    if (mem != NULL) {
        // 0x80d5496
        free(mem);
    }
    // 0x80d54a1
    return result;
  lab_0x80d53ac:;
    int32_t v107; // 0x80d5220
    int32_t v108; // 0x80d5220
    int32_t v109; // 0x80d5220
    if (v11 != 39 == (v11 != 34)) {
        goto lab_0x80d53c6;
    } else {
        // 0x80d53b6
        v107 = v15;
        v108 = v19;
        v109 = v13;
        if (v20 == 0) {
            goto lab_0x80d53e4;
        } else {
            // 0x80d53be
            v107 = v15;
            v108 = v19;
            v109 = 0;
            if (v11 == v20) {
                goto lab_0x80d53e4;
            } else {
                goto lab_0x80d53c6;
            }
        }
    }
  lab_0x80d53c6:;
    char v110 = v11; // 0x80d53c8
    int32_t v111 = v15; // 0x80d53c8
    if (v13 == 92 && v20 != 39) {
        int32_t v112 = v15 + 1; // 0x80d53d2
        v110 = *(char *)v112;
        v111 = v112;
    }
    // 0x80d53d8
    *(char *)v19 = v110;
    v107 = v111;
    v108 = v19 + 1;
    v109 = v17;
    goto lab_0x80d53e4;
  lab_0x80d53e4:;
    int32_t v113 = v107 + 1;
    unsigned char v114 = *(char *)v113; // 0x80d53e4
    v12 = v114;
    v16 = v109;
    v14 = v113;
    v18 = v108;
    if (v114 == 0) {
        // break -> 0x80d53ed
        goto lab_0x80d53ed_2;
    }
    goto lab_0x80d53a0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d5500 - 0x80d5580
// Line range:    226 - 243
void dump_string(char prefix, char * str) {
    // 0x80d5500
    int32_t v1; // 0x80d5500
    if ((char)v1 == 0) {
        // 0x80d5579
        return;
    }
    // 0x80d5548
    _IO_putc(0x1000000 * v1 / 0x1000000, (struct _IO_FILE *)g45);
    // 0x80d5520
    int32_t v2; // 0x80d5500
    char * v3 = (char *)v2; // 0x80d5529
    _IO_putc((int32_t)*v3, (struct _IO_FILE *)g45);
    char v4 = *v3; // 0x80d5536
    int32_t v5 = v2 + 1; // 0x80d553c
    while (*(char *)v5 != 0) {
        // 0x80d5544
        if ((int32_t)(v4 == 10) != 0) {
            // 0x80d5548
            _IO_putc(0x1000000 * v1 / 0x1000000, (struct _IO_FILE *)g45);
        }
        // 0x80d5520
        v3 = (char *)v5;
        _IO_putc((int32_t)*v3, (struct _IO_FILE *)g45);
        v4 = *v3;
        v5++;
    }
    if (v4 != 10) {
        // 0x80d5564
        _IO_putc(10, (struct _IO_FILE *)g45);
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d5660 - 0x80d5818
// Line range:    140 - 158
int32_t hid_find_action(char * name, char ** context) {
    // 0x80d5660
    if (name == NULL) {
        // 0x80d5736
        return 0;
    }
    // 0x80d5676
    if (all_actions == 0) {
        int32_t * mem = malloc(24 * n_actions); // 0x80d5775
        int32_t v1 = (int32_t)mem; // 0x80d5775
        char * v2 = (char *)mem; // bp-36, 0x80d5782
        all_actions = v1;
        int32_t base = v1; // 0x80d578a
        if (hid_action_nodes != 0) {
            char * v3 = NULL;
            int32_t * v4 = (int32_t *)(hid_action_nodes + 8); // 0x80d5790
            char * v5 = v3; // 0x80d5795
            int32_t v6; // 0x80d5660
            int32_t v7; // 0x80d5660
            int32_t v8; // 0x80d5660
            int32_t v9; // 0x80d57b3
            char * v10; // 0x80d5660
            if (*v4 >= 1) {
                // 0x80d5797
                v10 = v3;
                v6 = 24 * (int32_t)v3 + (int32_t)v2;
                v7 = 0;
                v9 = 0;
                v8 = v7 + *(int32_t *)(hid_action_nodes + 4);
                v9++;
                v10 = (char *)((int32_t)v10 + 1);
                *(int32_t *)v6 = *(int32_t *)v8;
                *(int32_t *)(v6 + 4) = *(int32_t *)(v8 + 4);
                *(int32_t *)(v6 + 8) = *(int32_t *)(v8 + 8);
                *(int32_t *)(v6 + 12) = *(int32_t *)(v8 + 12);
                *(int32_t *)(v6 + 16) = *(int32_t *)(v8 + 16);
                *(int32_t *)(v6 + 20) = *(int32_t *)(hid_action_nodes + 12);
                v6 += 24;
                v7 += 20;
                v5 = v10;
                while (*v4 > v9) {
                    // 0x80d57b0
                    v8 = v7 + *(int32_t *)(hid_action_nodes + 4);
                    v9++;
                    v10 = (char *)((int32_t)v10 + 1);
                    *(int32_t *)v6 = *(int32_t *)v8;
                    *(int32_t *)(v6 + 4) = *(int32_t *)(v8 + 4);
                    *(int32_t *)(v6 + 8) = *(int32_t *)(v8 + 8);
                    *(int32_t *)(v6 + 12) = *(int32_t *)(v8 + 12);
                    *(int32_t *)(v6 + 16) = *(int32_t *)(v8 + 16);
                    *(int32_t *)(v6 + 20) = *(int32_t *)(hid_action_nodes + 12);
                    v6 += 24;
                    v7 += 20;
                    v5 = v10;
                }
            }
            int32_t v11 = *(int32_t *)hid_action_nodes; // 0x80d57e9
            while (v11 != 0) {
                int32_t v12 = v11;
                v3 = v5;
                v4 = (int32_t *)(v12 + 8);
                v5 = v3;
                if (*v4 >= 1) {
                    // 0x80d5797
                    v10 = v3;
                    v6 = 24 * (int32_t)v3 + (int32_t)v2;
                    v7 = 0;
                    v9 = 0;
                    v8 = v7 + *(int32_t *)(v12 + 4);
                    v9++;
                    v10 = (char *)((int32_t)v10 + 1);
                    *(int32_t *)v6 = *(int32_t *)v8;
                    *(int32_t *)(v6 + 4) = *(int32_t *)(v8 + 4);
                    *(int32_t *)(v6 + 8) = *(int32_t *)(v8 + 8);
                    *(int32_t *)(v6 + 12) = *(int32_t *)(v8 + 12);
                    *(int32_t *)(v6 + 16) = *(int32_t *)(v8 + 16);
                    *(int32_t *)(v6 + 20) = *(int32_t *)(v12 + 12);
                    v6 += 24;
                    v7 += 20;
                    v5 = v10;
                    while (*v4 > v9) {
                        // 0x80d57b0
                        v8 = v7 + *(int32_t *)(v12 + 4);
                        v9++;
                        v10 = (char *)((int32_t)v10 + 1);
                        *(int32_t *)v6 = *(int32_t *)v8;
                        *(int32_t *)(v6 + 4) = *(int32_t *)(v8 + 4);
                        *(int32_t *)(v6 + 8) = *(int32_t *)(v8 + 8);
                        *(int32_t *)(v6 + 12) = *(int32_t *)(v8 + 12);
                        *(int32_t *)(v6 + 16) = *(int32_t *)(v8 + 16);
                        *(int32_t *)(v6 + 20) = *(int32_t *)(v12 + 12);
                        v6 += 24;
                        v7 += 20;
                        v5 = v10;
                    }
                }
                // 0x80d57e9
                v11 = *(int32_t *)v12;
            }
            // 0x80d57ef
            base = (int32_t)v2;
        }
        // 0x80d57ef
        qsort((int32_t *)base, n_actions, 24, (int32_t (*)(int32_t *, int32_t *))0x80d5580);
    }
    char * v13 = (char *)(n_actions - 1);
    char * v14 = v13; // 0x80d56ae
    int32_t v15 = n_actions; // 0x80d56ae
    char * v16 = (char *)-1; // 0x80d56ae
    int32_t result; // 0x80d5660
    if (v13 > (char *)-1) {
        while (true) {
            uint32_t v17 = (int32_t)v14;
            int32_t v18 = v15 + (int32_t)v16; // 0x80d56b6
            int32_t v19 = v18 + (int32_t)(v18 < 0); // 0x80d56be
            v15 = v19 / 2;
            int32_t str = 8 * (v15 + (v19 & 0x1ffffffe)) + all_actions; // 0x80d56c8
            int32_t strcmp_rc = strcmp((char *)*(int32_t *)str, name); // 0x80d56d7
            result = str;
            if (strcmp_rc == 0) {
                // break (via goto) -> 0x80d5725
                goto lab_0x80d5725;
            }
            while (strcmp_rc < 0) {
                // 0x80d56e3
                if (v15 >= v17) {
                    goto lab_0x80d56f0_2;
                }
                v16 = (char *)v15;
                v18 = v15 + (int32_t)v16;
                v19 = v18 + (int32_t)(v18 < 0);
                v15 = v19 / 2;
                str = 8 * (v15 + (v19 & 0x1ffffffe)) + all_actions;
                strcmp_rc = strcmp((char *)*(int32_t *)str, name);
                result = str;
                if (strcmp_rc == 0) {
                    // break (via goto) -> 0x80d5725
                    goto lab_0x80d5725;
                }
            }
            // 0x80d56a8
            v14 = (char *)(v15 - 1);
            if (v16 >= v14) {
                goto lab_0x80d56f0_2;
            }
        }
    } else {
      lab_0x80d56f0_2:
        if (n_actions < 1) {
            // 0x80d5740
            __printf_chk(1, "unknown action `%s'\n", name);
            return 0;
        }
        int32_t v20 = 0; // 0x80d5702
        int32_t str2 = all_actions; // 0x80d5702
        result = str2;
        while (strcasecmp((char *)*(int32_t *)str2, name) != 0) {
            // 0x80d5708
            v20++;
            str2 += 24;
            if (n_actions <= v20) {
                // 0x80d5740
                __printf_chk(1, "unknown action `%s'\n", name);
                return 0;
            }
            result = str2;
        }
    }
  lab_0x80d5725:
    // 0x80d5725
    if (context != NULL) {
        // 0x80d572c
        *(int32_t *)context = *(int32_t *)(result + 20);
    }
    // 0x80d5736
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d5820 - 0x80d593c
// Line range:    287 - 105
int32_t hid_actionv(char * name, uint32_t argc, char ** argv) {
    // 0x80d5820
    int32_t v1; // bp-40, 0x80d5820
    if (name == NULL || g108 == 0) {
        // 0x80d5844
        return hid_find_action(name, (char **)&v1) == 0;
    }
    // 0x80d58cd
    __printf_chk(1, (char *)&g32);
    if (argc >= 1) {
        // 0x80d58ec
        __printf_chk(1, "%s%s", (char *)&g5, *argv);
        int32_t v2 = 1; // 0x80d5921
        if (argc == 1) {
            // 0x80d5923
            __printf_chk(1, (char *)&g33);
            // 0x80d5844
            return hid_find_action(name, (char **)&v1) == 0;
        }
        int32_t v3 = *(int32_t *)(4 * v2 + (int32_t)argv);
        v2++;
        __printf_chk(1, "%s%s", (char *)&g34, (char *)v3);
        while (v2 != argc) {
            // 0x80d58f8
            v3 = *(int32_t *)(4 * v2 + (int32_t)argv);
            v2++;
            __printf_chk(1, "%s%s", (char *)&g34, (char *)v3);
        }
    }
    // 0x80d5923
    __printf_chk(1, (char *)&g33);
    // 0x80d5844
    return hid_find_action(name, (char **)&v1) == 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d5940 - 0x80d597e
// Line range:    272 - 284
int32_t hid_actionl(char * name, ...) {
    // 0x80d5940
    int32_t v1; // bp-92, 0x80d5940
    int32_t v2; // 0x80d5940
    if (v2 == 0) {
        // 0x80d5965
        return hid_actionv(name, 0, (char **)&v1);
    }
    int32_t v3 = 0; // 0x80d5954
    int32_t v4; // 0x80d5940
    *(int32_t *)(4 * v3 + (int32_t)&v1) = v4;
    v3++;
    int32_t v5; // 0x80d5940
    int32_t v6 = *(int32_t *)(4 * v3 + (int32_t)&v5); // 0x80d595e
    while (v6 != 0) {
        // 0x80d5958
        *(int32_t *)(4 * v3 + (int32_t)&v1) = v6;
        v3++;
        v6 = *(int32_t *)(4 * v3 + (int32_t)&v5);
    }
    // 0x80d5965
    return hid_actionv(name, v3, (char **)&v1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d5980 - 0x80d59a3
// Line range:    266 - 269
int32_t hid_action(char * name) {
    // 0x80d5980
    return hid_actionv(name, 0, NULL);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d59b0 - 0x80d5a50
// Line range:    246 - 263
void dump_actions(void) {
    // 0x80d59b0
    hid_find_action((char *)*(int32_t *)*(int32_t *)(hid_action_nodes + 4), NULL);
    int32_t v1 = 0; // 0x80d59db
    if (n_actions < 1) {
        // 0x80d5a48
        return;
    }
    int32_t v2 = 0; // 0x80d59db
    v2++;
    __printf_chk(1, "A%s\n", (char *)*(int32_t *)(all_actions + v1));
    dump_string((char)&g231, (char *)&g231);
    dump_string((char)&g231, (char *)&g231);
    v1 += 24;
    while (n_actions > v2) {
        // 0x80d59e8
        v2++;
        __printf_chk(1, "A%s\n", (char *)*(int32_t *)(all_actions + v1));
        dump_string((char)&g231, (char *)&g231);
        dump_string((char)&g231, (char *)&g231);
        v1 += 24;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d5a50 - 0x80d5bdf
// Line range:    193 - 98
void print_actions(void) {
    // 0x80d5a50
    hid_find_action((char *)*(int32_t *)*(int32_t *)(hid_action_nodes + 4), NULL);
    __fprintf_chk(g43, 1, "Registered Actions:\n");
    int32_t v1 = 0; // 0x80d5a97
    if (n_actions < 1) {
        // 0x80d5baf
        return;
    }
    int32_t v2 = 0; // 0x80d5a97
    char v3; // 0x80d5a50
    int32_t v4; // 0x80d5a50
    int32_t v5; // 0x80d5a50
    while (true) {
      lab_0x80d5ab0:;
        int32_t v6 = all_actions + v1; // 0x80d5ab3
        int32_t v7 = *(int32_t *)(v6 + 12); // 0x80d5ab9
        char * v8 = (char *)*(int32_t *)v6;
        if (v7 == 0) {
            // 0x80d5bb7
            __fprintf_chk(g43, 1, "  %s\n", v8);
        } else {
            // 0x80d5ac4
            __fprintf_chk(g43, 1, "  %s - %s\n", v8, (char *)v7);
        }
        int32_t v9 = *(int32_t *)(v1 + 16 + all_actions); // 0x80d5af3
        if (v9 == 0) {
            goto lab_0x80d5b98;
        } else {
            char v10 = *(char *)v9; // 0x80d5aff
            v3 = v10;
            v4 = v9;
            v5 = v9;
            if (v10 == 10) {
                goto lab_0x80d5b90;
            } else {
                goto lab_0x80d5b10;
            }
        }
    }
  lab_0x80d5b98:
    // 0x80d5b98
    v2++;
    v1 += 24;
    if (n_actions <= v2) {
        return;
    }
    goto lab_0x80d5ab0;
  lab_0x80d5b90:;
    int32_t v11 = v5; // 0x80d5b94
    int32_t v12 = v5; // 0x80d5b94
    int32_t size = 0; // 0x80d5b94
    goto lab_0x80d5b2a;
  lab_0x80d5b10:;
    int32_t v16 = v4;
    int32_t v17 = v16; // 0x80d5b14
    v5 = v16;
    if (v3 != 0) {
        int32_t v18; // 0x80d5b1c
        while (true) {
          lab_0x80d5b1c:
            // 0x80d5b1c
            v18 = v17 + 1;
            v17 = v18;
            switch (*(char *)v18) {
                case 10: {
                    goto lab_0x80d5b26;
                }
                case 0: {
                    goto lab_0x80d5b26;
                }
                default: {
                    goto lab_0x80d5b1c;
                }
            }
        }
      lab_0x80d5b26:
        // 0x80d5b26
        v11 = v18;
        v12 = v16;
        size = v18 - v16;
        goto lab_0x80d5b2a;
    } else {
        goto lab_0x80d5b90;
    }
  lab_0x80d5b2a:;
    int32_t v13 = v11;
    fwrite((int32_t *)"    ", 4, 1, g43);
    fwrite(&((struct _IO_FILE *)v12)->e0, size, 1, g43);
    fputc(10, g43);
    if (*(char *)v13 == 0) {
        goto lab_0x80d5b98;
    } else {
        int32_t v14 = v13 + 1; // 0x80d5b86
        char v15 = *(char *)v14; // 0x80d5b89
        v3 = v15;
        v4 = v14;
        v5 = v14;
        if (v15 != 10) {
            goto lab_0x80d5b10;
        } else {
            goto lab_0x80d5b90;
        }
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d5be0 - 0x80d5c88
// Line range:    52 - 52
void hid_register_actions_context(int32_t a, int32_t n, char * context, int32_t dynamic) {
    int32_t * mem = malloc(20); // 0x80d5bfd
    int32_t v1 = (int32_t)mem; // 0x80d5bfd
    int32_t v2 = hid_action_nodes; // 0x80d5c07
    hid_action_nodes = v1;
    *mem = v2;
    int32_t v3; // 0x80d5be0
    if (a != 0) {
        int32_t * mem2 = malloc(20); // 0x80d5c5f
        int32_t v4 = (int32_t)mem2; // 0x80d5c5f
        *(int32_t *)(v1 + 4) = v4;
        *mem2 = v4;
        *(int32_t *)(v4 + 4) = *(int32_t *)(v3 + 4);
        *(int32_t *)(v4 + 8) = *(int32_t *)(v3 + 8);
        *(int32_t *)(v4 + 12) = *(int32_t *)(v3 + 12);
        *(int32_t *)(v4 + 16) = *(int32_t *)(v3 + 16);
    }
    // 0x80d5c1e
    n_actions += v3;
    *(int32_t *)(v1 + 16) = a;
    if (all_actions != 0) {
        // 0x80d5c39
        free((int32_t *)all_actions);
        all_actions = 0;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/actions.c
// Address range: 0x80d5cb0 - 0x80d5ccb
// Line range:    80 - 82
void hid_register_actions(int32_t a, int32_t n) {
    // 0x80d5cb0
    hid_register_actions_context(0, (int32_t)&g231, (char *)&g231, (int32_t)&g231);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/flags.c
// Address range: 0x80d5ef0 - 0x80d605a
// Line range:    63 - 75
int32_t hid_find_flag(char * name) {
    // 0x80d5ef0
    if (all_flags == 0) {
        int32_t * mem = calloc(1, 12 * n_flags); // 0x80d5fad
        int32_t v1 = (int32_t)mem; // 0x80d5fad
        char * v2 = (char *)mem; // bp-40, 0x80d5fc1
        all_flags = v1;
        int32_t base = v1; // 0x80d5fc9
        if (hid_flag_nodes != 0) {
            int32_t v3 = 0;
            int32_t * v4 = (int32_t *)(hid_flag_nodes + 8); // 0x80d5fd0
            int32_t v5 = v3; // 0x80d5fdb
            int32_t v6; // 0x80d5ef0
            int32_t v7; // 0x80d5ef0
            uint32_t v8; // 0x80d5ef0
            int32_t v9; // 0x80d5ef0
            int32_t v10; // 0x80d5ef0
            if (*v4 >= 1) {
                // 0x80d5fdd
                v6 = 0;
                v8 = 1;
                v9 = v6 + *(int32_t *)(hid_flag_nodes + 4);
                v10 = 12 * v3 + (int32_t)v2 + v6;
                *(int32_t *)v10 = *(int32_t *)v9;
                *(int32_t *)(v10 + 4) = *(int32_t *)(v9 + 4);
                *(int32_t *)(v10 + 8) = *(int32_t *)(v9 + 8);
                v6 += 12;
                v7 = v8 + 1;
                while (*v4 > v8) {
                    // 0x80d5ff8
                    v8 = v7;
                    v9 = v6 + *(int32_t *)(hid_flag_nodes + 4);
                    v10 = 12 * v3 + (int32_t)v2 + v6;
                    *(int32_t *)v10 = *(int32_t *)v9;
                    *(int32_t *)(v10 + 4) = *(int32_t *)(v9 + 4);
                    *(int32_t *)(v10 + 8) = *(int32_t *)(v9 + 8);
                    v6 += 12;
                    v7 = v8 + 1;
                }
                // 0x80d6023
                v5 = v8 + v3;
            }
            int32_t v11 = *(int32_t *)hid_flag_nodes; // 0x80d6023
            while (v11 != 0) {
                int32_t v12 = v11;
                v3 = v5;
                v4 = (int32_t *)(v12 + 8);
                v5 = v3;
                if (*v4 >= 1) {
                    // 0x80d5fdd
                    v6 = 0;
                    v8 = 1;
                    v9 = v6 + *(int32_t *)(v12 + 4);
                    v10 = 12 * v3 + (int32_t)v2 + v6;
                    *(int32_t *)v10 = *(int32_t *)v9;
                    *(int32_t *)(v10 + 4) = *(int32_t *)(v9 + 4);
                    *(int32_t *)(v10 + 8) = *(int32_t *)(v9 + 8);
                    v6 += 12;
                    v7 = v8 + 1;
                    while (*v4 > v8) {
                        // 0x80d5ff8
                        v8 = v7;
                        v9 = v6 + *(int32_t *)(v12 + 4);
                        v10 = 12 * v3 + (int32_t)v2 + v6;
                        *(int32_t *)v10 = *(int32_t *)v9;
                        *(int32_t *)(v10 + 4) = *(int32_t *)(v9 + 4);
                        *(int32_t *)(v10 + 8) = *(int32_t *)(v9 + 8);
                        v6 += 12;
                        v7 = v8 + 1;
                    }
                    // 0x80d6023
                    v5 = v8 + v3;
                }
                // 0x80d6023
                v11 = *(int32_t *)v12;
            }
            // 0x80d6031
            base = (int32_t)v2;
        }
        // 0x80d6031
        qsort((int32_t *)base, n_flags, 12, (int32_t (*)(int32_t *, int32_t *))0x80d5ed0);
    }
    // 0x80d5f07
    int32_t result; // 0x80d5ef0
    if (n_flags <= 0xffffffff) {
        // 0x80d5f70
        __printf_chk(1, "unknown flag `%s'\n", name);
        result = 0;
      lab_0x80d5f8d:
        // 0x80d5f8d
        return result;
    }
    int32_t v13 = n_flags; // 0x80d5f20
    int32_t v14 = n_flags + 1; // 0x80d5f40
    int32_t v15 = -1;
    while (true) {
        uint32_t v16 = v13;
        int32_t v17 = v15 + v14; // 0x80d5f36
        int32_t v18 = v17 + (int32_t)(v17 < 0); // 0x80d5f3e
        v14 = v18 / 2;
        int32_t str = 4 * (v14 + (v18 & 0x3ffffffe)) + all_flags; // 0x80d5f48
        int32_t strcmp_rc = strcmp((char *)*(int32_t *)str, name); // 0x80d5f57
        result = str;
        if (strcmp_rc == 0) {
            return result;
        }
        while (strcmp_rc < 0) {
            // 0x80d5f63
            if (v16 <= v14) {
                // 0x80d5f70
                __printf_chk(1, "unknown flag `%s'\n", name);
                // 0x80d5f8d
                return 0;
            }
            v15 = v14;
            v17 = v15 + v14;
            v18 = v17 + (int32_t)(v17 < 0);
            v14 = v18 / 2;
            str = 4 * (v14 + (v18 & 0x3ffffffe)) + all_flags;
            strcmp_rc = strcmp((char *)*(int32_t *)str, name);
            result = str;
            if (strcmp_rc == 0) {
                return result;
            }
        }
        // 0x80d5f20
        v13 = v14 - 1;
        if (v13 <= v15) {
            // 0x80d5f70
            __printf_chk(1, "unknown flag `%s'\n", name);
            // 0x80d5f8d
            return 0;
        }
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/flags.c
// Address range: 0x80d6060 - 0x80d6163
// Line range:    98 - 127
int32_t hid_get_flag(char * name) {
    char * found_char_pos = strchr(name, 44); // 0x80d607d
    if (found_char_pos == NULL) {
        int32_t v1 = hid_find_flag(name); // 0x80d6143
        if (v1 != 0) {
            // 0x80d614c
            return *(int32_t *)(v1 + 4);
        }
        // 0x80d60f5
        return 0;
    }
    int32_t v2 = (int32_t)found_char_pos; // 0x80d607d
    int32_t v3 = v2 - (int32_t)name; // 0x80d608e
    char * v4; // 0x80d6060
    if (v3 < g106) {
        // 0x80d6098
        v4 = g107;
    } else {
        int32_t v5 = v3 + 10; // 0x80d6110
        g106 = v5;
        char * v6 = MyRealloc(g107, v5, "hid_get_flag"); // 0x80d612c
        g107 = v6;
        v4 = v6;
    }
    // 0x80d609d
    memcpy((int32_t *)v4, (int32_t *)name, v3);
    *(char *)(v3 + (int32_t)g107) = 0;
    int32_t str_as_l = strtol((char *)(v2 + 1), NULL, 0); // 0x80d60cc
    int32_t v7 = hid_find_flag(g107); // 0x80d60db
    int32_t result = 0; // 0x80d60e2
    if (v7 != 0) {
        // 0x80d60e4
        result = str_as_l == v7;
    }
    // 0x80d60f5
    return result;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/flags.c
// Address range: 0x80d6170 - 0x80d61cb
// Line range:    36 - 52
void hid_register_flags(int32_t a, int32_t n) {
    int32_t * mem = calloc(1, 12); // 0x80d6189
    int32_t v1 = (int32_t)mem; // 0x80d6189
    *mem = hid_flag_nodes;
    *(int32_t *)(v1 + 8) = n;
    hid_flag_nodes = v1;
    n_flags += n;
    *(int32_t *)(v1 + 4) = a;
    if (all_flags != 0) {
        // 0x80d61b3
        free((int32_t *)all_flags);
        all_flags = 0;
    }
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d6200 - 0x80d6237
// Line range:    207 - 216
int32_t hid_find_printer(void) {
    // 0x80d6200
    if (hid_num_hids < 1) {
        // 0x80d6234
        return 0;
    }
    int32_t result = *(int32_t *)hid_list; // 0x80d6216
    if ((*(char *)(result + 12) & 2) != 0) {
        // 0x80d6234
        return result;
    }
    int32_t v1 = 0; // 0x80d621c
    v1++;
    int32_t result2 = 0; // 0x80d6230
    while (hid_num_hids > v1) {
        int32_t v2 = *(int32_t *)(4 * v1 + hid_list); // 0x80d6220
        result2 = v2;
        if ((*(char *)(v2 + 12) & 2) != 0) {
            // break -> 0x80d6234
            break;
        }
        v1++;
        result2 = 0;
    }
    // 0x80d6234
    return result2;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d6240 - 0x80d624a
// Line range:    237 - 240
int32_t hid_enumerate(void) {
    // 0x80d6240
    return hid_list;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d6250 - 0x80d6285
// Line range:    245 - 255
void hid_register_attributes(int32_t a, int32_t n) {
    int32_t * mem = calloc(1, 12); // 0x80d6265
    int32_t v1 = (int32_t)mem; // 0x80d6265
    *mem = hid_attr_nodes;
    hid_attr_nodes = v1;
    *(int32_t *)(v1 + 4) = a;
    *(int32_t *)(v1 + 8) = n;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d65c0 - 0x80d66b9
// Line range:    219 - 234
int32_t hid_find_exporter(char * which) {
    // 0x80d65c0
    for (int32_t i = 0; i < (uint32_t)hid_num_hids; i++) {
        int32_t v1 = *(int32_t *)(4 * i + hid_list); // 0x80d65e0
        if ((*(char *)(v1 + 12) & 4) != 0) {
            int32_t result = v1; // 0x80d6603
            if (strcmp(which, (char *)*(int32_t *)(v1 + 4)) == 0) {
                // 0x80d66af
                return result;
            }
        }
    }
    // 0x80d6610
    __fprintf_chk(g43, 1, "Invalid exporter %s, available ones:", which);
    int32_t v2 = hid_num_hids; // 0x80d663c
    int32_t v3 = 0; // 0x80d663c
    if (hid_num_hids >= 1) {
        while (true) {
            int32_t v4 = v3;
            int32_t v5 = *(int32_t *)(hid_list + 4 * v4); // 0x80d6658
            int32_t v6; // 0x80d65c0
            if ((*(char *)(v5 + 12) & 4) == 0) {
                int32_t v7 = v4 + 1; // 0x80d6648
                v6 = v2;
                v3 = v7;
                if (v2 <= v7) {
                    // break -> 0x80d6690
                    break;
                }
            } else {
                int32_t v8 = v4 + 1; // 0x80d6664
                __fprintf_chk(g43, 1, " %s", (char *)*(int32_t *)(v5 + 4));
                v6 = hid_num_hids;
                v3 = v8;
                if (hid_num_hids <= v8) {
                    // break -> 0x80d6690
                    break;
                }
            }
            // 0x80d6653
            v2 = v6;
        }
    }
    // 0x80d6690
    __fprintf_chk(g43, 1, "\n");
    // 0x80d66af
    return 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d66c0 - 0x80d6727
// Line range:    194 - 203
int32_t hid_find_gui(void) {
    // 0x80d66c0
    if (hid_num_hids < 1) {
        // 0x80d66fe
        __fprintf_chk(g43, 1, "Error: No GUI available.\n");
        exit(1);
        // UNREACHABLE
    }
    int32_t result = *(int32_t *)hid_list; // 0x80d66d9
    if ((*(char *)(result + 12) & 6) == 0) {
        // 0x80d66f8
        return result;
    }
    int32_t v1 = 0; // 0x80d66df
    v1++;
    while (hid_num_hids > v1) {
        int32_t v2 = *(int32_t *)(4 * v1 + hid_list); // 0x80d66ef
        int32_t result2 = v2; // 0x80d66f6
        if ((*(char *)(v2 + 12) & 6) == 0) {
            // 0x80d66f8
            return result2;
        }
        v1++;
    }
    // 0x80d66fe
    __fprintf_chk(g43, 1, "Error: No GUI available.\n");
    exit(1);
    // UNREACHABLE
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d6730 - 0x80d6a80
// Line range:    561 - 596
void hid_load_settings_1(char * fname) {
    int32_t v1 = __readgsdword(20); // 0x80d6746
    int32_t file_path; // 0x80d6730
    struct _IO_FILE * file = fopen((char *)file_path, (char *)&g231); // 0x80d6754
    free(&((struct _IO_FILE *)file_path)->e0);
    if (file != NULL) {
        // 0x80d6770
        int32_t str; // bp-1056, 0x80d6730
        if (fgets((char *)&str, 1024, file) != NULL) {
            // 0x80d6798
            while (true) {
                // 0x80d6798
                if ((char)str != 0) {
                    int16_t * v2 = *__ctype_b_loc(); // 0x80d67bb
                    int32_t v3 = &str;
                    int32_t v4 = str % 256;
                    char v5 = *(char *)((int32_t)v2 + 1 + 0x1000000 * v4 / 0x800000); // 0x80d67cd
                    while ((v5 & 32) != 0) {
                        int32_t v6 = v3 + 1; // 0x80d67c0
                        unsigned char v7 = *(char *)v6; // 0x80d67c3
                        int32_t v8 = v7; // 0x80d67c8
                        if (v7 == 0) {
                            goto lab_0x80d6770_3;
                        }
                        v3 = v6;
                        v4 = v8;
                        v5 = *(char *)((int32_t)v2 + 1 + 0x1000000 * v4 / 0x800000);
                    }
                    if (v4 != 35) {
                        char * str3 = (char *)v3; // 0x80d67d9
                        char v9 = *str3; // 0x80d67d9
                        if (v9 != 0) {
                            int16_t ** v10 = __ctype_b_loc(); // 0x80d67e6
                            int32_t v11 = (int32_t)*v10 + 1; // 0x80d6811
                            char v12 = v9; // 0x80d67f8
                            int32_t v13 = v3;
                            while ((*(char *)(v11 + 0x1000000 * (int32_t)v12 / 0x800000) & 32) == 0) {
                                int32_t v14 = v13 + 1; // 0x80d6800
                                v12 = *(char *)v14;
                                if (v12 == 0) {
                                    goto lab_0x80d6770_3;
                                }
                                v13 = v14;
                            }
                            // 0x80d6818
                            *(char *)v13 = 0;
                            int32_t v15 = v13 + 1; // 0x80d681b
                            char v16 = *(char *)v15; // 0x80d681e
                            if (v16 != 0) {
                                int32_t v17 = (int32_t)*v10 + 1; // 0x80d6841
                                char v18 = v16; // 0x80d682c
                                uint32_t v19 = v15;
                                char v20 = *(char *)(v17 + 0x1000000 * (int32_t)v18 / 0x800000); // 0x80d6841
                                while (v18 == 61 || (v20 & 32) != 0) {
                                    int32_t v21 = v19 + 1; // 0x80d6830
                                    v18 = *(char *)v21;
                                    if (v18 == 0) {
                                        goto lab_0x80d6770_3;
                                    }
                                    v19 = v21;
                                    v20 = *(char *)(v17 + 0x1000000 * (int32_t)v18 / 0x800000);
                                }
                                char * str2 = (char *)v19;
                                int32_t v22 = v19 - 1 + strlen(str2); // 0x80d6854
                                int32_t v23 = v22; // 0x80d685a
                                if (v22 >= v19) {
                                    int32_t v24 = v23;
                                    char * v25 = (char *)v24; // 0x80d686a
                                    char v26 = *(char *)((int32_t)*v10 + 1 + 2 * (int32_t)*v25); // 0x80d686f
                                    while ((v26 & 32) != 0) {
                                        // 0x80d6860
                                        *v25 = 0;
                                        int32_t v27 = v24 - 1; // 0x80d6863
                                        v23 = v27;
                                        if (v27 < v19) {
                                            // break -> 0x80d6876
                                            break;
                                        }
                                        v24 = v23;
                                        v25 = (char *)v24;
                                        v26 = *(char *)((int32_t)*v10 + 1 + 2 * (int32_t)*v25);
                                    }
                                }
                                // 0x80d6876
                                if (hid_attr_nodes != 0) {
                                    int32_t * v28 = (int32_t *)(hid_attr_nodes + 8); // 0x80d689f
                                    int32_t v29; // 0x80d6730
                                    int32_t v30; // 0x80d6730
                                    int32_t v31; // 0x80d68b1
                                    char * str4; // 0x80d6730
                                    int32_t v32; // 0x80d690e
                                    int32_t v33; // 0x80d6938
                                    int32_t v34; // 0x80d693b
                                    int32_t v35; // 0x80d6968
                                    int32_t str5; // 0x80d696b
                                    if (*v28 >= 1) {
                                        // 0x80d68a8
                                        v30 = 0;
                                        v32 = 0;
                                        v31 = *(int32_t *)(hid_attr_nodes + 4) + v30;
                                        g230 = v31;
                                        str4 = (char *)*(int32_t *)v31;
                                        if (strcmp(str3, str4) == 0) {
                                            // 0x80d68d7
                                            switch (g230) {
                                                case 1: {
                                                    // 0x80d68e1
                                                    *(int32_t *)(v31 + 20) = strtol(str2, NULL, 0);
                                                    // break -> 0x80d6908
                                                    break;
                                                }
                                                case 2: {
                                                    // 0x80d69d2
                                                    *(float64_t *)(v31 + 28) = strtod(str2, NULL);
                                                    // break -> 0x80d6908
                                                    break;
                                                }
                                                case 3: {
                                                    // 0x80d69bc
                                                    *(int32_t *)(v31 + 24) = (int32_t)__strdup(str2);
                                                    // break -> 0x80d6908
                                                    break;
                                                }
                                                case 4: {
                                                    // 0x80d69ab
                                                    *(int32_t *)(v31 + 20) = 1;
                                                    // break -> 0x80d6908
                                                    break;
                                                }
                                                case 5: {
                                                    // 0x80d6938
                                                    v33 = *(int32_t *)(v31 + 36);
                                                    v34 = *(int32_t *)v33;
                                                    str5 = v34;
                                                    if (v34 == 0) {
                                                        // 0x80d6a29
                                                        __fprintf_chk(g43, 1, "ERROR:  \"%s\" is an unknown value for the %s option\n", str2, str4);
                                                        exit(1);
                                                        // UNREACHABLE
                                                    }
                                                    v29 = 0;
                                                    while (strcmp((char *)str5, str2) != 0) {
                                                        // 0x80d6968
                                                        v35 = v29 + 1;
                                                        str5 = *(int32_t *)(4 * v35 + v33);
                                                        if (str5 == 0) {
                                                            // 0x80d6a29
                                                            __fprintf_chk(g43, 1, "ERROR:  \"%s\" is an unknown value for the %s option\n", str2, str4);
                                                            exit(1);
                                                            // UNREACHABLE
                                                        }
                                                        v29 = v35;
                                                    }
                                                    // 0x80d6986
                                                    *(int32_t *)(v31 + 20) = v29;
                                                    *(int32_t *)(v31 + 24) = v19;
                                                    // break -> 0x80d6908
                                                    break;
                                                }
                                                case 6: {
                                                    // 0x80d69b7
                                                    abort();
                                                    // UNREACHABLE
                                                }
                                                case 7: {
                                                    // 0x80d69f0
                                                    *(int32_t *)(v31 + 24) = v19;
                                                    // break -> 0x80d6908
                                                    break;
                                                }
                                            }
                                        }
                                        // 0x80d6908
                                        v32++;
                                        v30 += 48;
                                        while (v32 < *v28) {
                                            // 0x80d68a8
                                            v31 = *(int32_t *)(hid_attr_nodes + 4) + v30;
                                            g230 = v31;
                                            str4 = (char *)*(int32_t *)v31;
                                            if (strcmp(str3, str4) == 0) {
                                                // 0x80d68d7
                                                switch (g230) {
                                                    case 1: {
                                                        // 0x80d68e1
                                                        *(int32_t *)(v31 + 20) = strtol(str2, NULL, 0);
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 2: {
                                                        // 0x80d69d2
                                                        *(float64_t *)(v31 + 28) = strtod(str2, NULL);
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 3: {
                                                        // 0x80d69bc
                                                        *(int32_t *)(v31 + 24) = (int32_t)__strdup(str2);
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 4: {
                                                        // 0x80d69ab
                                                        *(int32_t *)(v31 + 20) = 1;
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 5: {
                                                        // 0x80d6938
                                                        v33 = *(int32_t *)(v31 + 36);
                                                        v34 = *(int32_t *)v33;
                                                        str5 = v34;
                                                        if (v34 == 0) {
                                                            // 0x80d6a29
                                                            __fprintf_chk(g43, 1, "ERROR:  \"%s\" is an unknown value for the %s option\n", str2, str4);
                                                            exit(1);
                                                            // UNREACHABLE
                                                        }
                                                        v29 = 0;
                                                        while (strcmp((char *)str5, str2) != 0) {
                                                            // 0x80d6968
                                                            v35 = v29 + 1;
                                                            str5 = *(int32_t *)(4 * v35 + v33);
                                                            if (str5 == 0) {
                                                                // 0x80d6a29
                                                                __fprintf_chk(g43, 1, "ERROR:  \"%s\" is an unknown value for the %s option\n", str2, str4);
                                                                exit(1);
                                                                // UNREACHABLE
                                                            }
                                                            v29 = v35;
                                                        }
                                                        // 0x80d6986
                                                        *(int32_t *)(v31 + 20) = v29;
                                                        *(int32_t *)(v31 + 24) = v19;
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 6: {
                                                        // 0x80d69b7
                                                        abort();
                                                        // UNREACHABLE
                                                    }
                                                    case 7: {
                                                        // 0x80d69f0
                                                        *(int32_t *)(v31 + 24) = v19;
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                }
                                            }
                                            // 0x80d6908
                                            v32++;
                                            v30 += 48;
                                        }
                                    }
                                    int32_t v36 = *(int32_t *)hid_attr_nodes; // 0x80d691f
                                    while (v36 != 0) {
                                        int32_t v37 = v36;
                                        v28 = (int32_t *)(v37 + 8);
                                        if (*v28 >= 1) {
                                            // 0x80d68a8
                                            v30 = 0;
                                            v32 = 0;
                                            v31 = *(int32_t *)(v37 + 4) + v30;
                                            g230 = v31;
                                            str4 = (char *)*(int32_t *)v31;
                                            if (strcmp(str3, str4) == 0) {
                                                // 0x80d68d7
                                                switch (g230) {
                                                    case 1: {
                                                        // 0x80d68e1
                                                        *(int32_t *)(v31 + 20) = strtol(str2, NULL, 0);
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 2: {
                                                        // 0x80d69d2
                                                        *(float64_t *)(v31 + 28) = strtod(str2, NULL);
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 3: {
                                                        // 0x80d69bc
                                                        *(int32_t *)(v31 + 24) = (int32_t)__strdup(str2);
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 4: {
                                                        // 0x80d69ab
                                                        *(int32_t *)(v31 + 20) = 1;
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 5: {
                                                        // 0x80d6938
                                                        v33 = *(int32_t *)(v31 + 36);
                                                        v34 = *(int32_t *)v33;
                                                        str5 = v34;
                                                        if (v34 == 0) {
                                                            // 0x80d6a29
                                                            __fprintf_chk(g43, 1, "ERROR:  \"%s\" is an unknown value for the %s option\n", str2, str4);
                                                            exit(1);
                                                            // UNREACHABLE
                                                        }
                                                        v29 = 0;
                                                        while (strcmp((char *)str5, str2) != 0) {
                                                            // 0x80d6968
                                                            v35 = v29 + 1;
                                                            str5 = *(int32_t *)(4 * v35 + v33);
                                                            if (str5 == 0) {
                                                                // 0x80d6a29
                                                                __fprintf_chk(g43, 1, "ERROR:  \"%s\" is an unknown value for the %s option\n", str2, str4);
                                                                exit(1);
                                                                // UNREACHABLE
                                                            }
                                                            v29 = v35;
                                                        }
                                                        // 0x80d6986
                                                        *(int32_t *)(v31 + 20) = v29;
                                                        *(int32_t *)(v31 + 24) = v19;
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                    case 6: {
                                                        // 0x80d69b7
                                                        abort();
                                                        // UNREACHABLE
                                                    }
                                                    case 7: {
                                                        // 0x80d69f0
                                                        *(int32_t *)(v31 + 24) = v19;
                                                        // break -> 0x80d6908
                                                        break;
                                                    }
                                                }
                                            }
                                            // 0x80d6908
                                            v32++;
                                            v30 += 48;
                                            while (v32 < *v28) {
                                                // 0x80d68a8
                                                v31 = *(int32_t *)(v37 + 4) + v30;
                                                g230 = v31;
                                                str4 = (char *)*(int32_t *)v31;
                                                if (strcmp(str3, str4) == 0) {
                                                    // 0x80d68d7
                                                    switch (g230) {
                                                        case 1: {
                                                            // 0x80d68e1
                                                            *(int32_t *)(v31 + 20) = strtol(str2, NULL, 0);
                                                            // break -> 0x80d6908
                                                            break;
                                                        }
                                                        case 2: {
                                                            // 0x80d69d2
                                                            *(float64_t *)(v31 + 28) = strtod(str2, NULL);
                                                            // break -> 0x80d6908
                                                            break;
                                                        }
                                                        case 3: {
                                                            // 0x80d69bc
                                                            *(int32_t *)(v31 + 24) = (int32_t)__strdup(str2);
                                                            // break -> 0x80d6908
                                                            break;
                                                        }
                                                        case 4: {
                                                            // 0x80d69ab
                                                            *(int32_t *)(v31 + 20) = 1;
                                                            // break -> 0x80d6908
                                                            break;
                                                        }
                                                        case 5: {
                                                            // 0x80d6938
                                                            v33 = *(int32_t *)(v31 + 36);
                                                            v34 = *(int32_t *)v33;
                                                            str5 = v34;
                                                            if (v34 == 0) {
                                                                // 0x80d6a29
                                                                __fprintf_chk(g43, 1, "ERROR:  \"%s\" is an unknown value for the %s option\n", str2, str4);
                                                                exit(1);
                                                                // UNREACHABLE
                                                            }
                                                            v29 = 0;
                                                            while (strcmp((char *)str5, str2) != 0) {
                                                                // 0x80d6968
                                                                v35 = v29 + 1;
                                                                str5 = *(int32_t *)(4 * v35 + v33);
                                                                if (str5 == 0) {
                                                                    // 0x80d6a29
                                                                    __fprintf_chk(g43, 1, "ERROR:  \"%s\" is an unknown value for the %s option\n", str2, str4);
                                                                    exit(1);
                                                                    // UNREACHABLE
                                                                }
                                                                v29 = v35;
                                                            }
                                                            // 0x80d6986
                                                            *(int32_t *)(v31 + 20) = v29;
                                                            *(int32_t *)(v31 + 24) = v19;
                                                            // break -> 0x80d6908
                                                            break;
                                                        }
                                                        case 6: {
                                                            // 0x80d69b7
                                                            abort();
                                                            // UNREACHABLE
                                                        }
                                                        case 7: {
                                                            // 0x80d69f0
                                                            *(int32_t *)(v31 + 24) = v19;
                                                            // break -> 0x80d6908
                                                            break;
                                                        }
                                                    }
                                                }
                                                // 0x80d6908
                                                v32++;
                                                v30 += 48;
                                            }
                                        }
                                        // 0x80d6919
                                        v36 = *(int32_t *)v37;
                                    }
                                }
                            }
                        }
                    }
                }
              lab_0x80d6770_3:
                // 0x80d6770
                if (fgets((char *)&str, 1024, file) == NULL) {
                    // break -> 0x80d69fe
                    break;
                }
            }
        }
        // 0x80d69fe
        fclose(file);
    }
    // 0x80d6a0c
    if (v1 == __readgsdword(20)) {
        // 0x80d6a18
        return;
    }
    // 0x80d6a6a
    __stack_chk_fail();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d6a80 - 0x80d6b5d
// Line range:    599 - 612
void hid_load_settings(void) {
    // 0x80d6a80
    if (hid_attr_nodes != 0) {
        int32_t * v1 = (int32_t *)(hid_attr_nodes + 8); // 0x80d6a93
        int32_t v2; // 0x80d6a80
        int32_t v3; // 0x80d6a80
        int32_t v4; // 0x80d6aba
        int32_t v5; // 0x80d6ac4
        unsigned char v6; // 0x80d6ab3
        int32_t v7; // 0x80d6ab7
        if (*v1 >= 1) {
            // 0x80d6a9a
            v3 = *(int32_t *)(hid_attr_nodes + 4);
            v5 = 0;
            v7 = 0;
            v2 = 0;
            v6 = *(char *)(v7 + v3);
            v7++;
            v4 = v2 / 0x10000 ^ 13 * v2 ^ (int32_t)v6;
            while (v7 != 44) {
                // 0x80d6aa8
                v2 = v4;
                v6 = *(char *)(v7 + v3);
                v7++;
                v4 = v2 / 0x10000 ^ 13 * v2 ^ (int32_t)v6;
            }
            // 0x80d6ac1
            *(int32_t *)(v3 + 44) = v4;
            v5++;
            v3 += 48;
            while (*v1 > v5) {
                // 0x80d6aa0
                v7 = 0;
                v2 = 0;
                v6 = *(char *)(v7 + v3);
                v7++;
                v4 = v2 / 0x10000 ^ 13 * v2 ^ (int32_t)v6;
                while (v7 != 44) {
                    // 0x80d6aa8
                    v2 = v4;
                    v6 = *(char *)(v7 + v3);
                    v7++;
                    v4 = v2 / 0x10000 ^ 13 * v2 ^ (int32_t)v6;
                }
                // 0x80d6ac1
                *(int32_t *)(v3 + 44) = v4;
                v5++;
                v3 += 48;
            }
        }
        int32_t v8 = *(int32_t *)hid_attr_nodes; // 0x80d6acf
        while (v8 != 0) {
            int32_t v9 = v8;
            v1 = (int32_t *)(v9 + 8);
            if (*v1 >= 1) {
                // 0x80d6a9a
                v3 = *(int32_t *)(v9 + 4);
                v5 = 0;
                v7 = 0;
                v2 = 0;
                v6 = *(char *)(v7 + v3);
                v7++;
                v4 = v2 / 0x10000 ^ 13 * v2 ^ (int32_t)v6;
                while (v7 != 44) {
                    // 0x80d6aa8
                    v2 = v4;
                    v6 = *(char *)(v7 + v3);
                    v7++;
                    v4 = v2 / 0x10000 ^ 13 * v2 ^ (int32_t)v6;
                }
                // 0x80d6ac1
                *(int32_t *)(v3 + 44) = v4;
                v5++;
                v3 += 48;
                while (*v1 > v5) {
                    // 0x80d6aa0
                    v7 = 0;
                    v2 = 0;
                    v6 = *(char *)(v7 + v3);
                    v7++;
                    v4 = v2 / 0x10000 ^ 13 * v2 ^ (int32_t)v6;
                    while (v7 != 44) {
                        // 0x80d6aa8
                        v2 = v4;
                        v6 = *(char *)(v7 + v3);
                        v7++;
                        v4 = v2 / 0x10000 ^ 13 * v2 ^ (int32_t)v6;
                    }
                    // 0x80d6ac1
                    *(int32_t *)(v3 + 44) = v4;
                    v5++;
                    v3 += 48;
                }
            }
            // 0x80d6acf
            v8 = *(int32_t *)v9;
        }
    }
    // 0x80d6ad5
    Concat((char *)pcblibdir);
    hid_load_settings_1((char *)&g231);
    if (homedir != 0) {
        // 0x80d6b08
        Concat((char *)homedir);
        hid_load_settings_1((char *)&g231);
    }
    // 0x80d6b3d
    Concat("pcb.settings");
    hid_load_settings_1((char *)&g231);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d7300 - 0x80d73c4
// Line range:    153 - 165
void hid_register_hid(int32_t hid) {
    // 0x80d7300
    if (*(int32_t *)hid != 208) {
        int32_t v1 = *(int32_t *)(hid + 4); // 0x80d7378
        __fprintf_chk(g43, 1, "Warning: hid \"%s\" has an incompatible ABI.\n", (char *)v1);
        return;
    }
    uint32_t v2 = hid_num_hids; // 0x80d730a
    int32_t v3 = hid_list;
    if (v2 >= 1) {
        // 0x80d7320
        if (*(int32_t *)v3 == hid) {
            // 0x80d7372
            return;
        }
        int32_t v4 = 0; // 0x80d732a
        v4++;
        while (v2 > v4) {
            // 0x80d7330
            if (*(int32_t *)(4 * v4 + v3) == hid) {
                // 0x80d7372
                return;
            }
            v4++;
        }
    }
    int32_t size = 4 * v2 + 8; // 0x80d733c
    hid_num_hids = v2 + 1;
    int32_t * mem; // 0x80d7300
    if (v3 == 0) {
        // 0x80d73a2
        mem = calloc(1, size);
    } else {
        // 0x80d7350
        mem = realloc(&((struct _IO_FILE *)v3)->e0, size);
    }
    int32_t v5 = (int32_t)mem;
    hid_list = v5;
    int32_t v6 = 4 * hid_num_hids + v5;
    *(int32_t *)(v6 - 4) = hid;
    *(int32_t *)v6 = 0;
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d73d0 - 0x80d75a2
// Line range:    56 - 108
void hid_load_dir(char * dirname) {
    // 0x80d73d0
    char v1; // 0x80d73d0
    char v2 = v1;
    int32_t v3; // 0x80d73d0
    char * name = (char *)v3;
    struct __dirstream * dirp = opendir(name); // 0x80d73e2
    if (dirp == NULL) {
        // 0x80d74e8
        free(&((struct _IO_FILE *)v3)->e0);
        return;
    }
    struct dirent * v4 = readdir(dirp); // 0x80d7464
    if (v4 == NULL) {
        // 0x80d74e8
        free(&((struct _IO_FILE *)v3)->e0);
        return;
    }
    char * str = __strdup((char *)((int32_t)v4 + 11)); // 0x80d7473
    uint32_t len = strlen(str); // 0x80d747d
    int32_t v5; // 0x80d73d0
    char * str2; // 0x80d73d0
    char * str3; // 0x80d73d0
    if (len >= 4) {
        // 0x80d748d
        v5 = len + (int32_t)str;
        str2 = (char *)(v5 - 3);
        if (strcasecmp(str2, ".so") == 0) {
            // 0x80d73f8
            *str2 = 0;
        } else {
            if (len != 4) {
                // 0x80d74be
                str3 = (char *)(v5 - 4);
                if (strcasecmp(str3, ".dll") == 0) {
                    // 0x80d74da
                    *str3 = 0;
                }
            }
        }
    }
    char * file_path = Concat(name); // 0x80d7415
    int32_t v6; // bp-116, 0x80d73d0
    int32_t v7 = __xstat(3, file_path, (struct stat *)&v6); // 0x80d742e
    int32_t * v8; // 0x80d750b
    char * v9; // 0x80d7531
    if (((int32_t)v2 & 0xf000) == 0x8000 && (v2 & 73) != 0 && v7 == 0) {
        // 0x80d7500
        v8 = dlopen(file_path, 258);
        if (v8 == NULL) {
            // 0x80d7561
            __fprintf_chk(g43, 1, "dl_error: %s\n", dlerror());
        } else {
            // 0x80d7516
            v9 = Concat("hid_");
            if (dlsym(v8, v9) == NULL) {
                // 0x80d758c
                dlsym(v8, "pcb_plugin_init");
            }
            // 0x80d754e
            free((int32_t *)v9);
        }
    }
    // 0x80d744e
    free((int32_t *)str);
    free((int32_t *)file_path);
    struct dirent * v10 = readdir(dirp); // 0x80d7464
    while (v10 != NULL) {
        // 0x80d746d
        str = __strdup((char *)((int32_t)v10 + 11));
        len = strlen(str);
        if (len >= 4) {
            // 0x80d748d
            v5 = len + (int32_t)str;
            str2 = (char *)(v5 - 3);
            if (strcasecmp(str2, ".so") == 0) {
                // 0x80d73f8
                *str2 = 0;
            } else {
                if (len != 4) {
                    // 0x80d74be
                    str3 = (char *)(v5 - 4);
                    if (strcasecmp(str3, ".dll") == 0) {
                        // 0x80d74da
                        *str3 = 0;
                    }
                }
            }
        }
        // 0x80d73fb
        file_path = Concat(name);
        v7 = __xstat(3, file_path, (struct stat *)&v6);
        if (((int32_t)v2 & 0xf000) == 0x8000 && (v2 & 73) != 0 && v7 == 0) {
            // 0x80d7500
            v8 = dlopen(file_path, 258);
            if (v8 == NULL) {
                // 0x80d7561
                __fprintf_chk(g43, 1, "dl_error: %s\n", dlerror());
            } else {
                // 0x80d7516
                v9 = Concat("hid_");
                if (dlsym(v8, v9) == NULL) {
                    // 0x80d758c
                    dlsym(v8, "pcb_plugin_init");
                }
                // 0x80d754e
                free((int32_t *)v9);
            }
        }
        // 0x80d744e
        free((int32_t *)str);
        free((int32_t *)file_path);
        v10 = readdir(dirp);
    }
    // 0x80d74e8
    free(&((struct _IO_FILE *)v3)->e0);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidinit.c
// Address range: 0x80d75b0 - 0x80d7754
// Line range:    123 - 149
void hid_init(void) {
    // 0x80d75b0
    gui = &hid_nogui;
    hid_gtk_init();
    hid_lpr_init();
    hid_bom_init();
    hid_gerber_init();
    hid_nelma_init();
    hid_png_init();
    hid_ps_init();
    Concat((char *)exec_prefix);
    hid_load_dir((char *)&g231);
    Concat((char *)exec_prefix);
    hid_load_dir((char *)&g231);
    if (homedir != 0) {
        // 0x80d7692
        Concat((char *)homedir);
        hid_load_dir((char *)&g231);
        Concat((char *)homedir);
        hid_load_dir((char *)&g231);
    }
    // 0x80d7711
    Concat("plugins");
    hid_load_dir((char *)&g231);
    Concat("plugins");
    hid_load_dir((char *)&g231);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/common/hidnogui.c
// Address range: 0x80d77b0 - 0x80d7e91
// Line range:    412 - 458
void apply_default_hid(int32_t d, int32_t s) {
    int32_t v1 = s == 0 ? (int32_t)&hid_nogui : s; // 0x80d77c0
    int32_t * v2 = (int32_t *)(d + 16); // 0x80d77c3
    int32_t * v3; // 0x80d77b0
    if (*v2 == 0) {
        // 0x80d7a08
        *v2 = *(int32_t *)(v1 + 16);
        int32_t * v4 = (int32_t *)(d + 20);
        v3 = v4;
        if (*v4 != 0) {
            goto lab_0x80d77d9;
        } else {
            goto lab_0x80d7a20;
        }
    } else {
        int32_t * v5 = (int32_t *)(d + 20);
        v3 = v5;
        if (*v5 == 0) {
            goto lab_0x80d7a20;
        } else {
            goto lab_0x80d77d9;
        }
    }
  lab_0x80d77d9:;
    int32_t * v6 = (int32_t *)(d + 24);
    int32_t * v7 = v6; // 0x80d77de
    if (*v6 == 0) {
        goto lab_0x80d7a38;
    } else {
        goto lab_0x80d77e4;
    }
  lab_0x80d7a20:
    // 0x80d7a20
    *v3 = *(int32_t *)(v1 + 20);
    int32_t * v8 = (int32_t *)(d + 24);
    v7 = v8;
    if (*v8 != 0) {
        goto lab_0x80d77e4;
    } else {
        goto lab_0x80d7a38;
    }
  lab_0x80d7a38:
    // 0x80d7a38
    *v7 = *(int32_t *)(v1 + 24);
    int32_t * v9 = (int32_t *)(d + 28);
    int32_t * v10 = v9; // 0x80d7a43
    if (*v9 != 0) {
        goto lab_0x80d77ef;
    } else {
        goto lab_0x80d7a50;
    }
  lab_0x80d77e4:;
    int32_t * v11 = (int32_t *)(d + 28);
    v10 = v11;
    if (*v11 == 0) {
        goto lab_0x80d7a50;
    } else {
        goto lab_0x80d77ef;
    }
  lab_0x80d77ef:;
    int32_t * v12 = (int32_t *)(d + 32);
    int32_t * v13 = v12; // 0x80d77f4
    if (*v12 == 0) {
        goto lab_0x80d7a68;
    } else {
        goto lab_0x80d77fa;
    }
  lab_0x80d7a50:
    // 0x80d7a50
    *v10 = *(int32_t *)(v1 + 28);
    int32_t * v14 = (int32_t *)(d + 32);
    v13 = v14;
    if (*v14 != 0) {
        goto lab_0x80d77fa;
    } else {
        goto lab_0x80d7a68;
    }
  lab_0x80d7a68:
    // 0x80d7a68
    *v13 = *(int32_t *)(v1 + 32);
    int32_t * v15 = (int32_t *)(d + 36);
    int32_t * v16 = v15; // 0x80d7a73
    if (*v15 != 0) {
        goto lab_0x80d7805;
    } else {
        goto lab_0x80d7a80;
    }
  lab_0x80d77fa:;
    int32_t * v17 = (int32_t *)(d + 36);
    v16 = v17;
    if (*v17 == 0) {
        goto lab_0x80d7a80;
    } else {
        goto lab_0x80d7805;
    }
  lab_0x80d7805:;
    int32_t * v18 = (int32_t *)(d + 40);
    int32_t * v19 = v18; // 0x80d780a
    if (*v18 == 0) {
        goto lab_0x80d7a98;
    } else {
        goto lab_0x80d7810;
    }
  lab_0x80d7a80:
    // 0x80d7a80
    *v16 = *(int32_t *)(v1 + 36);
    int32_t * v20 = (int32_t *)(d + 40);
    v19 = v20;
    if (*v20 != 0) {
        goto lab_0x80d7810;
    } else {
        goto lab_0x80d7a98;
    }
  lab_0x80d7a98:
    // 0x80d7a98
    *v19 = *(int32_t *)(v1 + 40);
    int32_t * v21 = (int32_t *)(d + 44);
    int32_t * v22 = v21; // 0x80d7aa3
    if (*v21 != 0) {
        goto lab_0x80d781b;
    } else {
        goto lab_0x80d7ab0;
    }
  lab_0x80d7810:;
    int32_t * v23 = (int32_t *)(d + 44);
    v22 = v23;
    if (*v23 == 0) {
        goto lab_0x80d7ab0;
    } else {
        goto lab_0x80d781b;
    }
  lab_0x80d781b:;
    int32_t * v24 = (int32_t *)(d + 48);
    int32_t * v25 = v24; // 0x80d7820
    if (*v24 == 0) {
        goto lab_0x80d7ac8;
    } else {
        goto lab_0x80d7826;
    }
  lab_0x80d7ab0:
    // 0x80d7ab0
    *v22 = *(int32_t *)(v1 + 44);
    int32_t * v26 = (int32_t *)(d + 48);
    v25 = v26;
    if (*v26 != 0) {
        goto lab_0x80d7826;
    } else {
        goto lab_0x80d7ac8;
    }
  lab_0x80d7ac8:
    // 0x80d7ac8
    *v25 = *(int32_t *)(v1 + 48);
    int32_t * v27 = (int32_t *)(d + 52);
    int32_t * v28 = v27; // 0x80d7ad3
    if (*v27 != 0) {
        goto lab_0x80d7831;
    } else {
        goto lab_0x80d7ae0;
    }
  lab_0x80d7826:;
    int32_t * v29 = (int32_t *)(d + 52);
    v28 = v29;
    if (*v29 == 0) {
        goto lab_0x80d7ae0;
    } else {
        goto lab_0x80d7831;
    }
  lab_0x80d7831:;
    int32_t * v30 = (int32_t *)(d + 56);
    int32_t * v31 = v30; // 0x80d7836
    if (*v30 == 0) {
        goto lab_0x80d7af8;
    } else {
        goto lab_0x80d783c;
    }
  lab_0x80d7ae0:
    // 0x80d7ae0
    *v28 = *(int32_t *)(v1 + 52);
    int32_t * v32 = (int32_t *)(d + 56);
    v31 = v32;
    if (*v32 != 0) {
        goto lab_0x80d783c;
    } else {
        goto lab_0x80d7af8;
    }
  lab_0x80d7af8:
    // 0x80d7af8
    *v31 = *(int32_t *)(v1 + 56);
    int32_t * v33 = (int32_t *)(d + 60);
    int32_t * v34 = v33; // 0x80d7b03
    if (*v33 != 0) {
        goto lab_0x80d7847;
    } else {
        goto lab_0x80d7b10;
    }
  lab_0x80d783c:;
    int32_t * v35 = (int32_t *)(d + 60);
    v34 = v35;
    if (*v35 == 0) {
        goto lab_0x80d7b10;
    } else {
        goto lab_0x80d7847;
    }
  lab_0x80d7847:;
    int32_t * v36 = (int32_t *)(d + 64);
    int32_t * v37 = v36; // 0x80d784c
    if (*v36 == 0) {
        goto lab_0x80d7b28;
    } else {
        goto lab_0x80d7852;
    }
  lab_0x80d7b10:
    // 0x80d7b10
    *v34 = *(int32_t *)(v1 + 60);
    int32_t * v38 = (int32_t *)(d + 64);
    v37 = v38;
    if (*v38 != 0) {
        goto lab_0x80d7852;
    } else {
        goto lab_0x80d7b28;
    }
  lab_0x80d7b28:
    // 0x80d7b28
    *v37 = *(int32_t *)(v1 + 64);
    int32_t * v39 = (int32_t *)(d + 68);
    int32_t * v40 = v39; // 0x80d7b33
    if (*v39 != 0) {
        goto lab_0x80d785d;
    } else {
        goto lab_0x80d7b40;
    }
  lab_0x80d7852:;
    int32_t * v41 = (int32_t *)(d + 68);
    v40 = v41;
    if (*v41 == 0) {
        goto lab_0x80d7b40;
    } else {
        goto lab_0x80d785d;
    }
  lab_0x80d785d:;
    int32_t * v42 = (int32_t *)(d + 76);
    int32_t * v43 = v42; // 0x80d7862
    if (*v42 == 0) {
        goto lab_0x80d7b58;
    } else {
        goto lab_0x80d7868;
    }
  lab_0x80d7b40:
    // 0x80d7b40
    *v40 = *(int32_t *)(v1 + 68);
    int32_t * v44 = (int32_t *)(d + 76);
    v43 = v44;
    if (*v44 != 0) {
        goto lab_0x80d7868;
    } else {
        goto lab_0x80d7b58;
    }
  lab_0x80d7b58:
    // 0x80d7b58
    *v43 = *(int32_t *)(v1 + 76);
    int32_t * v45 = (int32_t *)(d + 80);
    int32_t * v46 = v45; // 0x80d7b63
    if (*v45 != 0) {
        goto lab_0x80d7873;
    } else {
        goto lab_0x80d7b70;
    }
  lab_0x80d7868:;
    int32_t * v47 = (int32_t *)(d + 80);
    v46 = v47;
    if (*v47 == 0) {
        goto lab_0x80d7b70;
    } else {
        goto lab_0x80d7873;
    }
  lab_0x80d7873:;
    int32_t * v48 = (int32_t *)(d + 84);
    int32_t * v49 = v48; // 0x80d7878
    if (*v48 == 0) {
        goto lab_0x80d7b88;
    } else {
        goto lab_0x80d787e;
    }
  lab_0x80d7b70:
    // 0x80d7b70
    *v46 = *(int32_t *)(v1 + 80);
    int32_t * v50 = (int32_t *)(d + 84);
    v49 = v50;
    if (*v50 != 0) {
        goto lab_0x80d787e;
    } else {
        goto lab_0x80d7b88;
    }
  lab_0x80d7b88:
    // 0x80d7b88
    *v49 = *(int32_t *)(v1 + 84);
    int32_t * v51 = (int32_t *)(d + 92);
    int32_t * v52 = v51; // 0x80d7b93
    if (*v51 != 0) {
        goto lab_0x80d7889;
    } else {
        goto lab_0x80d7ba0;
    }
  lab_0x80d787e:;
    int32_t * v53 = (int32_t *)(d + 92);
    v52 = v53;
    if (*v53 == 0) {
        goto lab_0x80d7ba0;
    } else {
        goto lab_0x80d7889;
    }
  lab_0x80d7889:;
    int32_t * v54 = (int32_t *)(d + 96);
    int32_t * v55 = v54; // 0x80d788e
    if (*v54 == 0) {
        goto lab_0x80d7bb8;
    } else {
        goto lab_0x80d7894;
    }
  lab_0x80d7ba0:
    // 0x80d7ba0
    *v52 = *(int32_t *)(v1 + 92);
    int32_t * v56 = (int32_t *)(d + 96);
    v55 = v56;
    if (*v56 != 0) {
        goto lab_0x80d7894;
    } else {
        goto lab_0x80d7bb8;
    }
  lab_0x80d7bb8:
    // 0x80d7bb8
    *v55 = *(int32_t *)(v1 + 96);
    int32_t * v57 = (int32_t *)(d + 100);
    int32_t * v58 = v57; // 0x80d7bc3
    if (*v57 != 0) {
        goto lab_0x80d789f;
    } else {
        goto lab_0x80d7bd0;
    }
  lab_0x80d7894:;
    int32_t * v59 = (int32_t *)(d + 100);
    v58 = v59;
    if (*v59 == 0) {
        goto lab_0x80d7bd0;
    } else {
        goto lab_0x80d789f;
    }
  lab_0x80d789f:;
    int32_t * v60 = (int32_t *)(d + 104);
    int32_t * v61 = v60; // 0x80d78a4
    if (*v60 == 0) {
        goto lab_0x80d7be8;
    } else {
        goto lab_0x80d78aa;
    }
  lab_0x80d7bd0:
    // 0x80d7bd0
    *v58 = *(int32_t *)(v1 + 100);
    int32_t * v62 = (int32_t *)(d + 104);
    v61 = v62;
    if (*v62 != 0) {
        goto lab_0x80d78aa;
    } else {
        goto lab_0x80d7be8;
    }
  lab_0x80d7be8:
    // 0x80d7be8
    *v61 = *(int32_t *)(v1 + 104);
    int32_t * v63 = (int32_t *)(d + 112);
    int32_t * v64 = v63; // 0x80d7bf3
    if (*v63 != 0) {
        goto lab_0x80d78b5;
    } else {
        goto lab_0x80d7c00;
    }
  lab_0x80d78aa:;
    int32_t * v65 = (int32_t *)(d + 112);
    v64 = v65;
    if (*v65 == 0) {
        goto lab_0x80d7c00;
    } else {
        goto lab_0x80d78b5;
    }
  lab_0x80d78b5:;
    int32_t * v66 = (int32_t *)(d + 116);
    int32_t * v67 = v66; // 0x80d78ba
    if (*v66 == 0) {
        goto lab_0x80d7c18;
    } else {
        goto lab_0x80d78c0;
    }
  lab_0x80d7c00:
    // 0x80d7c00
    *v64 = *(int32_t *)(v1 + 112);
    int32_t * v68 = (int32_t *)(d + 116);
    v67 = v68;
    if (*v68 != 0) {
        goto lab_0x80d78c0;
    } else {
        goto lab_0x80d7c18;
    }
  lab_0x80d7c18:
    // 0x80d7c18
    *v67 = *(int32_t *)(v1 + 116);
    int32_t * v69 = (int32_t *)(d + 120);
    int32_t * v70 = v69; // 0x80d7c23
    if (*v69 != 0) {
        goto lab_0x80d78cb;
    } else {
        goto lab_0x80d7c30;
    }
  lab_0x80d78c0:;
    int32_t * v71 = (int32_t *)(d + 120);
    v70 = v71;
    if (*v71 == 0) {
        goto lab_0x80d7c30;
    } else {
        goto lab_0x80d78cb;
    }
  lab_0x80d78cb:;
    int32_t * v72 = (int32_t *)(d + 124);
    int32_t * v73 = v72; // 0x80d78d0
    if (*v72 == 0) {
        goto lab_0x80d7c48;
    } else {
        goto lab_0x80d78d6;
    }
  lab_0x80d7c30:
    // 0x80d7c30
    *v70 = *(int32_t *)(v1 + 120);
    int32_t * v74 = (int32_t *)(d + 124);
    v73 = v74;
    if (*v74 != 0) {
        goto lab_0x80d78d6;
    } else {
        goto lab_0x80d7c48;
    }
  lab_0x80d7c48:
    // 0x80d7c48
    *v73 = *(int32_t *)(v1 + 124);
    int32_t * v75 = (int32_t *)(d + 128);
    int32_t * v76 = v75; // 0x80d7c56
    if (*v75 != 0) {
        goto lab_0x80d78e4;
    } else {
        goto lab_0x80d7c60;
    }
  lab_0x80d78d6:;
    int32_t * v77 = (int32_t *)(d + 128);
    v76 = v77;
    if (*v77 == 0) {
        goto lab_0x80d7c60;
    } else {
        goto lab_0x80d78e4;
    }
  lab_0x80d78e4:;
    int32_t * v78 = (int32_t *)(d + 132);
    int32_t * v79 = v78; // 0x80d78ec
    if (*v78 == 0) {
        goto lab_0x80d7c80;
    } else {
        goto lab_0x80d78f2;
    }
  lab_0x80d7c60:
    // 0x80d7c60
    *v76 = *(int32_t *)(v1 + 128);
    int32_t * v80 = (int32_t *)(d + 132);
    v79 = v80;
    if (*v80 != 0) {
        goto lab_0x80d78f2;
    } else {
        goto lab_0x80d7c80;
    }
  lab_0x80d7c80:
    // 0x80d7c80
    *v79 = *(int32_t *)(v1 + 132);
    int32_t * v81 = (int32_t *)(d + 136);
    int32_t * v82 = v81; // 0x80d7c94
    if (*v81 != 0) {
        goto lab_0x80d7900;
    } else {
        goto lab_0x80d7ca0;
    }
  lab_0x80d78f2:;
    int32_t * v83 = (int32_t *)(d + 136);
    v82 = v83;
    if (*v83 == 0) {
        goto lab_0x80d7ca0;
    } else {
        goto lab_0x80d7900;
    }
  lab_0x80d7900:;
    int32_t * v84 = (int32_t *)(d + 140);
    int32_t * v85 = v84; // 0x80d7908
    if (*v84 == 0) {
        goto lab_0x80d7cc0;
    } else {
        goto lab_0x80d790e;
    }
  lab_0x80d7ca0:
    // 0x80d7ca0
    *v82 = *(int32_t *)(v1 + 136);
    int32_t * v86 = (int32_t *)(d + 140);
    v85 = v86;
    if (*v86 != 0) {
        goto lab_0x80d790e;
    } else {
        goto lab_0x80d7cc0;
    }
  lab_0x80d7cc0:
    // 0x80d7cc0
    *v85 = *(int32_t *)(v1 + 140);
    int32_t * v87 = (int32_t *)(d + 144);
    int32_t * v88 = v87; // 0x80d7cd4
    if (*v87 != 0) {
        goto lab_0x80d791c;
    } else {
        goto lab_0x80d7ce0;
    }
  lab_0x80d790e:;
    int32_t * v89 = (int32_t *)(d + 144);
    v88 = v89;
    if (*v89 == 0) {
        goto lab_0x80d7ce0;
    } else {
        goto lab_0x80d791c;
    }
  lab_0x80d791c:;
    int32_t * v90 = (int32_t *)(d + 148);
    int32_t * v91 = v90; // 0x80d7924
    if (*v90 == 0) {
        goto lab_0x80d7d00;
    } else {
        goto lab_0x80d792a;
    }
  lab_0x80d7ce0:
    // 0x80d7ce0
    *v88 = *(int32_t *)(v1 + 144);
    int32_t * v92 = (int32_t *)(d + 148);
    v91 = v92;
    if (*v92 != 0) {
        goto lab_0x80d792a;
    } else {
        goto lab_0x80d7d00;
    }
  lab_0x80d7d00:
    // 0x80d7d00
    *v91 = *(int32_t *)(v1 + 148);
    int32_t * v93 = (int32_t *)(d + 152);
    int32_t * v94 = v93; // 0x80d7d14
    if (*v93 != 0) {
        goto lab_0x80d7938;
    } else {
        goto lab_0x80d7d20;
    }
  lab_0x80d792a:;
    int32_t * v95 = (int32_t *)(d + 152);
    v94 = v95;
    if (*v95 == 0) {
        goto lab_0x80d7d20;
    } else {
        goto lab_0x80d7938;
    }
  lab_0x80d7938:;
    int32_t * v96 = (int32_t *)(d + 156);
    int32_t * v97 = v96; // 0x80d7940
    if (*v96 == 0) {
        goto lab_0x80d7d40;
    } else {
        goto lab_0x80d7946;
    }
  lab_0x80d7d20:
    // 0x80d7d20
    *v94 = *(int32_t *)(v1 + 152);
    int32_t * v98 = (int32_t *)(d + 156);
    v97 = v98;
    if (*v98 != 0) {
        goto lab_0x80d7946;
    } else {
        goto lab_0x80d7d40;
    }
  lab_0x80d7d40:
    // 0x80d7d40
    *v97 = *(int32_t *)(v1 + 156);
    int32_t * v99 = (int32_t *)(d + 160);
    int32_t * v100 = v99; // 0x80d7d54
    if (*v99 != 0) {
        goto lab_0x80d7954;
    } else {
        goto lab_0x80d7d60;
    }
  lab_0x80d7946:;
    int32_t * v101 = (int32_t *)(d + 160);
    v100 = v101;
    if (*v101 == 0) {
        goto lab_0x80d7d60;
    } else {
        goto lab_0x80d7954;
    }
  lab_0x80d7954:;
    int32_t * v102 = (int32_t *)(d + 164);
    int32_t * v103 = v102; // 0x80d795c
    if (*v102 == 0) {
        goto lab_0x80d7d80;
    } else {
        goto lab_0x80d7962;
    }
  lab_0x80d7d60:
    // 0x80d7d60
    *v100 = *(int32_t *)(v1 + 160);
    int32_t * v104 = (int32_t *)(d + 164);
    v103 = v104;
    if (*v104 != 0) {
        goto lab_0x80d7962;
    } else {
        goto lab_0x80d7d80;
    }
  lab_0x80d7d80:
    // 0x80d7d80
    *v103 = *(int32_t *)(v1 + 164);
    int32_t * v105 = (int32_t *)(d + 168);
    int32_t * v106 = v105; // 0x80d7d94
    if (*v105 != 0) {
        goto lab_0x80d7970;
    } else {
        goto lab_0x80d7da0;
    }
  lab_0x80d7962:;
    int32_t * v107 = (int32_t *)(d + 168);
    v106 = v107;
    if (*v107 == 0) {
        goto lab_0x80d7da0;
    } else {
        goto lab_0x80d7970;
    }
  lab_0x80d7970:;
    int32_t * v108 = (int32_t *)(d + 172);
    int32_t * v109 = v108; // 0x80d7978
    if (*v108 == 0) {
        goto lab_0x80d7dc0;
    } else {
        goto lab_0x80d797e;
    }
  lab_0x80d7da0:
    // 0x80d7da0
    *v106 = *(int32_t *)(v1 + 168);
    int32_t * v110 = (int32_t *)(d + 172);
    v109 = v110;
    if (*v110 != 0) {
        goto lab_0x80d797e;
    } else {
        goto lab_0x80d7dc0;
    }
  lab_0x80d7dc0:
    // 0x80d7dc0
    *v109 = *(int32_t *)(v1 + 172);
    int32_t * v111 = (int32_t *)(d + 176);
    int32_t * v112 = v111; // 0x80d7dd4
    if (*v111 != 0) {
        goto lab_0x80d798c;
    } else {
        goto lab_0x80d7de0;
    }
  lab_0x80d797e:;
    int32_t * v113 = (int32_t *)(d + 176);
    v112 = v113;
    if (*v113 == 0) {
        goto lab_0x80d7de0;
    } else {
        goto lab_0x80d798c;
    }
  lab_0x80d798c:;
    int32_t * v114 = (int32_t *)(d + 180);
    int32_t * v115 = v114; // 0x80d7994
    if (*v114 == 0) {
        goto lab_0x80d7e00;
    } else {
        goto lab_0x80d799a;
    }
  lab_0x80d7de0:
    // 0x80d7de0
    *v112 = *(int32_t *)(v1 + 176);
    int32_t * v116 = (int32_t *)(d + 180);
    v115 = v116;
    if (*v116 != 0) {
        goto lab_0x80d799a;
    } else {
        goto lab_0x80d7e00;
    }
  lab_0x80d7e00:
    // 0x80d7e00
    *v115 = *(int32_t *)(v1 + 180);
    int32_t * v117 = (int32_t *)(d + 184);
    int32_t * v118 = v117; // 0x80d7e14
    if (*v117 != 0) {
        goto lab_0x80d79a8;
    } else {
        goto lab_0x80d7e20;
    }
  lab_0x80d799a:;
    int32_t * v119 = (int32_t *)(d + 184);
    v118 = v119;
    if (*v119 == 0) {
        goto lab_0x80d7e20;
    } else {
        goto lab_0x80d79a8;
    }
  lab_0x80d79a8:;
    int32_t * v120 = (int32_t *)(d + 188);
    int32_t * v121 = v120; // 0x80d79b0
    if (*v120 == 0) {
        goto lab_0x80d7e40;
    } else {
        goto lab_0x80d79b6;
    }
  lab_0x80d7e20:
    // 0x80d7e20
    *v118 = *(int32_t *)(v1 + 184);
    int32_t * v122 = (int32_t *)(d + 188);
    v121 = v122;
    if (*v122 != 0) {
        goto lab_0x80d79b6;
    } else {
        goto lab_0x80d7e40;
    }
  lab_0x80d7e40:
    // 0x80d7e40
    *v121 = *(int32_t *)(v1 + 188);
    int32_t * v123 = (int32_t *)(d + 192);
    int32_t * v124 = v123; // 0x80d7e54
    if (*v123 != 0) {
        goto lab_0x80d79c4;
    } else {
        goto lab_0x80d7e60;
    }
  lab_0x80d79b6:;
    int32_t * v125 = (int32_t *)(d + 192);
    v124 = v125;
    if (*v125 == 0) {
        goto lab_0x80d7e60;
    } else {
        goto lab_0x80d79c4;
    }
  lab_0x80d79c4:;
    int32_t * v126 = (int32_t *)(d + 196);
    int32_t * v127 = v126; // 0x80d79cc
    if (*v126 == 0) {
        goto lab_0x80d7e80;
    } else {
        goto lab_0x80d79d2;
    }
  lab_0x80d7e60:
    // 0x80d7e60
    *v124 = *(int32_t *)(v1 + 192);
    int32_t * v128 = (int32_t *)(d + 196);
    v127 = v128;
    if (*v128 != 0) {
        goto lab_0x80d79d2;
    } else {
        goto lab_0x80d7e80;
    }
  lab_0x80d7e80:
    // 0x80d7e80
    *v127 = *(int32_t *)(v1 + 196);
    goto lab_0x80d79d2;
  lab_0x80d79d2:;
    int32_t * v129 = (int32_t *)(d + 200); // 0x80d79d2
    if (*v129 == 0) {
        // 0x80d79f8
        *v129 = *(int32_t *)(v1 + 200);
    }
    int32_t * v130 = (int32_t *)(d + 204); // 0x80d79dc
    if (*v130 != 0) {
        // 0x80d79e6
        return;
    }
    // 0x80d79e8
    *v130 = *(int32_t *)(v1 + 204);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/toporouter.c
// Address range: 0x80da2c0 - 0x80da2dc
// Line range:    7497 - 7497
void register_toporouter_action_list(void) {
    // 0x80da2c0
    hid_register_actions((int32_t)&toporouter_action_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/dbus-pcbmain.c
// Address range: 0x80ebfe0 - 0x80ec09e
// Line range:    312 - 338
void pcb_dbus_connection_finish_with_mainloop(int32_t connection) {
    // 0x80ebfe0
    if (function_805fc48(connection, 0, 0, 0, 0, 0) == 0) {
        // 0x80ec052
        __fprintf_chk(g43, 1, "Not enough memory when cleaning up DBusConnection mainloop integration\n");
        return;
    }
    // 0x80ec01e
    if (function_8060118(connection, 0, 0, 0, 0, 0) != 0) {
        // 0x80ec078
        function_805f448(connection, 0, 0, 0);
        return;
    }
    // 0x80ec052
    __fprintf_chk(g43, 1, "Not enough memory when cleaning up DBusConnection mainloop integration\n");
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/dbus-pcbmain.c
// Address range: 0x80ec0a0 - 0x80ec17f
// Line range:    264 - 309
void pcb_dbus_connection_setup_with_mainloop(int32_t connection) {
    // 0x80ec0a0
    if (function_805fc48(connection, 0x80ec350, 0x80ec320, 0x80ec410, 0, 0) == 0) {
        // 0x80ec112
        __fprintf_chk(g43, 1, "Not enough memory to set up DBusConnection for use with PCB\n");
        return;
    }
    // 0x80ec0de
    if (function_8060118(connection, 0x80ec1e0, 0x80ec1b0, 0x80ec270, 0, 0) != 0) {
        // 0x80ec138
        function_805f448(connection, 0x80ebfd0, 0, 0);
        return;
    }
    // 0x80ec112
    __fprintf_chk(g43, 1, "Not enough memory to set up DBusConnection for use with PCB\n");
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/dbus.c
// Address range: 0x80ec500 - 0x80ec587
// Line range:    378 - 406
void pcb_dbus_finish(void) {
    // 0x80ec500
    int32_t v1; // bp-28, 0x80ec500
    function_805edd8(&v1);
    function_805f098(pcb_dbus_conn);
    function_8060908(pcb_dbus_conn, "/org/seul/geda/pcb");
    function_805ef38(pcb_dbus_conn, "org.seul.geda.pcb", &v1);
    function_8060718(&v1);
    pcb_dbus_connection_finish_with_mainloop(pcb_dbus_conn);
    function_80600e8(pcb_dbus_conn);
    function_805e978(pcb_dbus_conn);
    function_805ecf8();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/dbus.c
// Address range: 0x80ec590 - 0x80ec734
// Line range:    322 - 374
void pcb_dbus_setup(void) {
    int32_t v1 = 0x80ec4f0; // bp-52, 0x80ec59b
    int32_t v2; // bp-28, 0x80ec590
    function_805edd8(&v2);
    pcb_dbus_conn = function_805efc8(0, &v2);
    char * v3; // 0x80ec590
    if (function_805eff8(&v2) != 0) {
        // 0x80ec698
        __fprintf_chk(g43, 1, "pcb_dbus: DBus connection Error (%s)\n", v3);
        function_8060718(&v2);
    }
    // 0x80ec5f2
    if (pcb_dbus_conn == 0) {
        // 0x80ec64e
        return;
    }
    int32_t v4 = function_805f2b8(pcb_dbus_conn, "org.seul.geda.pcb", 2, &v2); // 0x80ec612
    if (function_805eff8(&v2) != 0) {
        // 0x80ec6d0
        __fprintf_chk(g43, 1, "pcb_dbus: DBus name error (%s)\n", v3);
        function_8060718(&v2);
    }
    if (v4 >= 3) {
        // 0x80ec631
        __fprintf_chk(g43, 1, "pcb_dbus: Couldn't gain ownership or queued ownership of the canonical DBus name\n");
        // 0x80ec64e
        return;
    }
    // 0x80ec658
    if (function_805fcf8(pcb_dbus_conn, "/org/seul/geda/pcb", &v1, 0) == 0) {
        // 0x80ec708
        __fprintf_chk(g43, 1, "pcb_dbus: Couldn't register DBUS handler for %s\n", "/org/seul/geda/pcb");
        return;
    }
    // 0x80ec684
    pcb_dbus_connection_setup_with_mainloop(pcb_dbus_conn);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/gtk/gtkhid-main.c
// Address range: 0x80ee4f0 - 0x80ee50c
// Line range:    2718 - 2718
void register_ghid_main_flag_list(void) {
    // 0x80ee4f0
    hid_register_flags((int32_t)&ghid_main_flag_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/gtk/gtkhid-main.c
// Address range: 0x80ee510 - 0x80ee52c
// Line range:    2699 - 2699
void register_ghid_main_action_list(void) {
    // 0x80ee510
    hid_register_actions((int32_t)&ghid_main_action_list, 24);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/gtk/gtkhid-main.c
// Address range: 0x80ee530 - 0x80ee57b
// Line range:    2733 - 7
void hid_gtk_init(void) {
    // 0x80ee530
    hid_register_hid((int32_t)&ghid_hid);
    apply_default_hid((int32_t)&ghid_extents, (int32_t)&ghid_hid);
    register_ghid_main_action_list();
    register_ghid_main_flag_list();
    register_ghid_netlist_action_list();
    register_ghid_attribute_list();
    register_gtk_topwindow_action_list();
    register_pcbmenu_attr();
    register_ghid_menu_action_list();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/gtk/gui-netlist-window.c
// Address range: 0x80fec50 - 0x80fec6c
// Line range:    1003 - 1003
void register_ghid_netlist_action_list(void) {
    // 0x80fec50
    hid_register_actions((int32_t)&ghid_netlist_action_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/gtk/gui-top-window.c
// Address range: 0x8103f00 - 0x8103f1c
// Line range:    3889 - 3889
void register_ghid_menu_action_list(void) {
    // 0x8103f00
    hid_register_actions((int32_t)&ghid_menu_action_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/gtk/gui-top-window.c
// Address range: 0x8103f20 - 0x8103f3c
// Line range:    2901 - 2901
void register_gtk_topwindow_action_list(void) {
    // 0x8103f20
    hid_register_actions((int32_t)&gtk_topwindow_action_list, 3);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/gtk/gui-top-window.c
// Address range: 0x8103f40 - 0x8103f5c
// Line range:    2910 - 2910
void register_pcbmenu_attr(void) {
    // 0x8103f40
    hid_register_attributes((int32_t)&pcbmenu_attr, 1);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/gtk/gui-top-window.c
// Address range: 0x8103f60 - 0x8103f7c
// Line range:    2605 - 2605
void register_ghid_attribute_list(void) {
    // 0x8103f60
    hid_register_attributes((int32_t)&ghid_attribute_list, 2);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/lpr/lpr.c
// Address range: 0x810dd30 - 0x810dd6c
// Line range:    172 - 177
void hid_lpr_init(void) {
    // 0x810dd30
    apply_default_hid((int32_t)&lpr_hid, (int32_t)&ps_hid);
    apply_default_hid((int32_t)&lpr_hid, 0);
    hid_register_hid((int32_t)&lpr_hid);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/bom/bom.c
// Address range: 0x810ee60 - 0x810ee88
// Line range:    595 - 599
void hid_bom_init(void) {
    // 0x810ee60
    apply_default_hid((int32_t)&bom_hid, 0);
    hid_register_hid((int32_t)&bom_hid);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/gerber/gerber.c
// Address range: 0x810ef10 - 0x810ef38
// Line range:    1130 - 1134
void hid_gerber_init(void) {
    // 0x810ef10
    apply_default_hid((int32_t)&gerber_hid, 0);
    hid_register_hid((int32_t)&gerber_hid);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/nelma/nelma.c
// Address range: 0x8111e90 - 0x8111eac
// Line range:    176 - 176
void register_nelma_attribute_list(void) {
    // 0x8111e90
    hid_register_attributes((int32_t)&nelma_attribute_list, 5);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/nelma/nelma.c
// Address range: 0x8111fc0 - 0x8111fec
// Line range:    1109 - 1
void hid_nelma_init(void) {
    // 0x8111fc0
    apply_default_hid((int32_t)&nelma_hid, 0);
    hid_register_hid((int32_t)&nelma_hid);
    register_nelma_attribute_list();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/png/png.c
// Address range: 0x8114220 - 0x811423c
// Line range:    213 - 213
void register_png_attribute_list(void) {
    // 0x8114220
    hid_register_attributes((int32_t)&png_attribute_list, 17);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/png/png.c
// Address range: 0x81144e0 - 0x811450c
// Line range:    1496 - 1
void hid_png_init(void) {
    // 0x81144e0
    apply_default_hid((int32_t)&png_hid, 0);
    hid_register_hid((int32_t)&png_hid);
    register_png_attribute_list();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/ps/ps.c
// Address range: 0x81172c0 - 0x81172dc
// Line range:    214 - 214
void register_ps_attribute_list(void) {
    // 0x81172c0
    hid_register_attributes((int32_t)&ps_attribute_list, 18);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/ps/ps.c
// Address range: 0x8117370 - 0x81173a6
// Line range:    1210 - 2
void hid_ps_init(void) {
    // 0x8117370
    apply_default_hid((int32_t)&ps_hid, 0);
    hid_register_hid((int32_t)&ps_hid);
    hid_eps_init();
    register_ps_attribute_list();
    register_eps_attribute_list();
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/ps/eps.c
// Address range: 0x8117f90 - 0x8117fb8
// Line range:    669 - 673
void hid_eps_init(void) {
    // 0x8117f90
    apply_default_hid((int32_t)&eps_hid, 0);
    hid_register_hid((int32_t)&eps_hid);
}

// From module:   /home/naftali/source/pcb-20091103/build_gtk/src/../../src/hid/ps/eps.c
// Address range: 0x81189c0 - 0x81189dc
// Line range:    69 - 69
void register_eps_attribute_list(void) {
    // 0x81189c0
    hid_register_attributes((int32_t)&eps_attribute_list, 5);
}

// Address range: 0x8139cfa - 0x8139cfe
int32_t __i686_get_pc_thunk_bx(int32_t a1, int32_t a2) {
    // 0x8139cfa
    int32_t result; // 0x8139cfa
    return result;
}

// --------------- Statically Linked Functions ----------------

// int32_t atexit(int32_t a1);

// --------------- Dynamically Linked Functions ---------------

// const unsigned short int ** __ctype_b_loc(void);
// int __cxa_atexit(void(* func)(void *), void * arg, void * dso_handle);
// int * __errno_location(void);
// int __fprintf_chk(FILE * restrict stream, int flag, const char * restrict format, ...);
// int __printf_chk(int flag, const char * restrict format, ...);
// char * __realpath_chk(const char * restrict name, char * restrict resolved, size_t resolvedlen);
// int __sprintf_chk(char * restrict s, int flag, size_t slen, const char * restrict format, ...);
// void __stack_chk_fail(void);
// char * __strcat_chk(char * restrict s, const char * restrict append, size_t slen);
// char * __strdup(const char * string);
// int __vfprintf_chk(FILE * restrict stream, int flag, const char * restrict format, _G_va_list ap);
// int __xstat(int ver, const char * filename, struct stat * stat_buf);
// int _IO_getc(_IO_FILE * fp);
// int _IO_putc(int c, _IO_FILE * fp);
// int _setjmp(struct __jmp_buf_tag env[1]);
// void abort(void);
// char * asctime(const struct tm * tp);
// double atan2(double, double);
// char * bind_textdomaincodeset(const char * domainname, const char * __codeset);
// char * bindtextdomain(const char * domainname, const char * dirname);
// void * calloc(size_t nmemb, size_t size);
// int chdir(const char * path);
// int closedir(DIR * dirp);
// int32_t dbus_bus_get_private(void);
// int32_t dbus_bus_release_name(void);
// int32_t dbus_bus_request_name(void);
// int32_t dbus_connection_close(void);
// int32_t dbus_connection_flush(void);
// int32_t dbus_connection_register_object_path(void);
// int32_t dbus_connection_set_dispatch_status_function(void);
// int32_t dbus_connection_set_timeout_functions(void);
// int32_t dbus_connection_set_watch_functions(void);
// int32_t dbus_connection_unref(void);
// int32_t dbus_connection_unregister_object_path(void);
// int32_t dbus_error_free(void);
// int32_t dbus_error_init(void);
// int32_t dbus_error_is_set(void);
// int32_t dbus_shutdown(void);
// char * dlerror(void);
// void * dlopen(const char * file, int mode);
// void * dlsym(void * restrict handle, const char * restrict name);
// void exit(int status);
// int fclose(FILE * stream);
// int ferror(FILE * stream);
// int fflush(FILE * stream);
// char * fgets(char * restrict s, int n, FILE * restrict stream);
// int fileno(FILE * stream);
// double floor(double);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// int fputc(int c, FILE * stream);
// int fputs(const char * restrict s, FILE * restrict stream);
// size_t fread(void * restrict ptr, size_t size, size_t n, FILE * restrict stream);
// void free(void * ptr);
// size_t fwrite(const void * restrict ptr, size_t size, size_t n, FILE * restrict s);
// char * getcwd(char * buf, size_t size);
// char * getenv(const char * name);
// struct hostent * gethostbyname(const char * name);
// int gethostname(char * name, size_t len);
// __pid_t getpid(void);
// struct passwd * getpwuid(__uid_t uid);
// __uid_t getuid(void);
// int isatty(int fd);
// struct tm * localtime(const time_t * timer);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// DIR * opendir(const char * name);
// int pclose(FILE * stream);
// FILE * popen(const char * command, const char * modes);
// void qsort(void * base, size_t nmemb, size_t size, __compar_fn_t compar);
// struct dirent * readdir(DIR * dirp);
// void * realloc(void * ptr, size_t size);
// int regcomp(regex_t * restrict preg, const char * restrict pattern, int cflags);
// size_t regerror(int errcode, const regex_t * restrict preg, char * restrict errbuf, size_t errbuf_size);
// int regexec(const regex_t * restrict preg, const char * restrict string, size_t nmatch, regmatch_t pmatch[__restrict_arr], int eflags);
// void regfree(regex_t * preg);
// void setbuf(FILE * restrict stream, char * restrict buf);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int32_t sincos(void);
// int sscanf(const char * restrict s, const char * restrict format, ...);
// int32_t sscanf2(void);
// int strcasecmp(const char * s1, const char * s2);
// char * strcat(char * restrict dest, const char * restrict src);
// char * strchr(char * s, int c);
// int strcmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// char * strerror(int errnum);
// size_t strlen(const char * s);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// char * strrchr(char * s, int c);
// double strtod(const char * restrict nptr, char ** restrict endptr);
// char * strtok(char * restrict s, const char * restrict delim);
// long int strtol(const char * restrict nptr, char ** restrict endptr, int base);
// time_t time(time_t * timer);
// int unlink(const char * name);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.5)
// Detected functions: 321

